hi everybody
uh welcome to the last lecture of 6006
last lecture we talked about
summing up this class and talking about
future courses in the department
that use this material um
just as a pointer to some of those
classes i have a little slide here i
didn't get to
uh at the last lecture talking about
kind of what i was talking about the end
of last lecture about
different models uh different
specialized classes
on different aspects of o6 material
for example more graph stuff
different models of computation
randomness
uh complexity all of these things have
their own specialized classes
in the department uh as well as a lot of
applications
uh for this material in subjects like
biology cryptography
and in particular for your instructors
uh the the realm of graphics and
geometry
okay so all of all of your instructors
this term happen to be
geometers and have uh be interested in
geometry related problems um
me in particular i didn't start out in
computer science
i started out in mechanical engineering
uh
and the thing that was my passion um
coming into mit
was origami and so here's a couple of
uh pieces that uh i designed um
origami pieces one square sheet of paper
without cutting here's a
a lobster and here's a
you know a copyrighted dinosaur from a
particular movie of the year that i
designed it
um i
uh when i was young in high school i
started designing my own origami models
and what i didn't realize was the
procedures
that i went about designing these models
was
actually algorithms right i just didn't
have the mathematical language
to to understand exactly what i was
doing but i could gain some intuition as
an origami artist
and design these things by using some of
those algorithmic techniques it wasn't
until
grad school as a mechanical engineer
that
i started talking
with uh our other instructor here
professor domain
about uh using algorithms in computer
science
to design not just origami
uh which we both do but also uh
folded structures that can be used for
mechanical applications like space
flight um uh deployable bridges
in in like um in times when you
you can't you need a temporary
bridge or shelter or something like that
deployable structures
where you might need to make folded
structures transformable structures
that can have different applications
for different purposes need to
reconfigure the dream being that
we have these powerful devices in our
pockets right now
cell phones uh which uh you know are
really powerful because we can
reconfigure
the bits in them to make software of all
different kinds right
there's a there's a exponential number
of different programs that we can write
and that's part of why you're here is to
write the next best one
right so that's how to how to make uh
kind of a universal a device uh
at the electronic level what if we could
do that
in a material from a material standpoint
what if i could
reprogram the matter in my phone so that
not only
uh could i reprogram the app that's on
your phone
but instead of having the say the iphone
10 or whatever that you have and and you
want to go buy the iphone 11 instead you
you download a software app that then
reconfigures the matter in your phone it
folds or reconfigures
into the next generation iphone
you you don't have to throw away that
old one you can essentially recycle the
material that you have
uh to potentially uh save material save
cost
and be better for the environment
potentially so uh
i started moving into computer science
because i found that it was
a really good way to model the world and
solve some really interesting problems
uh about folding that i i really enjoyed
so um the the three of us today
are going to spend some time talking a
little bit about how we can use
algorithms
606 material and beyond in our own
research
and we're going to start off with
professor domain
and then professor solomon
sweet so why don't i just jump into
uh computational origami and geometric
folding algorithms is sort of a broader
umbrella for folding
related things which is encapsulated by
this class 6.849
which is happening next fall so you
should all take it
06 should be a reasonable background
and in general we're interested in two
kinds of problems one
the big one is origami design or general
folding design where you have some
specifications of what you'd like to
build
in this case i wanted to make a logo for
and i imagined extruding that text
into third third dimension and then i
wanted an algorithm
to figure tell me how to fold that
structure and so there is an algorithm
which i'll talk about in a moment that
gives you a crease pattern and then
currently you fold it by hand the dream
is we'll eventually have folding
machines that do it all for us
um and so that's the origami design
where you go from the
the target shape back to the
um to the crease pattern the reverse
direction is sort of foldability if i
gave you a structure
like this and i wanted to know does it
fold
that's a problem we call foldability in
general
a class of problems and sadly most of
those problems are np hard
jason and i proved that foldability is
hard for a general given a crease
pattern like that
telling you whether it folds into
anything it turns out to be np hard so
that's
bad news so we focus a lot on the design
problem because that
actually tends to be easier we can solve
it with algorithms like
that one you're seeing um and so
a long time ago we proved that you can
fold everything
if i give you a square piece of paper
and you take
any polygon you want to make or maybe
the paper's white on one side black on
the other
you you want to fold some two color
pattern like a zebra or in general some
three-dimensional surface
like these guys there is a way to fold
it from a large enough square of paper
and it's actually really easy to prove
that with an algorithm i have
a sketch of the two pages of proof that
we go over in 6849
but i'll just hand wave a little bit uh
if you take a piece of paper
like my lecture notes here the first
thing you do
is fold it down into a very long narrow
strip
much longer and narrower than this one
wasting most of the material
and then you take your strip and you
just figure out how to
turn it in some general way and then you
just sort of zigzag back and forth along
the surface
so it's very cool in that you can prove
with an algorithm in a very short amount
of time
to someone you can actually fold
everything of course it's a terrible
folding because in the very first step
we throw away
all but epsilon of the material but it's
a starting point and then that was back
in the 90s late 90s
one of the first results in
computational origami and
in modern times we look for better
algorithms that are more efficient that
try to minimize the scale factor from
how big of a piece of paper do i start
from
to how big of a model do i get um and
one of the cool ways
these days which was invented by
tomihirotachi and then analyzed by the
two of us
it's called orgamizer it's free software
you take a 3d model
and you can it makes it into a crease
pattern that you fold from a square in
this case it uses 22 percent of the area
which is pretty good
um similar to these guys
in terms of efficiency but very very
different kind of folding
than what you would get from more
traditional origami design which uses
different algorithms which i'm not going
to talk about but you should take the
class jason gives a lecture in the class
that you can
learn from him but the you know the
vision is we can take any sheet of
material that can hold a crease
like this sheet of steel that tomohiro
is folding i was cut
by a big laser cutter at mit and this is
him in this data center several years
ago
folding it into a steel bunny
and so this is like a totally new way to
manufacture
3d objects and you can make particularly
interesting objects that
either collapse flat for uh
transportation
uh or transform like jason was talking
about
but i'm just giving you a flavor uh the
i think the first paper we wrote
together
was on maize folding so this is an
example of folding
a maze from a rectangle of paper and you
can all
try this out you just
google for our maze folder you can
generate a random maze
and this 3d structure can be folded
from this crease pattern that's a really
hard one so
try maybe try something smaller you can
also write your favorite message
and fold this maze extruded graph
from this crease pattern might want to
start with something smaller
but that's the general idea and it's
actually quite easy to prove this
algorithmically
if you have a really good origamis like
jason on your team
what you do is design how to fold each
type of vertex this is just a graph on a
grid
so there are you know some constant
number of different ways that each
vertex could look it could be degree
four it could be degree three
uh in as a t it could be degree two
either as a turn or a straight
and you design little gadgets little
crease patterns that fold into each of
those little structures
and if you can do it in a way that these
boundaries are compatible
then to fold the whole thing you just
sort of glue together those crease
patterns and that's how that software
works
and so that was this is particularly
interesting because you can fold an
arbitrarily complicated graph
uh arbitrarily complicated maze m by n
with a
constant scale factor as long as the
height that you're extruding that maze
is constant
then this is one family of shapes we
know how to fold really well
in general we're trying to understand
you know what makes
this lobster a nice shape in that it can
be represented with a not too large
piece of paper and we don't have general
answers to that
that problem i think that was a
whirlwind tour of computational origami
i also play a lot in the
in algorithmic sculpture one of the
leading edges in comp
in origami and origami math is
understanding how curved creases work
and one of our favorite models is this
one where you fold concentric circles
alternating mountain and valley
cut a circular hole out and it folds
into this kind of
pringle shape as a nice physics
equilibrium thing and then you can turn
it into fun sculptures like
this these are done with my dad martin
domain
who's also here at mit or this guy this
paper has been printed with a pattern
according to
getting burned by glass and then it gets
folded and then put inside
glass also made here at mit
uh and so we use sculpture to try to
explore and understand intuitively how
curve creases work and then we get
better and better
understanding of the mathematics of even
we don't even know whether this surface
exists whether it's possible to fold in
this way although
getting close to proving it uh
so that was sort of in the top level of
this
hierarchy computational geometry is a
bigger umbrella
which is represented by another class
6850 that's being taught this term
and then i talked about geometric
folding within that branch
let me briefly tell you about another
world of geometry very different
in terms of model of computation oh i'm
jumped ahead a little bit
uh rewind let me show you one more fun
demo
which uh if i find my scissors
so if i take a rectangle of paper and i
fold it flat
and make one straight cut what shapes
can i get
this is called the fold and cut problem
hundreds of years old
here for example i get a
swan here i get
one straight cut i unfold and get
an angelfish tough audience
today i keep going i've seen all these
before
this is this one is um a particularly
difficult one to fold
only full and to cut yeah
okay hopefully that works well
this is
the mit logo
yeah go mit all right so
um that's that's actually the first
problem i worked on in computational
origami it's a lot of fun
and there's a really interesting
algorithm here also for computing
the crease pattern how to fold your
piece of paper to align
in fact any graph you draw on a piece of
paper
you can align all those edges and
nothing else so you cut along the line
you get exactly what you want
cool all right now i want to talk about
something completely different which is
self-assembly
a fun thing you can do with dna which we
all have
just pick out some cool dna strands and
design them in a clever way so they fit
together to form a kind of square
with dangling ends which i'll call glues
and each of those dangling ends can have
a particular pattern and only
identical or complementary patterns will
attach to each other
and so you can use this to design your
own self-assembling system
like biology does but engineered for
example to build a computer this is an
example of taking a bunch of these
square tiles
and building a binary counter this thing
is roughly counting in binary
along the diagonal it's a little skewed
so it's hard to see
but the general model is
you have
squares this is sort of the
computational model
with four different glues and you can
build any square you want
but you don't have very many of these
different glues ideally
and then if you have two tiles with
complementary glues they'll want to
match together but it depends how strong
this glue
is how much affinity there is for how
long those dna dangling ends are
and also the temperature of your system
if you have really high temperature
nothing will stick together
low temperature things will stick
together even if they're not supposed to
and so you can if you tune your system
really well
you can design uh a system so that maybe
these guys
these glues are really strong and so
let's
i don't know right e here eric
and so these tiles will always glue
together but only when all three of
these
are glued together can this tile which
has c
complement and f complement
then it will if you set the temperatures
just right only because both of these
edges match
will this style be able to come in and
that's the basis for that
building that binary counter and so this
is a very different model of computation
from what we're used to in this class
where you think of instructions and they
run one at a time here the
model of computation is geometric it's
these squares that are just floating
around
and gluing together and so your program
at any moment is some
conglomerate of squares and so i just
wanted to mention it because it's a
really fun model
you can prove cool things in this model
like how to build any shape
by a sequence of pores mixings between
tiles
that you can execute in parallel and so
it only takes log n time
in parallel steps a linear number of
different mix
operations to make an arbitrary shape
even using
a constant number of different glues
which is
cool and may be practical
you can also use it to build a
replicator where you're given an object
like this
that you don't know the shape of like we
don't know whether this exists
and we can't model it mathematically
very well and you would stick it in a
vat and all these tiles would attach and
basically build a mold
and then start photocopying in 3d that
mold and you can build that
with a system with only two steps i
believe
and a constant number of tile types and
it does all of that
in this model in constant time in
reality you'd have to feed this machine
and wait for it to print out all these
things and and these experiments take
hours if not days to run but in theory
it's really cool and you get some really
fun models and very general results
you can also use it to build a
miniaturizer or a magnifier and
other other fun stuff okay
um so that was a brief tour of
computational geometry
i work mostly in four different areas of
algorithms
geometry data structures graph
algorithms and what i call recreational
algorithms
i think i made up that term and
let's go into data structures which is
represented by this class 6851
all of the classes i mentioned have
online video lectures so especially for
those
watching at home on opencourseware most
of these classes are on opencourseware
and if not
they're on my webpage so 6851 advanced
data structures
is an extension of the sorts of data
structures you've seen in
here in 06 and the ones you will see in
i thought i'd give you a flavor of one
such result
which is
a problem we've seen in this class
done better so suppose you want to store
a dynamic ordered set
so this is the set interface dynamic in
the sense that i have
insert and delete
and ordered in the sense that i want to
support find next and finds previous
okay so exactly which subset of the set
interface you choose
influences what what data structure
you've seen we've seen for dynamic sets
you want to use
hashing if you don't care about find
next if you just care about
find then hashing is great constant
expected
you can prove stronger things about
hashing we do in that class
but if you want dynamic and ordered
you cannot do constant time for
operation you can prove that
which is cool but and so what data
structure have we seen that solves this
problem
pretty well set avl trees which solve
everything
in log n so log n
one competitor
yeah i am interested in this in the
word ram model
which is the only model we've seen in
this class this happens to work in a
stronger model
um and we can do better than log n
in the following it'll take me a while
before i get better but here's at least
a different bound we can get
log w uh this is via a structure called
venom nubos
who's a person avl is two people
ben under both i've actually met so log
w
remember w is our word size so this is a
bit of a weird running time it's great
if w is like log n
then this is log log n and we know w is
at least log n but it could be bigger
we don't really have a sense of how big
w can get maybe it's even
n maybe it's big and then these are the
same maybe it's bigger than n
and then this is maybe worse but for
most w's this is actually
pretty good and indeed optimal
but it's not strictly better in any
sense yet on the other hand
there's another data structure which
runs in log n divided by log w
this is called fusion trees this was
invented around the time that cold
fusion was in the news and so
they wanted data structures to represent
and so we can achieve this bound or we
can achieve this bound
and this bound as good is if w is large
this bound is good if w is small and so
you can always take the min
of the two whatever's better and in
particular
the min
uh the min of those two things
is at most i think it's square root log
n over log log n
if you want to bound just in terms of n
then the crossover point between these
two is this place and so you're always
at most this which is
quite a bit better than the log n of avl
we've got a square root
and we've got a slight thing in the
denominator pretty tiny
but the big thing is the square root and
that's kind of cool and it turns out
that's
pretty much optimal in terms of an n
bound this is optimal
the min of these two in general is
roughly optimal up to like log log terms
i for fun
i threw up the actual formula for the
right bound
uh which is tight up to constant factors
there's matching upper and lower bounds
which we talk about it's min of three
things
four things uh including log of w over a
divided by log of log w over a over log
of log n over a
uh that's the last term that i just read
is messy
uh surprisingly that is the right answer
for this very
particular problem a very natural
problem
uh a is the log of the space you're
using
so it's the address size uh good
question
um if you throw so it depends if you
have a polynomial space data structure
then basically
these are optimal and this is
generalizing to beyond that
maybe you have a little bit more than
polynomial space
cool um so that's data structures
i'm going to jump ahead to graph
algorithms
which if you want to take this class i
recommend a time travel device
go back to fall 2011 it may never get
taught again but
it has videos so you can watch instead
of time traveling
if you don't want to watch it live you
can just watch the recorded version
it was taught by a bunch of postdocs
that were here uh and and
myself uh and so what i like to do with
graphs
is the world of planar graphs or near
planar graphs
so we've talked a lot about this class
algorithms that work for arbitrary
graphs
and the algorithms we've seen in this
class are pretty much the best we know
for a lot of problems for
for arbitrary graphs but if your graph
has some structure like
it's a road network and there aren't too
many overpasses you can usually
draw these graphs in the plane without
crossings that's the meaning of planar
maybe not exactly maybe just a few
crossings there's a generalization of
this which i won't get into
but let's just think about planar graphs
planar graphs have some nice features
like
they always have a linear number of
edges they're always sparse
so you can immediately plug that into
our existing bounds but even so you know
dijkstra
uh this would take in this such a graph
would take
v log v time for planar graphs you can
do
the equivalent of dijkstra meaning i can
compute single source shortest paths
with non-negative edge weights
in linear time
no log okay not that impressive but
remove a log more impressive is we can
do the equivalent of bellman ford
uh which is single source shortest paths
with arbitrary edge weights
in a planar graph in uh
sometime almost linear time
v log squared v over
log log v okay so there's a couple log
factors here
but for the almost linear time whereas
bellman ford would take v squared time
so this is a huge improvement over what
we've seen in the class
these are quite complicated algorithms
but they're covered in that class if
you're interested in them
then the the area i work in a lot is
approximation algorithms for
planar graphs and let me just give you a
fun
flavor using something we know which is
uh breadth first search
so breadth research you can think of as
building these sort of rings around
a single root node
and there's this general approach as
introduced by baker in 1994
we've used for lots of different
problems you want to solve some
np hard problem on on a graph so just
run
breadth first search from an arbitrary
vertex and decompose your graph into
these layers
you could number them you know zero one
two
three these are the levels
and let's just like delete some of those
layers let's say let's delete every
fourth layer
so maybe i delete this one i delete all
the vertices in that layer
and then i delete all the things in
layer 8 and layer 12
and so on guessing
i don't know which one to start with but
from i'll just try them all
and then i delete every fourth layer
after that
so i've deleted on average about a
quarter of the graph
and it turns out for a lot of problems
that you care about
like choosing where to place fire
stations in this graph to minimize
uh you know travel time for if there's a
fire somewhere in the graph
this happens you know fires and graphs
then
this will only hurt your solution by
like a factor
of uh one plus a quarter
uh so you'll get a solution that's uh
within
25 of the optimal for a lot of problems
um and uh
that works for any value of four so i
could do it for ten
and then i'd get within ten percent of
the optimal solution
uh okay but how do i actually solve the
problem once i delete every fourth
layer well then your graph has this
extra special structure
which is a constant number of layers
let's say a constant number of breadth
first search layers if you just look at
this portion this connected component
or this connected component in here you
can
your graph is almost like a cycle
it's like four cycles kind of stacked up
together with some connections between
them
and it turns out that's something you
can solve with very fancy dynamic
programming
like the stuff we've seen before in this
class which focuses on just a single
path or a single cycle
if you just have a constant number of
cycles with more work you can still do
everything in polynomial time
and so this is a very general approach
for getting
arbitrarily good approximation
algorithms we call these one plus
epsilon approximation for any epsilon
but the larger the epsilon the more time
you take it's something like
two to the order one over epsilon times
polynomial and n so as long as epsilon's
constant this is polynomial time
this is called a p-tess
anyway those graph algorithms last topic
is recreational algorithms which is
maybe best encompassed by this class
6892 is its latest name it changes names
every once in a while
and i mentioned it in the hardness
complexity lecture because this class is
all about
hardness proofs analyzing fun games and
puzzles we saw the tetris
np hardness in that lecture but you can
also prove
super mario brothers is hard or portal
is hard or mario kart is hard
or the witness some modern video game is
hard
or one of our latest results is that
recursed that game in the top right
is undecidable there's no algorithm to
play that game perfectly
so and you can even download the level
and an example of the level and play it
if you
if you dare um so
uh that's a lot of we have a lot of fun
in that world
of hardness of different games and
puzzles
uh where do i want to go next uh
okay next topic is balloon twisting
totally different
this is recreational but not about
hardness so this is an octahedron
twisted from one balloon i mean another
one
on a stick and so each of these is made
from one balloon what graphs can you
make
for one balloon well you should read our
paper
and you can characterize how many
balloons you need to make each
each polyhedron and some of these
problems are np hard
and it's a lot of fun
[Music]
cool i think that's the end of the
slides uh the last thing i wanted to
show you
is a
problem a puzzle slash magic trick comes
from the puzzle world
called the picture hanging problem so
imagine you have a picture
you want to hang it on a wall so you
invested in some nice rope
and you hang it and then if the on a
nail
if the nail falls out the picture falls
and you're set
so you invest in two nails like i have
here
and maybe you hang your picture on both
those nails now if one of the nails
falls out you still have a crookedly
hung picture
the other nail falls out okay it's gone
i want to hang a picture on two nails
such that if i remove either nail the
picture falls so jason pick a nail left
or right
left we remove make sure this doesn't
fall off
and boom the picture falls same wrapping
you can check you can rewind the video
make sure i did the same wrapping
okay take out the right one good choice
uh
then also the picture false
uh and so this is a classic puzzle but
you can generalize it so let me do it to
for three nails which is all i have here
this nail sagging a little bit uh y
x and y inverse x inverse okay i think
that's right
uh so this is one way to hang a picture
on three nails such as if i remove any
of the nails
picture falls uh just justin uh one two
or three
two two okay
yeah i wanna get out of the way make
sure make sure i don't go
over the edge here
yeah it's a lot easier to make this one
work
but you can see boom picture falls there
and of course
imagine infinite gravity and the picture
falls tada
and so you can generalize this to do
essentially any
it's called a monotone boolean function
on any set of nails
i mean you can make any subset of the
nails cause the picture to fall
and any collection of subsets of nails
to make it fall of course if you remove
more nails it's still going to fall
that's the monotone sense but otherwise
you can do an arbitrary
pattern which is fun that's actually
result with ron rivest and a bunch of
other
other people um i think
i'm approximately on time so that was a
quick tour
and there are obviously various classes
here you can take
6892 the hardness class was just offered
last semester so probably won't be for a
while
all these classes are online watch the
videos feel free to ask me questions
and now we have justin i left you space
here
for your outline
you don't have to
but i'll put your name out thank you
so jess justin is also a jabiter yeah
we've got a lot of geometry people in
double six this semester thank you
okay you know it's like i can't help but
share that on our
instructor chat eric was texting that he
was going to be
he was somehow nervous that the applied
guy would have all the like the cool
stuff to show off
and now i feel totally boring uh
right yeah so yeah we have three
different geometry instructors uh
in in this class we have many different
flavors of geometry that are kind of
represented in this this room here from
mechanical engineering to
theory plus lots of other cool stuff to
uh whatever it is that i do
um all right so i'm a professor also
from brazil and lead a group that
studies
slightly more applied geometry problems
in some sense
in seasonal we kind of cross a lot of
boundaries actually closer to the math
department than to the theory group in
computer science
which i would argue is largely a
historical artifact rather than anything
interesting about computer science or
math um
so continuing in our whirlwind tour of
interesting geometry classes here at mit
uh i have some more fun things to to add
to the list and we'll introduce some of
the ideas in the next couple slides here
uh so uh normally every fall i teach
uh which is the introduction to computer
graphics course in fact my
background was was working in an
animation studio for a little bit of
time and and
uh got one movie credit out of it until
they changed the standards for movie
credits and then that stopped happening
uh but but in any event uh if you watch
what's that movie up with the old man
if you hit pause at just the right
moment you can find me right above the
list of babies that were born during
uh production uh but in any event um
although computer graphics might not
sound like an algorithmic discipline
i'll try to convince you guys that
in some sense you can take just about
anybody in our department have them
teach 606 and give a similar talk that
like
the material that you've encountered in
this course is going to be relevant to
your life
uh the other course that i teach that
might be of interest uh
and actually is a little more
theoretically flavored uh that i teach
is a six eight three eight
so since eric so kindly put my board my
name on the board here i guess i can
draw a picture
so the main object of interest in six
eight three eight
is a particular thing called a
simplicial complex
so um usually uh in 606 we spend a lot
of time thinking about graphs
so let me draw you a graph so i'm going
to take a square
and subdivide it and now let's say i put
edges diagonally
like that now
and pick from the most important thing
is a bunch of notes can
connect my edges in fact if i took this
edge and i like moved it down or
something it would be the same graph
uh but of course in a lot of uh computer
graphics applications this thing also
looks an awful lot like a square uh and
the reason
is that of course the graph here
contains triangles inside of it
uh and so for instance um maybe
i think of my graph as a collection of
vertices clutching edges this is the
sort of notation we've seen before
and then i add a third thing to my trip
uh to my
description which is a set of triplets
uh that's a set of triangles here
right and we can take a lot of the
algorithms that we've talked about in
this class and extend it to this case so
for example
um here's a deceptively annoying one uh
let's say that i want the shortest path
between two vertices on my graph
yeah so we certainly have learned
dijkstra's algorithm as one technique to
do that
and indeed common practice in computer
graphics which is shameful
uh is on your triangle mesh if you want
the shortest path between two vertices
run dijkstra's algorithm on the edges
and let's see if that works really quick
so let's say that i want the shortest
path between
and by the way i'm going to assume the
lengths of my edges are like the lengths
as i've drawn them on the board here so
it's like 1
1 square root of 2. okay so let's say i
want the shortest path between the
bottom left and the upper right
for run dijkstra's algorithm we're in
good shape right we could uh you can
i'll let you do the computations at home
you'll get the path
that is these two edges but here's a
really annoying thing
let's say instead i wanted the shortest
path from the upper
left to the lower right if i run
dijkstra's algorithm on this
triangulated square
what's going to be the shortest path
yeah in fact there's a bunch of them
one of them might go all the way down
and then all the way to the right
what's the length of this path one two
three four
is that the length of the shortest path
well probably not well we'd like our
shortest path
to do something like that but graphs
don't know how to talk to
triangles and this is going to be a
problem
in fact it wasn't until
history terms that we were able to kind
of work out the correct
algorithm for a shortness of a
triangulated domain like this um
that's the runtime that we would expect
this is called uh mnp
i'm guessing eric and jason could do a
better job describing it than i can
but the basic idea of the mmp algorithm
actually is a really
happens to be a nice extension of the
way that we taught uh dijkstra's
algorithm in 6.06 because they really do
keep track of these sort of level sets
of the distance function
but now the level sets have to like oops
i have to window an
edge like that when i uh compute short
its path which is a giant headache
this is one of these algorithms that was
known in theory about 10 years before
anybody bothered to implement it in a
way that they could convince
them themselves really random n log n
time uh and nowadays is a cottage
industry in
in computer graphics research papers to
implement this and then speed it up in
different ways and
sadly the reality is that a different
number we cover in 6838 called fast
marching which doesn't actually give you
the shortest path but some approximation
thereof
uh is faster easier to use and basically
indistinguishable um so in any event um
in 683 we kind of have an interesting
we'll talk about a lot of algorithms
that look like what we've done
in whatever this class it's uh 6.006
um but at the same time start to have a
more geometric flavor and we
don't worry quite as much about uh so in
our computation model oftentimes we're
kind of okay with real numbers because
that's not where
the headache is and of course when you
write your code in this class you use
double precision floating point
if you're more responsible like in in
jason's previous lecture you should
probably keep track of
the number of operations to make sure
that your error is bounded but no i'm
not sure that we
really bother with that um in any event
this allows us to kind of have two
different mindsets right there's one
mindset which is discreet
there's another mindset which is smooth
right so we think about
understanding geometry like these
triangulated domains as an approximation
of a smooth surface
and then we might want to do stuff like
compute curvature and so on which is
really associated with computing
derivatives
which of course we don't have on these
kinds of special objects
and that leads to this really fun area
of math computer science
whatever called discrete differential
geometry which sounds like a
contradiction in terms
um and it's something that we cover in
quite some detail in this course so we
build up
all of calculus the only calculations
you're allowed to do
are on the vertices edges and triangles
of a triangle mesh
uh and get pretty far including some
some constructions of topology like the
durant complex and so on
i would argue actually if you take our
course and then the differential
geometry courses in that department
somehow some of the indices and
headaches that you often encounter
in that world are much more concrete
when you try to make them work on a mesh
in any event i think i've already spent
all of my time i can tell you a little
bit about uh
research uh in our group um so i
leave kind of a weird extremely broad
group where some of our students are
essentially theory students
what's your keyboard i'm sorry it was a
reflex
um but it was fast uh all right so
we have some students whose background
is not other ones that like we're in
autonomous driving industry and decided
to come back and
uh uh work in research and so
because of that we have this extremely
broad set of research problems
everything from
the sort of classic machine learning
problems you might encounter in
in geometry world like if i have a
self-driving car and i want to identify
pedestrians and
other cars on the road in an efficient
and accurate fashion
um by the way part of that is machine
learning and deep
whatever but there's another part which
is algorithms because actually what
comes into your lidar scanner
is on the order of like thousands of
points and some
minuscule fraction of time and time
complexity
of your learning algorithm actually is
really critical to get right
and something that there are a lot of
open problems right now because it's
really not compatible with the hardware
architecture that
these cars often use uh we also look at
geometry problems like if i give you
data can i find a geometric structure
uh so a sort of classic example of
natural language processing
where we use words like near and far you
know in terms of semantics and meaning
all the time
the question is can we actually find an
embedding of our
you know word data into a geometric
space to facilitate the kind of
statistical algorithms that we care
about
and of course we apply geometry to lots
of practical problems everything from
meshing and scientific computing which i
think is sort of a classic
uh one in fact i think we're the first
group that sort of enumerated all the
cool things that they happened to
draw matches um which is the sort of
bottom finger here i should share this
with you because there's some fun things
to look at there
um to uh other practical problems like
taking a
you know eric took a zebra and folded it
we can take a zebra and
move its texture onto a cat or a pig or
actually
off the side of the screen but if you
download the paper is it all for the 3d
scan
of one of my gratitude um so
in any event in uh my five minutes
remaining here i thought
i'd dig into a little bit of a detail of
two or maybe one application depending
on when jason and eric get bored uh
uh and essentially my message for you
guys is of course
you know it's not broken i'm not really
a central
cs theory group member here at mit uh
but unfortunately for you guys 6.06 is
unavoidable even if you want to go into
deep learning statistics whatever data
science
you're going to encounter the material
that you've seen in this course and in
fact it's really
the bread and butter of just about
everything everybody does here in this
data center
so i thought i'd give you two quick
examples one of which lifted from my
teaching one for my research
so uh if you continue with me next fall
uh we'll teach
6837 which is the intro to computer
graphics course
one thing that's always amazing to
students is these algorithms that
produce these
images can fit in about 10 20 lines of
code um so a really
this is totally facetious because if you
want those beautiful images and you use
those 20 lines of code
you'll be waiting until the universe to
actually compute these things but in any
event uh one nice one for rendering so
drawing a bunch of shapes on your screen
something called ray casting
um or it's better known cousin ray
tracing
typically the difference is whether your
rays can bounce off of the surface and
have a secondary thing
uh right so here's the raycasting
algorithm let's say i have a scene
built out of spheres and cues i'm gonna
have a for loop over every pixel
on the computer screen for every pixel i
got to discover what color that should
be
so i shoot a ray from my eyeball through
that pixel
and find the first object that it runs
into
it's not so hard to intersect a line
with a sphere or a line in the cube
so what is that algorithm well i've
given it to you on the screen here
not too bad to think about and i think
you guys are all extremely well equipped
to analyze the runtime of this
which is roughly the uh number of pixels
times the number of objects right
because for every pixel
i gotta decide what object the ray out
of my eyeball hits first
so i need a for loop over every object
make sense
cool so let's uh look at sort of a basic
uh rendering
problem in fact eric already uh secretly
stuck this one
in here so there's a very famous 3d
model called the stanford bunny
um the stanford bunny is actually a
great example of a simplicial complex
it's
in fact a manifold one triangulated
surface
um actually i'm not sure it's manifold
in its original
form but but usually it is uh and this
uh innocent looking
extremely famous 3d model uh is actually
quite uh pernicious
it's composed of 69 000
triangles and if i wanted 1080p like you
know a high def
uh rendering of my triangle then of
course there's there's two million
pixels on the screen
so if we look at our big o expression
roughly our computation time scales like
the product of those two big numbers
uh so just to render this ugly gray
bunny it takes me
a pretty large amount of time yeah and
in fact uh the real
by the way the bunny is like this famous
test case in computer graphics so if you
take my class you'll be rendering
bunnies all day
um you know the reality is we don't want
just like gray flat shaded bunnies we
want
bunnies that are transparent and
reflecting stuff
and you know i shoot my bunny with a
bullet and it shatters into a million
pieces and all these cool things
so of course that raycasting algorithm
and each one of these new graphics
features i add
only adds the time complexity of of the
technique uh that i implemented
so pretty quickly and indeed if you
write your own ray tracer at home which
i strongly encourage you to do
what you'll discover uh is that a
teleslope would be the
technical phrase uh so what is our way
out of this well
if you take uh a37 you'll see that our
way out of these problems and graphics
is data structures and algorithms
it's completely unavoidable so for
instance obviously we spent
quite a bit of time in this course uh
talking about avl trees
uh in age seven we'll spend a big chunk
of our tours talking about space
partitioning trees
uh so here i've actually forgot what
kind of tree this
is i think it's a kg tree
doesn't matter um in any event uh one
thing i could do is take all the
uh triangles in my bunny and i could put
the entire bunny in a giant cube
right then with the property that the
cube is outside of my let's say i
cast a ray and the ray doesn't touch the
cube
can the ray touch the bunny no right
zing's right pass it
right so suddenly i just saved myself a
lot of computation time right i don't
have to iterate over all the triangles
inside of the bunny to see whether they
hit the ray or not because i already
convinced myself by this conservative
test
that i didn't hit even the bounding box
of the whole body
yeah well that's sort of a nice order
one speed up but depending on how big
the bunny
is relative to the size of my rendered
image that might not be a super useful
uh efficiency test but of course what
could i do i could take the
box containing the bunny i could slice
it in half and i would say it does my
you know does my ray hit the front or
the back of the bunny or maybe both
that's where you got it that's where
things get done
um and and so on so now you have this
nice recursive
tree structure where i keep taking the
box containing my bunny and chopping it
in half
and placing uh in some sense usually the
the triangles maybe not the leaves of my
tree but that's exactly that that's
probably good enough
and you get a structure like what you
see on the uh the screen here
and why should you do that well remember
it takes sort of pn
time to render my image of my bunny
normally
well now the picture is actually
misleadingly suggestive
but you might think that maybe it takes
roughly remember and as
the number of objects in my scene p
login time to render my bunny now
because i can kind of traverse
this tree of objects in my scene of
course notice i put a question mark here
and and the devil's in the details here
in fact i think computer graphics people
often believe that the rendering
algorithm takes
p log in time that's often not possible
although kind of there's an interesting
question which is that
the heuristics they use for building
these sorts of trees often do on average
give them lock-in time
and so there's something about their
data that's making this problem easier
than it might seem
so we'll dig into that a little bit in
the graphics class of course you're not
going to prove as many pounds as you
might in a
theory course um but we're certainly
building on the intuition that you've
seen in this class
to build up practical data structures
and these data structures appear
everywhere in computer graphics so for
instance directive a6
black directed acyclic graphs appear
all over the place in computer graphics
literature to describe 3d
scenes so for example this classroom is
a stark reminder of why we need
dags and computer graphics because we
have all of these empty seats here
and they're all copies of one another so
would it make sense for me
to store however many like 100 3d models
of the same chair
probably not right so instead what do i
do i have
i store one instance of a chair and then
some instructions on how to tile it
into my entire scene so one way that i
can do that
is to think of there being a node which
in a graph which knows how to draw one
chair and now i can have a bunch of
different nodes in my scene for all the
instances of the chair that store like a
different transformation for each one
so what if you think about the graph
structure here each of those is going to
point
into the same 3d model of the chair for
rendering
and that makes a direct and acyclic
graph structure um called a scene graph
which we'll spend quite a bit of time
talking about in a37 how to
traverse construct all that good stuff
um and there are lots of different
models of computation
in that universe as well um your
graphics card
is a very specific kind of parallel
processor that's kind of like
lucille ball on the conveyor belt you
know hammering at the same object over
and over again
but if you ask it to do anything other
than one thing it knows how to do it's a
bunch of data at a time
uh then all of your computation grants
for health this is called
single instruction multiple data
parallelism sim d
numerical algorithms matter a lot for
things like fluid simulation
in approximate approximation algorithms
are quite critical too
um in computer graphics the the
complexity is kind of interesting
because of course
your eyeball is sensitive to about 29.97
frames per second worth of material
um you can choose that time to do like
really well rendering one object but
then you take out of the time rendering
something else
so there's kind of an interesting
conservation law that you have to
balance when you solve these kinds of
problems
which is an interesting balance now
between like complexity and runtime of
your algorithm
and perception like what things can you
get away with when you draw a scene
and maybe like i can do tons of extra
computation to get that extra shadow but
it's just not worth it so i'll quickly
sketch out another
uh completely different application of
uh the material that we've covered in
6006 from my own research uh
again just like eric i guess in a funny
way both of our groups i think are kind
of raw in terms of subject material like
rather than
some of our colleagues have like really
laser focused on one
topic or another um another research
area that i
sort of backed into uh is the area of
political redistricting um
this is relevant in the united states uh
recently i've been reading some
proposals about other countries which is
really interesting how they do this
stuff
so in the u.s when we vote for people uh
in congress
by the way not necessarily for president
this is a common uh
misconception but uh certainly for for
congress
um your state gets divided into little
regions each of which elects one member
of the house
and this there's sort of a subtle
problem if you're not used to thinking
about it or one that's like staring you
in the face and screaming depending on
on
how often you read the the news uh in
politics which is an issue called
gerrymandering
where your legislature draws the lines
for what area on the map elects
a member of congress and depending on
how you draw the lines
you can engineer different results for
who's likely to get elected
so for instance maybe there's some
minority i can cluster them all together
into one voting district
then they'll only get the opportunity to
elect one person but
maybe if i divide the space where they
live into two i could manage to engineer
two districts
with a high probability of electing
somebody with their political interests
in mind
so it turns out that uh political
redistricting in a broad sense is a
great problem
computationally even if you're a totally
heartless theorist there's some really
fun problems here
um so for example the state of iowa we
all pick on iowa because
it has a unique law which is that your
districts have to be built out of
counties which are much larger than the
typical census unit so computationally
is easier
but even in iowa um which is a giant
grid with the exception of one
shift in the middle which is fascinating
um
i know a lot of times this is a fun fact
like literally people were
making the map of iowa and they work
from the bottom up and the top down and
it meets in the middle and their grids
were shifted and now we're stuck with
that
and it has an interesting effect on the
topology of your graph because it looks
like squares although there's triangles
in the middle
uh but in any event um even though
there's only 99 counties in four
districts there's approximately
quintillions of possible ways you can
divide that state into four contiguous
districts that satisfy the rules as they
were
at least if you read them kind of
literally in the uh the the law
um so it seems like computers are useful
but unfortunately it's a little subtle
how right so for instance
there's no single best districting
planner out there um
i can't think of a single state with a
law that gives you an objective function
you know similar to
you know whatever cute you know
characters that we've had in 6706 you
know they often have
very clear objectives in life but
unfortunately redistricting uh that's
very rarely the case you know you have
to balance continuity population balance
compactness all these different things
uh reality check number two is that
even if somebody did give you an
objective function for just about any
interesting objective function it's very
obvious that
generating the best possible districting
plan is empty hard
um and by the way it doesn't even matter
because the law
doesn't say that computers have to draw
the best district right so
even if p equals np you really could
extract the best possible districting
plan using an algorithm
um it doesn't mean you have to use it at
least the way the law is written now
interestingly this is not true in
certain parts of mexico where they
actually make you
compare your districting plan against
the computer-generated one which is
philosophically really interesting
although practice it doesn't work
terribly
um right so uh our research has studied
analysis of distributing plans instead
so instead of writing a piece of
software that takes in your state
draws your districts and then you're
done uh instead we ask statistical
questions about
i propose a districting plan and what
does it look like relative to the space
of the uh
possibilities um so that of course begs
the question of what are the
possibilities
so these are like connected graph
partitions meaning you have a graph
and now you take the vertices and you
cluster them together
in a way where they're connected to one
another the one thing that we all agree
on
actually philosophically it's
questionable why um
is that you should be able to start at
any point in your district and walk to
any other one without leaving
these days with the internet it's not
clear that that's actually the best
criteria but that's a lot that i think
is never going to get passed in
in your future so anyway i think i'm out
of time so i don't think i'll walk you
guys through the
the theory here um if maybe i'll leave
it in the slides uh there's a
very simple proof that can show that at
least the very simplest thing you might
think of for analyzing your districting
plan which is to say
you propose a plan and now i want your
plan to be at least
as good under some axis that's just a
randomly drawn one from the space of all
possible connected partitions
all possible ways i could draw the lines
well then it might be useful to have a
piece of software that could just
randomly draw such a thing so in other
words to draw something where the
probability of any one partition
is one over the number of partitions um
this seems innocent in fact actually
there's a number of papers that claim to
do things like this
but it turns out that it's a
computationally uh
difficult uh assuming that you believe
that p doesn't equal np
so i'll maybe leave some suggestive
pictures uh in the slides and we can
if you guys text me or during if we have
a you know professor student chat i'm
happy to sketch it out to you then
um there's a very nice easy proof uh
that reduces the hamiltonian cycle
um and shows you that maybe you
shouldn't trust these tools uh
as much as they're argued about
literally the supreme court a couple
months ago
by the way it was it was pretty fun like
our uh expert report was referenced in
the descent of the the case last summer
um and when you read the discussion like
you can see the judges trying to talk
their way around complexity and
um it's an interesting if somewhat dry
uh read
so in any event that's just the starting
point for our research which says that
of course these
sampling problems are really hard and
the question is what can you do like you
throw the baby out with bath water or
not
um but the uh the real message here is
of course the
this course is unavoidable even in these
extremely applied problems showing up in
court cases or on your graphics card
uh you're still complexity and
algorithms and data structures
are going to come back to play um so
with that
uh find our other two instructors up
here for our final uh farewell
suitably distance so algorithms are
everywhere
i hope you enjoyed this class it's been
a lot of fun teaching you and having you
as students
even though you're not here physically
in the room we still feel your presence
and uh i look forward to seeing you all
soon
thanks for being a part of this fun
thing i want to thank our to uh my
co-two co-instructors for an awesome
time this semester it's been a lot of
fun teaching to you guys and
thanks for uh spending 006 with us this
term yeah thank you and hopefully we'll
see you again soon
bye
you