welcome everybody to
our lecture 14 of 6006 this is our last
lecture
on uh graph algorithms in particular
the last lecture we'll have on weighted
shortest paths uh but we're going to
talk about a slightly different problem
today uh different than
single source shortest paths we're going
to be talking about all pairs shortest
paths
okay but first let's review
our single source shortest paths
algorithms we had
bfs dag relaxation dijkstra which we saw
last time which
you know gets pretty close to linear
right
v log v plus e is pretty
close to linear it's much closer to
linear than the general algorithm
algorithm we have for solving single
source shortest paths
namely bellman ford which is a little
bit more like quadratic this is like the
difference between
for sparse graphs this is like the
difference between
sorting using insertion sort and
n squared and merge sort in
n log n for example right we're going to
get a actually quite a big bonus
for large input sizes by using dijkstra
when we can
okay today we're going to be focusing on
this new problem called all pair
shortest paths
it's not really complicated instead of
having a single source
we are essentially wanting to give in an
input
is our weighted graph
where we've got a graph v
e and we've got a weight function
from the edges to the integers
right this is our general weighted graph
we want our output to be something like
the shortest path distance from u to v
for every u and v
in our vertex set right
that's what we want to return now
there's one caveat here that if if
there's a negative weight cycle in our
graph
in other words if any of these
delta uvs is minus infinity
there's a negative weight cycle in our
graph
so unless
i guess or
abort if
g contains
a negative weight
cycle okay so
we're not actually going to worry about
negative weight cycles
in today's class if we have a graph it
could have negative weights right these
are
any integers could include negative
weight edges
but as long as all of our path distances
are you know bounded
from below none of them are
negative infinity we don't have any
negative weight cycles
then i want you to output all of the
shortest path distances now
in particular this output could any of
these outputs
needs to have size theta of v
squared right because for
every pair of vertices i need to return
to you a number
or infinity or minus infinity or
something like that but we are not
dealing with the case with minus
infinity
the output could have size
this is a theta here it does have size v
squared
right but in particular it's at least v
squared
because i need to give a number for each
pair of vertices
and so we couldn't hope for linear time
in the size of this graph for this
problem right
single source tortoise paths for certain
versions of the problem
we need to read the graph and so we need
to use linear time
but in this problem our output has
quadratic size in the number of vertices
so in a sense we can't do better than
this
right we can't do better than quadratic
and it actually
what's one way we could solve all pairs
shortest paths
by using stuff we've already done in
this class
that's why i put this slide up here
right yeah we could just
solve a single source shortest paths
algorithm
from every vertex in my graph you know
that's
seems like a stupid thing to do right
it's almost brute force on the vertices
but it's certainly a way we could solve
this problem in polynomial time
right and we could definitely solve it
in order
v squared e time
using bellman ford right we just take
the
steps of bellman ford and deal with
a graph on any set of vertices right we
can do better than this
we can do better than this for graphs
that are special in some way right we
can do
v times v plus e v times linear
if our weights are positive and bounded
we can use bfs
v times or if our graph doesn't have
cycles we could use dag relaxation v
times or if our graph had non-negative
edge weights we could get
basically v squared log v plus v times
e right and that's actually not bad
in sparse graphs
this is what bellman ford would give us
but if we had dijkstra's for example
if we had all positive net edge weights
or
non-negatives sorry we could get v
squared
log v plus
v v e
time this is v
times dijkstra
okay so how do these running times
compare this is v times bellman ford
this is v
times dijkstra in a spot let's let's
just
get a feel for this separation here if
if we had a sparse graph where v is
upper bounded by the number of vertices
this one looks like v squared log v
this one looks like v cubed
and we need to spend at least v squared
time
right so actually this is really close
to linear in the size of the graph just
off by a log factor
just like sorting would entail
and this one
would have a linear factor right
in the sparse graph this would be a a
linear factor worse than
this instead of a logarithmic factor
again this
linear to log separation we don't want
to have to do
this running time if we don't have to
right
that's the name of the game and
really all we're going to do in this
lecture
is try to solve how we can
make this running time faster
by doing something a little bit more
intelligent than
running a single source shortest path
algorithm from every vertex
okay uh
how are we going to do that well
we could
let's see what are we doing right
the idea here if we had a graph
uh should my graph be directed or
undirected
i'm not sure let's see if we can make a
directed graph
okay so here's a directed graph why do i
not care about undirected graphs can
anyone tell me
yeah it's because
i don't care about undirected graphs
because if i had an undirected graph
i could detect whether it had negative
weight cycles
in
in constant time all right sorry in in
linear time i could just check each edge
see if it has negative weight
because a negative weight edge
undirected edge is a cycle of negative
weight
so i could just if it has any negative
edge weights
i could return in linear time
that it does and i can abort or it has
only positive weights and i can still
use dijkstra
so that's all good so we're only
concerned about
needing to run bellman ford on directed
graphs that potentially have negative
edge weight
okay so here's a graph let's see
is this a graph that i want
sure let's say we've got
that direction and this direction
okay say we have a directed
graph like this and let's say this is s
this is our source
okay and we have
weights being
2 sorry weights being
4 1 1 2
2 2 2. okay
so this is an example of a graph we
might want to
run all pairs shortest paths on
maybe we also have negative weights in
this graph
okay
in particular this has a negative weight
cycle i don't want negative weight
cycles so i'm going to make this
zero okay so this graph doesn't have
negative weight cycles
great that's
true great all right so here's an
example that we might
want to compute shortest paths on
there's no s
in all pairs shortest paths but i'm
going to be talking about
a couple shortest paths from s in my
next argument so i'm just labeling that
uh vertex as s okay the claim
the the approach we're going to do we're
going to try to take a graph
that has negative edge weights
directed graph we don't know if it has
negative cycles or not yet but we want
to compute all pair shortest paths
not in this running time but in this
running time
how could we do that well maybe it's
possible that we can
change the weight of every edge
so that they're all positive but
shortest paths are preserved so
basically
if a particular path like
okay the shortest path from s to t here
is one two three
right i could change edge weights
uh in this graph say
for example if i changed 1 to 0 here
that would still make this a shortest
path
right i haven't done i've reweighted the
graph
shortest paths have to be the same in
this graph
but now uh
sorry yeah
this is not a shortest path
i'll make that minus two
and then these both two and i think
and this four man i really should have
done my example beforehand okay
so this still doesn't have negative
weight cycles it has a negative weight
edge
but this path is longer than this path
so when this was one
this had length of three which was
shorter than this path
that is length four
okay cool so this
is the shortest path from s to t
i could change weights in this graph for
example
changing two to three
and one to zero that changed weights in
my graph
but shortest paths remain the same
so maybe there's a way i could re-weight
my edges
so that shortest paths stay the same
shortest paths are preserved
okay
so i'm going to put this back to where
it was
all right so idea
make edge
weights
non-negative
while preserving
shortest paths okay
in other words just re-weight the edges
here
so that shortest paths in g
this is g after we rewrite we'll go to
some
graph g prime with the same
combinatorial structure
just different edge weights and we want
shortest paths
we want these weights to all be
non-negative and we want
shortest paths if there's a shortest
path in g it continues to be a shortest
path in the re-weighted graph
that's the goal for today
if we can do that transformation and
this is non-negative
then we're done right we're done because
we can just run
dijkstra v times on that new graph
get the shortest path distances
construct the shortest path tree from
those distances
and then traverse that tree in the
original graph
and compute shortest paths along that
tree so that's
that's the claim claim
we can compute
distances in
g so we're going to restrict
g prime to have with
non-negative edge weights
if we have such a g prime with
non-negative edge weights we can compute
distances in g
from distances
in g prime in
v times
v plus e
okay which is smaller than our dijkstra
running time right this is our dijkstra
running time
and this is smaller than that so
that would be fine right what do we do
we have
our new graph g prime it has all
positive edge weights so we
run all pair shortest paths in here by
just running dijkstra v
times and then for each vertex
s we have some shortest path tree
to all the things that's connected to
right
we can look at that path in g
this is the same combinatorial graph
just with different edge weights
we can look at that same tree i'm not
going to
be able to draw the exact same tree here
okay
but what i can do is i can just bfs or
dfs along this tree
and every time i have an edge because
each one of these is a shortest path
in this tree i can just compute
every time i traverse an edge
what its shortest path distance is in g
in linear time for that vertex for that
particular s
i do that over all s's and i get this
running time
okay so that's the goal here all right
so we first wanted to find
we were wanting to make edge weights
non-negative while preserving shortest
paths
because if we could do that we could
solve our
original all-pair shortest paths problem
okay
so this is the proof sketch
but how can we do this but how
it doesn't even seem like this could be
possible generally
right how can i just re-weight the edges
and maintain that the shortest path
trees are the same
that seems like hard to do and in
particular
if there are there's a negative weight
cycle in this graph
it's impossible to do right so claim
not possible
if g contains
a negative weight cycle
okay the exclamation point is just
my comment here
so if g contains a negative weight cycle
then
in particular the shortest path distance
or a shortest path in g
right if this is g say we have a
negative weight cycle
directed cycle c here
in particular the shortest path from
this vertex on the cycle to this vertex
on the cycle
what is its shortest path it's infinite
a shortest path is infinite around this
cycle you just keep going around the
cycle
over and over and over again because it
has negative weight right
weight of c is less than
zero strictly right that's what a
negative weight cycle is
okay so the shortest path a shortest
path from s to t
has infinite length and in particular is
non-simple
however
so so
shortest path from
shortest path
from s to t
is non-simple
but as we proved in the last lecture
shortest paths
in a graph
with
non-negative weights
are what are simple right because
they're exist shortest path trees
so that's a contradiction so
this is not possible okay
so given a graph
with negative weights but no negative
cycle
it's still not clear how we could find
such a re-weighting of the graph
can we do this well we're going to
exploit
a little idea here how can we
transform the weights of a path well how
what's a a silly idea i have this silly
idea
if i don't want negative edge weights in
this graph uh this is messy
in the back we got edge weights 1 minus
2 0
1 4 5 and 1.
there's only one negative edge weight
here
what if i just added a large number or
in particular
the the negative of the smallest edge in
my graph
to every edge in my graph then i'll have
a graph
with non-negative weights fantastic
why is that not a good idea
well in particular if i did that to this
graph if i added 2 to every edge
the weight of this path which was the
shortest path
changed from weight three
to weight nine because i added two for
every
edge but this path which wasn't the
shortest path in the original graph it
had weight four
increased only by two now that is the
shortest path or it's a shorter path
than this one
so this one can't be a shortest path
right
so that transformation sure would make
all the edge weights
non-negative but would not preserve
shortest paths
right in particular if i added
the same edge weight to every edge
i will bias toward taking paths
that have fewer edges not just smaller
weight
okay so that first idea doesn't work
right
idea
add large
number to each
edge
this is bad uh makes
weights
non-negative
but does
not preserve
shortest paths so this is a
not a good idea bad idea
is there any way you can think of to
modify the edge weights in a graph
in any way that will preserve shortest
paths
so here's a
an idea for you
which is kind of this critical step in
johnson's and
a lot of graph transformation algorithms
if i have a vertex say this middle guy
say v
every path
from v goes through an outgoing edge of
v
and every path going into v
goes through an edge going into v
i haven't said anything it is i've said
very stupid things
but that observation is critical here if
i add a number or let me see if i got
this right
in terms of adding and subtracting
if i add a number to all outgoing edges
from a vertex
and i subtract that same number
from all uh from the weights of all of
the incoming edges to that vertex
then every path from v
is changed by the same amount because
every path from v
goes through one of those outgoing edges
and any
path going into v has also changed by
the same amount
in particular it's changed by a negative
whatever we added to the outgoing edges
so such a transformation
adding a number from all the outgoing
edges from a vertex
and subtracting that same number from
all the incoming edges
preserves shortest paths that's a claim
idea
this is a better idea
given vertex
v
add i'm going to
put this on two lines
add weight
h to all
outgoing yeah outgoing edges
and subtract
weight to all incoming
edges
so that's the idea and the claim is
this transformation
you know shortest paths
are preserved
preserved
under this
transformation
and why is that it's kind of the exact
same argument that i had over there
right proof
consider any path in my graph right
either
if the path
path could go through v many times or it
could go through v net
not at all if my path if i if i have a
path
in my original graph g
then with pathway
w of pi right this is my path
it goes through
uh v
some number of times okay
so i'm gonna say this is going from s to
t
if it crosses
v if it never crosses v if it never it
touches v the
vertex that i transformed then i argue
that the pathway is the same right
because i didn't do anything to edges
that are in this path
alternatively this thing goes through
v sometimes if it goes through v in the
middle
how has the weight of my path changed
well it hasn't
right because i added a number to all
outgoing edges so there's an outgoing
edge here
with weight i've changed by way h
and there's an incoming edge here that
i've changed by weight negative h
so these cancel out and you've got zero
right
so passing through a vertex
doesn't change the weight of my path
the only way i could change the weight
of my path is if v
is the start vertex or the n vertex
right so it's possible that
s is my vertex or t is my vertex
well for any vertex for any path leaving
v i will have increased
the weight of that that that path
by h right because i added away h to all
outgoing edges
so again while the path weight has
changed
since all of the paths leaving the have
changed by the same amount
a shortest path will still be a shortest
path and same goes for
t if t the n vertex is v
i'll have subtracted h from all
of my incoming edges which means that
any
path ending at t any directed path
ending at t
also changes by the same value and so
shortest paths will must be preserved
so shortest paths
preserved so that's pretty cool
transformation i can assign
for any vertex such a transformation
which affects all of the edges
surrounding it right by
by this h additive factor
either added or subtracted so maybe and
i can do this independently for every
vertex right
if shortest paths were preserved by me
doing this to one vertex
then if i do it to another vertex
then shortest paths are still preserved
and let's
let's prove that real quick
okay what i'm going to do is i'm
going to want to do this to give me
flexibility for changing all the edge
weights in my graph
to have this property i'm going to set
or define
a potential
function h
that maps vertices to you know
integers
so this is the potential
h of v
okay
and then we're going to make a graph
g prime
based on
above transformation
for each
vertex in v okay
so i'm going to set a number an
h for each vertex these are independent
now
and i'm going to add that potential to
all outgoing edges
and i'm going to subtract that potential
from all incoming edges
this transformation is going to preserve
shortest paths let's
let's actually be a little bit more
rigorous that that's the case when we do
this multiple times okay
so claim
shortest paths are still
preserved
all right well that's again not so
difficult to see let's
consider a path from s
to t passes through a bunch of vertices
i'm going to label these as
v 0 to
v k so that i can kind of number them
all right this is v one here
this is a directed path okay
v one two three four four all the way up
to k okay
there are k edges in this graph
right i claim to you that any path
from v 0 to v k
any shortest path from v 0 to v k
remains the shortest path
after i we everything in this way
okay so let's say this is path pi
and so it has weight w pi
which is really just the sum
of all of the edge weights from v i
minus 1
to v i for i
equals 1 to k right this is poor
notation this is the weight of the edge
from the i minus 1 to i
right and we've got my indexes from 1
that's the first edge 2k which is the
last edge
right so that's the weight of my path
the weight of my transformed path
i'm going to do it down here it's a
little iffy the weight of my transform
path i'm going to say is the weight
in this new re uh weighted graph g
prime okay
this weight of that same path right it's
the same path
is just going to be the sum
of all of the re-weighted edges so i
equals 1
to k
of my original weight of my edge
so from 0 i minus 1
to v i
but what did i do this edge
is out going from v i minus one
so it's outgoing so i add that weight
that that potential sorry
but that edge is also incoming
into v i right so when i reweighted the
thing
i got a subtraction of h
v i
okay now what happens here in the sum
this term if i just took the sum
over this term that's exactly my
original pathway
right so that's good
but you'll notice that this sum
has k terms and this sum
has the subtraction of k other terms but
most of these terms are equal
right along the path all the incoming
and outgoing edges
cancel out right so we're left with only
adding the potential at the starting
vertex
and subtracting the potential at the la
final vertex right so we've got
add h v
0 minus h
v k
and why is that good well that's good
because
every path from v 0 to v
k starts at v 0 and ends at v
k that's just that's how it is that's
how we've defined paths going from v 0
to v
k but every such path
we transform the weight of that path by
adding a con
by adding a constant associated with the
start and adding
this value associated with the end and
so every path
going from v 0 to v k changes by the
same amount
right and so if this path p
pi was shortest it's still shortest in
the re-rated graph
because i've just changed all paths
between those two vertices by the same
amount
it's this is kind of like a telescoping
argument here
uh in in that kind of proof right so we
have
uh the weight changes right it could
change
but it changes all paths between these
two vertices by the same amount
which means that shortest paths are
still shortest
awesome okay
so the name of the game here
is now we have this really flexible tool
right we have this tool where we can add
or subtract
weight from various edges but we have to
do so in a kind of
localized constrained way right we have
to do the same thing
around each vertex but it seems like a
powerful transformation technique
that maybe we can get this this thing
that we want
which is a g prime a re-weighting of the
graph where all the edge weights are
positive
or non-negative
so does there exist an
h such that
the weights are all positive what does
that mean w
prime uv
right the weight in my new graph in g
prime
i want these modified weights
right this modified weight of my graph i
want each of these to be
non-negative so does there exist such a
thing
huh well if i rearrange this equation a
little bit
this side i get something that looks
like this
h of v needs to be
less than or equal to h of u
plus the weight of some
edge from u to v
huh what does that look like
that looks like almost exactly the
definition
of the triangle inequality right
shortest path from some vertex here and
the shortest path distance from the same
vertex here
this is just a statement of the triangle
inequality
right so if we can set these
h's to be the shortest path distance
from some vertex
and those shortest path distances are
finite
and none not minus infinity
then this thing will hold by triangle
inequality and in particular
if we were to re-weight the edges based
on those values of h
then we get new edge weights that are
non-negative
awesome okay but
there might not be any vertex
from which we can access which is which
we can reach
all vertices in the graph right in
particular my graph
might not even be connected right
if i want this property i need all of
these i don't gain any information if
these things are infinite
right i it's it exhaustively true
infinity is i i don't even know how to
compare
infinity and infinity plus a constant i
i don't know right so i need all of
these things to be finite
so how can i make those things finite so
here's the next
idea
add
new vertex
s with
zero weight edge
to every
vertex
v in v right we take our original graph
we add a new super node or auxiliary
vertex
s with a zero weight edge to every
vertex in my graph right
what does that look like this is like
there's my original graph
and now i have this vertex s but it has
directed edges into all of the vertices
with zero weight that's our picture
and this new thing
right i'm going to call maybe my
s graph now all right
and the claim is well now if i run
some shortest path algorithm single
source shortest path algorithm this time
from s to compute the shortest path
distance to all of the vertices
the shortest path distance to each of
the vertices
can't be positive right
because there's a zero weight edge so a
minimum weight path
is going to be no bigger than zero
if it's finite then there's a finite
length shortest path if it's
minus infinity then there's a negative
weight cycle in my graph and i can stop
right okay so
there are either two situations
if delta
sv equals minus infinity
so i guess this is run
single source shortest paths from
s and really because this graph
could contain negative edge weights and
could contain negative cycles
we can't really do better than running
bellman ford here
right from s to compute these paths if
there exists in this new graph this gs
if there exists a vertex that has
negative
infinite weight in the re-weighted graph
sorry
in the original graph g g hasn't been
reweighted yet
if there's a negative weight distance
from s
then it
then there was a negative weight cycle
in the original graph why is that
well if this was set to minus infinity
then there is some negative weight cycle
in the graph
right the worry is that that negative
weight cycle
was added to my graph by adding this
vertex s but what do i know about vertex
s
it has no incoming edges right so no
negative weight cycle could go through
s right so any negative weight cycle
was in the original graph and so i can
abort
abort yay
otherwise
what do i do well i know these shortest
path distances
here would satisfy the triangle
inequality
right so if i re-weight
with h of v
equal to delta s of v
right if we set our potentials in our
reweighted graph
to be the shortest path distance from
our
super node s
it satisfies the triangle inequality
right and because there's no
negative cycles all of these values are
finite
and then this re-weighting will lead to
a graph
with strictly or not strictly uh
strictly no negative weights or uh
non-negative weights okay great
so that's basically it
that's the idea behind johnson's
algorithm
it's really a reduction problem a
reduction algorithm
we're reducing from solving
kind of signed all pair shortest paths
graphs where their weights could be
positive or negative
and we're reducing to creating a graph
that has the same shortest paths
properties
but only has non-negative edge weight so
we're reducing from a signed context
to a non-negative weight context
right so johnson's algorithm
what are the steps construct
g s from
g right
just as up here right i make a new
vertex
s i put a zero weight
directed edge from s to every vertex
okay so that's the first step
second step compute
d s v for all
v in v
i e or e g
i guess really it should be ie because i
don't really have another option here
but
by bellman
ford this is a single run of bellman
ford here
compute and then there are two
possibilities
if there exists
a delta sv that's
minus infinity
then abort
else
make
our we re-weight the graph
according to this re-weighting scheme
right
by re-weighting
each edge
in my original graph to have weight
our new weight which is our old weight
plus our transformation now our
transformation is now going to set
hv to this delta sv right
so i'm going to add delta
s u and subtract delta
s v that's our rewaiting scheme i'm just
identifying
hv with this shortest path distance here
okay
and i after i re-weighted that i can
just
solve
all pairs shortest paths
on g prime with
dijkstra
and then compute
g shortest path distances
from g prime shortest path
distances
right compute these distances from the
other
using this algorithm up here can compute
distances in
g from distances in g prime
in linear time or sorry
v times linear time linear time for
each s for each vertex in my graph
okay so that's the algorithm it's
basically correctness is trivial right
we already proved the whole part of this
lecture the interesting part of this
lecture
was proving that if we had a
transformation
based on a potential function that
changed outgoing edges
in a symmetrically opposite way as
incoming edges
then that preserves shortest paths
and then realizing that the triangle
inequality
enforces this condition that edge
weights will be
positive or non-negative under this
re-weighting
so we find shortest path distances from
some other arbitrary vertex
and set our potential functions to be
those shortest path distance weights
we do the re-weighting because that
re-weighting preserves shortest paths
which we already argued
right then we can do
then then this has positive edge weight
so dijkstra applies
and then computing this takes a small
amount of time okay what is the
running time of this algorithm so this
part
reconstructing this thing this takes
linear time
right i'm just adding
i'm just making a new graph of the same
size
except i added v edges and one vertex
okay computing doing bellman ford on
this new
modified graph that's just i'm doing
that once
that takes v times e time
doing this check that that just take i'm
looping over from my vertices that just
takes v
time otherwise
doing this re-weighting i change the
weight of every edge
so that takes order e time
and then solving g prime
solving all pair shortest paths on the
modified edge weight graph
with dijkstra takes v times dijkstra
right that's uh
use a little bit more board space here
that's
v times
v log
v plus e
time right which is actually the running
time that we're looking for
right i wanted to reduce to not using
more than this time
we used this amount of time let's make
sure we still didn't use
even more after that we compute
these paths as proved before in
v times v plus e
which is smaller than that right and so
summing up all of these running times
this one dominates and so johnson's can
solve signed weighted all pairs shortest
paths
signed all pair shortest paths not in
v times bellman ford like we had before
up here but faster
in nearly linear
for sparse graphs just without this
log factor so we got a quite a big
improvement
right so that's the nice thing about
all pair shortest paths is that
really we don't have to incur this this
big cost uh in the context of negative
weights
essentially we just run bellman ford
once
to see if there is a negative weight
cycle in my graph if it is
i save a lot of work by stopping early
okay so that's johnson's that's the end
of our
graphs lectures we'll be having a review
and problem session
about how to solve problems graph
problems
using this material but we've we've
talked about a lot of different things
so far we've talked about graph
reachability
connected components detecting cycles
detecting topological sore orders of a
dag
we've talked about finding negative
weight cycles single source shortest
path algorithms
and now finally today all pair shortest
path algorithms
with a new algorithm that's really not
a an entirely new algorithm right we
didn't have to do
any proof by induction here
really the heavy work that's happening
is we're reducing to using
either dykstra or bellman ford to do the
heavy lifting of finding
single shorts shortest paths efficiently
right so johnson's is really just glue
to uh transform a graph in a clever way
and then reducing to using some of these
shortest paths algorithms
faster okay so that's our unit on graphs
our next lecture will start talking
about a
general form of not presenting you with
an algorithm
but how to design your own algorithm in
the context of dynamic
programming okay so see you next lecture