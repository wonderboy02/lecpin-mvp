i'm jason hopefully you guys saw me on
tuesday
uh this is our first ever 6006
problem session that we'll be having on
fridays this term it's really an
experiment
we've never done this before but one of
the things that we were discussed while
preparing for this class
is that we have two different methods
of instruction formally usually
in this class a lecture which is there
to present you with the fundamental
material
the the data structures and the
algorithms uh that are
kind of the base the foundation of what
how you will be approaching problems in
this class
uh and then the problem sets
that you will will you will work on our
applications of that material but it's
there's usually a much different feel
between those problems that we'll give
you than the
underlying foundational material right
so the application that
material feel very different and a lot
of times there are tricks to approaching
the problems
uh or ways of approaching the problems
that um you kind of just have to figure
out by
working on the problems sometimes going
to office hours
but what we wanted to do this term was
to
since we had the opportunity to be
recorded by ocw
was to record us going through some
problems that we've had on problem sets
in the past so you could
see how we would approach working on
these problems
that you'll be working on at least in a
similar vein
so that's the goal of this these problem
sessions in the past
for ocw we have recorded recitation
but we felt that that was a little less
useful to you guys because
recitation is meant for interaction
questions one-on-one questions we wanted
to be a safe space
for you guys to interact with the
material with in a in a smaller
environment
that might not be recorded so that's the
goal
of of this these sessions that we'll be
doing on fridays
any questions about what we're going to
be doing today
okay so uh we do have a handout up here
by the door
um which uh we may or may not have in
the future this is all an experiment so
you'll have to work with us as we
figure this stuff out um they were
posted on uh
elmod about an hour before this session
we'll try to
keep that uh as a standard
uh but it just shows you the the
questions we'll work on
uh today in the in the session
it won't necessarily be the entire it's
it isn't just
the problem set from last term it's a
selection of problems from previous
terms
and some of them have been edited to be
maybe a little shorter and things like
that
um so what we're going to do is just go
through the problems one by one i'll try
to just
kind of show you how i'm approaching the
problems
uh but at any point if you want to you
can ask questions that's fine
okay all right so the first question we
have
is has a setup that's very similar to
what you will have on your pset one
it's essentially saying that uh it has
it is
usually many parts this has two parts an
a part and a d part uh i've i've omitted
a b and a c that that was on last term's
problem set
and it has five functions each and
you're trying to
order them increasing asym
based on their asymptotic behavior so
here are the uh
the functions that we have uh maybe i'll
stick it up
instead
all right so we have a few sets of
functions and we just want to order them
and some of the the functions may be
uh asymptotically equivalent right in
which case when we are ordering these
things
we're going to put those numbers in a in
a set so what we have is
as an example are three functions
uh n uh root n
and n plus root n this is one two
three and what we're going to ask you to
do is order those functions
uh based on their asymptotic complexity
so hopefully you guys can get this one
which one's the slowest growth in term
root n so number two so if we say
f of two will be our first one and then
how about the other two they're the same
they're both
order n right so we would put in set
brackets
f1 and f3 on your problem set
if you put just two and one and three
here that would probably be fine
okay but if you were to put two over
here
or not have these curly braces
around here those would not be correct
and you'd get points marked off
does that make sense okay so we're going
to approach the first set of problems
first set of functions which is a little
different than the second set of
functions hopefully this one's a little
easier
one of the common approaches that i have
in going through these
things some of these are in a form that
is hard for me to tell
how they would compare to other things
actually most of these are
are fine but in general does can can
anyone just buy eyeballing
tell me an order that that works for
them
yeah um okay this is a little
a little difficult to do on the spot
with five functions
okay
okay great that's that's excellent so
what we've got here
is on f2 f3 and f5
we kind of have this n leading term if
we factor an n
out of that then we're comparing log
with a
you know basically we look over here at
the polynomial function
right this one's smallest out of them
and then the log factor
is smaller than a polynomial factor
right log grows slower than linear
right and so this guy
is smaller than f2 is smaller than f3
that's
great that your colleague said um in
general
you hopefully you proved in recitation
today no wednesday
this nice uh you know
fact i guess that a
is
is less than asymptotically this
polynomial this log and to any power is
asymptotically less than any polynomial
for any
positive a and b and in particular
there's actually a stronger thing you
can say which is
little o did you guys talk about little
o in
recitation at all probably not it's kind
of the same as
big o except is big o minus
theta right so things that are
asymptotically
equivalent are not going to be included
in this set so actually these things are
strictly asymptotic grows strictly
asymptotically slower
than any polynomial does that make sense
okay so knowing this
identity right or this
uh relation can we say anything about f1
someone maybe maybe someone else any a
and b
any positive a and b anyone else have a
a guess on how yeah uh
that f1 is less than f1 yeah f1 is less
than
f5 right because just using that
identity this sorry a
here that i erased stupidly right is
smaller than
say this is small this is bigger than n
right
and n to the b being one
is bigger right so uh and then
as your colleague pointed out before
this thing is
exponential so definitely higher than a
polynomial okay so that was very easy
right so the
the answer here is if i if i got uh if i
remember correctly
f1 f5 f2
f3 and then f4
great so that one was pretty easy
how about b or d
i guess yeah sure
how would you go about proving that so
there is a proof in your recitation
handout
uh there the the method in which they
proved that in the recitation handout
was putting um
the the two taking a ratio of the two
functions
and taking their limit as n goes to
infinity right
and if the top one if it goes to it
it grows arbitrarily then the top one
would be
asymptotic grow absent faster and if the
it
went to zero the bottom one would grow
asymptotically faster
and if it went to some constant then
that would be
asymptotically equivalent does that make
sense in in actuality to make the
limit easier to take we take the limit
of the logarithm of the ratio it just
made it easier
does that make sense okay
so let's move on to b b
we have a polynomial and an exponential
and then we have these things down here
what do these things in in parentheses
mean
choose right it's a binomial coefficient
uh
does anyone know what a binomial
coefficient is yeah
pro hopefully from o42 or something like
that or whatever your competition math
background is
um but in general we have this
definition
right this thing is what does anyone
remember
what does n choose k mean it means
that yeah to choose k objects
yeah the number of ways to choose k
objects from n
things right i never remember this
formula
uh and probably a lot of you have
memorized this formula
uh i'm not going to ask you to do it i'm
going to tell you how i
kind of think about this uh what if i
want to know the
number of permutations of n choose k
i mean of of of n so sorry just how many
permutations are there
of n items what is that that's just n
factorial
right so what we do here is we want to
choose
some n number of things
okay i have n factorial different ways
of choosing those
but then essentially in here and in here
k and n minus k i don't really care what
their order is
right so i'm going to divide out
the permutations of this stuff and this
stuff does that make sense
so the formula here as i remember it
that hopefully is correct is
n minus k factorial right so i'm
getting all of the permutations of the
whole thing
divided by their constituents does that
make sense
did i do that right okay cool
so that's a nice transformation so the
first step is kind of writing these in
terms of factorials
that doesn't really help me any because
i don't know how big factorial is base
with respect to these other things does
anyone know how big factorial is
yeah you can use sterling's
approximation so that's
that's nice does anyone remember what
sterling's approximation is
no i don't remember either i always have
to look it up
uh sterling's approximation says
n factorial is
uh approximately and this approximation
is much stronger than
um uh than an asymptotic behavior
it's actually as these things as n
approaches infinity these things are
equal
the limit is the identity uh but the
approximation is
the square root of 2 pi
n n over e to the n
okay that's fun
so what kind of growth is this
super super bad right right it's
it's you know definitely exponential
it's
higher than exponential it's n to the n
something like that
dividing out uh an e e this is uh
you know e right uh the base of the
natural logarithm
right and this is a constant right and
so it's pi pi is a constant
kind of interesting that we have two
transcendental numbers here that's
that's kind of fun like mathematics i'm
sure
some one of your o42 instructors could
tell you why uh
i can't right now off the top of my head
but this is
this is an approximation that's very
good right
and actually uh some sometimes other
people will think
this is this is what people call
sterling's approximation
one a weaker notion that sometimes is
useful
for you is uh if you take the logarithm
of both sides
this is asymptotically what
if i took the log of this thing
it is uh you know a polynomial thing
it's it's basically n log n right so
it's
if we take a log of this thing it would
be
uh various things all right let's let's
do it out
2 pi n n over e
to the n so when we're
inside a logarithm multiplication we can
split it out
becomes addition division becomes
subtraction right and this thing
grows faster than all these other things
so we can ignore them when we
add them out asymptotically and so we
end up getting is this
n to the n the n comes out on the
logarithm
and you get something that's theta n
log n oh that's fun
this is something we might use later on
in the class okay
okay but when we are comparing these
functions
one of the nice things to do is convert
them into
something that's familiar to us so that
we can compare them easily
right so here this thing is
whatever that thing is right roughly
square root n n over e to the n right
that's
that's the this is uh i'm gonna say
theta okay that's a little bit more
precise
all right then what about these two
things let's start with the bottom one
can someone tell me what this is
asymptotically yeah
n cubed why is that well if we plug this
stuff
into that definition here right we have
n factorial over 3 factorial
n minus 3 factorial right
n factorial over n minus 3 factorial
just leaves us with an n an n minus 1
and an n minus 2
over 6 right and if you multiply all
that out the leading term is an n cubed
right so this thing is
asymptotically n cubed i kind of skipped
some steps but hopefully you could
follow that
okay and then the last thing to
remain is this one right there
that one's a little tricky
anyone want to help me out here what we
can do is we can
stick it into this formula and then
apply
sterling's approximation to replace the
factorials that make sense okay so what
i'm going to do
is let's do this in two steps
uh this is going to be n factorial over
what is this n over 2 factorial and then
what is n minus
n over 2 that's also n over two so this
is going to be
n over two factorial
squared is that okay yeah
now let's replace this stuff with
sterling's approximation and see if we
can simplify
okay so on the top we have 2 pi
n n over e to the n
over and then we've got a square here
pi n x canceled the two
n over two over e to the
n over two did i do that right
okay i can't spell and a lot of times i
make arithmetic errors so
catch me if i if i am doing one
okay so let's simplify this bottom here
uh i'm not going to rewrite the top the
bottom here we square
this guy it's pi times n
and then this guy n over 2 squared that
just stays as an n right
then we have n over 2
to the n over e
something like that and over 2 over e to
the n that makes more
mean happier okay so now we have this
over this
how do we simplify well we can cancel
out
one of the root n so we've got square
root
of pi n down here
and square root of 2 up top
and then what do we got we've got
n to the n down here and n to the n down
up there so those cancel
we got e 1 over e to the n 1 over e to
the n up there those cancel
what's left in this term when after we
cancel
uh 1 over 2 to the n in the denominator
right
which is 2 to the n in the numerator
okay so this thing is what
this thing is right asymptote we can get
rid of these constants and it's root n
it means it's 2 to the n over root n
asymptotically right
does that make sense everybody okay with
that knowledge
and i'm sorry for my messy board work
uh what is the ordering of these
functions then can someone
help me out someone else
eric i'm sorry you can't answer come on
guys you followed what i said
how about some of the starting start it
out for me
right so both of these things are
asymptotically equivalent so we should
put those in brackets
f2 f5
f3 this one why this one
i'm i'm just asking you to justify what
you're saying
this one's the biggest
i don't know if that's f4 f4 is the
biggest right so this one's definitely
bigger than this
right because it's n to the n as opposed
to
two to the n okay
so for any n larger than 2 plus
e is is you know fairly obvious that
that's bigger
so when have 3 why would f3 be before f1
but we're dividing by a polynomial
factor right so
it's going to be uh slower
asymptotically than than the first one
right there right so
you got it right what is it f3
f1 and f4
okay cool so
it's a little complicated but you know
just applying some logarithm and
exponent rules
uh understanding that log rhythmic
factors grow slower than polynomial ones
and again grow slower than exponential
ones
and being able to do some
transformations of some of these
mathematical quantities to get them in a
polynomial
like looking form is how you're going to
approach
these problems does that make sense all
right so
we're going to move on to question
tuna yeah you've got a question
so it's just that i don't i don't know
how to simplify that any further
right you've got a polynomial factor
here and then this is an
n to the n term divided by an
exponential okay
f3 took this uh this
little cycle here okay what we did was
we
probably we uh expanded out the
definition
of the binomial coefficient here then we
applied sterling
and then we simplified and got back does
that make sense
yeah sure is there a reason
why is f3 before f1 right so this is
if i erase the 2 and the pi
this thing is theta of that 2 to the n
over a polynomial factor right it's over
n to the one-half right n
to the one-half grows uh non-trivially
right right and so this is going to
decrease the running time of this thing
by a polynomial factor
right you could think about a we're
multiplying this by a
n to the minus one-half as well right
that's another way of thinking about it
any other questions okay
so we're going to move on to
problem two i guess i need a
an eraser
so problem two is kind of a funny
looking problem
uh the point of this problem is
uh kind of to get you to think about
using some of the things we're going to
be using in this class as a black box
if you if you using something as black
box means is that it has a kind of a
public interface that you're allowed to
work with but
i'm not allowed to see what's inside of
it right and a lot of times what we'll
do in this class
is try to use a black box and just
try to use the abstracted outer
functions
uh so that we can prove things about it
right we can just accept those as true
and then use those to to deal with our
analysis so what we're given in this
problem
is a data structure supporting um
a sequence interface that you heard
about yesterday right
what's the sequence interface again it
what is a sequence interval how does it
store items
anyone remember yeah
in in well it okay
all right so so what your your colleague
is saying here is
we list them in a contiguous array okay
does anyone have a problem with that
definition
yeah up there
okay if you use the link so um one of
the
the important things about this class
is abstracting this idea of an interface
versus an implementation and so
what this student down here said is
talking to me about an array
as an underlying implementation and what
the student back there was talking about
is a linked list
these are both things that can implement
that interface
right but in reality the interface is
something
abstracted outside of those ideas we
could implement
with either of those data structures
right so
what makes the sequence interface a
sequence interface yeah an order
or at least an index specific way that
allows for calling though
so so it's about the data right that
we're storing right
the data that we're storing we're
storing some number of things
right and the important thing is that
the data structure is maintaining being
able to
find items in that set by
by maintaining an order on them right
i usually like to call it an extrinsic
order on these things right
it has nothing to do with what the items
are right it has to do with how
i put them in order there's a first
thing there's a tenth thing there's a
last thing
right that's what a sequence of items is
right and so uh what this data structure
is doing
that's the input that is the kind of uh
what we have available to us in this
problem is some kind of data
structure storing a sequence of things
and it can support these four operations
right and insert first
insert last delete first and delete last
and it supports each of those things in
constant time
okay you don't know a data structure
that does that
yet you will on your problem set one
and we'll talk about another way to do
that
today um but we we don't care how it's
implemented
we just give you this black box that
achieves these things yay
awesome uh and so what we're trying to
do is
we have this thing right and i want to
be able to
manipulate the sequence stored inside
but all i have access to
are these external operations okay
so the idea is going to be let's
implement algorithms for these some
higher level operations
in terms of these lower level things
that are given to us does that make
sense
okay and this is actually a pretty easy
question
hopefully we'll have slightly more
difficult ones for you on
in a different context uh on problem set
one
okay so uh the first uh operation we're
going to support
or try to support uh is an
operation called swap ends
okay and what this is going to do is
take the data structure that we gave
another way you could do this is put
this as a method on that data structure
but
let's do this separately it's going to
take that data structure that we gave
i gave you that's storing the sequence
as the only argument and what is going
to what we're asking you to do
is describe an algorithm to swap the
first and the last items
okay so i i mean i
if it's if it was an array i could just
look at index 0
look at that look at the last one look
at that and swap them
okay but i don't have access to what
that underlying representation is so
how would i do that using the the things
that we have
available to us this is a pretty easy
question
uh what do we got just a quick question
yeah does the delete method also return
whatever deletes
yes yes it does so in general if you
actually take a look at the session
notes it's giving you a nice little
reminder
recall the delete operations return the
deleted item
okay it says it right there on the thing
all right uh yeah
did you oh i i also had a question sure
and then this actually after you got it
it's not related
if they don't specify a space of
complexity
one of the things that eric talked about
yesterday was generally in this class
uh if you have it usually what we'll
give you is a running time bound on the
things that you ask for
and because allocation of space by our
model
takes that amount of time right the
amount of time
but the amount of space that we are
using
is going to be asymptotically upper
bounded by the time that we're going to
use
for the algorithm right and so generally
we'll
ask you to stay within a time bound and
not ask you to do something separate
with space
but there are problems probably at the
end of this unit
where we might talk about space
complexity uh
but usually we will be we will be very
specific if we
if we want you to think about space any
other questions
all right so how do we implement this
swap ends thing
yeah this is a pretty easy one yeah
okay so another thing about this class
right
your your colleague over here is trying
to write
code to me okay uh
which is great for a computer and that's
great if you're taking six level nine
it's not great if you're talking to your
friends or if you're talking to me
right i am i can't parse code in my head
and compile it all the time
sometimes something i can but but not
all the time especially when it gets to
be a large program
so i want you to explain in words to me
and we want you to explain
in words in your latex submissions
what it is the algorithm is doing okay
so
can you start over with your description
words are hard i agree with you okay
computer science
i would delete the last the last then
okay
okay so proposal we have a sequence of
things
uh again as eric was doing in lecture
yesterday uh this isn't representing an
array it's representing a sequence so
this is the
front first i guessed and last
and what your colleague was saying was
to delete this guy
yeah and stick it on the front
okay maybe by using delete last
and insert first okay
that sounds pretty good does that do
what swap ends is doing swap ends
swap the first and last items in the
sequence
it's probably better to first store it
in some other variables so that way we
can
get the delete the end so what your
colleague is saying
is well we've done kind of half of our
work
the first one's still over here right
that's no good
okay does someone have a way to modify
this
yeah before i modify the question in
order to modify
um restrictions about the amount of
things we're storing
ah yeah so how much extra space can we
use for example
right the easiest way would be to um
delete the labs that they prefer
and then just if we have them already
kept
them but i don't know if i can keep two
different bibles
good good question so the question right
can i
use additional space and in general if
we don't give you any restrictions
on what you can store then
you can go wild do whatever you want
outside of this data structure right
like one of the things you could do is
you know
remove first on all of these things
right
store it in some data structure you like
manipulate it as much as you want
and then insert first i'm all the way
back in and rewrite the thing
but that's not going to give us constant
time which is what we're asking for
right but if we don't tell you otherwise
feel free to
you know i mean probably you're only
allowed to store a constant number of
things since we have constant time
but generally uh unless we say no you
can't use additional space
you can use additional space okay so how
would you do that would
probably erase the last one
that's great so what your colleague is
saying we delete both of them
we store them in temporary variables and
then one at a time
we insert each of them in their
corresponding place using the functions
that we have available okay
so if i were to write little pseudocode
for this um
i might take you know the first one
right i'd delete
uh first okay
i'm really abusing notation here
but that's okay you get what i'm saying
uh delete
the last and then store them
in their respective places insert
at the front which one i'm going to
insert
what's up hmm
speak up guys x2 yes thank you
and insert last
x1 right okay
that's pretty easy yeah what would in
this case what would let her and
i think this might be relevant from like
what would constitute a pseudocode
versus
writing pythons all right so for this
this problem
you'll see the solutions posted to this
later on in that one
i wrote up a description of what i was
going to do
and then i actually because this was
pretty easy you know i actually wrote
down some python code to do
whatever whatever this thing was but in
general and
uh it's actually okay to write python or
pseudo code
of this form on your problem sets or on
an exam or something like that but
if we can't understand what your
variables mean if we can't understand
what your
pseudo code is doing then that's not
sufficient
right so the reason why we ask for words
is
so that you can communicate those ideas
well
okay so can you also have a combination
of pseudocode and description sure
yeah including both of them can be
clarifying for you
potentially yeah any other questions
okay so now we have so one of this is
not such a
interesting question from an algorithm
standpoint right
this is a constant size problem kind of
right
i have this data structure i do two
operations i need to do something right
and this is so easy that i'm really not
even gonna argue
correctness i'm not even gonna have to
argue correctness
to you because we're essentially just
doing exactly what we asked for
right so you don't most of the time in
this class when you're doing something
non-trivial especially
when you're doing something that has to
recurse in some way
we do want you to argue correctness okay
but in this case the for example the
time analysis is very easy right
we do four operations they each take
constant time
so this operation takes constant time
done yeah
all right so how about the second
operation
second operation at least uh
allows us to use a little bit more so
shift
left the
k this is
the operation we're supporting now is
we're given this sequence and what we
want to do is take the
first k
right here
and stick it over here at the back okay
so that
the uh these k go here so the
kth item ends up being the last item and
the k
plus one item now becomes the first item
does that make sense okay again this is
actually not such an interesting
algorithm from an algorithm standpoint
but it's hopefully uh
helpful to talk about from an
instructional point of view
okay so how would i approach this
problem i i need
this operation to
happen in order k time
yeah okay so first i'm go and delete
set a variable x1 to be the d dot delete
first element then a pet
do dot insert at the last exponent
d write a for loop and then do that k2
okay and i should have take two
steps which is okay okay so what your
colleague was saying
is uh that we're just going to delete
this guy
stick it on there do it k times
that sound good yeah so there's one of
the things in this class
that you have in terms of implementation
right
usually there are two ways at least two
ways you could do something that
takes longer than constant time you
could write a for loop
or you could use recursion right
and that's sometimes approaching a
problem
would be good one way rather than
another right
why is it that a lot of computer
scientists
as opposed to coding engineers prefer to
think about an algorithm recursively
does anyone know why
at least i do when i'm explaining it
from a theory standpoint
it actually might not be good from an
implementation standpoint because your
computer can vectorize for loops and
things like but that's not something we
need to talk about
uh why would we want to talk about a
recursive algorithm
maybe more it lets you break up the
problem much smaller more manageable
pieces
okay so recursion uh lets you break up
the problem into small
measurable pieces that's that's actually
true
in in some context what your recursion
how i like to think about recursion a
lot of times is if i have a non-constant
amount of work that i have to do
usually easy for me it's hard for me to
hold
a non-constant amount of information in
my head right
what i want to do is think about a
constant amount of information at
at any given point in time because
that's easier for me to argue on
right it's easier for me to think about
making arguments case analysis on these
small amount of things
and so one of the things you can do is
if you break it down so that i
i solve a slightly smaller problem
recursively
and then do a constant amount of work
and maintain
some invariant then it's very easy to
argue things about it
right it's very easy for me to convince
myself that this thing is correct
okay so i'm going to provide
a recursive way of solving this problem
can anyone set up maybe a recursive way
of thinking about this problem instead
of putting this
inside a for loop like your colleague
was saying
um
ah so what your colleague is saying is
setting up the
a very nice thing right but she is
saying that if
we if we think about this recursively
we'll think about a base case
which your colleague was saying maybe k
equals zero
right uh and otherwise
if we're not at zero what we'll do is
we'll
start it out right move one of these
guys over
and then we have an instance where we
want to shift
k minus one things over right
it's we want to do the same thing but
with k minus 1 things
and so we can just call this thing for a
smaller value of k
does that make sense
all right so let's try to write that out
um
the first thing i'm going to write out
is kind of a a break
if if i'm at a base case
let's not do anything to this thing
right and maybe i also want some bounce
checking
to make sure that we're in range okay so
i'm going to say
if you know our k is less than one
right we're certain i don't think we
should be doing anything to this array
so let's just
not do anything right if k is less than
one or
k is bigger than the length of d
minus one so i don't know what to do if
i'm you're asking me to shift more than
the things i have
right so let's not do that
uh is this uh
i guess it's really yeah because if it
was length of d
right we would just not move anything
anyway right because we'd shift the
whole thing
right so we don't have to do anything
all right if we're in either of these
cases we're just going to return
because i either shouldn't do anything
to the array or i have no idea what
you're talking about
right if it's negative or something like
that okay
so that's the first thing otherwise what
do we do
we shift one thing over and then we make
a recursive call does that make sense
okay so
we'll delete the first thing as a
temporary variable
right delete first
okay and then we'll
insert last
uh x
right
and then we need to do the recursive
call so what's our recursive call look
like
yeah yeah
so shift
left d k
minus one okay and then
we can return this this thing doesn't
need to return anything it's just doing
stuff to the thing
right and whenever we get
this k we make a call that gets down to
zero
we will terminate right because we will
return
right we're in this range somewhere
between we have an input
after this line we know that k is
somewhere between
1 and n minus 1 right and what we'll do
is every time through this recursion
we will subtract 1 from k
so this is a nice well-ordered sequence
right
we do the correct thing obviously right
in the base case
and as long as this thing was correct
for a smaller value of k
this thing also does the correct thing
right
because we're shifting over one as we
are asked
and we're letting this do the work of
the rest
i don't have to think about that right
like i just have to think about this one
loop
this one part of the thing that i'm
doing constant amount of work is done in
this section
and how many times do i call a function
okay yeah i think k minus one times or
i don't know i forget but it's order k
for sure right
and we do a constant amount of work per
call
ignoring this extra call does that make
sense
right so this thing runs in
order k as desired okay does that make
sense
all right so now we'll move on to
question three
does that any questions about question
two it's that one's really
probably one of the easiest problems
we've ever had on a problem
sorry to uh scare you okay
so problem three okay so this is a
little block of text right here
okay a dynamic array can support a
sequence interface supporting worst case
constant time indexing as well as
insertion and removal of items
at the back of the array in amortized
constant time so this is what we did
yesterday
in lecture right we showed how a dynamic
array
it's fast to do dynamic operations at
the end
right okay however insertion deletion at
the front is not very efficient because
if you tried to do that you'd have to
shift everything over right that makes
sense
all right on the other hand what we
talked about yesterday was linked lists
uh they can be made to support insertion
and uh deletion at both ends in constant
time okay so that's a little
foreshadowing of something you're going
to do on pset one
okay but in lecture we talked about
that operation that data structure a
singly linked list
being good at dynamic operations at the
front of the list right because
essentially we could just remember where
the front of the list was
and swap things in if as as needed right
that makes sense okay so on your problem
set what you're going to do is make
end operations good on the length list
as well
as well as supporting another operation
uh
but what's the problem with linked lists
uh as compared to dynamic
dynamic arrays yeah
yeah linked list lookups can take linear
time right because
i have no i don't have the benefit of an
array where i can
randomly access something in the middle
by essentially just
doing one arithmetic offset calculation
from the front
address right and being able to find
this thing further down in constant time
using our
com model of computation of the random
access machine right
you know linked lists these things could
be stored all over the place in memory
and i have to
kind of traverse those pointers until i
get to the one that i'm looking for
right that's that's a benefit of an
array-based
data structure versus a a link to a
pointer-based one
right okay so the then we get to the
meat of this question
show that we can have the best of both
worlds right we can have a
data structure that supports um
worst case constant time lookup just
like an array
but amortize constant time dynamic
operations
from the back and the front
of the sequence does that make sense
all right so is this question or if okay
yes can i define sorry about that can i
define
amortize one more time okay so this is
this is a tough
thing to define in general but and uh
but not that much right so all right so
amortization usually you put in the
at least in this class we're going to
put in in terms of the data structure
okay so you have this thing right it
supports some operations
and you're going to do a bunch of
operations on that thing right
there's not really a reason to have a
data structure unless you're going to do
lots of things to it
right otherwise you just write a single
algorithm to do whatever it is that you
want to do
right so data structure the the value of
the data structure
is that you can do some work up front
by making this thing to make some of
these operations faster
okay so what amortization means
is okay if i have say a dynamic array
where i'm going to be inserting things
at the end
right yes sometimes when i add something
i'm going to spend a lot of time to add
that thing i'm going to spend linear
time
right but what's the point of this
data structure in the first place the
point is that i want to be able to
potentially add a lot of things to this
thing does that make sense
right amortization is saying that even
though
sometimes this operation will be bad
right averaged over many operations this
is going to
have a better running time that's the
amortization so more formally
right what's that's going to say is if i
have an operation
the definition of it running in amortize
some amount of time
say k time or
yeah sure that means that if i do
n operations kind of generally for large
n right
if i do that operation n times the total
time it takes me
to do all of those operations is not
going to be more than n times k
right so on average it's going to take
me k time okay
now in o46 you'll get a more formal
definition of that and you'll
get a lot of ways of analyzing things
like a potential function
and we're going to use some what we call
charging arguments even
even today um but it so it's a much
broader
uh uh analysis paradigm than what we're
going to talk about we're only going to
talk about it for this
this material with dynamic arrays and
we'll just kind of
it's just kind of an introduction to
that concept but does that make sense
amortized as a financial term right
if you know from financial term it kind
of means
over the long term this is what it is on
average right you can think about that
but that's different than running time
that's
average running time of an algorithm
right
it's it's a much different concept right
what do what is an average
running time well that that's that's
hard to define because it's talking
about
an average over all possible inputs and
then okay
maybe some inputs are more likely than
others right and so you've got a
distribution on the inputs and you're
trying to average the running time
that's a much that this has nothing to
do with that
right amortization means that you have a
usually a data structure
that you're operating on and you're
doing an operation multiple times
and you're getting a benefit because
you're doing that operation lots of
times
okay and so when you are instantiating a
python list
and you're doing push and pop operations
on the back
right that's or is it append a
pendant and pop okay i'm i've been
writing javascript a little bit recently
um but so append and pop
right those those operations while not
cheap all the time are cheap well enough
that when we analyze
an entire algorithm that might do a
linear number of
uh appends to this list right all of
those pens added together
will only take linear time because i've
done a linear number of them does that
make sense
okay long-winded uh answer to your
question sorry about that
uh any other questions before we get
going
all right so how can anyone have any
ideas of how we can
use the ideas of a dynamic array and
make it good
for operations on both ends i'll let
someone else
answer i'll give give a second and then
go to you in a second yeah
sure
that's that's an excellent idea is one
of the ways we're going to
we're going to talk about two ways of
doing this um
right so what your colleague was saying
was that in lecture when we were talking
about dynamical ways and we wanted to
make
operations on the kind of the right side
the end
uh fast right what we did was we
allocated some extra space at the end
and then when we
added things right we didn't have to
reallocate we had space to put those
things right
so what your uh what your colleague was
saying was let's just do the same thing
on both ends
okay let's leave some extra space on the
front and
extra space on the back when we
instantiate this thing
and then we can rebuild less
frequently than if we didn't have that
extra space does that make sense
okay so what we had for
let's stay down here so this is question
three
right the idea of the dynamic array
right was that we kind of
left some extra space here at the end
right so that uh sure we allocated more
than we needed to
right but when we insert things now
it's cheap and we don't have to
allocate more space for this thing until
we've done a linear number of insertions
right
this was and this was n really any
constant factor we'll do here
but if you had n things here we'd be
assured that i wouldn't need to rebuild
this thing until i've done a linear
number of operations and so
in a sense i can charge the linear time
operation of re-expanding this
thing to each one of those operations
and so on average
it'll be constant does that make sense
right so
instead what your colleague was saying
let's instantiate this thing with some
extra space on both sides
okay so now as i insert thing here
insert thing here blah blah blah blah
i'll definitely know that after a linear
number of insertions
when i rebuild this thing i'll have done
enough operations to pay
for that expensive operation does that
make sense so that's the idea behind
you know expanding this dynamic array to
be
kind of this dynamic deck right so it
does
it's a doubly ended queue kind of system
where i can
do dynamic operations efficiently on
both ends
okay so one of the things that we talked
about
uh yesterday was also removing right at
the end
right removing
uh items from the back of this thing
will decrease the number of items we're
storing right that makes sense
and maybe we're just fine with that
right but what's
what's a problem what what's as a
programmer
why might you not like just removing
items
until you got to nothing and just
leaving the space where it is
yeah it might lock up a lot of memory
yeah so
let's say over the course of my program
i use this data structure
right i'm just trying to fill it up with
stuff
and then i remove all but like two
things
right and then i go about my business i
run through the program right but i'm
i'm never really using all any but those
two things for the rest of my program
but now i've got i don't know maybe i
did put a thousand or a million or a
billion things in that
thing and then when i as i decreased
uh as i removed things from that item i
still have all that space there
being taken up by essentially is nothing
right
because i've removed everything from it
at least in my conception
right so what i would really like to
maintain with this data structure
is that at no point in time am i using
more than a linear amount of space
with respect to the number of things
that are stored in it right
does that make sense so
in a dynamic array
right what we do is when we get
small enough let's resize this thing
down
so that we have we're using less space
okay so when should i as i'm decreasing
as i'm popping things from the end of
this thing
right at what point do you think
i should rebuild my array when i'm no
longer
a linear amount well that's a little
hard to tell
what that is in real life because our
ends aren't arbitrary
we need to actually have a
a time at which we need to transition
over and copy
things over so when might we want to do
that
say again after
n over two removals okay so
i remove n over two things okay so now
we're kind of at a
n over four fill rate i mean so we're
using a fourth of the space
okay and now great so you're saying
rebuild okay so i'll stick everything
in something that's now this is
m i'm going to call this m and now we're
sticking it
into something that has size m over 4.
sound good yeah
yeah everyone okay with this
oh okay so what you're saying is that we
we actually want to keep some extra
space back here
right and why is that
because imagine if we just allocated
this amount of space
and i removed the m
over four plus one item here we resize
down to this thing
and then i want to do an insertion again
right
well then i have to re-expand out to
something like this right
and that's maybe not going to be a good
thing right we might have to bounce back
and forth
a lot that's that's hard for me to think
about what we're going to do
right but if we
always resize to a fill ratio that
includes a linear amount of things on
the end
then i know that when i resize down
you know i'll be doing either a linear
number of deletions or a linear number
of insertions before i have to rebuild
again
right so this charging argument again i
have to do a linear number of cheap
things before i have to do an expensive
thing again
okay so i resize down to
b still keep a linear amount of extra
space at the end
right and with the double ended thing
you can write the same kind of policy
right
with the extra space as your colleague
was saying we can just
resize down always to shift
these things to be placed in the middle
with a linear amount of extra space on
the ends right
does that make sense
no questions all right
that was a way in which we kind of had
to redefine an entirely new data
structure
right we took the ideas behind dynamic
arrays
and we extended those ideas to make this
thing have
extra space on both ends but we kind of
had to do that re-implementation all by
ourselves right if we were doing code
that would be kind of gnarly okay but
what if someone just
gave us a dynamic array right like what
if someone gave you a python list
right and you wanted this functionality
right
i don't want to re-implement a dynamic
array but i want this behavior so how
any way that i could do that by reducing
to using
a dynamic array this kind of running
time
no no no one no one thinks that we can
do this
this is impossible no no ideas
no ideas how could i use some let's say
i had
i have a dynamic array
right that's good on one side
is there anything i can do to support
dynamic operations on both sides of a
sequence
yeah are we able to just use like a
second dynamic already
i like oh that's supposed to be empty
right
yeah so what your colleague is saying
yeah let's do that right
let's have one pointing forwards one
pointing backwards right this is the
first of a certain thing
right when we were doing just a dynamic
array
here where we had to rebuild everything
it was important that we kept
track of where the front thing was right
so that we could do constant time
indexing right we could
as this thing changed we would now have
to compute
where our index was in this thing by
adding it to where the front was
right okay on this one
we've got some similar problems so what
i'm going to do is i'm going to divide
the sequence i'm trying to store up into
two
sections right maybe about the same size
right so each of these contains a linear
number of items
that's how i'm going to instantiate my
thing with a linear amount of extra
space on both ends
okay so now as i insert on either side
or delete from either side it's going to
work just like a dynamic array right i
have to do some arithmetic here
to figure out where if i was trying to
access these items
i'd have to like subtract from wherever
this thing was
right i'd have to do some index
arithmetic but you know that's
tedious but you know you could do it
right
okay there's one caveat one problem that
you run into
in using something like this and what
would that be
yeah i'm not sure that you can't store
things
in the second half
in here in here
right so what i'm doing here is actually
i'm thinking of this as
two dynamic arrays but i'm viewing this
one in reverse
right so this is actually
the last of this dynamic array does that
make sense
all right so if that's the situation
i'm in is am i done do i
do i have to care about anything else
you guys are all like we're done and i
would not give you full points
why aren't we done
uh well so
okay so what your colleague is saying is
we somehow have to merge these into one
array
so we're getting around that by kind of
keeping indexes
to here and being able to do index
arithmetic to kind of simulate
an array underneath right so we can
compute where these indices should be
okay anyone have another problem with
with
an underspecified data structure here
yeah
i see so what your colleague is saying
which is exactly correct
if i were removing things removing
things removing things uh i have nothing
else
in here if i try to pop from this end
again
i'm gonna have to pop from the beginning
of this thing which i don't
really that's that's gonna break
something of what i'm doing right it's
not maintaining the invariance of what i
want on my data structure
and so the only caveat here is that when
i reduce down to one of these
is empty what do i do
you could cut this thing in half move
these elements over
but that's going to leave these things
in the middle here right
the nice thing that happens here is i've
done a linear number of options
operations i have i i now
have an amortized cost buildup that i
can spend
to now rebuild the entire data structure
does that make sense
right i can now once i get down to this
thing you know take
whatever the remaining things are split
in half put it into two entirely new
arrays copy them all over
and now i've restored my invariant where
i'm again a linear amount of operations
away from having to do
an expensive operation again does that
make sense
so while we were able to reduce to using
these dynamic arrays for
a lot of the cases right we actually had
to do
a little bit more work to make this work
out
that makes sense okay cool so that's
that's two ways of approaching problem
three
okay in the last little bit
we're going to talk about the last
problem
all right that makes sense i'm going to
erase this picture if that's all right
with you guys
what's up it's not all right well too
bad
all right watch the video okay so
problem four
also a fairly
uh accessible shall we say code in
question
okay what we're doing on problem four is
we've got this
nice little story at the beginning which
is about
this this woman jen and her friend barry
who are trying to sell ice cream to
elementary school kids
they're basically lined up at jen's
truck and she's like oh there's too many
students here
so she calls up for friend barry he has
another ice cream truck
parks at the end of the line and the
students what they want to do is to make
it more fair
is they're going to take the last half
of the line reverse it
to make it more fair i don't know it's a
stupid situation
but the underlying thing is what we're
doing is part a
here is we have we're giving you a
linked list
a singly linked list
right and what i want you to do
this singly linked list all it has is
a notion of size how long it is right it
has a size and it has a head
this list it has a size and it has a
head
okay and this head is a pointer to a
node and the node has
kind of just one two two things stored
in it right
it has who which the name of the child
that's there
right and the next pointer to the next
node right that's what a singly linked
list is so
node has a an
item key and a next pointer
okay this next pointer points to the
next node in the sequence okay
and the question is asking
if we give you a linked list that has
two n nodes i want you to take the last
n nodes and reverse their order
and do this to the data structure you're
not going to return a new data structure
right you're going to do this you're
going to modify the existing nodes and
actually
here is goes back to your question right
is
uh can what are we limited to in how we
approach this problem what this uh
problem says is your algorithm should
not make
any new linked list nodes or instantiate
any new non-constant size data
structures
right so it's not like i can read
through this whole thing
find out where the n plus one node is
read out all of those names store them
in an array somewhere
and then rewrite them back out right i'm
not allowed to
store more than a constant amount of
stuff outside of this linked list and
i'm not able to make any new nodes
essentially i just have to probably keep
these items where they are
and move around the nodes yeah
uh so if you're using non-constant space
you're instantiating some kind of data
structure whether it be in
an array right or
sure i'm wanting you not to do that
yeah yeah
any other questions
so
how are we going to do this problem
anybody anyone have approach
for how i might approach this problem
yeah
in order to get to the second half you
have to
do like oh then over two times so sure
could you start
like uh i probably start counting
backwards so that you can get them
in the back order and then meet it in
the middle so then say
interesting so there's there's a lot of
things going so the
let's let's break this down so a lot of
times when we're asking you to
construct an algorithm a lot of times it
makes sense to kind of
develop an outline or a game plan of
kind of constituent parts
that you might want to approach this
problem with right like so the first
thing that your
colleague over here was saying was at
some point we need to find out where the
middle of this thing is
right does that make sense
so maybe the first thing we want to do
to approach this problem
is one
find nth
node okay that's the
end of the first set of children okay
then
i have a second thing that i want to do
what's the next thing i have to do i
have to
kind of reverse the pointers of
everything after the nth note right okay
so second thing
reverse
i guess next pointers
of everything after the nth node
right the nodes n plus 1 to 2n
does that make sense
and after i've reversed all of those
things
what do i have i have a first block this
points like that
and now we've got this thing
and we've reversed all the pointers
like this
so that's after step two is that
what we want
yeah step three would be um
you don't find the flat the pointer
so this is my new end right
i'm going to call this node a and this
node b
okay and this node c
okay so tell me in terms of a
b and c what i'm supposed to do yeah
question how old we reverse the next
pointer
i mean i get what you're talking about
like right to
actually make that happen yeah so to
actually make that happen this thing has
a next pointer
right it's pointed to some pointing to
some node but i don't necess
i'm needing to relink it to the thing
before me right so i better remember
what was before me so i can set you know
node b dot next equals the thing before
me instead of the thing after me does
that make sense
so that would be re-linking the point
next it disconnects the link list
possibly temporarily right and so
therefore it still works out
well we have to relink everything to
make sure it's temporary
right if we i mean it's very possible
when you're dealing with linked data
structures
to unlink something and not have a
reference back to it and
now this thing is in memory that your
garbage collector hopefully will
pick up but if you're writing in a
language that's not garbage collected
then that's called the memory leak right
that's no good okay so
how do i relink these things
right this is the picture that i have
right now how do i make this into a
linked list where
it's here and then reversed
yeah so i replace this pointer from a to
b
to make it point to c instead and then
whatever my pointer is to b
from b b is reversed right it's pointing
to a let's set that equal to none
right so basically the last step here is
clean up ends all right
and in a latex write-up
right you'd want to specify what are the
things that you're re-linking okay
but this was a coding question and so we
actually gave you code to work with
okay so i'm going to see
whether i can live code this for you in
front of you
okay so here was uh
our code submission site from last term
okay
and what i have here is my template from
last term
pset one it opens this folder okay it's
got a bunch of things in it
the template the latex template that you
have
and then a bunch of these python files
okay so i'm gonna
uh where is it here okay so these are
the files that are in my directory
i've given you a version of this linked
list sequence
uh and then we have two more code
questions a test file and a reorder
student's file right
so reorder students look something like
this
okay it has a template of the code that
we're going to want you to write with
inputs and outputs and you're putting
your code here right and
this function doesn't need to return
anything all right and then
we also give you this link list
implementation which is what's in your
recitation
handout right i'm actually going to
ignore most of this stuff
really just that this thing contains a
item in
next in your node i'm not actually going
to look at the items at all
and a head and size in my linked list at
the top level
okay but this is just to kind of tell
you what's in there
right so that's what's going to be input
to my thing
and if i go here and i run
the tests document that you gave me it
fails because i don't have anything
it didn't do anything to the list okay
right uh and in fact if i go into here
to the tests
and uh you know
i uh what is it it's reordering the
students here i print the
the linked list that you gave me i'm
going to
have a line break here what we can see
is
when i do this okay here are my test
cases
here's a linked list right and what's
happening is it's just spitting out the
same linked lists right i haven't done
anything to it
right all right so we need to do
something to it
how are we going to do that all right so
let's let's implement this function and
i'm going to get rid of this
stuff because get rid of that all right
so we need to reorder this student so
i'm going to break this under the three
parts that we have here
we're going to find the nth node so how
do we find the nth node
well we have a saw this thing has a size
on it
so let's at least figure out what n is
right so let's set
n equal to uh i think i can use
length right because i've implemented
that on my thing and it's going to be
whatever the length is over 2 and i'm
defined by the problem statement that
i'm only going to have even inputs
okay and i'm going to set
at first my a
to be the starting place okay i'm going
to just have a little temporary variable
that's going to say
this is going to be equal to the head of
my list okay
and what i'm going to do is what your
colleague was saying is i'm just going
to loop through
end times until i reach the end thing
actually
how many times do i have to travel
through next pointers to get to
node a and minus 1
actually yeah so this is going to be 4.
i don't care about this loop variable
so i'm going to just use that n minus 1
times
right what am i going to do i want to
replace
a with the thing it's pointed to right
so i'm going to just walk down this
thing
a equals a dot next
okay and now after the end of this loop
what is a
a is the nth node right i've now
made it the nth node fantastic okay so
and now i'm going to say that b is going
to be the next one
right i'm just just in terms of my
write-up i labeled these things as a
and b and c and so in my mind i'm going
to want to use the same kind of
notation here so that i can understand
my code okay so b
is going to be the next thing okay
and now in this process as i'm going to
flip things around what i'm going to do
is i'm going to keep track of three
notes
i'm going to keep track of x which is
the node that i'm
going to be relinking and what else do i
need to keep track of
if i'm destination yeah where i came
from and where i'm going to
right because that's what i'm going to
need to relink right in particular
i'm going to have someone pointing to me
which i'm going to call
next previous right or
no the x previous and the next thing
when i'm going
to uh label it it's going to be the next
thing all right does that make sense
so in in my first situation
i'm my the first thing i need to relink
is b
right so that's going to be my x and the
x previous is going to be a
does that make sense so i'm going to
instantiate those two variables
x and xp are going to be
b and a sorry that's
right yeah maybe it makes more sense to
have
x previous and x equal a b
all right that's in in the right order
all right that's
either way is fine and then i i want to
go through a loop this
i'm going to be doing in the loop way
you can do it a recursive way if you
want
okay here's a loop way in which i'm just
going to loop through how many times
how many pointers am i going to relink
as i go down this thing
i need to re-link the pointers of all of
these guys how many are there
how many n there are n of them right so
four i don't care about the loop
variable here either
i'm going to do this n times and what am
i going to do
i'm going to first figure out who my
next guy is
okay i'm going to set xn
equals what x dot next all right so now
i know
who's next to me right so i can
go there later after i relink my pointer
i'm remembering that
okay now i i
don't care about what's stored in x dot
next because i've stored it locally
right that makes sense all right so now
i
am free to re-link that next pointer to
my previous guy
all right and now i can
essentially shift my perspective over
so the thing that i'm going to relink
now is the next one
okay so uh x
previous and x now
equals x x next does that make sense
just re-linked things over okay
so that's the end of step two now as i
all
as i got down this at the end of this
for loop where is x
what is x p x and x next or x n
really i'm only keeping track of x and x
p
here right so what are x p and x at the
end of this loop
i've done this n times i started
with b at x right
so what is x yeah
so we have a vote that x is c okay
so this is a little interesting all
right i agree i will tell you that c
is either xp x or xn
okay so we have one vote for x who says
something else
eric doesn't like x
so any there are only two other choices
just someone say something
xp well i will argue that it is xp
all right why because i'm at b
there are eight n things i did n
operations
right and every operation i move one
over right
so when i've done n minus 1 things i'm
at c
the nth one now x is none because
there's no pointer at the end of the
list
so xp is c so i'm going to set
p equal to xp which is it's just for me
to remember what these things are
and i just re-link these two pointers
right a dot next
should be c and b
dot next should be none
right does that make sense everybody
let's see if we did it right so we saved
that thing
and we run python
on the test cases and it did the right
thing apparently
right maybe uh let's see ran five test
cases
okay all right so let's take a look at
this
we had this linked list lily sally cindy
maisie sammy davey
and what it turns into is lily sally
cindy which is correct
and then it reverses this last part of
the list danny sammy
maisie cool awesome
but these are the test cases we gave you
so let's try this against
our code checker so i select the file
where do i go i think i'm in my desktop
here
and session one and template and reorder
students
i submit it please work please please
and a hundred percent and now we're
happy and we can go party okay
all right so that's uh the first problem
session hopefully this was helpful to
you
uh we will release uh problem set one
tomorrow
uh and good luck on it
you