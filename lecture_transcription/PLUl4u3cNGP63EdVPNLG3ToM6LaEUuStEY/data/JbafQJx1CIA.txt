today we're going to
in one lecture cover an entire field
which is computational complexity
um it's sort of uh
it meets algorithms in an interesting
way which is algorithms is mostly about
showing how to solve problems well and
showing that you can solve a problem
well
and computational complexity is more
about the lower bound side proving that
you can't prove
you can't solve a problem very well you
can't find a good algorithm to solve it
we've seen a little bit about lower
bounds several lectures ago
proving search and sorting lower bounds
in the in
bounded branching decision tree model
but these are much stronger notions of
badness
this is not about n versus n log n or
constant versus log n this is about
polynomial
versus exponential which has been the
sort of bread and butter model of in
this class polynomial is a good running
time and we're always striving for that
exponential is usually pretty trivial to
get
and so we're going to talk about some
different they're called complexity
classes
that talk about this issue and different
ways to prove hardness
this is a pretty high level lecture so
you're not going to be expected to be
able to prove hardness but you'll get a
flavor of what it's like
and this will segue nicely into other
follow-on classes which is
we're at pretty much the end of 006 so
natural to
talk about what other things you might
study
one result we'll prove today is that
most problems
are actually have no algorithm which is
kind of shocking
and lots of other fun things so let's
get started with
the notion of p this is a set of all
problems solvable in polynomial time
we talked about what polynomial time
means a bunch last lecture
so just recall that polynomial time
means polynomial
in the problem size which i'll denote as
end
here
the number of words in your input
okay so these are the problems that are
efficiently solvable
p is set of all of them and for contrast
x is the set of all problems solvable in
exponential time
so problems solvable
in exponential time
exponential here means something like 2
to the n to the constant
this is one reasonable definition of
exponential so just the exponentiation
of this
of polynomial so as you might
expect most problem every problem that
we've talked about in this class
so far can be solved in exponential time
rather easily
and algorithms in some sense is about
distinguishing these two which problems
are
in p versus are in say x minus p
so to formalize this a little bit i'm
going to draw a picture
which is a bit of a simplification of
reality but
for the purposes of this class will
suffice and i think is a really helpful
way to think about
things which is to have a big axis for
a single axis for how hard is your
problem what is the difficulty of
solving your problem
and i want to be sure to leave so the
easiest problems are over here
and each problem is a dot on this axis
hardest problems are way down
the line and i want to make sure to
leave enough space for all the things i
care about
so p i'm just going to call this segment
up front and then i'm going to have
a bigger thing for
exponential time
so this is just to say that p is nested
inside
x every problem that can be solved in
polynomial time can also be solved in
exponential time because polynomial is
less than or equal to exponential
these are just upper bounds x
being an x means you're somewhere from
this line to the left being in p
means you're somewhere from this line to
the left in terms of difficulty
but formally we would write p is
contained in
x as sets in fact they're
also known to be different from each
other
they're problems that can be solved in
exponential time that cannot be solved
in polynomial time
for example
put that here sure
for example n by n chess
is in exponential time
but not polynomial time so what is the n
by n chess problem
this is i give you an end by end chess
board and i
describe to you uh a position here's
where all the white pieces are here's
where all the black pieces are
you can have an arbitrary number of
queens and bishops and pawns of each
color
of course up to n squared of them they
don't overlap each other
and i want to know uh does white win
from this position let's say it's white
to move can white win
and that problem can be solved in
exponential time by exploring the entire
tree
of all possible games but it cannot you
can prove that it cannot be solved in
polynomial time
so that's a nice example a more positive
example
so to speak is negative weight cycle
detection
it's literally negative but it's morally
positive
negative weight cycle detection is the
following problem i give you a graph a
directed graph
with weights and i want to know does it
have a negative weight cycle yes or no
and this problem is in p
because we saw a polynomial time
algorithm for this
you run bellman ford on an augmented
graph so this is
an example of a problem we know how to
solve this whole class is full of
examples that are
that we know how to solve in polynomial
time but this is a nice
non-trivial and succinct one to phrase
it's also an example of a decision
problem a lot of basically all the
problems i'll talk about today
are decision problems like we talked
about last class meaning the answer is
just yes or no
can white win from this position yes or
no is there a negative white cycle yes
or no
tetris we can also formulate as a
problem
this is a version of tetris that we
might call perfect information
perfect information tetris suppose i
give you a tetris board
it has you know some garbage left over
from your past playing or maybe it
started that way and i give you the
sequence of
end pieces that are going to come and i
want to know can i survive this sequence
of end pieces
can you place each of these pieces as
they fall
such that you never overflow the top of
the board
on an n by n board this problem can be
solved
in exponential time but we don't know
whether it can be solved
in polynomial time
uh we will talk about that more in a
moment it's a problem that
very likely is not in p but we can't
actually prove it yet
all right uh so there's one other class
i want to define at this point and we'll
get to a
fourth one also but r
is the class of all problems that can be
solved in
finite time r stands for finite
r stands for recursive actually this is
a notion by church
way back in the foundations of computing
as we know we need
we write recursive algorithms to solve
problems in the beginning that was the
only way to do it now we have other ways
with loops but they're all effectively
recursion in the end so r is all the
problems that can be
solved in finite time on any computer uh
so very general this should include
include everything we care about right
and it's bigger than x it includes
problems that take doubly exponential
time or whatever uh
so i will draw a
region for r so everything includes p it
includes x
and so we also have containment but not
equal
r there's of course many classes in
between
you could talk about problems that take
double a exponential time and that would
have a thing in between here
or there's also between p and x there's
a lot of different things
we will talk about one of them but
before we get to
the finer side of things let me talk in
particular about
r so we have a nice example
we being computational uh complexity
theory or i guess it's usually
just called theoretical computer science
has a problem
and if you're interested in this you can
take
one i think no that doesn't sound right
that's probability it'll come to me
we have an explicit problem that is not
in r
so this class has been all about
problems that are in p do you have the
number
604 604 5. thank you so close to this
this class or it's so close to 6046
which is this
natural successor to this class so 6045
would talk about this
so this class is all about problems that
are in p which is very easy
but in fact there are problems way out
here beyond r
and here is one such problem
which we won't prove here today it takes
a whole lecture to prove this
given a computer program
does it ever halt
does it ever terminate this would be a
great thing if we knew how to solve it's
basically an infinite loop detector
if your problem doesn't halt then it has
an infinite loop of some sort
and you'd like to tell your user hey you
have a bug in your program
so this is one part of bug detection and
it's impossible there is
no algorithm that always saw that solves
all inputs to this problem
maybe given one program let's say has
zero lines of code
it could solve that it says yeah that
one terminates and maybe you can detect
simple kinds of infinite loops
so there's some inputs some computer
programs that you could detect
but there's no one algorithm that solves
all
inputs so this is kind of sad news
we call such problems uncomputable this
is just another word for
being not in r
okay and next thing i'd like to do is
prove to you that most decision problems
are uncomputable
or sketcher proof
so remember decision problems are
problems where the answer is just yes or
no
this is a very special kind of problem
and even those almost all of them
cannot be solved so halting is an
example of a problem we want
uh we can't solve this whole class 006
is about problems we can solve but today
i'm going to show you that actually
those are in the minority most problems
cannot be computed this is very strange
and also a little depressing
so we'll talk more about that in a
moment first let me argue why this is
the case
so we i'm going to be a little informal
about what is
what exactly is a computer program and
what exactly is a decision problem
but roughly all i need to do
the only level of precision i need is
just to count how many are there
what is a computer program well it's
usually a file
well it's a file it's like a string of
characters what's a character
it's a string of bits so a program is
just in the end a string of bits
finite string of bits
we all understand that whatever language
you define
in the end your every program is just a
string of bits
and a string of bits we can translate
into a number
so we can convert between strings of
bits
and numbers when i say number i mean
what's usually called a natural number
or a non-negative integer um
this is usually represented by uh bold
board
bold board bold
blackboard bold ant capital n so this is
just
you know zero one two and so on
okay now what about decision problems
decision problem is a specification of
what we want to solve so we can think of
it as saying
for every input is the answer yes or no
that's
literally what a decision problem is the
only question is what is an input
and we've talked about inputs and the
size of inputs and
and there's lots of different ways to
measure them but in the end we can think
of an input as a string of bits also
it's just a file so a decision problem
is a function
from inputs
to yes or no
and inputs we're going to say well
that's uh you know string of bits
which we can associate
with a number
in n so here we can start to tie things
together
so in other words a program is a finite
string of bits
and a problem is in some sense an
infinite string of bits because there
are infinitely many possible inputs
and for each of them we specify yes or
no
so this is basically
an infinite
string of bits
so we can imagine you know zero one one
zero one
zero zero zero one one one zero
infinitely
um just some for every string of bits we
can say okay
if your input is the number zero here's
the answer
no if your input is uh the number one
then the answer is yes if your input is
the number two your answer is yes and so
on
down this line every infinite string of
bits corresponds to exactly one decision
problem
which specifies for every possible input
integer which corresponds to a string of
bits
what is the answer yes or no so this may
seem subtle
or it may seem like not a big deal this
is a finite string of bits
this is an infinite string of bits but
mathematics has well studied this
problem
and infinite strings of bits there are
very many of them
uh infinitely many it's not surprising
they're also infinitely many
integers so that's maybe doesn't seem
that deep
but there's a difference
in infinitude programs
and integers are countably infinite
and infinite strings of bits are what's
called uncountable
i think the most intuitive way to see
this is
an infinite string of bits if i put a a
decimal or a binary point in front
this encodes a real number between 0 and
1.
so this is roughly a real number
in 0 1 and when i'm writing
approximately equal here this really
goes in both directions right given the
decision problem i can define a string
of bits
of course giving me the answer for all
inputs and i can convert that into a
real number between zero and one but
also the other direction if i take any
real number
that is a corresponding decision problem
these are one to one
bijection between them and the bad news
is real numbers are uncountable
and natural numbers are countable which
means
there's a lot more of these than there
are these
so one may way you might phrase this
is informally
is the number of natural numbers is way
smaller than the number of real numbers
and so from that
we derive that most problems are
unsolvable because
every program solves exactly one
decision problem we can also
run a program conceptually on all
possible inputs and we will figure out
what function it's solving
and if we don't allow random numbers in
our program which i'm not here
then every program solves exactly one
decision problem
possibly it's even worse for us because
multiple programs probably solve the
same decision problem
they're just they add irrelevant lines
of code or they don't do anything
different
or you know you run bellman ford versus
running bellman ford five times
you'll get the same result and that's
actually the bad direction for us we'd
like to know whether there is a
program that solves every decision
problem
and because there are only this many
programs and this many decision problems
it just there aren't enough to go around
so most
what's the phrasing not nearly enough
programs for all problems
and so there's no assignment
of programs
problems because there's just too many
problems
more money more problems i guess um
so when i first saw this result i was
shocked and dismayed that
why are we even doing computer science
if most problems can't be solved
luckily it seems like most of the
problems we care about can be solved
that's what this class is all about and
in fact even the problems that seem
really really hard for us to solve
like n by n chess where we can prove it
takes exponential time
there is an algorithm to solve chess
it's just really slow
this is a statement about most problems
can't even be solved in finite time no
matter how much time you give them
so it's not all bad
sort of luckily
most most problems
we care about
are in our i don't know why
this is sort of a mystery of life but
it's good news or it's why
we keep persevering trying to solve
problems with algorithms
the statement tends to be small
well i mean this so the question was
well maybe it's just because the short
statement
problems are easy but this is a pretty
short statement
and it's hard uh i think
i don't have a great reason why i wish i
understood uh is there's a general
result that if you have any question
about a program itself
then there's no algorithm to solve it
basically any non-trivial question about
programs is heart
uh it's not in our and i guess if you
took
i mean if you imagine taking a random
statement of a problem then maybe this
will be in the middle of it with some
probability
uh maybe that's why most but this is a
very strong notion of most there are so
many more real numbers than natural
numbers that i don't know
all right i want to add one more class
to this picture
which is np
it nestles in between p and x
so we know that p
is contained in or equal to
np and np is contained in or equal to
x we don't know whether there's a
quality here or here
probably not but we can't prove it but
what is this class
a couple of different ways to define it
you might find one way
or the other more intuitive they are
equivalent so
as long as you understand at least one
of them it's good
np is just a class of decision problems
so i define p
and x and are arbitrary they could be
problems with any kind of output but np
only makes sense for decision problems
and it's going to look almost like the
definition of
p
problem solvable in polynomial time
we've just restricted to decision
problems
but we're going to allow a strange kind
of computer
or algorithm which i like to call
a lucky algorithm
and this is going to relate to the
notion of guessing that we talked about
for the last four lectures in dynamic
programming
with dynamic programming we said oh
there are all these different choices i
could make
what's the right choice i don't know so
i'd like to
make a guess and what that meant in
terms of a real algorithm is we tried
all the possibilities and then took the
max or the or or whatever
over all those possibilities and so we
were
but what we were simulating is something
that i call a lucky algorithm which can
make guesses
and always makes the right guess this is
a computer that is
impossible to buy it'd be great if you
could buy a computer that's lucky
but we don't know how to build such a
computer
so what does this mean
so informally it means your algorithm
can make lucky guesses and it
always makes the right guess and whereas
in dp we had to try all the options and
spend time for all of them
the lucky algorithm only has to spend
time on the lucky guess
on the correct guess more formally what
this
is is called a non-deterministic model
of computation
and this n is the the n in
non-determinism is the n for np so this
is non-deterministic polynomial time
uh so algorithm
can make guesses
and then in the end it should output
yes or no
so like say if you're exploring a maze
this algorithm could say
uh should i go left or go right i'm
going to guess whether to go left or go
right
and let's say it guesses left and so
then it just goes left and then it
reaches another junction and says should
i go left
or right and i'll say i'll guess and
let's say i guess right this time
and in the end if i get to some dead end
maybe and i say no
or if i get to the destination i'm
trying to get to i say yes so that's a
non-deterministic algorithm
and what happened what does it mean to
run that algorithm
what does it mean for the guesses to be
lucky
here's what it means these guesses
are guaranteed which way you end up
going
is guaranteed to lead you to a yes if
there is one
if possible so in my maze analogy
if it is if my destination is reachable
from my source
then i'm guaranteed whenever i guess
left or right uh
i will choose a path that leads me to my
destination
whereas if the destination is in some
disconnected part of the maze
and i can't get there then i don't know
what the guesses do it doesn't really
matter because no matter what i do i'll
end up in a dead end and say no
okay that's the that's the model as long
as you have an algorithm that always
outputs yes or no
uh in polynomial time because we're only
talking about polynomial time lucky
algorithms
uh if there's any way to get to a yes
then
your machine will magically find it
without having to spend any time to make
these decisions
so it's pretty magical computer and it's
not a computer that exists in real life
but it's a computer that's great to
program on it's very powerful
you could solve lots of things with it
yeah if you have this magical
computer you can guess whether it's yes
or no why doesn't it just
answer the question right so
what if we so a nice check is does this
make all problems trivial all decision
problems
maybe i should say well i don't know
whether the answer to the problem is yes
or no so i'll just guess yes or no
this is problematic because
so i might say it will guess a or b and
if i choose
the a option i will output yes and if i
choose the b option i'll output no
in this model that algorithm will always
output yes
because what it's saying is if there's
any way to get to a yes answer
i will do that way and so such an
algorithm that tries to cheat and just
guess the whole answer of the problem
will actually end up always saying yes
which means it doesn't solve a very
interesting problem it only solves the
the problem which is represented by the
bib vector 1 1 1 1 1 1 1.
where all answers are yes but good good
check
yeah does there have to be a bound on
the number
of things it has to choose between
yes
uh exponential number of choices is okay
um i i you i usually like to think of it
as you can only guess one bit at a time
um but that but we're allowed polynomial
time so if you're actually allowed to
guess polynomial number of bits
at that point you can guess over an
exponential size space but not more than
exponential
cool so it's it's yeah polynomial time
let's say in the one bit guessing model
did i say makes guesses let's let's add
binary here
otherwise we get some other class which
i don't want
okay let's let's do an example of a real
example of such an algorithm that's
useful which is tetris
so i claim tetris is in np
because there is a lucky algorithm an
undeterministic
polynomial time algorithm that can solve
the tetris game
so again you're given a board you're
given some sequence of pieces
and you want to know whether you there's
some way to place the pieces that lets
you survive
and so what i'm going to do is for each
piece
i'm going to guess how to place it
so for the first piece i'm going to
guess you know how how far left or right
do i move it then i let it fall one step
maybe i rotate it i choose a sequence of
moves
among left right down rotate right
rotate left
and all along the way i make sure i
check is that move valid
if the move is invalid at any point i
just say return no
and then if the piece gets nestled into
a good spot i continue to the next piece
i do the same thing guess all the
possible things i could do to that
again i only need to guess sort of one
bit at a time
and i'll only need to do a polynomial
number of guesses like a linear number
of guesses for each piece
about where it falls in so maybe a
quadratic number of guesses overall
and then at the end if i survived oh i
also have to check if a line clears
then i clear the line and if in the end
i survive
i return yes so this is a
non-deterministic algorithm
so i would say check the rules of the
game
and if we survive
return yes
and if at any point we violate the rules
for example we go off the top of the
board
we return no so this is an algorithm
that sometimes returns known sometimes
return yes
depending on what choices you make and
this model guarantees if there's any way
to get to a yes
it will find it if i swapped these
answers
if i returned yes when i violated the
rules and returned no if i survived
this would be an uninteresting algorithm
because it's very easy to lose in tetris
the hard part is to survive if i say is
there any way to play the game in such a
way that i violate the rules then of
course the answer is yes
you can just stack pieces and go off the
top there's an asymmetry
in this definition of yes versus no
right
it always finds yes answers if possible
it doesn't always find no answers if
possible so it's very important the
the way that i wrote these questions
it's important that i define tetris as
the problem of can i survive
the problem of can i not survive is it
impossible to survive
that's a different question that problem
is not an np probably
okay so slight subtlety there yes versus
no
let me give you the other definition of
np so if this one's confusing which
although i prefer this definition most
people do not
so this is confusing let's do the other
definition
so another definition
is that np is a set of decision problems
ah
that can be checked in polynomial time
this actually came up in the last
lecture where we talked about subset sum
i said here's a bunch of integers here's
a target integer
and i can prove to you that this integer
can be represented as a sum of
numbers from my subset of numbers from
my set
because here they are i gave you this
plus this plus this
equals a target sum and so that
is a solution in some sense that can be
checked
for a yes example if i can represent my
number as a subset sum of a given set
it's easy for me to prove that to you
and you can check it just by adding up
the numbers
and checking that each number was in the
set
whereas no instances we had an example
of a target sum that could not be
reached and the only reason i knew that
is because i had brute force the thing
and there's no succinct way to prove to
you
that that number can't be represented a
similar thing with tetris
what i would say is so this is version
one
version two for tetris is that
a certificate
for a yes
input of tetris is
a sequence of moves for the pieces
okay if it's possible to survive in
tetris i can prove it to you
i can just play the game and show you
that i survived
no answers i don't know it's hard to
prove to you that i can't survive a
given sequence of pieces
but yes answers are easy i just show you
here's here's the sequence of
button presses i'll do for this piece
then for this piece then for this piece
notice
it's exactly the same thing that i
guessed in the beginning of this
algorithm
and then i did some other work to
implement the rules and similarly if i
gave you a certificate which is the
things that i wanted to guess
of how to play the game i can check this
certificate
by just implementing the rules of tetris
and seeing whether i survived and if
you violate the rules at any point you
say no and if you
survive you return yes that's what's
called a verification
algorithm so let me formalize this
notion
given a problem input
plus a certificate
like that one over there
there is a polynomial time so this isn't
yet another definition this is what i
mean by this definition of np
a verification algorithm
that satisfies two properties one is
for every yes input so every input where
the answer is yes
to the problem there exists a
certificate
such that the verifier says yes
so this is saying it's possible to prove
to me that an answer is yes because if
there's
if you ever have an input that the
answer happens to be yes
you can prove it to me by giving me a
certificate there's always some
certificate that proves
the answer is yes because the verifier
which runs in regular polynomial time
this is a regular
old-fashioned down-to-earth verification
algorithm
polynomial time in our usual sense it
will say yes
and furthermore the yes answers from the
verifier are actually meaningful
because if i ever give it a no input
it always says no no matter what
certificate i give it
so this should really formalize what all
this means is equivalent to the previous
definition
this is saying that proofs exist for yes
instances
and this is saying that proofs don't
exist for no instances meaning there are
no false proofs
so if the verifier ever outputs yes you
know that the answer to your problem is
yes
but if it outputs no you're not sure
maybe you got the certificate wrong
because we only know there's some
certificate where the verifier will say
yes or maybe it was a no input and then
it didn't matter what certificate you
used
but it's nice because it says on say
tetris if i give you the sequence of
pieces
it's very easy to write down a verifier
which just implements the rules of
tetris
and so then you can at least check
whether a solution is valid
in the yes case in the no case we don't
have anything useful
so np is a structure some additional
structure about
the yes inputs in your problem and a lot
of decision problems are in nnp
a lot of the problems that we care about
can be phrased as an np
problem as long as it's a decision
problem usually answering yes or no
is provable like subset sum
like tetris these are all problems where
if the answer is yes
i can give you a convincing proof why
and it turns out a lot so a lot of
problems fall into this np setting
and so we have some tools for talking
about
problems being
hard with respect to np let me first
talk a little bit about
p does not equal np
uh question mark um a lot of people
conjecture that p does not equal np
it's sort of a standard conjecture in
theoretical computer science but we
don't know how to prove
whether p equals np or or does not equal
np
and so in this picture i've drawn the
hypothesis which is that np
is a strictly bigger region than p is
but we don't actually know whether there
are problems in this
region we don't know whether there are
problems in this region between
np and x we conjecture there are
problems here and there are problems
here
there's definitely problems here or
problems here but we don't know which
one because we know p does not equal x
but we don't know whether p equals np
and we don't know whether np equals x if
you could prove
that p does not equal mp or disprove it
you would win a million dollars which
not that much money these days but you
would be famous
to for the rest of time if you could
ever prove this
every year there's usually a crackpot
proof that
doesn't work out some of them go to me
please don't send them and anyway the
it's it's a very hard problem it is sort
of the core problem with theoretical
computer science
how to prove peter's nautical mp but for
the most part we just assume it
uh now what does this conjecture mean it
essentially means
the way i like to say it is you cannot
engineer luck
because np problems are problems you can
solve by lucky algorithms
p are problems you can solve by regular
old algorithms
and so if p equal to np it means luck
doesn't buy you anything which seems
weird like if i can magically make these
super powerful guesses
uh then i can solve the problem that
that's np
that seems super powerful way more
powerful than regular algorithms
where we have to actually brute force
and try all the choices
um and so it seems seems pretty solid
that p d is not equal to p
that's my my of course we don't know how
to prove it another phrasing is that
it's harder to
come up with proofs than it is to check
them from a mathematical perspective
this is equivalent to p does not equal
np
so that's why you should believe it now
let's go over here
the next notion is
np hardness
so in particular i want to claim this is
a theorem that exists in the literature
that if p does not equal np
then tetris is not in p
so i said right here tetris is in x but
we don't know whether it's in p
but in fact we conjecture is not in p
because we conjecture that p does not
equal
p if you could prove this conjecture and
there's a lot of theorems that are
conditioned assuming p does not equal np
then we get some nice results like
tetris cannot be solved in polynomial
time
i cannot figure out whether to win
whether i can win a tetris game
in polynomial time in the input size
why this is a
consequence of another theorem
which is that tetris
is np hard i'm going to define
mp hard informally first and then i'll
define it slightly more formally in a
second
but this means roughly
that tetris is as hard as
all problems in np
so let me draw this in the picture
so np hard is
this part oh
did i leave myself enough room maybe not
well we'll squeeze it in there's another
region here
for x-part
so your problem being an np was a
positive result it says you're no more
difficult than this
line you're either at this position or
to the left
being in p is also a positive statement
says you're here or to the left
being in p is better than being in np
because this is a subset of that
np hard is a lower bound it says
you are at this point this level of
difficulty or to the right
and so it goes from here off to infinity
in difficulty
and x part says you're at least as hard
as the right extent of the x
uh set uh or you're harder than that
in a sense that we'll formalize in a
moment
and this place right here as you might
imagine is
kind of interesting it's exactly where
np meets np hard
this thing is called np-complete
you probably have heard about mp
completeness the famous notion
and this is what it means it is
the problems that are in np so they have
a lucky algorithm that solves them they
can be verified their certificates they
can be verified
and they are np hard so they're in np
and they are the hardest among problems
in np
now they're not the hardest problem
they're actually many problems
right here at this single level of
difficulty called mp complete
among them is tetris there are many
others which i will list in a moment
so that is mp completeness so
because these problems are the hardest
problems in np
if there's any problems here in between
in np minus p
then these must be among them and so if
you assume
that p is not equal np as most people do
then you know that all problems at this
rightmost extreme of np the hardest of
the problems in np
they must not be in p and that's why i
can say if p does not equal np
tetris is not in p and also any mp
complete problem is not np
okay what does as hard as
mean
this is our good friend
reductions
we talked about reductions a lot in this
class
reductions are the easy way to use
algorithms you just take your problem
and we reduce it to a problem you
already know how to solve
you take the input
to some problem that you want to solve
and you convert it
into an input to some other problem
like single source shortest paths or
something like that that you already
have an algorithm for solving
so if you have an algorithm that solves
problem b
you can convert that into a solution for
b
and a reduction should also tell me how
to given a solution to b
how to convert it back into a solution
for a
and when i say solution here i actually
mean certificate from over there
uh so how
like so if i um yeah
okay so if i have so reduction consists
of these two pieces
how to convert an input at a to an input
for b given a solution to b
how to convert it to a solution to a let
me give you some examples of reductions
you've already seen you've seen a lot of
them
if i have unweighted shortest paths on
the left
unweighted
[Music]
single source shortest paths i can
reduce that
to weighted shortest paths how
set all the weights to one so here i'm
given a graph without weights if i set
all the weights to one
that turns it into an input for weighted
string of source source pads so if you
didn't know how to solve this you could
solve it by converting it if you've
already written say a dijkstra algorithm
you could
apply it to solve unweighted single
source shortest paths now we know a
faster way to solve this
but you know it's only a log factor
faster and here we're talking about
polynomial versus exponential
okay so this is a valid reduction it's
not the most interesting one from an
algorithmic standpoint but it is an
algorithm
another one we have uh we've seen is if
you have integer weights on the left
you can convert that to unweighted on
the right
by positive integer weights by
subdividing each
edge of weight w into w edges
of no weight so that that's
maybe a little bit less efficient it
depends how what the sum of the weights
are
another version that we've seen is
longest path in a graph
we can weighted path uh we can reduce to
shortest path in a graph
weighted by
negating all the weights we did this in
some of the dynamic programming things
like oh
longest path in a dag we can convert
that into shortest path and tag just by
negating all the weights so these are
all examples of converting
one problem to another usually you
convert from
for algorithms you convert from a
problem you want to solve into a problem
that you already know how to solve but
it turns out the same tool of reductions
can be used to prove
negative results too and in this case
we're going to
reduce from a problem that we think
cannot be solved
and reduce it to the problem that we're
interested in solving
okay so let me write more precisely what
this
means if you can find a reduction like
this it means that solving a
is at least as easy
as solving b right because
i could solve a in particular by
converting it into b
solving b and then converting it back to
the solution to a
so in other words if i can solve b i can
solve a which is
i can phrase informally as a is at least
as easy as b
and now using uh grammar or
contrapositive whatever
this is the same thing as saying that b
is at least
as hard as a
and this is what i mean by at least as
hard as so this is my definition of at
least as hard
in this notion of np hardness
okay so what np hard means is that i'm
at least as hard as all problems in np
and so what that means is every problem
in np
can be reduced to tetris which is kind
of funny
but in particular that means that if
there's an algorithm for tetris there's
an algorithm for all problems
in np and so that's actually the
contrapositive of this statement
so saying if there's a polynomial if i
take the contrapositive this this is
saying if there's a polynomial time
algorithm for tetris
then p equals np there's a polynomial
time algorithm for every problem in np
and the way we prove that is by
reductions we take an arbitrary problem
in np
and we reduce it to tetris luckily
that's not as hard as it sounds because
it's already been done once there is
already a reduction from
np to from all problems in np
to singular problems out there the mp
complete problems there was some first
mp complete problem which
i guess is turing machine
non-determinant it's basically
simulating lucky algorithm so it's kind
of a not very interesting problem
but from that problem if you can reduce
it to any other problem you know that
problem is np-hard as well
and so briefly i want to show you some
examples of that
here so
i want to start out with a problem that
i'm just going to assume
is mp complete and it's called three
partition
um it's one way to phrase it is i give
you a bunch of
integers i think i have it written down
over here
also the board i give you n
integers and i'd like to divide them up
into n over three groups of size three
such that each group of size three has
the same sum
uh as it's written up there on the board
uh so you can also think of this as the
following problem i give you a bunch of
rectangles that are
a side length or a bunch of sticks let's
say of varying lengths
and i want to group them up like on the
right diagram
so that in groups of three such that the
total length of each group
is exactly the same okay this is just a
problem
and just believe for now that is mp
complete i won't prove that
but i'd like to do what i'd like to show
you is a reduction from this problem
to another problem solving jigsaw
puzzles
uh so you might think jigsaw puzzles are
really easy
and especially easy if i lose the
projector
but in fact if you have a jigsaw puzzle
where some of the
matches are ambiguous if there's
multiple pieces that could fit against a
given tab
or pocket then i claim i can represent
this three partition problem by building
little sticks
like here so if i want to represent a
stick
of length a i i'm just going to build
and ai i didn't mention they're all
integers and they're
polynomial sized integers
i'm going to represent that by about by
ai
different pieces here and the red
tabs and pockets are designed to be
unique global to the puzzle like a
regular jigsaw puzzle
given this piece on the left and this
tab on the right there's a unique pocket
there's a piece with a unique pocket
that fits perfectly into that piece so
this
this joining is forced and also this
joining is forced
but the blue tabs and pockets are
different they're all the same
they're all identical and so if i build
this frame
using the you know red unique
assignments and i build these rectangles
if i want to pack these rectangles into
this rectangle that's exactly the three
partition problem
with some details that i didn't fill in
but it turns out
you'd be forced to group these into
groups of size
three something like this
varying lengths but
okay so that's an example of reduction
if you believe the three partition is np
hard this proves to you
that jigsaw puzzles are np hard
something you may not have none
every time you solve a jigsaw puzzle you
can feel good about yourself now
especially if it has ambiguous mates
next is tetris so here is a reduction
from the same three partition problem
which is one of my favorite problems to
tetris it starts out with this strange
board it has a bunch of
columns here where i could put pieces so
i'm not allowed to put pieces in these
dark regions
they all have height t t is the target
sum
that we want all of the numbers to all
the triples of numbers to add up to
and there's n over three of these uh
slots where i can try to put pieces
and it's because of this thing over on
the right there's no way to clear lines
in this game and now to represent a
single number ai i'm going to give you
this sequence of pieces which starts
with an l piece
and then it has a i repetitions of this
pattern
and then it ends with these two pieces
and so what ends up happening
is that this is in the intended solution
you first place an l at the bottom of
one of these
buckets and then you repeat this pattern
in this nice way
and it fills up the ai roughly height
of this bucket and then at the end you
have to put the eye here
and what this guarantee what this ends
up guaranteeing is that all of these
pieces
go into a single bucket it's um you can
check it's tedious but
uh if you tried to put some of these
pieces in one bucket and other pieces in
a different bucket
you would lose some space and then you
would die
so if you want to survive you have to
put all these pieces into one bucket and
so again we're just stacking rectangles
we're putting a whole bunch of
rectangles in one
pocket and then a bunch of rectangles in
another pocket we can switch back and
forth however we want
but the only way to win it turns out is
if you get all
of those rectangles to add up to exactly
the right height
then you get a picture like this if you
don't get a picture like this you can
prove you end up dying
then i'll give you a bunch of l's then
i'll finally give you this t which
clears some lines
and then i'll give you it's the most
satisfying tetris game ever i'll give
you a ton of eyes
and you get tetris tetris tetris and you
clear the entire board
and so if you can solve the three
partition problem you can clear the
board and win the game and
be the best tetris player ever and if
there is no solution to three partition
you're guaranteed to lose
um and so this proves tetris is np hard
um
cool so what else do i want to say
briefly i think that's the main
main idea so another example
so this spot is called x completeness
and this includes problems such as end
by end chess
so we know that uh chess requires
exponential time because in fact it's
among the hardest problems in
exponential time
but most common are the somehow because
of the two-player nature of the game
most common are mp complete problems and
we have a bunch of
example mp complete problems i'll just
briefly mention here
so we saw the subset sum problem which
we had a polynomial time algorithm for
sorry a pseudo-polynomial time algorithm
for last class in fact has no polynomial
time algorithm assuming p
equals np so pseudopoly is the best you
can hope for
for subset sum there's a related notion
called weekly np hardness which i won't
get into here
three partition is one we saw we saw
some reductions to other problems
so these are all mp complete longest
common subsequence is another dynamic
programming problem we saw
with two sequences i mentioned you could
solve it for three or four or any
constant number
but if i give you n sequences each of
length n that problem is
np hard np complete longest
simple path in a graph we know how to
solve longest path you just solve
shortest path and
negative weights but longest simple path
where you don't repeat vertices that's
np-complete
relatedly one of the most famous
np-complete problems is traveling
salesman problem
the short finding the shortest path that
visits all vertices
uh in a given graph so instead of just
going from a to b
i want to visit all the vertices in the
graph
a lot of these problems i'm phrasing as
mac as optimization problems but when i
say mp complete i actually mean a
decision version of the problem for
example with this one
the decision question is is the shortest
path that visits all vertices in a graph
less than or equal to a given value
x if you can solve this then by binary
search you can solve
the overall weight three coloring a
graph is hard even though two coloring
or graph is polynomial
three coloring is np-complete assigning
three colors to the vertices
so that no adjacent vertices have the
same color finding the largest clique in
a given graph
which would be useful for analyzing
social networks whatever
this is a fun one for me as a geometer
if you're in a three-dimensional world
which i am and i want to find the
shortest path
from here to there that doesn't collide
with any obstacles like this desk and
all the chairs and so on
in 3d this problem if you can fly so if
you're a drone flying
among all these obstacles and you want
to find the shortest path from a to b
uh this is mp complete quite surprising
in two dimensions it's polynomial
you can reduce it to graph shortest
paths but in 3d it's np hard this is a
formula problem that comes up a lot
given a boolean formula and or not can
you ever make it true
if it has some variables that are not
assigned and some more fun examples are
minesweeper or sudoku basically any
paper and pencil puzzle you've ever
played
there's probably a paper out there
proving that it's empty complete
and on the video game side uh super
mario brothers is np hard
legend of zelda's mp hard pokemon is np
hard these problems are actually all
pro a little bit harder than np in a
different class called pspace
which i won't go into but if you're
interested in this stuff
there is a whole class devoted to it
which has online video lectures so you
can
watch them whenever you want called 6892
that gives a bunch of especially fun
examples of
np hardness and other types of hardness
proofs from a sort of algorithm's
perspective
for lots of games and puzzles you you
might care about
and that's it
you