all right welcome back to double06
dynamic programming
we're now in step two out of four
gonna see a bunch more examples three
more examples of that dynamic
programming
longest common sub sequence longest
increasing subsequence and uh kind of a
made up problem from w6 alternating coin
game
and through those examples we're going
to explore a few
uh new ideas things we haven't seen in
action before yet
dealing with multiple sequences instead
of just one dealing with
sub strings of sequences instead of
prefixes and suffixes
parent pointers so we can recover
solutions like and shortest paths
and a big one which will mostly be
fleshed out in the next lecture
is sub problem constraint and expansion
this is all
part of the sort bot paradigm
remember subproblems relations
topological order base case original
problem and time
here is subproblems and relations i've
written down both what these things are
and the sort of key lessons we got from
the first dynamic programming lecture
namely we want to split up our problem
into multiple sub problems and
if your input is a sequence that's the
main case we've seen so far
like the bowling problem for example
then
the natural subproblems to try are
prefixes suffixes or substrings
prefixes and suffixes are nice because
there's few of them there's only a
linear number of them
in general we want a polynomial number
sometimes you can get away with one of
these they're usually about the same
sometimes you need substrings there's
quadratically many of those
then once you set up the sub problems
which
it's easy to set up sub problems but
hard to do it right
to test whether you did it right is can
i write a recurrence relation
that relates one sub-problem solution to
smaller sub-problems
solutions and the general trick for
doing this is to identify
some feature of the solution you're
looking for so you're trying to solve
some sub-problem
and you try to ask a question whose
answer
would let you reduce to a smaller
sub-problem so if you can figure out
what that question is and that question
only has a polynomial number of answers
then boom and you've only got polynomial
number of subproblems then you will get
a polynomial running time
so i have i think another way to say
this
we just locally brute force all possible
answers to whatever
question we come up with as long as
there's polynomially many
and then each of them is going to
recursively call
the smaller sub-problems but because we
memoize we'll only solve each
sub-problem once
and so in the end the running time will
be at most the number
of subproblems times the non-recursive
work done in that relation
for that to work of course the relations
between subproblems must be acyclic
so we'd like to give an explicit
topological order usually it's a couple
of for loops
but this is a topological order in the
subproblem dag
which i defined somewhat informally last
time but if i have to
the vertices are are sub problems and i
want to draw an edge
from a smaller problem to a bigger
problem meaning that if
evaluating b in this relation calls a
then i'll draw an arrow from a to b from
the things i need to do first
to the things i'll do later so then
topological order
will be ready by the time i can try to
compute b
i will have already computed a uh and of
course the relation also needs base
cases
and then sometimes the sub the original
problem we want to solve is just one of
those sub problems
sometimes we need to combine multiple
we'll see that today
so that's review of this framework
and let's dive into longest common
subsequence
this is kind of a classic problem
it even has applications to things like
computational biology you have two dna
sequences you want to
measure how in common they are one
version of that
you might see other versions in
recitation called edit distance this
is sort of a simplest cleanish version
where i give you two sequences
i have two examples an example here
so for example it could be a sequence of
letters
so my first sequence spells
hieroglyphology
study of hieroglyphs and second sequence
spells michelangelo
and what i'd like is a subsequence so
remember
sub string has to be some continuous
range some interval
subsequence you can take any subset of
the letters
in your sequence or any subset of the
items in your sequence so you can have
blanks in between you can skip over
items
and so what we want is the longest
sequence
that is a subsequence of both the first
string the first sequence and
the second string and if you stare at
this long enough
the longest common subsequence i'm not i
don't think it's unique but there is a
longest common subsequence which is
uh hello
hiding in there
and that is a longest common subsequence
so given that input
the goal is to
compute hello or whatever longest common
subsequence is so we're given
write this down carefully given two
sequences let me name them
a and b
we want to find the longest
sequence l
that's a subsequence of both a and b
so that's the problem definition
and we're going to see how to solve it
using dynamic programming
and whereas in the bowling problem we
just had a single
sequence of numbers the values of the
bowling pins
here we have two sequences and so we
need a new trick
before we said okay if our sub-problems
or sorry if our input consists of a
single sequence we'll try prefixes
suffixes or substrings
now we've got two sequences so somehow
we need to combine
multiple input
together and so
here's a general trick sub problems
for multiple
inputs it's a very simple trick
we just take the
product multiply
the sub subproblem spaces
okay in the sense of cross product of
sets
and in particular from a combinatorial
perspective so we have sort of two
inputs the first sequence a and the
second sequence b
for each of them there's a natural
choice or there's three natural choices
we could do one of these i will choose
suffixes for a and suffix is for b you
could do some
other combination but that will be
enough for here and then i want to
multiply these spaces meaning
the number of subproblems is going to be
the product of the number of suffixes
here
times the number of suffixes here okay
and in other words every subproblem in
lcs is going to be
a pair of suffixes so let me
write that down so for
for lcs
our subproblems
are l of i j
this is going to be the longest common
subsequence of
the suffix of a starting at i and the
suffix of b
starting at j
and just to be clear how many there are
i'll give the ranges for i and j
i'm not going to assume the sequences
are the same length like in the example
so right lengths of a and less than b i
like to include the empty suffix
so when j equals the length of b that's
a
zero items in it because that makes for
really easy base cases
so i'd like to include those in my
sub-problems
so that was the s in sort bot
now i claim that that set of subproblems
is enough to do
a relation
recursive relation among them so i'd
like to solve
every subproblem l i j
and uh relation is actually pretty
simple but
it's maybe not so obvious so the idea is
because we're looking at suffixes we
should always think about what happens
in the first
letter um because if we remove that
first letter then we get a smaller
suffix
if you're doing prefixes you should
always look at the last letter either
one would work for this problem
so we're doing suffixes so we look at a
of i
and we look at b of j
that's the first letter in in the suffix
a starting at i
and the suffix b starting at j
and there are two cases they could be
equal or
different
i think the easier case to think about
is when they're different so
like in hieroglyphology and michelangelo
if we look at the whole string say the
first letter in the top one is h
the first letter and the second one is m
those are different letters so clearly
the one of those letters is not in the
common subsequence
because they don't match i can't start
with an h i can't well i can start with
an h i could start with an m but i can't
start
with both one of those letters is not in
the output in this example
it's m and so but i don't know which one
so i have this question i want to
identify some question
the question is should i do i know that
the h is not in the answer or do i know
that m
is not in the answer the final final
longest common subsequence
we don't know which so we'll just try
both
and then we're trying to maximize the
length of our common subsequence so
we'll take the max
of uh
l i plus 1 j
and l i j minus 1.
so the intuition here is one of
at least one of ai and bj
is not in the lcs
uh get this wrong
plus one sorry
thinking about sub strings already yeah
these are the beginning points so i want
to exclude
the i letter so if if a i is not in
then i want to look at the suffix
starting at i plus one if bj is not in
then i want to look at the suffix
starting at j plus 1.
so the indices are always increasing in
the function calls
and the other case is that they're equal
so this one
i have a little bit harder time arguing
i'm going to write the answer and then
prove that the answer is correct
here i claim you don't need to make any
choices
there's no question you need to answer
you can actually guarantee
that ai and bj might as well be
in the longest common subsequence and so
i get one point for that and then i
recurse on all the remaining letters so
from i plus one on
and from j plus one on why is this okay
well we have a b we're starting at
position i
and starting at position j for b
um and think of some optimal solution
some longest common subsequence so
it pairs up letters in some
some way these this would be some
non-crossing pairing between
equal letters uh and
let's say uh so first case is that maybe
i and j
aren't paired with anything well that's
silly because if they're not paired with
anything you have some pairing on the
rest of the items you can add this pair
and that would be a longer subsequent so
that would be a contradiction if we're
taking
imagining some hypothetical optimal
solution it has to pair
one of these with something maybe it
pairs eye with something else though
well if we have a longest comb sub
sequence that looks like that
i can just instead pair i with bj
that's still uh you know if i had this
pairing
i'm actually not using any of these
letters so why don't i just use this
letter instead
so you can argue there is a longest
common subsequence that matches
ai with bj and so then we can guarantee
by that little proof that we get one
point for
matching them up and there's no that we
don't have to max this with anything
okay so two cases pretty simple formula
um and then we're basically done we just
need to fill in the rest of sort bot
so next is topological order
so this i'll write as for loops
because i'm dealing with suffixes we
want to start with the empty suffixes
and then work our way to larger and
larger suffixes so this might seem
backwards if you're doing prefixes it
would be an increasing order
there's all sorts of orders you could
flip the i and j it's very symmetric so
it doesn't really matter
but anything that's generally decreasing
in inj
is good then we have base cases
uh these are when one of the sequences
is empty
i don't care how many items are in b but
if a has no items there's no common
subsequence i mean
it's empty and same for uh
no matter how big a is if i've exhausted
the b string i start from beyond the
last item
then i should get 0. then the original
problem we want to solve
is l 0 0 that's just longest common
subsequence of the entire a and the
entire b
and time
okay so for time we need to know how
many sub problems there are it's
a plus one times b plus one
i'll just call that theta a b so these
are
non-empty subsequences so this is the
number of sub-problems
and then what we care about is how much
time do we spend for each subproblem in
evaluating this
recurrence relation so we ignore the
cost to recursively call these l's
because
they are smaller sub problems they're
already dealt with when i multiply by
the number of subproblems
so i just care about this max
computation and this equality check
and we'll say those each cost constant
time
so this is
quadratic time if the two strings are
size n this is n squared
general it's the product of the two
string sizes
and that's longest common substring
so uh pretty straightforward this really
doesn't
other than this little argument and
understanding the case when they're
equal
the easy case where they're unequal we
just try the only two things we could do
one of the
uh one of a inbj is not in the longest
common subsequence
so what i like to say is we guess which
of those
is the correct one that is not in the
longest common subsequence
and if we guess that it's in a then
we'll recurse on that side if we guess
that it's in j
then we'll recurse on by increasing j
and then uh would i'd like to assume
not really that we always make the
correct guess
that we made the correct choice whether
it's irj now we don't actually know how
to do that so instead we brute force
we try both of them and then because
we're trying to maximize we take the max
okay just another way of thinking about
it but
overall very straightforward the only
com added complication here is we had to
deal with two
uh sequences simultaneously and we just
took the product of those so pretty
pretty easy in general if you have some
constant number of sequences you can
afford to do this you'll still get
polynomial
but of course once you go to end
sequences you can't afford this you
would get like an end to the n
behavior so that's kind of a limit to
how far you could go
two sequences is fine three sequences is
fine but n sequences
there probably is no polynomial time
algorithm
for this problem uh cool i want to show
you an example
i have an example here not i didn't
i didn't want to try out hieroglyphology
versus michelangelo
so i came up with another example their
habit
is to say hi so the longest common
subsequence of their and habit
is h i um and i mean it's a giant
well not that giant it looks kind of
like a grid graph
the base cases are out here because
those correspond
so uh when i say this each of these
nodes is a subproblem and this
corresponds to what is the longest
common
subsequence between eir
and abbott and it should be i
it's the only letter they have in common
and that's why there's a 1 here to say
that
the longest common subsequence has a 1
has size 1.
the base cases are when either there has
been emptied
or when habit has been emptied so those
all have zeros
on the outside and then the problem we
care about is this one it's
there versus habit uh claim is the
length is two
and what i've drawn in here are what
i'll call
parent pointers like we talked about
with
bfs and shortest paths and so on
this is so we had this choice
uh sometimes we had a choice on whether
we
recursed here or recursed here was the
best thing to do
and so i'll just draw i'll draw in red
the arrow from
lij sorry to lij from one of these
in this case and in this case there's no
choice but i'll still draw in red that
arrow
so uh these diagonal edges are exactly
the cases where the letters match here h
equals h um i equals i here so i draw
this diagonal edge that's that first
case where the letters are equal
and so i recurse by increasing i and j
that's why i get a diagonal edge
there's also one over here where t
equals t
so for those we're getting a one plus
you see this one is one larger than the
zero
this two is one larger than the one this
one is one larger than the zero
and for every other vertex we are
recursing this way and
this way uh we can see what those two
numbers are and we take the max
so this whole diagram is just filled in
uh by
for each uh position where they're not
equal
we look at the guy below we look at the
guy to the right those are the slightly
smaller
substrings we look at those values we
take the max
as long as you compute this in a
generally right to left and bottom up
fashion
whenever you're trying to compute a guy
you will have the its predecessors
already computed that's the topological
order of this graph
and then at the end we get our answer
which is two and now if we pay attention
to
where we came from for example this
vertex had to come from this
direction the 2 is the max of 2 and 1.
so i highlight the 2 edge and if i
follow this path
there should be a unique path to some
base case we don't know which one
and in this case the diagonal edges
correspond to my
matching letters so there's the h here
and followed by the i here and so high
is our longest common substring in
general we just follow these pointers
backwards
the red pointers and we get our answer
so not only do we compute
the length of the lcs but we actually
can find the lcs using
parent pointers so this is
and this is a concept you can use in
most dynamic programs
including all the ones from today okay
any questions about lcs
all right perfectly clear to everyone in
the audience
uh so we move oh uh yeah now we move on
to
longest increasing subsequence which
did i lose a page here i just disordered
them
okay this problem has almost the same
name but is quite different in behavior
longest increasing
subsequence
l i s instead of lcs
both famous problems examples of dynamic
programming
here we're just given one sequence
like carbohydrate
so this is a sequence of letters and i
want to find the longest subsequence of
this sequence
that is increasing strictly increasing
let's say so
in this case alphabetically so i could
go i could include cr for example but
not cb that would be
a descending subsequence and in general
or in this example the right answer or a
right answer
is abort there aren't very many english
words that are increasing but
there are some and i looked through all
of them
because i just implemented this dynamic
program we're about to
to write down it take took me like two
minutes to write down the dp and then
more work to read the dictionary and
look for cool examples
so in general we're given some sequence
a
and we want to find the longest
increasing subsequence of
a the longest sequence that is
increasing
strictly
you we could use the same thing to solve
not strictly increasing but
so here uh things are going to be a
little trickier it's easy in that we
just have a single sequence so again we
think
okay let's look at our chart here we
could try prefixes suffixes or
substrings i personally prefer
suffixes jason prefers prefixes uh
whatever you prefer is fine
um but always i'll generally start there
because there's nothing in this problem
that makes me think i need to
delete things from both ends one yeah
question isn't the answer to this
problem always 26.
so if is the ques is the answer always
at most 26
yes if you're dealing with english words
so
when i say sequence here this is a
sequence of arbitrary integers
word size integers so there you can have
a ton of variety this is just for the
fun of examples
i've drawn drawn this but even if the
answer is 26 finding that longest common
subsequence is
you know the obvious algorithm would be
to take all sub
strings of size 26 which is like n to
the 26
so that's we're going to do much faster
than that here and squared time
and then if you remove the strictly
increasing
then it can be arbitrarily large
okay so um
let's try to do this uh
maybe i won't be so pessimistic to write
attempt here
let's just go for it uh
so i want some sub problems and i'm
going to choose suffixes
so i'm going to define l of i to be the
longest increasing subsequence
of the suffix of a starting at i
okay that's the obvious thing to do uh
and now i'm gonna leave myself a little
space and then i'd like
a relation on these
so i'd like to say what l of i is
and what do i have to work with well i
have l of things larger than i
those would be smaller suffixes
uh but let's let's go back to what is a
question
that i could ask about this sub problem
that might
help me figure out what the longest
increasing subsequence looks like
so we're looking at a
here's a from i on
longest increasing subsequence is sub
subsequence and we'd like to remove
letter i now when we do that there are
two choices maybe i
is in the longest increasing subsequence
or it's not in
so the question i would like to answer
is
is i in the longest increasing
subsequence of a
of a from i onwards
this is a binary question there are two
options so again just like before
and so i can brute force those two
options
the trouble and then i want the longest
one so i'm going to take the max
so i'd like to take the max of something
like
li plus one so in the case that i don't
put i in the solution that's that's fine
then i just look at
i plus 1 on and recursively compute that
and that would be my answer
and the other option is that i do put i
in the longest increasing subsequence so
i do 1
plus the rest
no i plus 1. okay if i if i close this
brace
this would be a very strange recurrence
right because this is always bigger than
this one
so this there's something wrong here and
there's something wrong
is i haven't enforced increasing at all
there's no constraints here it's just
saying well i'll put i in
and then i'll do whatever remains and
i'll pray that that's increasing
probably won't be because indeed if
if i is a letter or as a number that is
strictly
greater than i plus 1 then this will be
wrong so i really
can't always do this i need to somehow
know
i could check whether i plus one is is
in the answer but some but i don't know
maybe i plus one
so i can check whether i the letter i is
less than the letter i plus one
uh but maybe i put this in the longest
increasing subsequence then i put this
in the longest increasing subsequence
and so i need to compare these two items
but i don't know when that's going to
happen
things seem really hard and indeed
there's no
way from this sub problem definition to
write down a relation
but there is a slight tweak to this
definition
that makes it work so um
the the trouble we have here and this is
the idea of sub problem
constraints or conditions the trouble
we have is when when we recursively
compute the
longest increasing subsequence on the
remainder we don't know
the first item in that answer
maybe it's i plus one maybe it's some
guy over here if we knew who it was then
we could compare that item to
item i and so what we'd like to do is
add a constraint to this sub-problem
that somehow
lets us know where the longest
increasing subsequence starts
so what i would like to say is longest
increasing subsequence of that suffix
that starts
with a of i
so in other words it includes
a of i
okay this was a separate question
okay this is a bit of a funny constraint
it changes the problem
it's no longer what we want to solve if
you think about the original problem
before it was solving l of 0 we just
want the longest increasing subsequence
of the whole thing
now it's not necessarily l of zero this
would be l of zero means what is the
longest increasing subsequence of the
whole
of the whole sequence a that includes
the first letter of a
and maybe we do include the first letter
of a maybe we don't we don't
know where the longest increasing
subsequence starts here for example it
didn't it started at the second letter
but conveniently it's okay that we don't
know
because that's just another question we
could ask
is where do we start where might the lis
start
to start at the first letter second
letter third letter there's only n
choices
and let's just take the max of all of
them so before i get to the relation
let's solve this problem
i just want the max of l i
for all i
i guess we've been writing size of a
here
okay the maximum will beat the overall
longest increasing subsequence so if i
could find longest increasing
subsequence that includes the first
letter
and or the longest one that's includes
the second letter and so on
so it starts at the first letter starts
the second letter then
this max will be the longest overall so
if i could this sub problem is not what
i really wanted but it's still good
enough because it lets me
solve my original problem and this is
adding an extra constraint
to my sub problem and doing this is
challenging thinking about what the
right constraint that would let you
solve your problem is tricky especially
in the beginning
but for now let's just take this as a
thing that works why does it work
because now i can say well
this this term was fine max so i'm
trying to write
longest increasing subsequence starting
with the ith letter
versus uh
yeah actually no this is just going to
be different
okay so now i get to the central issue
which is
i i know by the definition of l i that
i include letter i this is going to be
in my longest increasing subsequence
that's what i'm looking for
by this definition but i don't know what
the second letter is
could be i plus one could be i plus two
could be anything bigger
whenever there's something i don't know
i'll just brute force it
right i don't care uh that i don't know
i'll just take a max over all the
possible choices let's say that the next
the next letter included in the longest
increasing subsequence i
is j then i would like to look at
l of j now i don't know what j
is but i'll just brute force all
possible choices for j so it's going to
be i
strictly less than j because i don't
want to include the same letter
i again and otherwise i would get an
infinite recursive loop if i put less
than or equal to here
uh and maybe i don't do anything else up
to n
and uh okay not quite done
now this is the interesting part i can
enforce
increasing because i can't just choose
any letter
j to the right of i also the the
number that's or letter that's written
in here has to be greater than the
number that's written here that's the
strictly increasing property
so i can add as a constraint
in this max to say
a of i is strictly less than a of j
and if you wanted non-strictly
increasing you would add an
equal there okay this is mathematical
notation in python you would say
max open paren of this thing for
j in this range if this holds
so i'm just doing the for loop but i
only do
i only look at the possible choices for
j
uh when uh the strict increasing
property holds
and then when that holds i put check
this now this set might be empty
i need to define what the max is when
it's empty then i will just
say oh i also need a oneplus don't i
let me just do one plus so we're told
that i is in the answer so we always get
one
and then the remainder is this or
zero if there are no uh
j's there if there are no aj's greater
than a i
uh then we'll default to zero and say
that i is the only item in my increasing
subsequence
okay so there are a few details to get
right but in general once
once you figure out what these
recurrences look like they're very
simple i mean this is one line of code
and then all you need in addition to
this
is the original subproblem and some
other
things we need the
base cases but i should do them in order
topological order
is just the usual for loop because i'm
doing suffixes
it's going to be i equals length of a
down to zero
uh base case is going to be
l of length of a which is zero
because there's no letters in that
suffix
um and we already did o and then time
okay this is a little different from the
past examples so number of subproblems
just like usual is
linear length of a
sub problems
there's only one sequence we're thinking
about now unlike the previous example
but the work we're doing in this
relation now is non-trivial work
before we were just guessing among two
different choices now we're guessing
among
up to n different choices this n here is
length of a
and so we have theta
length of a
non-recursive work
that we're doing in each subproblem
or you might think of this as choices
that we're considering
and for each choice we're just spending
i mean we're just taking a max of those
items adding one
so that's a constant overhead and so we
just get this product
which is a squared
cool so that's the longest increasing
subsequence make sure i didn't miss
anything else
so we're using this idea of asking a
question
and guessing or brute forcing the answer
to that question
in two places one place is
we're promising we're being we're
requesting that the longest increasing
sub sequence starts at i
so then the question is well what is the
very second
uh item that's in the longest increasing
subsequence that it starts with i
uh we're calling that j and we're brute
forcing all the possible choices that j
could be which conveniently lets us
check confirm that it's actually an
increasing subsequence locally from i to
j
and then l of j will take care of the
rest by induction
the rest of the longest increasing
subsequence starting at j will also be
increasing and so this guarantees by
induction
the whole thing will be increasing then
we also use this
uh local brute force to solve the
original problem
so we added this constraint of starting
at i but we didn't actually know overall
where to start
but that's fine because there's only
eight choices so i should mention
in the running time analysis so they're
solving the sub problems
that's fine but then there's also a plus
whatever it costs to solve the original
problem
but that's okay that's length of a
so this was all of this plus length of a
is still length of a squared
okay but if you're doing you know
exponential work here that would be bad
we have to do some
reasonable amount of work to solve the
original problem in terms of all the sub
problems
i have an example hiding here
this is a little harder to stare at here
i have
empathy and this example is not
doesn't have much empathy because the
longest increasing subsequence of
empathy is
empty
empty is one of the few english words
that's increasing
and you the hard part here is drawing
the dag
i mean it's almost the complete graph
but we only draw edges
from smaller letters to bigger letters
so we draw from e to m
from e to p from e not to a there's no
edge from e to a
from e to t not from e to h
but yes from e to y and then we also
draw from e to the base case which is
there's no more letters
that was that that uh edge to the base
case
is
uh corresponds to the zero
or i guess this n where we say ah let's
just
recurse let's just throw away
actually maybe we don't need the union
zero there in fact because
we include l of n which is the empty
substring then the definition of
of l is a little funny what does it mean
to say you start with a of n
hm right a of n is not defined so that's
not so nice
so maybe i'll fix that
and decrease equals case
okay but i'm still going to draw an edge
there conceptually say oh we're just
done at that point
that's the base case where we have no
string left
um cool and when i said from to two
actually i meant the reverse all the
edges go from right to left
um and then what we're doing is looking
for the longest path in this dag
um longest path is maybe a problem we've
talked about in
problem session because it's a dag
well longest path is the same thing as
shortest path if you just negate all the
weights
there are no weights in this picture so
if you just put negative one
on all these edges and ask for the
shortest path
from the base
to anywhere so single source shortest
paths from this base
then we would end up getting this path
which if you look at it is e m p
t y empty and so that
uh shortest path is indeed the right
answer what i've drawn here is the
shortest path tree
so also if you wanted the longest
increasing subsequence starting at
a then it is a t y just by following
the red arrows here and how do you get
that you just
draw the parent pointers just like we
did before i didn't mention
this example can also be solved with
shortest paths once i'd construct this
graph you can do the shortest path from
some base i don't know which one
to here if you put
negative one on all of the diagonal
edges
and you put weight zero everywhere else
then that corresponds to
the shortest path in that graph will
correspond to the longest
the path with the most diagonal edges
and that makes sense because the
diagonal edges are where we actually get
letters in common and so in this case
it's
two so both of these dynamic programs
could instead
instead of writing them as a recursive
thing with memorization
or writing them bottom up as a for loop
and then
doing the computation you could instead
construct a graph
and then run dag shortest paths on it
but the point is these are the same
thing it's actually a lot simpler to
write the dynamic programming code
because it's just a for loop and then a
recurrence which you're just updating an
array
you don't because you already know what
the
topological order is you don't have to
write a generic
depth first search algorithm take the
finishing order reverse it
and then run this
run dag shortest paths with relaxation
uh much simpler to just write down the
recurrence once you've figured it out
okay but they are the same in these
examples uh in fibonacci for example you
cannot write fibonacci as a single
source shortest path problem but a lot
of dps
you can write as the shortest paths
problem
just a connection to things we've seen
all right last example
last problem for today we'll do more
next
week
alternating coin game this is a two
player game
we're gonna find the optimal strategy in
this game uh
so an example is in general you have a
sequence of coins
and we have two players
they take turns so given
coins of
value uh v zero
to v n minus one so it's a it's a
sequence
they're given an order in some order
for example 5 10 125 not necessarily
sorted order
and the rules of the game are we're
going to take turns i'm going to take
turns with you
i'm going to use i and u to refer to the
two players
and so in each turn either one whoever's
turn it is
i get to we get to choose either the
first coin
or the last coin among the coins that
remain so at the beginning i can choose
5 or 25 and i might think
oh 25 is really good that's better than
5. i should choose that
but then of course you're you're going
next and you're going to choose 100
and you'll win the game you'll get more
of the total value of the coins
so in this example a better strategy is
to take the five
because then the hundred is still in the
middle and so once once i take
five uh you get to choose
10 or 25 at this point you probably
prefer 25 because that's better than 10
but whichever you choose i can take the
100 and so i get 105 points
and you're going to get 35 points
okay good good example for me um
and what we're going to do so that's
easy for a simple example but
in general there are exponentially many
strategies here at each step either of
us could go left or right
choose the leftmost or the rightmost and
we're going to give a dynamic
programming
algorithm that just solves this fast uh
i didn't mention so this algorithm is
quadratic time but it can be made n log
n time it's a fun
exercise using a lot of the data
structure augmentation stuff
we've done you can make this n log n
this algorithm i think is going to be n
squared time uh y
so i won't write the problem
exactly but i think you know the rules
she's left most of rightmost coin
alternating moves
so i'd like to define some
sub problems and this is a problem
that's very naturally a substring
problem
right if i just looked at suffixes that
would deal great with if i'm
deleting coins from the left but as soon
as i delete a and if i
delete coins only from the right that
would give me prefixes
but i'll tell you now there's no dynamic
programming where the answer is
suffixes and prefixes you can do
suffixes or prefixes but if you need
both
you almost certainly need substrings
because as soon as i delete
the first coin and then maybe you take
the second coin
that's exactly the optimal strategy here
now you have an arbitrary substring in
the middle
okay but substrings are enough because
we're only deleting from the ends
we'll look at substrings
so more precisely this is just the
intuition
we're going to define some generic x
of i j is going to be what
is the maximum
total value
i can get
uh from this game uh if we play it on
coins uh of value
vi
to vj so that's a substring
so this is one way to write down the sub
problems and is also
a good way i mean you can write down a
relation
on this
on this definition of sub problems but
i'm i'm low on time there's there's two
ways to solve this problem
this is a reasonable way exploiting that
the game is zero sum
but i'd like to uh change this a little
bit
to give you a i think what's a cleaner
way to solve the problem
which is to add a third coordinate
to my sub-problems so now it's
parameterized by three things
p here is uh
only has two choices it's me or you
okay and this gets at a point that's
maybe not totally clear from this
definition
uh max total value that i can get uh
from these
this substring of coins but uh this is
not obviously what i need so obviously
at the beginning i want the whole string
and i want to know what my maximum value
is fine
and i go first in this game i didn't
specify
but i do overloading i
but as soon as i do a move as soon as i
take the first coin for example
it's now your turn and so i don't really
want to
know the maximum total value that i
would get if i go first
i'd like to say uh
if player p goes first i'd really like
to know
what what happens in the case where you
go first
and so for some of the uh substrings i
want to know what happens when you go
first and for
some of them i want to know what happens
when i go first because as soon as i
make a move
it's your turn and so we're going to
flip back and forth between p
being me and p being u p u
so you don't have to parameterize this
there's a way to write the recurrence
otherwise but
this is i think a lot more intuitive
because now we can do
a very simple relation
which is as follows
so i'm going to split into two cases one
is x of i j
me and the other is x of i j u
uh so x of i j me so i have
i have some substring from i to j
uh what could i do i could take the
first coin or i could take the second
coin
what should i do that's my question
should what is my first move
should i take the first coin or the
second coin so this is my question
what is the first move
there are exactly two possible answers
to that question so we can afford to
just brute force them
and take the max
for moving we want the maximum
number of points we can get maximum
total value of
the two choices so if if i take from the
i side the left side
that would be x of i plus one j
uh sorry and now crucially we flip
players because then it's your turn
and if i take from the j side that will
make it j minus one
this is what i accidentally wrote at the
beginning of lecture
also flipped players so either i shrink
on the i side or a shrink on the j side
oh i should add on
here the value of the coin that i get
and add on the value of the coin that i
took
sorry these are this is a an expression
inside the max
that sum okay and if i take the max
those two options that will give
that is my locally brute forced best
choice
of how many how what are the total value
of coins i will get out of the remainder
given that you start plus this coin that
i took right now in the first step
and for the two possible choices of what
that coin is
okay what remains is how do we how do we
define this x of i j
u this is a little bit funnier
but it's conceptually similar i'm going
to write
basically the same thing here but with a
me
instead of a u because again it flips
this is if you go first then the very
next move will be me
okay so this is just the symmetric
formula here i can even put the braces
in
so far the same now
i don't put in the plus vi and i don't
put in the plus vj here because if
you're moving i don't get those points
so there's an asymmetry in this
definition you could define it in
different ways but
this is the maximum total value that i
would get if you start
so in your first move you get some
points but i don't get any points out of
that
so there's no plus vi there's no plus vj
it's just
you either choose the ith coin or you
choose the jth coin and then the coins
that remain
for me shrink accordingly now
you're kind of a pain in the ass you're
an adversary you're trying to minimize
my score
potentially because you're trying to
maximize your score this is a zero-sum
game so everything that you get i don't
get
so you want to maximize your score if
you want to maximize your score you're
trying to minimize my score these are
symmetric things
and so if you think for a while the
right thing to put here is min
from our perspective we're imagining
what is the worst case that could happen
no matter what you do and we don't have
control over what you do
and so we'd really like to see what
score would i get if you chose the
ithcoin what
score do you get if if you chose the jth
coin
and then what we get is going to be the
worst of those two possibilities
so when we get to choose we're
maximizing and this is a general
two-player phenomenon
that when you choose we end up
minimizing because that's the saddest
thing that happened to us
okay this is one way to write a
recurrence relation
um we have of course
all of sort bot to do so the topological
order here is in
increasing length of substrings so the t
is increasing j minus i
start with empty strings so base case is
that
x of i i me
is vi uh so here i i'm
i'm inclusive in both ends in this
definition
uh so there is a coin i can take at the
end but if you move last and there's one
coin left then i don't get it
so it's zero then we have the original
problem that is
x i j me sorry
x zero n that's the
entire coin set starting with me that
was the problem i wanted to do
and then the running time we get is the
number of sub problems that's theta n
squared
because we're doing substrings times the
amount of non-recursive work i do here
that's just a max of two numbers very
simple constant time
so this is quadratic
let me show you an example
this is hard to draw but what i've
described here is called solution two in
the notes
um so here's our sequence 510 125 in
both
directions and what we're interested in
is all sub strings so
over here i've written the choice for i
so we start at one of these and if you
start here
you can't end earlier than there so
that's why we're in the upper upper
diagonal of this matrix
and then there's two versions of each
problem the white version and the blue
version just down and to the right of it
if you can't see what blue is
this is the version where you start this
is the version where i start
and i've labeled here all of the
different numbers please
admire because this took a long time to
draw but in particular we have 105 here
meaning that the maximum points i can
get
105 and that's the case because
if we look over there it is the max of
these two
incoming values
plus the vi that i get so either i go to
the left and i take that
item or i go down and i take that item
so the option here is i went
to the left and took well that's going
to be tricky to do
in time the claim is that the the best
answer here is to go here with the
hundred
and take the five uh because going down
corresponds to removing the last item
if i went to the left that corresponds
to remove sorry the first item
if i went to the left that corresponds
to removing the last item so my options
are
10 plus 25 which is 35 versus
100 plus 5 105 wins
so that's why there's a red edge here
showing that was my better choice
and in general if you follow the these
parent pointers back it gives you the
optimal strategy
in what you should do first you should
take the five is what this is saying
because we just clipped off
the five we used to start here and now
we start here
in this sub interval then
our opponent to be annoying we'll take
the 25
doesn't actually matter i think then we
will take the 100
and then they take the 10 and it's game
over
okay all the numbers here how many
points we get doesn't say how many
points the opponent gets of course you
could add that as well
it's just the total sum minus minus what
we
get ah now let me come back to
high level here what we're really doing
is sub problem expansion and this is an
idea
that we will expand on next lecture
uh and the idea is that sometimes you
start with the obvious sub-problems of
prefixes suffixes or substrings here the
obvious version with substrings because
we're
removing from both ends if you don't
know probably suffixes or prefixes
are enough
so we start there but sometimes that's
still not enough sub problems
here as soon as we made a move our
problem almost turned upside down
because now it's your turn instead of my
turn
and that was just annoying to deal with
and so we could whenever you
run into a new type of problem just
build more sub problems as long as it
stays polynomial number
we'll get polynomial time and so here we
doubled the number of sub-problems to
just the b
case and the u-case and that made this
recurrence really easy to write in the
notes you'll see a messier way to write
it if you don't do that
in the examples we'll see next lecture
we're going to do a lot more expansion
maybe multiplying the number of sub
problems by n or n squared
and this will give us uh it will let us
add more constraints to our
sub problems like we did in longest
increasing subsequence
we added this constraint that we start
with a particular item
the more sub problems we have we can
consider more constraints because we'll
just
brute force all the possible constraints
that could apply
well we'll see see more of that next
time that's it for today