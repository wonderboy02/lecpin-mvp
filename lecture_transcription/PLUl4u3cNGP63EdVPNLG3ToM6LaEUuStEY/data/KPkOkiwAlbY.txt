so today uh we're going to continue in
our discussion of uh dynamic programming
I actually found this set of problem
session problems to be easier than the
previous one I think the fun there's a
funny thing which is uh we learned in
class about sort of pseudo polinomial
time style Dynamic programs somehow that
language is a little bit liberating in
the sense that you're sort of using
parameters that you really shouldn't uh
when it comes to the runtime of your
algorithm well I I suppose you should in
the sense that it's it's allowed if you
call your algorithm pseudo polinomial
time but somehow makes it a little
easier to formulate your dynamic
programming algorithm because sort of
all the numbers are staring you right in
the face like you don't have to be so
careful about what's a fair game and
what's not uh when you when you post
your algorithm so long as it's
sufficient in the values that you care
about uh and so uh today's problem
session has five problems squeezed in
instead of the usual four uh we'll see
how far we get see that I usually talk
too much anyway uh but I'll try to stay
on schedule here and we'll see how well
we do um any questions from our students
about dynamic programming before we get
started here cut one if you want we can
cut one oh I I will gladly cut one if I
run out of time yeah
okay so without further Ado uh let's get
started with uh coin crafting which is
problem -1 here so I suppose it should
be Keel nafy if I were to work uh
through my spoonerism properly here um
in any event we have a thief who's in
desperate need of money uh as with many
thieves or else of course they wouldn't
resort to the world of crime uh and uh
ke nafy here um has uh n identical
coins I've been very self-conscious
about the way that I write the letter I
ever since Eric pointed it out and it's
only gotten worse now it's inconsistent
and and hard to read uh but in any event
uh so we have uh n uh identical coins
and of course you know these coins have
very distinctive markings and so we
can't possibly run away with them as is
because if you take them to your
standard Jeweler they'll immediately
recognize that these markings are bad
and stolen and and that's not so good so
instead we can melt uh these coins into
other
objects so uh you know our sneaky uh
Thief here has identified a potential
buyer and uh the buyer has a few
criteria here right so we have a
buyer um and the buyer has the buyer has
a very strange value system thing that
apparently it's easy to take coins and
make them into other things uh but but
in any event the the the buyer what they
care about is not the fact that the
coins are made of gold but rather that
they like particular objects better than
others made out of said gold um so in
particular they have a different rate uh
for each object like a different price
they're willing to pay um and so they
have a list of
um uh uh
n objects that they're interested in uh
and each one uh is associated with two
things and objects uh they have a price
so the amount that the buyer is willing
to pay for that object which again is
not just the weight and gold for some
reason you know there's a value added
tax uh in in in in this universe uh and
uh it takes a different number of coins
to
manufacture right like so maybe maybe
you know I can make like a golden
chocolate fountain and that takes like
10 coins but I don't want two of those
so if I make that then the next thing I
have to do is like a figurine of of Eric
and Jason to to put alongside it um and
having more than one of those would also
be like creepy and weird right so so I
can only make one of each object uh and
of course uh my goal here is I have end
coins by the way the fact that there's
end coins and end objects for the buyer
doesn't really matter I mean it will for
the runtime but like you could imagine
this being n and M so I wouldn't be too
hung up on that um and what you're
trying to do is is of course maximize
your Revenue uh subject to the
constraints that uh you have end coins
uh and you can't make two objects that
are the same hopefully I've captured the
essence of our problem okay okay
fabulous so uh as with uh all of our our
our dynamic programming problems in
6006 uh we have a paradigm for how how
to approach them um which has a cute
acronym which is sort bot uh and I think
sbot is a totally relevant and
straightforward approach to uh this
problem here yeah so uh in particular
let's let's give ourselves a bit of of
notation right so we're going to number
our objects between one and N uh just
for convenience so we'll say that uh p i
is the
price of uh object
I
okay and uh we'll say that Ki is the
what the problem calls the
melting uh number in other words if I
want to make object I this is the amount
of coins that I'd have to me uh melt to
to make that object okay so just a tiny
bit of
notation and in general so okay what do
we do when we formulate our dynamic
programming problems we want to identify
interesting sub problems we could solve
that are smaller uh and when we compose
them all together uh we get the the
final solution to our problem and this
uh particular problem uh involving
manufacturing objects out of coins I
think is like a really classic one when
it comes to dynamic programming this is
the sort of thing where you know someday
when you're trying to to to pay for your
tuition by doing these like hacker
contests online you know like this is
the sort of thing that comes up all the
time in in that Universe right um so in
particular uh the two sort of variables
here uh you know when I make new object
is what object did I make and how many
coins did I spend when I did that so
sort of the two natural parameters to
use uh when I solve my Dynamic uh
programming problem yeah and and of
course it's going to be sort of
recursive in the sense that um I can
either choose to make object I or not
and it doesn't matter what order I make
my objects in or similarly what order I
spend my coins in which is usually a
nice property to have in a dynamic
programming universe so in particular oh
this thing is my
Nemesis um this is
front I think this classroom is
particularly tough for short people
because I like I'm moving it up and down
all the time okay uh so given our our
observation here uh if we're doing sort
bot uh right so uh what's our our s
again let me ask myself that sub
problems thank you uh Professor domain
uh then uh essentially what we want to
do based on what I sort of argued
verbally is maybe Define our variable XI
J the thing we're going to compute to be
the
revenue uh from
using I
coins uh and uh objects uh one to
J okay so in other words you know I have
I coins left in the bank and I'm only
allowed to use the first J objects and
we can already see that this kind of a
sensible way to approach this uh dynamic
programming problem in the sense that
you know there's an obvious recursion
here I choose to make an object I have
fewer coins uh and I can sort of imagine
there being a topological order in the
sense that I could first decide about
object one and then object two and
object three and so on or vice versa
depending on whether you're a prefix or
suffix kind of guy um which I still get
backward but the the the good news is
that uh doesn't really matter what
matters is is formulating the equation
okay any questions about our our our
definition of the thing that we're going
to chase after
here
fabulous okay right so uh let's do uh
let's continue sort bot so our next uh
uh uh piece of our puzzle here is the r
I believe R stands for recursion this is
a new acronym for me too oh nope no
relate but it might as well be recursion
for for most of these problems uh right
so the basic relationship here is that
of course I can either use object J or I
can not use object J uh and and in both
of those cases right if J is the very
last guy that I'm going to consider uh
that'll be a totally reasonable
recursive rule right so in
particular um I have that uh XI
J um essentially can take one of two
values a parenthesis in case you're
wondering um and and of course you're
trying to maximize your
Revenue uh so so let's do that okay so
um so we have sort of two OB uh
potentially potential options but we
have to be a bit careful is there a case
where I can't make object
J yes class there is uh which is uh the
case where I don't have enough coins
left in the bank right so I want to make
that really expensive Fountain but I
only have one coin then I'm I'm sort of
out of luck yep so uh let's do these two
cases so
first um you know if
uh oops I got my cases
backward that's okay um right so let's
say that I choose not to uh make uh
object J okay so what does that mean so
so did I spend any coins
no and moreover what is my maximum
profit well it's going to be the same as
the maximum profit using objects 1
through J minus one because I didn't use
object J yeah so in particular that
would be
X um let's see I got it backward in my
notes so we're going to do it live uh
like that okay and otherwise let's say
that I did choose to make object J well
what happens so I did get some Revenue
now right so I got man what on Earth did
I write on these uh not um so I get the
uh price of object J here as my Revenue
but I spent uh some coins in the
process so I have I minus uh K sub I
which is the number of
coins what was that oh thank you sorry K
subj that's why we should be consistent
with our indices when we write these
things down um right so I spent K sub J
coins uh making this thing uh object J
uh and uh moreover I can still choose to
make any of the previous object so it's
still just J minus
one but I have to be careful because I
can't always do this in
particular this it better be a positive
number if I end or at least a non-
negative number because if I end up with
a negative number of coins well that
that's not a physical universe that I
choose to be in uh so in
particular uh what we need in some sense
is I minus K minus J KJ to be greater or
equal to zero or equivalently I is
greater than or equal to K so J I think
you guys could all do that one at home
okay and this is our recursion uh
hopefully I've gotten it right because
it disagrees with the crazy thing I
wrote in my notes at 1 a.m. yesterday uh
but uh I think it's pretty
straightforward essentially either I can
choose to use the last object or I
choose not to uh and either one of those
uh of course decrements uh J cuz that's
the index of the object I'm considering
uh and I either account for the price
but have to pay in gold or I don't
account for the price so implicitly
there's a zero and I don't have to pay
in Gold okay good all right so let's
continue with uh sort bot we might later
in the problem session relax going
through every one of these steps because
a lot of the arguments are kind of
similar but for now we'll do one or two
carefully so t uh I believe stands for
topological order uh and here it's uh
staring Us in the face because notice
that
um x i j
only
depends on um x i x question mark comma
J minus
one right so of course on your problem
set you should write things more
carefully uh but the basic Point here is
that there's a clear topological order
just by looking at that second index
because you kind of if you think of all
of your X's as variables in a graph
which we've actually drawn in lecture so
like maybe these are all the I's and
then you know the J you know so like I
goes down and J goes to the right then
essentially this argument is saying that
all the arrows kind of Point left in
this
graph
um suppose the way I've drawn my arrows
this isn't quite accurate but it
actually doesn't matter the only thing
that matters is that it goes from right
to left um but I'm going to erase this
so you don't remember it
okay so in general just when you when
you want to make your topological order
argument I think a totally sensible one
is like looking at the indices of your
recursion and then just trying to find
some number that
decreases incidentally if you take a
differential equation course uh that's
roughly how you prove that a lot of
those things converge too um so there's
a a sort of a generic math trick that we
use a lot you call that in in in od
where you have some number that
decreases I would call potential
function potential function that's a
perfectly sensible one there's the it's
not lip shits it's some other
mathematician anyway uh okay so let's
continue uh sord bot so next we need B
which is our base
case uh so in this case uh is pretty
straightforward if I if I don't have any
coins I can't make any
money I have a t-shirt that that says
that at home uh and moreover uh if I
can't sell anything I can't make any
money uh so those are are pretty
straight forward cases so we have that
zero
equals x of 0 comma J remember the first
index is the number of coins you have so
this is saying I don't I can't make
anything if I don't have any coins and
similarly equals x i comma 0 for all i j
right so this is the coins and the uh
objects okay so let's see I keep writing
these problem sessions too big and then
spending half of it erasing so let's
let's try and fit this on one board here
so we're going to do sort but then the
second no the first o because there's no
o in sort um is the uh the uh what the
original problem that you want to solve
so of course you start out with n
objects and N
coins uh
so the original problem we want to solve
uh is equivalent to Computing xn comma n
and then finally we got to do our
runtime T stands for runtime or time I
suppose um so first of all how many many
sub problems are there well there's x i
j both I can go from 0er to n this is a
great way to be off by one um so there's
n + 1 squared
sub
problems uh and how much work does each
sub problem do well it does boring work
it's just a formula right so there's
order one
work per sub problem so the overall
algorithm takes n^2
time so I promised to do something last
in our last problem session then I
didn't actually do it uh so I did think
I would spend just a minute uh here sort
of translating what this sbot thing
would mean in terms of of code because I
think that it's a little bit implicit
here in particular I think this step
here I mean you will'll see that it
really clearly is going to give you an
algorithm but I think it's kind of easy
to like again just to to forget what
what your code actually looks like and
actually the coding problems on these
problem sessions are almost too
interesting and and and can obscure it a
little bit so I thought we'd do a boring
problem and show you uh that it's really
not so hard to to do this and in fact uh
we covered two different strategies in
class for how to take sort bot and
convert it into a piece of code although
they might have uh kind of zipped past
you in in this you know 2x speed uh
thing that you can do now um so right so
here are two options um one of them is
called memorization uh and the other I
don't know bottom up I guess is a
reasonable phrase uh to describe and so
I thought we'd do them both because
they're both easy for this particular
problem
um
okay right so um let's do that so let's
uh so is this necessary on your homework
strictly speaking no like if you've
you've gone through sort bot then
essentially everything that happens
after that is sort of boilerplate in
terms of converting these steps into a
piece of code or an out algorithm but I
do think just for understanding why sort
bot makes sense uh it's worth thinking
about for a minute um so option A here
is
memoization ironically I've taught and
ta algorithms a few times and I never
actually knew what memorization uh meant
so I I learned something from from
Eric's lecture the other day um which
remember memorization the key thing and
then what apparently is kind of a madeup
word is memo like you know if you're
back in the day you had a what a stopad
and you were writing down stuff because
that's where you solve problems with
your slide rule um then uh essentially
the idea is that if I compute xig for
some pair I shouldn't compute it again I
should just write it down on my memo pad
um steno isation sounds better to me but
I suppose we'd have to go back to the 19
what 40s and fix it um okay so let's uh
actually write down I'm going to write
down pseudo code that'll probably look
more like mat lab cuz I'm that kind of
guy uh so uh let's say that I wanted to
make a
function um which I guess is
revenue of i j uh like
that um and and and and this is the
thing I wanted to
compute oh that's actually going to be a
problem because we're not be able to
see okay right so in addition to
this I I'm going to kind of pass in an
array X um which is going to be like the
my my memo pad this is going to be
terrible coding practice but easy board
coding uh practice so like if I were in
C++ maybe I pass it by reference so that
like when I edit it's a treble cleff but
whatever
uh you know when I edit X it actually
persists when I when I recurse this is
terrible coding practice and you
shouldn't do it okay um but it's just
going to be because I don't want to
write too many lines on the board here
um and maybe we initialize like we have
some helper
function uh to Let's see we want our
Revenue to be big well actually no we'll
just initialize it to like not a number
so that like we know that we haven't
computed it yet how about
that okay so
uh what should we do well if we're going
to memoize the first thing we should do
anytime that I call my Revenue function
on on an AJ pair is check have already
computed it yeah um so in my kind of
goofy bad board coding style here what
could I do I'd say well if I've already
computed it then this thing won't equal
Nan anymore it won't be not a number so
I can say okay if x i j is not equal not
a number so in other words it is a
number um
return and this like I think that this
little line of code here it gets like a
little loss but this is like we should
put like sparkles around it right this
is the magic of dynamic programming
because I just killed recursive CS right
like I even if I and J are like 17 and
23 if I already computed it I'm done
right I I don't have to call my
recursion again okay and otherwise what
am I going to do
um well otherwise I'll you know maybe
call do I want to write it all down I
don't want to write that all down
um so otherwise
I'm going to
evaluate R where R is this formula over
here notice that this will
require um recursive calls right uh and
I'm going to store it in
x i
j and then return x i
j okay so B basically the only
difference between like what we've seen
in the first two3 of 66 and now is this
beautiful line of code saying if I
already computed this thing return it
and this is the memorized version of our
algorithm um I think this is sort of the
easiest one to maybe think about but
actually from a runtime analysis it's a
little bit annoying um it's not in the
sense that we convince ourselves that SB
is okay but of course like if you're
thinking about your recursion tree like
what's happening is that you're sort of
maybe convincing yourself that like this
piece can be lopped off in your function
calls um so you sort of have to do your
counting uh
carefully uh there's a different way to
uh implement the same thing so this
would be option b this is maybe more
efficient maybe less efficient depending
on your problem um but these are all
within constant factors of each other
for the most part not always but for the
most part this would be bottom
up and this is the idea of rather than
just taking our recursive algorithm that
we already know know and then just like
checking a table to see like okay did I
already do this in this in that case
return it uh in the bottom up version
I'm going to build up my array XI J um
so there's no recursion at all um so
right so what would that look like so in
the bottom up case notice that in some
sense memorization is a top down
strategy right I would call it on N
comma n here we're going to start from
zero and work our way toward n right so
we'll start with x 0 J equals uh x
i0 equal 0 for all i j obviously I can
do this with a
forloop uh and
now well remember if we think about our
topological order x i j only depends on
previous JS right so it makes sense to
have an outer loop which is over
J and now inside of inside of this out
loop I can uh compute anything that I
want in that J column of X and I'm in
good shape because I'm building it up
one column at a time right so in
particular now we can
do you know our Loop over I and then
just have you know x j um and now you
know evaluate our R step in our sort bot
uh Paradigm and and notice that that's
perfectly fine because by the time I get
to Computing XI J I've already filled in
x j for you know minus one which is all
I needed to evaluate that formula so
what are the advantages and the
disadvantages here so notice that here
our our our runtime is staring you in
the face right we have N squ Sub
problems order one work and you're done
on the other hand there's some
possibility like if you were an old
school AI person that you might be able
to do some pruning on on the the your
left hand side uh that I can't do over
here right so here I'm literally
evaluating every entry of xij it could
be the case it's not the case for this
particular problem but maybe X only
depends on x i j minus 5 right this
strategy is going to still build up that
whole table this one maybe can skip over
some entry so in practice it could help
on the other hand here I've got a bunch
of recursive calls I put on the stack of
my computer that here I don't have so I
think actually because of the overhead
of recursion typically the strategy on
the right is is is preferred also for
clarity but that's a blanket statement
that I shouldn't make okay so anyway I
think i' I've done this uh this problem
to death uh are there there any uh
questions here I just thought I'd fill
in for something I promised last time
and and didn't actually
do okay fabulous so we'll go on to
problem
92 um so this is continuing from last
time in The Saga of Tim the beaver here
so I forget what Tim the beaver was
doing in our last problem session but
today Tim the beaver is going to the
career fair and as we all know the only
real purpose of going to a career
fair is to pick up free
stuff um you know we joke actually you
guys should all go to the career fair I
I got my first job out of college by
going to a career fair um and hanging
somebody that picks our booth until they
let me in uh but in any event um so Tim
the
beaver uh is not interested in getting a
job but rather just wants uh swag just
wants free stuff out of booths at the
career fair okay uh so in in this
particular problem there's n
booths is it Boos certainly not boots um
I don't know there there end booths Each
of which has a swag uh and in particular
each swag has a value Associated to it
which is CI which is the
coolness of object
I uh it additionally has wi I this is
the
weight of object I
and just to make this problem verbally
difficult to communicate there's a w AI
T associated with each object which is
the time it takes to wait in line and
pick up object I okay and and Tim the
beaver like if there's some ridiculously
cool object with like a low weight time
he might just keep getting in line and
and and and getting more of that object
so unlike um ke nafy on our first
problem uh Tim the beaver is perfectly
happy to to have more than one of the
same thing okay
um in addition to this uh just to make
this problem in my opinion slightly more
annoying and and point losing um Tim the
beaver also takes one minute to get in
line at any booth um so we're just going
to have to remember that when we account
for our our time
TI
okay so uh let's continue adding some
more constants to our our problem so
each uh booth has an object which has
coolness CI weight wi time TI um Tim uh
is carrying a bag the
bag uh has uh can can hold uh a
particular weight B um so this is the
max weight
weight that Tim uh can hold in his bag
at any given
time uh and
finally you know Tim is a a greedy
Beaver but he also uh can go home uh you
know or go back to his Dam I suppose uh
and empty his bag right and so H is the
amount of
time uh to go
home uh and
back uh and and empty his bag in the
meantime and again just to be annoying
don't forget he encouraged plus one to
get in the next line this is what made
my answer wrong and I'm bitter so I'm
going to keep complaining about it okay
so of course uh what he wants is the max
you know it's sort of a what would
economists uh call this I I don't know
but but for for Tim the beaver he wants
the Max total
coolness um or MTC uh which is of course
a number that we're all trying to
optimize um in K
minutes like you might remember those
old uh TV shows where you get like some
like one minute in a grocery store to
empty the shelves into your cart uh kind
of thing um so he wants to do this uh
and and uh the computation time that
he's reserved for this is order
nbk I know that was a big setup I tried
to document all the different Conant um
that are in this problem I don't think I
missed any here okay fabulous so
incidentally you know continuing
on K uh K is the total amount of time uh
that Tim the beaver has allotted uh to
do his job fair uh uh
Scavenging fabulous uh right any any
other
uh cool okay um notice that this is
going to be an example of of a problem
that was sort of not Kosher in last
week's problem session in the sense that
K is included in our runtime right but
like what is K it's just a number K
doesn't scale in the size of your
problem in a linear way um so it's it's
not going to matter for how we solve our
problem but it is just a feature that's
worth uh pointing
out okay so how do we solve uh dynamic
programming problems we use a sword poot
um or a Senor uh BST uh if you are
watching previous iterations of this
course okay so uh right so let's let's
do
that see I'm trying to conserve board
space this is not going to end up uh
succeeding so again like what are all
the different sub problems here well
somehow what are what are the different
things that are are limiting Tim the
beaver you know what are what are his uh
constraints well he only has so much
time and somehow this is going to sound
more philosophical than I intend but you
know time always moves forward for Tim
the beaver so it's a pretty good
candidate uh in terms of of dynamic
programming because there's not going to
be some cyclical dependency remember
that in dynamic programming we're all
about trying to identify topological
orderings in our sub problems and when
you see something like time not only
does it also begin with t uh but it's
it's useful in the sense that time moves
forward uh there's never a case where
Tim the beaver you know purchases like a
weird warp speed airplane and somehow
goes back into in time um that that
doesn't happen in this particular
homework problem and and for Tim the
beaver's sake I hope in in no homework
problems um so instead of the so so this
is a Long window way of saying that time
is a pretty reasonable uh uh constraint
to put in our problem or not constraint
as much as index I
guess moreover there's another thing
which is uh limiting Tim the beaver
which is the capacity of his bag
remember he can only hold weight uh
B but this one should give you the
heebie jibbies a little bit because this
problem as a
Twist has allowed the bag to empty
itself out right so it's not true that
somehow you can come up with Sub sub
problems where um Tim the beaver is just
monotonically decreasing the weight of
his
bag however if he does choose to
decrease the weight of his bag he has to
spend time doing it so time continues to
move forward for Tim the beaver and
that's what's going to give us our our
topological order yeah this is a little
too philosophical I guess but in some
sense this is a long-winded way of
saying for our sbot Paradigm here um a
totally reasonable thing to do would be
to have x i
j uh I don't think in this class we do
this definition notation so just x i j
equals um the max
coolness um where he has I
minutes uh and he has J
weight let me glance at my answer to see
if it's left in his bag or weight that
he's carrying left in his bag either one
would make a reasonable uh problem I'm
just bad at looking at my notes and
seeing them disagree with the board so
I'm going to try and and and stay
consistent okay so XI is the MTC but in
I minutes with J weight left rather than
in K minutes with B we which is going to
be our base uh problem okay oh no I did
it out of order like disregard that
we'll get to the b in a minute
okay okay so now uh so so that's our our
our our uh sub
problems so now uh let's do the r and
sort
hate this classroom so
much I'm sorry so right so so let's say
that that that Tim the beaver uh has has
IM minutes left in the clock uh and he
has J weight in his bag he's got a
number of actions that he can take yeah
uh and and let's think about what all
those actions are by the way there's one
thing that plausibly Tim the beaver
could do but he doesn't really need to
is is like do nothing now but then in 10
seconds do
something like it just you could do
account for that in this problem but
like there's there's sort of not a
reason right like he might as well stack
up all of his actions and then leave all
of his leftover time at the end um you
convince yourself that that's sort of
okay you know Tim prefers a compressed
uh schedule um right so he's he's got a
lot of energy this this Beaver it's what
they say their nature is uh construction
workers something
okay right so let's think about all of
our options so for one Tim the beaver
could not do a damn thing he could just
sit around for the rest of time and and
that would be perfectly fine so another
different way of putting that um is that
he could give up how much coolness would
Tim get from giving up zero that's right
kids giving up makes you zero cool um so
okay uh right so um Tim the beaver is
trying to maximize uh he has a lot of
different options one of them is zero
meaning he gave
up right notice he could recurse like X
I guess what would be you know he could
give up for one minute right and have
that be X IUS one J or something um
forget if I'm going to do i+ one or IUS
one I minus one
J but there's no reason like he can just
give up and and stop like that would
just be extra recursive calls for For No
Good
Reason okay the next thing that he could
do is he could get in for a booth right
um so first let's work out what happens
uh then so for one um he gets coolness
let's say that he gets into Booth K so
he gets coolness CK when he does
that and now he can recurse so first we
have to account for the time so it takes
I so it takes TK that's a
t time or does it no because it takes an
extra minute for him to get in the next
line or to get in this line line I guess
this is better um and
moreover uh he needs to account for J
minus WK like that can he always do this
no he needs to have this much time
remaining and he needs this much time in
his bag
or this much weight remaining in his bag
um you guys can work out the inequality
but since I only have a foot here I'll
just say if
applicable
this is a great way to lose points on
your homework uh but for Board Writing
it's okay so so when I say applicable I
mean these two numbers have better be
greater than or equal to zero okay uh
and you can do this for all K right so
in other words he can choose to get into
Booth
K and Tim has the third option which is
he can go home okay so what happens if
he goes home does he is he cool when he
does Tim the beaver get cooler when he
goes home
no I'm afraid to to to say so
um in par but he does spend time yeah so
how much time does he
spend
age what was
that he should have lost coolness by
going home no home is cool guys
especially this semester stay home stay
indoors um so he he uh right so he he
loses home time H and one to get in the
next line okay um but you know he's got
a devil's bargain of sorts uh he he he
loses time but he gains bag bagginess
weight is the word that I'm looking for
um B like that okay um again in this
case remember that he still needs if I
is greater than H right otherwise he's
in
trouble by the way I wrote this in kind
of an annoying way this is a different
way of saying that is IUS H minus one is
greater than equal to zero which is
really what's applicable in our
recursive call but this is strict
greater than sign that was another
little thing that caught me up when I
was reading the answer here okay and
those are all the options for Tim the
beaver yeah um notice that every one of
our options either gives up
completely or decreases time so we have
our topological order which is again
that the arrow of time always continues
to move forward I'm going to prove that
rigorously by putting a check mark next
to the letter T again on your homework
you should write out your answers uh
what is our base case for
Tim
well how much coolness do you get if you
have no time zero coolness that's how
much um
so we have this expression x0j equals z
for all J incidentally um although it's
perfectly fine to have this be your your
base case you actually in some sense
didn't need it because Tim the beaver
always had the option of giving up um so
you could I guess in this problem have
no base case if you really wanted um
would be okay but kind of
weird um
okay what's our original problem well he
starts out with time K and weight uh
capacity B in his bag so it's x k b and
then finally uh we need to do our
runtime
analysis so how many sub problems are
there well again I sub problem is
basically just the number of indexes for
for most of our our dynamic programming
problems right so there's
um so the first index is time the second
one is bag size this is always between
zero and B this is always between zero
and K so there's order k b sub
problems um how much time does each sub
problem take well notice that I have to
lose
over all of my different options K here
so I
incur oh I'm
noticing K is abused in our answer to
this problem we should use K only
once okay so here's here's here's where
uh I made a mistake and I believe it's
in the written solution but I'm not
going to check now um there's K which is
the total time that Tim the beaver has
and there's the K that I use as an index
here and those are are not the same I
guess I can make this K Bar really
fast there you go problem
solve and I just noticed that because I
was doing my runtime and it's not order
k um it's the loop over all the K
bars how many K bars are there well
these are all the different booths and
there's order n of those so this is
order n time per sub problem which gives
me a total runtime of order K
BN um which I believe uh oh our desired
run time was order nbk but I think we
can convince ourselves that indeed those
are are the same thing okay so my
apologies for a slight uh uh overloaded
uh character here but honestly it's kind
of one of those things if you read the
answer you probably wouldn't even notice
but now that I'm saying it out loud I I
am okay and that uh solves uh Tim the
beaver's uh maximization problem he's a
very cool Beaver any uh any questions
about this one notice that both of these
problems are are very similar in nature
I basically just wrote sub Problems
indexed by every possible thing uh and
then enumerated every possible solution
U I think this is totally sensible like
I again I remember I had a math
professor in college that always would
use this phrase like it's important not
to think here um and and I think this is
is absolutely true uh for these dynamic
programming problems somehow they look a
lot more complicated than they
are fabulous so problem three protein
parsing ah yeah so this one
this one also got me tripped up for a
minute because the runtime they want is
not the runtime of the obvious solution
but it kind of sort of is after a little
bit of uh uh fixing okay so uh Professor
uh laric Ander uh has a
laboratory and that laboratory processes
DNA Tada um okay so let me go to my
notes here because I think they're
easier to
read right so a of DNA as we all know
because we're MIT
students uh is is equal to basically
strand of characters that are like a and
g if you ask me to name what those stood
for I I could make a stab at like one or
two of them but I'm a failure of a like
I did not have the G because I went to
Stanford and this is why I'm apparently
a poorly educated person according to a
person in a faculty meeting um but in
any event um
right so we have a strand of DNA is
basically a long string of characters
that are one of four options I'm told
that there's sometimes like a fifth and
a sixth option but not too often this
problem there's not um and uh moreover
um so a strand can be cut up so I have
this big long Strand and I'm looking for
certain like markers in particular I
have a
list P of uh
markers um which are really a sequence
of less than or equal to K uh
nucleotides by the way this really is uh
something that the people do like like
string searching really is applicable to
processing the these DNA strands
obviously I think in in practice these
techniques have to be a lot more
resilient to error um but really A lot
of these algorithm recovering are not
all that far off from from how people
process these giant data sets which is
pretty cool I think um okay so what are
we going to do we have uh a string uh
and then we're going to make a division
um so we'll call our string s and our
division D um which kind of looks like
D1 to
DM which are uh
substrings uh that concatenate to make
uh uh the full the full
guy
so if s is our our our input string then
a division D is just like chopping up S
into little substrings uh Each of which
we can give a name Little D here so big
D is the full uh division Little D is is
all the little pieces you know there's
that that old song about going through
the Big D and do me Dallas I think it's
for divorce I don't know um right so uh
okay
so the
value of a
division is the number of uh
strands so strands are these little D's
here
um that are in our list uh P okay uh and
so uh right so given S and P what we
want is the max
value
and the runtime that we're budgeted is
kind of a weird runtime and this should
make us a little suspicious um so the
the max value is Big
O of I think I wrote it slightly
differently in the problem but whatever
I distributed a
k like that so it's K mod P uh plus k^ s
mod s right so so we have two terms here
which somehow smells funny in dynamic
programming okay
so what are we to do well what I did is
I ignored our desired runtime came up
with a dynamic program noticed that it
was a little wrong and then fixed it by
wrong I mean it was it was correct it
just wasn't fast enough okay so let's do
version one
here
1.0 that makes it more
accurate um they're more precise right I
always confuse those two uh so so here's
a sort of thing that it's going to be a
little bit funny because it's going to
look like we're going to have an easy
computational problem but then it's
going to turn out that it's actually too
slow so in particular uh in our s in
sbot um what we could do is
say XI is going to be the
max
value of a
suffix if you're wondering I don't know
the difference between prefix and suffix
but I wrote the word suffix in my notes
and checked it at home
um s i comma colon see it's suffix
because it starts at I and it goes to
the end huh no
comma in mat lab it would be a comma and
that's a colon and that's an i okay
thanks um I'm inventing my own
programming language on the board as we
go
today all right so um and notice this is
kind of a reasonable set of sub problems
right because kind of obviously if I if
I Lop off off you you know some some
piece of my string then the max value I
can get is just the the value of
whatever remains yeah so spiritually
this somehow feels like the right uh uh
dynamic programming and indeed we'll see
that it is but it it just requires a
little bit of liptick at the end to to
run in the right time okay so let's do
our recursive call and this is actually
straightforward
um at least the sort of recursive call
that you want to make uh is
straightforward and then we'll see that
there's an equivalent formula which is
the one you'll see in the solution which
looks more complicated but is is the
same thing so I'm going to write it as
pseudo code for a recursive call rather
than as one giant formula because I
think it's easier to follow not pseudo
code I know that's that's frowned upon
in this class a a a description of a set
of steps for obtaining our recursive
call rather than um a formula so in
particular uh we're going to initialize
XI to be zero
uh we want to do a maximization problem
so initializing a variable to zero is a
sensible thing to do and remember what
what can we do here so we're looking at
a suffix I could go down my list P of
all the different markers see if any of
them matches the first couple characters
of my string if it does I get some value
and then I hop on to the next thing does
that make sense
um oops I'm realizing I have a slight
mistake here um rather than initializing
to
zero I actually have one additional
option that I forgot to account for
which is I could just not use this
character I could I could I could put it
in its own little snippet and and get no
value from it right so maybe initially I
make a recessive call like that it would
be okay to initialize it to zero and
then do this but
whatever notice we're already seeing the
T in our sort bot start to kind of stick
out at us we're going to only depend on
bigger indices I okay but in addition to
this this isn't enough right this would
obviously just recurse the end of our
list and and do nothing uh we get value
if we can find a substring that's in our
our our list so what we could do is um
for each
marker uh in P remember p is the list of
things that we're looking
for okay um um what could I do uh if the
marker
matches um s starting at
I I'm going to just not even attempt to
do python uh starting at I and ending at
the length of the
marker well what could I do I could get
one dollar by by Mark you know by
matching that
object and then I have to hop forward
the length of the string uh in my
recursive call right so
um well I could do that or I could not
do that and I want to maximize right
so I could keep my old value or um I
could get one point by using this as my
match plus x i plus um the length of the
marker okay and this is actually in my
mind the simplest possible Dynamic
program you could come up with this is
actually a totally fine Dynamic program
we'll just see that the runtime isn't
good
enough okay um so does everybody agree
this is a way I could solve this this
problem and it would give me a correct
uh answer um I'll do the
tabbot yeah that's what we're going to
do but we're we're going to maybe skip
some parts of sort bot um so in in
particular um what's the topological
order notice that I always look to the
right uh when I make a recursive call um
what's my base case well in this case
it's just uh X of of zero I guess
because I'm looking forward oh I'm sorry
my base case is X of of the whole length
of the string which is going to return
zero right because if I have no string I
can't get any value out of it the uh
original is X of zero meaning that I
want the whole string and let's actually
do the runtime analysis as as uh Jason
suggests because that's of course the
relevant computation here um so this is
T2 because it's the second T in sort F
okay so how many sub problems are
there well there's I mean it almost
looks like we should have a fast
algorithm because our our sub problems
are only indexed by I right um so
there's one sub problem um for basically
each character in the string so there's
mod S Sub problems
total but how much time does it take for
each sub problem well let's be
careful so there's a for Loop over all
the markers in P so I know that I
incur at least mod P work uh in my sub
problem is that all the work that I
incur kind of looks like it because
there's only one for Loop and there's an
if but how do I check if strings are
equal I have to iterate over the length
of the string so I incur a second cost
which is checking if two strings are
equal we know that our strings are at
most well I didn't actually write it
down but the problem tells us that our
strings are at at most length
K so I incur another factor of K in
every one of my sub problems and that
implies that our whole algorithm that
I've I've outline for y'all above takes
mod S k^
2 oh I'm sorry that was a lie if I
actually multiply these things together
what I get sorry this is I need more
sleep s PK and that is against the rules
that's frowny face yeah uh because in
particular I took two big numbers in
some sense and multiplied them together
uh and and and and that's no good so
what what is a person to do you know I I
tried to solve my problem I came up with
by the way for from a partial credit
perspective I think you'd be be doing
okay if you got to to this point okay
not great but okay um but of course the
problem is is is asking you uh to solve
this in this funny uh runtime which is
KP plus k^2 uh uh s yep when I see a sum
like this in a you know remember that
there are two problems to solve there
are two strategies for solving problems
in algorith class there's one which is
useful in your everyday lives which is
to devise algorithms there's a second
which is to psychologically diagnose
your instructors um and I think that
second strategy is actually pretty
effective here I see two terms most of
our dynamic programming things involve
filling in a table where you would
expect there to be a product so in
general I would kind of squint at this
and Think Like H maybe I have to do some
pre-computation yep in particular um we
got to do a lot of string matching in
our problem and maybe we can make that
more efficient yeah that that's sort of
the the the main question here
um right so so this thing is too slow
and we're trying to fix it the way I'm
going to try and fix it is to say like
okay well I have mod S Sub problems if I
look at these two terms how much work
can I actually do in my sub problem
something that looks like K squ maybe
plus this amount of pre-computation see
what I did there okay so let's uh let's
do
that so in particular here are the types
of queries that I'm going to have to
make
there's a bunch of times in my code when
uh here's a number that he falling apart
that's what I get for sprinting across
campus to get here uh I'm going to
define a me a number m
j and it's going to be
one if the substring
s i oh man
2J uh is in my list of markers p
and zero
otherwise by the way why is this enough
like notice that I'm not answering which
marker but the problem doesn't really
care right like this problem just checks
if there is a marker and if so then I I
use it yeah so if I have this thing
that's going to somehow make this for
Loop a heck a lot easier because now I
don't have to do string matching we'll
return to that in a
minute okay so my question is how can I
compute this thing and by the way notice
that I know how to compute this when the
difference between I and J is bigger
than K right because I know that all of
my markers have length K or less that's
going to be important because even
though m is doubly indexed uh I don't
actually need to do that in fact I could
even store it uh using less memory than
that if I wanted to by kind of just
storing that that diagonal block okay uh
right so the other thing which I think
we saw in a previous uh problem session
as well is that when we do a lot of
string matching it often pays to put our
strings into a hash table uh so that
they're easier to look up later like
does this string exist in in this thing
or not right rather than matching every
character every single time um so maybe
we do that just for for for for fun uh
and in general when you see a string
matching problem I might and you have a
list of strings I'd suggest thinking
about hash tables just for for Fun and
Profit yeah so in in step one here maybe
I put
all the strings in P into a
hash okay um how much time does that
take well I have to process every string
right find its its code um which is
going to take order K time there's mod P
of them so this is K mod P
time notice that that conveniently
agrees with our first term here so we
feel like aha we're in we're in good
shape we're making progress here um and
now uh maybe I want to fill in this M J
uh object uh here how could I do
that well for one I'm certainly going
have to iterate over all possible eyes
yeah so let's let's uh let's do that so
we're going to do two by the way I mean
like using ones and twos and as's and
B's and whatever these are just ways to
denote steps of
things uh okay
so let's say that I just want to fill in
M um using a brain dead algorithm so I
could go from one to the size of my
strings for
I careful now I can't incur an S squ but
I know that my strings are always at
most length K so I could do
for J
equals uh I + 1
2 I + K so this for Loop actually incurs
K time not mod s time and now uh I can
do two things right I can find the uh
hash of the string from I to J right
this is going to take order K
time
and I
can uh search for it
ah
[Music]
no uh um to see if it's actually in our
uh hash table of p and if it is uh then
I set m equal to one otherwise I set m
equal to
zero uh right and these are our sort of
constant time operations at least in
expectation so how much uh cost to it
and and so this you can convince
yourself uh fills in that array M how
much times does it take well I have a
loop to the size of s I have a loop of
size K I have a second second Loop of
size K here to compute the hash so this
whole thing is going to take order k^ 2
mod s time like that notice
conveniently there's chalk on the floor
and this is uh the second term in our
runtime so this is kosher we can fill in
m and and and and and that's a
convenient object to have around so the
only thing that remains is to revise our
R from above um to make use of the M
that we have uh and that's pretty
straightforward
um so the trick is to not lean against
this thing and to actually hit the stop
button I'm I'm learning so now I suppose
we had T2 for the second
T So for our revised R we should have R
Prime
um what was that the Der that's that's
right the derivative yeah we could do
you know like christopal symbols like I
J Prime semicolon K
uh take 6838 if you want to learn what
christopal symbols are um right so uh
Now what is my recursive call for
XI well I want to
maximize uh well what can I do I can
check every possible length of a string
um that could be in P che check if it is
using my array m
um and and get that amount of profit so
in particular I get
M by the way I keep using the word
profit here I'm essentially using that
to mean increment in every single one of
our our problems here I like to think of
our problems as maximizing profit
because I'm a greedy Professor so this
is m i j which would be like one if I
found a string there and zero if I'm not
plus
x i + J to account for the length uh uh
here where J
is in one to uh well
either the length of the string or I get
to the end of either the maximum length
of a string in P or I get to the end of
my
array like that okay and this is our new
recursive call the one thing we should
double check is what is the runtime for
actually filling in X now well there's
still mod S Sub
problems and now how long does it take
well now I just have one Loop over K
things this is mod s * K it's actually
less than any of the terms that's in our
uh
runtime and so this is fine this
actually is kind of a funny example
where the dynamic programming part of
our our algorithm once we've done all
this cute pre-computation is actually
insignificant um compared to all the
pre-computation that we had to do uh in
our final runtime
sneaky all right any questions about uh
protein folding or whatever it is that
we just just
did okay so as usual I'm talking too
much cut one of yeah which one would you
prefer to cut I have very few
preferences okay so one of the problems
um I would take a vote but with our
audience there's a high probability of a
split jury here um right so there's two
remaining problems in the problem
session as usual uh your
instructor you can leave it there this
is another problem learn about
um uh right as usual I've talked too
much and and and haven't gotten to the
end I get the impression that in 66 this
egg drop thing is a bit of a tradition
anyway um so maybe we'll we'll cover
that problem really fast do they do that
in section some variation not this time
even
better okay so yeah so maybe we'll do uh
this this egg drop thing mostly because
the other one I think takes a lot of
verbal setup the other one is
is I would say from a dynamic
programming perspective Maybe not super
exciting but from like a interesting
problem perspective is is is is kind of
cool uh to think about um so I'd
encourage you to leave it in there and
you guys can can read it at home um from
a coding perspective it's also kind of
fun I noticed the solution didn't do
what I would do which would be to use
the the bits in the you know like assume
that something wasn't too tall and use
the bits in like an integer to store
your binary
variables but that's an old hack right
that's sort of like you know this this
old hack for computing the square root
of a number that's apparently in the
Doom the code for the Doom video game
which involves like bit shifting and it
happens to agree with square root for
some magic reason that numerical
analysts really hate um okay so right so
uh let's do a lazy egg drop instead so
that's problem
four
okay so we're in a
building our building has n
floors um and K
eggs I guess it's debatable whether the
building has eggs or the residence but
uh in any event I have some set of eggs
uh and maybe I'm in the state of Center
or some other weird building so I don't
have Heights of floors that are
isotropic but rather each floor has a
different height which could vary
um so it's height of
floor or I really want to write flower
um but I digress
uh and we're going to assume that that
our our list is already
sorted so in other words like the fifth
floor is taller than the fourth floor uh
and we don't have to like spend nlog end
time uh doing that okay uh right
so apparently in our our problem we have
an egg with a mysterious mechanical
property that we are trying to
recover and all eggs as we know are
identical so you know the only
difference between eggs is like chicken
versus Goose versus like struggling to
think of a third category of poultry
turkey thank you um right but assuming
that I got all of my eggs at the same
Stop and Shop and they all come from the
same species then they have roughly the
same mechanical properties actually the
probably the better setup is that floors
are very far apart relative to the size
of an egg um and if I get high enough my
egg when I drop them on the
ground like that uh
breaks didn't break but it could have
broken uh and of course if I drop it
from an even higher height my egg still
get going to break however if I have a
very low floor apparently a very low
floor maybe this is a house for mice um
you know when I drop my egg it actually
stays intact uh and and the question um
as all good scientists want to know is
what is the highest floor in my building
from which I can drop an egg and uh have
it remain
intact
and the question
isn't is kind of a funny one it's sort
of like experimental design in some
sense it's it's not asking like what is
the you know like given this and like a
list of experiments you know try and
figure infer something about the eggs
but rather it's saying sort of if I
carefully design a sequence of floors to
drop my eggs from from which upon I drop
my eggs then um you know in sort of what
is the maximum number of experiments I
need to do to triangulate in on that
that floor that critical floor above
which my eggs break yep um so what I'm
given are the heights of the floors and
a budget of eggs in some sense the
budget of
eggs sort of doesn't matter more than
just like putting a cap on the size of
our our problem in some sense what
really matters is I'd like to use fewer
than K eggs to determine that because of
course the remaining ones I'm going to
use to make an
omelet but notice the I can be a little
sneaky in my experimental
design that
like what happens if I drop my egg from
a really low floor in my
building well it remains intact so I can
slep down the stairs I can pick up my
egg and I can use it for my next
experiment and I have not paid an
egg yeah um so the first question you
might ask is like well why the heck
wouldn't I just start on the first floor
drop the egg if it's not
broken you know go on to the next one
and then drop the egg and so on that
would be the most egg efficient plan and
indeed that is the case because you'll
only break at most one egg but you're
spping up and down the stairs a bunch of
times when you solve that right like
every single time you got to go retrieve
the The Unbroken egg you got to run down
the stairs pick the thing up and then
run up to the next floor and maybe uh in
your optimization problem rather than
trying to like minimize the number of
eggs that you break you're trying to
minimize you know the expense on your
your your quads and and and so instead
you're trying you know you you skipped
your leg day or whatever and the thing
that you're trying to
minimize is the sum over the
heights of the drops in your experiments
right so you're trying to determine the
um mechanical property of your egg uh by
designing an experiment like like sort
of a procedure that minimizes number of
times that you need to to drop uh eggs
because every time you do you got to run
all the way back down the stairs and go
look at the pavement and see if the egg
broke or not that's a lot of work okay
uh this is different from the sort of
classic egg drop 66 problem which I
encourage you guys to go uh seek out in
previous uh iterations of this
course uh let me see so so right and and
so the the question is what is the
minimum the minimum number of egg drops
you need to do to ascertain that for any
type of egg
yeah so I give you a mystery back basket
of eggs and you have to design an
experimental procedure uh and bound the
number of of of this this particular
value here given a budget of of
kxs okay uh and um the amount of time
that we have to do that is order n cubed
K apparently our building we have lots
of eggs and not very many
floors okay because our our setup uh
make some sense here we're just trying
to avoid running up and down the stairs
that's the M the main takeaway
okay so uh what are we going to do sort
bot because that's all we know how to do
yeah um and and in particular we're
going to make one observation which is
kind of Handy if I drop a floor o if I
drop an egg from a
floor you know in this deterministic
universe where egg mechanics are very
predictable um there's only one of two
things that can happen either egg broke
broke or
didn't or I run into the board again um
so let's think about our experiment
remember at the end of the day we're
trying to figure out the tallest floor
in my building that I can safely from
which I can safely drop an
egg so if I think about kind of
bracketing that height of that floor
notice that I can
always for one thing do I ever need a
bracket that's like not a continuous or
like a connected set of numbers the is
no right it's never it should never be
the casee that like I think that my eggs
could be on Floors one you know like
only the prime numbered floors in my
building or something that really makes
no sense right because if I convince
myself my egg breaks at floor five then
obviously floor 6 through n my egg also
breaks in so I always can kind of just
keep narrowing down some
interval right uh so in particular
here's kind of a clever s in my sort bot
which is to
say that I'm going to say that x i j
e is equal
to the
minimum by the way this is I'm writing
this as minimum total height so this is
like the minimum total times I got to
run down the stairs and check my EGS um
or total height that I run down the
stairs the number of stairs I run down
uh assuming my stairs are one foot tall
um where I have e eggs
left notice the way that we've written
the problem this time I might as well
use all of my K eggs like that doesn't
cost me anything what cost me is running
up and down the stairs um
and uh that I have floors I through J
inclusive uh to
check so in other words if I'm on a
floor below floor I I've convinced
myself my egg won't break then if I'm
going to floor above floor J I'm
convinced my egg will break
okay so what do I do well remember that
this is sort of an experimental design
problem I can drop my egg from any
floor um f which is in the range I to J
right and of course there's never a
reason for me to drop an egg from a
floor below I or above J because we
already know what happens in that case
okay
so what happens uh when we do that well
if I drop it from floor F I have to pay
uh in terms of my cost function right
because I have to pay the height of F I
got to run down the the the
stairs okay um but in exchange for that
I learned a little bit about my egg
problem right I either get an upper or a
lower bound of f depending whether the
egg broke okay so let's uh let's let's
let's let's form that mathematically so
in particular we have x i j
e well what do I get to control in my
life and what do I have have to deal
with what I have to deal with is the
fact I don't know what's going to happen
to the egg it might break it might not
right and the Egg might be an
adversarial egg like it wants you to run
up and down the stairs and I have to
account for that but uh I am the eggs
adversary and get to choose what floor I
drop it from so remember like uh we saw
an example I forget what from class
where there was sort of a game right one
guy was trying to minimize the other was
trying to
maximize in some sense the egg is trying
to maximize the amount of work you have
to do running up and down the stairs uh
uh to do your experiment a better way to
put it is that we're trying to Upper
bound uh the amount of work in your
experimental
procedure and I'm trying to design a
procedure that minimizes my work right
so let's say that I'm the player so I
want to minimize
um
and the decision that I get to make the
control that I have is what well it's
what floor I choose right so let's say I
choose floor F Well I have to go down
the stairs so that takes me
HF I suppose going up the stairs is
probably what incurs the HF and going
down is nothing um but I digress but now
my I still am not done I've narrowed
down into one of two cases right either
f is my new lower bound my new upper
bound and I have to account for both of
those in my recursion and I have to take
the max of those two in the sense that I
need an every possible case that my AEG
drop experiment Narrows down my floor uh
to to to a width of of zero y so in
particular this's actually a this is a
Minimax problem there's a Max inside of
a Min here um so what's either the egg
broke in my experiment or it didn't
right so if it did broke
then well what happened well let's see
here um if the egg broke then I got an
upper Bound for my floor so my lower
bound Remains the Same it's I my upper
bound it's F minus one because it broke
on floor F well what happens to egg eggs
when they break I can't drop them from
floors again so I lost an
egg
okay so this is uh my egg brow
okay or my egg didn't break so in that
case well my egg didn't break now I have
a lower
bound so I'm only unclear about floor is
f+ one uh but uh the upper bound didn't
change it's still
J and how many eggs do I have well my
egg didn't break so I can run down the
stairs which is going to be tiring right
I've accounted for that here but at
least I can reuse my egg so I didn't
lose
anything okay
okay
and I get to choose so notice
oops so do you guys see why there's a
Max here essentially I have to account
for every possible scenario when I'm
when I'm designing my experimental
procedure but I get to minimize in the
sense that I can choose what floor at
every step so um right so in particular
uh my f here is in the range I to
J like that
okay and now we have our recursive
formula for our our our egg drop that
minimizes total height um so now let's
uh finish off sort bot in four minutes
it's actually not too hard so I think
we'll actually make it for once by
removing 20% of the problems I'm
supposed to cover um all
right so first of all what's our
topological
order so
this one seems kind of annoying
because I think usually we think of
spending stuff in a lot of these uh
dynamic programming problems but do we
actually spend an egg not necessarily
right because in this recursive
call you know the number of eggs I had
remained the same so maybe that's not
actually a great way to establish a
topological order but instead what do we
know like what is in science the purpose
of an experiment you know uh it's to
improve our understanding of the world
in this case our world consists only of
eggs and floors of buildings um and in
particular once I dropped that egg I
learned something about my building and
I narrowed down the range of floors that
are uncertain for me so in
particular I know that x i j e
only uh
depends on X I guess I prime J Prime e
Prime
um with what well my sub problems I
always have a smaller range of floors
than I did before so in particular J
Prime minus I prime is going to be
smaller strictly than J minus I and
that'll give me my topological
order cool uh and so that's actually to
I think the sort of annoying part other
than working out this Minimax expression
here uh the remaining uh things are not
so hard so uh what are our base cases
well let's say I have zero eggs left but
I still have a set of Uncertain floors
that's bad news yeah so yeah so that
should be
infinity and the reason um is of course
um I'm going to take the Min here right
and so I obviously I should never choose
Infinity as a as a Min um so in other
words I I should never choose an option
for a floor that could possibly lead me
to an uncertain scenario um when I run
out of achs yeah um in addition to that
there's another base case here right so
this is like I've got no eggs left but
some FL us to check uh there's a second
one
I IUS one e so in this case I've got e
eggs left and I'm done right i' I've
narrowed it down to uh uh the bounce
incidentally the way I wrote it in terms
of inclusive versus exclusive might be a
little
fishy over here you guys shouldn't be
off by one like your inspector often is
um but in any event you're you're zero
right there's no more floors left to
check you you've narrowed it down to a
range of one again something that I'm
out of time so I'm not going to check
carefully is if my bounds are inclusive
should that be i j minus one I IUS one
or just I I but I think you guys are all
smart enough to work that out at home
what should my original case be well now
I have all the floors to check and all
my eggs in my uh metaphorical basket
here so I have um floors is one 2 N here
uh and the problem tells me I have K
eggs when I start and then finally I
need to do my uh sub problems
here I think you can actually simplify
the the argument that that's written
down a tiny bit um and just again look
at your your sub problems so they're
indexed by three
numbers I'm going to do a really
conservative estimate I think the
problem actually works out a better
estimate but then ASM totically it's the
same um what's our bound on the first
and second index well they're both just
the index of floors um which which go
between zero and and N yeah obviously
you could do better than that because
the lower floor is always less than the
Upper Floor which is what the problem
accounts for um but if I'm being lazy
then you know well there's n
squared uh sub problems to account for
the two floors uh and the third index uh
is is your eggs which you have MOS K
of okay uh how much work um do we have
per sub problem well uh let's see here
there's a for Loop over f f is over
floor again if I'm going to be really
conservative right well there's a most
uh n uh Flor is total my build and so
that leads us to a runtime of n Cub K
which is what we wanted at the end of
the day okay
um there should be a big O here because
I think technically this is n plus one
to account for floor
zero
okay and that uh that solves our our ACH
drop uh experiment again I think this is
a nice one and I think in my mind
actually in terms of dynamic programming
this is one of the harder things to get
right which are these sort of
Minimax games you could probably I'd
have to think about it which in my
negative -2 minutes I'm not going to
have time to do I think in in lecture
the way that we solved Minimax problem
was we separated out the Min and the Max
and we thought of there being two
dynamic programming problems that were
sort of interacting with each other you
could probably write this one in that
form as well I guess just by kind of
pulling this term out and thinking of it
as a different array um but this form is
perfectly fine too either one's all
right but in my mind these are are sort
of the hardest things to get right in
dynamic programming so I would choose
whichever one jibes in your uh brain so
uh in your thing should we choose to
leave it alone there is a fifth problem
here which as usual I haven't managed to
uh get to where you're kind of building
Walls by placing tiles this is an
interesting one because your runtime is
exponential um but the problem tells you
that that's
allowed but there's like some
exponential things which are okay and
some that are not right like essentially
what you don't want is like product of
two giant exponentials you'd like to
just get it down to one um basically
saying it's going to be polom if you a
small height that's right or it's it's
polinomial in everything except for the
things that's exponential in and and and
moreover the things it's exponential in
are are small and and the problem say
that so I I encourage you guys to take a
look because it really does take some
time to logic through it but the setup
for that problem is I think longer than
my glacially slow board uh writing can
can handle um but with that uh we'll
call for the
day