all right folks
uh i think it's about time to get
started uh thank you guys for for making
it to our problem session and i guess uh
talking to many of you guys virtually
given the number of people in the room
but that's perfectly fine
uh right so we're in uh problem session
number two for 6006. hopefully you're
all in the right place i'm justin
uh i think i was looking i was looking
at a little spreadsheet of who's
teaching what and i think you guys are
stuck with me in a lot of these uh
problem sessions which actually i think
in terms of hours of video means that
you're stuck listening to my voice the
most
uh so sorry in advance uh but but in
in any event it's always fun to do this
kind of thing and it gave me the
opportunity to do homework which i have
not done in a very long time
um so last last night i worked through
all these problems and
came up with my own hacked together uh
answers these which thankfully more or
less agreed with what was in the the
answer key which i have and you don't
uh i think that we released on so
there's a bit of a
there's a known bug in 6006 which is
that this instructor has horrible
handwriting
um i'm working on it i went to the
classroom and practiced the other day
uh but uh in the meantime there are
horrible handwritten notes that are
posted in the the
learning module at least for the
duration of the talk today and we'll
decide whether we want to leave them up
or not because they're not
super exciting um just so you can make
sure you can follow along with that i'm
writing on the board and
as with before if there's ever anything
that you can't read just stop me
and i'll gladly uh fix cool
so uh right so hopefully does everybody
have a copy of the uh
problems it'll look a little different
from this the green stuff is the answers
i get
i get those and you don't uh or sorry i
always ask this question when i'm
teaching and
you never get to answer does anybody not
have a copy of the problems in the
problem session
fabulous okay if you don't there there's
a pile of handouts up here
here i'll grab one for you um
yeah uh great so you know the the basic
goal of the problem sessions is to
go over a bunch of example problems
which i believe are mostly lifted from
past
years uh homeworks and exams and and you
know work through
how we went about thinking about them uh
and and a solution or at least just kind
of sketch out
enough that we're confident you could
fill in the blanks of a solution given
our
limited time together um
right and of course uh one of the
pleasures of teaching this problem
session is this is not normally the
class that i teach so these really are
problems i haven't seen before
uh and indeed in the middle of the night
last night i woke up and realized my
answer to the last problem was totally
wrong
uh so if you feel that way sometimes the
feeling is mutual
so in any event there are four problems
on your handout
that roughly i think are in
correspondence with the stuff we've
taught over the last week or so
so the first problem involves
recurrences the second involves
infinity stones the third involves uh
some kind of a cue stack
structure uh and the uh the fourth
involves like all kinds of things
talking to each other in a way that i
got wrong
um so i guess for lack of a more
creative thing we'll just go through
these guys
in order uh and essentially this is
supposed to be an interactive
session although it doesn't really look
that way um but since you guys are the
people in the room you have the
advantage of being able to stop me
the second that i a make a mistake or be
say something that confuses you and i'm
relying on you
to do that okay no that's our deal today
some kind of acknowledgement noses out
of the laptops maybe for a second
cool thank you see thumbs up that's what
i'm looking for okay
all right folks so uh right so let's
start with uh problem number one here
so problem number one is solving
recurrences which is like our favorite
way to torture undergrads and algorithms
classes in the first couple weeks
uh and in particular applying this uh uh
master's theorem
so i thought i'd spend about 82 seconds
reviewing master theorem
um because this is sort of the giant
sledgehammer uh for
solving recurrences without
understanding why you got the answer
that you did
and then for each of these problems uh
conveniently this homework problem asks
you to do
uh each uh big o thing twice right once
using master theorem
to kind of get you used to just applying
this little set of rules which is sort
of the most
efficient way to solve our currencies it
just gives you a formula to look at
uh in addition to that drawing a tree of
computation
and and kind of counting the number of
computations you do so the first two
are basically straightforward
applications of uh master theorem the
third one
uh requires a little bit of thinking so
naturally i got stuck and wasted an hour
yesterday trying to convince myself the
answer was right
okay so uh for a tiny bit of review i
know that you also did this in uh
recitation but it can't hurt to bring it
up again
remember that master's theorem
uh i believe that master really is just
because it's general right there's not
like a guy named master but i noticed
that it was capitalized a lot in the
course notes uh
but in any event uh the basic idea is
that i have some recurrence that looks
uh like the following
which is t of n equals uh a
t of n over b uh
plus f of
n right so for instance uh
in merge sort uh for a tiny bit of
review remember that we kind of split
into two pieces
so both a and b and merge short would be
two yeah
and the amount of work that i do in the
merge step is kind of like n
so that's how to fill in these different
constants there and the question is
asymptotically
what does this function look like and of
course that's not totally obvious from
this formula because i've defined t
in terms of itself right and that's the
sort of annoying part of solving
recurrences
and so master theorem and and i'll let
you guys review your your section notes
about precisely
how this gets proved uh it essentially
divides into three
cases uh and and the relevant numbers
here
are as follows right there's an a a b
and an f and so the a
is kind of like a branching factor right
so if you remember your computation tree
right like in merge sort you split it
into two
pieces right so that number is kind of
like a it's the number of splits that
you make
right uh b uh is the amount of that your
problem size reduces when you go to each
of those leafs
then finally f is the amount of work
that you do at each note yeah so
hopefully that the basic language makes
sense uh and then
essentially what you learned from master
theorem uh is that there's three uh
cases
the first is that f of n
uh looks like by the way in the
recitation notes for some reason it's
kind of written backward like they give
the answer
to master's theorem and then the
condition i'm going to write in the
other order um
right looks like the following which is
n to the log
base b of a minus epsilon
for some
[Music]
positive epsilon i'm going to try to be
very conscientious about reading my
writing out loud as i write it down
all right and in that case what we find
is notice there's something kind of
magic here which is that this is just an
upper bound there's not a theta here so
it's okay if if f is below this thing
but in any event um the conclusion then
is that t
of n is big theta
of uh n to the log base
b of a it's kind of cool if you think
about it you only have an upper bound
for f but you get a nice a theta bound
for
t which is pretty cool the reason for
that is essentially the f
is sort of insignificant relative to the
work of just traversing up and down the
tree
that's case one case two
i'm gonna try and leave this on the
board as we actually solve these
problems
is the following which is f of n is big
theta of n to the log
base b of a multiplied
by log to the kth power of
n this is like a super weird form but
like for example
you can it's perfectly kosher to take k
equals zero in which case it starts to
look like case one right
um for some uh positive k
or non-negative k rather
in which case uh what we learn is that t
of n is uh theta
of uh n to the log base b
of a uh times log
to the k plus one of n
you can see why we don't love applying
this theorem in this course because i
feel like just staring at these formulas
is like totally unenlightening
but it is a giant sledgehammer for
solving recurrences quickly
uh and then finally
case three i'm going to slide the board
up and i'm going to slide it back down
because i don't want to
bend over okay uh is
the following which is f of n
is omega right meaning that it's lower
bounded
uh by n to the log
base b of a plus epsilon
uh for some
epsilon greater than zero
and we needed a second case uh
what's it called a f of n
over b is less than c
f n for some
c between zero and one
and what's the conclusion there then it
turns out that the f term sort of
dominates
and what we get is that t of n
is theta of f of n
[Applause]
okay so essentially uh this covers three
sort of major cases that you see in
recurrences there are other more
kind of generic versions of the master
theorem out there where essentially
rather than just having
one term with a t in it like maybe you
saw more than one term with a t in it
i don't think those are covered in this
class i always confuse the name of the
more general one i want to say
arzela escuoli but i know that that's
from functional analysis aquapasi
uh theorem um if you want to google that
learn more
uh but in the event that's going to be
enough for for most of the recurrences
we care about in double of six
so i've at least written our conditions
down and now they're gonna sit on the
left-hand side
while we do three example problems to
show how they show up in practice
are there any questions about like what
this theorem is telling us about life or
how to apply it
don't speak at once now yes no problem
what's the after sum the last line oh
for some c in zero one
not inclusive fabulous question
any others
okay so let's uh let's do an example uh
problem here
um so let's do part a right so
in part a they give you a recurrence
which isn't all that different from
merge sword or
or any of the other ones it looks
something like this t of n
is equal to two t
of n over two uh
plus and then they have some other term
which they don't tell you anything about
beyond that it's big
o of theta of a big o of square root of
n
by the way this might mean that it
actually does order one work right like
it just has to be upper bounded by
square root of n that's the only thing
the problem's telling you
i'm going to keep kind of driving home
that point because i think everybody
including myself gets really sloppy
about like when is it o when is it theta
when's it omega
and so every single time you write one
of those letters down you should like
step back 50 feet and look at it and
think like did i do that right or did i
just write a greek letter
right and and make sure that you're
actually thinking through it logically
okay so um when i apply
master theorem in my everyday life what
i like to do is to say
okay somehow the really key quantity
in master theorem is this this this dude
right
n to the log base b of a right he just
keeps showing up in all these different
cases
so i might as well figure what that is
for my recurrence
yeah and then plug it in and check which
case i'm in does that make sense
so let's do that uh so first of all uh
what is a
in for this particular recurrence two
what's b you're killing me guys on three
one two
three okay the enthusiasm is
overwhelming
okay and what do we know about the
function f
yeah it's big o of root n we don't know
that it equals root n
but we do know that it's at most upper
bounded by something that kind of looks
like root
eric gave me a whole lesson on this
chalk and i'm still failing at it
okay so uh right so now uh that gives us
everything we need
uh to compute n to the log base b of a
we're gonna do this one real slowly and
then we're gonna do the next one a
little more fastly
quickly so n to the log
base b of a well that's
n to the log base 2
of 2. maybe an idea what's
what's the log base two of two
one okay i'll take it this okay
right and so then what does uh what does
master theorem
tell you well in some sense i want to
know what f
is which in this case looks like square
root of n compared to
what this is n to the first yeah
now first of all which of these two
things grows faster
this guy right so what do we know is
that f
is really kind of upper bounded by this
n here
upper bounded is not quite the right
term because big o allows for some
wiggle room but like asymptotically
hopefully you guys get this concept
okay so uh so in particular
let's see so so remember that f uh let's
maybe just write it again so f of n
is big o of square root of n but let's
write that
in a suggestive way as n to the one half
yeah in particular this is equal to big
o
of n to the one minus one half it's a
beautiful thing about one half
yeah but what is n to the 1 well that's
n to the log base b of a
right that's what we just showed here
right
so this is really o
of n to the log b of a that's a
complicated way of writing the number
one
right minus one half and let's give one
half a special name too while we're at
it let's call him epsilon
or her yeah where
we take epsilon equals
see what i did there now what does it
tell me of uh
uh there are three different cases of
master's theorem and take a look at what
i just showed i showed that f
n is equal to big o of n to the log base
b of a minus epsilon
for sum epsilon that's equal to one-half
the beautiful thing about one-half is
that it is greater than zero
yeah so i think we have somewhat
laboriously
checked that we are in case one any uh
dissidence here
fabulous okay so in that case master's
theorem
basically you're just done right so what
is the conclusion
exactly so t of n is theta of n to the
log base b of a but we already showed
that's equal to n
so we're done
all right any questions about how we uh
apply master theorem here
okay so now so here's the thing about
master swim do we learn anything about
like what this recursive function is
doing
no we just like did a bunch of work
plugged in some greek symbols and out
came
a big theta yeah um so
what we might want to do instead uh is
to use a method
that i'm still learning myself because
uh i'm not used to presenting it this
way but that's okay
uh which is to actually draw out the
tree of computation
yeah so let's actually do that so let's
say that i call
my function t of n so what does t
of n do well in some sense it does work
that kind of looks like the square root
of n
right and then it makes two function
calls
each of which has n over two amount of
data
yeah so so let's draw what this looks
like so the first thing that my function
might do
is work square root of n much
we put a little square root of n there
and now it makes two function calls
and how much work does each of these
guys do
so when it calls t what goes into t
n over 2 exactly so it does square root
of n
over two amount of work
at each of these two notes
does that make sense okay so now
that's determined by the french you have
to be careful so the branching number in
this case they happen to be the same
the next problem we do they'll be
different um so they're both two here
the outside two refers to the fact that
there's two children
and the inside two refers to the fact
that i divided by two it's a fabulous
question because it's exactly what i got
wrong when i did this problem
okay so now each of these guys
calls uh one of their children yeah and
so
again the data divides by two right so
now
i have the square root of n over four
like this yeah
if you're wondering inside of each of
these circles it says square root of n
over four
okay
okay so let's say that uh
so so now meanwhile in our function call
tree here
how many nodes are in just like the
first level the very top
one right this is just this dude yeah
one uh node
how many nodes are in the second level
two or if we want
two to the one nodes
here there's four yeah which is two
squared
nodes
and so on okay so now we kind of have
some pictorial
representation of what's going on inside
of our uh
recurrence if you look at the courses i
wrote out i wrote out one more layer
just for
for fun and profit um so now let's see
how this helps us actually solve our
recurrence
so what do we know
how many levels are in this tree well
our algorithm kind of stops when the
input to t
looks like one right so
since this divides by two each time
uh the tree has a log base two
of n levels in the tree
yeah and each level
does how much work
so be careful so uh each level
let's call that level l right so we'll
we'll say
l equals zero l equals one and so on
so there's two different things we have
to account for when we account for the
work in this level
right one is the square root of n over
two and a single node the other is the
fact that there's two different nodes in
the level
so in level l
so the amount of work in level l is
equal to the product of those two things
right so how many nodes are in level l
two to the l yeah okay
and how much work does each one of those
nodes do
it's like n over two to the l yeah
so uh a different way of writing that is
the square root of
n times two to the minus l like that
this is just n over two to the l
fabulous so now we have everything we
need to
actually work out our solution to the
recurrence
okay yes what does that say this is
n times two to the minus l
i appreciate this i'm gonna i'm gonna
work on this more
and that's why i also share it online
the handwritten notes is what this is
literally a scan of the page that i'm
holding in front of you
okay so if we want the total amount of
work in our tree
right if we want to account for all of t
of n then what are we going to do
well we have to sum starting at level
0. i'm using l instead of i because i'm
an analysis person and i is the square
root of -1 and i don't like eyes in my
algorithms
but in any event how many total levels
are there in my tree well we know that
there's
log base two of uh n
right and now we have to sum this
quantity for all those levels right
two to the l the square root
of n times 2 to the minus l like that
okay and then what do we know secretly
from from the master theorem is that we
we're suspecting that this is going to
be theta then right so that's all we
gotta check
okay so let's let's do that real fast
so first of all notice that n here this
n term doesn't depend
on the cement so i can just pull them
out right so this is really
this is the square root of n times the
sum over
l equals zero to the log two of
n of uh
what um
oh and there's a mistake in my uh notes
oh man
oh no this is oh all right duh
okay so you have 2 to the l and you have
a square root of 2 to the minus l
so this is really two to the minus l
over two
so you have l minus l over two and this
quantity is really
two to the l over two like that
does that make sense so this is just
properties of exponents from from high
school class
and in fact uh i don't like this because
l over 2 and i want to blindly apply a
formula without thinking about it
and so of course this is really the same
as
the square root of 2 to the l power
right it's just properties of exponents
okay so
what is this sum called do you recognize
this so there's some constant here
you're taking it to the elf power and
then you're summing it over else
this is called a geometric series right
so it would be like
1 plus x plus x squared plus x to the
third and
x to the i guess in this case log base 2
of n
yeah so uh conveniently there's a
geometric series formula out there
uh it's in i wrote it down in the uh the
handwritten notes but maybe uh for now
because i'm moving slowly as always so
we'll skip that part
uh and what you could um
is as follows that this is the square
root of n
right that's just this outer part times
uh
on the inside you're going to get the
square root of 2
to the log base 2 of n plus 1.
uh minus one
divided by the square root of two minus
one
and this is just the this is the
geometric series formula
so i encourage you guys to go back home
and google that one if you forgot yes
okay why are we doing why are we
calculating in some of the series
because what we're trying to do is
figure out the total amount of work in
this tree
right so what we've done so far we know
that
a single level in this tree is this
value and now we have to sum over all
the levels from zero to log base two of
n
okay and what is what do we use this
number for because we're trying to
actually approximate or at least bound t
of n
right and t of n is the sum of all these
values oh
okay and theta of n is not a sufficient
sound it is a sufficient bound we just
got it from
kind of a boring way this is a second
way that we could have proved the same
formula
yeah i see a question over here um
the root n two minus l part i understand
the num the two that l is the number of
nodes
second part oh
okay this is the number of nodes this is
the quantity inside of the circle so
notice that it's
square root of n and then square root of
n over two and then square root of n
over four and then square root of n over
eight
right so two to the minus l here is like
you know one half and then one fourth
and then one eighth yeah
fabulous any other questions yes
and we started indexing
uh boy i hate my bad at this stuff uh
no right i think this is like this is
correct uh
let's see so let's say that i have uh n
equals two
right um then what's going to happen
yeah no this is correct so so as a
sanity check uh think about n
equals two so how many levels should
there be it should go from l equals zero
and then l equals one
and then i'm done because i have t uh
and that i think
yeah so the log base two of of two is
one so
yeah so this this formula checks out
okay any other uh questions
these are all great questions you guys
are keeping me honest
okay so we have this giant ugly
expression here
uh and so our final job here is just to
simplify it that's it
uh and then and then what we're gonna
find is that this is secretly just theta
of n a little surprising given you know
that this is kind of ugly
okay and by the way this is just a
constant so this term on the denominator
is not going to end up mattering for
our asymptotic calculation okay
cool so let's see here so remember that
the square root of two
is uh two to the one half yeah so i can
do a little bit of reshuffling on our
formula and and what i'm gonna find
is that this is exactly the square root
of n
times one over the square root of 2
minus 1 that's just this constant here
now i just have to cope with this funny
term inside of here
i'm going to do the following i'm going
to say well 2
square root of 2 is the same as 2 to the
1 half so i'm going to write this
by moving that one half upstairs here
right so what am i going to get at the
end of the day is that this is the same
as
2 to the log base 2
of n plus one
and all of that uh oops plus one half
right because there's a one-half
exponent that got multiplied by the one
uh minus one all right so this is just
an identical expression to this one all
i've done is move the one-half upstairs
and finally now there's some order in
the universe right because what is 2 to
the log base 2 of n
n exactly very complicated way of
writing n
so this is equal to the square root of n
times 1 over the square root of 2 minus
1 which is just a constant
i see your hand i'm going to write and
and then i'll catch up with you
and now this whole quantity is n times
the square root of two
right oops
wait
um oh i'm sorry
that should be right because we moved uh
we moved the one-half into the exponent
i didn't account for it
so this is the square root of n uh
multiplied by the square root of two um
what's that
n over 2 times the square root no i
think this is right
yeah it doesn't make me nervous
okay so finally now we can start to see
the big o come out right because now we
have the square root of n
times itself plus some other stuff which
is obviously going to grow slower than
the remaining terms here so we're good
[Applause]
if you're wondering the official
solutions are actually incorrect they
too get this a little bit wrong
i'm going to fix that tonight and then
we'll post them for you guys
uh and this unfortunately is the kind of
thing you do a lot of where you're gonna
take your tree write down this giant
tree formula here
write down a geometric series of some
sort and then start bounding terms until
you get to the expression you want so
now you can see why master theory maybe
is kind of valuable because it saves you
a lot of headache yes um when we write
up our presets and we have to write up
trees like this
and take pictures yeah i don't see why
not it's uh they don't have to like draw
it in dixie or something
oh you can take pictures of diagram
songs the math doesn't
take yeah i think i think if you're like
just writing out your math
taking a photo of it and then like
backslash include graphics of your photo
yeah but just for the figure i think
that's
yeah like when i write research papers
that's how i do it until the final draft
yeah okay so essentially what do we just
do in this problem which is part a of
one problem
uh is essentially just show two
different ways of solving a recurrence
right one is the sledgehammer
that's very efficient but not terribly
illustrative the other is really working
out all of the work that happens at
every level of our tree
doing a giant sum and then and just
actually deriving the the proper formula
and both of these are just different
ways to skin the same cat is that a
weird phrase
i don't know okay so uh
right so actually uh part two i believe
ends up being easier by a funny fluke
even though it looks like it's harder
uh so so let's do that uh next here so
i'm going to leave master theorem
on the left-hand side i really want to
say master's theorem but i guess that's
not right i'm going to leave the master
theorem
on the left-hand side
and just do the problem over here
i'm gonna do this one a little bit
quicker because i prefer not to spend
the whole session on one problem
okay but i do think it's worth spending
a few minutes going over this theorem
and how to apply it carefully because
well otherwise you won't okay
all right folks it's a workout up here
[Applause]
so in part b uh we have a version
where the branching factor and the
amount of the work reduce
uh reduces or not the same so now we
have to be a little bit more careful
in the way that we apply master theory
right so now in part
uh b we have that t
of uh n here is equal to
eight t of n over four
[Applause]
plus and now in the problem they write
big o of n
times the square root of n we're all
grown ups here that's the same as big o
of n to the three
halves yeah that's this arithmetic
okay so first let's apply the uh the
master's theorem so uh
let's see so what is n to the log base b
of a in this case well
what is uh b four
what is a eight
anybody know log base four of eight
through wow you're good
yeah so this is equal to n to the three
house and notice that these two things
agree now
yeah so which of the three cases of
master's theorem are we in the master
theorem are we in
are we in the first one where like one
of these kind of dwarfs the other
no we're in case two right where they
both kind of behave similarly
yeah so this is case two
and what is the value of k uh for case
two that's relevant here
do i need a log factor no these two
terms are just the same
right they're both n to the three halves
so this is case two with k
equals zero yeah and in particular
immediately we get that t of n
is uh let's see we're in case two so we
have
theta of n to the log base b of a
times log to the k plus one of n so you
have to account for that term so it's
like that that makes sense how we apply
to master theorem in that case
yes so how do we apply case two of this
video
how can we apply case two
if f n is big o and not big theta
well this is coming from a grad student
so why don't i ping it back to the to
the
the students in the class rather than
answering myself can you read the
question
sure so let's say that we just have a
big o we don't have a big theta here
or is this at least a simple answer
which maybe is the one that you're
looking for
so what do we know in that case we know
that f n might grow more slowly than
this function but it doesn't grow more
quickly than this thing
yeah would you ever just be big o
instead of b that's exactly right so you
can just replace big theta with big o
and that's perfectly fine
so i don't know if that's the answer
you're looking for but it's a at least
you get a loose bound this way yeah
oops oh i'm sorry that's i i see we're
being
pedantic okay you can just tell me if i
made a mistake
it happens i think it's correct in my
notes it is
okay so the reason our colleague brings
it up in the back is that i made a
slight mistake which is that this is a
big o
not a big theta right in which case the
only thing i can draw
uh down here is that this is also a big
o so i made exactly the mistake i told
you guys to avoid before
yes so then over there
those also be videos uh no yeah now i've
managed to confuse you all
this is correct this entire statement of
the master theory i'm assuming i copied
it correctly
is is right but there's a bit of a
difference remember we wanted to apply
case two
and look at case two so there's a theta
here
but in the problem in the homework
problem they were sneaky
and they only said that f of t is big o
of something so remember the
what's what's the difference between big
o and big theta
well intuitively big theta says that my
function really does look like this guy
that like somehow bounded above and
below
yeah as i go far enough out in big o
there's just a bound above right so this
is somehow looser
and so the way to apply massive theorem
in this case is say well at least f
n is upper bounded i think it looks like
this so the best that i can do
is to replace this guy also with an
upper bound yeah it's a great question
so the reason you chose to use that one
exactly you got to kind of stand back
and squint out it a little bit make sure
that it fits
but certainly it's the case that the
other two parts of this theorem don't
apply
we might as well try to squeeze this
part into the right floor
all right um
so let's uh let's do the tree version of
this and then i think what we're going
to do is skip part three for now of this
problem because it's mostly like a fun
combinatorial problem rather than
something that like actually is going to
help your understanding of algorithms
and then if we have time at the end
we'll come back to it okay
all right so that was the easy way to
solve the problem now let's do the
painful one
where we uh we draw the tree i shouldn't
say that because i think it's the one we
want to encourage
the more enlightening version yeah um
so now at the top of my tree i do and
to the three halves work
and now how many children does this guy
have
careful do you kind of yeah one in two
chances either eight or four
eight right so the outer coefficient is
the number of children because that's
like the number of function calls you
make right that's the way to think about
it right so there's eight
of these guys
okay and each one of these guys i'm only
going to do one level of these
by the way that should not be connected
uh does how much work well remember that
it's divided by four
here right so it looks like n over four
to the three halves
that makes sense how we kind of got this
picture from from uh our recurrence
let's switch to another piece chat okay
so uh
right so in other words uh
if i look at level l of my tree assuming
we're going to index from zero at the
top
how many nodes are in level l
remember it branches by eight each time
so it has
eight to the l nodes
yeah and uh how much
work does each do
well in each level i divide by four
right so it's gonna look like n times
one fourth
to the l to the three halves
right um
right where am i uh
there we are so that's n
times four the minus l that's fancy
notation for one fourth to the l
uh to the three halves
notice that this is exactly the same
pattern as the previous problem i'm just
plugging in some different some
different constants
yes the question of the diagram is if
you had like a really
large a um and you're trying to do the
recovery tree method is that
this type of um work okay like where you
have like if i were grading your papers
it would be but i
you should probably check with your tas
on piazza on that one
um but you know i've learned my license
uh you know i'm not sure you guys have
yet and also i'm not sure i have either
all right folks so now we need to do our
our total amount of work here
right so how many uh how many levels are
there in our tree
here well the amount of data divides by
four each time
and when the amount of data is one then
i'm done
right so the total number of levels
is equal to the log base 4 of n
the basic thing to get right in in this
problem is just where there should be
fours and where there should be eights
okay so now uh what am i going to do
well again as our colleague in the back
points out we only have big o
so we can only upper bound our work but
our work in the tree
is less than or equal to um
really there's a proportion here because
this is just up to a multiple i guess
that's why in the notes they put a
little c in front
um which i can do let's do
c like that uh well we're going to have
the sum
from l equals 0 to log base 4
of n of exactly the quantity uh
this this guy multiplied by the number
of of nodes in the rail
yes is the reason why we made this work
the inequality
because of the because of the big o
that's exactly right
yeah okay all right so what do i uh
get here well let's write it out the big
ugly way first so this is
n times 4 to the minus l this is to the
halves and then this is multiplied by a
to the l but whoever designed this
problem is really sneaky
right so what's four to the minus l to
the three halves
any guesses yeah this is exactly eight
to the minus l if you work through all
of your exponent arithmetic
yeah why does that matter well it
exactly cancels this eight to the l term
here
this is actually exactly what case two
in master theorem is kind of trying to
capture
so this whole thing is equal to
of uh really just n to the three halves
from l equals zero to the log
base four of n all these constants just
go away isn't that beautiful
yes um good question no problem uh-hum
so do people ever use these for like
optimization
in terms of trying to write a better
algorithm like try to minimize the
work per per level
yeah i'm just curious if that's like a
application that
sure i guess so i mean this is somehow a
visualization of how your algorithm is
making function calls
right so like every node here kind of
looks like a call
to your piece of code right so every
time you make a new one it's like making
a call
and then the divide here is kind of like
how much data goes into that function
call
so i think this is a useful way to kind
of visualize what's going on inside of
your code
and then if you're trying to optimize
your code you're trying to basically
reduce the number of
nodes and or the amount of work that
each node does right
yeah so this is just like a nice way to
kind of visualize what's going on in a
recursive algorithm
yeah great question all right
so here's a here's a really nice thing
does n to the three half depend on l
no right so this whole thing is equal to
c times n to the three halves
and my colleague in the back is going to
catch me if i don't if i don't make the
off by 1 error here
so uh this is log base 4 of n
plus 1 because my sum started at zero
yeah and notice that this is exactly
big o of n to the three halves log
n which agrees with what we did in a
much more easy case with the master
theorem
that make sense yeah so we found an
exact balance so could we say that it's
theta of n oh great question
this is where this notation is going to
be misleading this expression
in a vacuum is theta of this value
but the reason that i wrote big o is
because i only have an inequality all
the way up here so if i'm worried about
bounding this work
there's no reason to write a theta there
because it's just telling me some kind
of intermediate piece of information
yeah okay fabulous so
uh yes
does the base of the log matter ah this
is a nice formula here
um so remember that
log base b of a is the same as log
a over log b if i got that right
yeah so the base of the log when it
comes to big o doesn't matter because
it's just a constant factor
yeah okay so that's part two of this
problem part three
is a little bit annoying because it has
two branches in it i wrote out a careful
solution
um it does not apply the master theorem
because it's irrelevant at least the
version that we know in this class
um so we're going to kind of skip that
for now because i don't think it's
terribly relevant to
most of the algorithms that we'll see in
6006 but we'll come back to it if we
have time
uh yes can we make that a lower bound
and an upper bound using master's
theorem
using knowing that t of n over four are
smaller than t of n over three
i'm gonna refer you to the solutions
rather than talking about that problem
uh right now yeah
uh okay cool all right so that's how you
apply master theorem which is
mildly painful the good news is the rest
of this problem set is actually i
consider it to be much easier than the
first one which is why i think it's okay
to
spend a little bit extra time here
because i think this stuff is confusing
to get right
mostly for me and hopefully i've
conveyed my confusion to the rest of you
okay so let's uh erase this and while
we're doing that
why don't you guys all give problem
number two a read
so one of the big skills that we need to
cover in 683
not 6837 6006 uh
is uh the and 6837 but i'm not quite as
evil about it in that class
is as follows which is you read a
problem and for some reason
your instructors have some sick sense of
humor and they
encode it in this totally weird goofy
language
which somehow to a theoretician makes
your problem feel more practical
um so in any event uh you know when you
read all of this paragraph the very
first skill that you have to do
is to figure out like okay like this is
cute notation it's about infinity stones
and if i watch star wars or whatever i
would know what that was what that meant
but um in any event uh
what really matters is understanding
like okay but algorithmically like what
are they asking
yeah so i'm gonna try and talk about
this problem as i erase the board
so i believe um what like mickey mouse
or whatever has a bunch of
uh it's like some planet that he's
looking for uh i'm gonna open
the problem now and uh right she's a
super villain on a quest
she's looking for a stone on a planet
and the planet has some index
k and unfortunately for us there are
the number of planets is is quite large
it's infinity in fact
because it's the infinity stone um
or sorry did i say that i think it's the
infinity phone or something i
i forget but but in any event um the
only thing that you can do when you land
on a planet
is ask an oracle is the index of my
planet bigger or smaller
than the index of the planet that i'm
standing on
right and then the question is in log k
time where k
is the index of the planet notice that's
already a little weird because it's like
not the size of your data
quite um can you find the the planet
now what does this kind of problem like
what is it
screaming out for you to use like you
see a log k you're looking for something
by section right or binary search that's
absolutely right
those are both great answers but
there's a bit of a problem which is that
the number of planets is unbounded we
don't know how many planets there are
in um this this little universe that
problem 1.2
sets up yeah so our intuition is that we
want to use binary search but
in order to do binary search i need to
have a left and a right hand side and
divide and i have no right hand side
so what can i do how's a how's a super
villain to
solve this problem
well remember that each planet has an
oracle on it telling me like is there
something to my left or my right yeah
so i could start at planet number one
and i could just start walking from
planet one to planet two to planet three
planet four and asking like am i there
yet am i there yet
how much time is that going to take
potentially
actually it won't take infinite time i
got you how much time will it take when
will i stop
when i hit planet k right because i know
that planet k is out there somewhere
the truth is out there and when i find
it and i step on it i stop
and i took exactly k steps maybe k minus
1 depending how you count
but we need a log k algorithm yeah so
what could i do
um if you start at some k then
right you can multiply by another case
multiplied by another k
it's actually like proceeded by another
k minus
yeah so okay so you got the right you're
the right church wrong pew
here so the the basic intuition here is
that stepping one planet at a time
doesn't step fast enough
um if you work out the details in that
one you're going to find that you'll end
up with a run time that still
grows a little bit too quickly in in in
k here
right in some sense you one way if you
were to reverse engineer this problem
which isn't really a great way to
problem set you really do expect there
to be powers of two
in every step of your algorithm yes
the binary search of like start in the
middle and
[Music]
this is the right intuition but there's
i have a philosophical question for you
which is what is the middle of an
infinite set of planets
infinite exactly that's a problem yes um
we could
use like um i don't know who it was back
there who was
suggesting using doing i squared verbs
instead for
doing i squared replace it with 2 to the
i that's exactly right that's a great
intuition so let's let's formalize that
a little bit
which is like i could do binary search
if i had a right-hand side i have
left-hand side because it's one
so what i'm going to do i'm going to
keep trying right hand sides and the
oracle is going to tell me
is this a valid right-hand side right
because the oracle is telling me is
there a planet to my left
yeah so here's what i'm going to do
again i don't like the index i in the
official solution there's an i but i use
the letter m
because i can um which is
the following i'm going to visit
i hate teaching no that's not true i
like teaching i just don't like chuck
um i'm gonna visit planet
two to the m for each m um
you know starting with m equals zero
from
and uh essentially until uh
remember that k is the index of the
planet i'm looking for so eventually i'm
going to reach the point
where k is less than or equal to 2 to
the m and i know that i can query my
oracle and they're going to tell me when
that's the case
so how much time does this take right so
i'm going to try
planet 1 and then planet 2 and then
planet 4 and then 8 and 16
all the way up until k
so it's going to take log k time yeah
you also have a
stronger lower bound now to that minus
one
yeah that's sort of right so so right so
eventually what's going to happen when
you stop here
is that 2 to the m minus 1 is going to
be less than or equal to k
less than equal to 2 to the m right
because then then
because this is the condition for
stopping this is the condition for not
stopping
so when you stop k this little sandwich
is true
yeah so if i take the log essentially
what i've shown
is that i've taken right because m is
like the number of steps in this part of
my algorithm
so if i take the log i'm going to find
that i took log k steps
yeah now that's acknowledgment yeah okay
uh
and then well now um now i have an upper
bound and a lower bound
so now what can i do yeah now i can
binary search and that also takes log k
time
that's exactly right oops
so now i have step two is also binary
search and
it's also a log k time and our problem
is solved so problem number two is not
so hard
anybody with me any questions about that
one that's a quick one
okay now problem three really spoke to
me as a computer graphics professor
so uh right so now i am running
for dobie
um i have some
i've collaborated a lot with adobe free
search
um right so uh fidobi is trying to make
a piece of software uh for image editing
and what does my piece of software do
well uh my
my uh my image or i guess my document
consists of a bunch of images that are
overlaid with one another
okay and essentially what's happening
inside of the software is i want to keep
all the images
in order from like top to bottom okay
because when i render uh my photo
what do i do i render the bottom one and
then the next one and so on and just
layer them on top of each other
like if you've ever played with
powerpoint or photoshop or i guess
whatever fake name
they're giving here that's a pretty
common uh user interface to encounter
and so what they've asked you to do is
to come up
with essentially a data structure and
your data structure has to support a few
different operations in particular you
have to be able to make a document
import an image and then stick it on top
uh
display which returns all the ids in the
order
uh that you store them and then there's
a real kicker
which is that you need to be able to
take one of the
the thing one of the layers and stick it
underneath another one
but you have to do that in log in time
it's that butt that makes this whole
problem kind of a pain in the took us
yeah uh so right so again uh here are
operations we've got to make
an empty dot
this is supposed to take order one time
we're going to uh
import which adds an
x on top and that this should take
order end time notice that this is
already a little suspicious if i were
like trying to psychologically diagnose
my my
professors i would look at this this
order end with some
like with a raised eyebrow right because
probably like what would you have in
mind if you're like talking about stacks
of photographs
would be like a you know a stack or
queue or some data structure like that
but then insertion would be like order
one time you know so there's clearly
something a little more complicated
going on
okay uh what's number three
is um display uh
this has to happen in order end time
this one kind of makes sense right
because in order to display n things you
kind of expect to take at least end time
uh and then finally
we have to move below
and this has to take order login time
uh and this is going to be the kicker
right because we really uh this is
this is somehow not totally obvious from
from the way that we set up our problem
so everybody understand the problem set
up so far we just keep adding objects
with ids
and we need to be able to insert them on
the top and then kind of reorder them
and the problem has given you run time
for each of these different operations
okay right so here's the thing there's
like kind of a
sequence aspect to our problem and kind
of a set
aspect to our problem does that make
sense like the sequence aspect to our
problem is that we're going to have to
display stuff in order end time right
we've got to iterate over our whole list
put stuff on top and so on
and the set aspect is that we'd like to
move stuff on top of each other
in log end time and the reason that i
say that this is somehow set
aspect is that i need to be able to put
any x underneath
any y which means that i need to be able
to quickly find
what layer the x and the y is in
any ideas how we could solve this
problem how about some from some folks i
haven't heard from you
yes
yeah that's a really great idea so maybe
i'm going to maintain so remember we've
talked about
uh let's see in in my lecture two
lectures ago we kind of thought of a
sorted list as like a set
data structure so yeah so that's that's
a fabulous idea why don't we
for the set part of our problem
we're going to store in particular a
sorted array
of uh and for now let's think about like
a sorted array of x's
and so this is going to be able to help
us answer questions
like you know is this id in my my set of
images or not
but there's also going to be a second
part of my problem which is in addition
to that i need to be able to keep a
different ordering other than being just
ordered by x
which is the ordering that they're being
like drawn on the screen right that's
different than the ordering of their ids
so for that um good question we're gonna
be building a sorted array
with nothing in it and it's gonna be o
of n log n time but that's undefined
so we can we actually go to this one
we're gonna write it with nothing
hmm okay uh
no i'm not sure i quite follow uh um
it's uh
building an empty sort of array of n log
n time which is o of zero log zero time
and log zero is entered
array yeah building an empty anything
takes one time
oh yeah okay cool cool
all right uh so in addition to this we
have a sequence aspect of our problem
right and for that uh maybe we'll use a
linked list right that's a pretty
reasonable sequence uh uh data structure
and in fact let's think for a second now
we're gonna need this move below
operation right so our links list is
gonna store the order of the images in
our document
in order to move something below
something else we're going to kind of
splice an image in between two other
guys
so for convenience maybe we have a
doubly linked list so that we can like
move backward and forward so that we can
insert stuff
yeah so we'll have a doubly linked list
okay right so
let's start uh solving our problem and
then uh thinking about where uh things
are gonna go wrong here
uh with with our setup here so first of
all i don't think we really have to
write anything for the
for for part one because making an empty
anything is a pretty easy algorithm
on your homework of course you should
write that and tell us that it takes
order one time
now how about uh importing an object
remember so that puts it on the top
of the uh it puts that on the top of our
linked list
and we have to insert it into our sorted
array
right so when we do that
[Applause]
our insert algorithm is super simple
right we're going to add
x to the set which we talked about in
class for a sorted array
how long does this take for a sorted
array to add something
exactly order end time but that's
actually okay because wait that's our
criterion for number two
yeah and in addition to that uh we'll
put
x on the top of the
the linked list
right let's order one time that's easy
i'm adding space because we're going to
see that we made a slight mistake and
that we're going to need to modify our
algorithm a tiny bit to solve this
problem
okay so how do we uh how do we display
i think that's the simplest one right
i'm just going to iterate over the
entire linked list and just
one by one output the order because
remember the whole point of the linked
list is to keep track of all of our
documents
in in order huh so uh
display
all you have to do is loop over
the linked list okay and the real kicker
is the last part right which is how do
you move something below
so so let's think for a minute what
what's what's moving below going to
entail
so is it going to affect the set of keys
that are in my document
no actually right they're just changing
their ordering but both of those keys
were already there
yeah the only thing it's going to do
is affect where they are in the sequence
but there's something really really
annoying
how do i find something in this sequence
like let's say that i tell you the
document 75 has to move
below document 352.
well so far in my data structure what's
my only option
does the set tell me anything about
where stuff is in the links list
no so how much time is it going to take
for me to find a key
order n right because i've got a link i
gotta loop over this whole linked list
and and find the item that i'm missing
is that allowed no the problem tells me
that i have to do this in order
log and time so somehow on our head we
should be thinking like
okay we're gonna we want to kind of use
this set
here to help us find stuff in the doubly
linked list
does that make sense that intuition so
here's how we're going to do it
actually before i do that any any ideas
how can we solve that
yes
[Music]
that's a fabulous idea so here's what
i'm going to do remember that when we
make a set we don't
have to store the keys we can attach
data to our keys yeah and in particular
i am going to attach a pointer
into my linked list it's a really sneaky
answer
yeah so let's say that i have let's do a
quick example so let's say that i have
my documents are
one five three two
and seven like that so my linked list is
gonna be real simple
it's doubly linked see there's two
arrows here
just like that right and now my sorted
array
is gonna store all the keys in order
let's see if i can do this with me one
two
three five seven all right so this is my
this is my linked list
and here's my uh sorted array is going
to be one
two three five seven but then what i'm
going to attach to each of these guys
is a pointer to the element of the
linked list right so he
is going to additionally contain an
arrow here the two will contain an arrow
there
the three will contain an arrow there
the five
uh this is ugly i'm sorry
now here's the thing let's say that i
remove this three here
does that actually affect seven's
pointer
no right so these pointers remain valid
even if i like edit other parts of the
list
really sneaky trick okay
so that is going to be our solution to
this problem is to store
not just assorted array of x's but x's
and
pointers so now we have to
modify a tiny bit you're right
and now uh what can we do to move
something below
well it's going to happen in sort of
three steps right
so
our first step well we gotta first find
keys x and y
right so we're gonna find
x v x and
y v e y in
the set how long does this take
well now we can do it in binary search
right exactly so this is like oh
like that and now uh
what's my next step
well remember the move below operator
sort of removes
x from where it currently is and then
puts it underneath y
right and both of those are like linked
list editing operations right
so i'm going to kind of like you know if
i have a linked list
like one two three four
right and like let's say i want to erase
the two right i think you guys have all
coded this up at some point in your
lives then like what i'll do is
you know add links like that which i can
do because i can move forward and
backward in the list
right and similarly if i want to add
something then i'll like erase the links
put it in there and update the links
how much time does that take let's just
order one time right because now that i
have the pointers to these two locations
i'm just kind of like doing a lot of
rewiring in my my linked list but it's
all kind of local stuff
if you're coding in c this is where your
memory leak happens and your company
gets hacked
okay so uh right so that is uh what
we're gonna do next is update
the linked list and that takes order one
time on your homework if you're writing
out your answer you should have an
answer closer to what i've written on my
page
than the two words that i've written on
the board here
and then finally in step three
well actually there is no step through
the way written in here sorry
if we think of there there's actually
two sort of parts to updating the linked
list right
one is to remove
the old x uh position and then
insert in the proper position
right and when i do that my whole uh
my whole update happened notice that
there's something kind of interesting
about this move below operation
which is that did i actually edit the
set at all
no right that kind of makes sense
because the set is just a set of keys in
my document
and just by changing the ordering it
doesn't affect what's what's in my
document so somehow it was a sanity
check that that works out
so this entire algorithm takes how long
well there's order
log n there's order one and there's
another order one
so the whole thing is log n and life is
good for our problem here
yes um so how can we input such pointers
in real life
how do we input such points like a set
with pointers
in real life got it so i only know the c
plus version of this i'm going to get it
wrong for python
um but i'm not sure that i quite
understand the question so
it's just like pointers anywhere else in
real life uh so i guess in in in python
you know
um what you'll do is you'll create a new
right as you add these guys to your set
you'll create a new object here
and in addition to that you're going to
create a new vx that you add to the
linked list
and then the pointer is just an address
in memory right so
essentially what you'll store notes are
the
are the second l the pointers are pairs
they're a pair of an x value uh and a
oh i'm sorry yeah actually i guess this
right
um no the linked list just contains a
long list of x's
right um but they don't have to be in
contiguous memory that's the only
difference so you make them one
linked list item at a time but it's just
like constructing any other linked list
yeah
in fact there's pseudo code in the uh
the solutions that are are
distributed so you can take a look there
yeah speaking of which um for these
for like implementing these database
operations can we pseudo code the
like algorithms for them i think the
official answer is no
that you really are supposed to write
out in words what your your thing is
doing
now there's a weird gray area of course
which is that the words that you write
are going to look an awful lot like
pseudo code
but uh you you should make an effort to
try and write down a little bit in
paragraph form and b
be descriptive about it this is a good
skill to learn at the beginning of this
course i think it's it's
it'll feel a little pedantic at points
and and that's good because it
should and you should deal with it yeah
no but really yeah try and write things
out in a way that like
captures your logic rather than just
like python code yeah
cool all right so let's see we've got
we've got approximately 17
minutes left in class which is
approximately one-eighth of the time it
took me to figure out the solution to
this last homework problem
but we'll get started uh and i've
written out a careful answer
um because essentially in problem four
i found myself getting stuck in a few
little details and so i figured the way
that i'd write out my little
hand scribbled chicken scratch answer
online was to just basically give you
an internal dialogue of my brain and how
i went about solving these things and
all the stupid missteps that i made
yeah um because i think that's actually
quite valuable essentially it's often
you see in these problem sessions just
like oh here's a problem here's the
answer here's a problem here's the
answer
but the reality is even your professor
especially because he's used to thinking
about
rendering um occasionally gets confused
about these
these algorithms problems especially
when they're frankly written in a bit of
a
confusing way uh and i heard some some
war stories about this problem actually
being on the homework apparently i i'm
in good company
so let's take a look at this last
homework problem 1-4 so this is on brick
blowing and this is a great exercise in
taking
a problem that is described in really
long nasty useless language and then
extracting like the two words that
matter
um by the way like i'm making a joke
about that i can tell you that about 82
percent of my time as a professor is
spent with like people from industry
visiting my office with exactly this
kind of scenario where like
you know they have some really
complicated thing they've been thinking
about their
you know construction problem for like
years and they have all these details
and tables and flow charts and then it
turns out that their problem is like
can be captured in about two sentences
but so it's a good skill to have and one
that can get you a lot of money as a
consultant
so it's one that's worth practicing in
this class even if we're doing it for
pork
pork land with a wolf that blows only to
the east
okay so what's going on in this problem
there's there's a wolf and the wolf can
blow on houses
but for some reason um the wolf likes to
blow to the right
and to make matters even more
complicated whoever wrote this problem
occasionally ordered things from east to
west and other times ordered them from
west to east
if i were instructed of your instructor
at the time that i would have at least
gotten rid of
that's just that's just mean um but in
any event
i believe the story goes as the
apocryphal uh
uh uh houseblowing pork wolf uh
story that we all know and love from our
childhood is uh
there's a row of houses each of which
has a different number of bricks
yeah and now there's a wind
which is blowing from west to east i
remember all this because i was staring
at it this morning in my office
and essentially the wolf being the the
big bad wolf that he is
says aha if i to blow from west to east
i can knock over more houses more
efficiently
yeah because i'm the wind is helping me
you don't want to blow into the wind
it gets you know you're spitting your
face okay so uh the wolf does that
and then what happens is that the wolf
not only
knocks down the house upon which the
wolf blows
but also all the houses to the east of
that house
that have fewer bricks
why you might ask i don't know because
whoever wrote this problem was being a
goofball
but that's the basic setup of this
problem and you can see that essentially
this is just a long convoluted way of
describing something pretty
straightforward
yeah and so at the end of the day the
wolf being kind of an adversarial
uh wolf wants to blow down as many
bricks as possible and we are providing
the wolf with the analytical tools
needed to do so
yeah so in case you didn't think we
covered anything practical in 6006
uh now you know that we we actually are
doing state-of-the-art
wolf brick blowing pig analysis okay so
uh
right so let's uh let's do an example
because this is like weirdly complicated
so the first part of the problem asks
you to just do an example out and i
think
if i were psychologically diagnosing the
person who wrote this problem probably
the reason is that they stood back and
they said nobody's going to understand
this
unless i force them to do an example by
hand
right and so the basic problem is asking
like you know i could choose to blow
on each house which one should i choose
to cause the most damage
or in fact they actually ask a slightly
different problem which is if i were to
blow on each house how much damage would
i cause
okay so let's step through the problem
so they give you an example uh
a set of numbers 34
57 70
19 48
actually let's just stop there i don't
think there's any reason to do like a
list of a million numbers like in the
problem that was just like
you know the more times you do it the
more you convince yourself how useless
6006 is
okay so so uh right so so how much
damage
does blowing on house number one cause
well let's make a little table so if i
blow on house number one
just by default house number one false
i'll pull x there meaning i blew it over
and then the rule is any house to the
right which has
fewer bricks the physics of this problem
drives me nuts i thought about it for
quite a long time and i
i can't think of a wind that actually
has this property uh but any house
that has fewer bricks and is to the east
also gets blown down so
57 does not right that's bigger than 34.
similarly for 70. aha the 19 goes
with the wind uh 48's bigger and the two
goes
right so the element number one of my
array would be three
right three things get blown over
okay for the next guy right so the 57
gets blown over
it does not blow over the 34 because my
wolf only knows how to blow to the right
uh so
it does not blow over the 70 it does
blow over the 19
doesn't blow it does move over the 48 it
does
right so here there'll be a four these
numbers do not match the ones in the
notes because this is a shorter list of
numbers
i should point out okay let's do one
more and then we're going to stop
because this is laborious and boring
so the 70 blows over everything
yeah but only everything to
it's right because as we all know holes
only blow to there okay i'll shut up
uh so there's uh there's four uh there's
four things that get blown over here but
you guys get the point right and so
essentially this problem is asking you
to fill in arrays that look like this
for your problem everybody on board with
the problem
now notice that just by virtue of doing
this example let's think about this
abstractly because i think this is a
problem that's just coded in so many
words and made up like weird ta garbage
but like at the end of the day like this
problem as an algorithmic problem is not
so bad
right essentially what i'm asking you to
do is i look at that 57
and i look to the right and i count how
many things are smaller than 57
and i add one to it and that's the
number that should go in that element of
the array
so notice that like those three
paragraphs that's what they're
communicating you didn't need like
wolves blowing and winds and and trees
and houses and
dorothy and all that kind of stuff yeah
so uh right so so at the end of the day
that's the problem we can think about
and we no longer have to think about
pork land ever again
okay so maybe in the in the remaining 10
minutes here i think we can feasibly do
part b
uh and then part c is a sort of an
extension of part b
i got myself confused on part c so the
handwritten solutions have an incorrect
answer
and then an oops and then a correct
answer in it so you can see where my
logic went wrong
to be fair i i wrote i already knew the
full answer and wrote out both because i
thought that it was
useful um okay so
in case our our problem wasn't contrived
enough we're going to add a little bit
of condition to it and then what we're
going to see in part c
is the that's somehow a stepping stone
towards solving the bigger
problem so in part c they say that a
house in
in pork land is special
if it has one of two properties either
it has no easterly neighborhood neighbor
meaning that's just like the rightmost
house
yeah or its adjacent neighbor to the
east
contains at least as many bricks as it
does
right so what does that mean in terms of
this
list of of numbers which one of these
guys is is special
so the easterly guy is special we just
know that by
default and other than that this special
property is saying that
the guy immediately to the right has a
bigger number than the guy or at least
you know equal to or larger to the one
uh right before it
yeah so 57 is bigger than 34 so this
guy's special
by the way the problem doesn't ask you
to do this on the example but i totally
would if i were solving this
yep um 70 is bigger than 57 so it's
special
19 is smaller than 70 so it's not
special i'm sorry
uh 48 is bigger than 19
and i guess two is special just because
things on the right are special
okay so do we all get the definition
fabulous
so in this problem now
what we're given is that i guess uh
what our our evil uh wolf takes a walk
down the block
and takes a look at you know counts the
number of bricks at each house and
he or she makes an observation which is
at
all but one house is special
now let's think about what that means
let's think about the structure of our
array
so what happens as i walk along my right
if the house is special what do i know
about the next house get blown if you
blow a special house down
that's true but we're already solving
the problem they're listening
qualitatively for a second
like just in terms of the number of
bricks right i'm walking down the street
i'm looking and the number of bricks
increases until i get to the one house
that isn't special
and then it decreases potentially or
it's the last one and then it starts
increasing again
yeah so in other words my array kind of
looks uh
like the following which is that it's
basically has two different pieces that
are both
sorted yeah that's what this long
paragraph is saying is saying
suppose that the list of houses is
sorted except for one thing
yeah that's how you could have said it
okay so uh here's an example so maybe we
have
one two three four and then i don't know
two three four five
so all of these is special with the
exception of this guy sadly for him
and so uh there's kind of like a little
dividing line
that happens to the left of which it's
sorted into the right
yeah okay and then the question is can
we predict
the damage for each house uh based on
this information
um so i want as output to my code an
array that says like
this guy causes so much damage this guy
causes so much damage and so on
and i want to get it in order end time
let's think for a second so yeah we're
going to do that so order in time means
that i can't do i can't afford to do
like sorting and
all that kind of fancy stuff right so
basically all i can do is kind of walk
up and down the array
so we should think a bit about like
what's special about
special oh you say uh what's special
about this configuration that we
wouldn't normally have
anything before the non-special node
should have the same
or not sorry anything not quite
everything after the non-special node
causes only one damage yeah so so let's
think about this
carefully i think that's right but i i'm
bad at parsing sentences
um remember that i always blow to the
right and i only blow short stuff
so if i blow on uh
like this two here will anything before
that vertical line ever get blown over
no because by property of being special
we know that the list is increasing but
it has to decrease to blow something
over
that make sense so for each one of these
guys the only stuff you can blow is in
the second array does that make sense so
we made an observation notice that it is
special to the structure that we gave to
our problem
yeah and moreover so
in both parts of this problem we're
going to kind of look at two parts of an
array and then merge them together in a
smart way
let's look on the right hand side does
any of these things like if i blow on
any of these houses what's the damage
that i do
what you see that because this is an
increasing list i only blow to the right
and it has to get shorter
yeah so for what partial credit on my
homework problem probably very little
partial credit
but you know spiritually it's half of
your credit um
we know the second half of my array is
just a bunch of ones
incidentally one detail which i bet
would get a minus one on your homework
we didn't tell you that all we told you
is that there existed one house that
wasn't special but we didn't tell you
which one
but notice that i can find it in order
end time right i can just walk along my
array and find the first place where it
decreases
and that's the special house yeah so i
can kind of assume that i know where
this line is that's that's
that's kosher so then the only question
is
how do i fill in my array here
right like how do i count and so so
let's think about this mathematically
because how
like porks and blowing and stuff is kind
of confusing so let's think about it in
terms of this array
essentially what am i trying to do so
for this two
i'm trying to look in the second half of
my array and find all the numbers here
that are less than 2.
right that's essentially what this
problem is asking you to do you see that
okay i'm going to make one so
here's a simple kind of n squared
algorithm right which is i could iterate
over every
item here and just loop over here and
count the number of things that are less
than that
right that's a double for loop each of
which could be up to n so that's n
squared
those against the rules can't do it so
we need one more additional observation
okay let's think about this for a second
let's say i'm the wolf the pork blowing
wolf and i walk
from one house to the next and i keep
track of what houses get blown over here
now what happens as i walk from one
house to the left on the uh
to one house to the next on the
left-hand side
they're only getting taller right that's
what it means to be special
so the houses that get blown over here
the set of those only grows larger does
that make sense
right because as these guys get taller
more stuff falls over on the right hand
side
it's like a total goofball talking about
this problem
moreover these guys are in sorted order
yeah so
what's going to end up happening is that
always there's just some interval of
houses
that gets knocked over so for example
the four goes over the two and the three
i guess notice that that always starts
on the left-hand side
and that's because these guys are sorted
right the three just blows over the two
which is kind of a subset of the four
this isn't a great example because those
first two guys don't blow over anything
that makes sense any ideas how could i
use that observation to make an order
n algorithm for counting blowiness
damage
heard a lot from you let's hear from
some of our other colleagues here
another person
yes binary search
tell me more what would i search for so
let's say you have four
and you will buy your shirt for the ride
it's an interesting intuition and it's
like 82 right
so uh the the to repeat our colleague
suggestion which is a good one and we'll
make your code a lot faster
in fact in practical terms would
probably be about the same would be i'm
going to move from the left to the
right-hand side unless there's a very
large neighborhood of pigs
i'm going to move across this array i'm
going to binary search this other
side and find sort of like the first
house that shouldn't get blown over or
something
and now i know that the total number of
things that get blown over now
unfortunately for you what's the wrong
time of that algorithm
n log n right because for every single
guy here
i incur a binary search there which is
log n time so
you're in the right church wrong pew
here
but there's an observation we haven't
used yet which is as i move to the right
these numbers increase yeah
so what's going to happen to the index
of the stuff that gets blown over
it's always going to move this way is it
ever going to move to the left
no so there's a term that we used in the
two lectures ago
which is a term i never heard before but
i kind of like it it's called a
two-finger algorithm
yeah what does a two-finger algorithm do
looks like this
two fingers yeah so
what i'm gonna do is i'm gonna keep my
finger on the right
pointing at the very first thing that
doesn't get blown over
okay so here right the one doesn't blow
over anything so it stays here
i'm going to iterate to the next guy
does the 2 blow over anything
no by the way the problem is written now
i'm going to move this guy here
well now the 3 blows over the the two
here so i'm going to move
my right finger one thing to the right
and move the guy to the four
the four also the lower or anything and
then i guess i'm done
but the basic point here is that i'm
always going to be incrementing two
different pointers
and moving to the right and so what am i
going to do i'm going to if i call this
finger i
and this uh finger
j will i or j ever decrease
no so if my algorithm is looping over
all of these guys and they only ever
touch each of these indices once i'm
going to get an order n
technique yeah and that's going to be
the basic trick to solving this problem
now i've managed to
talk myself out of time but basically
that's it so what i'm going to do
if we have 10 extra seconds is i'm going
to initialize
essentially for each eye
i'm going to increment
j until
the number of bricks at j
is uh greater than the number of bricks
at i
because that should be greater than or
equal to right
and the reason to do that is that now
the number of houses that get blown over
is just this index j
minus the index of the first guy right
and then i'll increment i
and and continue that make any sense
fabulous so i managed by some miracle to
make it to
almost the end of this problem set minus
one part of one problem of course that's
the hardest part of the whole problem
set
uh but there's an answer written out
where essentially now
the question is can you do exactly the
same algorithm but i don't give you this
special
assumption right that it increases and
then decreases
and it's going to be basically an
extension of this idea as we're going to
use this plus a little bit of merge sort
okay so with that we'll see you guys
next week
it's always a pleasure and yeah have a
lovely weekend