okay well uh welcome back to another
problem session it's great to see
everybody's smiling faces again uh uh
right so today we're going to continue
our discussion of graph Theory problems
uh this time focusing on well a little
bit of this a little bit of that some
shortest path problems all pair of
shortest path uh and then a modification
of the dier algorithm to finish us off
for the day um so as always we'll go
through our problem session problems in
order for no reason other than that's
the way they were presented to me uh and
I think roughly isomorphic to how most
of the homeworks in this class go anyway
uh but in any event uh let's get started
here so uh in in uh problem session
problem 7-1 here as always our first
problem is sort of a warmup to make sure
that we understand all these sort of
definitions techniques that we use in
66 uh today uh we're going to go over
Dyer's algorithm so if y'all recall ders
algorithm is a technique for computing
shortest path from a single source to
your rest of your graph uh there's about
a million different ways to explain
understand uh D's algorithm so I'll
undoubtedly revert upon the one that I
remember which is probably not the one
that Jason just covered in lecture but
we'll make it work and of course if
there are any questions we'll we'll we
we'll address those along the way here
uh I'm going to switch to a piece of
chocolate that isn't an e/ of an inch
and get started uh right so in problem
uh 1 a of our homework here we were
asked to run dce's algorithm from uh
vertex s here by the way just sort of a
standard terminology in graph theory
that I think we'll see a lot in the
homework uh is we typically use S for
the sort of starting point of a path or
sometimes the source if we're talking
about Network flows but I don't think we
do those in this class uh and then T is
usually the destination
um why T you might ask because it's the
letter after s uh right so uh our our
first uh task here is to compute the
single Source shortest path from s to
everything else in our graph initially
this looks painful uh but it's not um so
you're going to forgive me I'm going to
write a sort of shorthand version of
DA's algorithm because I'm talking to
you as I solve this problem which of
course it would be much more annoying
for you guys to do uh on paper uh but
that's life in the city uh so so so
there that's my what in the words of
Britney Spears It's my prerogative as
your instructor here okay so in uh D's
algorithm what do we do we initially
label all of our vertices as having
distance Infinity to the source or and
and we insert them into our priority Q
except for one vertex which of course is
our source vertex uh and he or she has
vert uh has distance zero for an obvious
reason which is that if my path starts
at the source it has distance zero to
the source
so as our shorthand what was that do I
want to use red yes of course I
do
uh yeah but see it's this fat chalk man
um
okay zero I can make this work okay so
uh our our convention for today is going
to be if a Vertex does not have a label
on it it is distance
Infinity okay uh so what does Dyer's
algorithm do uh Dyer's algorithm grabs
the closest vertex that I haven't yet
processed uh and closest in terms of the
distance value that I've stored at that
vertex and then updates all of its
neighbors using sort of a triangle
inequality uh style construction so
let's see what that looks like so so far
everything is distance Infinity away
except for one vertex which is vertex s
which is distance zero so obviously that
should be our first iteration of D's
algorithm and now what vertex s is going
to do is look at all of s's neighbors
and update them using the triangle in
equality quality and if they're Closer
by having a path through S to the
neighbor then I update the distance and
if it's not then I don't uh in this case
everything is infinity so it's pretty
clear that I should route my path
through S because any distance less than
infinity is smaller than infinity uh so
in particular notice that there's an
edge of length eight from s to a so now
rather than being distance Infinity away
I can see that vertex a is really
distance eight away oh this truck gives
me shiv
uh similarly here there's an edge of
length
seven uh and I believe that's all of the
edges out of s so we're good and now the
kind of nice thing about the way dier
algorithm Works um which I guess was a
little bit implicit in the construction
we saw yesterday but but that's okay is
that once I visit a Vertex I never I
never touch it again right it gets
frozen in time uh in in distance I
suppose uh but in any event what that
means I'm going to pull a little box
around it meaning I'm done with this guy
he he is no longer in my queue okay
hopefully our pictorial system makes
some sense here again on your homework
problem you actually have to write this
stuff out and I'm sorry that sucks uh
but I don't have to because I'm talking
to you all today okay so remember D's
algorithm we're going to look at our
list of vertices we haven't seen yet so
that's everything except for S find the
one that's closest and process that one
next so in this case that's the seven
here uh okay so let's take a look what
are the neighbors of seven well I've got
s
uh and that's oh and D here okay so
first of all let's take a look at s
obviously if I have a path that goes
through C back through this vertical
Edge to s that path to have length eight
right 7 + 1 eight is bigger than zero so
I do not update s but we actually
already knew that because s was frozen
here so I didn't even have to look at
that edge I could have removed it if I
wanted
to uh okay but there's another Edge
coming out of C which is pointing toward
D that has length four 7+ 4 is wait for
it 11 uh and that's less than infinity
so I update D's distance to 11 and I
don't think I've managed to make a
mistake yet uh okay so now uh We've
looked at all the edges out of
C and C is frozen and we move on okay
next uh let's see among our vertices we
have Infinity 8 and 11 so the smallest
of those three numbers is eight and
we're going to update all the neighbors
of the eight uh which thankfully
although this graph looks big uh they
had some mercy on your your section inst
structure today and and really there
aren't that many edges so this isn't too
hard to uh process but here's the thing
uh there's an edge of length Zero from a
to d here I can get to the a in eight
units so I can also get to the D in
eight units uh by traversing that edge
eight is less than 11 that's good news
do I want to erase it or scratch it out
what's going to be better I'll scratch
it out just to be messy okay so now uh D
is a distance eight from a Vertex s and
I believe that's all the edges out of
a so a
set okay this fun or what so now we look
at all the edges out of oh oh sorry we
step back and we look at all of our uh
vertices we find the closest one that's
D now we got to update all of D's
neighbors so uh thankfully all the
remaining vertices have distance
Infinity uh so what do we know there's
an edge of length one here so I get a n
there's an edge of length two so I get a
10 um and I believe those are all the
outgoing edges from d and now D is set
I'm going to start moving faster because
this is hella boring uh okay now the
next closest uh Edge is the nine uh
notice that the nine only or rather B I
suppose is the vertex which is currently
at distance 9 uh it only has one
neighbor that hasn't yet been processed
which is e uh so we know that that's 9
to 11 12 distance away I'm going to
check my scrap paper and make sure I
haven't made any mistakes yet seven
eight
cool okay so now our next closest vertex
is vertex H which is distance 10 and aha
if I Traverse The Edge upward from H to
E I can get a path of length 11 and 11
according to most mathematicians is less
than 12 and hence we should update the
value
here uh in addition to that there is an
edge of length two out of H pointing
into G 10 + 2 is 12 and I believe that's
it getting there okay so the next
closest uh vertex is e e has no outgoing
edges so e is all
set uh after that we've got g g has an
outgoing edge of length 1 into D 12 + 1
is 13 Which is less is larger than eight
so we don't update uh and similarly 12+
0 is bigger than seven so we don't
update but again the edges that point
into vertices that we've already
processed we really don't have to even
consider uh just by the way that D
algorithm Works notice that if there
were a negative weight Edge where we're
going to come back to uh then that
assumption would be problematic so the
takeaway here is that this guy's Frozen
in stone and now notice that our Q is
actually empty yeah so depending on how
we set up our well it's not empty um but
it only contains one vertex and it's at
uh distance
infinity infinity plus Z is still
Infinity uh so that's this guy's uh
distance here and now we're now our Q is
empty sorry okay so I
believe I managed to do that right
excellent so the problem ask for two
things it ask for the single Source uh
shortest path distance it also ask for
the traversal order which I forgot to do
while I was doing this problem but you
could retrace it pretty easily okay so
uh that's part A then in Part B they say
change the weight of the Edge from G to
C to minus 6 so we have G to C and now
instead of zero we're going to make it
minus six and the question is if I ran
Dyer's algorithm essentially what would
break and I think it's pretty easy to
eyeball remember that g was essentially
the last interesting vertex that we
touched in our algorithm here the only
one that we looked at was was F
and so this outgoing Edge from G
actually wouldn't even be seen by d's
algorithm thankfully until we've touched
all these other vertices in an identical
fashion to our previous traversal uh and
then we finally get to G and now what's
going to happen well if I had this edge
of length Nega six what's 12 minus
6 it's six and notice that that's less
than um seven which is the the label of
vertex C but that breaks our assumption
which is that as soon as I visit a
Vertex I never have to touch it again
right because now I've identified a path
through G back to C that has a smaller
distance than the path that c had when
it was visited in the Q so somehow
spiritually I should add C back to the Q
but that's against the rules in DA's
algorithm right so like for instance if
I did that I I would have to convince
myself that the runtime doesn't explode
uh and that this algorithm terminates
right which could be a problem if you
have a negative weight
cycle thankfully we have algorithms for
detecting negative weight Cycles but
that's a different matter
okay so I think this is pretty
straightforward it's just essentially
asking you to walk through DA's
algorithm make sure you understand
what's going on any uh questions about
that one cool I think this is one of the
easier uh problem sessions so maybe
we'll finish early except I always say
that I talk too much sorry not sorry
okay so uh right so in problem
s-2 um this is an extension of a problem
that we considered I believe two problem
sessions ago
uh and it looks something like this I'm
going to go back into my notes so
remember in two problem sessions ago we
defined the radius of a graph for an
unweighted graph we came up with an
algorithm for computing it and
approximating it all that good stuff uh
now in this problem uh we're going to do
basically the same thing but now we're
on a weighted graph yeah so in
particular we're going to define a
quantity this is problem two uh called
weighted
eccentricity
uh which is associated to a vertex in a
weighted graph uh and it looks like this
so the weighted eccentricity Associated
to vertex U is equal to the
max over all vertices in my graph of the
shortest path distance from U to that
vertex again hopefully our audience will
catch if I accidentally swap the
argument to shortest path because I'm
used to thinking of that as symmetric
but it's not uh because our graphs are
directed um actually in this problem I
don't think the graph is directed
so I forget it's directed okay good yeah
then good I'll try to be
accurate okay and just like the problem
we had uh two PR sessions ago um so the
eccentricity is associated with the
vertex is sort of like the distance to
the farthest away thing in My Graph and
now the radius of My Graph tries to find
the most Central vertex which is the
minimizer of weighted eccentricity and
we call that the weighted
radius and so the weighted ah the weight
o that's a tough one the weighted
radius is a measurement uh which is
associated not with a Vertex but rather
with the graph and it's equal to the Min
over all possible vertices U of the
weighted
eccentricity of U okay and so the
problem here is that we're given a
weighted directed graph with no negative
weight cycle so it may have negative
weights but they can't have a negative
cycle and the question I touched my face
uh the question is what is the uh can I
find uh the radius of My
Graph uh in time uh that looks like
order mod
V cubed
okay now if you recall from our previous
problem session when we considered
Computing the radius of a graph what did
we do well we tried to come up with an a
clever algorithm and then we realized
that that was actually kind of
unnecessary that it turned out that the
kind of brain dead thing where you
just look at the definitions and just
make it work uh was actually good enough
uh and that actually turns out to be the
case here right this is a good reminder
for us all that before we go crazy you
know 66 is a fun algorithms class we get
to learn about cute you know references
to TV shows and and all that um before
we go crazy with that of course if
there's an obvious algorithm staring Us
in the face to solve a given algorithm's
problem we should try that first before
we try something more clever uh and
indeed in this case uh that
works so what are the sort of
ingredients that we need to compute the
radius well the radius is the minimum
eccentricity so what would be the
smartest or the simplest thing to do
rather would be compute the entric for
every vertex and take the smallest how
do I compute the centricity for every
vertex well I have to have the max
distance uh away from that vertex so
what would be a simple thing to do would
be to compute distances between all the
possible vertices and conveniently in
lecture in some day or another I'm a
little confused about the time ordering
of this class because of the way we're
filming it uh we covered an algorithm
that computes the distance between every
pair of vertices and that's called
Johnson's algorithm yeah so if we were
to do a totally brain dead version of uh
solving this problem maybe for
convenience the first thing we do is
compute Delta UV for every possible UV
pair and because our graph doesn't have
a negative weight cycle we can do that
with Johnson's algorithm yeah so step
one is to use Johnson's algorithm uh for
all
pairs shortest path and I'll uh refer
you guys to the lecture for how to do
that um but the important thing is the
runtime of this step of our
algorithm so Johnson's algorithm
generically speaking has v
e plus
v^2 log V hopefully I got that right uh
run time and uh what do we know about
our problem well I believe we're given
that the graph is
connected um and so one thing that we
can do is notice that e is upper bounded
by v^2 I guess even if it's not
connected I'm sorry that was a dumb
thing to say
just generically speaking our graph is
is simple so we know that e at most is I
guess 2
v^2 which means that this term is upper
bounded by V cubed right so we have V
cubed plus order v^2 log V so at the end
of the day the first term wins and we
have this is V cubed time notice that
we're given that budget in the statement
of our problem so this is perfectly fine
in other words this is a longwinded way
of saying it's kosher to compute all
pairs shortest path in the constraints
of our our problem here so that's
convenient because now in step
two well maybe now we just keep you know
we follow we do the the twocan Sam
approach again we follow our noses and
well now that we have our our pairwise
distances we can now compute the
eccentricity for every
vertex for all you just
directly of course in your homework you
should write out what that means um but
here directly just means that for every
u i Loop over every V and I take
whatever value is
biggest so notice that I have two Loops
one over U one over V so this is order
mod v^ 2 time so already the first term
is is dominating here so that's that's a
good thing I guess uh and then
finally we have to take the
smallest eccentricity
of uh any U which just requires one more
for Loop so this time I I for Loop over
this array and I just take the smallest
value right so this is just one for Loop
so that takes order B
time and then we're done right so that's
uh our our technique for computing the
radius and notice that all I did was
translate the definition into an
algorithm I didn't do anything smart in
this problem at all uh and then we
should really quickly double check our
run time so step one take V Cube time
step two two takes v^2 time step three
takes V time so we add them all together
and of course the V cubed wins uh and
that is what was given in our uh our
problem as our our
budget okay so I think the first two
problems in this uh this this problem
session are fairly straightforward are
there any questions so far I'm talking
fast cool all right so now we're going
to move on to problem three involving
atus
kevine uh who is uh you know probably
playing the what the the gunger hams
anger games that was close um sorry
under uh whatever uh you get the point
yeah so before I get carried away trying
to read Jason's uh jokes here um what's
going on in this problem so this is
problem three there's an underground
sewer Network I suppose we also could
have written this problem about MIT
right there's all kinds of crazy
underground tunnels here
uh I remember when I was looking at MIT
as a potential undergrad I they had us
like slepping around in the tunnels and
I thought they were very dirty and I
didn't get the point so I went to
Stanford but uh in any event um right so
uh what I'm given is a
map and uh this thing has uh n
bidirectional
pipes not going to write it down but the
problem tells you that they're all
connected they make
like there you can get from your source
to your target moving through the
pipes um and uh right the and they're
connected at at
Junctions uh but uh at every Junction
there's less than or equal to four
things that come together so just like
in our last problem session every time
you see a phrase like that it's like
screaming out there's a degree bound uh
hiding inside of your graph uh and
moreover uh every Junction is reachable
from every other Junction I believe okay
uh in addition to this uh we're given a
positive integer
length for each
pipe um so it's starting to smell like a
shortest path problem but is it that's
our question uh but just to make things
a littleit but worse atus uh kevine here
is trying to escape through the uh pipes
and she doesn't want to be detected and
in particular there exist
Junctions with uh motion
sensors and apparently atn's uh Intel is
pretty good here and she knows which of
the Junctions in her pipe network uh
actually have a motion sensor sensors uh
that
um that can detect people moving around
okay um now what this problem is asking
her to do is to say like maybe
apparently she knows where the motion
sensors are but maybe she doesn't know
if they're like you know what kind of
brand they are you know is it a
Microsoft sensor or a apple sensor or
something and of course the sensors have
different ranges right so so atus kevine
here she wants to be as conservative as
possible when she traverses this pipe
Network in particular what we looking
for what she
wants is uh in uh n log n time
here find the PATH um that
maximizes uh the distance to the
sensors so hopefully this problem makes
sense so you've got some you know grid
graph well not necessarily a grid graph
but the a bunch of vertices of veilance
4 maybe something like that you know
makes sense you know she's living in a
city somewhere uh and she has some
source that she's starting at some
destination she wants to go and then a
few of these
vertices are marked as having motion
sensors at them and rather than like
giving you a radius or something like
that instead what we're saying is that
she wants to go from the source to the
Target she's willing to walk a long
distance the length of the path doesn't
matter
what matters is that she never wants to
get closer to any motion sensor maybe
there's a second one like here then she
has to okay so like in this case I guess
if I were to eyeball it looks like you
can't do better than one Edge right so
she would go like that uh and of course
uh in an extreme scenario it might be
the case that like there's a sensor at
every Junction in which case she's uh
hosed um but she we'd like to let her
know that before she uh embarks upon her
J here okay so does our our problem make
enough
sense excellent um okay so right so
unfortunately for
us this isn't again it doesn't look like
a shortest path problem and the reason
is cuz you know it's it's not uh but
rather uh it's sort of a reachability
problem in Disguise and and let's think
about what I mean here so
um right so there's an obvious graph
here
we'll call it g out of a lack of
creativity um where what I'm going to do
is uh give a
Vertex per
Junction and uh I'll have an undirected
edge for each
pipe um whose weight is the
length
okay by the way I think the length I
didn't even mention in the problem
description but I
believe she wants to find the shortest
path that maximizes the radius so like
if there are like multiple different
paths that she could take that both have
the same radius from the sensors then
she'd like to be lazy and not walk too
far so that's that's where this going to
come into play okay um that's sort of a
secondary concern I would imagine on
adn's behalf here okay and moreover uh
I'm not even attempt to remember the the
details of this problem but but rather
there's a source which I'm sure has some
cute Hunger Games uh name attached to it
and some other Target
um and these are just two nodes in the
uh the network of pipes and she wants a
path from s to
T okay so first of all uh let's just
count um and make sure that we know uh
so there's uh how many vertices are
there well the problem actually gives a
name to that there's order n
vertices because that's just the number
of Junctions which is what we Define to
be n guess I forgot to write that there
uh and because we have a degree bound uh
our favorite argument uh in this class
uh we know that there's order and
edges as well so that's that's good
news why can't I use this graph directly
like like let's say that I computed the
shortest path from s to T notice that
that completely ignores the point of the
problem right the the point of the
problem is that uh atus wants to avoid
these starred vertices on our graph up
here but the shortest path may not do
that in other words she may have to walk
like a really indirect path to avoid
being detected by the
sensors that's the problem so we need to
be a little more clever than that we do
have to think on this problem a bit okay
but not too much uh and so here's the
basic trick like let's say that let's
solve a slightly different problem first
which is let's say that I give you a
radius k and I want to know does there
exist a path that can get me from s to T
without coming more than distance K away
from the
sensors notice that once I if I have a
tool that can answer that like yes or no
problem I could come up with an
algorithm that that finds my number of
sensors by like looping over k or
something it may not be fast enough but
I could do that okay so that problem is
actually not terribly difficult because
essentially what I could do conceptually
is just remove the vertices that are too
close to the sensors and then solve a
reachability problem like can I get from
s to T without getting distance K away
from any one of the sensors well what do
I do I just remove any vertex that's
distance K away from the sensors and
then I compute reachability so so
conceptually I think this isn't a huge
leap intuitively uh speaking but there's
a lot of details to fill in yeah so
unraveling just a little bit
more we might Define a graph g k and GK
is going to be the sub
graph um of vertices whose
distance uh with uh distance bigger than
K to
any
sensor right and somehow reachability in
this thing can answer yes or no can I
get from s to T without coming you know
distance K to a sensor by way do we know
this term subgraph in this class
essentially it's pretty clear what it is
just from the the word right like
essenti I'm just going to remove
vertices uh that that um inside of our
larger graph and any edges that touch
those vertices uh and obviously if my
original graph had order n size then the
subgraph has Big O of n size might have
less but but it certainly it's an upper
bound okay so we unravel a little bit
more somehow this seems like a
convenient structure but I haven't told
you how to compute it uh and in
particular uh the sort of annoying thing
is uh this piece right I need to be able
to figure out if I'm distan K from any
sensor or more generically speaking it
might be kind of Handy to compute
distance from every from the set of
sensors to every other vertex in My
Graph every other Junction in my pipe
Network
okay well we already covered a trick uh
in our problem sessions so it's going to
help us do that right
because okay what would be a very simple
algorithm for doing that would be to
Loop over every sensor call D's
algorithm for each one right so that
gives me the the distance to sensor
number one and the distance to sensor
number two the distance to sensor number
three and I take the men over all those
and that function gives me the distance
to any sensor that's going to be a
problem right because Dao's algorithm
runs in N log n time but now I've
incurred another Factor because I have
to Loop over all the sensors and we
didn't give you a bound on how many
there
are so more generically this is actually
a problem that shows up all the time uh
in my everyday life which is that like
we don't just want comput shortest path
to a single point sometimes you want
shortest path to a bunch of stuff like
in other words I don't care which sensor
is close to me I don't want to get close
to any sensor yeah uh this shows up in
Geometry all the time like maybe I want
to know the closest you know like I want
to find the closest point on the highway
you know so the highway is driving past
uh my house so the highway is a whole
bunch of points on some Network and I
just want to get on the highway and
start driving um I don't care about the
closest path to every single point on
the highway I just want the whatever
closest to me right so this is a pretty
practical thing to think about so how do
we solve that so um let's say this is
our pipe
Network I feel like I draw this network
a lot maybe I'll spice it up with an
extra Edge okay and maybe uh for board
drawing purposes these two vertices have
sensors so I'm trying to find the
shortest path distance to either one of
these two vertices uh from every other
vertex on the graph or vice versa it
doesn't matter it's
undirected um and I don't want to Loop
over all these sensors that's the basic
headache here so one thing that I can do
is it's kind of a sneaky trick and it's
exactly the same trick that we've
applied a few times in in the problem
sessions here is to add a new vertex
that's kind of like a
source and make that vertex distance
zero to every one of my
sensors and now what I'm going to do is
do single Source shortest path from this
new extra vertex that I added to All the
Rest of My
Graph now why do I do that well if you
think about it well there's an edge of
length zero to any sens sensor
topologically I can think of it like I
glued all the sensors into one vertex if
I wanted but that doesn't really matter
um fact that would be a different way to
solve this problem I guess would be to
take all the the sensor vertices glue
them together into one and then solve
this problem but I digress um right so
the the shortest path distance from our
new uh Source vertex all the other ones
is going to be just the shortest path to
any sensor because notice that any path
coming out of s necessarily has to pass
through a starred vertex okay so let's
write that down um basically uh what I'm
trying to do here is uh in step one of
my algorithm I want to
label
each
Junction with its distance to a cent
answer right that's the high level goal
here and the way that I'm going to do
that is I'm going to make uh oops in in
the problem solution we call it X so
I'll be consistent uh I'm going to make
a new Vertex or a new graph rather G
Prime which is equal to my original
graph G which is coming from the pipe
network uh with one extra
vertex which we're going to call X which
is connected to every motion
sensor
uh with weight
zero okay and now I'm going to do uh Dy
stress starting at
x uh which takes n log n time
because I just gave you the size of our
graph up here and gives me essentially
the shortest distance to any motion
sensor from all the vertices in My Graph
so that's good thing that's sort of like
a convenient piece of information but
when we're solving these kinds of
algorithms problems notice that I've
done sort of a similar reasoning in both
of the last two problems um which you
can do and actually is a pretty
practical way of thinking about
algorithms where like this problem tells
me at the end of the day my algorithm
has to run an N log n time right where
like in the previous problem it had to
run an N Cube time I guess V Cube
time so one thing I can do is say what
is all the information that I can gather
out of my graph in nlog and time and I
might as well compute it right so for
instance the distance to the closest
Center sensor I just gave you an nlog
and algorithm for computing it it seems
like a useful piece of information so
what the heck I I might as well compute
it in step one and just have it around
um obviously you could do breath first
search on all the computable numbers and
this might not be the most efficient way
to solve a problem but I think for
graphs there's only so many things that
we we typically want to compute so it's
worth kind of going down your checklist
like similarly here notice that like we
gave you a budget of of VCB time so like
you might as well compute all pair of
shortest path because we can do it in V
Cube time and why not have that
information around it seems useful for
computing
radius okay so in any
event now in step one we now know how uh
close every Junction is to every
sensor so now I can argue
I'm I'm numbering these like Steps but
they're not really steps these are more
just like thought bubbles so thought
bubble number
two it's going to be how do I actually
construct
GK right and notice I have a nice piece
of information here I now know what
vertices are inside of GK and which ones
aren't right because I can just Loop
over all the vertices if the distance is
bigger than K I keep it if it's not I
don't yeah so that gives me an algorithm
for computing um GK so we can
construct construct starts with a C
construct GK from our original graph G
um and that's really easy to do right
just by looping over the
vertices and
remove any uh whose distance is too big
or too small
rather
uh
V that make sense because those are the
ones that are are dangerous if like the
radius of my sensor is K any vertex with
this is less than equal to K I want to
throw away um and how much time does
this take well there's just a loop over
the vertices I guess I need to account
for the storage of My Graph also but of
course this graph takes less space than
G and so overall uh this takes order n
time
Tim time and
space but there's a catch which is this
is
per K okay so every time I want to make
a new G uh a new GK I incur an expensive
order
n but this is already getting us pretty
close to our problem because what can we
do if I have
GK I can say that
BFS on GK
establishes
reachability from s to
T right which is what we care about um
outside of radius
K and how much time does BFS
take linear the size of the graph I only
ever asked Jason one question which is
you know always has the same answer um
right so BFS takes time linear in the
size of our graph our graph has size n
or kind of 2 Nish uh so at the end of
the day this takes order n so if our
problem were written slightly
differently we would be done right if
the problem said you know given a radius
K and the graph you know tell me yes or
no does there exist a path that stays
outside of radius K of the sensor this
is how we would do that hopefully we all
agree and we can do that in order and
time oh just kidding order n log and
time because I had to do D's algorithm
first thanks okay uh but uh sadly for us
we're we're not quite done because we
want to find the largest uh possible K
right want to to find the biggest radius
that we can stay away from the sensors
uh and still get successfully from s to
T so let's say that I uh want to find
this number so this
is when to Define K star like got a
moving Target to right on is the
largest K
where g k is
connected well that's not quite right
from s to T this is a weird way to
phrase it really this is should say
where there exists a path from s to T
and GK I'm
sorry re uh
yeah where
GK I've just phrased this in a funny
way has path from s to T there we
go all right so our question is how do
we find that well here's a dumb
algorithm I could Loop over all
case construct GK and then if my answer
is yes is reachable then go to the next
K increment by one and start over right
so this is the dumb
answer
uh when I say dumb I mean the answer
that your instructor wrote down on his
notes and then realized was done okay uh
which is
Loop over K until you get to K star I
guess plus one right because once I get
there then I get a thumbs down obviously
getting any bigger than that is only
make my graph smaller this is called a
filtration right because each graph is
contained inside of a different one um
actually a filtration would be the other
way I'll think about it for later
because this is not a topological data
analysis class uh but in any event um if
I did that how much time will it take
well remember okay so for one thing I
have n log n from D algorithm I don't
get around
that so I always have to account for
that but now every time I try a new k i
incur cost n right that's what we argued
up here and so at the end of the day
this algorithm takes order K
star and time like that of course it's a
little weird to have the answer of your
problem in the runtime but K star here
it could be we don't have any bound here
it could be the the number of vertices
or or anything like that yeah and so if
we have a budget of n log n time this
doesn't quite work and so the question
is can we rescue this uh this strategy
here here and the answer of course is
yes or else I wouldn't be standing here
today uh one way that you might do that
so there's the uh way that you would do
that as a real algorithms person and
there's a way you could do it by
psychologically diagnosing your
instructors let's let's talk about both
of those um let's actually do the second
one first because I think that's the
most practical if you want to get your
homework done quickly um which is as
follows this problem tells you that you
have an an Logan budget of time uh in
order to run the algorithm and so what
does that mean well when we Loop over
potential gks that we can try we have a
budget of log and tries before we're
done yeah uh so we kind of know that any
algorithm that constructs a GK and tries
it can only do it log n times and to my
knowledge we only have one algorithm
that runs in log n time in this class uh
which is binary search and so we might
be thinking very critically about how we
could use that tool but more generally
than that I I think this is actually a
strategy that shows up a lot both in
algorithms and actually numerical
analysis a lot uh which is you have some
like yes or no answer and you want to
find like the point on the interface
right but where yes flips to no and so
one way to do it is to sort of bound it
on two NS then keep dividing in half and
as long as your relationship is a bunch
of yeses then a bunch of NOS you can
keep doing that by binary search right
so so let's think about it this way so
like we have a long
interval of K values
by the way obviously there's an upper
bound here which is like the biggest
distance to any vertex in my graph or
something like that yeah like the sum of
all distances or some large number uh
compared
to but you can afford a lot you could if
you took the sum of every Edge here's a
way to do it if you if if you took this
to be the sum of every possible Edge
length um might not be bounded in N
polom polom be bounded in N difference
between between you and
M sure so very large numbers uh in the
near
space okay I'm not sure that that's
quite right but but but that's okay um
in any event let's say that we have an
upper Bound for k for now then then what
do we know we know that here's like the
K star that I
want and to the left my algorithm will
return Yes this algorithm up here up
here it'll say no right so one thing I
can do one thing I should do is put K
star not right at the center of my
interval um for illustration purposes
but now I can binary search right
because I could query here and now I'm
going to get a no and maybe I subdivide
that the midpoint for some reason now I
get a yes and I can kind of triangulate
in on what I want right so that's our
our basic strategy is binary search here
um but uh we have to figure out how to
do that
exactly okay so first of all um okay
there is an obvious upper bound here
which is just the biggest distance from
any vertex to any sensor yeah uh right
so we could probably come up with a
conservative one we didn't feel like it
but um conveniently in step one remember
that Computing convenient numbers is
always a convenient thing to do um
clearly if Katniss wants to sorry sorry
atus wants to go uh within a radius
that's bigger than the distance of any
vertex to any sensor she's in trouble
because like that covers the entire
graph yeah so um right so we actually do
have a upper bound here which is the
biggest distance to a
sensor and now we want a binary search
but we have to be a little bit careful
how to do it because we want it to be
logarithmic in N which is like the
number of vertices in our graph and of
course the way that I've drawn this
interval here uh as Jason points out I I
don't at least immediately have a bound
on this number in terms of n right like
it could be that my Edge weights are
like really
ginormous uh okay so uh right so how can
we get around that well essentially what
we want to be doing is binary search in
an array that scales like the vertices
okay uh and here's the solution that I
came up with which I'm pretty sure is
the same as one in the answer I should
really check that before uh teaching
this thing uh which is to do the
following which is a remember like
again we have a budget at n log n and so
we can do a constant number of things
that take n log n time we just might as
well keep doing it yeah and so another
kind of convenient thing we might do is
sort my
vertices by the
distance to X which of course remember
is exactly the distance to their closest
sensor why would you do that well in
some sense like as I move along that
array that's the sort of order in which
I'm going to remove vertices from My
Graph and make the radius get bigger and
bigger and bigger does that make sense
because like these you know the first
couple ones the ones right next to the
sensor as I move along this array uh
they get farther and farther away okay
so we're going to say and and of course
why can we do that because sorting I
think this is one that all computer
science students everywhere know takes n
log n time using whatever your favorite
sorting well that's not true whatever my
favorite sorting algorithm is okay and
we're going to take di to be the uh
distance uh the ith
largest uh actually I think in my notes
I got this wrong the I is
smallest I'm diverging from my notes so
there is a high likelihood of a sign
mistake that's about to happen Okay and
now what I'm going to do is I'm going to
binary
search on I in other words on the index
into my distance array is a reason to do
that is there a r like let's say that my
distances are like one 2 five s right so
these are the distance of some vertex to
a sensor and let's say that I test three
and I notice that three is admissible
you know in other words she can get from
one vertex to another um never getting
within a radius of three should I try a
radius of
four well no because I'm going to remove
vertices only when I pass an element in
this array right so it makes sense to do
binary search not in distance space but
rather in Array index space because
those are the sort of place junctures
that determine when I'm going to uh
remove stuff okay so
uh right so remember how big is this
array it's got length n so overall this
binary search takes log n time and
that's good because our whole algorithm
now what do we do we binary search on D
or rather we binary search on I and then
we take Di and plug it into our our
algorithm up there to construct our
subgraph we test yes or no and that
tells us the left or the right interval
in our binary search and and we
recurse uh and so overall uh this takes
log n time but uh or rather log
n
steps of binary
search uh and of course each one of uh
these steps as I argued up there takes
order n time so overall our algorithm
takes order and log oh no I made an
accidental Theta and log n uh time and
that was the bound we wanted uh to
achieve as usual there's like a lot of
detritus that we need to clean up at the
end of our problem here one of them is
that we actually want to return a path
uh but that's not so bad right so now we
we we've essentially determined that we
can compute Kar in N log end time well
that's good it says now if we actually
want the path we can construct our graph
one more time right at K star I suppose
you already have it around from the end
of binary search uh and then use
whatever your favorite reachability
algorithm is uh to go from s to t uh and
and give Katniss the path that she wants
or specifically dicer's algorithm if you
want the shortest path um which is
courteous because she doesn't want to
walk too far she doesn't have to uh
moreover uh let's see there a couple
boundary cases that are probably worth
mentioning in your problem so for
instance if Kar equals zero in other
words I do my binary search I get all
the way back to the first element of my
array and it's still saying I can't do
it what does that mean that means that I
cannot go from my source to my target
node without passing through a Vertex
that has a sensor at it yep uh and in
which case what do you do well you can
return any path or you might as well
return the shortest path so that she can
run
okay uh and that I believe uh concludes
our
problem any questions about that
one thumbs up cool how are we doing on
time as usual I think I'm going to end
early and and we're precisely the same
time I'm always added problem
four okay so problem four we move from
one fictional Universe to another
here so now we're playing like okay Pawn
or something like that
[Applause]
sorry if I didn't write so big I
wouldn't have to waste half of class
erasing but that's
okay right
so
cool so now we have Ashley gum and
Ashley gum is trying to go from twinkl
town to blue blue Bluff and uh these are
both two clearings in the TKO region I'm
sure if I played Pokemon this would have
meaning to me uh or whatever this is uh
but in any
event we have a bunch of map we have a
map of a bunch of
clearings not liking the erasing on this
board so maybe we'll start up
here okay so we have uh n
clearings uh and they're connected by
two way
Trails uh and thankfully there's less
than or equal to five Trails connecting
in every clearing this is like our
favorite detail to add to six6 problems
is a degree bound y okay now with every
Trail um we
associate um a length
um which we're going to call L subt for
Trail T but an addition to that we're
going to have another piece of
information which is that it has a set
of Critters on a c
subt right so now every Trail you know
our our our character here is walking
along the path and what does she want to
do anytime that she walks along a path
she collects a critter or however many
Critters are on that path in fact she
feels a very similar way to how I feel
at TJ Maxx right she she's walking down
the aisles and like she can't help
herself she's got to catch every Critter
that she goes past on the path there's
there's no option here she can't leave
it behind because if she does then
she'll be sad and the way the reason why
our our character might not be able to
pick up uh one of the critters would be
if she ran out of her tools for picking
up these Critters which are apparently
pocket spheres and she has uh K
spheres in other words she has like a
backpack and the backpack can hold that
many spheres at a time okay uh there are
a few uh details here one is that every
time she walks down a path she collects
all the critters but then if she walks
down that path again she'll collect the
same set of Critters apparently they
they respawn they're very prolific these
these Critters uh and moreover uh there
are
stores uh some of the
clearings and at these stores uh she can
get rid of
the critor she currently has and drop
them off and pick up uh empty uh spheres
instead right so essentially every time
she does that she empties her backpack
and gets a new set of material where she
can keep picking up the critters I have
many questions about this character like
does she just leave them there does she
come back for them later what does she
do with the critters there's there's a
lot of questions like does she have a
bigger bag she can go back around to the
stores but in this fictional Universe
we're not going to worry about these
problems okay and so um right so
essentially the question here is that
there are two uh uh locations I don't
remember the name trundle trown to Blue
Bluff that she's trying to travel in
between and she gets sad if she comes
across a critter that she can't collect
so the question
is can you find the
shortest
path
without
being
sad and in like kind of a da da twist in
this problem uh if no such path exists
in other words there's like she has to
walk along some long trail with a bunch
of Critters more than K Critters I guess
in the worst case then sadness is
unavoidable is what your code is
apparently supposed to uh return which
is
really defe us I I don't know who wrote
this problems that um
okay the question is how do we how do we
solve this it looks like a shortest path
problem but as with all problems in 66
there's a slight twist right and in this
case the twist uh is that it's the
shortest path without becoming sad where
sadness means that you ran out of
spheres to collect your your
craters now notice that we're given a
budget by the way of I believe NK log NK
time is that right
like
that
okay notice that this is a little
suspicious somehow it makes us think
that the size of our problem really is
NK rather than just n or
k okay so uh how could we do this let's
think back to a problem that we solved
yesterday under the assumption that you
guys are binge watching your uh 66
problem sessions here uh and remember
the problem yesterday we had this dude
that was walking along paths and like
every third path he had to drink a
beer that's I've tried this on my
commute home and it doesn't doesn't work
terribly well uh but in any event we
have kind of a similar scenario here
where like there's some number that we
need to keep track of right there in
this case is the number of Critters that
our our character has uh remaining that
she can pick up right so she starts with
an empty bag as she collects them the
amount of capacity in her bag decreases
until she gets to a store and then it
goes back again but the good news is
that our runtime bound includes K in it
so it's actually okay to make an
algorithm that scales in the number of
Critters that she can carry around this
kind of a typical but but an interesting
uh Choice here okay so remember the the
term I introduced last time for this
kind of universe is that it's called
like a state machine like in addition to
walking along the graph she needs to
know how much capacity she has for
craters uh and so here's here's a way to
do it so I think actually this problem
isn't too bad given that you saw the
problem where you do every third vertex
uh in our last problem session somehow
it's it's just like a same church
different Pew kind of scenario here so
in this case uh one thing we can do is
we're going to make a graph to colum G
he's got vertices V EDG is E just for
fun um but what we're going to do is
have k + one
vertices for every
clearing and the reason is that what
we're going to do is we're going to walk
along the graph and as we Traverse our
edges we're not only going to keep track
of the costs like the distance that
she's walking but also the number of
Critters that she has remaining in her
bag that she can store and the way that
we can do that is by like keeping a
bunch of copies of our graph and
ascending every time that we collect a
new Critter does that make
sense okay so here's a let's let's add a
little bit more detail here so in
particular I can define v c comma I is
going to be the vertex per clearing
comma crater space uh and and the way
that I can view it is that this is um
sort of representing that I'm at
clearing oops this should be a
c uh and I have
a i pocket
spheres uh that are empty
okay so like initially I'm going to
start at vs comma 0 and go from there
okay okay oh it dep I guess it depends
whether you're decreasing it or
increasing
it oh you're right yeah I'm sorry so in
that case I guess it would be K we'll
see if I manage to do that consistently
throughout my my answer here um okay so
now I need to tell you how to make the
uh the edges in our graph and so let's
do that next next so in
particular for all
trails from a uh between a and b um
with
length uh L um and uh Critter
C right so she picks up C Critters she
traverses distance L she gets from A to
B or vice versa our trails are are are
bidirectional
here uh we need to Define
edges and they look like this so we sort
of have two different cases uh one uh is
where uh you have a store and when is
when you don't right because that that's
going to affect how your your state
changes
so right so the first one would be uh oh
did I get this whole thing backward oh
don't tell me
that no I did okay good um great so the
first case would be a does not has have
a
store
um right so in this case she leaves with
the same number of Critters she had in
her bag minus whatever Critter she picks
up along the way right so now I'm going
to have a uh an edge
of
length
L uh and I'm going to go
from va a comma I
to v b comma I minus C right so the idea
is that I go from A to B and in the
process I lose C Critters right but I
have to do this for all the possible
eyes that I could see in my state so
that goes from
CT oops to
K
right
C associated with the Trail T which I
decided not to use okay uh right so the
the basic Point here is that there are a
bunch of different states where I can
Traverse this Trail but I have to have
at least C Critters in my bag if I'm
allowed to Traverse this Trail or else I
will be sad okay uh and so kind of copy
this Edge a bunch of different times to
represent all the possible transitions I
could
make and similarly let's say that a does
have a
store well I still want to add an edge
but now I have the luxury of clearing
out all the stuff in my bag uh before
collecting the critters yeah so now uh I
still want an edge of length
L um but now I get to connect more
vertices and reset my state state in the
process right so now I'm going to go
from va a comma I
to v
b and uh where am I going to end
up well how many Critters are going to
be in my bag I have a bag of capacity
K and I just Traverse The Edge from A to
B which contains C
Critters
so I get in v k minus C like that uh and
of of course um I can do that for for
all
I uh
[Music]
from oh yeah I have to be
careful well no actually just for all I
is fine yeah I think there might be a
there's either mistake in how I copied
it down or a mistake in the problem a
mistake in the
problem yeah I think this is right yes
so I think there's we we wrote for all I
and some interval but we didn't have to
okay right so uh those are our different
cases right so essentially in this case
we we we clear out our our Q here or or
well not even a q just our our set of
spheres we reset we go back here notice
that the second vertex doesn't even have
an i in its index because it doesn't
matter okay and then similarly uh you
know so that gets me from A to B I also
have to do the symmetric thing to go
from B to
a
okay so now I have a
graph um and first of all we should
reason and make sure uh that we can
actually construct this graph in a
reasonable amount of
time so let's do that really
fast right so uh the number of vertices
on our
graph
well I basically have k + one copies of
my graph so it's equal to k + 1 * n
that's good so that's order K and time
uh order K and space I suppose uh and
similarly uh there's
K
edges um that are associated with every
Trail and there's order n Trails because
I have a degree bound so overall there's
order k n
is in my graph
okay great so now uh my problem is not
so bad I have a a source uh which is the
the place where our our Walker
starts f t which is the destination
where she wants to go um so what do I
need well I just need any
path that starts at
vsk right in other words she starts at s
and has a full bag with K capacity and
ends up at to V uh T comma I for any I
right because it doesn't matter how much
capacity she has in her bag when she
reads her her her
destination um so this is for all I any
path
avoids
sadness and the way this problem is
written right so how could I do that
well she wants the shortest path um so I
can just do dicer's
algorithm from vsk and do a bit of
cleanup afterward to check all the
different eyes and find this closest one
and how much time does that
take well my graph takes KNN spa space
because it has knen vertices and Order
knen uh edges so
overall this is going to take order KNN
log KNN time time which is a good thing
because that's exactly what the problem
asks
for and of course uh uh if the uh
shortest path is
infinity then what do we
know you say it with me sadness is
[Laughter]
unavoidable this is a weird thing to
write on a
Blackboard okay so that's our basic
problem here so what was our strategy if
we step back 10 ft essentially we took
our graph um and rather than just making
our graph we make K copies of it with
edges that kind of Point upstairs uh
meaning that you you you give away
spheres uh in the the process of
traversing these different edges except
when you hit the stores which brings you
back to level zero um so that was our
our basic graph structure and then we
just need to do shortest path on that
thing all right any questions about that
yes last time we did graph duplication
we made a it was layered graph and you
kept making these Transitions and it was
a d so can't we do this in linear time
can't we do this in linear time so in
other words why is our graph not a dag
in this particular case
um let me think about that for a
second what there's something about this
problem that mean it says that the graph
has to be a dag uh in particular I guess
you could keep walking like if you had a
path with a store that were exactly the
same as the number of Critters you could
keep walking back and forth along that
path um and so there's like a little
cycle there which would be enough to not
be able to do it in linear time well the
edges that we constructed are not Ed are
not don't necessarily correspond to the
edges in the original Trails that's not
the problem uh sure that's absolutely
right so we we constructed a directed
graph out of our original one but that
director graph also can contain Cycles
right um so yeah so I I think the
example I'm giving you works so I have a
graph with two vertices maybe there's
other grass stuff going on but whatever
I have two vertices here and I have some
number of Critters here and I have a
store on either end of my Edge just
because I'm boring and
conservative and now well assuming that
c is less than K I can just keep going
back and forth along this Edge as many
times I want and this is for free right
because every time I get to the end of
The Edge I throw all my critters away um
so that's an example of a cycle in My
Graph and because there's a cycle I'm
not in the the dag case anymore a cycle
in the in the constructed graph sorry
yeah it is a cycle here and also a cycle
in the constructed graph
um yeah sorry I guess that's
true all right any other questions I can
make a hash of here excellent so am I
out of time ah Shucks no um okay in that
case we'll do the last problem here
actually last problem I think is the
most interesting one so as usual I've
left myself with not enough
time okay which of these boards is the
tidiest the answer is none of yeah none
of the above so let's use the backs
here um
okay right so our last problem is a uh
shipping problem not a trans shipment
problem which happens to be my area of
research but rather uh just uh a a good
old uh shipping thing so here
um Strangely I did not give myself my
complete notes so this will be fun um
right so I'm trying to ship servers from
San Francisco to Cambridge by truck and
I have all these bunch of third-party
companies that all have pairs of cities
that they can ship between and only so
much these companies are kind of Divas
they have a weight limit they only have
like cities they're directed edges I
can't like they don't drive their trucks
back apparently or maybe they like pick
up somebody else's stuff and they're
just picking your stuff up in the boring
direction or or whatever uh so I have a
bunch of I have N Trucking
roots and uh each root are sub I uh is a
tupal with SI I
TI w i c i and what are all these things
so here uh this is the source
of uh every shipping route every
Trucking route here this is the Target
right so this is like where the truck
starts this is where the truck
ends this is the max
weight that the truck can handle so like
the truck only has so much space in it
uh you know the tires are only so big uh
if I put something of of weight bigger
than W uh then my my truck is is going
to die so that's the most that I can put
on this truck and this is the
cost okay and I have uh end roots that
look like this I'm trying to ship
servers and of course some of my servers
are are too darn busy but we make an
assumption here which is that our
Trucking routes form a uh sort of a
continuous Network I can get from s tot
and ship at the very least like a pencil
eraser you know like some minimal amount
of weight okay and so the basic uh end
point of this problem is going to be uh
to sort of figure out the heaviest thing
that I can ship uh and and uh we we give
you a problem on the uh sort of on the
path toward that uh to help prove a
little bit about this this is a very
typical kind of setup so again I've got
a bunch of trucking routs each one of
which has a max weight and I'm going to
want to know first of all what's the
maximum amount of weight I can ship and
then what is the minimum cost I can ship
that that
weight so in problem a which is marked
as useful
digression um we're first going to prove
kind of a handy uh in equality I decided
to go off book with my proof ever so
slightly of this so get excited uh for
this to be slightly uh wrong in a subtle
way which is what I specialize in um but
in particular uh we're going to make a a
definition here so let's say that Pi is
a
weighted
path okay then uh the bottleneck of
Pi of Pi is going to be uh the the
minimum Edge
weight of of any Edge in in in
pi and to make sure that we see how this
is connected to the problem um you know
if I'm trying to ship a server and I
have to put on truck one and truck two
and truck three and truck four and truck
five um obviously of those five trucks
the one whose capacity uh for weight is
the small is the only one that matters
in terms of the heaviest thing that I
can
ship okay so uh right now uh given two
given a directed graph uh and two
vertices s and t we're going to define a
quantity called B of s comma
T and we're going to say that this is
the
max over any path PI
from pass to T of the
bottleneck
of Pi okay so so to sanity check this
quantity here essentially what it's
saying is at the end of the day I have
this big network of trucking routes I
just want to go from one city to another
and I don't care which series of trucks
I want to use I just want to maximize
the weight that I could ship right and
so this is saying I'm going to look at
all the different paths that I could
take each path is sort of band limited
by the one truck that has the lightest
weight that it can carry um and I'm
going to find the path that has the
best bottleneck as measured by this
quantity using the word best because I
tend to make sign mistakes and that's a
vague term okay and then uh
right uh
so writing too big I hopefully I won't
run out of space we're going to make one
additional uh definition which is I of T
is the
incoming
neighbors of uh t okay and then the
problem is asking you to prove uh a
particular uh inequality
here claim which is that b of s t is
bigger than or equal to um the Min of
two values B
of
SV or W of
VT for
all uh V in I of T so let's see what
this is saying so remember that this is
like the capacity that I can ship from s
to T using any route um and that that uh
upper bounds the minimum of two things
right either the capacity of shipping to
one of my neighbors with an incoming
Edge or the weight of basically shipping
from that neighbor to me notice this is
kind of similar to a triangle inequality
which is why we're going to kind of know
how to solve Part B of this problem
pretty easily
okay um and moreover uh
with uh
equality uh for
some V Star in
if
okay guess what that VAR star is going
to be it's going to be the vertex that's
sort of the previous one on the path of
of of of of trucks that I actually take
to ship stuff right okay so how could we
prove this so the intuition here is that
the path that's actually giving you this
bottleneck this BS comma T has to
include one of my incoming edges and I'm
just trying to find it right that's
that's roughly what's what's going on in
this inequality and and by the way
whenever a problem asks you to prove an
inequality you should step back you know
like I feel like I spend like 85% of my
day with research students sort of
saying like Okay but like what is this
really telling me about life and and and
this is a good uh
example okay so to that end um I'm going
to make a definition which I found to be
convenient when I was solving this
problem um which is the following I'm
going to say that Pi s comma t uh is
going to be the actual path uh that
gives me the bottleneck so this is kind
of like the ARG Max over all Pi I'm use
really bad notation Pi is the connect S2
T that's how we're going to think of
that of the
bottleneck
so in other words
like this is the uh path that actually
realizes uh this this quantity B right
so in other words B of s t is equal to
bottleneck Pi only has two lines has two
this is convenient for me because the
reasoning about that path uh makes some
sense um okay so now uh we're going to
prove the inequality first and then we
may or may not choose prove the equality
case depending on how I feel okay so uh
right so let's section this off try and
use my board a little more
conservatively
here uh
okay so right so now let's
take a Vertex uh
V from the
incoming uh edges here of
t right because that's what we need to
to prove this and we're just going to
prove the inequality directly here uh in
particular
um we can
define a path that goes from s to T as
follows I could take the uh Pi
SV and then concatenate onto the end of
this
guy um T right because we know that
there's a directed Edge from V to T by
definition of of what this I is
okay um right and so this is kind of
convenient because this is like the
bottleneck path for one of my neighbors
and now I'm just kind of sticking an
edge on there and we know uh that of
course this is a candidate path to get
from s but it may not be the one that
actually achieves the bottleneck
okay right so
uh yeah uh and let's uh oops let's
define that to be Pi uh twiddle just for
for fun I like give things names okay so
what do we know we know that b of s
comma T well this by definition is the
max
bottleneck of any incoming path going
from s to
T this is a path from s to T yeah so
because this is the max it is bigger
than or equal to bottleneck
of Pi twiddle right that's the nice
thing about Maxes they tend to be bigger
than other
stuff okay uh well what is the
bottleneck of Pi twiddle well remember
our definition of bottle bottleneck here
right it's the Min Edge weight over my
entire
path well I have two options either that
edge weight is The Edge from V to T or
it's the edge
we that's associated to the rest of this
stuff yeah so either um this is the Min
of the uh
bottleneck of the first segment of our
path Pi SV by the way that may be empty
and that's like okay that's just like a
one Edge path you can dispense with that
case pretty easily uh or the weight of
VT
cool well by definition bottl neck of Pi
SV
is exactly this quantity right because
that's what I chose it to be over here
yeah so this is exactly Min the b s
comma V That was supposed to be a v but
I wrote a t or W of V comma T and that
is exactly what we wanted to prove yeah
so that takes care of our inequality
case do I want to do the equality
case I don't think I do yeah so uh it's
not too hard to check the equality case
essentially you you can make a pretty
easy contradiction right because if it's
strictly larger then what does that mean
that means that every single incoming
Edge none of them can be the edge where
your bottleneck path comes in and
obviously there's something wrong with
that uh okay so I'll refer you guys to
the uh the notes for that one and
finally uh the problem says uh assuming
that
uh so now we have kind of a funny
constant in here just to make your life
a little bit annoying we have
um at most three Square Ro TN
cities that we care about um again why
three why not uh I think uh and what we
want is the weight of the single uh
largest server and the minimum cost to
ship uh that thing so we want one the
largest weight we can
ship
we'll call that W star to ship and two
is the
smallest cost um to ship that weigh W
star
okay so let's do two first because it's
easy so let's say that I was able to
compute W
star so now what can I do well I can
construct a graph by only keep around
the the the trucks that can ship at most
at least this amount of weight because
the other ships are I really want them
to be boats in this problem but the the
other trucks uh are are useless right if
they can't cover W star then they're not
pulling their weight yeah so to do
uh part two
here what can I do um I can make a new
graph uh G Sub C with a vertex
for every
city and um and uh right and an
edge d a directed Edge
sorry per uh shipping route uh with
um this is going to be an unfortunate
clash in terminology I'm going to say
Edge weight to refer to the edge in My
Graph and that's going to be equal to
the cost of the edge
um uh and only keep around
uh but only for
roots that can carry at least
um W star amount of
weight and now what do we do well it's
the shortest path right at this Point um
you know shortest path which is really
the minimum cost in this case because
that's what we're associating to the
edges um is going to give me the cost of
shipping wstar in my network I think
that's pretty obvious from this
construction um so that's drra d i j k s
t r
a and now the only question is how much
time does it take so let's say that I do
the brain dead version of dyra where I
just use a direct access array to do my
priority CU so if you call that'll take
Big O of mod V cubed here squared
squared yep you're right sorry I was
thinking Johnson's algorithm okay well
in this case how big is V well it's
square root of n 3 * square root of n at
most so of course v^2 uh is really big O
of n uh and and and the that part is
solved yeah so really our only uh
remaining problem here is to do part one
and I don't have nearly enough time in
fact I'm completely out of time so maybe
we'll just talk through it really
briefly sorry about that um essentially
the basic observation here is that the
inequality that we proved in part A of
our problem it's kind of like the
triangle inequality of the bottleneck
World in some sense um essentially what
it's giving you is some or you know
update formula that looks kind of like
the update formula that we'd apply in
dce algorithm for shortest path right
the basic assumption here being that
well my shortest path has to come from
somewhere right so if I look over all my
neighbors and then I kind of add in my
closest The Edge uh or rather you know
the sum of the path length to the
previous vertex plus the edge to me it
gives the shortest path to me here
instead of that we're saying the biggest
bottleneck path so what do I do I look
at all of my incoming neighbors I find
the one with the biggest bottleneck
which is band limited by their
bottleneck plus the bottleneck of the
incoming Edge uh and then I update
myself so the only thing remaining here
is to basically do exactly uh dce's
algorithm but rather than updating by
summing EDG length we update by using
this formula and essentially everything
else Remains the Same so conveniently
I've run out of time so I won't even
have to uh uh jumble this one on the
board I'll I'll let you guys do that one
at home but I actually think the
explanation of the written material is
pretty self-evident for this problem so
that's probably just as
well