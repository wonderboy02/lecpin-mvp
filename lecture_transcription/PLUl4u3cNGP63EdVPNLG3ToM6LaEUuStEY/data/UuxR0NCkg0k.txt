foreign
right so uh today is going to be our
first I believe of two problem sessions
covering dynamic programming
um
I find dynamic programming is one of
these interesting parts of an algorithms
class where like somehow the people that
are really good at it are completely
disjoint with the people that are good
at all the other parts of the algorithms
class so for some of you guys that might
be promising uh and for others maybe a
little bit less so uh so maybe we'll
spend just a minute or two kind of
reviewing the basic ideas we're going to
apply uh in these problems because
they'll follow more or less the same
template although of course as usual in
6006 if you like to put some
interesting window dressing around it so
that it's not totally obvious what
you're doing uh uh and then we'll do a
bunch of sample problems
um right so let's let's talk a little
bit about dynamic programming and the
basic uh idea here
so dynamic programming is kind of a
funny outlier in 6006 in that like for
example in the data structure is part of
the course we learned like what you know
struggling to think of a data structure
like like a useful you know like trees
and arrays and whatever these are
actually things that you can code like
if you look in C plus plus like there's
a there are well plausibly it could be
an implementation of a tree in there
some way
um and so these are like useful
algorithms that you could maybe even
read the pseudo code and there's a
universe where you really do translate
that pseudocode into something inside of
your laptop
dynamic programming is a little bit less
so this is more like a meta I don't know
if you call it a meta algorithm or a
problem-solving approach or what
um but it's not like you somehow say I'm
going to apply the dynamic programming
algorithm to this problem but rather
it's sort of this big class of things
that all follow a similar template or or
sort of approach to thinking about
problem solving which I think sort of
explains why actually in some sense the
last couple lectures that you've seen
and I guess if I'm getting the the time
sequence of our course right the next
couple ones that you will see
um and the problem sessions actually
start to coincide in the sense that like
when Eric was teaching your diet's
dynamic programming how did he do it
well he didn't like write down well he
sort of wrote down some template for
dynamic programming but then we just did
a bunch of sample problems and that's
exactly what we're going to do today uh
so somehow all of these things are just
going to converge uh in in this part of
our course uh because dynamic
programming it's really more of a way of
life uh than any particular algorithm uh
and this is a pattern that I think you
see a lot in advanced algorithms like
for example in my universe numerical
analysis like when you talk about the
ADM algorithm it's actually totally
useless algorithm what matters is
applying it to a particular problem uh
and and this is a sort of I think a more
mature or grown-up way to think about a
lot of things in algorithms right that
pretty soon this sort of general purpose
stuff that's useful all the time I think
I think it starts to disperse a little
bit in favor of different patterns and
mechanisms that you're used to thinking
about so there's my 10 seconds sort of
philosophical introduction know what
we're doing during which I've managed to
chase this
table across the room
you know I played I did College on the
west coast and I thought I was going to
be a music Major and there's a Piano
Master Class where we forgot to put the
little Clips on the wheels and our there
was an earthquake and I just thought I
was really nervous because the piano was
literally slipping away from me uh and I
can never think of that that Chopin
Nocturne quite the same way um but in
any event uh in dynamic programming uh
Eric laid out for you guys a particular
sort of set of steps uh that are sort of
a useful problem-solving approach in the
dynamic programming Universe in today's
film session I'm going to try and help
you guys translate a little bit from
this template to what it means to
actually write code to implement a
dynamic programming algorithm because I
think
it's a little easy to forget that here
but uh on the other hand on your
homework when you're writing out answers
to algorithms problems is perfectly fine
to follow this template even letter I
guess literally letter for letter uh and
answer each of these questions and then
sort of the remaining glue that you need
to actually write the code is not
terribly uh exciting from an algorithm's
Theory perspective
um so the basic idea here is the there's
a lot of different problems that can be
written recursively in some sense uh
certainly we we've encountered many of
those in this course in fact I think the
bias in the way that we've presented
algorithms that don't have to be
recursive is to write them in a
recursive way
um and and the point here is that when
you have a recursive call and you repeat
something you know you you give the
function the same input more than one
time you might as well remember what you
got the last time you saw that input and
then you don't have to do that
computation again really in one sentence
I think that's roughly the logic behind
all these dynamic programming things
yeah so there's no reason to be too
redundant with lecture uh for just sort
of the 10 second overview I think that
there's an example which is
simultaneously good and misleading which
is this Fibonacci Sequence uh it's good
in the sense that the logic of dynamic
programming is really easy it's bad in
that the run time is kind of weird to
think about
um but remember those your Fibonacci
Sequence looks something like f of k
equals F of K minus 1 plus F of K minus
two
and if you look uh your sort of
recursive call tree here right like
let's say that I do k equals four right
then it's going to call you know my
function f is going to have to evaluate
it at 3 and 2 and then the 3 is going to
evaluate at 2 and 1 and so on
and the thing to notice is that when I
call F of 4
or rather F of 3 here if there were
three somewhere else in my tree I get
the same number right so in particular F
of 2 and F of 2
both of these are going to take some
amount of algorithmic work but if just
the first time I see a 2 I have a little
piece of scratch paper and I say ah
anytime I see uh k equals 2 just return
this number rather than doing recursive
calls then in fact if there's any
subtree underneath this thing uh I I've
just pruned it from my tree right and
and and so that's the basic logic here
uh and that's basically this the the
Paradigm that's going on in this this
sort bot uh
acronym uh which is is uh you you first
take your problem and divide it into sub
problems that is mysterious why is this
board moving
um
oh there's a phone in my pocket I bumped
against the wall uh
foreign
right uh
yeah so the first thing I want to do is
to write my my problem as sort of
this sort of form notice that we've done
this a lot in this class we've written
things recursively the difference here
is the the sort of argument that goes
into recursion is typically maybe a
little simpler than you know like
putting some giant data structure inside
of there or something like that right so
for instance merged sort you could write
in this Paradigm I guess we covered that
but it's probably not the most natural
way to think about merge sort
then we need to relate our sub problems
to each other so for instance in the
Fibonacci sequence problem I just gave
you the relation that sort of what
defines the problem
incidentally this is what a model for
the reproduction of rabbits I think if I
remember reading the history of the
Fibonacci sequence
um
and then I think to me the most not
necessarily unnatural but I think the
thing that maybe is hardest to translate
to an algorithm if you're thinking about
writing code is this like oh man this is
going to be a problem uh this idea of
topological uh order the basic idea here
is that like if F of one depended on F
of 2 and F of 2 dependent on F of 1
I'd be in a lot of trouble right because
somehow my tree would never converge
from one thing if I made these recursive
calls and I'd never be able to memoize
or kind of remember a value uh when I
move on right and so the idea here is
that there's some ordering of my sub
problem so that I can build up a
solution
and there's sort of two dual ways to
think about why that's useful
so in the memoization universe right
what do I do I just add an if statement
saying you know if I've already
evaluated F okay return it that's
perfectly fine the other thing I can do
is if I write my sub problems in
topological order
then I can sort of go in the reverse
Direction and build up my memoization
table so for instance uh for uh the
Fibonacci sequence problem I could do F
of one and then F of two and then F of
three and F of four
all the way until I get to the K value
that I actually wanted and those are
just Duels of the the same coin they're
exactly the same approach of the
memoization version sometimes you can
prune out some problems that you didn't
actually need to solve so for instance
maybe this was F of K minus seven and so
I can like skip a few indices in my
array
I don't think typically that has a big
effect on runtime for the problems that
we've seen but it could
um plausibly uh in some Universal I'd
have to think about a problem where that
that makes a difference
um right and then I think the bot part
of swordpod is a little easier to think
about uh you have to make sure that this
recursion has you know a base case like
when is this thing going to stop that's
exactly the same it's just any recursive
algorithm
um the O for original I think is a
little bit retro retrofit to to make
short but sound nice but I think the
idea here is that you need to go back to
original problem and make sure that it
corresponds to one of the function calls
that you've written and all those
complicated stuff hopefully that's a
reasonable characterization and then
finally the t is more you know these are
for describing your algorithm the last
ones for analyzing it
um and again the the bot part of sortbot
almost applies to anything we've done in
6006 like you should always analyze your
runtime
um okay so in any event that's my
10 minute version of uh the last couple
lectures uh and I think more or less
enough to get us started with some
sample problems here
sorry I couldn't help it I like to teach
things
okay so uh right so in our problem
session we have a few of the homework
problems from last year uh to go over
um
if it makes you guys feel any better I
got myself all balled up on one of them
last night while I Was preparing for
today and I I look forward to doing that
in front of all of you guys now uh right
so
I'm afraid of this so I'm going to go to
the next port
um okay so in our first problem uh Sunny
studies
this was somehow you know the like cute
naming conventions we have in 6006 got
really meta in this problem because
there's a problem about Tim the beaver
uh but as we all know uh Tim is MIT
backwards so like he happens to fit into
this goofy
game that Jason likes to play in in
writing homework problems anyway
um but it's also the MIT mascot
anyways I got very excited
um right so so what's going on in this
problem
so Tim the beaver has kind of an
interesting uh you know mathematics I
think you would call this a Martingale
as you flip the coin a little bit when
he saw this problem but uh luckily Tim
the beaver is a deterministic uh kind of
a guy uh and he looks at the weather
outside
and if it's a temperature tee apparently
Tim the beaver is okay with with boiling
um the higher the temperature uh the
happier Tim gets so this is the first
derivative kind of a phenomenon in
particular uh on a on a given day if I
have a temperature t uh Tim the beaver
has two things that he can do to change
his mood apparently Tim the beaver's
mood never stays fixed it always goes up
and down
um
in particular you can either
uh go outside
in which case the happiness increases by
T
okay or he can stay inside
in which case his happiness decreases
by T okay so every day Tim the beaver uh
he wakes up he he
I really want to say that he checks for
his shadow but that's that's a gopher
right
um in any event he wakes up in the
morning he checks the weather uh and he
makes a determination does he want to go
outside or not and if he goes outside he
gets happier by an amount that's equal
to the temperature
if he stays inside he gets less Happy by
an amount that's equal to the
temperature by the way I think our
solution is perfectly fine if
temperatures are negative here in which
case I guess everything would kind of
flip uh intuitively but there's no
reason to get too hung up on that
but of course there's a Twist here
um so Tim
as with many of you has end days
until his final exam
and he's worried about studying yeah so
uh in particular
um
he never wants to go he's you know he's
come up with a personal resolve to never
go outside more than two days in a row
yeah
um so right
um
and so
the question is right because that way
you know he has to stay inside and study
at least one out of every three-ish days
okay so the question is how can Tim
maximize his uh his happiness
incidentally that's you know machine
learning sometimes they call that
minimizing regret which I always found
to be like a very sad way to think about
algorithms when there's a totally dual
version but but Tim's an optimistic guy
he wants to maximize his happiness
subject to this constraint the he cannot
go outside more than two days in a row
right so like if I go out on Monday and
Tuesday I have to stay inside on
Wednesday
yes I think there's no effect to his
happiness when he stays in there's no
effect to his happiness when he stays in
uh no it says with a decrease in
happiness when T oh when T is negative
that's not actually going to affect our
problem at all
[Laughter]
sure yeah I can fix this life uh and
this is what happens when I do the
problem myself before looking at the
answer and then don't check it closely
um fine so uh let's let's change that
I like this problem better uh somehow
psychologically but that's okay
um right so uh Jason correctly points
out that if you actually read the
problem uh what's what's uh asked there
is is slightly different that when he
goes outside his happiness increases by
T if he stays inside his happiness does
nothing right so
um it stays
the same
my apologies so
um Tim the beaver is a particularly
optimistic fever his happiness can only
increase in time assuming he lives in a
climate with positive temperatures okay
now I think I've got it right now
cool let's see if I
can still do this
yeah I think basically nothing changes
okay that's great
all right we're gonna do it
um
okay so right so the question is how do
we uh solve this problem uh and and
thankfully I think we put the easiest
problem first uh and in particular if
we're we're following our ballot
Paradigm here
um somehow there's there's a set of sub
problems that are staring Us in the in
the in the face that's the word I'm
looking for uh in particular uh
well there's sort of only one index in
our problem which is what day it is so
the obvious thing to do would be to say
can we figure out the maximum amount of
happiness for days say I to the last day
by the way if I do that I'm using the
prefix version of my problem uh ah
suffix version of my problem I could
also do it the opposite way and work
from the end back in
um maybe if we have time all the way at
the end we'll do the second one but it
doesn't doesn't really matter
okay so in particular
um just to add a little bit of notation
let's say that uh T of I is equal to the
temperature
on day
I okay
and now we're going to make a new thing
which is going to be the actual variable
we want to compute this is going to be X
of I
which we'll write is the
maximum happiness
that you can achieve if you only
consider the calendar from day I
to day n I guess inclusive
okay uh incidentally just for
convenience we'll assume that x i is
equal to zero if I go past the end of my
array which I think is kind of a typical
thing to do in these DP algorithms
okay so the question is can we actually
come up with a recursive algorithm that
computes X I uh using this nice uh sort
of topologically acyclic
uh way of of thinking about our problem
the answer is obviously yes or I
wouldn't be here today
um and and so you know in the absence of
a smarter idea let's let's just do the
the Toucan Sam approach here and follow
our nose and see if we can just write
our problem in terms of other ones
so in general let's say the the Tim the
beaver wakes up on day I
he has basically two decisions that he
can make right he can either stay inside
or he can not stay inside he can go
outside
uh right so so let's let's just
basically uh
handle these three cases so in case one
um he stays inside
well now what happens to his happiness
well according to my revised version of
this problem nothing right so uh in
particular
um
what do we know well if he stays inside
then he has
any decision he can make tomorrow it
doesn't matter he can go inside and go
outside whatever because by having
stayed inside he's earned himself two
free days of going outside if he wants
right so in particular in this case we
can convince ourselves that
this is true in our uh I think yes
um right so in other words uh well he
gets no utility for today he wakes up
tomorrow and he can make whatever
decision he wants
okay
the second thing he can do is go out
this is where things get a little tricky
right can I just do like you know
take TI and add it to x i plus one what
goes wrong
maybe you go three days in a row right
you you somehow have to remember that
right uh and and so that's where things
are a little bit of a headache
um the in particular if I go out
today and tomorrow I can't go out the
day after that
um and somehow if we just uh dealt with
this one case as t i plus x i plus one
we wouldn't remember that right and
that's a problem
so instead what we can do is think of
there being two sub cases right so what
we're going to assume is that not only
does he go out today but he's free to go
out tomorrow and we're going to kind of
make that recursive assumption as we we
move down on our way
uh so if we do that uh
well now we have case a and case b so in
case a
he goes out today and he stays in
tomorrow
yeah okay so what happens in this case
well
by the way I'm using this kind of weird
arrow notation I don't know if this is
good or not but essentially the point is
that I'm keeping track of cases and then
eventually going to want to have to take
the max over all of these things
so I don't like the equal sign because
somehow that's a little misleading
um right so in that case well he gets
the utility of having gone out today
tomorrow he stays in
which means that the day after tomorrow
he can do whatever the heck he wants
right he has he has free ring so
I can write that
using this recursive call
okay uh similarly
uh right so
I'm getting the hang of this
sorry this is way too entertaining for
me I can play with this board all day
um okay so in in case 2B
he goes out today and he goes out
tomorrow
Okay so
he's a party animal he is an animal and
he's going out a lot
um right so in that case what happens
well he gets that
he gets uh
today's utility
he gets tomorrow's utility
uh the day after he has to stay in so we
might as well skip it
and then he can do whatever he wants
the day after that okay
so if we go back I guess technically
we should revise our definition of x a
tiny bit that it's not the maximum
happiness well we can convince ourselves
that it's the same thing but really it's
not the maximum in the happiness for day
I through n it's the maximum happiness
for day I through n under the assumption
that he has permission to go out on day
I
right and that's really what's going on
in our our recursive set of calls here
okay so does our recursion uh make sense
here
cool all right so uh let's see here so
if we're following our sort but I keep
reviewing papers that use the word
Paradigm a lot so I feel I feel like I
should do that so what is T is the
topological order
notice uh that
um right x i
only depends
on larger eyes
so in terms of our topological order the
dependence graph is really simple right
it's just a line
um so remember that you can think about
topological order or you can think about
being a cyclic graph those are
equivalent we covered that in this
course I kind of like thinking about
acyclic graphs
um right so X1 depends on x2 depends on
X3 it depends on X4 that graph has no
Cycles so we're good
um wait what's our so
next we have to come up with our base
case for our recursion
notice the the way I have chosen to
solve this problem is uh by calling
future indices which means that my base
case says at the end of my array right
because that's sort of like the lowest
down in the recursion train uh recursion
chain is what it's going for but I kind
of like the recursion train better
um in particular on day n
well if he has permission to go out on
day and
um
he can do one of two things he can
either go out or not it doesn't matter
right so in particular we can say that
that's
the max of 0 or t of n remember I didn't
tell you that temperatures have to be
positive yeah maybe he's uh he's a
Celsius kind of a beaver
okay uh uh right and and then in
addition to that
um
for convenience notice that like there's
a universe where I look beyond the end
of my array in my recursive call here
um so I should probably think about a
few extra X's uh obviously the utility
of going out on a day that doesn't exist
is zero uh so we can say that x n plus
one equals x n plus two equals zero
okay
I've managed to use way too much space
for one simple algorithm problem
okay so
yeah
okay good credit for that okay
um right so now uh we need to do the O
and the t uh so what's our original
problem
well remember that he wants to maximize
his happiness starting on day one
um so our original problem is just X of
one
um
or is it so remember that Tim the beaver
this is you know your instructor is very
sloppy when it comes to actually reading
the problems as you saw at the beginning
um a second mistake for which I would
have personally lost points where I to
solve this problem on my homework is
that it didn't ask for just the maximum
amount of happiness that Tim could
achieve that's not very practical for
your everyday Beaver uh but rather
um he wants to know the actual plan he
wants to know what days he can go out
and what days he can't yeah and I
haven't actually told you how to do that
right I've only told you how to compute
X which is just the maximum amount of
happiness
if I were you guys I I think this is a
perfectly reasonable simplification
that's like a warm-up problem to solve
in fact I would argue it's less of a
warm up and more the Crux of the problem
uh and then going back and making sure
you can convince yourself that you could
actually reconstruct the solution
um my way of solving this was ever so
slightly different from the one in the
problem but they're equivalent
um which is to say I can make a second
array I won't write it down because I'm
slow ready
that just says on every day whether I
took option one option 2A or option 2B
right and now I can reconstruct my plan
very easily right so I look at X1 if I
took option one uh then I stay in and I
look at you know day two
if I took option 2A then I can label
today tomorrow and the day after oh wait
uh
yeah that's right I can label today's
Choice tomorrow's Choice the day is
after Choice and then look three days
later uh and we're Chris that way
um or option b is is kind of similar
right so a reasonable way to reconstruct
the actual set of what days you go out
and what days you go and is this to
remember as you do your your
memorization or or whatever uh whether
you did option one two a or 2B and then
it's pretty easy to reconstruct from
there maybe I'll let you guys convince
yourselves of that at home or in the
last eight seconds if you happen to be
the two audience members that I have
uh and then finally
um
right we need to do our time thing and
most of the time arguments here follow
more or less the same pattern which is
you count the number of sub problems and
the time per sub problem you multiply
those two things together uh and you get
your run time we're going to see in one
problem on this problem set that's not
quite right because we have to account
for some pre-computation
but uh in this case it is
right so
right so let's see what are our sub
problems here well essentially I guess I
didn't actually say it but you have to
take the max of these three values
um
this is the max of three Expressions
which have a constant number of plus
signs and lookups in memory and all that
good stuff so each subproblem
takes
order one time
how many sub problems are there well
there's I guess n plus two uh max if you
want to be conservative about it uh so
in particular there's order N Sub
problems
right so all I have to do is multiply
these two things together and my
algorithm
takes order and time
and that's our solution to problem
number one
any questions so far
yes uh-oh
when I was thinking
of problems before him I was wondering
could you use base cases
right now we have two different kinds of
base case
a base case for x
for things after
10 plus 3 equals zero as well what would
that do
could I remove the first one and add an
X of n plus three
yeah I guess that's fine
I'm sorry that's not a particularly
helpful answer for the people watching
on video my answer to this question you
can't hear is yes
um right so uh the question to uh repeat
uh was you know this base case is
somehow kind of complicated looking
to be fair it's the one that I was
giving him assignment but that's okay
um but the the question is is this truly
necessary in particular can I get rid of
the xn case and instead add a third day
past the end of time uh which also has
value zero and if you kind of look at
that plus case b I think you uh
or rather case a I think you're
convinced well case A and B for that
matter you can convince yourself that
these are equivalent right
um that's absolutely right so so I could
add a third day after the end of this
thing
which also has value zero or by the way
I could just say in my code if n is Big
you know if I is bigger than n returns
zero that's the same thing
um
yeah and then I guess I don't have to
worry about that xn case yeah these are
the same
you know he eats their own
fabulous question any any others uh that
I can answer while we're at it
cool all right so that's problem one
right
I don't like this big Chuck you know
okay so problem two is the one that got
me all hot and bothered yesterday so
let's see if we do any better uh in
front of people because that's usually
the best way to improve uh problem
solving skill uh right uh so in problem
two which annoyingly is also probably
the most practical uh problem on on this
problem so essentially you have a uh I
suppose I should write some stuff down
right so in problem Oh I used the wrong
side
two uh you have an operating system men
X
whatever uh which is a uh you know
apparently it's a very simple
oh I get it
doesn't mean I have to like it
um right so
in me mix
um no yeah
uh apparently the only thing that my
operating system can do is uh compute
edit distance between files and it wants
to do so efficiently so
we have that a file
is a sequence of strings
and I believe we say their length
is less than or equal to K that's going
to come into play a little bit later
and the strings are basically just lines
of the uh the different files so
there's three different ways that we can
change a file
um so here are the changes we could do
change number one is to add a line
change number two is to remove a line
and change number three is to swap
but a caveat for
this this interesting model of of of
what's cheap and what's not is that
apparently swapping two lines is cheap
because they exist in memory like maybe
I'm
I don't know using like a linked list or
something to store files and so swapping
two pointers isn't so bad uh but
inserting and removing a line is hard
because I don't know memory allocation
is expensive like you know Minix is
actually operating on clay tablets and
you know I can top my clay tablets into
different slices and just pick them up
and swap them and that's fine but you
know if I want to add a line to my file
I have to go to the Tigris and Euphrates
and pull out the or whatever it was the
eugris and the typhraties and and pull
out a
you know Stone it's a lot of work to
make a new line or to dispose
um right so these are expensive
and this is cheap
right and so the question uh that I'm
trying to say uh that I'm trying to say
and that the problem is trying to ask uh
is that you are given
files
A and B
um with n lines each
uh you want to know what the uh
the minimum number of non-swap
operations it'll take and so in other
words the minimum number of times you
need to add and remove lines to
transform a into B right
um
uh
essentially with low cost
and in fact
just to be nice I think that's actually
kind of a critical hint in this problem
we give you the runtime
um and I'm going to kind of ignore it in
my answer notice that I did something
wrong and then go back and fix it this
is different from the way the answer is
written where you know God came in and
said like oh we observe that we're
probably going to need this thing so
we're going to go ahead and do it here I
think that's that's maybe not
representative of the logic here so
um right so the the runtime here is K
and plus N squared the first thing to
notice there's a
K here
yeah and and so someday we're gonna have
to compare our strings
right like because that's what K is and
I think that's sort of sort of the hint
that's implicit in this problem it's
easy to miss uh and and and so indeed
what we're going to notice is we're
going to look at our solution and say
well wait a second if we didn't
incur a factor of K we must have done
something wrong
um and and indeed that's that's going to
be the case but uh
it's only a minor uh
fixed to change it
oh I'm sorry yeah and and um right when
I swap things uh they have to be
adjacent
I can't write at the bottom of the board
um
that's supposed to be adj for those
watching at home uh but they have to you
can only swap lines that are adjacent
um as they appear in their original file
I'll say it out loud rather than try and
write it because it's going to take like
the rest of the lecture to do that
any other
things I've threatened this High
likelihood I'm bad at this
okay so uh
this one was annoying and and and it's
not actually annoying it's actually a
relatively easy instance of a very
well-known Dynamic program plus a tiny
bit of additional stuff which is called
edit distance
um in fact I think if you guys are
looking for intuition on this problem
you might Google that one first
um as sort of a Rosa
oh in fact you're doing a recitation oh
that's why it's it's not totally
unreasonable to come up with the answer
here even better
um but even if you hadn't you know this
is just another dynamic programming uh
problem that's just like a little bit
more
annoying than your than your average uh
dynamic programming problem uh now the
solution written out in the course nodes
works from sort of the last line of the
file downward in some sense a up upward
whatever
um
I like literally lost two hours of my
life trying to think about editing files
from the end up and just getting myself
all upset and confused so so here I'm
going to attempt to do it in the other
direction and probably introduce a bunch
of mistakes in the process so
what do we do in dynamic programming if
we don't know what else to do we we do
sort sort stuff sort bot uh and so let's
do that here uh so in particular what
are our sub problems this is a little
bit funky
it's actually even before we do the S of
sort pack let's think about our problem
a little bit
um
let's think about like what it actually
means to edit a file because this is
what helped me sort of think about the
right right answer here which is to say
you know so so what's going on I have
like two documents you know this is
document a this is document B
right each one of them is composed of a
bunch of lines
and I'm basically trying to turn a into
B and the only thing I can do is like
Scribble out a line insert you know just
hit the enter key or do a third thing
where I kind of like swap to uh things
that are adjacent to one another this is
the only thing I can do
and the way that I like to think about
this problem
there's kind of an annoyance here which
I think is a typical annoyance in
dynamic programming problems which is
that the order of operations
suggests that this problem is a lot
combinatorially more difficult than it
is right because like okay let's think
about how I actually edit documents like
I spend two-thirds of my day editing bad
grad student writing is like you know
I'm like jumping all over the place
between different lines like first I
delete this line and then maybe I go to
the bottom of my document delete some
other one that would be a big problem
from a dynamic programming perspective I
can't jump all over my document because
keeping track of that whole edit history
is going to be somehow combinatorially
ginormous right I'm not you know the
track changes button in Microsoft Word I
want the minimum number of changes
and if I have to recurse over like all
possible edits to every single line in
any order that's an awful lot of like
factorials and Two To The Ends floating
around that that I don't want to have
right and and so that's the sort of Crux
of of the challenge here uh is to
organize my approach to editing these
files in a way that doesn't require me
to have to to do this sort of
combinatorial jumping all over the place
and I think it's also the one where the
sort of like I know Jerry Kane at
Stanford talks a lot about the the
recursive leap of faith you know like
somehow dividing your problem into
organized sub problems that's that's
really where the the challenge uh lives
here
so if I were a more organized PhD
advisor the way that I would edit a file
um
or a clay tablet uh I guess in this case
um would be linearly right that like I
might as well do whatever the heck I'm
going to do to line one before I move on
to line two
right and like at the end of the day
like even if I did stuff in a different
order you could convince yourself that I
could always order it in such a way that
like all the edits that I do to the
first line kind of happen before lines
later in the document
uh with the possible exception of this
swap thing
um but we'll see that that somehow
doesn't matter and and moreover
if I do an edit I might as well do the
edit to make things better right like
there's no reason to just start like
willy-nilly inserting and removing lines
um I might as well always do an
operation that improves stuff
and so thinking about that sort of logic
leads me
to the to a particular way that I might
write down my S my sub problems here
which is to say that I'm going to think
about editing my document line by line
so in other words like once I've dealt
with line one meaning that I've found
some way to mess with it and make it
match line one of the other guy
I'm just gonna kind of think about
removing it and then thinking about the
rest of the document instead of saying
aha that's then it sounds like recursion
and that's right that's how we're going
to solve this problem okay so in
particular
here's going to be our our thing I'm
going to do a slightly different one in
the solution so you guys should all be
vigilant
which is I'm going to write x i j to uh
B the min
work
to convert
I'm not a python programmer but
hopefully I got this right
um
I colon is going to be everything from I
to the end of the file right so in other
words this is the
suffix version of our problem
um and uh the uh into
B
J colon
like that
okay
um so in other words like I have like a
little it's kind of like a video you
know like I think about Tetris you know
once once you get that full line of
blocks you can just throw that line of
blocks away and the whole video game
moves down there's somehow something
very similar going on here which is the
second I've managed to get a match for
line one of document into line one of
the next document I'm just gonna like
throw it away
and pretend like I have two documents
with one less line in them
now the thing that got me all hung up
last night
my original problem assumes that both of
my documents have the same length
but here I'm not making that assumption
right
and essentially what we're going to
figure out is if that actually doesn't
matter a whole lot that if I end up with
one document of length K and well I
shouldn't use K one document of length L
and another document of like zero what's
the amount of work that I should do to
convert well
L right because my only choice is to
insert a bunch of lines
in one document by the way or delete a
bunch of lines from the other those are
dual to one another exactly the same
I'm philosophizing a lot because I'm
also convincing myself that my answer is
okay in the process
okay uh right so this is going to be our
set of sub problems and now we have to
do
um the uh the r right we have to relate
something we struggle with in the math
department sometimes
um uh and essentially uh the way that I
went about this uh is to just do a
billion different cases of all the
possible edits that I could do to line I
and line J and that's perfectly fine in
this problem I think the problem is a
little slick and the way that they've
written the solution they've convinced
themselves that like some things are
equivalent to others and removed them
but you didn't have to as long as
there's a constant number of cases
you're you're golden
Ponyboy uh so in particular uh let's
think about some cases so first of all
if line I matches line J of my document
remember that it's not really line J
it's like making a document that just
happens to kind of start at line J
right it's like taking scissors well
then I can match them with zero cost
right because the beginnings are in the
same place
and I can move my Tetris game down one
and that's perfectly fine so uh right so
case one I think is the easiest one
which is if a i
equals B
J
right then I can just remove that line
from both documents and move forward in
which case I'll use my same goofy
notation I'm going to get that x i j
well I'm going to just increment I and J
and keep going right
like that
cool
Okay so
what's something else I could do I could
delete a line
yeah so what happens uh
um so
case two is delete
a I right that's a different thing I
could do to line I
well now what do I have to do I have a
document on the left hand side which is
one line shorter and the right hand side
nothing changed
but deleting a line cost me a dollar
right so in particular I have that x i j
well what happens well I got rid of one
line
right
um but I had to pay
okay let's think about some other things
um you could delete BJ
this case actually isn't in the solution
because it turns out to be unnecessary
um
oh I'm only allowed to edit a oh in that
case I don't have to delete BJ I really
didn't read these problems very closely
that's my bad
this would have made it much easier I
really should read these things
um
cool so that like eliminates half of the
cases of my notes fabulous
incidentally you could
do these things on the other direction
and it really wouldn't change this
problem a whole lot
uh sorry you know I have this bad habit
like when I'm reading research papers of
like reading the research paper I wanted
to be there instead of the one that's
actually on the paper and somehow it's a
very similar phenomenon here
okay right so uh great so I can only
edit document a which means it's
probably way easier than what I was
worried about uh fabulous in that case
ah bananas
um what's our third case here well
um
let's see I could also insert
a line
um
let's see so what ends up happening
there so I can only edit document a H so
that makes my cases different than the
ones I wrote down on my notes
um
sorry okay so uh
um
okay so if I insert let's do this live
yeah okay so if I insert a line at line
I
I might as well make it match BJ there's
no reason not to right like I might as
well kill off one element of B while I'm
at it yeah so if I do that what ends up
happening
well I still have to match line I I've
just kind of moved it lower in my file
but I've in essence killed one line in
file B by making it match this new line
that I inserted
in my notes because I thought I could
edit B I said okay I can just delete the
line and b instead and somehow logically
that's all easier to think about but but
these are these are exactly dual to one
another
um so in that case I have x i j
well I still have to deal with AI I
haven't gotten rid of it but I've
matched line J so I paid one dollar for
uh inserting a line
and now I have
that because I've gotten rid of a line
in in the other file
if I stopped here by the way I would
have edit distance but
um unfortunately for me I have one
additional case which is
mild irritant as they say which is that
I can swap right
first of all can I always swap
I mean I can but if I swap two lines and
they still don't match the lines on the
right hand side I'm kind of hosed right
because I'm you can convince yourself
that in the next step I'm gonna have to
delete something anyway
swapping was free if I swap and delete
that's the same thing as just deleting
so it doesn't really matter so in
particular what that means is I might as
well only check the swap if it actually
helps me yeah so in other words
if I have a and I have to be a little
bit careful because I'm swapping so if
the next guy in a equals B
the current guy in B and the current guy
in a
equals the next guy in b
well now I can swap this guy and kill
off two lines of my files while I'm at
it right so in this case uh I get that x
i j
well swapping doesn't cost me anything
and I killed off two things so
that's the the the the recursive so if I
were to write this out on my homework
what should I do well I shouldn't I mean
probably if you use this arrow notation
I don't think it would be a big deal but
but really you should should add a line
at the bottom saying that you know I can
choose to do any of these things so
really my recursive call is x i j gets
the Min of all of these uh one two three
four Expressions that I've written here
okay
what if I have the first condition but
not the second one ah so
that's a great question yeah so the
question was like okay well what if I
you know I can match the next line but
not the current one
well there's two different things you
could do you could either make another
case for that that's perfectly fine
right in fact you could do that you
could do you know that I matched the
second condition not the first one like
whatever you can just enumerate as many
things you want it all through and
there's a constant number
um alternatively you convince yourself
that that actually is unnecessary here
because a different so that's like
swapping
but then one of those two lines is still
a mismatch so you're going to have to
delete something in the next step
so you might as well just delete first
rather than than Swap and then delete uh
and and so that's why that case isn't
isn't necessary yeah exactly
exactly so if you swapped and you killed
a line then in effect I think it's a
combination of case one and case two
here
if you kind of expand your recursion now
but if you're having trouble convincing
yourself of that that's fine just add a
case here yeah
any other questions I'm going to ask
quickly because I this problem makes me
nervous
sure yeah okay in the worst case if if
we've done something wrong you can
certainly add another case here
um
I'll think about it at home
okay so uh since I've managed to
pontificate too long let's let's keep
moving here
oh yeah the problem is it might have
been used
[Applause]
and that's
not okay yeah because at the end of the
day the the files have to agree like you
have to match B to a
wow
to the leads into inserts no no but the
the Swap and delete is illegal because
you have to use both lines that's a
condition in the pocket oh I'm sorry
that's a better answer um so Jason
points out that if I swap thing I can't
delete it
um because the way the problem is
written so that effectively removes this
case otherwise I think I guess Eric is
oh sorry I've managed to totally botch
this which is totally unsurprising
um yeah so so I think the problem also
states that like if you swap the swap
has to be useful
um and that's why this this additional
case that Eric is asking about where you
swap and then you match one line but not
the other is unnecessary
you might be able to relax that by just
adding a case here but since the problem
doesn't ask it I'm not gonna think about
it
okay right
so under all the assumptions this
problem that I didn't read but are very
important to solving this problem
correctly uh uh I believe we really have
uh uh written down all of our cases here
um okay so let's let's continue with our
sort bot uh
Paradigm so now we have all of our our
recursion
the topological order here is a little
bit
trickier than normal right because now
you've got a two-dimensional array but
it follows a pattern uh that's pretty
typical here which is that x i j only
uh depends
um on on other xijs with higher
I plus J right so I think about my graph
of sub problems it always you know if I
wrote this in 2D Matrix it always kind
of points down into the right maybe
um which is what's making it uh acyclic
it's a very typical pattern in these
sort of two-dimensional dynamic
programming problem
all right so let's see here sort bot so
we need our base case
uh this isn't too bad because
essentially when you have boring
documents they're very easy to match to
one another right so in particular
uh
for any I
if I'm at line n plus one in other words
I have a blank document that I'm
matching to document I well
how much work do I have to do
it'd be a little bit careful this is
where the the suffix version of this
problem is a little bit more annoying
than the prefix one or if I managed to
swap those backward again
um that in particular the remaining
number of lines looks like n plus 1
minus I right
um which is different than like in the
problem is just I because they're
working in the other direction in the
solution rather and similarly you need a
second case for those two here right so
you have X
n plus 1 J is going to be
n plus one minus J
cool
okay
so we're going to continue with sort bot
here
um right so what is our original case
kind of by definition uh
is is X one one or zero zero depending
on how you index and then finally
what's our run time well uh let's see
there's n plus one
squared sub problems
and of course that's equal to order n
squared the sub problems are just a
constant amount of work
so they're each
with constant work
so our entire runtime is order N squared
and hopefully
by watching me be confused in front of
you and think through this problem you
too will see how the problem solving you
know procedure can happen in your own
disorganized brains
okay so that concludes our our sort of
treatment of this this problem here
that I think is the hardest one so so
the other two thankfully are are much
easier to to think about
I thought
um but I never liked at a distance I
remember seeing that in undergrad
algorithms getting confused
okay so uh the next problem uh problem
three here
uh deals with saggy mimson uh and she
has a bunch of blocks
and she wants to stack them on top of
each other
that's what it does and as a young
structural engineer she has a few
criteria on her problem
let me go to the right page in my notes
Here
right
so uh so this is problem three uh so we
have the Block B
um
I uh has size that looks like with w i
by
height h i by length l i
I remember getting confused in
elementary school about the difference
between width and length all the time to
me those always sounded the same but it
doesn't really matter because she's
happy to rotate her cubes anyway that
that she pleases
uh there's a key detail which I did
remember uh to actually read in this
problem uh which is that she has at
least
three of
each type
um where type here means that I can I
can permute these three numbers any way
that I want because that's the same as
this rotating a block
but anytime she has one block that's
like one by two by three she has at
least two two more in her bag somewhere
okay
um
oh one times two times three is equal to
six thank you Apple watch
okay so uh that's odd so she can Orient
her block any way that she wants meaning
she can rotate it
um uh and any any in any fashion that
you'd like
and so what we're trying to do what we
want
is
the max height
um where she's stacking uh her end
blocks I suppose I should say there and
blocks
uh so she wants the max height that she
can achieve but just to be kind of
annoying
um or because again she's very concerned
with structural stability she lives in
an earthquake zone she would like uh
with the condition
um that each block is strictly supported
uh on the Block beneath that right
um
so in other words like if this is the
base
of one block then the next block that's
stacked on top of it has to be strictly
contained within the block below it
right
so the problem makes sense have I
omitted any critical details I don't
think I have this time this one's a
little easier
oh yeah so and she can't do anything
crazy she can't like do like a weird you
know like balance it on its Edge kind of
thing
um which is Eric is absolutely right it
could actually give her a taller uh
Tower than you could get if you're only
allowed to rotate blocks 90 degrees I
don't think the problem states that
explicitly but this isn't a trigonometry
class so I think we're in good shape
okay
um right so so that's our our basic
problem here
this is one of these problems that like
it's going to be a dynamic programming
problem but again similar to many of the
things that we saw in lecture it's not
totally obvious how right because
somehow she has this big disorganized
bag of blocks you could imagine a
universe where there's two to the n
different things she could do right she
could for every single block she could
decide whether or not to put it in her
stack and then she has to do a bunch of
other work to verify whether she can
stack them while supporting the strict
support condition or not
so initially that seems kind of annoying
so what we have to do which again is is
pretty common to a lot of these problems
is is Place some order on it I mean that
both in the entropy sense and also like
literally we're going to order stuff
um and and in particular uh we'll see
that this problem has a lot in common
with that longest common subsequence
problem that we saw in lecture
increasing subsequent sorry
um right
so here's some some observations
about our problem which are going to
help
um first of all
when we stack our blocks
we might as well always align the
shorter side of the block on top to the
shorter side of the block underneath it
right
um
let me draw a picture of what I mean
so let's say I have a really block whose
base kind of looks like that and then
another block which is also rectangular
that I sit on top of it like that
then notice I could so in this case the
shorter edge of one block is aligned to
the longer edge of the other notice I
can rotate it 90 degrees and it still
supports on on one another so there's
never a case you convince yourself with
just a few inequalities
um where I don't kind of always put the
long side parallel to the long side of
the guy underneath it and the short side
parallel to the short guy underneath it
that makes sense
cool so that's observation one
observation two
can I ever like let's say that Maggie
actually sorry sat
saggy actually had not just three blocks
of a type but like 25.
so she just like has hella blocks
right she's uh my question doesn't
matter
the answer is no because
um this word here
is really critical which is that there's
strict support right so your block only
has so many faces
right and in fact
um by by observation one really all that
matters is which of the three types of
faces is sitting on top right because we
can just always rotate right so there's
three configurations of every block
so at most
can any one configuration appear more
than one time no because of the strict
support condition right otherwise the
rectangles would match up and that's
against the rules yeah
um so in particular
oops the number after two is never after
one is is two
which looks like that
um okay uh right so so in particular um
there are only three orientations
wait this is just which of the three
edges of the block is the one that's
that's going away from the floor the
normal to the ground uh and moreover uh
each
can appear
less than or equal to one time
that's good because it limits the size
of our problem
uh and finally
um
oops well I collapsed the the two of the
cases in my notes into one case here um
but that's okay
uh and in fact notice that the problem
tells us that she has at least three of
each type so in a sense
if the problem
um if You observe a one of a block you
might as well just throw away the rest
because you know that you can use it at
most three times and she has three of
that block we can't use it more than
three times so and since that's just
Superfluous information
okay
right so
um
this allows us to to put a little bit of
order here because notice that when I
look at the stack of blocks here
what do we know if I look at the length
of the long side and the length of the
short side in the plane of the ground
those numbers have to decrease on every
level of my block right they can never
increase that's what the strict support
condition says combined with observation
one actually even without observation
one
um which is which is good news right
um so this is what's going to allow us
to impose order on our problem namely
that we can sort by The Edge lengths
because we know that we we have this
support condition okay so let's let's
fill in some details of our algorithm
okay
so
right so originally already we can see
that our list of blocks is kind of
useless because the width length and
height values are sorted in ways that
don't matter uh moreover if we have more
than three of a given block that's
somehow not super useful
um so instead of that
um Let's uh without loss of generality
let's assume so w l o g here
um we can always take our block and
assume
I'm going to do this slightly different
from my notes the width
is less than or equal to the height
um
is less than or equal to the length Okay
so so every block if this isn't the case
I could go down my array of blocks and
sort and sorting a list of three numbers
is constant time okay
um
right so what does this allow me to do
well I'm going to say that a block type
actually is an ordered set where the
third number is going to be the axis
that points up
and the reason to do that is that we
know that we can never use that more
than once for any type of a block yeah
so now
I'm going to make a new list of blocks
capital B because I like blocks
um and it's going to look like the
following so if with so if W is less
than H is less than L then I'm going to
take every block and duplicate it three
times
notice that I might end up with a list
with like nine times of every block but
we will fix that later
um uh right and it's going to look like
the following
which is the okay I'm going to have w i
h i l i
this is like describing a way to stack
my block right because it's saying this
is the short side this is the long side
this is the vertical side
yep
and there are three cases right where
any one of these guys can be the
vertical side right so there's one let's
say that the H is the vertical side then
W has to go before l so it would be w i
l i h i
and a third one where the third guy is w
h is less than l so it would be h i l i
w i and those are all the different ways
that I can sort of Orient uh these
blocks in my stacking assuming that I
um impose condition one for convenience
here
okay we're going to make a new list of
blocks where I take every block in my
original set and I just duplicate it
three times this way after I sort its
coordinates
right and now
um well what do I need to do well for
one thing this thing may have too many
blocks I might have a block that's
that's repeated more than one time and I
know I can't do that
um and moreover it's going to be
convenient to have this sorted because I
gotta stack these guys eventually yeah
so I'm going to sort
uh that list uh and I want to do it I
can never say this word
lexicographically meaning the I'm going
to sort of the first coordinate and the
second and the third
lexicographically
um notice this length is 3n if I had n
blocks to start with so this entire
thing takes order n log
n time which is important to account for
um and then I can remove duplicates
I'll let you guys convince yourself you
can do this in order end time an easy
way would be to make a second array uh
and just kind of move and only add stuff
when when you you didn't see the same
thing before
okay and finally now these are ordered
in a really nice way right because I can
stack my blocks
but only ever looking to the right in my
sorted list
right assuming that I'm stacking from
the top of my tower down
which is I think sort of uh what's
what's going on in this thing
okay so now finally we can do our sort
bot um and I might do S and R and T and
then allow you guys to think about the
rest because as usual I'm talking too
much uh okay so
now
um this is starting to look like a
subsequence problem right because
essentially when I stack my blocks if I
use this block here again if I'm
stacking from my tower from the top down
all the blocks that can sit underneath
this one have to be farther to the right
in my array because of the way that I
sorted
now that doesn't mean that I can put
anything on the right underneath this
guy but it does mean that I know nothing
to the left can go underneath this guy
that's that's the way to think about it
Okay so
here's gonna be sore bus so s what I'm
going to say is that x i here is equal
to the maximum height of my tower
and I'm going to taking a little bit of
inspiration from our subsequence problem
that we've already seen I'm gonna I'm
gonna force myself to use block I we'll
see that's convenient
I and possibly
just for fun maybe we'll do the the
prefix version of this problem this time
um so now uh
I can use any of the previous blocks
right so I can use the first eye blocks
to make a tower but I'm forced to use
block eye by the way I'm from now on
when I use indices into this sorted
array okay
um so this is a problem obviously uh if
I could solve for x I would be done
right because I could get the maximum
height by just iterating over all the
x's and choosing the biggest possible
value here and the question is how do I
do this uh recursively
so uh here's our uh recursive step
so
let's say that I use block I
well because we we know we have to right
um so in particular
right we have uh now I'm seeing why they
didn't use this notation uh in their
answer but that's okay
[Music]
um
let's use another letter to refer to the
third coordinate
uh
[Laughter]
yeah let's say VI is always the third
coordinate so I've already used wh and L
and I'm afraid if I reuse them after
sorting it's going to confuse people
um so v i is the third coordinate
of the is element of my my sorted array
that's fine okay
um right so what is my height uh if I
use a
x i here well I get some height from VI
and in addition to that I get whatever I
I stack uh underneath that guy yeah
um so in particular
um
I get that x i well I get the height of
the block that I just decided to use
and now
what are all my cases
well I could decide to do nothing else
like just not use any other blocks that
gives me a height of zero
or
well let's see here
I could use the X's but I have to be
careful that I can actually stack them
yeah so in particular
well uh I need
yeah I I can take an XJ value but I got
to be careful that I can stack it
underneath so in particular
um
what do we know well I can do
anything from one to I minus one
right because that's sort of the
definition of x i
but in particular
I can stack it on top
right so one easy way to do this is like
it just array I I iterate through the
first I minus one elements of my array
and I just check my stacking condition
for every single one of them relative to
block J right so in other words that the
the width and the height or rather the
first and the second coordinate satisfy
the strict inequalities that I need
I'm phrasing this sentence neutrally
because I forget whether this is
increasing or decreasing but in any
event
um so what do I do I check all of the
blocks that I could possibly stack from
the index of the array perspective I
make sure that I could actually stack
them thanks to the the size of the
current block that I just decided to add
to my stack
um and I I move recursively
okay right so this is great because now
I'm learning exactly the recursive
scenario we wanted to be in right
because X I only depends on XJ where J
is smaller than I and that is exactly
our topological uh ordering that we need
if you do that on your homework you get
minus n for large m
okay
uh similarly uh what's our base case
well
obviously
um if I only have one block I might as
well use it yeah so in that case we have
x one is equal to I guess in our
notation here like that
uh our original one we have to look a
little bit careful because of the way
that I've defined X
because X assumes that I've used a
particular block
right so I have to say well I might not
have actually chosen you know the very
last block as the one I want to keep
um so I have to iterate I could say
that really my original is the max over
I of x i right so one of these blocks
has to be the block on top I'm just
going to iterate over all the possible
ones and find it
and then our final thing to do is the
runtime t
um this one is the mildly trickier than
the previous runtimes that we've done so
far in our example problem
in particular
uh how many sub problems are there well
there's N Sub problems or I'll say order
n because I'm always off by one
um
right corresponding to each uh Block in
my my stack here
but how much time does each sub problem
take at least the way that I've written
it here
um well what do I have to do I have to
Loop over all of the possible blocks and
find the one that I can stack on top of
and then take the max so there's a loop
here
from 1 to I I is upper bounded by n
so this is order N Sub problems Times
order n
work
per sub problem
so at the end of the day
my algorithm
is going to be order N squared
and of course again I guess I had I
promised it and then I didn't actually
do it to actually implement this
algorithm there's sort of two different
ways to do it right I could write a
recursive call plus a table right the
table is maybe initialized to a bunch of
nands and then I implement this function
recursively but before I do that I say
if the table does not equal Nan just
return the value in the table and
otherwise you know call this recursion
or I could just have a for loop from 1
to n and build up the table uh one
element at a time and both of those are
exactly the same from a runtime
perspective
okay so I think I've managed to botch
that much more than my notes or the
written solution uh but uh the problem
itself is actually pretty
straightforward so if you guys read
through the answer plus some of the I
think actually the hard parts of this
problem were not the dynamic programming
it was all the observations you need to
get there so that's why I I spent a
little more time there
okay so as usual I haven't left myself
enough time for the last uh problem but
we have a few minutes and and that'll be
that'll be sufficient to set up the the
I actually found the last problem to be
easier even though it technically is
sort of two Dynamic programs in one
um somehow I think the logic is a little
easier okay so uh
[Music]
I think this is the backboard yeah
that's that's I was just realizing that
this room doesn't work the same way as
the other one uh yeah this is
embarrassing you know I spent all day
thinking about topology and this is like
a classic kind of you know problem in
that Universe
um
Okay so we'll just erase one board at a
time and I'll try not to write three
feet
um live this time oh this is probably
the one board I shouldn't use
foreign
so
right and our final problem we're given
an N by n grid
and on our n by n grid uh Princess uh
Apple uh banana
Plum Princess Plum uh
right so here's our basic setup there's
a big grid of stuff
or maybe a small grade because I don't
feel like drawing and and every grid
Square can have one of three things you
can have a mushroom you can have a tree
or it can have nothing at all
and uh our princess starts here
and she goes she wants to go there
uh and and and
moreover uh there's a couple things that
are worth noting here so first of all
um her path is quick
meaning that she can only Traverse two n
minus one grid squares
um
to get from one corner to the other
and apparently she's very into mushrooms
and she'd like to accumulate as as many
as possible along her path right that's
the basic setup here so she wants to get
from the upper left to lower right
and uh in order to do so uh she wants to
take a quick path so she her main
priority is to be efficient but among
the different quick paths
she wants to pick up a lot of mushrooms
it's understandable
and not walk through trees thank you all
right so like maybe there's some grid
squares that are marked with like a tree
meaning that you just can't go there
that's a tree
um okay uh uh right so that's our our
basic setup here but the problem does it
takes a bit of a Twist right it's not
saying just
could be the shortest path which should
be very much like the last kind of unit
in six double o six
um but rather uh the question is sort of
what is the number of paths that she can
take from one side to the other
um and what is the maximum number of
mushrooms is roughly the question asking
at least what I remember from reading it
last night
that's right so so so she has to take
the most number of mushrooms she can but
there may be more than one path uh that
gets you there that is quick that
satisfies this condition in which case
she wants the count of the total number
of ways you could get from one coin to
the other why you might ask why not
um okay so right so uh you know so for
instance maybe there's a mushroom
here
um now there's a quick path that gets
her there uh and collects one mushroom
so there's exactly one but maybe if
there's a mushroom
there uh
well initially it feels like maybe she
could get two mushrooms right she could
go there go up pick up the second
mushroom and get back
but we're going to see that this quick
condition actually uh allows it doesn't
allow you to do that okay so in fact
it'll turn out that quick paths can only
collect one Mushroom in this two three
by three case so there's the at least
two different paths
well there's one
two
three uh different ways that she could
collect one mushroom and have a quick
path
okay
so the first thing to notice uh your
search is a little bit sneaky
by defining quick paths uh basically by
giving her no slack at all right
um and here's the basic observation
notice the in order to get from the
upper left to the bottom right she's
going to have to go down into the right
possibly she could also go up like she
could try and go around a tree
but only plausibly uh and in particular
the question is how many times does she
have to go down and how many times does
she have to go to the right
well she has to get to the bottom of the
grid right so she's on grid square
number one just go down in this case at
least two more times so in general n
minus one times
she has to go to the right
n minus one times
so what does that mean she has to make
two n minus two moves
and that's a lower bound right so if she
goes up she's going to have to go down
again so it's only going to make it
bigger right so at the very least she
has to do two n minus two
moves
you know down and right to get from the
upper left to the lower right
how many squares does she touch when
she's doing that was the fence post
problem right so she made two n minus
two moves and she had a place where she
started
um that implies that just by moving down
into the right she makes two n minus one
squares
she touches rather
so can she ever move up
no could she ever move to the left
no
and that basically is all you need to
solve this problem the rest of it's
actually pretty easy right so so the
basic observation here is you can only
move down and to the right because she
moved up or to the left her path would
no longer be called quick uh and that
would be a problem moreover every path
that moves down into the right is a
quick path
assuming she was just their target and
doesn't hit a tree
okay
um so that's the basic observation and
notice that that already basically
suggests it's like screaming out to you
how to do dynamic programming because
literally you have a table
looking at you on the Blackboard right
now and you have an ordering like down
into the right the the the the the the
is acyclic yeah
okay have I flammed on the board enough
times the first time I taught at
Stanford they I got negative course
feedback that I had too much coffee and
was slamming on the board a lot
apparently
um I watched the video later and indeed
that was not wrong
okay
so uh right so uh we're going to call K
this is going to be the sort of the max
mushrooms
she can get going on on the entire path
in the upper left to the lower right so
we want to know the number of Quick
paths that can achieve this number kit
okay so let's do sort by
really fast because I got four minutes
actually a tiny bit more than that
because we started late
okay so uh
now the kind of annoyance here is that
there's two different numbers that we
don't know right one of them is K and
the other is the number of paths right
like the problem didn't tell you how
many mushrooms she can pick up it does
tell you that there's some path to get
from the upper left to the bottom right
there's not just like a row of trees
somewhere
um
which I feel on my commute sometimes
but uh
it doesn't tell you you know the number
that she has to accomplish
um and and initially that's that's kind
of annoying so maybe the first thing
that we do is just compute K like the
maximum number of mushrooms that she can
collect on any quick path
and then we go back and compute that
other account yeah because that would be
one problem-solving approach so that we
could think about a little bit
um so in particular uh let's define
okay
i j
to be equal to well we can generalize
our problem slightly and say what is the
number of mushrooms that I can get on
any kind of rectangle embedded inside of
my full problem right so in other words
this is the max
number of mushrooms or M's for short on
a quick
path
to i j so in other words she always
starts in the upper left but now she
stops at any other grid cell
okay
uh
because I'm running low on time
no I'm going to do this the way I want
to do this no so we're just going to
think about okay yeah
so the question is could we
compute Justice value K which certainly
seems convenient like like you know
Princess uh Plum really she might as
well know her anime she might as well
know the number of mushrooms she's
targeting if she can if she can get it
right
um
so how could we do this uh
recursively
well she has to get to position i j
and from our argument up there she has
to get there by either coming from up or
to the left
right the way we've chosen to write down
this problem
so
what are our different cases well first
of all if there's a tree
you can't do a damn thing right she
shouldn't even be able to get there yeah
and for convenience uh we're gonna find
You could argue that it's zero um we're
going to mark this as with a special
number and we'll see that that makes our
notation a little convenient
um so one is if there exists a tree
then we're going to say k i j is minus
infinity again there's a philosophical
question there does she get minus
infinity mushrooms if she is standing on
top of a tree I don't know because she
shouldn't stand on top of a tree but at
least it's it's going to let us know
that something went wrong in this grid
Square in the other parts of our
recursion okay
um and otherwise
well what are our different uh
cases here well she always picks up a
mushroom if it's there she might as well
she's maximizing yeah in fact I think
the problem even says that she's she's
like really new mushroom she like
collects them automatically right
um so uh what do we get
I'll use unnecessarily fancy notation
this is an indicator of uh whether there
exists a mushroom
at position i j
right
um meaning this is a one if there is and
there's a zero if there's not
uh sometimes this is a indicated with a
one with a little subscript but whatever
um and in addition to that she might
have picked up mushrooms along paths and
we know that her path to position i j
either came from up or to the left
right so uh in other words we know
that she could have gotten the Max from
any path ending a buffer or any path to
the left of her so that's k i minus 1 J
which I guess is to the left and k i
J minus one like that
and this can be used to fill in our
whole table of K values
in fact since I'm low on time I'll let
you do the t-bot
for the remainder of this problem right
essentially I think the key observation
is this one right obviously when she
starts in the upper left we get zero
mushrooms because she's not standing on
top of one the problem says that
and this allows us to fill in our whole
table k
so in particular this gives us our enemy
now we now know how many uh
mushrooms she should have at every step
of her journey in fact it tells us a
tiny bit more than that right because it
says if I'm at this grid scale at this
particular grid Square during my path I
should have this many mushrooms if I
didn't then something else something
went wrong
yeah
um so the way that the solution is
written they do two pieces of the
recursion and once you actually could
have just solved for this K Matrix first
and then gone back and done the second
half with this problem and those are are
exactly the same yeah and and when I was
writing my solution this is the way I
thought about it because somehow I kind
of thought like she might as well know
how many mushrooms she wants to collect
before she starts counting paths that's
like a secondary question you know
um and and so this is one way to do it
so in our remaining negative two minutes
um let's think about the recursion for
computing remember that we want to know
the number of paths needed to collect
that many mushrooms uh the maximum
number of mushrooms
please let there not be a whole lot of
stuff on this board ah there's not any
stuff on this board it's great okay
um so in particular
now I'm going to define a second thing
that I also am going to do dynamic
programming on yeah I'm going to say
that x i j
is equal to and I'm going to make a kind
of a sneaky definition uh here which is
the number of Quick Pass
um that end at IJ
with
now let's anticipate our problem a
little bit so at the end of the day
we're going to do like X of n comma n
because she wants to end up all the way
down to the right and how many mushrooms
does she want to have now that we know
okay
she wants to have K of n comma n
mushrooms
along the way
it would be kind of ambitious if she
wanted to have K of n comma n mushrooms
the entire path
um but it would be slightly less
ambitious to have K of i j mushrooms
because somehow that's exactly what we
we just uh constructed in in the
previous thing was path right
so well the last guy looks like a Max
now we're going to expect to see some
plus signs here because we're like
adding up how many paths we have okay
and now let's come up with our recursive
rule for for this uh array X and then
we'll we'll call it a day so in
particular
gun one if there's a tree
how many paths are there
there are no paths because I can't get
there yeah so then I J
equals zero
okay otherwise there ain't a treat
and now I have to be a little careful
right
um
so I'm going to write this like a little
piece of code
um you could have written this as a
giant Max instead and there are a bunch
of cases uh and and whatever so let's
think about it like a piece of code so
initially I think there are no paths
that get me kij mushrooms that's
perfectly fine
and remember we're going to keep
applying the same piece of logic which
is that a path can only come from to the
left and up and let's uh think about
those two cases
um
and by the way we're going to use Chi to
equal this Chi of stuff that that we had
in the previous expression right
um so Chi is one if there's a mushroom
at this place and zero if there is not
okay
so my path can come from the left or up
I know that it can't come from Up
if the number of mushrooms that I got
from Up
plus potentially the one that I got here
doesn't align with the number of
mushrooms that I should have by the kij
standard that I have set for myself
yeah so if I if I want to write that out
in code uh the way I do that is I say if
um K of so let's say I look to the left
first
you know this is like you know look to
your left look to your right one of you
will pass this exam kind of scenario and
I potentially add a mushroom at my
current position if there is one
if that is equal to k i j well what does
that mean that means that path that went
to the left were able to collect the
number of mushrooms I need to get to the
position I am now so now I can add
what well all of the different ways
maybe I'll do a plus equals
X of
I minus 1 J right because any path that
got to the previous guy and clicked the
right number of mushrooms can now reach
me and get the right number of mushrooms
and similarly I can look up and do
exactly the same logic so if K of i j
minus 1 plus this number is equal to k i
j
then x i j
gets an additional
number of paths
like that
and now I do think it's worth spending
eight seconds thinking about our base
cases uh here because initially when I
first saw this I panicked a little bit
because it kind of looks like this
should just end up giving you a bunch of
zeros
right because like I'm just adding
values of x's to themselves I don't have
like a one plus anything anywhere
which is kind of weird if you think
about it so all of the reason why the
positive numbers appear in this problem
is from the base case which is kind of
cool I think
um it's like I think one of these things
where if you anticipated a problem then
it's cool and if you didn't anticipate
the problem to begin with you just wrote
down this formulas you probably wouldn't
even think that it's interesting um uh
but but in any event
uh what is our base case so we'll we'll
do the b in sort bot
um so first of all
um
what is K of one one remember that's the
number of mushrooms you can collect by
starting at the left square and going
nowhere
and that's zero because the problem says
there's no mushrooms in the upper left
what's X of one one well this is the
number of paths from one one to itself
that collects zero mushrooms so that's
one
OK and I think that the rest of the sort
bot table here isn't terribly uh
difficult to fill in
um so notice that in in a kind of a
funny way all of these were Christmas
steps we're just adding one to itself a
bunch of times
um but of course the way you do that the
reason why you get a number that's
interesting is because of all these if
statements and the fact that you can add
two different pluses coming from two
different sources
okay so I actually do encourage you guys
to look at the code in the the problem
solution because I think it's a nice
example of taking this recursive formula
and then unrolling it into like
iterating over a table and that's a
useful skill that I intended to do today
and then didn't actually do uh very
carefully
um but with that as usual we've gone
over time here so we'll call it for the
day uh and I will see you guys
when I see you guys
all right