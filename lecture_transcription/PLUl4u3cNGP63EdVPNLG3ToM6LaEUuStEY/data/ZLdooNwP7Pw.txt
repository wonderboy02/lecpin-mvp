all right
well uh welcome to problem session five
of 6006 it's a pleasure to see all your
smiling faces here today
uh this week we're going to cover some
problems in graph theory related to
death for search and breadth first
search which were roughly the topics
that i guess we've covered in the last
couple lectures and what's going to be
on your homework
uh and i believe this is basically the
homework from from last year uh
with a few revisions uh based on some
typos we cut
oh and i caught a spelling mistake that
i'll bother our instructor about later
okay uh so without further ado let's get
started i guess we'll just do them in
order for lack of creativity here
um the very first problem has to do with
some measurements on a graph
uh which is actually a really
interesting one to me so it turns out
that in a lot of research in
for some reason in computer science
there's graph theory research and then
there's networks research and these are
two different
communities for weird historical reasons
that i don't totally understand
but people in the network science
literature often measure
things like the radius of a graph and
some other kind of measures that are
trying to tell you something about like
is a graph a long spread out thing like
a line graph or
something super compact like a star and
so on uh and so this problem is kind of
digging into the algorithmic aspects
of how we might compute one of the
measurements that i believe is is
fairly common in in that community
uh so let's uh kind of go through these
problems as usual in 6006 we like to
take
actually relatively straightforward
computational problems and then dress
them up with a lot of language to make
it annoying for you guys to parse
and indeed this problem is no exception
to that uh so in this problem we're
given an
undirected graph
uh and as usual we will call him g
uh and we define a particular number
that we're trying to measure
in this in in this problem right so uh
in particular uh
right if we given a given a vertex v
uh then we can define something called
the eccentricity of v
which is the distance to the farthest
away uh
thing so in particular um we can define
um is going to be given by
the following which is the max
over all the possible i'll try to make
sure my notation
oops i've already oh that's okay uh
over all the other vertices of the
distance from
uh v to w
right uh so i'm like standing at a point
on a graph and now i like you know make
a loud noise
and the last person to hear me uh the
distance to him would be
uh the the eccentricity of that vertex
and so uh this is some kind of notion of
like radius or diameter
but sort of planted at a point and then
if we want to learn a property not of a
vertex but of the entire graph
one thing we can do is to find the
radius
and that is given by r of g
is uh the min
over all of the different vertices u
of the eccentricity of u
okay so i think this is one of these
definitions that's really annoying to
parse and think about so we should like
draw a little bit of a schematic and see
what's what's going on here because uh
especially as a geometry professor this
one's kind of nice because it translates
directly to
what you might do in metric geometry so
um let's say that i have a circle here
and i want the world's most complicated
way of defining its radius
okay so for any given point
there's a point in a circle that's a
circle in case you're wondering you know
those are those
internet contests where like they have
people that just walk up to the board
and draw
perfect circles and then leave i
unfortunately am not an expert at this
matter
um but anyway so if we think of a point
like a circle as some analog of our
graph
and then i draw a point which might be
the analog of a vertex
right then what is the eccentricity well
it's the distance to the farthest away
point right so for this guy it might be
the length of this line roughly uh
because that's the distance to the
farthest away thing
right so for every different point that
i draw
you know each point has its own farthest
away point in the circle
uh so there's some positive number
that's assigned to every single point in
this domain
and if i take the minimum of that
positive number
where do you think i end up
that's right jason i end up in the
center of the circle
because if i think about it the distance
to the farthest away
point in this domain um one thing you
can convince yourself is that that's
sort of as small as possible so this is
what we might call a minimax problem
in in optimization because we are
minimizing the maximum
distance yeah um this also shows up in
game theory
all kinds of different places that solve
this stuff but thankfully in this
particular problem we're not going to
need all that
okay so uh right so this homework
problem has two parts
um the first is to give an algorithm for
computing the uh the radius of a graph
and then the second one is to give an
algorithm for approximating the radius
of the graph
uh really quickly or more quickly than
the first part
um i actually don't know if there's a
lower bound there but
come back to that later okay so in part
a
right we're given
g and moreover we're given one
additional piece of information which we
actually do
need in this problem i think it's one of
those words that kind of slips past us
when we read graph theory problems
but it's important to pay attention of
course and
that is we're given g and it's connected
i suppose really it should be given
connected
g but that's okay um now what we want
is to compute
the radius of g in time that looks like
the product of the vertices the number
of vertices oops
times the number of edges or the number
of edges times the number of vertices
your instructor struggles to speak and
write at the same time but it's a skill
that i'm working on
and frankly handwriting is much easier
with this little chalk
okay so essentially you know i used to
have a math professor in college that
use this phrase all the time that you
know this is like it's important not to
think here
um you know the the problem asks you to
compute the radius
of a graph and in some sense there's an
algorithm that just like writes itself
for computing the radius right because
the radius is the min over all the
vertices
of the eccentricity the eccentricity is
the max distance so what would be the
simplest thing to do here well
in some sense it would be to loop over
all the vertices compute their distance
to all the other vertices
and and and and take the max for each
one of those
and then the min over all of the guys in
the outer loop
since i just said a sentence that i'm
realizing doesn't parse particularly
well uh let's let's sort of write down
what i mean
um which is to say we're gonna think of
there being an outer
that's why we don't use this chalk an
outer for loop uh which is computing
this min
right so
right well what are we going to do we
can you know compute
the the shortest path distance
to uh all of the other w
uh in in my graph you know
take the max
of w of the distance from v to all the
other w's
obviously we can kind of do these two at
the same time
and then if this number is bigger than
my current max keep it and
or oh yikes if it's smaller than the
current estimate i have
of the uh the radius then i keep it and
if it's not then i throw it away right
so maybe i initialize
you know my radius at infinity
and now let's call this number i don't
know little r
if little r is less than big
r then just keep it around
right and so if we think about it i
don't think it's terribly hard to prove
that this algorithm is correct because
it's sort of just
taking our definition of what the radius
of a graph is and translating it into
um a brain dead algorithm um so i think
really the the challenge here uh is is
proving the the run time uh
in in this particular algorithm so what
does our runtime look like so we have a
loop over
vertices right so i kind of incur
a factor of mod v here uh and then
uh well our graph is unweighted so
one strategy for computing the shortest
path distance would be
uh breath first search i think that's
what's in my notes
yep uh and in general breadth first
search if you recall from lecture
takes mod v plus mod e
time so the question is okay so if i
multiply these things together what do i
get i get
o of v times
v plus e
like that time but like uh oh
that's not the time that my homework
problem wanted right because the
homework problem
asks you to solve this in just mod v
times e
time and somehow we've incurred an extra
factor
and now we have to figure out why this
is actually okay
or we have to fix our algorithm but in
this case uh it turns out that this
runtime is just inaccurate
okay um what's our intuition here well
i i kind of underlined it for you here
our graph is connected
in particular there's going to be a nice
property of connected grass
which is that the number of edges dwarfs
the number of vertices here
so really if we have v plus e you know
and sometimes it's going to look like a
constant factor times e
plus another e here so this whole thing
is going to be v times e
time yeah so let's let's make that
argument a tiny bit more uh formal here
so in particular we know that g
is connected
um right and every vertex
so in particular what can happen here is
okay unless my graph consists of one
vertex
which is a case you could dispose of
pretty quickly
what i can't have is a graph that looks
like this like one vertex and then an
edge
floating around there everything has to
be connected together
connected together okay so
in particular uh what this means is that
every vertex
is adjacent to at least
one edge again
except i guess technically the one
vertex case but i think we can convince
ourselves that for any graph of constant
size
we're we're not terribly worried about
it right it's just the asymptotics that
matter in this problem
okay so if every vertex is adjacent to
one edge
well and remember that every edge kind
of by definition of an edge is adjacent
to two vertices then what we can
conclude
is that the number of vertices is less
than or equal to the number of edges
divided by two there's a conservative
estimate
and so in particular what does that mean
it means
that v is big o of
e this is a case where we have to be
quite careful about big o being an upper
bound
right uh in this case typically v is
much less than e
um well depends how many edges like if
you have a really dense graph or not
um but in this case what does that mean
that means that
mod v plus mod e is really just
big o of mod e right because this is big
o mari
plus big o of e and that means
that our problem really runs in v
times e time uh which is what we wanted
in our problem
are there any questions from our
audience on part part a here
cool yes understand why uh
where you went from the first statement
to the second statement there
every versus one edge implies v is less
than or equal to
e oh yeah so i guess i guess there's
sort of two things that matter here
right
uh every vertex is adjacent to one edge
at most and every edge uh
yikes uh every edge uh is adjacent
to two vertices
um i guess actually it's the second one
that matters so you you can never have a
vertex just floating by itself so one
way that i can count
my number of vertices by looking at the
number of edges and saying that well
every edge can touch exactly two
vertices every vertex has to touch
exactly
well at least one edge um so if you put
those together you can convince yourself
that this bound has to be true
if you want to be conservative about it
you can just get rid of the divided by
two here i guess it doesn't really
matter
any other questions from our audience
all right so now uh let's take a look at
part b
uh so in in in part b here uh they ask
us to basically do the
some version of the same thing right
they want us to now approximate the
radius but we're given a smaller
budget of time so now what we want
in number b here is uh compute an r star
such that uh i got yelled at in my
textbook that
st apparently should always be subject
to
i got an angry review of the textbook i
wrote because of that which was puzzling
to me
but amazon.com is not a great source of
useful data but in any event we want our
star
which is sandwiched between the radius
of g
and two times the radius of g
um like that now notice
so in other words we want to the first
thing to notice is we want to upper
bound
the radius of our graph and already this
should suggest to us how we might solve
this problem
right because if we take a look back at
our definition of radius over here
notice that the radius is a min right so
what's going to happen
if i returned epsilon of some other
vertex
well it's lower bounded by the radius
because the radius is the smallest
possible epsilon over any vertex
that makes sense now when i was doing
this problem
um because uh you know i'm the dumb
instructor of the three i said well okay
but
like you know maybe i need to be like
somehow judicious about what vertex i
choose like
you know well in some sense what this
suggests is that maybe i choose some
other vertex and compute its its
radius and return that as our
approximation but of course the problem
wants me to sandwich it
between two values here so in addition
to
uh you know upper bounding r i want to
be less than two terms are in other
words my approximation is within a
constant factor
um i tried some some weird stuff like
farthest point sampling and so on then i
realized that
you actually don't really need to do any
of that
one thing you can do is literally choose
any vertex
return its uh eccentricity and that's
actually good enough yeah so here's our
algorithm
um great let me go back to my notes here
i don't know why i'm following my notes
actually through the soft top head but
they make me feel better
if i'm looking at them at the same time
so in particular
what i'm going to do is choose
a u and v let me be clear here any
u and v so if i'm using some data
structure to store all my vertices i
just take the first one
whatever and two
i'm going to return
r star is equal to epsilon of u
um now of course this isn't really an
algorithm if you do this on your
homework you'll lose points
and the reason is that i haven't told
you how to compute this value here
so if you were to write out your answer
for this problem of course you should
tell us
that like really to compute epsilon what
do i do i use breadth first search to
compute the shortest path from u to all
the other vertices
and then i guess i take the the max
value here okay so i think you guys can
fill in the uh
the details of the algorithm uh the
bigger challenge is going to be to prove
that this is actually a good bound
right uh and so in other words what we
need to
prove here i don't know like there's a
claim
there's a proposition there's a theorem
so we're like somewhere on that axis
i'm going to call this one a claim i'm
going to downgrade it
and that is that the radius of my graph
is less than or equal to r star
which is less than or equal to two times
the radius of my graph
okay so let's uh let's prove this uh
this thing managing to use all of my
boards on one problem here
okay so uh in particular to prove this
claim i need to prove two inequalities
this is like two homework problems in
one
uh so let's number those off there's one
there's two okay
so let's do inequality one i think we
can squeeze
him into a relatively small space so
remember
uh what is the radius of my graph
well just by definition right we know
that it's the min
over all possible u of epsilon of u
so in particular what's the nice
property about the minimum of something
is that it's less than everything else
or equal so this
maybe let's call this u naught just to
distinguish between that and
the notation i have on the left hand
side this is less than or equal to
epsilon of u because
i don't know because min yeah uh
so uh that actually already uh and of
course this is exactly what we chose to
be our star
so our first part of our proof is done
here
yep so this is the easy part and
sometimes like
this is sort of what inspired our
algorithm so we expect this bound to be
kind of straightforward
okay but the other half of the problem
is a little more
tricky uh and actually
there's a solution in the notes and then
i decided just to make it a little more
inaccurate to write up my own
um so uh but actually i have
i have an ulterior motive which as i
noticed in this class we don't
tend to use a tiny piece of notation
that i like so for my convenience and
future problem sessions i thought i'd
introduce it now
so we're solving a minimization problem
the nice thing is that in this class
everything we do is finite
if you take my graduate course that's
not going to be the case in fact
actually in lecture two we're going to
do like variational calculus but
uh in in this course uh what does that
mean that means if i minimize a function
there's actually a vertex in my graph
that achieves that minimum
right this is different than like for
example if i then i'll shut up but like
if i wanted to minimize
you know here's f of x equals
1 over x and i ask you for the minimum
value well it's
you know overall x greater than or equal
to zero
well the minimum value is zero right if
i take x off to infinity
but it never quite crosses zero right so
you're kind of in this weird
universe if you remember jason's lecture
he talked about imps and supes as
opposed to min's and max's
but this can't happen in our problem
because when we compute a min there's
actually a vertex that achieves it
and that vertex we call argument okay
and so this arg here stands for for
argument
so one thing that i can do is say okay
so
remember that my radius is the min
the min overall u of u
epsilon of u that i'm going to define a
vertex
u naught to be the argument
over u of epsilon
of u and this is just fancy notation for
saying give me the actual vertex
that makes this value as small as
possible yep
uh the nice thing about this problem is
that we're not worried
yet about i will make runtime so i can
construct this kind of thing and not
worry about how i actually found
it right okay so let's say that we did
that so this is
find me the vertex um that actually
gives me
the radius right so in other words i
find that vertex and then i find his
or her farthest away vertex and measure
the distance and that distance is the
radius of my graph
okay um so let's actually do that so in
particular
then i can define a second vertex v
naught
well how does the radius algorithm work
i find the central guy and then i find
the one that's farthest away
so we're going to make him the arg max
over all v in my graph of the distance
starting at u to any v
right so if i think about my circle it's
a circle
right then u naught is like that center
of my circle
and then v naught is like that far away
point
this is a schematic right my circle is
really a graph in this problem but i
think i think the analogy actually works
okay but in reality my algorithm was
brain dead i didn't actually compute u
naught i computed
i just randomly drew sorry i shouldn't
use that word i arbitrarily drew a
vertex u
and then computed you know the farthest
away distance from that guy
uh and of course what we have to check
is that that thing is within a factor of
two of what i wanted
so okay uh if i have u then i'm
additionally gonna define one more thing
called v
and that
uh mm-hmm
oh boy uh okay so i'm noticing i'm
saying one thing and i'm writing another
u naught is the center of my graph i
just i think i said it i just forgot to
write it
and then this v is the farthest away guy
from him so basically
the subscript zero here means like is
the platonic ideal of what i wanted in
my problem and no subscript is gonna
mean
the other one so now um
i compute the farthest away thing from
the u that i actually chose in my
algorithm
that's some v bar right so again
remember my algorithm just says
okay i'm going to like choose some other
point v
and then return v's distance to some
farthest away point
uh oh sorry choose another oh boy choose
a point u
and return his distance to some far away
point v i think i've managed to lose
everybody
uh nodding together using fees here okay
so why did i introduce all of this
notation
um because this is what's going on in
this problem right to actually compute
the radius i want to find the most
central point u naught
and its distance to its farthest away
thing v naught in reality i
arbitrarily chose a point u and i
returned uh u's distance
to some point v and i want to show that
those two things are within a factor of
two of each other
okay that summary makes sense even if i
talked in circles for a little while
okay so let's actually do that so
remember that
uh the thing that i'm going to actually
return is r star
and that is equal to the distance from u
to v
now because i just made all these
definitions and now i get to
uh use my favorite inequality
um in fact this is sort of the only
inequality we know in this class so far
i think
which is the triangle inequality uh
which says
that of course this is less than or
equal to
the distance from u to u naught
plus the distance from u not
to v right so in other words this is
saying the shortest path from u
to v is always upper bounded from the
length of the shortest path
from u to u naught and then u naught to
v right this is drawing a triangle
aha but take a look what is
the actual radius of my graph well in my
notation
the radius of my graph is exactly the
distance
from u naught to v
naught and this thing
is bigger than the distance from u
naught to anything else by definition
for all of e right so if i flip this
inequality backward
well take a look this is the distance
from u naught to something this is the
distance from u naught to something
so i incur two factors of the radius
and i get the bound that i wanted yep uh
and so this is a slightly more formal
proof of
exactly the same thing that's in the
homework notes okay so the one thing
that's remaining is to actually show
that our algorithm
runs in a reasonable amount of time so i
think they give us a budget of order e
time but notice that argument is
precisely the argument that we
just made right here uh just minus the v
factor
and the v factor just came from looping
over all the vertices in in part a
uh so now i think we're we're done with
problem one
as usual i've wasted too much time on
the easy problem all right any questions
about uh about this one
excellent well now that i've written too
much uh let's uh do the rest of it
i spent time on this problem because i
like it it looks like a geometry problem
okay so now
uh let's see in problem two which i
noticed that this homework is kind of
full of
prototypical 606
graph theory problems in general like
they just go down the list of things
that people typically do in graph theory
that are like useful tricks to know so i
would suggest
the students in this class even if it's
pass fail uh look very closely at this
homework before doing
uh the current one i think the ordering
works out that they can do that
um because i think you'll get some good
hints
for how to solve all the the the current
homework uh
so you hear you heard you heard it here
first guys
okay so in problem two uh we're talking
about
internet investigation uh so in
particular
uh mit has a bunch of different routers
that are connected by cables uh to one
another
and essentially uh what are we given
we're given a bunch of different routers
and we're given the length of the cable
in between them and the latency
unsurprisingly is proportional to the
length of the cable that
in my abstract understanding of how
computers work kind of makes sense to me
i'm not sure that's actually true but
um that's sort of immaterial for 606.
i assume our department has a networks
class if you're interested in that kind
of thing
uh and essentially uh what we're trying
to do is sum up the latency
over all of the uh the router so let's
let's write down a little bit of
notation here
while i continue to dance all over the
room here
keep losing uh losing my chuck
i need like a holster i feel like that
would be useful for for the chalk bucket
okay so now we're going to do problem
2 here so we're given our routers
and some of them
are marked as entry points
uh and now we have a bunch of
bi-directional wires
wi each of which has length
l i uh and that's a positive integer
value here
yep and uh actually because of this
so technically i think a lot of students
in this class have encountered weighted
graphs before but if you think about the
narrative of of this course
i think for the version of this homework
we haven't really encountered
weighted graphs yet but a better way of
putting it rather than psychologically
diagnosing your instructors
uh is is that what we're going to find
is that they're often
problems that look like they're weighted
graph problems but they really aren't
and and this is a nice example
uh where that's the case okay uh so we
define latency
uh as follows that it's at least
proportional to um
the shortest uh path to an entry point
and now we have two additional
assumptions that we need
right one is that the total latency
uh or at least the latency of every
vertex
which is the same thing latency uh
is less than infinity what is this
really saying by the way
like when would the latency be infinity
it would only be infinity if i like took
a pair of scissors and cut a wire and
would just connect it
from the rest of the network yes uh
every router
is connected to some entry point that's
exactly like there's some path from
every router to some entry point
doesn't necessarily mean the entire
graph is connected i guess um
but at least that you can always get to
an entry point uh
and then moreover uh and this one's the
the real kicker here
uh that there's uh at most a hundred
r uh feet of wire
incidentally r stands for routers i had
like the problem the previous problem in
my head was thinking radius a long time
um so don't be like your instructor and
actually read the entire problem before
getting
hung up on it but in any event the thing
that you're trying to
do is to compute
the sum over all of the routers
uh i don't know are whatever
of the latency of of that router
okay so that's our our problem here
incidentally
this little goofy exercise i just did of
taking this paragraph problem and kind
of writing in bullet points
i find helps me a lot when i'm trying to
solve these algorithms problems
because i think it's really easy to just
get like thrown off by a wall of text
here
okay so this problem is screaming out
graph theory
like we're practically like using the
terms here we are using the terms right
like you've got
nodes that are kind of like routers and
maybe edges or kind of like
wires but there's a bit of a catch which
is that your runtime
right at the end of the day i think you
want order r
run time that's where things get a
little funky initially
um and so we have to think a little bit
carefully about how to do it
and here's going to be the the trick so
this is starting to look like a shortest
path problem but what would you
maybe not want to do would be to iterate
over every single router
or every single vertex and every single
router and compute the shortest path
between every single
pair because if you did that oh boy i'm
i'm confusing my terminology
there are entry points which is the
thing that i need to compute the
distance to
uh and i need to iterate over every
single router and compute its distance
maybe to all the entry points and then
take the min or something like that
but if i had a double for loop then i'm
probably not going to get order our
time right because somehow you expect it
to look like something squared or like
the product of two terms
supposed to be a little more sneaky than
that and we're going to use a sort of a
canonical uh trick
in graph theory okay so let's uh let's
follow the
the toucan sam approach here we're gonna
follow our nose
and say that okay there's basically a
graph
that's uh staring us in the face in this
problem
but then we're gonna have to make a
little bit of an edit because we'd like
to use
the kind of linear looking time search
uh that that bfs
affords us but it looks like we have
edge weights in our graph right because
the wires
are associated to uh lengths right
different wires have different sizes
but we have this nice fun fact which is
of the total amount of wire and our
whole universe is less than 100r
i guess the units of this 100 are kind
of weird right it's like feet per router
or something but
whatever okay uh so in particular uh i'm
going to make a graph
with a node per
router right so maybe here's a router
there's another router there's router
one and router two but since i want to
use the sort of linear time advantages
of breath first search
uh when i'm when i'm computing distances
i can be a little bit sneaky about this
which is to say instead of having like
10 feet of wires
i'm going to have 10 one foot wires yeah
except now i'm additionally going to
have you know
little chains so here maybe the length
l one two is equal to three right so i'm
gonna put
three edges in between um so in other
words
and i'm gonna i'm gonna connect them
with chains
of l i
edges for each wire
that makes sense so essentially i'm
going to take my weighted graph problem
and make it
unweighted by just like repeating a
bunch of well not really repeating but
chaining together a bunch of edges
uh so that the total length of this
thing uh is equal to the distance from
one router to another
okay one thing we might as well do is
bound the number of vertices and edges
in our graph when we do that
so first of all
let's think about the number of vertices
and we can be totally lazy and upper
bound this stuff it doesn't matter
well for one thing i have one node per
router so we incur one factor of
r there and now
notice that we're kind of laying down
cable one little piece at a time here in
our chains
and now i always uh tend to have a fence
post style
headache about exactly what the constant
factor is here but if we're conservative
about it
uh you know we incur at most a factor of
100 are
kind of additional edges because those
are all the different pieces that we
could lay together
it's actually less than that because of
the endpoints but whatever
uh because r plus 100r is big o
of r so the number of vertices in my
graph here is big o of r
similarly what's the number of edges
well this is exactly the amount of cable
uh that's inside of my network
i believe yep right so this is exactly
100r
well i guess the way the problem is
written it's uh upper bounded by a 100r
but whatever
um so this again is big o of
r this is kind of convenient so now we
have one number that rules them all
right which is r which tells you both
the number of vertices and the number of
edges
up to a constant factor right so one
thing i can convince myself is if i do
bfs on my graph that's sort of okay
remember that's
vertices plus edges time uh but in this
case uh those are the same
okay so uh right so remember at the end
of the day i'm trying to compute the
latency
this is like the length of the shortest
path
to the entry point nodes
so here would be a braindead algorithm
which is to say
for all routers
for all entry points
you know compute
i don't know let's call the router on i
the entry point j
i compute distance i j like using
breadth first search or something
uh and then i you know uh
you know take them the men of these
values um
and add them all together right so i
compute
for every router i look at every
possible entry point i compute its
distance to the entry point
i take the min over all these things and
now i add that to my running cell
there's a problem here which is i
haven't told you the relative number of
entry points to the total number of
routers
so at least the way that i've i've
written this algorithm here
how much time would this take well
there's two different for loops
and in the worst possible case at least
in my brain diet algorithm i don't
notice that
you know if i am an entry point then i
don't need to compute distances
well this would take order r squared
whoa r squared time right um
at least right actually i shouldn't even
write big o i should write
uh what's slower bound oh god i'm a
terrible algorithm professor
omega of r squared
time because i haven't even accounted
for the amount of time that it takes to
compute the distance
right uh and this is a problem because
i've only given you a budget of linear
time for your algorithm right so
so this is this is frowny face i tried
drawing the turret emoji on my notes and
it really it didn't work
okay so we need a better trick
uh and this is actually sort of one of
these proto-typical uh
uh tricks uh which is uh to do the
following
so let's construct a graph i'm gonna
draw my graph in a particular way
but notice that there's nothing about my
algorithm that cares about the way that
i drew it this is just to make my life
easier
which is i'm going to put all the entry
points on the left and all the
just the remaining non-entry point
routers on the right
because i can uh and so this is what my
graph looks like so these are like my
entry points
you know here are my other routers
my graph doesn't have to be bipartite
like it could be that my routers are
connected to each other
whatever um and then there's some some
you know
edges that go from my entry points to
the routers in the graph
trying to make sure that my graph is
connected okay
right and so essentially what this
problem is asking you to do uh is to say
okay for every single note in my graph
i need to compute the the distance to
the closest
entry point and then sum all those
things together
right that's the schematic we could have
in mind
so in some sense
what we want to do is think about the
set of entry points as like one
giant node right because it doesn't
matter which of
these guys i choose for my shortest path
uh to an entry point i just need to find
one
yeah and so here's the basic trick and
this is one that appears
all over graph theory which is i'm going
to introduce one additional note to my
graph
and i'm going to put him on the left
hand side he's really big because he
is a super note
which is a term of art uh this term
shows up a lot
and i'm gonna connect it to every
entry point in uh in my my network of
routers
does that make sense class okay
so here's the here's the kind of cool
thing so first of all for every entry
point
what's the the shortest path from the
entry point to the super node
well obviously it has length one right i
drew it for you here
now here's the thing let's take the
shortest path from the super node
to any of the routers on the right hand
side
what do i know well clearly like maybe i
choose this guy here
well what is my shortest path it goes
here and then there
there's one property that matters here
which is that it has to pass through
one of these entry notes which one does
it has to pass through
shrek for shame well remember
uh the justin's favorite inequality is
the triangle inequality
and what does it say it says that if i
compute the shortest path
from the super node to any node in my
graph
then every sort of sub piece of that
shortest path
is also a shortest path that sentence
was hard to parse
let's try that again so in particular if
i have a graph from the super node to
some router over here
well we've convinced ourselves it has to
pass through one of the entry nodes
which one does it have to pass through
is it ever something that is farther
than the closest entry node
well no because i could compute a
shorter path in that case
by choosing the closest entry mode and
then going to the super node
so uh this is a complicated way of
saying that essentially what we really
want
is for every router
the distance from that router let's call
it i
to the super node s
is that quite right is that the distance
to the closest uh entry point
one you went one more inch too far i
went one inch too far right because i
went to the closest entry point
and then i took an additional edge so we
want to do minus one
okay so what does this mean well that
means that i don't
actually have to have this inner for
loop over all the possible entry points
i just need to construct this new
special graph with one additional node
notice that's not going to affect my
runtime
and compute the shortest distance from
the super node to every other node in my
graph
and then use that as my output yeah so
in other words
what is my algorithm going to look like
well first
i'm going to construct
my graph right so what do i need to do i
have uh if i were to write this out on
my homework i would have to talk about
how
i've got these chains of edges between
different pairs of routers
in addition to that i'm going to make
one additional super node uh
and and insert an edge from that to
every uh entry point
uh notice that adding the uh
entry point here just adds a one to the
number of vertices
and at most i guess an r to the number
of edges which doesn't affect
asymptotically the size of either of
these two sets so that's a good thing
now i'm going to do
i'm going to use a bff
to do a single
source shortest path from
my super node to
all other vertices
and how much time does this take well
remember that in general bfs takes v
plus e time in this case v plus e are
both
you know look like r so this is order r
time
okay uh and then finally
i'm going to sum over
router's
i the value of the distance
from the super node to the router i
minus one to account for that that
additional edge that i added
okay and that's the solution to our
problem
okay any questions about uh number two
here
excellent go team okay so now uh let's
move on to problem three
am i yeah we're about halfway uh okay
so in problem three right so we're doing
um
poetry harder and three wizard friends
the number three here i believe is
actually irrelevant um
although like anytime you see a specific
number in a problem like you should you
know
cash that in your bag of things to
remember and in this case that was a
that was a red herring um padre harder
and um her three wizard friends uh
are tasked with searching around a
labyrinth yeah
uh and and in particular uh there's some
some some nice things to know about
the labyrinth and patri-harder world
which has really thrown off my dyslexia
here
which is the following um
right so what do we know we know that
there are
n rooms uh in my labyrinth
uh and that each of my rooms uh
has at most four doors
okay um so in other words uh if i think
of building a graph
out of my rooms which is like i don't
think i'm giving much away about
about this problem by like jumping to
the solution a little bit uh
what do we know about the degree of any
vertex assuming my vertices are rooms in
the labyrinth
is it most four so that's kind of nice
uh okay
right uh and all the doors start closed
so that seems like a useful piece of
information to remember
um but we have this kind of weird thing
which is that
some doors
are enchanted
and apparently uh pop oh my
uh pottery harder uh can open up
uh certain doors for free which are not
the enchanted doors
and then other ones they have to like
you know do the blessing and the holy
water and whatever it is that
that happens in in in this universe uh
and then opens up that door
um but that costs them materials and and
um heartache
right and so we wanted to minimize that
right and so what they're given
is basically a map right and this
includes all of the different rooms
how they're connected to one another and
which of the doors are enchanted
and what i want
is the minimum number of doors that they
have to
disenchant
okay now this problem is like kind of
sneaky
uh and and the reason why is that
there's like the the network that's
obvious to build
uh and that turns out to be not quite
the right one and then you can start
thinking about adding weights on your
graph and going crazy with that but that
turns out not to be the right direction
and in fact in poetry harder world um
apparently we're not worried about their
physical fitness
in other words like shortest paths are
actually irrelevant in this problem
do you see that because like let's say
that i have
a really complicated uh
annoying problem so like you know maybe
i have you know here's
my labyrinth
and um no we don't even talk about the
entry point like where they actually go
in
but just for for fiction purposes let's
say that they enter my labyrinth here
uh and that just to be annoying the two
doors that are enchanted remember we
could make a graph where all the
vertices or rooms and the edges are
doors
are like at these two endpoints of the t
so i have a giant t and i enter right in
the middle
now what is what is patri harder to do
here
well obviously there's like since this
graph is a tree there's only so much
they can do right they
maybe they they they enter here they
walk over all the way to the end
to disenchant the door over here uh and
then they turn around
they walk to the other end they
disenchant that guy
yep and now they can reach uh other
rooms
um yeah because that's their goal is to
visit every room sorry i think i skipped
that step
now there's a few things to notice about
this example which make it a little bit
different
from the typical graph theory thing
which is once
they disenchant this door right they
walk over here and they open it
well now they walk over to this other
room just to you know it's like
you know those gym exercises you like
run to the other side of the room you
like touch the floor and then you run
back
that's kind of what they did here right
they ran to the this room they tap that
vertex and now they want to turn around
and walk to the other side
they don't pay money again on their way
out right so once they open that door
it stays open right and and that's
actually quite important
um because this uh what it does is it
makes this problem not look like a
traveling salesman problem which
wouldn't be so great
um okay so right and moreover
does the fact that they're like maybe i
suffered by these edges i have a bunch
of edges here that are all not enchanted
does that matter like if i had like five
billion edges
here no right because they only ask in
this problem for the minimum
uh number of doors that you have to
disenchant
yeah so it might be the the harry harry
harder walks really far along my graph
but as long as they don't walk through
an enchanted door it costs them nothing
so what does that mean well that means
that like in some sense the second that
i enter a room
i might as well walk to every other room
that it's connected to
through unenchanted doors and that
doesn't cost me anything
right so sort of as a policy uh i should
do that right i
enter a room and then i kind of just
search around and enter every possible
door that i can that doesn't cost me an
enchantment
because those are free and and my goal
is to visit every room
yeah okay so here's going to be the
sneaky trick
like what is that starting to smell like
right i open a door and i want to
explore all the other rooms that are
that are connected to that one connected
component
yeah maybe a connected component there's
a problem is it connected component in
this graph
well no like this whole graph is one
giant connected component
so the sneaky trick is we're actually
going to remove the enchanted doors
that was supposed to erase and it didn't
happen um but
the the point is that if we remove the
connected doors these are like the
chunks of my map that i can visit
without incurring any cost
right so if i think of my graph maybe
there's like a bunch of vertices over
here
and then there's an enchanted door and
there's a bunch of vertices over here
and then like two more enchanted doors
like that and like what goes on in here
like if this is like a giant triangle or
something
it's actually irrelevant because once i
touch any one of these i can now
touch all the rest of them so that
suggests an algorithm
so our first step is to be
construct
a graph g where the nodes are the rooms
are the rooms
and what should the edges be well if i'm
just trying to find these like little
clumps
of rooms that i can visit for free if i
get to any one of them
then the edges
are the non-enchanted doors
okay and so now uh
in step two i'm gonna compute my
number my connected components which we
covered in lecture
uh the connected components of my graph
g
how much time does that take well
remember that there are two different
algorithms we mentioned that can do this
this is full b f
s or d f s
and both of them are going to take the
same amount of time right what is that
time
linear in the size of the graph okay so
initially
right that could be problematic because
i want order n remember their
uh n rooms here but
thanks to our degree bound thanks to
knowing that every room has at most four
doors
you can convince yourself that both the
number of vertices and the number of
edges are order n
which i should probably rush through
because as usual i'm going slowly
okay so now what do i have i have a list
of all the connected components in my
graph
and each one is potentially connected to
some other ones
by enchanted doors so in some sense
i could think about this not to say the
solution to the problem but i could
think about modeling my problem as
making some new graph
or like i put a giant vertex and every
connected component
and maybe i connect them by enchanted
doors and i want a path
that touches every one of these rooms
but that's not quite the right way to go
uh and and this is what what catches by
the surprise because this starts
sounding scary right if you've heard of
the traveling salesman problem it like
kind of smells like that
but that's not actually correct here uh
for two reasons one is that once i
open an enchanted door i can go back
through it like i can like
hopscotch back and forth through that
door as many times i want and it doesn't
cost me anything
only cost me something the first time i
open it
yeah and
[Music]
moreover i didn't ask you to actually
compute me that
path if you read the problem closely it
just asks for the minimum
number of doors you have to open so this
is a really sneaky problem
because it turns out there's additional
one line of code that solves this
problem that's step three which i'm
going to write
before steps one and two just to keep
you confused and that is
to return this
number of connected components
minus one
that seems sneaky why is that well
what's going on here
uh is the following um which is the
let's say that i walk along remember
that my graph is connected so what i
know
is that i can always get from any one
connected component to any other
right and so let's just take whatever
ordering
notice that the problem hasn't actually
actually asked me how to
return an efficient path it just asked
me for the minimum number of doors i
have to open
so all i have to do is convince myself
there exists a path with this many doors
i have to open i don't have to actually
return it
if i did it would be mildly more
annoying to think about
okay so my graph is connected
so one thing that i could do is make the
worlds
like well
how do i want to do this
well let's see here i guess i could i
could come up with an
ordering um that looks like depth first
search of my graph that should do it
okay so maybe i started this guy i just
started some arbitrary
vertex i'm going to do depth first
search
but rather than on the full graph on
this kind of metagraph where i've
clumped together
rooms that i can get to with no cost
right so what i'm going to do i'm going
to start walking outward toward this guy
and then it doesn't research
backtracking and then going back down
and if you think about it remember that
you know in depth research i have this
property i never need to
revisit a clump once i've got to it once
well the total number of doors that i'm
going to open is exactly the number of
connected components minus one because
as soon as i've done that my death first
search is is done here
yeah uh in other words that's the number
of of nodes in my graph
so if i took what would be a better way
to to i'm noticing that in my head this
was easier to articulate than in words
um
there'll be a way to do it uh would be
uh
maybe add some more enchanted doors to
the ground maybe add some more
enchantment
ah that's true actually my problem is a
little too easy
so as long as my back my death first
search backtracks along the path that's
already found
then i'm sort of reaching out into this
tentacle and then reaching back and then
reaching to a new place
i'll never traverse an enchanted door
that i don't need to
uh because i've already already seen the
location
um is your traversing tree yeah yeah so
i've got a shortest path tree that's
going on here actually i guess a breath
first search would be a better example
um in fact here's okay let's be concrete
about i'm sorry
i should have thought about this more
carefully than i did at home yesterday
um
one thing i could do would be to compute
a shortest path tree from one vertex in
this graph
to all the other ones in particular that
gives me the the shortest path
and i could traverse that tree to one
node and then turn this
all the way back and then traverse it to
a new node and then traverse it all the
way back
and so on this is not an efficient path
from a walking perspective
but from a door opening perspective it's
extremely efficient because it's a tree
right
and remember that the number of edges in
a spanning tree of my graph
is exactly a number of
vertices in my graph minus one which is
exactly
the property we have here sweating for a
second there
okay so now in our remaining uh 30
minutes here
we've got two more problems which is
more than enough time
especially because the last problem is
is largely combinatorial and less
algorithmic so
i think it's okay to focus maybe talk
about that at a high level
um and show a fun plot okay so for
problem four
uh we have an airline uh purity atlantic
uh that's that's cute uh jason really um
and it's owned by
richard ranson did i get that right
uh and purity atlantic uh has a cute uh
sale this is not like a cute
angle i suppose um which is uh
essentially the following which is that
you can book an itinerary
where you have your home city and then
you choose i believe
three other cities that you want to
visit
and then purity atlantic um you know
maybe you're on your honeymoon and
you're not concerned with price
uh but rather just the efficiency
because you don't want to spend your
whole time in an airplane that's
particularly true this month uh then
what do you want to do you want to
minimize your total number of
connections
right because as we all know in um
spring 2020 we don't want to spend very
much time in airports
yeah uh so right uh
so how do we do that well you know we
make a website where
you tell purity atlantic the cities that
you want to visit in your home city and
they give you back
an efficient itinerary that minimizes
the number of connections
okay and the question uh is how do you
actually do that right
how do you um compute the the best
itinerary uh that minimizes the number
of flights you have to take
so what are our variables and sometimes
it feels like the variables are all the
different permutations of the cities you
could visit right i could like go to
i don't know cambridge uh boston and
then cambridge
in the uk maybe you're doing like a
university thing and then yeah i don't
know budapest and some other place or
you do those in any other order
um and that feels like it should be
factorial which would be bad
news but this is one of these problems
which um i suppose a
computer science theorist might call
fixed parameter tractable but that's
sort of an overkill
uh term here but essentially as long as
you ignore all the factors that make
this problem hard then it's then it's
easy
um a different way to put it is that uh
okay if i'm only visiting three cities
what's the total number of possible
orderings of my
my my three cities
class so i have city a
b c i could do b c a i could do b a c
listen up yeah fine jason
uh i'll do that so
this is what we call direct proof
mathematically uh which are all the
possible ways
um to visit three cities
and now by my direct uh proof i claim
there are no other ways to visit three
cities
uh and in particular there are one two
three four five six
uh different orderings of the cities
that i can visit
notice that this is a constant in my
problem i am not asking you
to make a website that takes like the
total set of cities that you want to
visit as a couple and order them it's
specifically three
you might also notice that six is three
factorial
uh which is perhaps a more efficient way
to get to that same balance
okay so right so there's there's six
different orderings of the cities
and in each case uh what am i going to
have to do i'm going to have to
compute the sum of going from my source
city to city the first one
from the first one to the second one
from the second one to the third one the
third one back to the first one
okay so
what do i need well i need in some sense
i want to be conservative about it just
the cost of flying from
every city to every other city but
that's not quite right
i only need the cost of flying from
every city that you have specified as a
city you're interested in
to every other city that you specified
that you're interested in yeah
okay so in particular i go to my new one
um right so in this problem we have c
cities
and f flights
yeah um okay and initially it might
seem that we have to compute a ton of
shortest paths but like if i want to go
from boston to
budapest to london to i'm running out of
cities paris and back to boston or
whatever ordering i prefer
do i need to worry about the shortest
path
from you know nebraska to california
potentially not right like that could be
relevant the only ones that i care about
are those four cities that i've
identified okay
um so there's there's three factorial
possible
permutations at the end of the day
well there's two times four choose
two um if you're wondering this is
12 or big o of one pairs
of cities um meaning that like
uh uh for
uh itinerary purposes itinerary
okay meaning that uh if i always
enter an airport in one of city abc or
my hometown
and i always exit through another one so
then there's four possible cities i
choose them two at a time
notice that flights might not be ordered
like i might be able to get from one
city to another but then maybe the
airplane
has a connection or something so going
back is a different cost but
totally there's there's two times four
choose two uh different pairs of cities
that i could enter
exit from okay
so now what am i going to do well
so i can compute the 12 different
shortest paths
that matter in my my graph so when i say
shortest path what do i mean
well i'm going to construct a graph
g with one vertex
per city right and
one edge
per flight
and notice the the number of connections
that i need to make
the minimum number between any city and
any other city
is equal to the shortest path the length
of the shortest path minus one
right so like maybe i have you know like
here's boston
here's london here's paris
b l p for short
right then the length of my shortest
path
is two and the number of connections i
have to make is one because i stopped
through london
yeah so what am i going to do
well for every pair of cities
um in in this uh oops
no that's okay
uh in the set of the source city and the
three
cities you want to visit i'm going to
compute
the shortest the length of the shortest
path right so this is the
minimum number of connections i need to
get from any one of these to any other
one
uh in my graph g
well how much time does this take well
there's 12 such pairs we already argued
that
right and how much time uh does it take
to uh
actually do a shortest path say using
breath first search
linear time the size of the graph i
think jason actually has a t-shirt that
says that
um well in this case remember that's big
o of the number of edges plus the number
of vertices but just to make your life
a little more annoying the number of
vertices is the number of cities
the number of edges the number of
flights right so this takes
12 times o c plus f
time which of course is just o of c
plus f time notice this is one of these
things where we're being sneaky we
told you that you specifically visit
three places
and that's where this number 12 came
from right if we'd said that you wanted
to visit
m cities then this would be a very
different homework problem
this is one of those things you got to
remember right where we've given you a
few constants and you should use them
okay so now uh
what can i do i can iterate
over every
permutation of
a b c
right so this is like saying i go from
my source
to city 1 to city 2 to city 3
back to my source right i
add together
and compute the cost
the cost of that trip and remember cost
in this case is equal to the minimum
number of connections
and then i return the minimizer
so i say like is it cheaper for me to go
boston budapest to paris
boston paris budapest and so on so a for
loop over permutations which generally
is frowned upon
but in this case because we told you
you're visiting precisely three places
how many steps are going to happen in
that for loop
well we actually wrote them all out over
here on our board
it's exactly three factorial or six
steps
right three times two times one which is
6.
okay so right so at the end of the day
this for loop is going to take
well order 6 time
which of course uh is just order one so
it doesn't really contribute to our
runtime at all
and our entire algorithm runs in
c plus f time okay so uh
right so this is one of these problems
where you're really taking advantage of
the constants that we gave you we said
you're visiting
three cities so use it incidentally as a
computer science theorist if i said
you're visiting exactly 17 cities
well what would be our our numbers now i
mean there would be 17 factorial and
then
like 17 choose 2. those are big numbers
but they're still constants so for
purposes of this class
that would be okay but the second that i
gave it a name like
m then i got to think about those
factorial
things a little more carefully all right
um so that's this problem so so the
basic trick here
um was that like yeah it looks like all
pairs shortest path
but it's not quite it's all pairs of
things that you're actually going to
travel between shortest path
and since that number of pairs is finite
this is 12 that's that's an okay thing
to do
okay how are we doing
about 15 minutes perfect i didn't want
to do the last problem and i think i've
managed to
get myself in exactly that position okay
so
the very last problem on this homework
which again this homework really follows
the prototypical 6006
breath first search depth research
homework i feel like they all fall into
a similar pattern
again we all these resources are
available to you guys you should look at
them the uh
you know we're not trying to hide
anything um this problem involves uh
solving a pocket cube
which is like a little mini rubik's cube
which is two by two
um and and it looks like this uh
ah there's actually
here we go right so here's my rubik's
cube
looks like a cube which i'm having some
trouble drawing
uh uh and in particular it's two by two
uh which makes it a little easier than
your typical rubik's cube
okay um and in particular we're gonna
mark
uh some faces sneakily they used a
little geometry term here which is cute
so here's face f0 i'm sorry you can't
quite see that but
the top face is f zero case we were
wondering uh the left face
which is f one and the front facing
face here f two
notice that we've identified these by
like vectors that point ninety degrees
out from the face these are called
normal vectors
if you want to define those rigorously
you can take my my grad level class
but for a rubik's cube it's not terribly
difficult uh but in any event um
i can talk about flipping this rubik's
cube in a pretty easy way right which is
that i like i'm gonna
fix one corner of my cube so this is
like the corner that i'm holding onto
with my hands
and now i can grab what the top
the side or the front of my cube and i
can rotate it
clockwise or counterclockwise you can
convince yourself those are all the
possible ways that i could uh sort of
mess with the state of my cube
after fixing one corner okay
uh right and so this problem basically
is involving
um sort of a very typical trick in fact
a lot of the history of
these different search algorithms
breadth for search death for search
a-star which i guess we won't really
cover
here um date back to
what 20-30 years ago we would have
called artificial intelligence um these
days that has a very different
meaning but back in the day ai was all
about like solving
board games and you know rubik's cubes
and all these kinds of things
uh using algorithms right and the way
that they would do that is by searching
the different spaces of configurations
right so now
uh if we think of every face of this
cube as painted with a color
right there are different configurations
of my graph that i get by like flipping
the three sides
right so if we think of there being a
vertex
for each state
of my cube where state here means like
the coloring of every
face on my my rabix cube then there's an
edge
for every move
and in this problem we encoded a move as
a pair j
comma s where it's saying that i'm going
to
rotate face f
j where j is between i get 0 1 and 2
in direction s
and we can just index that as like plus
or minus one
to kind of say counterclockwise or
clockwise right
and so this is kind of a cute thing
right where your graph
has a bunch of vertices which are all
rubix cubes
that's cube and then their edges if i
can get from one to another by doing one
of these moves
and this is a nice abstraction because
if i want to solve a rubik's cube
in the most efficient way possible one
way to do that is to compute the
shortest path
from my current configuration to
the you know the platonic rubik's cube
right where all the colors
are constant on the different uh faces
of my cube yeah and so that's like a
sort of basic uh
identification that happens all over the
place in search strategies
where like i'm going to think of every
vertex of my graph as being the state of
some system
and every edge as being a transition
from one to another
and then paths in this thing are kind of
like different ways of solving my puzzle
right so like
a different one would be you know i
don't know every vertex
is a chess board with the pieces the
chess pieces scattered on the chessboard
and every edge is one chess move by one
player or the other
in that case you have to be a little
careful because you want player one or
player two to go back and forth from
each other but i'll let you think about
the reduction there
okay so uh right this problem
i think largely is mostly just fun like
combinatorics rather than algorithms but
there's a lot of algorithms hiding in
here
um so they want you to argue that the
number of distinct configurations of
this rubik's cube this two by two guy
is less than 12 million this is nice
because 12 million is a number that
computers can actually
cope with um and so there's a pretty
straightforward uh argument there
[Applause]
right uh so in particular um
here's a cube how many corners are in a
cube
eight thanks i i hid one back here
in case you're wondering so uh let's say
that i i
fix the corner of the cube like we've
done that right then
every time that i rotate one of the
faces of my cube clockwise or
counterclockwise
i'm essentially like taking one corner
of my cube and like sticking it in
another place
right so in all seven
corners of my cube can move
and if i'm not worried about like you
know it could be that like some of these
permutations are not actually achievable
by a set of steps like maybe i'd have to
break my rubik's cube and glue it back
together
but if i'm being conservative about it
there's of course
less than or equal to seven factorial
different configurations of the corners
right so in other words every time i
rotate my face one of the corners ends
up in a different place
so there's seven factorial different
ways that that could have happened
okay so that's part of my bound remember
that i'm trying to bound the total
number of configurations here
and essentially what i've done so far is
i've said okay
well there's a bunch of cubes in my 2x2
rubik's cube so i'm gonna
like unglue this entire cube take just
this corner
and stick it up here and there's like
seven factorial different ways that i
could do that
but i still have to account for the fact
that i pull this piece off i stick it in
the top
but i have to figure out his orientation
i can still rotate it
about this corner and in fact there are
three different ways that i could rotate
it
right you can kind of you can see it
right one two
three yeah so in all
so each corner
can rotate
three ways so
that means that i have three times seven
factorial
uh different configurations as an upper
bound
and this number is wait for it
one one oh two two four
eight oh um the problem asks you to
argue that
your upper bound is upper bounded by 12
million and indeed
it is less than or equal to 12 million
is that three times seven factorial or
oh i'm sorry um right because there are
seven corners
each of which can rotate three different
ways it's actually three to the seventh
power
times seven factorial thank you student
um okay right so
uh let's see here really quickly move in
here the next problem says
state the maximum and minimum degree of
any vertex in my graph
first of all do i expect vertices to
have different degrees this is kind of a
goofy problem
like what would it mean to have a vertex
the the somehow has
lower degree than another vertex would
mean that there's some configuration of
this cube
for which there are fewer moves that i
could do to change it than a different
configuration of this cube and that's
like obviously not the case right
because when i
when i flip one of the the faces of my
cube
all i'm doing is i'm moving the colors
around i haven't like somehow changed
the physics of how rubik's cube works
right and so uh
i think this was just intended to be
annoying by your instructors the the min
degree
is equal to the max degree
and in fact the degree of every node in
my graph is
constant here the one thing that's worth
noting here what i haven't argued
it turns out i think to be true but what
i haven't argued is that like i couldn't
rotate a face and actually end up in the
same configuration like maybe for some
reason i have like
red all the way around the outside so
when i rotate it nothing changed
that obviously isn't true but i haven't
argued it carefully but as long as i
don't worry about my graph being simple
like i'm okay with self loops
then the degree is certainly uh constant
yeah
okay and in fact i don't think that can
that can happen on a typical rubik's
cube well i think the point is to
say how what the degree was oh yeah
indeed though
so we haven't computed the degree but
we've argued that they're equal to one
another
okay so now we actually have to compute
what that degree is um
and here's how to do it so of course uh
well this i think is actually even
easier than than the first part
essentially remember we have three
different options for faces that i can
rotate i can work it at the top
the front or the side here right so
there's
uh three faces
that we could rotate uh
okay and how many different ways can i
rotate them i can rotate them
counterclockwise or clockwise
so there's two directions so in all
there's degree six for every vertex
right there's six different ways
um in or out of a vertex here
okay so the next part of the problem
gives you a piece of code
and then does breadth first search on
this uh this graph
and it's super super slow to give me the
distance to all the other configurations
and jason conveniently has run it on his
laptop here
i don't i'm nervous to touch your laptop
i
i don't care so much but i don't you
know i i don't want to infect here
yeah right
so we have a piece of code that um
explores the graph of all the
configurations of our cube
um by breadth first search and then sort
of gives me the
shortest path i think from the base cube
uh where all the faces are constant to
all the other configurations that are
reachable
and generates a plot uh
right and so what they ask is to um
figure out the total number of
configurations that explores uh one
thing that you'll find out
um center
down uh is that uh it
explores pretty much a third in fact
exactly a third of all the possible
configurations of my cube
i think we can see that here
um so i guess uh it runs this whole
thing you sell them all together
um right oops
that's okay um and so in fact uh the
kind of fun fact that you can learn
about the two by two by two rubik's cube
is that uh there's actually three
connected components
in this graph so in other words there's
sort of like
three different rubik's cubes you can
make modulo all the different flips that
you can do to the uh
to the faces and those correspond to
three corner rotations of one of the
corners of the thing
okay so uh
right so then the the next part of the
problem asks you to state the maximum
number of moves needed to
solve any rubik's cube and you can see
it in this plot so what this plot is
showing you
is the size of the level set of this uh
this distance uh
function for for every distance so
i think technically it looks like zero
but it's actually this is at a one here
we just say there's one uh vertex at
distance zero which is the source
right and as we move farther and farther
out our tree is expanding and we're
seeing more and more vertices
apparently most vertices are
approximately distance what is that 11
or 12
uh 11 away from the original
then eventually i explore the entire
graph and i'm done and you can see that
the farthest away vertex
is 14 away meaning that the most
annoying rubik's cube to solve can be
solved in 14
steps for the two by two by two uh
pocket cube
i'm sure that jason probably knows that
the the equivalent of this number for
the three by three by three but i have
no idea what it is
um i'm impressed if he can calculate in
his head like he looks like he was about
to try
uh but i digress uh right so in other
words um this is actually a fancy term
for uh uh you know we talked about the
radius of your graph in the first
problem now we've got the diameter which
is
well not necessarily two times the
radius the way that we've defined it
here but but actually
almost um uh i think within some
constant of that
okay so uh right so
notice that the vertical axis here is
really big
and this is explaining why this bfs code
is so slow right because these are
all the different configurations it has
to hit um or more accurately if i take
the y
position of each one of these vertices
and sum up its height those are all the
configurations that are reachable
and those are all the steps that bfs
needs before it's done right and so that
number is in the
[Music]
certainly in the millions yeah okay so
then the last part of this problem which
it
conveniently looks like i'm low on time
to solve but i'll refer you to the
solution anyway
is asking how we might do this faster
and so in particular what it says is uh
let's say that i have a total of n
configurations
for my rubik's cube in this case it
turns out that that's like roughly 3
million i think
okay and now i want an algorithm
that gives me the shortest sequence of
moves to solve any pocket cube
man i'm really ravaging the chalk today
um and i want to solve any cube uh
in a number of steps that looks like
to n to the ceiling
of w over two uh
where um
let's see here the code provides sorry
this problem changed on me this
afternoon
right so uh where n sub i is
equal to the uh number of configurations
reachable within imoves
oh good i see what we did here
right so like if this is my base cube
then we've got like maybe
like a six different one two three four
five
six different cubes that i can reach
from those and then there's six cubes i
can reach from all of those
but of course some of those might be
pointing backward um or to each other
but this is the number of things that
are reachable in eye moves and they ask
for an algorithm that finds the shortest
path
in this amount of time by the way big n
typically exponentiates in that
subscript there
this looks innocent but it's not um
the basic trick here uh is to do
i'm not gonna bother writing it down
we'll just talk about it for a second
and call it for the day
no i'll draw a picture so the breadth
first search algorithm that we've
thought about so far
chooses a vertex and then computes level
sets
outward from that vertex until it maybe
reaches
the destination uh that you want to hit
that doesn't quite work here and the
well i mean it does work but it's going
to be quite slow
because like let's say i had bad luck
and i were in that 14 vertex
right then somewhere in there i'm going
to hit this big height
which is sitting over the 11 before i
can get to
vertex 14. so the trick here is it turns
out that i can do it by only ever
getting to 7. and the way that i'm gonna
do that
is instead i'm gonna run bfs
sort of in parallel for two different
vertices right the source and the target
so in this case my
current cube and the cube i would like
it to be like the solution to the
problem
i'm first going to compute the level set
one of that cube
then level set one of the next cube
level set two
level set two three three and notice
that eventually they're going to
intersect pretty much right at the
midpoint
and so the size of the level set i never
need to compute a level set that's
bigger than a half of the shortest path
uh length i have to round up to be
conservative about that
and and that's where i get this factor
here so this is a nice little trick for
for reducing the search size
this is another kind of standard trick
if you look at some of the uh code
people use for for solving board games
algorithmically and so on i think they
typically
uh sort of search from the beginning and
end state outward to
and try and meet in the middle uh for
exactly this reason which is that
exponential growth uh as we all know can
be
quite problematic all right folks so i
think we're just about out of time and
i've certainly worn myself out
uh so with that hopefully we'll see you
next week and uh
yeah i hope everybody's doing well