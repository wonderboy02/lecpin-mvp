All right. Welcome everybody.
Everyone ready for the quiz? Quiz next
week? Yes. I hope you all are here
because you know that there's a quiz
next week. Okay. So, what is this quiz
about? It's about what we've talked
about so far in this class, of course.
What is this class about? Someone
remember from my first lecture? What is
this class about? What are we trying to
test you in this class? Algorithms.
Algorithms. Great. Also, data
structures, right? That's what the first
part of this is. But really, it's to get
you to solve computational problems.
That's the first thing. Be able to argue
to someone else that that you actually
did solve it, right? It's correct,
right? That you chose something that's
better than other things, that it's
efficient, right? and that you can
communicate those things to other
people, right? Those are my big four
that I try to get you guys to
internalize. And so that's what our
quizzes are going to try to evaluate you
on. Okay? And so, uh, aside from kind of
some mechan this nitty-gritty kind of
stuff that we do at the beginning of the
term like, uh, talking about our model
of computation, right? our model and
like asytoics
as
simpics.
Is that right?
Uh recurrences, right?
Aside from these kind of basics, we kind
of delve straight into algorithms,
right? Uh these are kind of like uh you
know almost definitions. We don't rely
on these things very much. I mean we
rely on these things all the time but
it's kind of the mathematics that we use
to talk about things right we how can we
even say how long this stuff takes
unless we can reason we can abstract
away that this stuff is not on a real
computer this is kind of in our minds in
a computer and we're reasoning about
these things based on the number of
constant time operations this magical
computer might have so that you know
which is a pretty good representation of
any of the computers you have right for
certain assumptions right we're not
going I mean there's not a lot of
problems set questions. We had you talk
about
uh these things like specifically
usually they were part of some other
problem, right? You you had to describe
the running time of this thing and you
might have had to solve a recurrence and
you might use master theorem, that kind
of thing, right? Or you use asmtotics
all the time or you need to remember in
our model, oh, it kind of matters how
big of an integer I can store and do
arithmetic on in constant time, right?
So for that pet 3 question you had at
the end of your the coding question,
right? Uh you you wanted to hash things
and you want you need to argue that
those things fit in a constant number of
words so that it that could be done in
constant time. A lot of you guys found
canonicalizations basically mapping to
things that were exponentially large.
So may maybe multiplying a product of
primes or something like that and that
would not be a good representation.
Okay. So the these things come up but
they're not like the main focus of the
problems we solve. What are the main
focus of the how do we solve a
computational problem in this class? I
kind of gave you two ways at the
beginning of the term. Do you guys
remember
we can solve how to how to solve
a computational computational
problem?
One's the hard way, one's the easy way.
Force. Brute force. Okay. So you're
describing to me a technique for making
your own algorithm, right? I can just,
you know, design my new algorithm from
scratch. One way I could do that is
brute force it, right? Look at all the
possible outputs and see which one
works, right? Or I could reduce to
something like divide and conquer or
something like that. That's generally a
hard thing to do to make your own
algorithm, right? That's why we don't
ask you to do it a lot in this class,
right? It's an 046 kind of thing, right?
So the first thing you could do is write
design
new
algorithm from
scratch. Usually it's not from scratch,
right? Usually you're reducing to some
kind of algorithmic design paradigm that
you've maybe heard of. You talk a lot
more about it in 046 and at the end of
this term when we talk about dynamic
programming, but generally that's a hard
thing to do, right? B you're you're
trying to think of a recursive
algorithm, right? You're trying to prove
that it's correct. All these
nitty-gritty. We we've actually
throughout the class in lectures have
been showing you the algorithms, but
we're not really expecting you to make
those algorithms. What are we expecting
you to do most of the time? Yeah. To
reduce it to a problem that we showed
you how to solve, right?
I'm going to say thing here, but really
what I mean is an algorithm that we've
taught you to basically here reduce to a
known thing. No to known thing. Uh
usually that means there's a problem or
an interface, right? That that we've
given you. And in general, we've shown
you multiple different ways to solve
that problem, right? Or interface,
right? So we've shown you many ways on
how to sort things right and we've shown
you many ways on how to implement
sequence and set interfaces. Remember uh
and uh a lot of times the the types of
problems that we're asking you to do is
to just use as a blackbox some of the
things that we did but you need as a
programmer as a as a computer scientist
you need to tell me when I should use
what when. Right. Yeah. Could you
clarify what you mean by use as a black
box? Use as a black box. Exactly. Right.
Um, so this is a phrase that I use and a
lot of people in computer science use.
It's basically uh you import a library
into your code, right? What do I have? I
have a kind of an API. I have a way to
interact with that code. I don't
actually know what's going on inside of
that library, right? I'm using it as a
black box. I it's opaque to me. I cannot
look inside what I mean I actually
probably could look inside what their
code is but I'm not going to. The thing
that makes it useful to me is that it
has this useful API that I trust it to
do the things that you told me that it
was going to do, right? And so there's
kind of I'm going to jump around a
little bit here actually because that's
a great question. uh uh so here
I think of there's kind of three
different types of problems that we talk
about that we give you in this class you
might have seen this on the problem set
right I I like to categorize them into
kind of three different categories here
one is you kind of have to understand
the internals of a data structure and
algorithm that we know right you have to
be able to look inside and I don't know
given a node in a balanced binary search
tree, an AVL tree, right? How can I do a
rotation, right? Or how do I do an
insert or uh uh something about the
structure of this thing, a binary heap,
right? Where are the top k things in a
max binary heap which is on your problem
set, right? Those things require me to
very much not blackbox these data
structures. It's a white box, right? I
need to know what's inside of that to
answer that question, right? I need to
know about the internals of that data
structure, right? And there are other
types of problems where it's like, oh, I
don't need to know what the internals of
this data structure is, right? I can
just operate with knowledge of the API,
right? And try to hook it in to the
problem that I need. And that's what I
call a reduction type problem, right?
This is like how does the core material
we presented to you in lecture work,
right? This is like how do I apply that
core material, right? And harder than
both of those things, right? Is what I
might call a modification type of pro. I
mean, these aren't really good names. I
came up with these this morning, right?
But it's trying to get at the the idea
here that it's possible that you kind of
need to know what the API is and you
kind of need to know what's going on
inside to be able to answer the problem.
Things like um adapting a divide and
conquer algorithm, right? or uh making
uh instead of using a dynamic array
that's has extra space on one end maybe
I have to put extra space in the middle
or something like that right I'm
adapting something that was from the
core material it's pretty close but I
have to modify it in some way
augmentation right I have to take the
vanilla set AVL tree that I might have
given you right and put some other
property on the nodes and you need to
tell me how to maintain that right how
how can I compute that subree property
from its children. Does that make sense?
Uh so kind of this is the harder of the
things, right? If you can identify which
one of these a problem that you look at
on an exam fit under, maybe that can
help you kind of conceptualize what
should I use for a reduction type
problem. We're going to talk about this
in a sec second, but a lot of times it's
useful to reduce it to
uh a problem or an interface
rather than an algorithm or a data
structure. What does that mean? Does
if if I can solve the problem by saying
reducing to sorting, right? I can argue
to you that that algorithm is correct. I
just use sorting as a black box. No, it
might not be efficient, right? my choice
of sorting algorithm that I chose
matters right for efficiency but for
correctness it doesn't matter right for
a a data structures problem I might
reduce to using two set data structures
and a sequence data structure or
something like that right but uh
and it will be correct if I reduce it to
those things right I can define the
operations in terms of those those
interfaces
I don't have to make that choice until I
talk about running time, right? Until I
talk about efficiency and the name of
the game on the quiz to get points, we
can't give you points for an incorrect
algorithm, right? Or something that's
pretty close to correct, right? Uh and
we can't give you full points unless the
correct algorithm you give us is
efficient, right? And that you've argued
things like correctness and running time
and things like that, right? like your
algorithm could be correct uh and
efficient but you analyze the running
time incorrectly so we mark your points
off for there or you you mo most of the
time what you do is you present us with
an inefficient algorithm and then you
analyze the running time as if it's the
target running time that we gave you
right that's bad on two fronts right
okay so try not to fall into these traps
okay so some general test taking
strategies when you're looking at your
quiz
I really strongly urge you to read
through the entire exam before you
start, right? Because some of the
problems will be easier for you than
others. And if you're trying to maximize
points on here, right, as all of you,
I'm sure, are trying to do, uh, it's use
useful to make that initial pass through
the problems to see which ones are
easiest for you, right? And then you can
tackle them in the the order in which
you have confidence. Now, in actuality,
the average on say quiz one of this
class tends to be around, I don't know,
between a 60 and an 80. I don't think
it's ever been 80, but right, uh, but,
you know, it's it's not 100, right? So
doing 50% of the problems well right is
probably going to be better for you in
terms of time management and you know
those kinds of things than doing all of
the like attempting all of the problems
and not doing great on any of them right
in terms of point man right you have to
in computer science you have to be
pretty close to a correct answer to get
points right it it basically needs to be
almost correct or you don't get if If
you've seen how your problem sets are
being graded, sometimes our problem set
graders make mistakes. Sometimes they
accept give you points for for uh an
incorrect solution, right? It's really
on you to take a look at your problem
sets that you gave us and our solutions
that we gave you. We spend a lot of time
writing good solutions for you guys. You
need to make sure that you know the
material.
Don't come up to us at the end of an
exam and say, "Oh, I said the same thing
on my problem set. It was marked correct
and you guys marked it wrong." Well,
yeah, the staff knows a little bit more
about algorithms than your graders on
your problem sets and we grade your
exams. So, unfortunately, that's not an
excuse, right? It's on you to know the
material. Yep. So are most of the
problems on the exam sort of like
multiple part things where we need to
like have a good understanding and do
like the first few parts right in order
to get even partial credit on the other
parts or is it like yeah so the question
is uh is it kind of are our questions
built on top of each other right so that
you're kind of at a wall if you miss the
first part right we try not to design
exams that way okay you can actually
take a look at um the practice exam
that's already been posted
Right? They t our problems tend to be
self-contained and if they are multiple
parts, the parts are usually
independent.
Right? Usually you don't need to have
done A correctly in order to do B
correctly. Right? And that's how our
problem sets try to be written as well.
Right? For your last the coding question
on P set 4, right? You had this problem
where you had to design this data
structure, right? But C said use that as
a black box essentially and solve the
problem. Right? So you actually don't
need to show we've given you this
interface. Right? You can just use that
interface to be able to answer C the
algorithms question without even solving
the data structures question correctly.
Does that make sense? And actually that
was the algorithms question was the
easier one there I think from what I
remember. Yeah. Do we have to write code
on the exam? Do you have to write code
on the exam? Uh
I've never given an exam where you've
had to write code. I have written exams
where you have to read code. Okay. So
pseudo code or Python, right? Since
Python's a prerequisite for this class,
it's completely fair game that we give
you small snippets of Python code and
you have to to be able to understand
what's going on.
Yeah. Um you listed
under the modification bar. So does that
mean like if we're using an amortized
like what I mean here right amortization
certainly appears in here or here right
these kinds of things right often times
like if I'm using a dynamic array if I'm
using a binary heap if I'm using a hash
table right amortization will appear
here in our running times right for
those dynamic operations what I mean
here in amortization I mean like if I'm
asking you to generalize something that
we've done like with dynamic arrays
where instead of adding additional space
at the end, I'm putting additional space
in the middle or at the beginning or
something like that. And you're having
to do some kind of amortized analysis.
Now, often it's unnecessary to do this,
right? In in uh when we talked about a
problem where we did do our own
amortized analysis and making a
double-ended deck, right? I mean, a
double-ended queue. uh you could
actually solve it by reducing to using
two
uh dynamic arrays. Right? So there
there's uh there's a lot of ways in
which
you could reduce to using things but you
might have to do some additional
bookkeeping at the end. Right? But what
this is saying is that these are more
you're not using things as a black box.
You're changing something about the
boxes that we gave you. Right? Does that
make sense? Yeah, if you tell us to
write an algorithm that does something
like log n time and we can think only of
an algorithm that does something
inefficiently like end time. Okay. Then
is there any point writing that? Sure.
So let's actually move uh on for a
second. I actually there's
I'm going to answer your question very
soon. Okay. Uh but I'm going to get to
it in a second. Okay. If I don't mind,
if I don't answer that question in five
minutes, please let me know. Okay. So,
so the first thing when I'm approaching
a problem on on the exam, I might try to
ask some questions about the problem.
Okay? It's going to help me decide what
to use, right? Different than your
problem sets, right? Your problem sets
basically what do you use is what did we
talk about in lecture that week, right?
On a quiz, you have eight lectures that
you've talked about. And so that this is
going to be a harder thing for you to
do, right? Because you don't know which
of the eight lecture material is going
to apply to this problem. And it could
be a combination of them actually,
right? And so I'm trying to give you
ways of answering that question faster.
Okay? So, uh, is this a mechanical
reduction or modification type problem?
That's just going to help me determine
kind of the difficulty level of what
this is. You might not be able to answer
it, right? But it can give you a sense
for what kind of problem it is. Is this
a problem about data structures sorting
both? Right. Uh if it's about data
structures, do I need to support
sequence type operations? So I need to
store an exttrinsic order on something
or is it a a thing where I I care about
what the objects are? I'm trying to look
things up by what they are, right? Or
maybe both. Or maybe some combination,
right? If I have a bunch of different
types of keys that I might want to query
on, right? I might have to use at least
two set type of data structures, right?
You could get very complicated with
these things, but putting it in terms of
well, I'm going to need to do this kind
of operation on this these names, right?
Then I can think, oh, I need a set data
structure there. I'll think about how to
implement that later. Should I use a
hash table? Should I use a sorted array?
Should I use a AVL tree? Right? But, you
know, thinking about it first at the
abstract level of I need a set data
structure here, right? can help you
compartmentalize correctness versus
efficiency. Does that make sense? Okay.
Uh if if you're stuck, this is your
question. If you're stuck, right, write
down a correct algorithm that's
inefficient, right? We can give you
points for a correct algorithm that's
inefficient. At least it's a correct
algorithm, right? As better than other
things, right? Now if it's really if
it's exponential time
you might be limited to like 10 or 20%
of the points right but if it's you know
a log factor worse or linear factor
worse maybe that's okay right on a data
structures problem if any operation
takes order n time that's probably not
going to give you a lot of points
because the whole point of the data
structure is to make those operations
fast right but you know if If it solves
the problem, you'll get some some
points. You won't get zero points. Yeah.
Will we get any questions that are like,
"How fast can you make this? Make this
as fast as possible." Yeah. So, a lot of
times we'll say, "Give us an efficient
algorithm." Okay. It's like, "Whoa, I
don't know if it's efficient or not."
Well, that just means that faster
running times are going to give you more
points. Okay. So in in questions like
that it's mostly uh trying to play this
game of uh usually we'll put an
efficient one in not in terms of a data
structure because usually a data
structures problem it's important in
your implementation that these data
structure operations be fast and we want
to tell you that what how fast is right
so dynam data structures uh questions in
general
uh there's usually a trade-off between
this the the running times of these
different operations and it's really
important how they relate to each other
and so for data structures problem it's
kind of about getting those running
times okay with an algorithms problem
right where we ask you to do one thing
right and we try to do as fast as
possible you know try to get linear time
right most of the time you can't get
better than linear time if you have to
read the entire input at some point
right like if I want to find the things
in my data Right? And if you can't think
of a linear time algorithm, you know,
think of an n squ thing or think of an n
login thing, right? Maybe that's a
little hard for you guys to think of
right now, right? But that's why I'm
saying start with any correct algorithm
and then maybe you can optimize, maybe
you can use a better data structure to
make it more efficient. Does that make
sense? Any other questions?
Okay. Uh, moving right along.
Okay. Here's some downsides, right?
Okay. If you find yourself doing one of
these thing three things,
take a step back. You're probably doing
something wrong. Okay? So, question
yourself if you're trying to compute
decimals, rationals, or real numbers. I
can't store those things on a I mean, I
can store decimals to finite precision,
right? But if you're doing finite
precision, you might as well round like
multiply your numbers by that fixed
precision and deal with integers, right?
We only have taught you how to deal with
integers in this class, right? We
haven't even shown you how to
efficiently compute on rationals and
real numbers. We have told you if you
have a denominator and a numerator of a
fraction, I can take two fractions and
compare them right in constant time by
doing cross multiplication. But if I'm
trying to actually do this division,
right, to arbitrary precision, that's
not that's not happy, right? Because I
can't even represent that on my computer
in finite number of decimal points for
some of these things, right? Uh if
you're trying to use radic sort for
every answer, it's probably wrong,
right? Uh one of the things that we try
to do on our quizzes, right? that we're
not just giving you a bunch of problems
randomly, right? We probably are making
problems that cover the material in some
way, right? We do want to test you on
all of the things, right? And so if uh
if you find that you're using the same
thing four or five times on the exam,
that might be a sign that you're using
it too many times. It's not all always
the case, right? Sometimes hashing is
super useful, right? So you want to use
it all the time. But in particular,
right,
everyone tries to use radic sort when
it's inappropriate, right? And they
love, right, because it gets linear
time, right? But if you if you write
merge sort for something where radic
sort will apply, you'll get some points
because it's correct but not efficient,
right? If you're
and it's inefficient by a log factor,
right? If you're trying to use radic
sort in a
situation where comparisons are the
answer and you don't have a bound on the
integers. If I don't have a bound on the
size of the integers, then this may be
taking huge amount of time, right? So,
I'm going to I'm might not even think of
that as being correct because, you know,
it could be exponential time, right? Or
it could I mean I don't know I don't
know how big my word size is. It could
be arbitrarily bad. Okay. Uh, and then
if you're trying to augment a binary
tree with something that's not a subtree
property, right? Something that can't be
computed from the augmentations of its
two children, you're doing something
bad. I every exam we have 30% of
students say augment by my index
in the entire tree,
right? Or augment by
here's one that's fun. uh augment by the
things the size of my left subree.
Okay, how like the number of nodes in my
left subree? How can I
how I'm not sure how I can maintain that
with rotations and things like that? Uh
let's see to in order for me to keep
track of the augmentation of my left
tree from the augmentation of my left
tree, right? I kind of have to do a
logarithmic walk all the way down the
thing to figure out how many things were
there, right? So that's not a
maintainable thing in constant time. If
I want to augment something of my left
subree, just augment the thing itself
and just look at your left subree and
look at its augmentation. Does that make
sense? Yeah.
If you had say augmented it with a sub
tree and then augmented again with left
subree and then use you could do that
still count as you could do that. Yeah.
So you could do that in constant time by
augmenting by subree size, right? Yeah.
Then have another augmentation in the
thing. You could have another
augmentation because then you could just
look at but then just look look at your
left subree please. Yeah. No no reason
to store it again, right? You just do
one constant time look to your left,
right? Okay. Don't do that. Okay. So
that is cool. I'm not that far behind.
Those are my tips on solving
questions. Oh, there's one more page.
Yeah. So like defining an augmentation
to give a formula and like argue that
it's exactly right. So the the idea is
if you give an augmentation that's not
uh stand like we're going to talk about
our standard things you can reduce to in
a second, right? If I if you're saying
I'm going to take a set AVL tree, right,
or a sequence AVL tree and like for
example at the end of lecture, we were
talking about how a sequence AVL tree
could be modified to support priority Q
operations in the same running times as
binary heaps, right? And that was saying
we store our subree maxes, right? The
max thing in my subree, right? Uh, and
so that's a different augmentation than
what's already augmented on the sequence
AVL tree. What's what what are the
augmentations on a sequence AVL tree?
Size.
Uh, so count is the same thing as how
many nodes are in my subree and height,
right? Because it's an AVL tree, right?
Uh so if I'm augmenting by max in my
subree
that's not part of my standard interface
so you need to tell me that right even
though we've done it before it should be
very easy for you right just say I'm
augmenting by my max can be computed as
the max between me and my left and right
subree if they exist done right but just
do that right you have to tell me and
and it takes constant time so it can be
maintained in constant time when I'm
doing my stuff does that make sense
Okay. So, uh the last thing I guess
especially on the data structures
problems um I would suggest that you
approach these things by by solving
these problems just in terms of the
interfaces
first, right? Because then at least you
get something that's correct, right? And
then choose the algorithms or data
structures that you use to implement
those interfaces afterwards, right? one
gets you to a correct algorithm, the
other is for efficiency. Right?
Decoupling these might help you in
solving the problem. If if it doesn't
help you, don't. Right? Right. If if
you're like, whenever I see a set data
structure, I'm going to probably use a
hash table, that's probably fine, right?
But if we're looking for worstase time
bounds, that's probably not fine, right?
So you just
you I'm I'm ask I'm suggesting that you
separate these things uh so that you
concentrate on solving the problem first
and optimize it later. Yeah. Just a
question in regards to worst case time
bound. Um so for our hash table given
that it's like oh one expected like that
also implies that oh worst case. So
could you technically it doesn't imply
that it is that right? So that I mean
you could have a data structure whose
expected time bound is constant but its
worst case bound is n log n right it
just happens to be the fact that for a
hash table those worst case operations
are linear right so but if I had we had
a question uh up here beforehand right
if I had a a running time bound that I
did something to a hash table right in
constant expected time right I did a
lookup and then I I I queried an AV VL
tree for the predecessor of a node or
something like that and I did that in O
of log N time
what's the worst case running time of
that O of N right what's the expected
running time of this thing
log N expected login right because it's
possible that in the worst case it could
be higher that make sense
okay
uh
Uh so okay the second bullet is just
setting up a data structures problem
right there's a lot of moving parts
we're going to do two data structures
problem at the end of this session right
describe all of the data structures
you're using right
including what they store right if
you're storing a set data structure you
better tell me what the things you're
stored are keyed on right usually the
things that we're storing contain a
bunch of information. And if you just
say I'm storing all of the toppings of
my pizza, right, in a set data structure
and that's all you tell me, I have no
idea what you're talking about because I
don't know what the semantics of your
set data structure are. What is it keyed
on? Right? I have to say, oh, it's keyed
on, I don't know, the wise or something
like that, right?
Okay. And they're invariance, right?
what how we're setting up these data
structures problem usually how I solve
these when I'm writing the solutions I
set you up a state right of what this
data structure could be at some instance
right I'm going to say this data
structure stores all of the things less
than K with with key less than K blah
blah blah right and this one stores the
uh the exttrinsic order of the items
based on blah blah blah right Okay, so
actually me stating what they store in
that way, right, is actually imposing
some kind of invariant on these data
structures that I'm wanting to maintain,
right? But what I need to do to prove
that this thing is correct is that based
on the assumption that those invariants
held before my operation, right?
then I can prove that an operation is
correct if all of those ma those those
invariants are maintained at before then
after the operation right that's kind of
how I'm proving that this thing is
correct and then when I'm querying I'm
doing some kind of lookup on this data
structure I can rely on those invariants
I know that those things are good right
those things have been maintained and so
I can rely on those to look up uh what's
the largest K of this thing does that
kind of make sense abstract we're going
get a little bit more concrete in just a
second. Uh and then uh implement every
operation. I you have no idea how many
solutions we write read on the quizzes,
right? Which we give you three
operations to implement and you don't
even mention one and it's usually the
easiest one. It's like insert it into
your data structure. It's like come on
just say that right? We can't give you
points unless you mention that
operation. Does that make sense? Uh, and
then it's going to help us re happy
graders give you more points. Not not
really, right? Like, but I if your
solution is well organized and wellleled
and things like that, then we're going
to be able to comprehend your solution
better and we'll be able to give you
more points. Remember, part of this
class is about communication. If your
thing is correct,
but we can't tell what you're saying,
then it's not correct. Right.
Right.
Okay.
All right. So, uh, now we get to any
questions on that? Yeah. Question about
the variance. So, what are the data
structures that we've discussed in the
past? Do you still like what the
variants are like that tree? Right. So
if it's the standard things we're going
to talk about what the standard things
are now uh then you don't need to
reargue or restate all I mean you can
you can basically say like uh because
the set and sequence interfaces are
defined that way these things are
correct like almost like ob you can you
can basically
we you're trying to convince us that you
know why it's correct right if you guys
if you're correctly using a set or a
sequence data structure in these data
structures type problems then unless
you're using it in a way that is unusual
right uh usually you can just rely on
the properties of the set and sequence
data structures that we gave you I do
want you to mention that you thought
about correctness right right like this
um
this data structure is correct because
right just write a sentence saying that
right and arguing that you're you're
basically maintaining the invariance of
your data structure kind of at the upper
level, right? What kinds of things are
is this data structure storing? What
what m uh things about the the global
data structure are are we relying on to
make query operations? As long as you
are are convincing that uh after a
dynamic operation where I'm modifying
the data structure that those invariants
stay the same that are are still
satisfied
then then that's really all you need to
say right you these these invariants are
are satisfied because of the definitions
of a set and sequence data structure
right like a lot of times it doesn't
require a lot of thought for the we're
not asking the the reason why we do
reduction problems, right? Is so that
you don't have to do a lot of work to
prove to us that it's correct, right? We
have these really nice black boxes. They
are correct. We proved them to you that
they're correct. And so you don't have
to redo that work. Okay? So now we're
going to go through
uh kind of the core material I like to
think about in this class. this class
the the first part of this class aside
from these you know mathematical
uh uh tools that we developed at the
beginning of the course is mostly about
solving problems involving data
structures and we motivated this problem
of sorting by saying that a sorted array
is a data structure that's actually
pretty useful right but how do we sort
those things uh well we showed you a
bunch of ways to do that right
and this is that nice table lots of
stuff, right? Why do we show you so many
sorting algorithms? Why don't we just
give you one algorithm?
H
different run times. Better for
different scenario. Better for different
scenarios. Yeah, they each have their
own individual components that may be
better. Yeah, you'll notice in this
table, right, there's not blue all the
way across for any of these things,
right? So, some of them are better for
different scenarios. And actually these
comments kind of list some special cases
where these things might be better.
Right? In in actuality this ultra blue
thing is saying like this could be
linear time that's better. Right? But in
some cases this is worse than all the
other things. Right? So be a little wary
of this blue color here. Okay. Generally
we're trying to get you down further
down in this chart if you can. Right?
And in general
uh like for example merge sort, AVL sort
these are really the same in terms of
asmtoic complexity and kind of the way
in which you interact with these sorting
algorithms. Um but there are special
cases where you might use insertion sort
or selection sort. Actually I'm not sure
about insertion sort. I there you had a
uh in your recitation
two days ago uh I think you guys showed
how to do uh if you had a kroximate
array where things are not more than k
away from each other. Insertion sort
actually runs in n times k and so if k
is small then that's really good. That's
kind of like linear. But you can
actually do even better with a binary
heap which you saw in recitation
hopefully where you can get that down to
n log k by keeping maintaining a heap as
you go across and finding the max that
way. Okay. Uh so insertion sort maybe is
not so great but uh selection sort right
the the name of the game there is that
uh if my reads are cheap but my rights
are expensive right uh selection sword
actually does pretty well because I only
have to do uh sorry my reads are cheap
and my rights are yeah expensive right
selection sort only does a linear number
of swaps right it's looking down finding
the max swapping it in and keep going
right and so such cases that's actually
better than any of these other
algorithms that we've got. Yeah. Is he
sort time um worst case or expected?
This is worst case. Okay. So, it's a
little hard to put there was a lot of
moving parts to get to this bound uh in
on in Tuesday's lecture, right? Uh
basically what we did, we showed you how
to think of an array as a heap, as a
binary tree, right? Complete binary
tree. It's not an AVL. I mean, it is an
AVL tree, but like AVL trees are weaker
than a complete tree, right? Height
balance is a weaker property than a
complete, right? The the the reason why
we use complete is because it's unique
for a number of nodes, right? That way I
when I give you one array with a fixed
length, I know exactly what tree you're
talking about because there's a onetoone
mapping there, right? If I I can't if I
there was it some ambigu ambiguity on
what tree I was talking about I wouldn't
heaps just wouldn't work right so what
what heaps sort does is it has this
correspondence between arrays and binary
trees uh and then what it does is uh
provides these operations that kind of
only do operations at the end right and
then the in place uh uh optimization is
that well instead of actually popping it
or pushing it onto the back of an array.
I'm just going to think of a subset of
my array as a heap and then always
kind of pooping the max out to the the
end, right? Just leaving it behind and
thinking of my heap as a smaller subset,
right? And that's how we got it. It
didn't actually use any amortization
uh for for the timebound timebound. You
could actually do this with the
amortized basically dynamic array
version of this. The timebound doesn't
rely on that. The in place relies on you
know key staying all within one array.
Does that make sense that you're doing a
bunch of amortized operations so that
this actually does achieve worst case
and login? Yeah. It seems that like the
things we learn not like such a long
time ago are they tend to be better. So
assume that most algorithms you want
them to be you know
faster. Um it seems like we will not use
as often especially in the exam as well
insertion and selection right yeah so
there are these special cases where
they're good right but I mean uh you
know generally these are better general
data structures for most situations that
you come across. I mean there are cases
where those other things are good so you
don't want to completely ignore them
right but generally uh yeah you trying
to be lower down in this chart. What I
mean is that if I don't have any exam
like I'm using them all except for like
selection it won't there's too many
things on here for us to test all of
them on an exam. Okay. So don't be
afraid if not everything is covered.
Worry when things are covered 18 times
on the exam. That's not good right. Um
okay. So for radic sort there are
situations where right you get linear
time right it's when you're polinomially
bounded is there are there times when I
want to use radic sort when I'm not
polomially bounded in my integers
well if you're not polinomially bounded
then that could take a really long time.
Sure. Yeah. But like where's the
uh this will be worse than n login when
right it's definitely better than n
login when u is polomially bounded right
because it's linear
yeah
n
to the n okay so if I put n to the n in
here right I get an n factor that comes
out here that gives me quadratic running
time which is not great. Okay. But when
will this be better than n login?
Yeah. Uh n to the c is less than n to
the c. Uh n to the c. So that'll
definitely give us linear time, right?
That's what this is saying. But we can
actually do better than n login if this
u is n to the c * log n, right? for some
C, right? If it's if it's as like if
it's N to the C log login log N, right?
That's smaller than login, right? So
that's a better algorithm, right? That's
a faster alg. Do you guys see why we
wrote these things this way is so that
we give you a more precise bound. It's
it's this is more important for you
understand what U means here than that
that this thing sometimes runs in linear
time, right? We want to know you when it
runs in linear time, right? Does that
make sense? Or when it runs faster than
merge sort. Does that make sense?
Okay. So that's sorting.
Uh we have sequence type data
structures, right? We have linked lists,
we have dynamic arrays, we have sequence
AVLs. Sequence AVLs are great. I don't
know why no one teaches it. They're
great. They don't teach it probably
because they're actually not that
useful, right? They you don't actually
use the insert in the middle a lot,
right, in coding, right? So it's it you
can usually get around with like
shifting something to the end and doing
dynamic operations there, right? And
that's a lot of the games that you try
to play. So you don't have to make your
own data structures and you can just use
the Python list that's in your in like
native to your thing, right? But theor
it has a theoretical interest because it
gets these kind of balance bounds if you
need to insert in the middle of this
sequence. Right? Uh now some of you look
at me and had a question before right
that was like but Jason how does linked
list operations on the end of a linked
list why does that take linear time?
It's because in lecture we presented you
with what?
A singly linked list, right? It just had
pointers to the next thing, right? And
if I only have pointers to the next
thing and a pointer to the head, for me
to find the end, right? I need to walk
all the way down the list, right? Now,
let's say I keep my pointer to the tail.
then finding that end one is fine but
removing it still takes linear time
because I don't know what came before me
right and so that's why in pet set
whatever one two I don't remember uh you
stored a pointer back to your previous
one that gave you doubly linked lists
yay right so actually expanding this
table out
you can reference a doubly linked list
here and get this one as constant time
does that make sense
And uh this one still linear time,
right? Okay. Uh but this one's still
linear time. Uh we al actually also
showed you how to do this in constant
amortize. Do do you guys remember that?
That was in problem session
two or one. I don't remember remember it
was whatever we talking about uh
amortized stuff, right? We got we got
actually both of these to one amortized
using the concepts of a dynamic array.
Right? And then we actually did it one
more time where we got a good
double-ended thing. What was that?
Does anyone remember? We went to problem
session three. Yeah. Oh, I'm probably
wrong. This is
like Q.
So QDQ uh those are talking about
double-ended things. uh those are
implemented in a certain way right which
is actually one of these things it's
actually I think this one in Python uh
but uh there's we used a different data
structure to get something that had
really good at right it had really good
pop and append and first and last
dynamic operations do you guys anyone
remember problem session three
space. That's That's what this was,
right? Okay. We got one that had
expected bounds. Does that help?
Really? I heard someone say it.
Hash table. Yeah. So, what basically you
did you instead of you you this is a
sequence thing. These things don't have
keys, right? But I could identify with
each item as I stick it in a key
representing its index, right? And I
could use a hash table that way. Now
there was some difficulty, right? If I
removed the first thing, right? Or
right, because actually how how those
all of my indices have now changed,
right? But if I just store what the
smallest index in my thing is, then then
I'm golden because I can compute what
that index should be, right? As I as I
change things at the front. Okay. So
there's actually three different ways we
showed you of getting constant time at
the front and the back of this thing. So
actually you can think of that as
standard material that you can reduce
to. Okay, that's the like one exception
of the things that I'm not showing on
this chart, but is a bonus if you're
watching this problem session. Yeah. So
the so isn't a hash table a set data
structure though it is right but it's we
used it to implement a sequence data
structure. So I will refer you to that
uh problem session if you want to learn
more about it. Okay. So any questions on
sequence data structures? Yeah. Uh a
different question. Uh should we be or
yeah should we be able to like prove the
tables that we're given? So, uh, I would
hope I hope that if I gave you a blank
table that you would be able to fill it
out, right? That's how well I want you
to know how these things are
implemented.
I'm we're not going to have that on the
exam, right? That's a boring kind of
question, but it is important to know.
Yeah, I I would um you know, it's good
for you to think like, oh, if I'm going
to use an AVL tree, right, operations
are generally going to be login, right?
That's a really useful thing to or if
I'm going to use a hash table, right?
Dictionary type operations, you know,
finding, inserting, and deleting, those
are fast, doing order type operations on
hash structure hashts is bad. That's
hard to do because I have to basically
look through all my things, right? Um,
knowing that dynamic operations on a
sorted array is bad, right? or knowing
that uh you know
you you have to think about here what we
mean when we say linked list and dynamic
array in this table right because sing
you've yeah exactly we are implying
singly linked here because that's what
we presented to you in lecture and so
those are the standard things that we
want you to reduce to so the three
modified standard things are the double
list the double ended yeah basically you
can assume that you have a doubly it's
this one that you probably want to use
Right? Because you get
constant indexing, right? And then
pretty good on both ends, right? But you
know, if you need a double-ended queue,
you can also reduce it to having two
dynamic arrays back to back. One going
this way, one going this way. And so
there's lots of way. We're not going to
give that to you as a standard method
because there's literally like four
methods we showed you how to do, right?
So you choose one. Okay. Yeah. In the
interest of like saving time on the exam
like if we want to say like we do this
thing with the sequence and it takes
login time like do we have to like say
the sentence like because it's a
sequence AVL it takes long time because
this or can we just like say like per
the table that we yeah no if if you just
if you told me that you're storing
things in a sequence AVL right and you
just say you basically say what you do
to it and you say which takes blah blah
blah time you don't need to say because
it's a sequence AVL Right? Because you
already told us it's a sequence of
wheel. I believe that you probably wrote
the chart on your cheat sheet and you
looked it up. Okay. All right. Uh any
other questions on this? No. Yeah. Just
to make sure the double link list will
make the insert and be all one. Is that
the only change? Yes. That double link
list gives this guy constant time.
And actually there are two operations
here. uh insert delete and I guess
there's a find here as well right if I
just store the tail pointer that gets
the find to constant time right but it
doesn't get the dynamic ones to constant
time right I need to store the previous
pointers as well at each node does that
make sense okay
uh lastly or I guess second to lastly
set data structures there are a little
bit more of these not so many more but
uh
But yeah uh we had a sorted array gets
good find but is not dynamic right
we set AVL tree which does pretty good
find and is dynamic again you get this
uh log n login overhead to build because
essentially what you're doing with both
of those data structures is to sort
right but if I'm looking on a theory
question Right? Like I'm not asking you
something specifically about a sorted
array. Right? If you have a choice
between this data structure and this
data structure, which one do you choose?
Well, I don't quite know because it's
almost like this one's better at
everything except for this one, right?
But can anyone tell me how to make this
one constant time as well?
Augmentation, right? I could just store
in my sub trees the max or min, right?
And I can make this one strictly better
than this one, right? So in a theory
problem, you probably just want to use
this one, right? Uh here, hashts, direct
access arrays, even better for these
operations. That's great, but they suck
at these, right? So if you need these,
don't use these, right? And in actual
coding, right? Especially if you're
coding in a language that's not Python,
something that doesn't automatically
give you a hash table, right? If you're
in C in a microcontroller lab in in at
at MIT here, you're taking 615 or
whatever, right? Like and you're doing
assembly, right? Usually what you're
doing is a direct access stuff, right?
Because that's giving you the jumps that
you need in machine language to actually
go and access this and cause the time.
That's generally if you have control
over the keys that you're putting that
you're putting in your data structure.
You don't want this overhead of com
running your keys through a hash
function to look these things up. You
just store the things in array, right?
You use the hash table when you don't
have control over the keys or your keys
are like strings or something, right?
So that's when you use the hash table.
Now for our purposes usually you know a
hash table is just as good unless we're
asking you for worstcase bounds right
and if we we're going to do this when we
talk about the data structures problem
if we give you a situation where we
don't care if you achieve worst case or
expected or amortized or any of these
things. We'll just say make sure you
state which one you achieve, right? And
as long as you analyzed it correctly
with respect to your data structures,
then you're fine, right? But if we say
you better do worst case here, I'm going
to slap you around, right? Then please
get those bounds, right? Don't don't use
a hash table in that case.
Does that make sense? Okay. Uh lastly,
we've got priority cues, which we talked
about. I'm not going to go through this
one very much. It's basically just
adding this to the thing. But act in
actuality, you can get all of these
bounds with a set AVL I mean a sequence
AVL tree with max or min augmentation
which isn't on this list because we
didn't really talk about it but
hopefully you can
if you need these bounds without the
amortization then then you could achieve
them. Okay. All right. So those are
that's basically everything that we've
talked about in the class. Okay, we're
going to spend the rest of the time
working a couple data structures
problem. I'm not there's there's a
number of different types of questions
you'll actually um see
on uh on the quiz the practice quiz that
we gave you from last term. there's some
what I call mechanical type questions up
at at the front right then usually some
reduction type problems where you're
reducing to using some sorting
algorithms or some data structures and
then usually the la latter ones are ones
where you have to do some kind of
something additional like some
augmentation or some you know divide and
conquer or something like that right
okay uh so we're going to go ahead and
spend the rest of the time working a
couple of these problems uh these were
from spring of 2019 on the exam. Uh uh
and actually one of the TAs who's uh
TAing for us now was also TA for us in
spring 19 was grading problem number two
here the rainy research problem and just
hated me because no one did it right. So
all right uh so
let's try to solve these problems. So
problem one, this is about restaurant
store. Yes. Okay.
All right. Uh so basically what's
happening? Uh popular restaurant,
criminal seafood.
What's the reference? Legal seafood.
Yes. Opposite. Does not take
reservations but maintains a wait list
where customers who have been on the
wait list longer are seated earlier. Uh
sometimes customers decide to eat
somewhere else so the restaurant must
remove them from the weight list. Okay.
Uh assume that a customer has a
different name. No two customers are
added to the weight list at the exact
same time. Right? So there's an kind of
an ordering at which people are being
added to this weight list. Right? Does
that make sense? Uh design a database to
help criminal seafood maintain its
weight lists supporting the following
operations each in constant time. Okay.
So here we're we've refactored the
running time up to the top. Uh and it
said oh sorry I added the build here. I
guess that's still constant time. That's
fine. Okay. Yeah. State whether each
running time operation is uh worst case
amortize expenses. So when you see that
statement you're saying okay I'm allowed
to use a hash table if I want to right.
I just have to make sure if I use one, I
label my operations expected and
amortized when they occur, right? Which
which operations are expected?
Basically, all of them. Which operations
are amortized? The ones that changed
what's in the data structure, right?
Insert, delete. Okay, so we've got some
operations building an empty thing
adding a name. So, this name is X to the
back of the weight list. What do I know
about X? What do I know about the names
per our assumptions in this class?
They're all unique. So they can be a
key. They're unique so they can be a key
and
they fit in a constant number of words
by our assumption. Right? So I can
compare two of them in constant or I can
hash one in constant time. Right? That's
kind of the assumption we make on these
inputs. They're strings and I didn't
assign you a a bound on their length. So
you it's probably not something you need
to worry about. Right? Okay. Uh remove a
name, right? So already I'm feeling like
I need to be able to find things by
their name, right?
Okay. Uh and then see it's the next
person in line. Does that make sense? So
what kinds of things do I need to
maintain here? I I've I have people,
right? They have names and they have
kind of places, right? The time that
they came in, right? But am I given the
times?
No, I'm not given times anywhere, right?
It's not on the inputs to my operations,
right? So, it's not like I'm going to be
able to key on times. Does that make
sense? What's the important part about
the times? The order, right? And you're
given that. Yeah. Basically, whenever
I'm I'm basically trying to maintain a
sequence on these guys, right? There's a
front one and a back one and people in
the middle, right? And I want to make
sure that order stays the same or else
people are going to get angry at me,
right? because ah they came here after
me and yeah right you've been in that
situation. Okay, so uh we're trying to
maintain some kind of sequence an
exttrinsic order on these things, right?
But we're also needing to be able to
look up people by their name because I
want to be able to change this thing,
right? Does this maybe sound familiar to
some other problem we had on this pro
this terms problem sets? Yeah, I think
there was a problem where uh
the chat, right? Right. You had to store
a sequence, right? But you also had this
dictionary that you had to look things
up, right? Now, the nice thing about
that um
situation, right, is that the things
that you needed to look up on was
static, right? And so what could I use
for my dictionary, my my set data
structure for that?
Anyone remember?
You could just use a sorted array,
right? Because it's static, these things
aren't updating all the time, right? And
so it was fine for me to just use a
static array. Right? Here uh uh and and
we gave you lookup times that were worst
case logarithmic. Right? Here I'm asking
for constant time. Right? Sort AVL
sorted array is not going to cut it. Set
AVL is not going to cut it. That's what
I'm going to use. A dynamic array or a
hash table. Right? Now dynamic array
might not be great because I don't
actually have a numeric bound on how big
these keys are. I just know that they
fit in words, right? So I can't actually
make a direct access array because those
words while they fit in a constant
number of words, I don't know if the
integer representation of those are
polinomially bounded.
Does that make sense? Right? So I I do
want to use hashing in this in this
case. Right? And so what do I want to
maintain? I want to maintain
a sequence data structure
uh on
customers.
Customers is there a U in there
somewhere? No, this is right. Right.
Okay. And a set
uh
mapping.
So you this is usually how I do it. Like
I want to say a set keyed on something.
If it's just a set, then I just have it
keyed, right? I can look up whether that
thing is there or not. But when it's I'm
I'm actually having it mapped to
something else, I'll say, you know,
mapping a key space to something else.
Usually the item that I'm storing or
maybe some property of the items that
I'm storing, right? Does that make
sense? Okay. So, mapping, what do I map
here?
Names, right?
to
oh to what do I want to map
the time the time that they entered
do I want to do that well we can't
exactly do it with the time that they
enter but the sequence and the customers
will show what's next and yeah kind of I
want to I want to store it to where it
is in this sequence right so I'll just
store the index where it is in the
sequence and I can just look it up right
that sounds
Yeah. Is that what I heard? Indices
change. Yeah. Indices change every time
I add or remove things, right?
Ah, yeah. Store a pointer, right?
Pointer
to place
in sequence. Now, uh that's a little
weird to say because I haven't told you
how I represented this sequence,
right? But you know conceptually I can
say I'm storing a pointer to some place
in this that represents where it is.
I'll deal with the details of that
later. Okay. Right. But generally I call
this a linked data structure. Right?
Because I'm linking between two data
structures. Right? So that I can do a
query in one say and find out where it
is in the other. Right? Or do a query in
the other. That kind of thing. Okay. So
everyone kind of understands why I chose
these things, right? How I approach this
problem. Yeah. Um not sure how a pointer
fixes the problem of just storing an
index, you know, like the the place that
the person is at in the sequence is
going to change over time. Are we
assuming that the pointer updates with
that change? So, okay. So, let's say uh
if if every time So, let's say I'm
storing let's say I'm storing this
sequence in a link list. Let's just say
because I know that I'm going to have to
be inserting and deleting things from
the middle of this thing. Does that make
sense? All right. So, I'm going to go
ahead and say that this is going to be a
linked list. Okay. And now I have this
linked list.
Okay. So if I said all right this set
data structure in my set
stores point or stores where it is in
the link list right I say it's stored at
at uh k right cool
now if I see it's this guy right I stick
him at his table right every index has
changed right so for me to update the
indexes stored in this set data
structure, I have to change every single
one of them. Yeah. Does that make sense?
Yeah. No, this makes way more sense.
Yeah. So, really what I want not to
store a number here, but an actual
pointer to the node that's containing
this thing, right? Because the node
isn't changing unless that thing left my
data structure, right? the node, the
address of the this thing in memory, the
the the node is just a little container
that contains an item and a next
pointer. And actually, we're going to
need a previous pointer here,
right? We're going to need a double
length list, right? Because what we're
going to do when we remove something, we
need to stitch it back together in
constant time, which means we need to
know what's the one front of us and the
one behind us, right? Yeah. Okay. All
right. So link list here we already said
maybe using a hash table here
right and so okay great
this is basically enough for me to say
this is my data structure these are the
invariants what are the invariants it's
storing all the customers right that's
an invar I mean it's not a very strong
invariant but it's I mean I I should say
that right I'm storing all the customers
because I'm going to have to make sure
that I'm maintaining that when I do a
query, right? Uh and then here set
mapping names to pointers, right? That
place in this thing, right? And as I
remove things, I need to make sure that
invariant stays the same, right? It's
still mapping all the names of customers
that I have in my thing to their nodes.
Okay? So when something leaves, I better
need to make sure that both of these
things are updated. Does that make
sense? Okay, so how do I maintain these
operations? We've got a build. Build
just sets up empty of these things,
right? So you just say that, right? I
build an empty linked list, doubly
linked list on the customers and I build
a a set uh a hash table mapping nothing
to nothing right now. Right. Okay. So
that's build. I'm gonna be precise here
and actually write down the thing
because I told you not to uh
not to ignore a operation or else we
can't give you points for it. The next
one. Yeah. By empty by building an empty
list you mean like it just has like the
head and the tail are set to none but
like it exists. Yeah. Right. It's it's a
thing in memory that we store. It has a
pointer to a head and a tail. Those are
none right now but we will add things to
it. Right? Okay. So the second one add
name right.
What do we have to say? We have to
update this data structure so it
maintains it to variance. Right? I have
to usually I start with one of them. Uh
I get to a point where oh I really
should have updated the other one first.
Right? So sometimes it's hit or miss.
What do I want to do here? Well, I have
no idea where in this sequence this is,
right? So, I kind of have to go here
first, right?
Oh, sorry. Adding a guy I could do
either way, right? I know where is he
going to go? End of the list, right? So,
I can just stick it there, right? So,
add
x to end of sequence. All right. So I
already come to a trick that I like,
right? Sequence set. Okay, in this
instance I only have one sequence in one
set and so calling them sequence and set
it's probably fine, right? I'm not going
to confuse the greater I'm not going to
confuse myself, right? But when I have
more than one of these things or even
for brevity on an exam where I'm, you
know, time constrained, give these
things a name, right? Say this is a
sequence uh C and M I don't know I see
customer here I see map here so you know
maybe I don't know right but just give
them a letter and we can follow you much
more clearly and you can refer to these
things more precisely right so end of C
okay
uh then what do we have to do I fix this
guy this guy's good now I have to fix
this guy so I add x to the set and I map
it back to that node that I just came
from. Right? I could store it in a
temporary variable, right? Add
uh x to m pointing
to
in node
v to v. Okay, cool.
So I added my X to the end of C into a
node V, right? I'm kind of hold I
labeled it so I can reference it later,
right? And kind of in code I would
probably remember what that node was.
Add X to M pointing to that node. Right?
And now I've maintained my invariant.
Great. Maybe what's next? Uh add
key X
or add add X to M having the key of X
point to that note. Does that make
sense? There's a subtlety there. Okay.
Three,
we have remove.
I don't remember the name whatever.
Okay.
So here we have to do the order matters,
right? I don't know where it is in the
sequence,
but I'm going to look it up in the set.
I'm going to remove it from the set, and
I'm going to look at whatever it points
to and remove it from the sequence.
Okay, I'm running out of time a little
bit here, so I'm not going to write all
that down, but you guys understand what
that means. Here, we're using the fact
that it's a doubly linked list so that
we can relink things together. You don't
have to tell me
repoint the previous pointer of my next
thing to the next the right you don't
have to tell me how to relink those
pointers because we did that already in
problem set one or whatever right just
in general is there any situation for
where using non not a double link list
like just a link list would be better
than double link list because it seems
like it always solves problems yeah
double link list is almost always
strictly better than a single link list
in theory problems So yeah, use it.
Okay. Uh and then seat last one.
That's just
take the front of the sequence, remove
it,
change the head around. But I I get that
you can delete first, right? You're
reducing to the interface that we had.
You're deleting first on this sequence.
Okay, but now we have a situation. I I
deleted the first guy. How do I know who
the first guy is? Well, I'm storing its
name in there, right? I'm storing the
names of these customers. So, I know who
was at the front.
I look in this set data structure and I
remove that entry. Does that make sense?
Because now I no longer need to maintain
where he goes. Now, in actuality,
I could just not update this set data
structure. But if I do that then well my
running times are still linear time
right I'm not giving you a bound on
space I'm I'm still constant time sorry
so you don't actually have to do that
removal but uh if that customer comes
back and wants to get on the wait list
again right you're right there there are
things to consider right
okay so that's that question
next question last 10 minutes or So, uh,
rainy research. This was a problem that
people had nightmares about.
Okay. So, basically, we've got uh Mother
Wan.
He's a weatherman. Uh, a scientist who
uh studies global rainfall. Uh, and he's
got a bunch of uh uh sensors everywhere.
And each one can post to the cloud or
something a measurement that's of the
form a triple of integers R, L, and T,
where R is a positive amount of
rainfall, an integer, uh a latitude,
uh an integer again, and at a time.
Okay, so we got three things to deal
with here. Yuck. Okay. Uh but they're
all integers. And don't be like, "Oh,
well, Jason, latitudes are pretty small,
so I can assume these integers are small
and these things take constant time,
right? I'm not specifying to you a
resolution at which I'm measuring these
integers. So, and I haven't given you a
bound between what that resolution is
compared to the number of measurements
that I have. So, don't play those games.
Okay? Uh the peak rainfall at a given
latitude
since a particular time is the maximum
rainfall at any measurement at that
latitude measured at a time greater than
or equal to that time. Does that make
sense? Or zero if there aren't
measurements at that latitude. Okay,
just or after the time or before the
time or whatever. Describe a data base
that we can build it and cause the time.
Right. uh is an empty one. I added this
one because we weren't good about that
last spring. Uh record data, we give you
a triplet and then so record data for it
to be correct, I just have to maintain
that information. Right. Right. For
these kind of updates, I don't I it's
really hard for me to argue that this
thing is correct. Right. Because I just,
you know, I throw it at the database.
The data basease doesn't have to give
anything back to me, right? So the the
important thing here about correctness
is that peak rainfall gives it to me and
it gives it to me in the time bound that
I'm looking for. And peak rainfall is
returning the peak rainfall at a
particular latitude since t. Okay. So we
have three things. Yep. Given that we
never have to like return a single
measurement is that we don't need to
have a record of it. There's the
potential that you don't need to store
all of the information because all we're
doing is giving you back RS essentially.
Right? It's possible that you don't need
to store the latitudes or times at all.
Right? You don't even need to store the
triplets. Now, in reality, I'm querying
on the latitudes and the times. So, I I
should store them somewhere, but I might
be able to compress them. in particular,
right? Many things could be stored at
the same latitude, right? That's kind of
the whole point of the query. And so we
want I mean, we may only need to store
that latitude once. Does that make
sense? Okay, I'm I'm going to wait for
questions until after because I want to
get to a solution to this problem. All
right, so uh what do we need to do? We
need to be able to add things and I want
to return. So return, I'm going to have
to query something, right? And then I'm
going to return something, right? So
return peak rainfall at latitude L since
time t.
What do I care about in a particular
query? I I only care about all the
things at L, right? At a latitude L. So
really I this isn't such an interesting
thing, but I want to be able to have
maybe many data structures, one
associated with each L. Does that make
sense? Right. And how can I find one in
each L right quickly?
put it in a dictionary. What's my time
bound? Worst case log N. Right? So what
data structure did I use for that set
data structure? A set AVL. Right? So
we're going to first have a uh set AVL
uh say L
uh mapping
latitudes
to
well now we have more data structures
right I want to store a lot of the
things that have the same latitudes in
another data structure right the ones is
probably
storing the times and the rainfalls of
all those measurements. Yeah.
Uh yeah, a hash table. A hash table.
Okay. So, what kinds of query am I going
to want to do on the things at the same
latitude? Um you're going to want to get
the times. I'm going to want to get the
times, but more than that, I'm doing
kind of a an ordered query, right? I
need the things less than a certain
time, right?
Greater. Also, it's just just a second.
You should do like an AVL for the time
and an AVL for the rain. Okay. Do I care
about an AVL for the rain? Do Am I
looking up on the rainfall?
No. No. Right. So, I'm going to go ahead
and store these things in a time sorted
AVL, right? To
uh mapping latitude
L to I'm going to call this data
structure a time data structure, right?
I'm going to say it's T of L. Okay, that
kind of looks like a recurrence. So,
it's a little irking me right now, but I
don't have anything better. All right,
so now each one of these time data
structures, right, is
a set AVL
mapping
time
to the, you know, the rainfall
measurement, right?
All right.
So that's going to if my query was
return the peak rainfall, sorry, return
the rainfall
of the thing with latitude L and time T,
we'd be done kind of, right? You you'd
know how to support that query, right? I
to insert things, I insert things into
both data structures. I just look it up,
right? The one complication here is that
I'm not asking for what is the rainfall
at a particular time. I want know what
the maximum rainfall is up to this time.
Okay, so max heap's good if I want to
know the global max, right? But here I
want to know the max bounded by a
certain range. Okay, so I we're gonna
you can ask me questions after this.
We're running out of time a little bit.
Okay. So, anyone have an idea for how?
Yeah. You just augment the the with the
max. Okay. You can just look at the
right child and just look at the max of
that. Ah, okay. So, what your colleague
is saying, if we augment by the max R in
my subree,
maybe we can use that to figure out this
query. Right? Because we're ordered on
T, right? we have this nice monotonic
property that everything that's going to
be in my query, right? Everything to the
right of a certain time, right? If if my
time is uh in is above t, right, at a
particular node, then everything in my
right subree is also above that t,
right? Because of the order of my set's
data structure, right? Because I'm
ordered on times, right? So there's
maybe the possibility that if I look to
my right subree, I can not do work all
over here by just looking at the max in
that subree. Right? So that's an idea of
let's say augmented
by
subtree
max r. Okay, you probably want to give
this a name as well, right? So like v
max, right?
where V is a node in my sub in my thing,
right? And I want to show how to support
this, right? How I can compute that from
its children. So, how do I actually
support this query, right? I can think
of it recursively, right? I have a
couple cases. If I add a V here, I want
to define a recursive function that's
called uh, you know, peak
peak rainfall of a given node.
lower bounded by a t. Okay.
So if I'm here, there's two cases,
right? Either my t my time is bigger or
small is in my range or out of my range,
right? If it's out of my range, what do
I do? Right? It's lower than my time
bound.
I can just recursively call this
function on this node, right? because I
know that any
thing is going to be down here that I
care about, right?
And that's just one recursive call down
the tree, right? And so if I only limit
myself to one recursive call down the
tree, I'm always going down each time.
This is going to take logarithmic time,
right? Okay, so that's the first case.
That's the easy case, right? This thing
is not in range. I return recursively
the thing to my right. What's the other
case? I'm in my range, right?
Well, now I could return recursively
call both sides, right? Because that's
what this this peak is talking about.
What's my peak rainfall? But if I do
that, if I call it here recursively and
I call it here recursively, that could
take linear time, right? I might touch
every node in my tree. So why did I do
this augmentation? It's so I don't have
to do work on this node. I just return
the maximum rainfall in this subree,
right? And then recurse on this side. So
I I did constant work on this side. I
did one recursive call down here which
could go to the bottom. That's okay. I
can afford to go to the bottom of the
tree. Does that make sense? And if I
don't have either subree, then I'm done.
Right? If if at any time I don't have
the node that I'm supposed to recurse
on, right? I take the max of this subree
myself and whatever the recursive return
value is here, right? and comparing
three values returning their max. Does
that make sense? Okay, so that's what we
call a one-sided range query. Okay, so
uh in the I think problem session four
that I didn't get to, it shows you uh a
way to do this for a two-sided range
query where I need to know like the
maximum of all things between two
things, right? But it's really no more
difficult than this defining a recursive
function that uses an augmentation so
that you don't have to do recursive call
on both sides. Does that make sense?
Okay. Uh that's going to be it for now
and I can take questions after. Okay.
Thanks for coming.