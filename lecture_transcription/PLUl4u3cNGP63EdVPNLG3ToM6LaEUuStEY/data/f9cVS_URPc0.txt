okay let's get started
welcome to the 12th lecture of 606.
uh this is our second lecture talking
about
weighted graphs and in particular
weighted shortest paths algorithms
last time we talked about weighted
graphs this is a kind of a
generalization of what we mean by
distance uh in an unweighted graph
instead of each
edge having a weight of one essentially
right we generalize that to be any
integer
and last time we we showed how to solve
shortest single source shortest paths in
a graph that doesn't have cycles even if
it has
zero or negative weights in linear time
using an algorithm called dag relaxation
we also showed
in that lecture how in linear time if we
are given the shortest path weights
to all the things reachable in finite
disk
or with shortest path uh distance
that's finite we can construct a
shortest paths tree from those weights
in linear time okay so this is
motivating why
we're not really going to talk about
parent pointers uh for the next couple
of lectures
we're just going to concentrate on these
shortest path weights
right and so today we're going to be
talking about
our most general algorithm we'll be
showing for solving single source
shortest paths
in particular in graphs that could
contain cycles
and could have negative weights okay so
just to recap
uh our little road map here
uh single source shortest paths new
linear time last time we discussed
another linear time algorithm dab
relaxation
and today we're going to be talking
about beltman ford which
isn't limited to acyclic graphs in
particular there could be
negative weight cycles in our graph
right
if it has cycles and has negative
weights
the worry is that we could have negative
weight cycles in which case there is
if a negative weight cycle is reachable
from our source then the vertices in
that cycle and anything reachable from
that cycle
will potentially have
an unbounded number of edges you need to
go through
there's not a bound on the number of
edges for a shortest
path because i could just keep going
around that cycle as many times as i
want
and get a shorter path right and so we
assign those
distances to be minus infinity okay
so that's what we're going to do today
in bellman ford in particular
what we're going to do is compute
our shortest path distances these
shortest path weights
for every vertex in our graph
setting the ones that are not reachable
to infinity
and the ones that are reachable through
a negative weight cycle
to minus infinity and all other ones
we're going to set to a finite weight
and another thing that we might want
is if there's a negative weight cycle in
the graph let's return one
okay so those are the two kinds of
things that we're trying to solve
in today's lecture okay but before we do
that
let's warm up with two short exercises
the first one exercise one
okay given an
undirected graph
given undirected
graph g
return whether
g contains
a negative weight cycle
anyone have an idea of how we can solve
this in linear time actually
in fact we can do it in order e
uh no yes yes reachable from s
i guess let's just save
a negative weight cycle at all
not in the context of single source
shortest paths
ah your colleague has determined
uh an interesting fact about undirected
graphs
if you have an a negative weight edge in
an undirected graph
i can just move back and forth along
that edge
that's a cycle of length two or
i guess three vertices back back to
where we came from
that is of negative weight because i'm
just traversing that weight
over and over and over again so the
question of
single source shortest paths of finding
negative weights
is not particularly interesting in the
undirected case what i can do is just
for every
negative weight edge undirected edge in
my graph
i can just you know find the
reachability from
the vertices the endpoints of that edge
and label them as minus uh
minus delta basically if the connected
component containing s
has a negative weight edge then
everything in the graph is accessible
from a negative weight cycle so this is
not
such an interesting problem and so we're
going to restrict our discussion today
today to
directed grabs
uh so this is uh
if and only if exists
negative wait
edge okay
okay exercise two
kind of a little preview for
what's to come we're actually not going
to show you an algorithm directly
that meets this bellman ford running
time v times e
what instead we're going to show you is
a an algorithm that solves single source
shortest paths
in so given an algorithm
alg a solves
single source shortest paths in order
v times v plus
e time okay what is that that's v
squared plus v times e right
that's close to what this v times e is
okay that's what we're going to show you
but if i had such an algorithm
can anyone tell me a single source
shortest paths algor
how we can use this algorithm to solve
single source shortest paths
in v just v times e time okay
show how to
solve sssp
in order v times
e i guess we can put a dot there as well
okay so this is a little tricky
it's kind of related to the difference
we had between the reachability problem
and the single source shortest paths
problem
that we saw last lecture right this
when are these asymptotically different
in their upper bound is when v
is asymptotically larger than e
right but the connected component
containing s can
have at most e vertices
or order e it can actually have at most
e plus one vertices because uh
otherwise it wouldn't be connected okay
so what we can do if we had such an
algorithm
we could first when we're given our
graph explore everything
in the graph using bfs or dfs find all
the things reachable from s
and then just throw away everything else
now i have a graph
for which v is asymptotically no bigger
than e
and then we can use this algorithm to
solve single source shortest paths in v
times e time okay i'm not going to write
all that down here
you can see it in the notes yeah
graph is it simple does this work if
your graph isn't simple
i haven't thought about it we are not
going to talk about non-simple graphs in
this class
uh but probably not because you've got a
lot of edges
though in our class if we're talking
about single source shortest paths
if we have multiple edges between two
vertices we can just take the minimum
weight one because it's never better to
take the larger ones that answer your
question
great all right so those are our
warm-ups that's our goal
we need to find an algorithm for single
source shortest paths in general graphs
graphs with potentially graphs and
cycles and negative weights
and solve it in this v times linear
kind of time that make sense
all right so first before we get to the
algorithm
we're going to uh discuss a little bit
about
simple short about shortest paths in
general
if we didn't the problem here is
negative weights
how do we find if we had negative weight
cycles
there seems to be these problems because
we could have minus infinities in
our deltas but if we didn't have
negative weights
i'd like to assert to you that our
shortest paths even if there are
negative weights
are going to be simple they won't repeat
vertices so that's the first thing we're
going to
show you
find let's say
simple shortest
paths
okay so claim
i'm going to give my claims numbers
today
just because i'm going to have a lot of
them if
my shortest path distance from s to some
vertex is finite
meaning it's not infinite or
minus infinite right some finite value
there exists
a shortest
path
a shortest s2v path
that is simple
and remember simple means not going
through a vertex more than once
all right how are we going to prove this
well consider
if this claim was not true right if
every shortest path contains a cycle
essentially right it repeated a vertex
then my path looks something like this
i mean there's some vertices along here
and then i go to v so here's s
and then there's this some cycle i
repeat some vertex i'm going to call
this cycle at
c okay
now what do i know about this path i
know that
it has it's a shortest path and it has
finite weight
right so in particular this path this
delta distance
is not minus infinity but
if this is not minus infinity what do i
know about the weight of this cycle
yeah it can't be negative right because
if it was negative i could keep going
around this cycle
and this would have a non-finite weight
shortest path distance from s right so i
know this is
you know can't be negative so it must be
zero or positive
right but if it's zero or positive and
this is the shortest path
right went through this cycle then i
could remove it
and now i have a new path with one
fury cycle i could just keep doing this
to create a simple path okay so
that checks out okay
so that's interesting if it's simple
what do we know about the number of
edges
in a simple shortest path
how many could there possibly be
how long in number of edges
could a simple shortest path path be if
i can't repeat vertices
right i can have at most v vertices
on my simple path which means i can use
at most
v minus one edges right fence posting
right
so simple
paths have
at most v
minus one edges
that's a nice little thing i'd like to
to box off that's a really nice property
right so
while uh a shortest path here could have
an infinite number of edges
right if the shortest path distance is
finite
i know i only have to check paths
that use up to v minus one edges in
particular
this is finitely bounded in terms of the
number of paths i have to consider it's
exponential potentially
right but at least it's finite okay the
other the other way i
i potentially had to check every
possible
path of which there could be infinite if
there's cycles in my graph
okay so
i have an idea okay
what if i could
find shortest path by limiting the
number of edges i go through
right so not the the full
shortest path distance from s to v
but let's limit the number of edges i'm
allowed to go through
and let's talk about those shortest path
distances just among the paths
that have at most a certain number of
edges i'm going to call this
k edge
distance and i'm just going to provide a
little notation here
instead of having a delta i'll have a
delta k here that that means
how many edges i'm limited by okay so
from s
to v is
shortest
s to v path
using at most
k edges
short weight
weight of
a shortest path shortest s to v path
using at most k edges
okay and the these notions
seem somewhat symmetric right if i were
able to compute
this thing for v minus 1
right then
it for all the vertices then if the
distance is finite then i'll have
successfully computed
the real shortest paths because of this
statement right
now that doesn't mean that if it's
if this is uh
it doesn't mean the other way right if
this is minus infinity
right if the shortest path distance is
minus infinity
it doesn't say anything about what this
is right it just says the shortest path
using at most v minus one vertices using
it
at most v minus one edges uh would be
whatever this is
but really the shortest path length
needs to consider an infinite number of
edges
right so it doesn't really tell us much
about that
but for the finite ones it does it works
well
and so if we are able to compute this
thing for k equals
v minus 1
in a graph that doesn't contain negative
weight cycles we'd be done
right
i claim to you a stronger statement that
if
the shortest path using
at most v edges from s to v
is less than strictly less than delta of
v minus one
right this is all in the subscript here
right basically this is the sh
shortest path distance of any simple
path
right and possibly ones that also
contain cycles but
definitely it includes all this the
simple paths right
if there's a shorter path to my vertex
that goes through more than v minus 1
edges
that this path can't be simple right
because it goes through a vertex more
than once otherwise it would be included
in this
distance set right so if this is the
case
and i found a shorter path to v
that uses v edges but yeah that uses v
edges
that path can't be simple which means
that path
or some path there contains a negative
weight cycle
okay so if this is true
then i know
that the real shortest path distance
from s to v
must be minus infinity
right i'm going to call such a vertex a
witness
right if if we can find a vertex that
has this property i mean i haven't shown
you how to compute these things yet
right but if i were able to find a
vertex v
and these are capital v's if you uh
having trouble these this v
is different than this speed this is
cardinality right
if we can find such a vertex v that
certifies that there's
a negative weight cycle in r
graph so i'm going to call
v is a witness
okay so
if this property is true it's a witness
and it definitely has this
is it possible you think i'm going to
claim to you that it's possible
that a vertex could have minus infinite
distance
but not have this property hold okay
there's i could probably give you an
example i don't have one off the top of
my head right now
but that's possible you could imagine
there might be no path going to a vertex
on a negative weight cycle
that goes through v exactly the edges
right
it might go through more edges a shorter
one
right so this equation would be an
equality
and would not certify that this is true
right but i claim to you
if a vertex has this property if it's
its shortest path distance is minus
infinite
then it must be reachable from a witness
okay so that's the claim
if delta sv
is minus infinity
then v is
reachable
from a witness
reachable from a vertex that has this
property that has
this property and if it's reachable from
something that has
minus infinity shortest path weight then
i can take that path
go to my reachable vertex and that's
also a
minus infinite path right okay so how do
we prove this
well let's consider
let's let's i'm going to state a
somewhat stronger statement
uh that will prove instead okay it
suffices to prove
that every negative weight cycle
contains a witness if we were to prove
that
right then every vertex with this
property
every vertex with this property has
uh
is reachable from a negative weight
cycle by definition
okay so if we can prove
that every
prove every
negative weight
weight cycle
contains
witness right
if we can prove that every negative
weight cycle contains a witness
then every vertex reachable from
one of those witnesses in particular
reachable from the negative weight cycle
has is uh
has shortest path distance minus
infinity and that should prove the claim
right uh is this thing has to be
reachable from a negative weight cycle
uh and so if we prove negative weight
cycles contain witnesses
then all of these vertices are reachable
from a witness okay great
great confusing myself there for a
second okay
so let's consider a negative weight
cycle
in g okay this is a directed negative
weight cycle
recall okay this would be my
negative weight cycle c right
all the sum of the edges in this thing
the way
the weights has negative weight
and i'm going to have a little bit
notation if i have a
vertex v here i'm going to say
that its predecessor in the cycle i'm
just going to call it v
prime okay that's just some notation
all right so
if i have computed these
path distances to every vertex in my
graph
shortest path distance going through at
most v vertices and the shortest path
distance going through at most v minus
one vertices
then i know the following thing holds
delta
of v going from s to v for any
vertex in my cycle
can't be bigger than delta v minus one
from s to u
plus the weight sorry knight u
v prime its predecessor plus the weight
going from the predecessor to my vertex
why is that why is that because
this is the weight of some vertex this
is
the way the shortest path distance to
my predecessor using one fewer edge
and so this in particular is the weight
of some path
that uses v edges so if this is the
shortest such
path distance this has to upper bound it
right at least at most yeah
that's that is a statement of the
triangle inequality thank you
all right so yes
this is just by triangle inequality okay
now what we can say is let's take
this equation summed over all vertices
in my cycle
okay so i'm just going to add some
summation here of all vertices in my
cycle
of this whole thing okay i'm going to
do that out a little bit neater okay
summation of
delt delta not d delta
v s v
i guess i don't need this open
parenthesis
equals or less than or equal to
sum of v and c of
delta v minus one
uh v prime
okay and here i'm summing over v
and c and this is just my notation for
it's the predecessor right
and then i'm going to sum over the
weights
in my cycle v
in c right these are the sum of the
weights in my cycle
well what do i know about this cycle
right this is just the weight of c right
weight of c
that's awful handwriting c
what do i know about the weight of the
cycle it's negative right
so this is less than zero
which means that if i remove this
this needs to be a strict equality
right but if this
if the sum of all of these is less
strictly less than the sum of all these
we can't have none of the vertices in my
graph
satisfying not satisfying this property
right right
if all of them are not witnesses
then this thing is bigger than this
thing
at least as big as this thing for every
vertex
in my cycle which is a contradiction
right
so the claim holds if
we have a negative infinite shortest
path distance
then v is reachable from a witness so it
suffices for us to find all the
witnesses
find all the vertices reachable from the
witnesses
and then mark them as minus infinity
does that make sense okay
so now we finally are able to get to
our algorithm all right bellman ford
and what i'm going to show you today
is a little different than what is
normally presented as bellman ford
the original bellman ford algorithm
does something a little different and
because it does something a little
different which we'll talk about at the
end
it's a little hairier to analyze i'm
gonna
show you a modification that is a little
easier to analyze
and has this nice property that we're
going to be able to use the algorithm
to give us a negative weight cycle if it
exists
okay so we're gonna say this is a
maybe a modified bellman ford and the
idea here is to
make a vertex associated make many
versions of a vertex okay and i want
this version of the vertex
to correspond to whether i came here
using
zero edges one edge two edges
three edges i have a different vertex
version of the vertex
for each one of these uh for
for uh a path going through
at most a certain number of edges okay
so this is an idea called graph
duplication
idea graph
duplication and this is a very common
technique
for solving graph related problems
because essentially what i get to do is
i get to store information right it's
i'm rep
i'm i'm if i'm having different versions
of a vertex
i can have that vertex correspond to
reaching that vertex
in a different state okay so that's what
we're going to do here
the idea here is make
the plus one
levels basically
duplicate vertices in our graph
where vertex v k
in level k
represents
reaching
vertex v
using at most
k edges okay so this definition
seems similar to what we're doing up
here right
if if we have vertices that have this
property
then their shortest paths in this new
graph
might correspond to these k edge
distances
and really what the name of the game
here is to compute these two for every
vertex
because then we can con then if
uh d is finite delta is finite
then this guy will be the length of our
shortest path and if they're different
that'll be a witness and we can explore
from it okay
so
and if we
connect
edges
uh from
one level to
only higher levels
basically levels with a higher k
then this graph is going to be a dag
oh that's cool
why is that cool because we saw how to
solve single source shortest paths in a
dag in linear time
now this graph that we're going to
construct is going to have v
plus 1 levels so could have
our our graph kind of explodes v
times right we're going to do that in a
second i'm going to
be more precise with what i mean there
but
if we're multiplying our graph v v plus
1 times
then the size of our graph is now v
times larger that doesn't
that's not so hard to believe
but if we made our graph v times larger
and we ran a shortest path algorithm in
linear time with respect to that graph
then that graph has something like size
v times v plus
e size
that looks familiar maybe
that's this running time right so if we
can find an algorithm that runs in that
running time
we can get down to v times e okay so
let's try to do that
here's the transformation i'm going to
show you i'm going to show you first
with an example
okay here's an example of a directed
graph that does contain a negative
weight cycle
okay can anyone find it for me
b c d right has weight minus four
plus three minus one it has a minus two
total weight right so that's a negative
weight cycle
okay so if i were to take shortest paths
from
a right i will want to say
at the end of my algorithm this better
be zero
and all of these better be minus
infinity right
so that's what i want in my in my
algorithm
so what's my algorithm going to be i'm
going to make
v plus one copies of this graph
and i'm going to kind of stretch it out
right okay so here
i have v zero one two
three four there are four vertices in my
graph so this is one two three four
five copies of my graph i have a
version of vertex a for each one of
those copies a version of vertex b for
each of those copies c
and d etc okay so i have this nice grid
of vertices
and i'm not going to put any edges
within a layer
within a level right because then i mean
this graph has cycles right
and i don't want cycles in my graph
right what i'm going to do instead
is for every edge in my original graph
for example the edge from a to b i'm
going to connect it to the
the b in the next level right so a0
is connected to b1 with an edge weight
of -5
just like in the original okay and i'm
going to do that for every edge in my
graph
and i'm going to repeat that down all
the way okay
in addition i'm going to add
a zero weight edge from a0 to a1
or from every vertex all the way down
the line these are all
zero weight edges corresponding to i'm
not going to traverse an edge
i'm just going to stay at this vertex
okay
that's going to allow us to simulate
this at most
k edges condition now if you take a look
at paths in this graph from a0
our starting vertex
clearly none of the other vertices are
in that level
are reachable from a zero right
just as we want right because the
shortest path distance
to any of these vertices using at most
zero edges
should be infinite right i can't get
there in zero edges
okay but then any path in this graph
using
at most
k edges is going to correspond
to a path from 0 a0
to a vertex in that level the
corresponding level so for example
if i had a if i was looking for paths
to be right
using at most three edges
right
any pat a path from a0 to
b3 in this graph
would correspond to a path in this graph
that uses it most
three edges right so let's find such a
path
okay so going from a0
b1 stay at b1
stay at b sorry yeah that's a that's a
path using fewer than
three edges or at most three edges okay
but there's another path here where is
it
going from a a a to b okay that's not
such an interesting one that's the same
path
so i might have more than one path in
here corresponding to a path in there
but my claim is that any path in here
corresponds to a path in here
okay so what's a what's a
path of length three that's non-trivial
yeah a
to c to d to b okay so
a to c
to d to b yeah that's a path
right and i basically because i
constructed this so that the edges
always move from level to level
as i traverse these edges i always
change levels
yeah but my original graph doesn't have
these self loops yes my original graph
doesn't have an edge from a to a
that's true right i'm using these edges
to correspond to
i'm deciding not to take an edge right
it's not that i'm like doing any work
here i'm just staying there for a state
okay and that's what's going to allow me
to get this at most
edges all right so this is the graph we
construct hopefully
you understand that we made these
v layers right this is
v right and
a vertex we made v copies of every
vertex
and connected them using edges in this
way okay
so first step of bellman ford is
construct this graph
uh so bellman ford construct
construct g prime
as described above it has
how many vertices
v times v plus one right
v times v plus 1 vertices and how many
edges
well i have one edge for outgoing edge
for each vertex corresponding to
just staying in the same place right so
that's
v squared vertices i mean edges
and then i have one edge
for every edge in my graph i have k
sorry i have a v minus one
sorry just v i have v edges for every
edge in my graph
okay so that means so this is the number
of vertices
and v times v
plus v times e
this is v v
plus e all right cool
so that's how many edges i have
so we construct it in that way it's a
dag right if we only have
edges going to increasing levels
then this thing can have cycles because
otherwise that would mean there would be
an edge pointing backwards
right and we didn't construct any of
those all right
so we construct this graph g prime we
can do that in linear time with respect
to these things i just go through all
the edges i make these
edges and i make these vertices it's it
doesn't take anything
i just do it naively right i can do that
in
time v times v plus e
asymptotically okay now
i run dag relaxation
our nice algorithm we had last
time
from
in there it was a0 i'm going to say it's
s0 our source
our source vertex single source shortest
paths
so that i compute
delta of s0
to vk
for all k in
what is it zero to
v
right that's what single source shortest
path does right it computes for me this
distance
from my source at some source right to
every other vertex in the graph and so
in particular i get these
right well that that is all of them
then
for each vertex
v set
the thing i'm going to return uh
d value uh s to v
equal to the shortest path distance i
got from dag relaxation
to a particular vertex
uh
v v minus one
all right why do my why am i doing this
right i'm setting it to be
the shortest path distance to
the guy in the second to last row here
or
column
in my modified graph
the hope is that this distance
in my dag corresponds to
this distance in my original graph right
uh the distance to v using at most v
minus one edges
right so that's the claim that's the
claim we're going to prove in just a
second
i'm going to write it down just so that
we have
just to continue our train of thought
claim
delta s 0
v k equals delta
k the k edge distance
from s to v
that's that's what we want to claim that
would then
what would that mean then that would
mean that i'm correctly setting the
shortest path distance here
for all vertices whose distance is
finite
great i mean i i set values
to things where they're not finite where
they're minus infinity also
but in particular i set the ones
correctly if they're
uh finite okay so the last thing we need
to do is deal with these
minus infinity vertices
right but we know how to do that right
we just look at the witnesses because
we've computed
this value
for k equals v and k equals v minus one
and if that claim over there is true
then those shortest path distances
are the same as these k edge shortest
path distances
and we can just for every vertex we
compare these things
if this is satisfied we got a witness
right okay so
for
each witness
you envy
you know where delta
s naught u v
is less than strictly s naught
u v minus 1
that's the definition of a witness here
close the parentheses
then for each
vertex v reachable
from u
set del uh sorry
d d is what we're returning d of s v
equal to minus infinity so that's the
end of the algorithm
basically i'm looking for all the
witnesses
for each witness i find all the vertices
reachable from it
and set it to minus infinity just as we
argued before
okay so it remains to prove this claim
how do we prove this claim
well we can induct on k
right is this true for k
equals zero yeah right we kind of
already
argued it over here when we are talking
about our initialization step or what
what
dag relaxation does it'll set this to be
the shortest path
from this guy to all these vertices
these aren't reachable from here
and so these are infinite and that one's
zero
okay so the base case
so induct
on k
base case k equals zero
check right that's all good
now we induct in our inductive step
let's take a look at the shortest path
distance from zero
from s zero to v of k
prime for some k prime and the
assumption is the inductive hypothesis
is
that this distance is the
k edge distance for all k prime less
than k
i mean all k less than k prime right
well kind of by definition of a shortest
path
this is the minimum over all
incoming vertices of the shortest path
from s zero to u of
k prime minus one
plus the weight of the ed of the edge
from
u of k prime minus 1
to v k
prime for all u
k prime minus 1 in the adjacencies
the incoming adjacencies of v k
prime okay what does this mean
right i'm just saying in my graph g
prime
a shortest path to this vertex needs to
go
first through some vertex in the layer
before it
which is one of these and in particular
i'm only connected to
things uh adjacent to me
that's all this is saying right i have
to go through that vertex
and take some shortest path to one of
those previous vertices
now in actuality
these adjacencies i constructed them to
be
similar to the adjacencies in my
original graph
in addition to one edge coming from my
original vertex
right from from vertex v so this is the
same as the minimum
of this set delta s naught
same thing
plus wuv
for all uh
u in the adjacent incoming adjacencies
of my original vertex
in addition to one more term what is
that other term
these are all of the things
corresponding to my incoming edges
in my original thing but i also have
that one edge coming from the
v before it right so this is i'm going
to union
union union this with
delta s naught
v of k prime minus 1.
awful i think there's another one here
this is s naught v of k prime minus one
okay i'm not going to rewrite it okay
then by induction this thing
and this thing must be the edge shortest
paths using
k minus one vertices and then that's
just
the statement of what the shortest path
should be
using at most k prime
edges going from s to v
okay so
these things are the same as we clamped
yay
check all right and then it's
not such a triv it's it's kind of a
trivial leap then to say that at the end
of bellman ford
these guys uh sorry the things that we
return
these guys are the shortest path
distances
because here if they're finite we set
them to their true shortest path
distance
and if they're minus infinity
that invariant means that these things
correspond to
exactly this claim over here
it's a witness
and then finding all the vertices
reachable from those witnesses
we said all of the infinite ones
to be minus infinity as desired okay so
what's the running time of this thing
well we have to construct this graph so
we had to take that time
okay we ran dag relaxation that takes
the same amount of time
right for every vertex we did order v
work and then for each witness how many
could there be
at most v checking the reachability of
each vertex
that can be done in how long order e
time right because we don't need to
consider the things that aren't
connected
to x or aren't connected to the witness
right so this thing takes order
v times e work so we're upper bounded by
this
the time it took to construct the
original graph
and by the claim we had before
that takes v times e time okay so that's
bowman ford
i'm just gonna leave you with two
nuggets
first the shortest uh shortest path
if for any witness let's say we have a
witness here do i have any witnesses
here
uh i didn't constru i didn't fill in all
these
but is there a vertex on this cycle
that goes through uh who has the
shortest path
that goes through four vertices that's
smaller than any other
right okay i can go from a to c
to b to d to b to c
and you can work out this algorithm i
have it in the notes that you can take a
look at
this will actually have a shorter path
for vertex sorry it'll have a shorter
path for vertex
b
a to b to c to d to b
thank you that's a path of length four
of four of edges
that has shorter path than any path that
has
fewer edges in particular there's only
one other path to be
using fewer than four uh there's two
other paths
one path of length that has one edge
that has weight minus five
and one path this path that has weight
nine minus one is eight
right whereas this path minus 5 minus 4
3 minus 1 has minus 10
plus 3 is minus 7 which is shorter
than minus 5. so b indeed is a witness
right and if we actually take a look at
that path
through this graph going from a
to b to c
to d back to b
we see that there's a negative weight
cycle in this graph
b to c to d to b and indeed that's
always the case for our witnesses
okay you can see a proof of that in the
notes and you can see in recitation
a little space optimization to make us
not have to construct this entire graph
on the fly
but actually only use order v space
while we're going okay
so that's bellman ford sorry for running
a little late