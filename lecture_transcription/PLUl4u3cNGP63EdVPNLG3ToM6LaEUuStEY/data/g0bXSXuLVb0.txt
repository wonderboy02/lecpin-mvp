all right welcome to
practice problem session three double o
six um
today we are going to go through a bunch
of problems which
you should have already um i was
thinking of skipping the very first
problem because it's just a mechanical
thing if we have time at the end we can
come back to it but there's not really
any
insight i can give you in how to
approach this problem it's just do you
understand hashing
so i want to go into the more creative
problems first i'll start with
problem three two hash sequence uh
so i'll just read it and then our first
task is to convert the la
the word problem into a concise formal
algorithms thing we need to achieve then
we need to come up with ideas for how to
achieve it and we need to check the
details
that'll be our general pattern so this
problem says hash tables are not only
useful for implementing set operations
they can also be used to implement
sequences
remember from lecture two we have a set
uh
interface which is about querying items
by either key and sort of intrinsic
order
that's about the items themselves versus
a sequence interface that we started out
with of linked lists and so on
and arrays for uh where we're given an
order we want to maintain that order and
that order may not have anything to do
with the
items themselves that's what we call an
extrinsic order we're told what the
order is by saying insert this item
after this one or append this one to the
end or prepend it to the beginning
so in lecture last week we saw hash
tables implement
sets and let me just remind you
some things that they can do
so we have on the one hand set
hashing
so this we're going to need this in a
moment
this is just a reminder from lecture we
can build one in linear time
expect it we can find an item in
constant time
expected by key and we can insert or
delete an item
in constant expected
amortized
okay uh so this is a black box that
we're given
and the problem
statement says that imagine you're given
a hash table as a black box which means
we're given a thing that behave
behaves just like a thank you to
uh we're given something that is a hash
table but
it's black box in the sense that we're
not allowed to reach in and change the
implementation details we're supposed to
use it as
is just by calling its interface so in
particular we're given these three
operations i'll maybe also use
it to iterate through the items so we're
allowed to build something in linear
time
find and insert and delete and
constantly expect it amortized
and what the problem is asking is to
build out of this data structure
a sequence with particular time balance
uh so this is what we call a reduction
in that we're going to convert uh
i guess technically we're reducing the
sequence problem
to the set problem um because we're
showing how to solve the sequence
problem using the set problem
but the way we'll think about it is in
the other direction we're given a data
structure to solve set and we're going
to convert it into a data structure that
solves sequence
so given that we already know how to do
this from lecture we're going to learn
how to do this
this is teaching you new stuff in a
problem set
so the specific bounds that we're told
to achieve are build
and constant expected time
get and set at
inconstant expected time
insert and delete app
and linear expected time
and insert and delete
uh first and last
and running out of room here
constant expected amortized
okay um so this is just what we're told
to do
and now we start thinking so we're given
this
we want to build this um and so
i'm going to tell you a little bit about
my thought process about when i'm
presenting with a problem like this
first thing is to read the problem
and see okay what what's what's the hard
part here
what are the challenges so clearly we
have to do all for all four of these
types of operations
building linear expected time that's
basically everything we've seen
uh get or set at in constant expected
time that's fast
and that feels kind of like this find
operation
so both of these seem pretty
matchy-matchy so that
looks like a good mapping i'm gonna try
to build these operations using those
operations
insert and delete uh at a specific
location
in constant expected time sorry linear
expected time
that's big linear expected time means i
can
rebuild the entire data structure every
time i do an operation
so this is easy okay that's first thing
you realize this
is big great so i don't really have to
worry
about these operations i mean i do have
to implement them but
it's not hard to do it that fast because
i can rebuild
uh and then here insert and delete at
the beginning and the end of the array
these are the deck
double ended queue operations can
certainly leave at either end
and constant expected amortized time
this i feel like is
a tricky one uh you've seen one way to
do this in problem set
but now we're gonna see another way with
okay the other thing to notice is these
expected words
uh in this case we're told to use
hashing but a lot of the problems
you're not told how to solve it or what
you should be basing your thing on
and so expected is always a good keyword
because it means randomization is
involved somehow if you're told the
bound is going to be expected
you should you probably need to use
randomization
and in this class the only form of
randomization you will use is
essentially hashing
so uh that's a good hint
in this case we know that we're supposed
to use hashing all right so
this is going to be the challenge
but any ideas on how we might tackle
this problem how can we
so set remember every item has a key
in a sequence items are just items and
we're told to insert and delete them at
particular locations
but they don't have keys so one of the
challenges is going to be
to take our items here give them keys so
that we can store them in a set
otherwise we can't use find
there's no keys there there's no way to
search by key
ideas
so let's think about what we want to do
let's start with so build i think is
fine if you
just want to build a data structure you
don't need to do anything
the hard part are the queries or updates
you want to be able to do on your data
structure
let's start with this operation get and
set at so
remember get at your given and index i
and you want to
find the item at position i
and set at we're given
a position and we want to change the
item stored
at that position at that index i now
over here
what we're given we can insert and
delete
but the main sort of lookup let's think
about get at first
the natural mapping given this arrow
is find find will search for an item by
key
so here's just staring at that once you
look at all the possible pairings you
could do
we have find by key over here and we
need to implement get at by index
so let's make the indices keys okay so
this is idea number one
uh index
assign a key
to each item
equal to the index
in the sequence
okay so then when i do to implement get
ad i can just call
find of i
if i is also a key and that should give
me
the thing that i want maybe for this to
make sense let me tell you how i'm
building
so if i'm given say an array of items
uh and they're both the only name
conflict here is built so let me call
this one
sequence build
and i'm going to implement it using set
build
and i'll use some short shorthand
notation here let's say
i want to make an object that has a key
equal to i and a value
equal to a of i
that's my object notation for i
equals 0 1 to
size of a minus 1.
that's a little bit code-like but not
quite literal code
so i'm just going to use this to say
let's make an object that has two
parts one is called the key so we can
talk about the object.key
so we can see which sets want to do and
we're also going to store a value which
is the actual item that we're given
so i'm just because these are given in
the sequence i'm just representing that
sequence order by assigning i to be the
key
and so now if i want to find the item at
index i
i can do find of i and technically i
should probably do dot
value that will give me the actual item
that's stored
at that position when i do find of i i'm
going to get this whole object
with the key of i and then i want to get
the value part of it
so then set at i can just
use this find operation to get
the object and set its value to x
boom we've implemented array like
semantics get at
i and set at i using
a set if you've ever programmed in
javascript this should feel very
familiar because javascript
actually implements arrays it's at least
at the conceptual level
as just general mapping types which are
they call them objects but they are
basically sets
and if it's even grosser they convert
the integers into strings and then index
everything by the strings
semantically anyway implementation
details can be more efficient but
conceptually that's what's going on and
so that's the the idea we're doing here
which seems great um any
any problem so i have let's see there's
insert and delete app
as i mentioned what i'm going to do for
those operations just rebuild the entire
structure
and just write that briefly
basically uh let's just iterate all the
items
iterate all items
um let's say into an array
insert delete one of them
and then rebuild okay
if i was writing a pset answer i would
say a little bit more detail what i
mean in this step um i've done it in the
notes not that hard
but we can afford linear expected time i
can afford to call build again
i guess technically i'm calling this
build sequence build
uh so i can afford to just extract
things into an array do the linear time
operation on the array of
with the shifting and everything and
then just call build again yeah
questions
no these are separate definitions yeah
sorry they got
a little close so this is the definition
of get at this is a definition of
sequence build
yeah thanks for asking
okay all good yeah can you
explain the answer explain insert and
delete okay so
maybe i should actually write one of
them down
or i'll just draw a picture maybe so we
have this data structure
which is now a sequence data structure
represents some sequence of items and my
goal is to say delete
the i item so there's some items in here
x0
up to xn minus 1. i want to remove x i
from the sequence
or i guess i should drop it this way
it's coming out
so uh what i'm going to do is first
extract all the items from the sequence
and i didn't write it but there's a
an interface over here called itter
which
just gives me all the items in order so
i'm going to extract
this into an array sequence
let's say i'll just build a static array
of size
n i also have a length operation that
tells me how many
items are in here and the the iter
operation will give me all the items in
order and so i'll put into my
array x0 and then x1 and so on as they
come out
then i go to position i
and i want to delete that item and shift
all the others over this is the
boring this is i think we even said how
to do delete
at in dynamic arrays
in recitation 2 pretty sure so i'm just
mimicking that i'm building
this just to get the new order of things
and then i'm applying
via the build operation i'm building a
totally new sequence
and that's how i would implement delete
app one way
there are other ways yeah um
how much space is this using uh oh it
problem with space if you're inserting
if you're inserting you probably want to
allocate a static array of size n plus
one you know exactly what's going to
happen
so just allocate a little bit bigger
then you can do the shift
you could also use dynamic arrays but
then you would get maybe an
it's not an amortized bound because
you're only doing one insertion
the point is this is really easy we can
spend linear time
so we can rebuild the we can rebuild
this array
three times if we want it question uh
what if you weren't allowed
externally uh non-constant space
ah you gotta throw me open problems uh
what if you only
have constant extra space uh
right then i think we need to use insert
and delete
so we could good question um
we could conceptually do this shifting
but do it using insert and delete
so we can so let's do the
delete case again so we want to
here's x i we want to replace it with x
i plus 1
and so on
and so we can start out by deleting
the item with key i that will get rid of
this guy
then we can delete the item with key i
plus one
give it and that gives us the item and
then we can reassign its key to be
i i instead of i plus 1 and then
reinsert it
so we can take this item out it has a
key
which is draw this properly
so we have key i plus 1
and value x i plus 1
stored in this data structure then we
update the key to i and then we reinsert
it
and it takes the place of this guy so
you could do that you could go down this
list
and or not the list but you could
iterate for i equals
sorry for j equals i to n minus one and
for each of those items
delete it change its key reinsert it
with a new key
and then you don't have to build this
intermediate data structure
so if you're told to have been in
myspace great and maybe you think of
that as simpler i like to think of this
as simpler because like
the point is i have linear time i can do
crazy
silly very non-data structuresy things
where i just start from scratch
okay great but there's one more set of
operations insert delete first and last
are these easy good
shall we try uh we can
insert last
so this is given an item x we want to
add it to the end of the structure so
that means its index is going to be
equal to
because we start at 0 it's going to be
equal to the length current length of
the structure
so let's just insert a new object
which has key equal to the length
and it has value equal to x
we're done delete last similar just
delete the item with key
length minus one okay what about first
this is supposed to add x to the
beginning of my sequence
well now i realize i have a problem
because
i want this new item to have key 0
because after i do an insert first get
out of 0 should return this item
but i already have an item with key 0
and an item with key 1 and an item with
key
2 and so on down the way and so if i
wanted to give x a key of 0 i have to
shift the keys of
all of those items just like we were
doing here and that's going to take
linear time
but we're supposed to do this in
constant expected amortized time
so that's no good so this idea
is not enough it's not a bad idea it's
still a good idea
but it's no longer what we actually want
to do it's only
morally what we want to do so
what do you have any thoughts on how we
might get around this problem
seems like inserting at position zero i
need to shift everything down
linear time that really sucks
yep um you could
create some sort of link to something
else
link this data structure with another
one so we could build more than one set
that's certainly allowed
uh i don't know how to
do oh i see you're saying maybe build a
whole another structure for the
items that come before xero yeah yeah
actually that would work i think
maybe uh it's like in the pset then you
have to deal with when
if you delete one of them it becomes
empty then things get messy
delete first is also going to be a
problem because i delete the beginning
of this data structure
then i lose my zero item and i want the
new zero item to be the
one item that's again all the indices
shift so delete and
inserting at the first is heart so we
could do that trick like in the pset but
or in like in less problem session and
so on um
but there's a much simpler idea
can you have an extra very to keep track
where
is that nice i have an extra variable
to keep track of where the beginning is
call this first this is going to be
the key
of the uh first
item index zero
another way to say this is let's just
use negative integers
right set sets work for any keys any
integer keys okay actually we
technically said they should use keys
zero to u minus one
but then uh if you have negative numbers
you can
easily fold do you know the string
ah python negative numbers means
something else but we're not using the
python interface we're using our custom
magical
set interface which we show how to
implement in recitation nuts
which can take an arbitrary key it
hashes that key
and you know finds a place to put
that item so we're not actually storing
things in order here we're storing
things in a hash table
but we're not supposed to get into the
implementation details
i think the way we presented hashing
with our
universal hash functions we only allowed
positive numbers
so maybe technically i should point out
if you have
positive and negative numbers you can
fold this in half
by mapping zero to zero one to
two two to four spreading it out
and then you can take minus one and map
it to plus one
and minus two and map it to plus three
so this is like
uh multiplying each of these guys by 2
and multiplying each of these guys by
minus 2 and adding 1.
and then you get non-negative
integers out of all integers this is a
typical math trick for showing that the
number of integers is equal to the
number of
non-negative integers which may seem
weird to you but they're both
countably infinite so you could
if your structure only supports negative
keys you could map negative keys in this
way and
throw them into the hash table okay so
now
i allow negative things for
[Applause]
like that and so great if i want to
insert at the beginning
what i can do is just decrement my
first variable which is keeping track of
the index so initially first is going to
be 0
so i'm going to add into my build first
i'm going to say
first equals zero
because i start with key zero and when i
initially build a structure
and if i wanna if i need more room
before zero i just set first to minus
one
and if i already have minus one element
i'll decrement it to minus two decrement
means decrease by one
it shows my assembly language
programming this is usually a built-in
operation on
most computers and then i can insert
an item with key first
and value x
right now if i want to delete the first
item i would delete
the item with key first and then
increment first
and now all of my operations have to
change a little bit let me use another
color
um because i was implicitly assuming
here that all my indices started at i
but now they start at first they
index zero maps to key
first and so the right thing to do here
is
plus first
and plus first basically add a whole
bunch of plus first
throughout this one's probably fine if
i'm globally rebuilding i can reassign
all my labels
but this one should be first plus
plus length
okay so just by keeping track of where
my
keys are starting i can do this shifting
and not have to worry about stuff
and this is a lot easier than having to
worry about
maintaining two structures and keeping
them both non-empty and stuff like that
because of if i assume my set has this
power
of dealing with negative integers and
strings and whatever else
oh why didn't i use a linked list
because
this linked lists are very bad at get
and set at a given index
this is not a linked list this is just
storing a single number as
integer in your data structure that says
what is the smallest key in my data
structure
that's all it does it's a it's a counter
okay so data structure keeps track of
its length and it keeps track of the
minimum key
and so it will always consist the
invariant is you'll always have keys
from first up to first plus length minus
one
and that's what we're exploiting here
we have no idea where first will be it
depends how many operations you've done
how many inserts at the beginning and so
on but the keys
keys will always be first
to first plus length
minus one this is what we call an
invariant useful to write these things
down
so you can understand what the heck why
is your data structure correct
because of invariance like this which
you can prove by induction
by showing each time you do an operation
this is maintained
even when i'm changing first in order to
maintain this invariant
cool sometimes you come up with the
invariant first in this case i came up
with it
episode uh post facto after the fact
uh cool let's move on
to problem three
which is called critter sort and the
other key thing i want you to learn
about
a question sorry um so when you do first
first plus one is that a rebuilding of
use this is just a sentence
is not an algorithm or data structure
this is a mathematical property
this is not an assignment this is a
mathematically is equal to but you are
reinvesting it though
because you're doing first plus one so
are you asking about one of these
operations
like this one wait oh okay never mind i
get it
yeah okay so the other important
takeaway i want you to get about reading
our problem sets is that they have
hidden humor inside
i don't know if you've noticed but
here's an example of a problem called
critter sort
ashley getum collects and trains pocket
critters to fight other pocket critters
in battle
what is this a reference to digimon
digimon
wow you guys are so young pokemon
the the old the ancient form pokemon is
short for pocket monsters
and in fact in the original anime okay
actually
i i don't know it was all after my time
we can debate after so pocket critters
is a reference to pokemons pocket
monsters which is pokemon
who's ashley getum
ash ketchum is his full name in the
english version
um totally different name in the
japanese version but
they're both puns on collect them all
right all right so that's the important
stuff we'll see more jokes later
so there's this setup but basically we
have n
critters and we want to sort them by
four different things
and so i'm just going to abstract this
problem into sort
m objects by the following types of keys
and for each one we want to know what
the best sorting algorithm is
and there's this footnote that's very
important it says faster correct
algorithms will receive more points than
slower
correct algorithms also correct
algorithms will receive more points than
incorrect algorithms but that's implicit
incorrect generally gets zero
okay so uh part a
uh it says species id but basically we
have integers
and the range minus and n
so if i want to sort and integers in the
range
minus end to end what should i do
reference to
yesterday's lecture
yeah radix sort yeah always a good
answer for almost always a good answer
when you
have integers it's a good answer
whenever you have small integers now
radix sort the way we phrased it
let me maybe put it down here uh radix
sort
sorts
n integers in the range
0 to u minus 1
in m plus
m log base n of u
time and in particular this is
linear time if u
is n to some constant power
okay so can i just apply this as is to
these integers
no because they're negative so what
should i do maybe i should do my folding
trick we just saw how to take
negative numbers and fold them in
interspersed with positive numbers if i
sort that
will that work no
because that does not preserve order it
would
intersperse it's just we want all the
negative numbers to come before all the
positive numbers yeah
just add n yup boom plus n
now we have integers in the range
let's be careful 0 to 2n
cool now we can apply this now u equals
technically 2n plus 1 because we're only
supposed to go to u minus 1.
but that's fine that's linear and so we
can sort in linear time
easy this is a super easy problem okay
but in each one we might need to do some
transformation
all right part b is a little more
interesting so we have strings
over 26 letters
of length
at most 10 ceiling log
n okay this is a little trickier
what could i do again i'd like to see
whether radix sort applies
um i should say radix sort sorts
i'd like to see if radix sort applies to
do that i have to map these strings into
integers somehow
any way to do that
this is easy if you understand radix
sort yeah
index the letters yeah
yep we can we can map right so we can
map a to zero
b to one then one
but we have a lot of letters
there are only 26 letters but then we
have uh 10 login
letters in a string that is together a
single key that we need to sort
yeah i'm going to sort by the first
first letter first start by the first
letter then the second letter that is
exactly the opposite of radix sort
remember radix or we want to sort by the
last letter
and then the next the last letter and
finally the first letter by the first
one here it's alphabetized
no to alphabetize we do want to in the
end
sort by the first letter but that's at
the end oh wait so that at the end
remember radix sorry always goes
backwards from the least significant to
the first to the most significant
so indeed that is what we want to do
you're just saying use radix work but
what am i radix sort on
what am i radix sorting on yeah on the
on the last letters not the first
letters so technically that would be
using counting sort
on the last letter counting start on the
next last letter dot dot counting sort
on the first letter
but that is together radix sort on
something or
jason likes to call this tuple sorting
tuple sort is the thing is the algorithm
that says
sort by the last thing then sort by the
previous thing and so on
you can also think of this as radix
sorting on a number written in base 26.
they're the same thing
okay but in the end we can sort in
linear time
how do you tell the algorithm that you
want a to come like
just like not zero is less than one a is
less than b
right so i mean technically when you
call something like tuple sort
or maybe it's even clearer when you call
it radix sort rakes are giving it a
bunch of numbers
so you're taking these strings and
mapping them to numbers
and when you do that you get to decide
which letter is the most significant
which is the least significant
all right so you you will choose to
always map the first letter in your
string
to position a two
uh um value
or the the position and positional
notation
position uh 26 to the power 10 log n
right as the most significant so it's
always most significant even if your
string is of length one
you want to put that in the most
significant digit and you'll pad with
zeros at the end if you
run out of letters in your strings
here how many times am i running
counting sort oh
10 log n times whoops yeah good question
good point uh computed this wrong so
uh right there are log n digits
in the string uh so that
is bad i mean it's okay
we'll end up with a n log n running time
however so that's the tuple sort so i
should really
if it's not equivalent if i run tuple
sort letter by letter
i'm going to do i'm running counting
sort log n times and so i get n log n
because each one takes linear time
if i map my strings into numbers
first radixor doesn't use base 26 it
uses base n
and then it will only run 10 times
because uh you know 2 to the
10 log n
is n to the 10.
and so uh the numbers that we're sorting
are between 0 and n to the 10
and so u is n to the 10 and so that's
the case when radix sort runs a linear
time
so if you run tuple sort letter by
letter it's slow
if you run radix sort it's doing a whole
bunch of letters at once
effectively it's doing log n letters at
a time in a single
call to counting sort and so the radix
sort will actually
win and get linear
there's a subtlety here which is i'm
assuming that we can actually
take these strings and convert them into
integers in
constant time each and this problem set
was ambiguous
and both answers were accepted if you
assume these letters are nice and
compactly stored then
and they fit in 10 words because a word
is at least log n
if it's long then you can actually do
this
if you store each letter in a separate
word then just reading the entire input
will take
and log in time
that's a subtlety which we don't need to
worry too much about in this class yeah
yeah there are 26 possible letters
numbering them 0 to 25. um and then
when we take a string like a
a map this into 0 0
in base 26
that's a number if we do bb for example
this is
maps to 1 1 in base 26 which means
uh 1 times 26 plus 1
which is 27. okay so that's that's the
mapping that i mean
you're mapping the whole string the
whole string to a single number yeah
and there's a subtlety because i want
lexicographic i need to pad things with
spaces at the end or pad them with a's
at the end
in case they're shorter than 10 log n
okay uh cool that was b
c is not very interesting it's integers
in the range 0 to n squared
this i can just solve with radix sort
because my radix sort at this point
we've done it
it's our third time rate of sort we can
sort as long as
uh the integers are bounded by a
polynomial here it's a
fixed polynomial with constant exponent
so this will
and this is radix sort i like to saw
that just calls counting sword twice
uh linear time d is where things get
more interesting
let me get this phrasing same
so
v we have rational numbers of the form w
over f this is
win some win ratio
always in the range zero to one as you
say w is at most f
and zero is less than w is
some f is less than n squared because
the
that is really confusing it's less than
n squared those are separate statements
uh because the f actually comes from
part c c is really a set up for this one
um doesn't really matter what this means
it's just that we have
numbers w and f where w is always less
than f and they're between 0 and n
squared
so you should think this is a good range
for me right
that i'm representing this rational in
terms of two numbers between zero and n
squared so
there's like n to the fourth possible
choices for what w
and f are so the range of my values is n
to the fourth that's the setting
where rate of sort should run fast
unfortunately these numbers
what i want to sort by is not an integer
it's a rational
and that's annoying so there are
a couple of ways to solve this problem
uh
in general a good way to solve sorting
is to use merge sort workshop is always
a good answer it's not the best answer
in these cases we've we shaved off a log
we got to linear time
but n log n is pretty good it's pretty
close to n so
first goal might be can we even achieve
n log n via merge sort
what would i need to do in order to
actually apply merge sort to this
instance
what does merge sword do to its keys
sorry it isolates and compares them yeah
right so there's an array data structure
and it indexes into the array that's the
isolation
but then it the thing it actually does
with the items themselves is always a
comparison
this is why we introduced the comparison
model and proved an ad log and lower
bound
in the comparison model because merge
sort and insertion sort and selection
sort are all comparison algorithms
rated sort is not but this one is but to
run to apply merge sort i need to say
how do i compare w i over
f i versus
w j over f j
my computer only deals with integers we
can't
actually represent w i over f i
explicitly in
in binary because it has infinitely many
bits
but i can represent it implicitly by
storing wi and fi
yeah multiply by f i and fj yeah as
when i went i didn't go to school but
then we learned
cross multiplication uh so it's which is
the same as multiplying both sides by fi
and multiplying both sides by f j as you
said
so then we get f i f j less than
question mark uh f
whatever f i w j
uh when we do that we better make sure
that the things are multiplying by our
non-negative otherwise the sign flips
but here we assume they're all
non-negative
so this is good and now we're just
multiplying two integers here
multiplying two integers here and
comparing
those are all things i can do in a word
round okay
so this was actually the intended
solution when this problem was posed
here's a way to do comparison sort we
get n log n but in fact
you can achieve linear time yeah
uh i feel like there's a joke here like
pikachu is superior that's always the
answer
so how do i tell whether one pokemon is
superior to the other
if i i multiply
uh my i multiply i's
f value with j's w value and i see
whether that's greater than
i's w value times j's f value
and if it is so these are
equivalent if this one is greater than
this one i know that this is greater
than this
these are equivalent sentences by
mathematics by algebra
and so uh this is what i want to know
this would say j is superior to i
and so i determine that by actually
doing this
so then i don't have to divide and deal
with real numbers
because i don't know how cause i'm a
computer
[Applause]
we're all computers
okay uh
so it would be great if my numbers all
had the same denominator
if they all had the same f then i could
just compare the w's
so that's one intuition for why
we can actually do this in linear time
um
but the the way i like to think about it
so let's just draw
the real interval from zero to one
and there are various spots all over
here
um that represent i can't actually
compute this but conceptually each of
these wi over
fi's falls somewhere in that interval
from 0 to 1.
and i want to sort them somehow
so one thing that would be great is if i
could take these real numbers and
somehow
map them to integers
which are uniformly spaced maybe a
little a few more of them
but these go from zero to u minus one
if i could get u relatively small and i
could map
each of these so i want the mapping to
be order preserving
and i want two very close but distinct
items
to map to distinct keys here i want them
to map to distinct integers down here if
i could do that then i just sort by the
integers and that's the same as sorting
by
the real numbers and so at this point i
wonder
how close can two of these numbers be
so how close
can two keys e
so i want to consider w i over f i
minus w j over f j
an absolute value okay
now i do algebra um so this is
i'd like to bring this into one ratio so
this is
i can do that by multiplying one by five
one by f j
and it's w i f j minus w
j f i which should look a lot like
something here
uh but never mind so i'm sure there's a
deep connection here i could probably
use this to prove that
or vice versa cool so
with some absolute values same thing uh
maybe
these are non-negative so i can actually
just put absolute values on the top part
and okay wi is an integer fj is an
integer w j is an integer
f is an integer all greater than equal
to zero
so this thing is an integer
so uh it could be equal to zero it's a
non-negative integer because all the
things are non-negative
it could be equal to zero but if they're
equal to zero that's actually identical
ratios right if this is zero the whole
thing is zero and so
these two values were the same okay but
let's suppose it's not zero if it's not
zero it's actually at least
one an absolute value because it's an
integer
what about the bottom f i so now we want
this
i want to know how small this ratio can
be it's going to be small when this is
small
and this is big how big could fifj be
well we're told that all the f's are
less than n squared so this thing
is at most n squared n to the fourth
less than n to the fourth n squared
minus one
squared but less than n to the fourth
uh f i is at most n squared f j is the
most n squared
so it's n squared squared so this is at
least
one over n to the fourth so the the
closest the two points can get here
is one over n to the fourth so what
could i do
to scale that up to make them
kind of like integers multiply by n to
the fourth
so just multiply
by n to the fourth and then
floor so we're going to take
each fi over
i like to compute this ratio but i don't
know how so
instead i'm going to take f i multi okay
conceptually what i want to do is
multiply by n to the fourth and take the
floor
how do i actually do this
[Applause]
in a machine that doesn't have real
numbers like this
and so i don't have a floor operation
just have integer operations then i can
uh take f i
multiply it by n to the fourth
and integer divide by w j
that is the same that computes exactly
this
because i can do the multiplication of
the division in either order
uh in real space and then this does the
floor at the appropriate time but this
is just operations on integers
and now these are integers representing
how good my pokemon
are that have the property that any two
distinct ones
before i take the floor any two distinct
ones are at least one apart
so after i take the floor they will
remain one apart they will remain
distinct integers
and so i have successfully mapped my
real numbers to integers where distinct
real numbers map to distinct
integers yeah wait so why is fi now in
the numerator
did i flip them yeah sorry please invert
everything just here
this is w and f5 that was just a typo
that's all that okay
are they both i's or js
uh these should are supposed to both be
eyes yeah
thank you this was for each for each
pokemon i
we're going to compute this as our key
then we're going to sort by those
integer keys and that will sort the
pokemon by the ratios
[Music]
that's right for monster
uh so my u was just a sorry this is
uh a label on this thing can i help you
yeah
so uh now my u all right what is my u
how what is my largest key
occurs to me i really would like fi to
be bigger than zero
but yeah let's not worry about it
uh how big could you be well the biggest
this could be is if f
i is small and this is big let's say f i
can only go down to one otherwise i get
a division by zero
i have to deal with infinity especially
probably the problem isn't even well
defined then
uh how big could this be well i know the
w i's
i'm sorry defined as positive oh good
here's also a positive constraint here
just i failed to
preserve that constraint in my mapping
from the word problem into the formal
problem
so f is at least one good but let's
minim
worst cases when it's one and when wi
how big could it be well n squared minus
one
so this could be basically n squared
times n to the fourth divided by one
which is n to the sixth
so w is sorry u the largest key i can
have plus one
is n to the sixth but that's okay
because radix sort can handle any fixed
polynomial in n
so it's going to end up doing six
counting sort passes
yay that's problem three
let's move on
uh
so problem four mit has employed gank
freri
who's that
frank gehry yep this is a common uh
encoding that jason really likes
i've grown to like it
uh is this called spoonerism where you
replace some
some part of the beginning of your uh
thing okay that's one joke there's
another joke in this problem
uh anyway they're building a new wing of
this data center as one does
uh we have a bunch of cubes if you read
long enough you realize that's a red
herring that's
cubes do not play a role in this problem
in the end
what we have is a bunch of
integers which happen to be the side
length of the cube cubes but we just
care about the side lengths not their
volume or anything
s
n minus one
and we want two
numbers in s
summing to h
this is the side length not the number
of sides so you got a cube
cool i didn't know we'd be doing 3d
geometry today ssi
okay so you've got little cubes you've
got big cubes
okay this is the smaller side it's the
biggest eye doesn't matter though
they're just numbers
okay we're not using them at all in the
problem you're trying to like stack one
cube on the other but
all we really care about is two numbers
who's whose sum
regular old sum is exactly h ideally
there's going to be two versions of this
problem
and so first goal is to solve this
exactly
in linear expected time
that's what the problem says so
what do we know well linear time that's
can't get much faster than that because
we need that just to read the input
expected time hashing
right we're told basically we should use
hashing now if we're really annoying
maybe we throw that in even when you
don't need it but
that's pretty rare uh so when we see
expected we should in a problem set
setting like this in real life you never
know what you should use but in
our and was your learning in this class
we're going to tell you basically
what tricks you're allowed to use here
you're allowed to use randomization so
probably we need it
indeed you need it to achieve this bound
ah
cool
not obvious how to approach this problem
with hashing so i'm going to give you
uh the way i it's it's hard for me to
not know this algorithm
but um to me the first thing you should
think about is if if i have linear time
and n things and i'm going to use
hashing
the obvious thing to do is to take those
n things and put them in a hash table
build why not uh so let's just
build a hash table
on all the keys in s
that's idea one
seems like the first thing to try so
what does that let me do
it lets me i just erased the interface
for hash tables but
i can build a sequence out of it but
normally it gives me a set interface
so i can call find now in constant time
it lets me given a number
determine immediately whether that
number is in s
well that sounds interesting because i'm
looking for two numbers in s
so it lets me find one of them so i call
it twice
no uh calling it twice and only spending
constant time on this beautiful data
structure will not give you anything
useful
but we have linear time right so in
addition to building a table
we could call find on that table a
linear number of times because each find
only takes constant expected
amortized time so if i do n of them that
will take
linear expected time the amortization
disappears because
i'm using it 10 times all right find
never has amortization so
it doesn't disappear because it was
never there never mind
i can afford n calls or five n calls
to find because each one costs constant
constant expected
and the total for that will be linear
time so next idea
is let's just somehow call
find
a linear number of times
okay okay uh so i want to find two
numbers
summing to a given value h that wasn't
maybe clear but h is given
sorry um how long does it take to build
the hash table
how long does it take to build a hash
table it was previously on this board
linear expected time
see previous lecture
no two lectures ago ah okay
well if we're gonna do this linear
number of times i guess we should have a
for loop
let's do a for loop over the numbers
this next idea
loop over s
and at this point we're done almost um
space so i want to
loop over the numbers and each one i
want to do a find that's
kind of all i have time to do so
seems like a natural thing to try this
this is by no means easy
don't don't get me wrong having these
ideas is well
i'm explaining them as the obvious ideas
they're not obvious
but uh they are easy at least
just not obvious to come up with the
easy ideas so let's loop over s
somehow called find using our hash table
so the order is actually we're going to
build the hash table
then loop and inside the loop we're
going to call find once per loop
iteration so let's do it let's say
for uh s-i-m-s
so i want to find two numbers here i've
exhaustively
looped over one number i just need to
find the second number that could
possibly
add up right i want to find
whether there's an sj in s
such that
s i plus s j
equals h
can i do that query with find
oh
so what what does find do find says if i
give you a key
it will tell me whether like if i knew
what sj was
i it would tell me whether it's in s
subtract h from s i and see whether that
exists
okay get it right h minus s-i let's
get wrong
i don't feel bad that you also got it
wrong makes you feel better because i
always get it wrong
so a claim is this why because what we
want to do
is find well
okay let's write see what it says over
here so if we do h
minus s i equals sj
right so these are equivalent statements
just by
moving the si over and this is a query
we can do
we don't so let's remember these are
things we know
and sj is something we don't know
although we know is that it's an s
okay so we know these two things so if
we bring them over to the same side
we're searching for an unknown thing
which is equal to exactly this thing
that we can compute
so we just compute h minus s i we call
find that will tell us whether there is
an sj
equal to this okay so this is
this is like a comment all right and
then this is what we actually do
and if there is a pair of numbers
summing the h this will find it
how much time did it take well we're
doing n iterations of this loop
each one we're calling a single find
operation and
find cos constant expected time
and so the total is linear with respect
to time
great part a done
then they throw part b at us to make it
harder
those pesky instructors
so we read part b and part b
says two things to make it harder
so first of all we want linear worst
case time
and furthermore so we can't use hashing
anymore
furthermore uh so here we just needed to
solve the exact problem to find whether
the two numbers summing exactly to h
now we would like to find the best
solution smaller than or equal to h
so find biggest
pairwise sum
that's less than or equal to h if no
if there's no perfect pair but we're
given
a little bit of extra information
which is we can assume h
equals 600 n to the sixth
it's a weird polynomial it took me a
while to even notice that that was jerk
in here
6006 hiding in a polynomial
all right so polynomial
that should make you think radix sort it
is radix or weak
so that is a natural thing to try but in
general even later in the semester when
you see
uh a nice polynomial with a fixed
constant like this
and it's somehow related to the integers
we're dealing with you should think
radix sort especially because now we
want constant worst case time
rate of source seems like a good thing
to do don't know what to do with it yet
in fact
i can't even apply radix sort but idea
one
is radical just because i see that
polynomial
i think maybe i should try it
now there's a problem here because we're
given some numbers
we're all some integers s i's we're also
given h we're told now that h is a nice
small polynomial
we have no idea how big these numbers
are
so problem with this idea is that um
when s i could be bigger than h we we
have no idea how big
the s i's are can i
what can i say about s i's that are
bigger than h
for this problem
summing to h oh i didn't say but all
these numbers are non-negative that's
important
that looks like korean
greater than or equal to zero
yeah well they can't be a solution right
if i'm finding a sum that's less than
equal to h they're non-negative
uh and any number any number that's
greater than h
i can just throw away they'll never be
in a solution
it's like already a single sum of one
numbers here than h so two is only going
to get bigger if they're non-negative
so let's idea number two is let's just
throw out all the big sis
anything bigger than h now that won't
change the answer because those can
never be in a solution
and now i have all the sis having the
property that they're less than or equal
to h
and so they are small
bounded by a fixed polynomial and now i
can apply radix sort so after this idea
i can apply this idea
okay this gives you a flavor of how i
like to think about problems
i see clues like polynomial i think
radix sort
doesn't work but with some more ideas i
can get it to work
okay uh what good is it
so now i've sorted si okay great s
is sorted
i guess we can try to do the same
algorithm
except i don't have a hash table anymore
so let's just
try doing a for loop over the s
why not so let's do 4
s i and s but now it's sorted so
presumably i should exploit the
sorted order so let's do do them in
order so i
equals 0 1 up to n minus 1.
let's say that s 0 is the smallest s 1
is the
next smallest s n minus 1 is the biggest
so i want to do something with this so i
have s i and i want to figure out
whether h minus s i is in there
hard to do that better than ah
actually i could do this with binary
search right
i know i'm looking for this value so i
could
and i have a sorted array now so i could
binary search for h minus si
and in login time i will find whether
that guy is in there
and if not keep looping i can keep track
of the best thing that i've found
and so in n log n time i can definitely
solve this but i'd like to get
linear time okay good question
i'm not looking for s i i'm going to
compute h minus s i
so so this is maybe i shouldn't even
write this down
right so in particular if um
if there are two items that sum to h i
want to find it
so uh so let's start with that so i'm
binary searching for
h minus s i in s so i could certainly do
that
and um if i if i find it great i found a
pair that sums to exactly h if i don't
find it
binary search tells me not only that
it's not there but it tells me what the
previous
and next value are so even though h
minus s i isn't there i can get what the
large
the next largest thing and the next
smallest thing what i want is the next
smallest thing
and that will be the largest sum i can
get using s
i and so then that's one candidate
for a sum let's equal to h i want to
find the largest one so i do a for loop
i always keep track i take a list of all
the candidates i got each time i do a
four
iteration of this loop i get one
candidate then i take the largest one
okay so return largest candidate
so this gives me a candidate
which is uh the previous item this is
what we called
find previous or find prev probably in
our set interface
and if you have a sorted set you can do
that in log n time so this is an n log n
solution
i want because we do n iterations for
the loop each binary search takes log n
i want to get linear this
is not obvious
the best intuition i can think of for
this next idea is
well i start with a very small
smallest item in s and i want to sum up
to something that's kind of
big i threw away all the items bigger
than h
if i start if s zero is like tiny like
close to zero
because it's the smallest one then maybe
i should look at the
end of the array because i want to
compare or i want to add the smallest
thing probably with the biggest thing
that's as close as i can imagine uh
so then
so here's my sorted s this is the
smallest item biggest item
so i'm going to loop over these items
one by one
so let's start by comparing the first
one with the last one
the two-finger algorithm okay
this is the big idea you're doing it all
the time in this class it's super useful
we saw it in merge sort for example and
merging two lists
we have fingers and two lists that
advance and because they only advance
it takes linear total time so we're
going to do this kind of folded and
backwards here we're going to start here
this seems like a good candidate to
start with now what else could this add
with well maybe smaller items and
maybe i have to go all the way through
here and then i've got to advance my
left finger
yeah okay so uh here's the idea
so um let's look at
so i'm going to call this finger i this
finger j
so we want to sum two things so i guess
another inspiration here is
we want to add two things up and we have
one algorithm that has the word two in
it and it's the two finger algorithm
so let's try that um so we're gonna
start with i equals zero and j equals n
minus one
we're gonna look at s i plus s j
and see how good it is it how close to
summing to h is it
well in particular it's either less than
or equal to h
or bigger than h
if it's bigger than h so this sum is too
big
i can't even use it as a candidate well
that means
i really don't need this guy right it's
too big overall this is i'm adding the
smallest item
to this item and it's too big well then
i should go to the left i should move my
right finger to the left
so in this case uh we decrement j
move the right finger to the left so i'm
guessing in this case i'm going to
increment i
why if i add these two items up
and this is too small smaller than h
then this item was
probably too small it might actually
it's an okay solution it's less or equal
to h so i should keep it as a candidate
um let's say add
candidate so i'm just going to keep a
list of candidates
that i see so this is a possible
solution it might not be the best one
but it's one to add to my list
and then i'm going to increase i and now
work with on this sub array
because that will be a little bit bigger
i can't go this way to make it bigger
because i'm at the last item
and it's not obvious that this works i
think there's a nice invariant
that will help
somewhere wherever i put my piece of
paper
here's an invariant
oh yes
it's really clear this is the right
thing to do in the first step and the
tricky part is to argue that it works in
all steps
because when i really have the smallest
item and the smaller and the largest
item it's clear that i should advance
one or the other
i'm too small or too big but the way to
prove it in general by induction
is to show this invariant that so it in
at some point through this execution i
and j
are somewhere and i want to say that if
i take any j from the right
any j prime to the right of j and any i
prime to the left of i
unstrictly then all of those pairs all
those pairwise sums
are either too big and that's when we
decrease j
or they're less than or equal to the
largest candidate that we've seen so far
that's because we add these candidates
in there so
this that invariant will hold by
induction because whenever there's a
possible thing that's
good i add it to my candidate list and
then at the end of the algorithm i just
loop through my candidate list compute
the max return that pair
okay so that is two-finger algorithm
which solves the non-exact
problem in linear worst case time yeah
oh i cannot right so what are the
termination conditions when i
equals j that's probably when you want
to stop it depends you could say
if i is greater than j stop
uh return max candidate uh it's
there are two ways to interpret this
problem one is that the two values you
choose in
s need to be different values or you
allow them to be the same value like
they can both be h over two
and either way is easy to solve if you
if you want to allow
s over 2 then i would put greater than
here if you don't want to allow
h over 2 then i have a greater than or
equal to
either way both both of these problems
you can solve both ways or both
algorithms can handle both situations
okay one more problem
all right yeah a lot of time
but i'm getting faster and faster so of
course on the hardest problem i can do
it the fastest
all right so jet so meh
jah this is a reference to jeff ma
of the mit blackjack team who i got to
see speak here at lsc
a bunch of years ago but he's featured
in the movie 21 and so on
fictionalized um
so as playing this game it's great great
great setup you should definitely read
this problem
uh po k er
and he has a deck of cards where each
card has a letter of the alphabet on i
get this
the right way up so i of course have
such a deck
doesn't everyone you can buy these i
have several actually
um and so we can do a quick magic trick
like uh pick a card any card here pick a
card
okay oh good choice i can't force so it
doesn't really matter
okay and uh so this is your card
right and your card is an s right
okay good okay no not all the cards are
s's
but he has mirrors in his glasses no i
can reveal later how that's done
um okay so a deck of cards each card has
26 possible letters on it and
uh there's this weird dealing process
even just defining this problem it's
going to take a little while oh here's
my piece of paper
so we have this dealing process here's
an example
it's in the problem a b c sorry
d b c so that you know the order of the
cards this is the top card this is the
bottom card
and now randomly you do a cut
cut is this right so i take some chunk
off the top
move it to the bottom once randomly
so for example i could take this cut
and then what i would get is cdbc
for for this part
that's copied here and a b
that's the so this is so the first thing
we do is cut
at i this is position i
this example i equals two
okay then we deal the top
k cards so uh let's say we deal
the top four cards k equals four so this
is uh
dl k so we get cdbc
in that order but the order doesn't
matter because the last operation we do
in the problem is sort them
which is b c c d
okay like you do when you get a hand of
cards you tend to sort them
okay so this is a process given a deck
so the deck here is
fixed uh we call this
process i think p of d comma i
comma k we're told what d is we're told
what k
is i is chosen randomly
and we'd like to know what happens with
different eyes
so so if you start this problem enough
it begins to simplify this is a
complicated setup
but what's really going on is we're
starting at position i and we're taking
the next k cards from there
cyclically so here we just took those
four if i equaled three would deal d
then b
then c then a but then we sort them
okay so we're getting different
substrings of length k cyclically
but uh then we're sorting those letters
sorting is really crucial for this
problem to at all be feasible
it took me a while even to see how to
solve this problem but the key is
sorting
that they get sorted because
that means because we sort it doesn't
matter whether you have a
a b a
these are all the same if you take these
cards dealt
you sort them to the same thing which is
the one i didn't write
a a b all these get sorted to the same
thing
so we lost some information when we sort
lost the order
the first question to get you thinking
in this direction
part a says build a data structure given
d
and k that lets you lets me know
given two indices i and j do i
end up with the exact same hand this
thing is called a hand
and it's exactly this pdik
so i want to do p d i k and p d j
k and i want to know j k and i want to
know
whether those two things are equal in
constant time that's what this says
constant time doesn't say worst case but
worst case is possible
uh and that sounds hard because i mean
there's k symbols for one of them
another k symbols for the other guy
but we don't have to compare the symbols
we just need to compare
the sorting of those strings and this we
can compress
so this is a subtlety but what i really
need to know is that there are three a's
here
and one b and zero c's
and zero d's and zero e's and so on
but uh because there's only 26 letters
in this deck and indeed in this deck
happens to have upper and lower case a
through z but
we might have n cards but they're only
26 possible labels so in fact a lot of
them are going to be equal if n is large
so this is a good compression scheme
because i to represent
the things i get after sorting i just
need to give you 26 numbers
and for us 26 is small because 26 is a
constant
independent of the number of cards i
just need to say how many a's are there
could be anywhere between 0 and
n how many b's are there between 0 and n
how many c's are there between 0 and n
so 26 numbers
in the range 0 to n
i like to think of this as a 26 digit
number base n plus 1.
we can map this into base n plus 1
and we get 26 digits
in that base another way to say it is
that the number of
possible uh combinations here how many
a's how many b's how many c's
is um not even theta it is
n plus one anything between zero and n
uh to the power 26.
this is a good polynomial
so i can do stuff
like radix sort
cool so let me summarize a little bit
how we solve part a
so i want to build a data structure
which is
for each value i i know i'm going to end
up serving these four
cards or in general k cards so for those
cards i would like to compute
um how many a's how many b's how many
c's are there and then just write down
this number this is a number which i can
write down in at most 26 words
because we can represent numbers between
0 and n in a single word
that's the wb's at least login
assumption uh
so it's constant size in a constant
number of numbers
i can represent all i need to know about
a thing of size
of length k here because i don't need to
know the individual which
letter is where just need to know the
sorted order so i just need to know this
is called a frequency table
how many a's how many b's and so if i
can compute those
then given that representation for
starting at i
and given that representation for
starting it j say which would be these
two and these two
i can compare them by just comparing
those 26 numbers
they're all equal then they're the same
string after sorting
and if there's any difference then
they're different so that's how i could
do it in constant time
if i can compute these representations
and it's not hard to do that you
it's called a sliding window technique
where you compute it for the first
k guys and then you remove this item and
add this item
into just by incrementing the counter
for b decrementing the counter for a
now i know this the representation for
these guys
make a copy of that which is a copy of
those 26 numbers constant
then i add on c remove b then i add on
a remove c add on b
remove d add on c remove b
and add on d and remove c
i got back to the beginning so now i
have representation of those
okay so i by sliding this window i'm
only changing
at the two ends i add one guy on i
increment one of these counters
i decrement one of these counters so in
constant time
given the representation of one of these
substrings i can compute the
representation
of the next one that's how in linear
time can build such a data structure
that
lets me tell whether any two hands are
equal
the next problem part b is given all
these representations
can you find which one is the most
common because we're choosing i
uniformly at random i want to know what
the most likely
hand that you get is and i think the
easiest way to say this is you can do
that by radix sorting
you take all these representations they
are nice numbers in the
range 0 to n plus 1 to the 26th power
so i can just run radix sort and sort
them all and then do
with a single scan through the array i
can see which one is the most
common or rather i can in single scan i
can compute
okay how many of the same things are at
the front they're sorted then
all the equal ones will be together so
how many are there then how many
equal ones next and how many forms
before this next each time comparing
each item to the previous one then i get
frequency counts for all of these
uh hands and then i do another scan to
find the most common one
and i can do another scan to find the
lexically best one because that's
lexically
last one and that's how you solve
problem five