okay team Let's
uh get started for the day uh it's a
pleasure to see all of you guys uh in
case you don't remember I'm Justin I'm
the third instructor of6 that you
probably forgot about uh but you're
going to see a lot more of me in the
graph theory part of our course because
that's the part of algorithms that I
like if I were reincarnated as a
theoretical computer scientist I would
probably go into this area hey guys okay
uh you know we have our our PhD admit
visit days coming up for the next uh
couple days so I'm working on my like
Camp counseler cheerleader voice so you
know don't make me uh wake all of you
guys up for the day you're not going to
like it uh but in any event uh right so
in in 66 if you look back at the course
outline we're officially starting part
two of this class uh there are a few
corollaries uh to that fact uh so unless
there any questions about that we'll get
started with our our new unit in 66
which is a graph theory if you're
wondering there's a graph on the the the
screen here uh but of course we'll fill
in uh a little bit more information
today uh throughout our lecture when I
was learning how to teach which I'm
still doing
um one of uh actually my PhD adviser
told me like if you want somebody to
learn something you have to write it as
big as possible and so I'm I'm really
leaning into that that approach today uh
in our our slides so in any event uh
right so today we're going to have our
first lecture on on graphs which I think
will somewhat be a review for many of
you guys and if it's not that's cool too
uh because we'll start from the
beginning and kind of build up all the
Notions that we need to understand and
process graphs and hopefully by the end
of lecture have some style of algorithm
for computing the shortest path from one
vertex to all the other
ones so in case we forgot a little bit
terminology a graph some people call
this a network but sometimes that term
is overloaded with a few different kind
of variations on the theme uh is a
collection of two things right that's
what this this parenthesis notation
means there's a set of vertices and a
set of edges right and the edges uh like
you can see in the sort of third point
on our screen here are a subset of V
cross V now this is fancy notation for
something really really
simple right because what is this
telling me this is telling me that an
like in the picture that we see on the
screen here it's just something that
connects two vertices
together right so if I think of there
being a pair of vertices like the from
and the to right then that is a subset
of the cross product of v in itself
right so hopefully the notation in that
third line on the screen makes some
sense this is just fancy notation for
edges or pairs of vertices but of course
inside of that notation there are two
special cases that we care about uh in
this this class uh one is is when you
have a directed graph and one is when
you you have an undirected graph gu I
said them in opposite order from what's
on the screen right so in an undirected
graph I guess we still think of an edge
like a pair of vertices but really I
should have notated this slightly
differently in fact maybe I'll I'll
revise it in the slides before uh they
go into ocw where instead of writing E
equals uh W comma V I should write in
fact equals V comma W and notice that
there's a slight difference between the
notation on the slide and what I've
written on the board which is this set
notation here what's the difference
between parentheses and squiggly lines
is that this guy is unordered this is a
set of things and what's on the board
it's ordered right or or what's on the
screen rather and of course in an
undirected edge there's no such thing as
an edge from W to V being distinct from
an edge from V to W those are the same
thing right they're undirected it's just
is a notion of connectivity whereas in a
directed graph now we're going to use
that parenthetical notation to say that
the Edge from W to V is different than
the Edge from V to W that's going to
make a big difference so for example uh
in the graph on the right let's maybe
redraw it uh on the board here so we
have four vertices I drew this last
night and I'm hoping that this example
actually works
uh uh like
that can I get from the upper right
vertex to the lower left vertex
following edges in this graph
I heard one person everybody on three
one two three no right because if I
wanted to I mean maybe I think of
drawing this path here but of course if
I go from the upper right to the lower
left this is like the ugliest thing I've
ever drawn I'm so sorry uh you notice
that the edges are pointing in the up
Direction here so I'd have to go kind of
against the stream of the water but
that's not allowable in the directed
graph case of course I'm already
anticipating the notion of a path which
we haven't really defined yet but I
think intuitively that's sort of the the
the big difference between a directed
and undirected graph does that
distinction make sense to all of yall or
have I managed to lose you in in in four
minutes or
less
excellent so I flipped things a tiny
tiny bit from the course notes because I
figured we'd Define what a graph is
first before telling you what the
applications are uh but in in in any
event I think it's really not a big
stretch of the imagination to say that
grass are like literally everywhere in
our our everyday life right anytime that
we come up with a network of stuff
connected together implicitly the right
abstraction often in in the back of our
heads uh is to think about a graph right
so some simple examples that I think
would all come to mind for us would be
like computer networks right so the
nodes or the vertices of your graph uh
in that case maybe are computers and
then the edges are roughly the the
cables connecting them together in my
very coarse understanding of how
networks work uh or or maybe in a social
network you know the nodes are uh people
in your social network and the edges are
like friend relationships or like you
know friendy relationships or or or
whatever uh in fact I think you could
think of both directed and undirected uh
versions of that particular uh
network uh you know in Road networks
maybe you know I'm I'm working for
Google and I want to tell you the
shortest path between your house and MIT
of course uh in order to do that and
essentially behind the scenes we're
solving some version of computing the
shortest path between two vertices in a
graph
that's a tiny bit of a lie in the sense
that there's a lot of structure in that
problem that we're not going to leverage
uh in this course right a road network
is a very special type of graph uh and
if you take an advanced course maybe
you'll say like well if I know a little
more about my graph I can do better than
the general case we'll talk about here
uh but the basic algorithms that we'll
talk about in 66 are certainly relevant
in that case and are really the building
blocks for what goes on and in in the
tools that are used every day on your
phone when you open Google Maps or ways
or or whatever
and of course there's there's many
others right so for instance an example
uh that maybe is a little bit more
subtle would be the set of states and
transitions of of a discrete thing so
think about like a Rubik's cube right so
I could make a graph where the node is
every configuration of my Rubik's cube
right like every rotation and then the
edges are like can I get from this
configuration to that one by making one
simple transition like one F flip I
don't actually know the terminology in
Rubik's Cube I have a feeling you do uh
for one rotation
twist thank
you and of course there are many other
places so for instance uh you know my in
my my day job here at MIT I typically
teach computer Graphics courses and
actually graph Theory although we talk
about it very differently appears in
that world constantly uh because of
course what's sitting behind any 3D
model on your computer is a giant
network of of triangles this is called a
triangulated surface like this Taurus we
see here uh and this is nothing more
than a graph and in fact if you squint
at the algorithm that we cover in 6838
you'll see that they're roughly just
graph algorithms in Disguise uh in fact
if you take my graduate course one thing
we'll do we'll spend a lot of time doing
differential geometry and then we'll
step back 10 feet and notice that
exactly the algorithms we were using for
like Computing all you know curvature
and bendiness on on triangle meshes just
looks like a graph algorithm and can be
applied to to networks in exactly the
same way so it'll be a nice kind of fun
reveal uh there and of course as one uh
last kind of fun application um I
actually was gone the last couple days
at a conference on political
redistricting and the funny thing is
most of the discussion at that
conference was about graph Theory uh and
and and the reason for that uh is sort
of a theme that shows up a lot in
Geometry World which is if I take my
state in this case I think these are the
voting precincts in some state or
another uh and I look at adjacency
relationships then maybe I put a node
for every Precinct and an edge anytime
that they share a boundary with one
another well now I have a network and
and maybe a region on my graph is like a
connected piece of of of this this
network uh and so anyway this is one of
these examples where graphs and networks
and connectivity and so on just show up
literally no matter where you go they're
totally unavoidable uh and and so that's
what we'll be spending quite a bit of
time on uh in this class
here now you could easily take I would
argue at least three entire courses on
graph Theory uh here at MIT uh and you
could easily build a PhD uh a doing
nothing more than really simple problems
on graphs uh of course in this class
we're we're we're limited to you know
some some just a few lectures out of
many uh so we're going to make a couple
assumptions both on the problems we want
to solve uh as well as on the graphs
that that we care about uh so in
particular uh one simplifying assumption
which actually really doesn't affect
many of the algorithms we'll talk about
here but is worth noting uh explicitly
is that we'll mostly be thinking about a
particular type of graph which is a
simple
graph uh and in fact often depending on
how you define your graph you kind of
accidentally made your graph simple uh
even if you didn't intend to so for
example uh we wrote that our edges were
a subset of V cross V uh which maybe
means that I can't have uh multiple
edges that uh you know sort of trans
Traverse the same pair of vertices
so let's see an example of a graph that
is not simple so sorry I haven't
actually defined it a simple graph is a
a graph that has no self Loops so I
can't go from a Vertex to itself
and every Edge is distinct so let's uh
make the most nonsimple graph we can
think of like let's say I have two
vertices uh so maybe uh if I want to
make my so there's a graph right two
vertices in one Edge this is simple if I
wanted to be annoying and make it not
simple maybe I'd take this Edge and I'd
like duplicate it three times just for
for fun uh that violates the second
assumption and now to make it even worse
I could violate the first one by adding
an edge that goes from this vertex to
itself this is
not
simple I don't know what you would call
it actually General graph I guess
complicated because it's not simple I
don't I don't know uh yeah a multi-graph
I always thought of that as something
anyway it doesn't matter uh but in any
event in this class we're not going to
worry about this particular uh
circumstance and of course in many
applications of graph Theory that's
totally reasonable assumption to make
any questions about definition of a
simple
graph okay so from now on whenever we
think about a graph in the back of our
head we're going to think of our graph
as simple there's one nice property that
a simple graph has which I've written in
really big text on the screen here which
is that the edges are Big O of of of v^2
and in fact let's uh let's expand that
formula just a tiny bit so there's sort
of two cases uh right one is when my
graph is undirected the other is when my
my graph is is directed yeah um so if I
have a directed
graph well let's think about how many
edges we could possibly have right so an
edge is a pair of a from vertex and a
two
vertex right and I can never repeat it
twice right that's that's sort of like
the uh the second assumption here right
so in particular what do we know know we
know that mod e or rather the number of
of edges in our graph is upper
bounded by what
well I can take any pair of of
vertices like that but I have to be a
little bit careful because my graph is
directed right so from and to matter
here so this is is V choose two is
saying that I can take any unique pair
of
vertices but I have to put a factor of
two in front of it uh to account for the
fact that the source and the target can
be flipped back and forth and of course
if I want to do the undirected I don't
have to worry about
that right we'll get e here is less than
or equal to just mod V choose to right
so this is just a fancy uh way of saying
that every Edge consists of two vertices
and my edges are unique and one thing if
you just write down the formula for uh
our our binomial coefficient here as
we'll see that both of these things
oops oh yeah
s our at worst mod V uh Square
here and that makes perfect sense right
because of course an edge is a pair of
vertices you kind of expect there to be
a square
yes I'm so sorry I can't hear you sorry
so the two comes from the backr it's
from the swamp
yes exactly so the the the two uh for
the directed case comes from the fact
that an edge from V to W is different
than an edge from W to V right so
remember that the binomial uh
coefficient here is just counting the
number of ways that I can choose two
things from a set of size V but it
doesn't care about ordering yeah any
other
questions fabulous so why is this going
to matter well these sorts of bounds I
mean they might seem a little bit
obvious to you but we're going to write
down graph algorithms and now when we
analyze the runtime and the space that
they take we now have like sort of two
different numbers that we can think
about right the number of vertices and
the number of
edges right and so for instance if I
write down an algorithm whose runtime is
proportional to the number of edges
maybe then generically I could also
think of the algorithm uh as having a
runtime that looks like the number of
vertices squared unless I put some
additional assumptions on my My Graph
right and so there's some connection
between all these different constants
and it's useful to kind of keep that at
the back of our head that sometimes
you'll see a bunch of different
expressions that really are encoding
roughly the same relationship just in
different
language of course that also means that
we can be more precise right so
sometimes uh a graph is what we would
call sparse so in my universe almost all
graphs that I deal with in my day-to-day
life are extremely sparse this is a
consequence of of topology uh and and
because of that an algorithm that scales
like the number of edges might actually
be much preferable to an algorithm that
scales like the number of vertices
squared because in practice often there
fewer edges than like every single
possible pair right uh and and and so
that's the sort of reason why is worth
thinking about these
numbers okay so let's continue making
boring uh definitions here uh so some
other ones that we should think about uh
involve the uh topology or the
connectivity of our graph uh in
particular thinking about
neighbors right so in general we kind of
think about uh pairs of vertices as
being neighbors of one another uh if
there's an edge between them we have to
be a little bit careful uh because of
course uh when we have a directed Edge
we have to be careful who's on the sort
of giving and the receiving end of this
this neighbor relationship yeah so let's
draw a really really simple graph so
here's vertex zero here's vertex one
here's vertex 2 and maybe we'll have an
edge going up Edge going down and then a
cycle
here okay now we can define a lot of
different Notions of neighbors like the
outgoing neighbor set the incoming
neighbor set uh and and the basic idea
here is that we want to keep track of
edges going from a vertex and edges
pointing into one yeah so for instance
the outgoing neighbor set which we're
going to uh uh uh notate as adj plus
here what is the outgoing neighbor uh
set of uh node zero here well if we take
a look notice that there's one Edge
going out of node zero and it points to
node two so of course this is set which
just contains one other node
and
similarly the incoming neighbor set of
node zero well notice that there's one
incoming neighbor from vertex one so
that is a set like
that now of course in an undirected
graph uh the sort of distinction between
these two uh things doesn't matter so if
you look at our final uh bullet point
here uh often in the undirected case we
just drop that plus or minus superscript
because it sort of doesn't matter yeah
uh in any event there's one additional
piece of terminology that matters quite
a bit which is degree and this is
nothing more than just counting the size
of this set right so the out degree is
the number of edges that point out of a
Vertex and the in degree is the number
of edges that point in so notice in in
this case both of those numbers are are
one uh let's see an example where
they're not so in node one notice
there's two edges that come out so the
out degree of of node one is two there's
one Edge that points in so the in degree
is
one okay so often why why are we going
to do this well we're going to write a
lot of graph algorithms that like have a
for Loop over the neighbors of a given
vertex uh and then this this degree
number is going to come into play um is
worth uh bounding these things just a
tiny bit so uh in
particular one thing we could think
about I write too big and I'm going to
run out of space really quickly here um
is the following so let's take a look at
all of the possible uh nodes inside of
my graph and now let's sum up all of
their
degrees right so like I'm going to let's
see if I look at this graph you know
then notice there's you know there three
Al uh three edges adjacent to this
vertex here three edges adjacent to that
one two adjacent to this so I sum them
all together so is a convenient bound to
have around uh is to sum these things
because we're going to have algorithms
that look like for every vertex for
every neighbor do something so we might
as well know kind of roughly how much
time that's going to take um let's think
about this so what do we know in an
undirected graph every Edge is adjacent
to two
vertices right so if we think about how
we account for
degree what do we know well we know that
an edge sort of contributes to the
degree of two different
vertices right
so if we think about it uh carefully
here what we're going to see is that uh
if our graph is
undirected oh oops
sorry is that right wait I'm backward
again so if I have a graph with two
vertices and one Edge and it is
undirected notice
that the number of edges here is is one
what is the the sum of the
degree well it's 1 + 1 equal 2
yeah so there's a two here if uh my my
graph is
undirected and E if my graph is
directed if what I'm counting is just
the outgoing
degree that Mak sense I think I managed
to totally botch that sentence so maybe
let's let's try that again so if I'm
counting just the number of edges
pointing out of every vertex and I count
that over all of the possible vertices
then there's two cases right one is
directed and one is undirected right so
in the undirected case you get a two
here because essentially every Edge is
simultaneously ingoing and outgoing
whereas you get a one as a coefficient
in the directed case that make sense I'm
sorry I botched that for a
second okay excellent okay so that's
going to be a useful Bound for us uh
later on now we think about graphs of
course we just spent the last couple
weeks thinking about data structures we
should think about how to store a graph
on a computer and there's many different
options uh in fact uh really one thing
that you can do is sort of pair just
like when we talked about sets uh right
there are many different ways to store
sets and and one way to think about it
was depending on how we're going to
interact with that set we might choose
one data structure or another to sort of
optimize the uh types of of of
interactions we're going to have with
that set and make them as fast as
possible there's exactly the same story
uh for a graph
right so for instance the world's
dumbest representation of a graph would
be to just have a long list of edges
right so for example uh for this graph
uh up here maybe I have you know 01
that's an edge and then 0 two that's
another Edge and then one two and then 2
one there's a big list of edges really
set I don't care about the
order first one is one Z One Z oh you're
right I'm sorry yeah the edge points up
thanks Eric or not Eric
Jason okay so let's say that I have a
graph algorithm and I'm going to have to
do something like check whether there
exists an edge from V to w a bunch of
times how long is that going to take in
in this data structure well if I just
have like a hot mess disorganized list
of edges and I want to know does there
exist an edge from V to W All I Can Do
Is Write a for Loop that just goes along
this set and says like is this Edge what
I'm looking for no is that the edge I'm
looking for no right so every single
time I want to find an edge it's going
to take me time proportional to the
number of edges in my graph which could
potentially be up to to V squ yeah so
this is not such a great representation
of a graph on my
computer right so if we're thinking back
at our our data structure we might say
okay so an edge list is probably not the
way to go although notice that the way
we notated like what is a graph kind of
looks like an edge list uh but in any
event uh the the the more common thing
to do is to sore something like an
adjacency list so uh right so the basic
idea of an adjacency
list is that what I'm going to
store uh is a
set that
Maps a
Vertex U to everything adjacent to
you right so in other words I'm just
going to keep track of all the outgoing
edges from every vertex
and now I have to decide how am I going
to store this
object and often times we're going to
have to answer queries like does there
exist an edge from V to W right so how
could I do that first I would look up V
and I get back sort of a list or set of
of all the things that are adjacent to V
and I have to query that thing and I
want it to be pretty fast so maybe what
I do is I
store uh the set of adjacent
stuff as something like a uh direct
access array or a hash
table um to make that look up uh
fast so for example uh how long would it
take I see I'm going to finish the
sentence here uh how long would it take
me to check if an edge exists in my My
Graph well what would I do I would first
pull out this object and then I look
inside of here right so if I stored this
as a hash table than an expected time I
would have order one look up right
because this is order one and then you
have another order one look up there so
we went from v^2 to to one with one
simple trick
yes that's a great question um so
there's a design decision here I'm sorry
in my head I think a lot about
undirected graphs and I'm going to make
this mistake a lot and I'm glad that you
caught me um there's a totally
reasonable thing to do which is maybe
just to keep track of the outer edge the
outgoing edges for every vertex this is
a design decision for an algorithm
maybe I want to keep track of the
incoming edges what whatever I just have
to make sure that it aligns with what I
want to do with my graph later yep
excellent point sorry as as a geometry
person we rarely encounter directed
graphs uh but it's important to keep
remembering that not everybody works on
the same problems that I
do okay um now if I wanted to be totally
extreme about it uh as as just a third
example of representation which actually
in some sense you could think of like an
adjacency list be an adjacency Matrix
where now I just keep like like a giant
v byv array of like does this Edge exist
Does that edge exist um now it's really
really easy to check if an edge
exists but now let's say that I make a
graph algorithm that's going to have a
for Loop over all the neighbors of some
vertex right so
here that if I wanted to Loop over all
the neighbors of you I could do that in
time proportional to the number of
neighbors of
you but if I just have a big adjacency
Matrix just a bunch of binary values
like for pair of vertices are these
vertices adjacent yeah or nay if I want
to iterate over all my neighbors now I
have to iterate over all the vertices
and check is that number one and then do
something so actually that can incur
some additional time and additional
space does that make
sense so in any event that's a sort of
the Lazy Man's graph representation I
use it a lot when I'm coding uh because
adjy matrices are easy to work with but
it does incur a lot of additional space
uh and it's not always the most
efficient thing even if you have the
space because iterating over neighbors
is actually can take quite a bit of
time okay so the the real point of our
lecture today uh is to start introducing
sort of the canonical problem that we
all worry about on graphs which is
Computing paths in particular shortest
paths uh so the first thing we should do
is is of course Define what a a path is
on a graph so we're going to think about
our graph like a road Network right
let's think of maybe every node here as
an intersection right so this is a
roughly Kendall Square see it's a it's a
square
um but in in in any event uh let's say
that I want to find uh maybe question
one would be you know does there exist a
way to get from vertex one to vertex 3
and then a better question to ask would
be does there exist a short way to get
from vertex one to vertex 3 then of
course the first thing I have to do is
Define my enemy I have to Define what
I'm looking for which is a path so a
path is nothing more than a sequence of
vertices in a graph where every pair of
adjacent vertices in that sequence is an
ed I think it's all with our intuition
of what a a path is in a graph so for
instance here's a path P equals V1 V2 V3
so notice that there's an edge from V1
to V2 and also an edge from V2 to V3 so
it satisfies the assumptions set forth
on our
definition what would not be a path in
our graph would be like V1 comma V3
right because there's no Edge
there okay so if we talk about paths uh
then there's a very natural uh notion
which is the length
length I guess you could think of like
the number of vertices in your path
minus one or uh the number of edges that
your your path traverses those are the
same thing right so for instance the
length of the path P here is two
everybody see that a very common coding
bug that I encounter a lot is adding one
to that number by accident um because of
course there's one more vertex in your
your path than there are
edges okay and and there are many
different uh there could be potentially
more than one uh path between any pair
of vertices so let's say that I have an
undirected graph uh that looks like the
following so it's just a square plus a
diagonal so here are
nodes right so then a perfectly valid
path from the lower left to the upper
right be to go one over and one up but
of course there's a more efficient way
to get from the lower left to the upper
right which is to go across the
diagonal and so when we talk about the
shortest path is nothing more than the
length of the path that has the fewest
number of edges or vertices in it
between any pair of vert uh vertices in
My
Graph okay so this is our enemy this is
what we're after is Computing the
shortest uh uh path between vertices in
a graph uh and and this is a thing uh
that that we'll be talking about quite a
bit in this course because of course
it's a very practical matter right like
when I saw want to solve routing
problems I want to like move packets on
my network I prefer not to well unless
I'm doing tour I'd prefer them you know
not to hit too many uh computers in
between uh then maybe I want a a
shortest path or or uh you know on a
Surface maybe I want to uh you know move
information in a way that's not too far
away but of course there's sort of many
variations on that theme when we talk
about uh shortest paths or even just
existence of a path right so these are
three sort of model problems that we
might solve on a graph right so the
first one uh which in this course we're
calling single pair reachability would
the idea that I take two vertices s and
t on my graph G and I ask you does there
exist a path between s and
t so what would be the sort of extreme
example where uh uh this gra this
problem may not always give back the
answer yes right like in somehow in our
head I think we think of all graphs as
being connected right but a perfectly
valid graph the way we defined it would
be like 10 vertices and no
edges right this this function would be
very easy to code if that were the only
graph you ever cared about uh but but in
any event uh the existence of a path uh
is already a query that that takes a
little bit of algorithmic thinking we
haven't we haven't figured out how to do
that yet
right now another problem we can solve
be the shortest path right given a graph
and two vertices we might say well how
far apart are these vertices in My Graph
uh if I I want to use the shortest
possible distance from one to the other
notice that I can use the second problem
to solve the first one right because
what's the shortest the length of the
shortest path between two vertices that
don't have a path between
them infinity or shrug that's actually a
totally valid answer yeah um that's
right so how could I implement the
reachability code well I could call my
shortest path code and it gives me
Infinity then I return no it's not
reachable and if it gives me not
Infinity I return yes right so remember
that a key idea in algorithm's class is
this idea of reduction that I can like
use one function to solve another right
so in this case if we can solve shortest
path then we can certainly solve uh the
reachability problem by calling that
that piece of
code and then finally we could talk
about single Source shortest path so
notice now that there's only one input
node here
s so what this problem is saying is give
me the length of the shortest path from
s to every single other vertex in my
graph that make sense so like maybe I
return a big array with all the
information every single shortest uh
distance so can we solve single pair
shortest path using single Source
shortest
path absolutely right I could you know
take s in my single pair shortest path
problem compute the shortest path from s
to literally everything
else and then throw away all that
information except the shortest path to
T and and and and now I'm good now I
haven't Justified that this is the
fastest possible way to solve that
second problem but at least it shows
that if I can solve problem three I can
also solve problem two if I can solve
problem two I can also solve problem one
so uh in today's lecture we're just
going to worry about uh problem three in
other words these things are sort of
listed in in increasing order of their
their
difficulty okay so in order to think
about the single short Source shortest
path problem we're going to make one
additional construction uh and this is
an idea uh called the shortest oops the
shortest path tree I got lazy drawing
PowerPoint slides at 2 a.m. yesterday
and and instead uh thought i' I'd draw a
picture on the
board so uh let's uh draw a
graph so here we have a a b I'm going to
use letters instead of numbers to refer
to nodes from now on because I don't
want to confuse the length of the
shortest path of the index of my uh my
node uh so here's a b c I'm going to
match my notes Here
d
e
f here's a
graph again undirected because your
instructor likes to think about
undirected graphs but I know I'm going
to get feedback that I shouldn't have
done that later uh but in any event uh
let's say that I want to compute the
shortest path from a to everything else
or the length rather so first of all
even without talking about an algorithm
I think it's pretty easy to guess what
it is right so clearly the shortest path
from a to a has length zero the shortest
length from A to B is one from a to c is
two right because I can follow these
guys now it gets complicated it branched
you know so the next uh shortest path
has length three and then four like that
does everybody agree with me that the
numbers I've decorated here are the
length of the shortest path from a to
everything
else but what have I not
done I haven't told you how to actually
compute the path I'm just giv you the
length of the
path right so I might want a piece of
code that in addition to doing single
Source shortest path length also gives
me single shortest single Source
shortest path so initially when I think
about that I might think about well how
do I even write down a data structure
that can store all of those paths right
well every po path could have like V
vertices in it right like it could be
the for whatever reason my there's like
a lot of branching in My Graph and all
the paths are super long actually I
guess I have to think about whether
branching would make them them longer or
shorter uh but but in any
event I could have a really boring data
structure that just for every single
vertex keeps track of the shortest path
from a to that
vertex how big would that data structure
be well if the only bound I have on the
length of a path is that
you know certainly most it takes all the
vertices in My Graph right then any One
path will take V Space so that would
take v^ s space
total that wouldn't be so good right
because somehow I have an amount of
information on my graph currently that's
linear right it's just the length of the
path if I want to actually reconstruct
that path initially it sort of
spiritually feels like I need way more
space to do that um but the answer is
that we actually don't that we're going
to only need linear space and the idea
for that is to store an object called
the shortest path tree yes
[Music]
so the question was about recursion we
haven't actually written down any graph
algorithms so we're going to defer on
that and until until we actually recurse
uh and then we'll think about it more
carefully yeah but it's a totally
reasonable question there are plenty of
recursive graph algorithms out there uh
and and and then we'll have to uh do our
our accounting very carefully for
sure right so uh instead uh we're going
to Define an object called the shortest
path tree and the basic trick here is to
say well how did I get from a to
c well there's always a Vertex which is
its
predecessor on the shortest path and
shortest paths have this really
beautiful property right which is that
the shortest path from a to c if I
truncate it right so like it goes A to B
to
C then the truncated one is also the
shortest path to that previous vertex
right so so let's think about that a
little bit because that sentence was as
usual poorly phrased by your instructor
so let's say that I have the shortest
path from a to d which is is is very
clearly A B C
D I think we can all agree and now I
take like this subl list I just look
from a to
c is there ever a circumstance when this
is not the shortest path or a shortest
path from a to
c no right because if it were right if
there existed a shorter path from a to c
I could like splice it in here and find
a shortest path from a to
d you see that so based on that
reasoning rather than storing like this
giant set of shortest paths sort of
actually applying in some sense this
recursive uh uh uh suggestion uh instead
I can just think of the one vertex
that's before me in my shortest path I'm
going to trace backwards so let's take a
look at our graph
here essentially the object to keep
track of of is like a
predecessor right
so what is the predecessor of f on the
shortest path it's actually either D or
E it doesn't matter in this case so
maybe the the predecessor is e for fun
right what's the predecessor of e well
clearly the previous Edge or vertex on
the shortest path is
C similarly for D now we have b and
a have a bunch of arrows that point this
way right so for every vert I'm just
going to St an arrow pointing toward the
previous vertex on the shortest path I'm
not going to store the whole shortest
path just the very last
Edge so first of all how much storage
does this
take takes V Space do you see that or
the size of the vertices space because
every vertex just has to store one thing
which is the previous vertex on its
shortest path yeah now what is my
algorithm for tracing shortest paths
it's really simple right I just start
walking along these edges all the way
until I get back to a
now this object is called as shortest
path tree notice I snuck in one
additional word which is
tree why is that can I ever have a cycle
in this
graph wouldn't really make any sense
right these are shortest paths you
should be able to kind of follow the
gradient back to the uh original uh
vertex okay so in other words uh I'm
going to basically decorate my graph
with one additional thing we'll call it
P of V which is the previous vertex on
the shortest path from my source point
to my vertex
V and what I think I've I've tried to
argue to you guys today is that if I
have this information that's actually
enough to reconstruct the shortest path
I just keep you know taking P of v and
then P of P of v and then P of P of P of
v and so on which sounds more
complicated than it is uh until I I
trace back to my original vertex and
this object uh conceptually is called
the shortest path tree any questions
about
that yes
I had an edge I connected a to d
okay ah okay so the question was let's
say that uh our colleague here added an
edge this is a great
question you know somebody was evil like
my adversarial neural network STI an
edge here because it was adversarial and
it wanted my shortest path code to fail
and now somehow the the tree that I gave
you is is no longer correct and my
answer to that is yes why is that well
by adding this edge here my the length
of my shortest path changed right the
the shortest path from a to d is now one
so this tree is no longer valid I need a
new tree so now what would be the uh the
previous like P of of of D here well
rather than being C it would be
a yeah so that's absolutely right and it
actually is reflective of an really
annoying proper property of shortest
paths which is if I add one Edge to My
Graph the length of the shortest path to
every vertex can change well I guess
with the the exception of the source
vertex yeah uh and and uh that's
actually a really big headache in
certain applications so uh for instance
and then I'll shut up about applications
and and do math again um I work a lot
with 3D models and there's a big data
set of 3D models of like ballerinas and
ballerinas are really annoying because
sometimes they put their hands together
like that and then suddenly the shortest
path between your fingers goes from like
your entire body to like zero and so
incremental algorithms for computing
shortest path can can fail here right
because I have to update like everything
if I accidentally glued together uh
fingers like that yeah um so anyway I'll
let you think about how you might fix
that problem and if you if you want to
know more you should take 683a
yes if you change your Source node the
shortest paths would change again yeah
so this is going to be one of these
really boring things I'm going to keep
answering like anytime I Chang anything
about my problem I changed my source I
changed my edges I have to just
recompute all the shortest paths there
are obviously algorithms out there that
don't do that uh but we're not going to
think about them yet okay so as usual
I've talked too much and left myself
about 10 minutes to uh do the actual
algorithm that's interesting uh in in
the lecture here although actually it's
really not so complicated so I think
we'll we'll do okay which is how do I
actually compute chtis paths yeah and
the basic thing we're going to do is is
sort of build on this this tree analogy
here we're going to Define one more
object which I really like actually I I
enjoy this from from Jason's notes
because it looks like calculus and I I
enjoy that um and and that's uh an idea
of a level set and so this is a whole
set of things L subk and these are all
the vertices that are distance K away
from my source right so for instance if
my source vertex in in this example is
the vertex all the way on the left then
l0 obviously contains just that vertex
right L1 is the the next one L2 is the
third one but now L3 is a set of three
vertices right because those are all the
things that are distanced three away
from the source that's what i' I've
labeled in pink here okay so that's all
that this uh this notation uh here means
oh oops I've made a slight typo because
in this class distance is Delta and not
D but whatever the shortest distance the
shortest distance that's absolutely
right so for instance I could have a
very long distance from l0 to L1 right I
could just flip back and forth between
l0 and L1 maybe go over to L4 and then
go back uh that that wouldn't be a
terribly helpful thing to compute that's
absolutely right
yes ah the red background is the set l
so for example L3 contains these three
vertices because they all the things
that are distance three away from the
left I got a little too slick drawing my
uh my diagram like late last night I'm
kind of proud of it
okay so essentially if I wanted to
compute the length of the shortest path
from vertex all the way on the left to
all the other
vertices um one way to do that would be
to compute all these level sets and then
just sort of check what level set I'm in
right uh so we're going to introduce an
algorithm called breath ver search which
does roughly uh that so uh breath ver
search the way we'll introduce it today
uh is going to be an algorithm for
computing all of those level sets L subi
uh and then from that we can construct
the length and and even the uh the shape
of the uh the shortest path so now I'm
going to move to my handwritten
notes okay
and here's what our algorithm is going
to
do I'm going to write it in a slightly
different way than what's in the course
notes and on the screen but but only
slightly um so first of all one thing I
think we can all agree on is that level
set zero oh that's cool this chalk
bifurcated uh it contains one node what
should that node be the source right
because the only thing that's distance
away zero away from the source is the
source node yeah
okay uh and uh in addition to that we
can initialize the distance from the
source to
itself everybody on three what is the
distance from the source to itself 1 two
three zero thank you see you're waking
up now it's it's getting it's almost 11
12 what time is it almost 12 okay and
then finally uh well maybe initially we
don't really know anything about the
array P so we just make it empty right
cuz P of of the source is somehow
doesn't matter right because once I've
made it back to the source I'm I'm done
Computing shortest paths so we're going
to write an algorithm that computes all
the level sets and fills in this array p
and fills in the distances all in one
big shot we're going to call it breath
first
search Okay so let's do
that so we can use the notation uh here
and notice that there's basically an
induction going on right which is I'm
going to compute level set one from
Level set zero level set two from Level
set one and so on until I filled in My
Level sets does that make sense uh so uh
here's a slightly different way to uh
notate the same thing I'm going to use a
while loop which I know is like slightly
non- kosher uh but that's okay um so I'm
going to initialize a number I to be one
this is going to be like our counter I'm
going to
say
while the
previous uh level set is not empty
meaning that potentially there's a path
that goes through the previous level set
into the next one right because as soon
as one of my My Level set is empty
notice that all the like the LI for even
bigger I are also going to be empty
there's like never a case when there's
something distance not distance I but
then distance like i+
5 okay so now what am I going to do well
let's think back to our
graph right so like now I know that this
guy is distance zero away that's what I
started with
so now I'm going to look at all the
neighbors of this vertex I'm going to
make them distance one away that make
sense and similarly here this guy's
distance
too and eventually I'm going to get in
trouble because
maybe well what's a good example here I
won't even try to draw uh I could run
into trouble if I don't want to add a
Vertex twice to two different level sets
right once I've I've put it in Li then I
don't want to put it in like Li I + 5
because I already know that it's just
since eye away does that make
sense okay so what I'm going to do is
I'm going to iterate over all the
vertices in my previous level
set and now I'm going to look at every
vertex that is adjacent to you because
what do I know I know that if I can get
to U in I minus one steps how many steps
should it take me to get to any neighbor
of
you ey steps right because I can go
through the path which is length IUS one
add one additional Edge and now get to
that new guy right so what can I do I
can iterate over all V which is in the
adjacent uh set of of of U but I have to
be a little bit careful because like
what if I have an edge backwards so like
for instance here I have an edge back to
the
source I guess this is yeah that's a
valid example like I wouldn't want to
add the source to like the third level
set because I already added it in a
previous guy right so I want to get rid
of the Union of all the previous level
sets of uh does that make sense so in
other words I'm only going to look at
the adjacent vertices that I haven't
visited yet in My Level set computation
algorithm and now all I have to do is
update my arrays right so in particular
I'm going to add
vertex V uh to level
set I CU I haven't seen V yet I'm going
to set the distance from s to
v um equal to
I right because uh I'm I'm currently
filling in My Level set I uh and then
finally what is
p of V what is the previous vertex to V
in my shortest path from my source
it's you right because that's the guy in
the previous level set that I'm building
my path from right going to say that to
you and then sorry I ran out of space
but I also have to increment
I okay so what does this algorithm do
it's just building one level set at a
time we go back to our picture right so
it starts by initializing l0 to just be
the source vertex then it looks at all
the edges coming out of that in that
case just one
makes that length one and so on right
and so this is just incrementally
building up all these level sets now
there's a pretty straightforward proof
by induction uh that this uh algorithm
correctly computes the L's the P's and
the Deltas which is all the information
that we need uh uh uh to compute the uh
the shortest path I think you guys can
do that in your recitation if you still
need a little bit of pro uh induction uh
proof uh practice here um and the final
thing that we should check is what is
the runtime of this algorithm I'm going
to squeeze in there just at the last
second here so let's take a look so
first of
all I did something a little oh oops
uh no that's okay um in my algorithm
actually in Step Zero I had to make an
array which was the size equal to the
number of
vertices remember that in in 66 how much
time does it take to allocate
memory yeah it takes the amount of time
proportional to the amount of memory
that I
allocate right so already that's I see
your hand but we're low on time so we're
going to make it to the end um already
we've incurred V time right because our
our shortest path array takes V space
but in addition to that we have this
kind of funny for Loop where for every
node I have to visit all of its
neighbors now first of all do I ever see
a node twice
here no right because I'm going in order
of distance and the second that I've
seen a node in one level set it can't be
in another right that's sort of our our
basic construction
here well conveniently for you guys we
already proved exactly the formula that
we need and if I'm lucky I didn't erase
it yeah here we
are if we take a look here this is
exactly the scenario that we're in right
because what did we do we iterated over
all the nodes in our graph and then we
iterated over all the neighbors of those
nodes and that's the basic computational
time in our
algorithm
so that for Loop or that while loop
rather in my code is incurring time to
the number of
edges so what is the total runtime for
for breath first search well we need to
construct that
array even so just in Step Zero we've
inquired V uh time and then we have to
iterate over something that takes at
most the number of edges so overall our
algorithm takes big O of mod V plus mod
e
time now notice that this is you might
view this is kind of redundant by the
way in this I have a little bit of equal
with Jason but in this class we'll call
this a linear time algorithm because
it's linear in the space that you that
you're using to store your graph I think
that's a little fishy personally because
this scales could scale quadratically in
V but I
digress um in any event
uh right why do we need both of these
terms
here well notice that you know if I had
no edges in My Graph right now this term
is going to dominate uh but as I add a
just to My Graph this thing could go up
to v^2 right so this is somehow a more
informative expression than just saying
well at worst this is v^2 time does that
make sense this is a slightly better
formula to have okay so with that we
just squeaked into the Finish Line we
have an algorithm for computing shortest
paths uh and I'll see you guys again I
guess on Tuesday