okay
welcome back to 6006 we're going to have
a
this problem session we're doing a quiz
2 review we're in a much bigger room
today so
i have a little bit more board space so
i just want to go through what's going
to be covered on the exam
first off the scope uh now quiz one
material
will be fair game for this uh
this quiz but it's not something that's
gonna be
explicitly emphasized or anything like
that right you should know that
you know when we're storing graph data
structures
that they can achieve certain running
time bounds and
and and that kind of thing but we're
really going to be concentrating on
graphs
the six lectures that we've had on
graphs the two on unweighted
graph algorithms and the four that we
had on weighted graph algorithms
they covered the material that was uh
covered in
the two problem sets uh problem set five
and problem set six now
uh we only usually this this material
covers
uh three problem sets worth of material
uh this term
it's covering two problem sets worth of
material uh so
just keep that in mind when you're when
you're studying and you wanna go look
back on
previous material okay in general
there's lots of graph problems that
we've talked about how to solve
there's really a small number of graph
algorithms but they can solve a lot of
different problems
okay and so we we saw two algorithms to
solve the graph reachability problem
single source uh what is reachable from
me
right uh and i can only search a
connected component of my graph
from me right and the connected
component from
me is actually upper bounded
asymptotically by the number of edges in
my graph
because a a spanning tree
of my component has at least or has v
plus one edges right and so
uh the number of vertices i can reach is
upper bounded by the number of edges
in my graph asymptotically anyway uh
graph then then uh we talked about
exploring an entire graph even if it's
disconnected
not necessarily from a source right just
just touching every vertex in a graph of
course we can just
you know touch every vertex in a graph
right i can look at the adjacency
representation of my graph
and just go through it but this is
really we're trying to explore the whole
graph maybe
count how many things are reachable from
each other
in the graph and this is what we had a
we talked about
exploring a graph and counting the size
of connected components in a graph
in an unweighted graph right and we
could do this via
full bfs or full dfs it's basically
putting a loop around
one of these graph reachability
algorithms to
explore an entire graph by exploring
component by component
and when i'm done with a component i
find a vertex i haven't reached yet
before
and explore it again okay and that still
gets linear time in the graph v
plus e then we had uh special types of
graphs directed graphs directed acyclic
graphs
uh that we could use we proved this
property of if we ran dfs
full dfs on that graph we could actually
get topological sort of that graph
basically an ordering
of the vertices in the graph such that
all edges go
in one direction with respect to that
ordering like all forward in that
ordering
right and we could actually use that to
detect cycles in a directed graph
by just looking at the topological
sort order and seeing if if
look at the finishing time the reverse
finishing time order of dfs
and just checking to see whether it was
a topological sorter right because any
back edge there
would correspond to a cycle in our graph
because the proposition was that if our
graph was acyclic
doing this procedure would give us a
topological report okay then we
had an algorithm bellman ford that uh
was able to detect and find negative
weight cycles in our graph
in the way that we've presented it in
lecture
and but but normally we concentrated on
these two problems single source
shortest paths
and some a little bit all pair shortest
path shortest paths
right uh first in the unweighted context
and then
in the weighted context for the majority
of the lectures okay
so let's move on to what those
single source shortest paths algorithms
were we had
kind of to me in increasing in
generality here
the first restriction is bfs already
solves unweighted shortest paths in
linear time in the unweighted context
that's all good
but for uh weighted graphs
regardless of the weights if we had this
very strong property on the graph that
the property
that the graph didn't have any directed
cycles
then we could get this in linear time
via dag relaxation
and then for general graphs we had these
increasing
or decreasing restrictions on the
weights
first we had the restriction was that
they were unweighted
and that that's the bfs constraint or
that they're non-negative
that's the dijkstra constraint and if we
have no constraints that gives us
bellman ford and they
increase in time in general you want to
choose an algorithm that's higher on
this list but sometimes
the algorithms higher on this list don't
apply right
if you if on a quiz you come to
a graph for which uh
so it's not a dag but you use dag
relaxation
that's no longer a correct algorithm
right and so you're going to get fewer
points
than if you happen to use an inefficient
algorithm that is correct
right so if i just whenever i saw
shortest paths
i used bellman ford right it's the
slowest thing
that's probably going to be a correct
algorithm it's not necessarily going to
be the most efficient algorithm
but you'll get more points because it is
a correct algorithm
then if you apply a faster algorithm
that doesn't apply to your problem
because it's not going to solve it
correctly
does that make sense okay so
and then in the last lecture we had
we talked about all pair shortest paths
and
really running a single source for just
paths from each vertex
is pretty good in most circumstances
we don't know how to do a lot better for
for a lot of these and then
johnson gives us
basically in this last line of our graph
restrictions and weight restrictions
uh where bellman ford is right there we
can actually get a speed up over v
times bellman ford uh by
kind of two tricks right
re-weight the find if the graph has
negative weight cycles
and if it doesn't then there exists a
re-weighting of this graph
so that all the weights are non-negative
but the shortest paths are preserved and
so we can use
dijkstra v times and get that that
running time instead
okay so that's that's just an overview
of the contents that we've covered so
far
just want to go right just brief
overview of what these algorithms
actually do
dag relaxation uh you know finds a
topological
order of the thing using dfs
looking at the reverse order of the
finishing times you prove that that's a
top
a reverse topological order
and then we relax edges forward in that
order because we know that we'll have
found
shortest path distance to everything
before us before and
we use that invariant to prove that this
constructs it in linear time
bfs explores things in levels right
out increasing
in the number of edges as we go out and
i just
process all of the ones in the same
level at the same time and dijkstra
generalizes this notion
by saying well i don't know all of the
things that are
in the same level per se from fr
as i'm going but i can using a clever
use of a data structure
find the next one i should process in
kind of a
topological relaxation order
to find shortest paths when the weights
are non-negative
because in some sense i know that once
i've reached things
from a short distance i will never have
to update their distance again
that's that's kind of the invariant that
we're having with dijkstra and then
bellman ford
essentially duplicates our graph so that
each node corresponds to reaching a
vertex
using at most a certain number of edges
and then that duplicated graph is a dag
and we can run dag relaxation
so that's the basic idea of all these
algorithms
uh when i approach problems on a quiz
uh there's a couple things to keep in
mind there's kind of two
two things that we have to worry about
when we're you're looking at a graph
problem in this class
the first thing is i might not see a
graph in my problem
right i mean on quiz 2 you know that
there's going to be a graph in your
problem because we cover
graph algorithms on on this quiz
but in general some of the word problems
you've been seeing on your problem sets
there's no graph defined for you they
give you a an array of things or a set
of things
or you know some connections between
some things right and that might be
a graph that you want to make but uh
kind of defining a graph is an important
aspect of that problem solving that is
not necessarily something that we've
covered in lecture
right we've not emphasized that in
lecture so much
right but it's something that you've had
to do on your problem sets and something
that will appear on the quiz
right so it's the part of this is a
modeling context can you look at a real
real world situation or maybe not so
real world
but non mathematical context
right and you're trying to abstractify
put it in the language of this class the
mathematics of this class make a graph
so that solving one of the problems that
you know how to solve
can adequately solve the word problem
that we gave you
right this is a modeling part so i
always suggest when you see a word
problem
on quiz 2 or on your problem set right
it's that uh
see if you can state cleanly an abstract
problem
related that if you knew the answer to
that abstract problem
you could easily solve your word problem
can make it a little
easier to decouple the complexity of the
word problem right
then you don't have to think about i
don't know
uh you know various strange characters
we come up with in
in weird contexts and they're weird
conditions
right if you can map that to just a
graph
with a certain with certain properties
and solving an abstract problem on that
graph that might be easier for you to
think about and apply the material in
this class
so you don't have to worry about oh do i
have to remember that
roads are connected to five other things
or do i have to remember
you you maybe you're given as the input
a sparse graph or something like that
right
that's a little easier to think about
for when applying this material
okay and so con converting your problem
into a finding a shortest path problem
or finding a cycle or finding a
topological sword or connected component
or a negative weight cycle or any of
these kinds of things
right can make it easier for you to
think about
uh it's not like fundamental material in
this class that's that's
that's super uh that we need to lecture
on but it is really important for you
when you're out in the real world
looking at problems to be able to make
that transformation
from a a non-mathematical
context to a mathematical i like to
think of this as a modeling
part of the problem but in general once
you've got that nice abstract problem
uh then in general you you might have a
graph but it might not be the graph that
you the only graph you want when you're
solving this problem right that might be
the input graph that you have
but in general a lot of the kind of
tricks of this thing is not modifying
the algorithms that we gave you
if you find yourself trying to modify
the algorithms we gave you
that we spent entire lectures on proving
their correctness and things like that
that's maybe not something you want to
be doing on an exam
because then you're going to be writing
pages of derivation and proof
that these algorithms work this unit in
particular
is much more on the let's reduce to some
very powerful black box that we showed
you how it works
and so because that's the framework here
the way in which we introduce complexity
into problems
is to make the graph non-obvious on the
thing that you're supposed to apply
right and so the graph that we give you
as the input may be different than the
graph that you'll
want to use to solve the problem and
here are some
strategies that you can use to modify a
graph
like if if you uh if you want to store
state
as you're traversing this graph right
you can expand the number of vertices in
your graph
to keep track of what state i'm in right
i can have a different vertex for every
possible state i could be
at that vertex right you know in your
problem session you had this guy who's
drinking when he got to bars right and
or or every third time and you need to
remember how many times it's been since
i've been to a bar
right or i had a drunk at a bar and and
so you can duplicate the vertices to be
able to
store that information another thing if
you if you
if you need to search from multiple
locations at the same time
or search to multiple locations at the
same time
right you can simulate that without
having to run an
algorithm many times you can simulate
that by adding a
an auxiliary node an extra node in your
graph with edges
to those sources or to those sinks
and run a a single source shortest path
algorithm from that that
that super node sometimes we call it uh
to get better performance it's kind of a
an efficiency
we're adding efficiency by changing our
graph to fit the algorithms that we know
to solve efficiently
and then the last thing maybe it helps
to pre-process the graph in some way
right some edges in the graph that we
gave you
might be forbidden or may need to be
traversed in one direction rather than
the other
even though the problem statement seems
kind of seems like they should be
traversable in either direction
right and doing this pre-processing of
the graph
could mean that you break up your graph
into your connected graph into a set of
you know disconnected components that
you need to find
or makes a undirect makes a a
cyclic graph acyclic right or
prunes part of the graph that you don't
want to
explore i never want to touch on my my
way to get to
to a location right so these are all
really common strategies
that we have you know uh duplicating
graph
adding auxiliary vertex vertices or
edges to the graph i don't know
the context in which we add edges it's
an interesting question
and then preprocessing kind of filtering
out the graph or transforming it in some
way
to to give it properties that will allow
us to solve the problem better
okay so any questions about the problem
solving strategies that we have
or or the content the kind of baseline
content of this class
this is kind of an overview of the
lecture type material where we're not
necessarily applying
this material in lecture the rest of
this uh
you know quiz review session will be on
applying this material to some
uh a quiz from a previous term uh some
of those problems
okay so yeah
what are some common ways people uh lose
points that's that's great thing
we i'll add it to the notes uh when we
post
uh so common things that people lose
points on in this unit when they're
solving problems
you're given a word problem and you
don't define a graph
right super it's as easy as that you
start
solving assuming that we know what graph
you're talking about
when the implicit graph in the problem
may or may not be correct but we don't
there's no graph defined in the problem
right so you need to define a graph in
the problem so that's the first thing
the second thing is a lot of times it's
really useful just as a strategy
when you construct that graph tell us
how many vertices and edges are in it
tell if tell us if it's acyclic right
tell us what the weights are on each
edge
if you don't tell us these things it's
really hard for us to base
to judge your application of algorithms
based on that graph
because you know you if there's
redundancy there even if you define
for every vertex in my original graph i
have 10 vertices or blah blah
right and maybe you're adding a super
node or all these things
it can be difficult for us to follow how
many things are so you do that
bookkeeping for us
your graders are going to be a lot
happier um
and that so so uh common mistakes not
defined
a graph not uh specifying your graph
completely
and then uh not uh
i i would also suggest that instead of
just applying an algorithm to a graph
that you clearly state the problem
you're solving on the graph first
right i want to solve this problem
because we've given you number of ways
to solve that problem on the graph
right and if you happen to choose the
wrong algorithm then maybe
that's like separating off the problem
from your implementation of how you
solved that problem
can maybe help you get some points for
stating the problem you're solving
even if you choose the wrong or an
inefficient way to solve it
right so that that can really help
decouple
uh uh some of the
the things that we're going to give
points on in this class right so
usually what we're we're breaking up the
uh a
graph rubric on grading in
did you describe a graph right did you
modify it in in a way that's going to
help you solve the problem
did you identify a problem that you need
to solve on this thing did you
use a correct algorithm to solve it did
you analyze the runtime
usually involves is the size of my graph
not too large
and what is the running time based on
that graph
and then the argument of correctness in
this unit is basically like
i constructed a graph that has
properties so that shortest paths
in this new graph correspond to whatever
it is that i want in the original
problem
right some statement that links the
problem you're solving in your problem
statement
to the the problem you're solving on
your graph it's that's a really good
statement to have
to bring together correctness but aside
from that statement
you're mostly relying on the correctness
of the algorithm so you don't need to do
much on the correctness side okay but
uh forgetting to analyze runtime is a is
a big thing
okay so those are a bunch of tips i'm
going to add them to the end of this
slide
after after the lecture great question
any other questions
all right let's get to solving problems
all right
so these uh problems that we're gonna
solve
are from uh spring 18
quiz two uh slightly modified
um but uh you know we're just gonna go
through them
uh one at a time so the first problem we
have
uh we have an image of black and white
squares so this is like a pixel grid
you think of it like as a you know a
bitmap on your computer
right and what we say is each
white pixel is contained in a blob okay
but what
what what is a blob i don't know right
okay i'm kind of giving you an
implicit representation definition of
what a blob is
two white pixels are in the same blob if
they share an edge of the grid
okay so this kind of tells me this
this graph has an edge if these these
pixels are adjacent they're both white
right that's what it means but
an interesting part about that
definition is that it kind of is
transitive
right if i have a white pixel that
shares an edge with
a white pixel a that shares a uh what
let's start writing things on the board
shall we
probably instead of me just talking at
you
right we have kind of a pixel grid here
okay and i don't know how to do this
with the chalkboard because it's white
versus black i guess
i have to color in the white things
these are all white
all right so these guys
are in the same blob right because they
share an edge
these guys are in the same blob okay but
because they share an edge in the pixel
grid
these guys are also in the same blob
because if these are in the same blob
and these are in the same blob
there's a transitivity argument here
right this this guy needs to be in the
same blob as that guy
and then it says that black pixels are
not in any blob
okay and so i'm given an n by m array
i never remember which one comes first
but we have dimensions of this thing as
n by m
so we have n times m pixels uh and so
we're describing
uh essentially in a linear time
algorithm
to compute the number of blobs in the
image why do i say linear time
it's because for every pixel in my grid
i needed to give you a specification of
whether that was
white or black right and so yeah if i
naively gave you
the input of this algorithm with a word
per per one of these pixels that would
be the input size of my
right and so even though this has looks
quadratic
right the actual input size has
is what we define as linear
right and so we're looking for a linear
time algorithm to count the number of
blobs in the image okay
so what is a this is a little
underspecified as a problem i admit
um i i hate to admit that i was involved
in
this class at that time but the idea
here
is if these are uh share an
edge then everything the the observation
here is if i just draw this picture
i notice that anything kind of that's
reachable
through white white connections
is going to be in the same blob right so
this is a blob
and this is a blob and this is a blob
and this is a blob but
right there's no path here this this
black part is not part of a blob now
actually there's nothing in this
specification
that doesn't say that says that we
couldn't have these things be in the
same blob
okay so that's a little confusing maybe
a source of error that there's a source
of error that i had when reading this
problem after a couple years
um but you know
when you are looking at a problem the if
if
everything could just be in the same
blob then you just return one and this
problem is not so interesting
right so the right way to interpret this
problem i mean i would not need
n times m time i could just say
one right so in in some sense
i'd like there to be something
interesting in this problem
uh and and having these things that are
not reachable from
each other be different blobs is kind of
the more algorithmically interesting
thing to have
and so what what is this then right this
is just
a pixel grid there's there's adjacencies
right there's connections between pixels
but in particular
i really only care about the connections
between white pixels right
hard to draw on here
but this component has a graph that
looks like this
this component is a single vertex this
one's a an edge here
and here's a singleton there and if we
were to construct this graph
we would have an unweighted graph such
that the number of blobs
in my pic image would be
the number of connected components in
this graph right
see how i'm relating the thing that
they're asking for in the problem
to a property of a graph that i'm
constructing
okay so that's that's that's really the
key
part of argument of correctness that
we're looking for is
for you to to make some kind of
statement connecting the two otherwise
you're just constructing a graph
and i have no idea what you're doing to
that graph right you have to tell me
part of it it's about communication to
us
uh so how do i construct this graph well
i can just
loop through all of the pixels right
look at its four neighbors at most for
and if those uh things
share are both white then i add an edge
we have a we have we're going to
essentially have a
graph we're going to construct a graph
this i told you to do this okay
so what is v here then uh v
is a
vertex for
each white
pixel
right and i can just i mean from the
beginning i can just
walk through all the things find all the
white vertices
maybe i identify them uniquely by their
x y coordinates in this
in this grid that's fine okay so now i
have all the vertices and now i want to
see what the edges are
i can loop through the pixels again and
just look at its four
possible adjacencies see if any of them
are white stick that edge in this set
so edge is
any two
white pixels
that share
[Music]
an edge
okay so i can construct both of these
things in
this in order n times m because there's
at most that many vertices
i just loop through them and the edges
for each pixel i'm only checking a
constant number of things
and i'm adding them to a set so the
number of edges the size of
the number of vertices in my graph is at
most n times m
and the number of edges is at most
n times m times four right it's upper
bounded by that because that's the
number of adjacencies i have in the
graph
okay you can probably get a better bound
in terms of the number of vertices right
it can be at most
v times four right but that's that's a
little stronger it doesn't really matter
we're trying to get within the
order n times m time bound so anything's
fine here so that's the graph we
construct
and then we can run full bfs or full dfs
we've identified a graph
we've identified that we want to count
the number of connected components in my
graph
so idea right
count connect
connected components and then
for example using full
bfs or full
dfs right i wouldn't want you to write
both of these algorithms there
but when we write up our solutions we
want them to
uh you know cover the space of student
solutions
and so we will usually mention it you
only have to mention one of them
and because these run in linear time
this also
runs into n times m so all of these
things are n times m and we're golden
any questions on this question yeah
what sort of things would you be looking
for to make sure right so when i'm
writing down
i've i've described to you the algorithm
and uh so the question is what
kinds of things do i need to write down
when i'm proving
or when i'm arguing running time of my
algorithm and i'm
arguing correctness right for
running time mostly just
check out the size of your graph right
state to me what the size of your graph
is here
in this case it's order n times m and
then
i state the what the running time is of
the algorithm that i have is
applied to that right and so because
uh full bfs runs in o of
v plus e time right
it's useful to actually write this down
even though
right it's not in the terms of our
original problem variables
it's useful to write this down so that
if i mess up when plugging these
variables in
uh that you know
you're showing your steps and so if you
mess up arithmetically
then we can still give you points but
because the size the number of vertices
in the graph is n times m the number of
edges is n times m
i add them together it's still order n
times m and that would be a sufficient
for an argument of running time
and then i was saying for correctness uh
most of this the correctness of this
algorithm is relying on the fact that
this thing
counts connected components correctly in
my
in my graph the key observation
on a word problem that i uh
uh or or even a graph transformation
problem
is that the property that you're wanting
of the original graph for the original
problem
corresponds to the thing you're solving
in a new graph
that you've made right and so here
an argument of correctness that i would
be looking for that
we might allow some weaker statements is
uh that the number of blobs in the
image corresponds to the number of
connected components in this graph that
i made
okay that's that's really all it needs
but
i would like a connection between those
values okay
now why why would you be constructing
this graph and finding connected
components if that
if if you didn't uh if
that wasn't what your thought was uh
i don't know but it's real it's good
when you're communicating to make sure
that that's abundantly clear
that that's why this is uh i mean you
should be able
to argue why why these things are
uh that is a connected component you
could say something like
because anything reachable is in the
same blob or something like that right
okay so that's problem one
we got these nice mechanical boards all
right
so that's problem one problem two is a
little funky
okay uh it's been reworded a little bit
from uh it's from spring 18
so that i could uh point out some other
features of this graph we're given a
connected
so connected is in bold so that might be
an important property of our graph
that we're trying to communicate to you
a connected undirected graph
with strictly positive edge weights
right
so they're mapping to the positive
integers where
e is the same size as v right so the
size of e is the same
size as the size of v right so i have
the same number of edges as i have
vertices
we're trying to find a order v time
algorithm to determine a path from
some vertex s if to some vertex t
with minimum weight okay so
what's the first thing i noticed i
noticed that on this thing i've got
a graph problem
problem 2 we've got a graph
it's undirected
it's connected
it has this weird property that v equals
e
or e equals v and
weights are positive
okay and we're asking for a
single pair shortest paths right we want
uh
a path the shortest path a shortest path
between two vertices
now if if we just we're given this graph
and we want to solve this problem
a very easy way to do that would be to
just say let's run dijkstra on the graph
right this is a graph it has only
positive edge weights
one direction on this graph how long
does dijkstra take
on this graph idea one right
what's the problem with this it applies
right we're in the context of
non-negative edge weights
we can find single source paths from s
to everything else in the graph
in using dijkstra it applies it's a
correct algorithm
what's the what's the difficulty with
this algorithm slow
too slow right that algorithm would run
in o of v
log v plus e and
in this case these are the same so this
is asymptotically smaller than this one
it runs in v log v so we're a little off
we're off by a logarithmic factor in our
running time but you know this would at
least be a correct algorithm
you know if whenever you approach a
problem on the exam
and you see a really stupid uh
polynomial algorithm
that still solves your problem correctly
you might as well write that write that
down in a line
it doesn't it doesn't uh hurt you that
much
to just write that down because it's
possible we give you points for that
right but this but but on your exam
notice why it doesn't is not sufficient
right notice that oh this right this is
v notice that this is not the running
time bound we're looking for we got to
exploit something different okay now
this doesn't seem
this is a weighted context we have
weighted paths
it doesn't seem to be in one of the the
conditions
that we can get a linear time weighted
single source shortest path algorithm
right
uh in particular using bfs
we saw a transformation where if as long
as the sum of your weights was
linear in the combinatorial size of your
graph we could use bfs
by by making each edge a bunch of
undirected edges
we don't have that in this context and
this graph is undirected
i mean so it definitely contains cycles
so we can't use dag shortest paths
so how the heck can we do this
well what does this graph look like here
i'm going to take a look at this
condition
v equals e okay
so what does this graph look like it's
connected and it's v
plus e well how many edges
does a tree have
v minus one right
so in a sense if a tree
is the is the smallest number of edges
you can have in a connected graph
so this has one more edge than a tree
right so really what this looks like
what our graph g looks like is some kind
of tree
and somewhere we've got
an extra edge
in this graph right it's a tree plus an
extra edge that's what our graph is
okay so
well let's take a step back if i just
had a tree
and i had weighed a weighted graph here
undirected
and the weights are all positive
if if any of the weights were negative
how could i solve this problem
well every edge is reachable from every
vertex
i can just go to that edge and traverse
a negative weight back and forth and
my shortest pathway would be uh
infinite for all our vertices that's not
the case we have here
we have positive edge weights only which
means
shortest paths are simple and actually
there's only one
simple path between any pair of vertices
in a tree
right i basically there's
there's one thing i can do and in fact
if i took
if this was s and this was t
t that's that's an x what am i doing
okay
t if i just ran
any unweighted short i mean
reachability algorithm i would get a a
tree
right a bfs tree or a dfs tree right it
would visit vertices in some order
now actually in a tree it i have to
output a tree that connects all the
vertices
right and that would be this tree
right and so in a sense the paths that i
got
from bfs or dfs in this graph would be
exactly
shortest paths i would just have to then
go and add up all the pa
path edge weights along the edges
that make sense okay so
uh bfs or dfs in the unweighted context
can give me the shortest path in the
weighted context
because there's only one simple path in
this graph but we have a complication
here
that's not the question that we're
asking we have an extra edge
and now we have a property where there's
not just one
simple path to t there could be two
simple paths
right i could go this way around the
cycle
or it could go this way around the cycle
so that's a complication but there's
only one cycle
if t is over here there's only one path
right so if there there is only one path
i'll be golden but if basically the
cycle can be reached between these two
things
i could have two simple paths that's the
property right we have
the closest vertex on so this is the
cycle
right there's a cycle here
if this is the closest vertex to s
and this is the closest vertex to t on
the cycle then i could take either path
around the cycle
to get from one to the other and that
gives me my two paths
but this path and this path
right these are completely edge disjoint
right
in other words any simple path from s to
t
if i if i find this vertex going through
here
it can only use one of these edges
right because i can't i can't come back
to this vertex
once i go into it here i got to go out
one direction and i can't come back
right so it's only one of these two
edges
so the the idea behind this algorithm is
i'm going to find the cycle
or in particular i'm going to find this
thing s prime
on the cycle find the
outgoing two edges here remove
one and then do my tree searching
basically find the shortest path by by
running a an
undirected i mean an unweighted
reachability algorithm which will give
me a path back to f
the only simple path in that tree right
i get rid of this
this edge and i do that once and i do it
again
without this edge so that's that's the
idea of my algorithm
okay so how can i do fir so i first have
to find
s prime how can i do that well
i don't know what this edge is but if i
ran
uh un uh uh an unweighted shortest path
algorithm like bfs or dfs on here i
would get back
a tree right some
edge of my graph will not be in my tree
something like here right the shortest
path to this
so i look through i i run b so
algorithm idea two
two first find
s prime okay and i can find
s prime by run i don't know
a single source shortest path unweighted
uh i guess
run single source reachability
unweighted from s using
bfs or dfs
to explore a tree of my graph then some
edge is not in my tree of the graph
that will exist on the cycle kind of by
definition right
it's cons it's connecting two part parts
of my tree
now i can look at those two paths
from here and the last one that they're
in common from s
is going to be my split point s prime
it's the it's the closest one
to my source that is on the cycle right
because i constructed this cycle here
okay so i can uh
find edge
u v not in
the parent tree right so
maybe this is u v right
not in the parent tree
and then find
last common
vertex in
paths from
s to u and s
to v okay that's going to give me my s
prime
okay and i can do that by i mean these
are each
of linear size and i can just look at
their prefix i can start from s
i can walk forward until they diverge
and the one before they diverge is s
prime
right that's s prime right here once i
have s prime
i know what the edges are when they
diverge
i remove one of those from the graph i
do the same algorithm again to find a
path to t
and i do the same algorithm again to
find the path to t
and i see which one is shorter that's it
there's only two of them
and so i check or they could be the same
path in which case
uh my my t
is actually before s prime on on my
cycle
does that make sense so that's that's
the idea
uh the last thing is
remove an
edge from
s prime i don't even have to be picky
about this it has degree three
i can just run single sorted paths on
all of them and
take them in right
uh for eat
remove
each edge from v at from s prime
uh
remove let's for
each edge from
s remove
and run ssr
from s okay
and one of the paths there to t will be
shortest my shortest path in the
original graph because it can't use
uh more than two of those edges that's
that's the claim
okay and this runs in uh
linear time because what i'm doing is
i'm running single source
reachability once
and maybe two more times or three more
times a constant number of times
on a graph that has size v right
and this prefix finding also only takes
order v and so we're done okay
any questions about this problem
no no questions
all right we will move on to uh
what's up there's a yeah there's a hint
in the title actually
the original version of this problem
said instead of this e
equals v specification it said there's
only one cycle in the graph
but it's in the context of undirected
cycles as opposed to directed cycles
which is usually what we talk about in
this class
right we say that there's a negative
edge weight cycle
in the graph if we can you know it's
usually we're
talking about we're allowing non-simple
cycles in this class
so to to you know
remember this this uh property about
trees
and to enforce this property without
talking about
sicklicity i changed the condition uh
for this
problem session this review yeah
could i also just run depth first search
on this graph
could you just run depth first search on
this graph to do what
to find the shortest path right so depth
first search on this path
if i ran it from s when i got to s prime
i would have a choice on what the next
outgoing edge to do
right so if i ran depth first choice for
one of those choices
i would find a path to t right
and then i would find then then i could
run and i would find a path to t
right there's only two of them or at
most two of them
but then there's the possibility i
missed this other path that could be
shorter well how would i miss it
has to go through the other edge too it
doesn't go through the other edge that's
the point
right um it won't go through
no so depth first search will actually
go through this thing
traverse an edge go all the way around
the cycle
because everything here is reachable
from here because it's an undirected
graph
it will reach back to here and then
backtrack all the way so we'll actually
never traverse this last edge here of
the cycle
so it's something you can actually prove
with dfs now you could actually
while you're running dfs try every
possibility right
because my branching factors at most
three at some of these things right
so what i i could do is uh
or it could be at most four right i
could i could
connect two things with the same uh
branching but in general it's a constant
and
and with with every choice dfs
could make i could try all possibilities
how many possibilities would that be
you get a blow up of the degree of
every vertex in my graph
so the degree
time multiplied by each other that's the
number of times i would have to run dfs
which is exponential right a constant
degree
so a constant uh
[Music]
multiplied like like two or
three right uh multiplied v
times is three to the v which is
exponential in the size of my graph
uh sure right because i could still have
large branching for a large number of
vertices
okay good great question
all right cool so that's that problem
problem three
i have half an hour for the last two
problems i think that should be fine
this one's uh okay this is doughnut
is the problem name uh momar has just
uh finished work at the fing sprilled
power plant
at a particular location p and needs to
drive home
to a known location h but along the way
if his driving route ever
comes within driving distance k of a
donut shop
he won't be able to resist himself and
will have to go there and eat donuts
and his wife harge will be angry okay
maybe you can get the reference here
mohmer knows the layout of
finn sprielled which can be modeled as a
set of n locations with
two-way roads of known driving distance
connecting some pairs of them
and you may assume that no location is
incident to more than five roads okay so
we've got a degree bound here
as well as the location and and he knows
the locations
that all the locations that contain
doughnut shops
there's at most d of them okay
describe an n log n time algorithm to
find the shortest driving route from the
power plant back to home that avoids
driving within distance
k of a doughnut shop
okay so we got a couple variables in
here we've got k
we've got d but a running time bound
only relies on
n right
okay i see shortest paths i see that
uh i don't see an explicit mention
of positive distances of the i
i see lengths right they say he knows
the
uh known driving distance connecting
some pairs of locations
so usually i think if if i were writing
this problem now i'd probably be a
little bit more explicit
the distance is positive but that's you
know something that you might
come into contact with right distances
are
positive right and so we can't have
negative distances here
okay uh so
i look at n log n i'm like hey
what has a log in it in this unit
dykstra
maybe i can use dijkstra okay so let's
see if if we ran dijkstra
from p to h okay so we've got we've got
a graph here
we've got our graph so
i'm this is a word problem so there's no
graph there
so i have to define a graph okay so i'm
going to define a graph
v e and we've got v
that's going to be my set of locations
locations so this has
their order n of them there's actually n
n of them and then e
what are we going to have we're going to
have
uh it's a known pair of things right
road roads
with weight
equal to driving
driving drive
driving distance
which uh by my assumption is going to be
greater than zero
right now it's not stated explicitly but
you know that would be a reasonable
assumption for you to make on your exam
because distances are positive we would
probably be more
explicit about that these days okay all
right
so this is a graph i could make and i
have a
vertex s or a vertex p
and a vertex h and i'm trying to find a
shortest path between them
right shortest driving distance driving
route
right okay so i could run dijkstra
wait so what do i know about this how
many edges do i have my graph
i have at most five per vertex
right so this is upper bounded by five
times v
which is order v okay so i have a order
v
size graph that's a good thing order n
because n is the number of vertices and
so
if i were to just run dijkstra on here
from p
doing dijkstra
on g from
any s takes
order n log n right
n log n plus n and n log n is bigger
than n
okay so that's that's a nice observation
we may be
we have we can at least afford to use
dijkstra in this problem to find
shortest distances
but what's the problem with a shortest
distance found by dijkstra in this graph
donuts like the entire point of the
problem right
i need to avoid being too close to donut
shops
okay so we might have a donut shop
here and we need to stay outside of that
distance k
right or we might have another donut
shop here
right and so we got to find a path that
kind of goes around these donut shops
okay so in other words if
if i have a vertex in my graph where i
can reach a doughnut shot within
shop within distance k i got i can never
visit that vertex
right because then i you know
momer will not be able to resist himself
and have to go eat a donut
okay so that's the thing we're trying to
avoid
so how can we do this well here's a
silly thing
i could run dijkstra from each of these
vertices
these donut shops find all the things
reachable in k
driving distance from them
right and then remove those vertices
from the graph
that's an idea but how long would that
take that would mean
need me to run dijkstra d times
right because there's d doughnut chops i
gotta run dijkstra d
times so that gives me a running time
bound of i run d
times to filter out the graph right to
modify this graph
and then i do one more to find the
shortest path if there is one
but in general that's going to take d
times n log n
not n log n i i have no bound on d
except that it's under n
right so it could be n and that would
give me a bad running time
so we're going to use a very similar
trick here to
one of your i think a previous review
session
uh stop
here we go uh
is to when you want to find things
if we're on a prunograph from multiple
locations
one of the things we can do is any
tricks
super node right i can have a vertex
well maybe i don't want to put it up yet
okay if i have all of these donut shops
what i can do is provide a
i guess i guess these are unweighted
undirected edges
right here we can model all of those
directed things by
two undirected edges it doesn't really
matter but here
you know i don't want to go be able to
go back to my super node
okay but what i'm going to do is i'm
going to add a super node
with edge weight say 0 to everything
else
right and then if i ran dykstra
from the super node
and found all vertices reachable within
distance k well i didn't
i didn't spend any of that distance
going through this first edge
right and i didn't come back to s
because these things are directed
into the things and so
anything i reach is going to be within
distance k
of this donut shop but for all donut
shops
and in some sense i'm doing this search
in parallel
so this is the same trick that we had in
the like you're looking through the
the sewer network or something and
they're trying to avoid
monitors or uh you know sensors
or something like that we actually did
this transformation and then binary
searched on the distance it was
kind of involved but this is an easier
example now you can actually
generalize this further what if each
donut
shop had had us
uh a like a
an amount that moamer liked it right so
if uh momar is within a
larger distance of a donut shop he
really likes he still won't be able to
resist
right but a donut shop that doesn't make
very good donuts
you know he'll be able to resist a
shorter distance without without having
to
to uh go to that donut shop so in other
words
each one of these donut shops has a
different k
right a different radius that momar will
allow
is there any way to generalize this
technique
to be able to prune all of those
vertices instead
ah all of these had weight zero before
the same weight i mean the algorithm
would have worked for any weight i put
on all of these edges
as long as i search the distance that
weight plus k
right here i can just make the distance
of this
frontier for each one of the the donut
shops the same
by modifying the distance to the of the
incoming edge
right so i can set the length
uh the disc the weight from the to the
donut shop
with the largest radius to zero
and then put the difference between the
largest radius to all the other ones
i put that as the weight on the other
edges
and then we still have a graph with
positive edge weights
and i can run dijkstra from this and
that would generalize this problem
and something that we've done in some
practice exams and or in in exams
and problem sets in the past okay so
that's another common
way so we filter
filter uh forbidden
there's two b's in forbidden or two d's
two d's there's a three ds
right vertices
by using
supernode
plus one run of dijkstra
those are the extra letters okay so on
your exam
you would probably want to be a little
bit more explicit this is this is a
summary of the things that we just
talked about i just
you know talked 10 minutes about the
algorithm
but it doesn't hurt to add a summary at
the top of what you're going to write
this is the approach that we're going to
have
we're going to filter out the vertices
from g
essentially by running dijkstra from
each of these
these donut chops but we're going to do
it in parallel by adding the super node
okay so actually on
another uh uh
recommendation i have for you on an exam
is that almost any problem that we give
you in this class
can get 80 to 90 of the points
by writing like maybe three lines
right almost and maybe not some of the
data structures problems
but almost any question in this class
can
like uh can be solved
with not all of the the points but most
of the points
by just writing a couple lines that we
know that you know how to solve the
problem
right and this
this would be one of those situations
right
now i would want to give you full points
i would want all the details here
did i construct a new graph i add this
vertex here
i have to add edges to each of the d
things
but i've only added d more edges and one
more vertex so it still has this
linear size in my input right
and then i want to say that i'm you know
putting the weights on here based on
what the distance is now they're all the
same weight because i don't have that
generalization
and then i run this thing and i remove
all those graphs
and construct a new graph from g right
that's a third graph that i'm
constructing now
but notice that the graph that was
implicit in my problem
was very different than the graph that
i'm ultimately running a shortest path
algorithm
like dijkstra from p to c if one a path
exists
does that make sense any questions on
this problem
all right we've got 20 minutes for my
last problem
uh man i'm not using
i write much less than some of your
other instructors
so i like to talk more than i
to write apparently okay so
problem
four let's take a look at this this
one's one i made up last night
kind of fun long shortest paths
okay given a directed graph having
arbitrary edge weights basically
these could be positive or negative or
zero
and two vertices from the graph describe
a
v cubed time algorithm to find the
minimum weight of any path from s to t
okay that
sounds like bellman ford right there but
i have this last condition
and the last condition is a little weird
containing
at least the edges
so i want a short path in terms of
weight
but i want a long path in some sense
in terms of the number of edges i
traverse
does that make sense so of all paths
having at least
the edges i want a shortest one among
them
in terms of weight this is a weird
freaking problem
right usually we're not trying to do
this max min kind of thing
we've got two different quantities here
we're trying to optimize
anyone have any ideas on how i could
approach this problem
what does this sound what does the at
least v edges
sound kind of similar to that we might
talked about in lecture
uh so uh when we were talking about min
ford we defined this thing called a
k edge weight right is the weight of any
path using at most
k edges this kind of edge constraint
seems similar except it's kind of the
reverse
it's not at least it's a mo it's a it's
not at most it's at least
right
well here's an observation i have for
you
if i want a a path that goes through at
least
the edges some prefix of that pass
path uses exactly the edges
right that makes sense right so maybe it
makes sense for me to
maybe it might make this problem easier
if it's not at least the edges but if
it's exactly the edges
maybe i think about it that way that
that seemed a reasonable
other way to think about this problem i
knew how to do
up to a certain set of edges
here we're asking for at most
maybe the thing in between is a little
easier to think about
okay so what we're doing we're given a
graph
g it has any
weights
it's possible that this graph has e
lower bounded by a quadratic in the
vertices right i have no restrictions on
how many edges this thing could be and
so
the worst thing i could have is that
this thing i mean my graphs are simple
the worst thing i could do is have this
be quadratic
in the number of edges say if it's the
complete graph that's the maximum number
of edges that i could have
and i'm trying to find in my graph
a path that uses a lot of vertices
but has small weight now what's another
thing to notice here
is if i use at least v edges can my path
be simple
no right because i need to use at least
v plus one vertices
and there are that's more than the
vertices i have in the graph
obviously right now it could go through
vertices more than once
but it's definitely not going to be a
simple path okay
so what's one thing like here's
what if there's a negative weight cycle
in my graph
what's the minimum weight of any path
from s to t
if the negative weight cycle is
reachable from s
reachable on a path from s to t what is
the answer to my problem then
negative infinity right because
certainly
an infinite length path is going to use
an infinite number of edges
right if it's going arbitrarily long
that's i then i can just run bellman
ford right so that's one thing i can do
i can just
run bellman ford on this graph i have
enough time to do that because
e is upper bounded by v squared and i
have v cube time
and if there's a negative weight cycle
in my graph i can know
that the minimum weight of any path is
minus infinity
i detect that that's the case if if if
basically
t is reachable from s with a minimum
shortest path distance
minus infinity that the path that
achieves that is going to have more than
v
edges so you know i'm done and that no
path actually achieves that but
you know that's the in the in fema
yeah supremum supreme or infimum sorry
we're going lower bound i'm thinking of
long paths though so the
number of edges is approaching infinity
okay but in the context where i don't
have
negative weight cycles actually one of
the things we
showed was that if you're
reachable not through a negative weight
cycle or if no negative weight cycle is
traversable from s to t then my shortest
path is going to be
simple but that doesn't seem to apply
here either because
we need to have a non-simple path so
what do we do
so let's go back to this idea of trying
to figure out the minimum weight of any
path
using exactly the edges can we use some
of the tricks that we had in bellman
ford
when we're keeping track of the number
of edges we're going through at a given
time
that's the idea right
if we have a vertex
if we have a new vertex for each vertex
different versions of it that talk about
exactly
how many edges i went through then maybe
i could keep track of this while i'm i'm
working on this graph
right so so let's say i have multiple
layers
of the graph this is the idea
maybe we start at level level 0
down here to level how many edges do i
want i want v
plus 1 vertices so i'm going to have v
plus 1 levels which is v right so
a level here
v how many levels are there there's v
plus the zero
yeah and so there i'm going to have
for every edge in my graph i'm going to
take
it so this is a directed graph right so
i direct it down
into the next level for each
version of this graph that i have
i take that edge that was originally
between u and v
here in the graph right it was
originally
here in g but here i've pointed all of
those edges downward
okay isn't that what we did in bowman
ford
we made one other addition in bellman
ford
to make it be the at most
property right what was that
transformation we did
we had zero eight edges going from each
vertex to another right it meant that we
didn't have to traverse an edge
right but here if we don't add those
edges actually this transformation gives
us that
any path that goes through v edges
will be some path from a vertex in
layer 0 to a vertex in layer v
right just because to get down here i
had to traverse
exactly the edges and they're the edges
of my original graph
now notice this encodes
non-simple paths as well right because
these non
these things could go i could go here
and back to you and back to v
and back to you if i had a cycle in my
graph
but right actually what kind of graph is
this
this is a dac right so this is dag
uh maybe i call this g prime
how many vertices are in g prime
v times v plus 1 right so i'm going to
say order
v squared and how many edges are on my
graph
v times e right i i copied
every edge made it directed down between
each level there are
v transitions between levels and i copy
each edge
for each of those so the number of edges
is
order v times e
okay so this graph is blown up
there's a lot of things in this graph
but i notice that you know this graph
has size
order v cubed is what we're going for
so i can afford to construct this graph
since v is actually also
upper bounded by v squared by simplicity
right okay so we have this graph
we could find our our vertex
s here as 0 up here
and we could afford to compute the
shortest path
distance to all other vertices using
exactly the edges
in my graph exactly right
that's what we could do i can
find everything reachable from s
0 in this graph and calculate the
shortest path
down here at the bottom so i can do that
in
v cube time because dag relaxation is
linear in the size of the graph
but that's not what the problem's asking
me unfortunately
right uh in particular i could find the
path to t
to t v and that would give me
the shortest path using exactly the
edges but that's not what i'm asking for
i'm asking for at least
so it's possible that i get down here to
some other vertex
and maybe there's a negative weight path
going to t and i want to be able to find
that
so how can i do that how can i allow
paths to continue
past this
an arbitrary amount
i could have more layers right right
actually
simple paths uh from
any ver i mean shortest paths that are
simple
right that use fewer edges right here
here i'm not restricted on the number of
edges i use
right so shortest paths in this graph
are going to be simple because there's
no negative i've already i can already
like throw away the case where i have
negative cycles because i ran bellman
ford at the beginning
right i can
uh i so i know that i'm going to want
a short pat a simple path
after i've reached the edges
because it's never going to be
beneficial to me to
come back to a vertex because that will
be a path of
longer weight right this is the the kind
of surgery argument we had
both in unweighted and weighted context
okay
so these are going to be simple so i
know that i only have to go
v more layers
at most okay so that's one way to look
at it i could add more layers of this
thing
find the shortest path distance to all
vertices
using uh up to two v
edges right maybe even
two v minus one but order v
and then for all of the ones down below
here i just look at each vertex
and see which weight is the minimum
right
another way the way i like to look at it
which is a little bit more fun
i think is once i'm down here
i'm just trying to find simple paths in
the graph
from this vertex v right
to this vertex v right so one of the
so actually um add these
go up
so actually on this bottom layer right
i want to find ver uh
short paths to t from actually every
vertex
right and i actually know
what the short just from from what i did
up here dag relaxation on this graph
i knew what the shortest path distance
was from s0
to each of these vertices because i did
that in v cube time
up here with dag relaxation so i could
add a super node to this thing with a
directed edge
to each vertex with the
shortest with weighted by the shortest
path distance i found up above
now i have a graph where any
path from s0 to
v to t v here
will be a path that uses at least
the edges in my original graph right
because these represent the shortest
path weights of
anything using exactly the edges
and then the path can continue in the
original graph
right so now i have a new graph here
such that every path from here to there
corresponds to a path that i'm looking
for
so i want to find a minimum weight path
in this graph how can i do that
now this graph might have negative
negative weights
i can run this with bellman ford
fellman ford
i can do that again sure why not
now jason
why couldn't we just add a bunch of
edges here right
at our original edges here in the bottom
layer of this graph
and run bellman ford on this entire
graph why couldn't i do that
it's too big right the number of
vertices is v squared the number of
edges is v
potentially v cubed running bellman ford
on that huge duplicated graph
would give me a v to the fifth running
time which is awful
right in a sense we're separating out
the complexity
the upper part of the graph has very
nice dag structure so let's do shortest
paths in that dag structure
and then reduce that complexity down
to just being the thing that has the
cycles that we
are are worried about that reduce the
complexity down here so how big is this
graph this graph has
you know uh v plus
one vertices right because i only added
one super node here
and it has e plus
you know order v edges i don't want to
be careful here
but it's this is linear in the size of
the original graph
so running bellman ford here only takes
v times e time
which is v cubed so that's two different
ways how to solve this problem
one using a bunch of graph duplication
and having the
the insights that going at most
the more steps of this graph duplication
could never get a better thing so i can
stop
or recognizing that well i have this
very powerful algorithm here
that can find shortest paths simple
paths in a graph without negative weight
cycles
and i can use this super note to
transfer
a part of my graph with a lot of nice
structure
down to this other graph okay
any questions about this problem so
these are some
we got two abstract problems for you two
word problems for you
uh with a lot of different
transformations and a lot of different
tricks of your trade uh
any of these would be a uh
something that is either appeared on an
exam or is at a level of something that
could appear on your exam
uh so go ahead and take a look at the
practice material that we've posted
and are accessible from previous years
uh websites
and wish you luck in working on graph
problems
on your exam