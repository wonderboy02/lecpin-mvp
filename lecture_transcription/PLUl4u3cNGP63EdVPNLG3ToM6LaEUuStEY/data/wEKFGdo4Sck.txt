hey everybody uh welcome back this is
our
last uh quiz review for the term uh quiz
three we'll be talking about which will
be the last quiz until the final
uh it's on dynamic programming which you
guys have been studying
in lectures and recitations and on your
problem sets seven and
eight um and lectures
fifteen through eighteen so four
lectures uh
quiz one and quiz two material on uh
essentially data structures and graph
algorithms aren't going to be
explicitly test or we're not trying to
explicitly test it
that material on quiz 3 but uh
you know it is fair game uh the material
is cumulative and so if
you know you have to store some stuff in
the data structure that's that's fair
game but we're not specifically trying
to test you on that material
okay and really we haven't learned all
that much
new material in these last four lectures
or this last unit
uh so right so this is scope we've got
uh you know we're mostly handling
dynamic programming
uh on these these four lectures and
recitations and these two problem sets
but really the focus is going to be on
this recursive framework
of solving problems with a focus on
dynamic programming specifically
now the recursive framework we've we
have
i think in previous
slides we use this uh sort bot notation
and i think there might be a space
there uh in in previous versions i'm
concatenating them together here
but really it's it's a framework for
solving breaking down your problem
into a set of sub-problems that can then
be related recursively
and if that relationship depends on
problems in a
decreasing or in a smaller sense right
there's a directionality to
which subproblems i'm reducing to each
time i make a recursive call
and that dependency graph is acyclic
then we can solve
via dynamic programming by memoizing
from bottom up
or by calling things and remembering the
calls that we've
we've called before uh via memoization
right and the basic idea here is this
the recursive framework
sort bot that we established
is good for any recursive algorithm
but in the special case where
subproblems made
may be used more than once may be used
when computing other subproblems then we
get this really nice
uh speed up by recognizing that we don't
have to do that work more than once
and essentially instead of looking at it
as a tree of recursive calls
that may recall the same problems more
than once we look at it by collapsing
those nodes of the same
value down into one we get a dag
and dynamic programming is is when those
sub-problems overlap okay so let's take
a look about
at uh our recursive framework here
sort bot we have the s-r-t-b-o-t
i remembered the space this time a sub
problem
you're going to define some sub problems
you're going to relate them recursively
you're going to specify a topological
order of those sub problems
that the relation satisfies uh
you're going to list some base cases
basically wherever
you could solve the sub-problem in
constant time without doing any
recursive work
stating how you solve the original
problem which
might involve combining many
sub-problems but
frequently is just you know finding one
sub-problem
and possibly remembering storing parent
pointers to return an optimal sequence
or something like that
and then analyze the time now the last
one isn't really
important for solving a problem
recursively but in this class it's
really important because we want to
tell whether the algorithms that we make
are efficient so
let's dive a little deeper into each one
of these things
so when we approach a sub-problem
really what i'm asking you for is to
describe
basically set up a set of sub-problems
basically
i like to use the variable x but you can
use whatever variable you want
but basically you're telling us what's
in your memo and how big your memo is
right so we we usually have x
as a function of some variables
and you're wanting to describe to me
what the meaning of that sub-problem is
in terms of the parameters
now if you have parameters in your
sub-problem that don't appear
in your sub-problem definition you're
doing it wrong and you're probably not
going to get points for the problem
because i don't know what your
sub-problem means now right even if it's
a correct sub-problem and you do the
rest of it right
part of this class is about
communication and if you're not
communicating to us what this
thing is doing it's really difficult for
you us to
for us for you to convince us that your
algorithm is correct
right so you really want to in words
describe
what the output of your sub problem is
what will the memo return to me
and how those return values depend on
the inputs
right the parameters of your sub problem
right so that's what in words describe
what a sub problem means so that's
that's going to be a really important
thing for you not to
forget on a quiz then when making sub
problems often
what we're doing is we're recursing
on different values of indices in a
sequence
or numbers in your problem right that's
kind of what we got to in the last
in lecture 18 i guess uh when we were
talking about
expanding subproblems based on an
integer in a problem now actually
an integer in our problem is the number
of things in a sequence
right and so really those indices are
integers in our problem that we're
looping over except those integers
happen to be the size of our subproblem
whereas
other integers might be larger which is
why you might get a pseudo-polynomial
time bound
okay but in general when i have a
sequence of things that i might want to
dynamic program over common choices for
sub-problems are preface prefixes or
suffixes
if i can kind of locally figure out to
do with one
what to do with one item and then
recurse
or if i can't kind of localize it by one
choice on one side
if i have to make a choice in the middle
or i have to make a choice on both ends
then you might want to use sub right so
basically contiguous subsequences
of your sequence because you might need
that flexibility
when recursing downward if you need to
take something from both the front and
the back for example
right and really what's the difference
between prefixes and suffixes
not much okay we've been concentrating
on suffixes in this class because
in some sense it's easier to think about
what am i doing with the first
thing in my sequence or my you know
suffix
and then i can recurse on what happens
later now in actuality
when you're doing this say
bottom up right the actual computation
that is evaluated first
is where in that sequence
right i may be calling at the top level
what happens to my first element but
i'll actually
deal with that first element last right
because i will recursively solve
everything below me
right in front of me before i figure out
what to do with this thing
right so in actuality when i'm solving
uh my recursion i will start at the end
bottom up right because that's my base
case
and then i'll work my way back to the
front whereas with prefixes
you look at it the other way what do i'm
doing with my last element
right if i look at what i'm doing at the
last time i recurse on a prefix on the
stuff that's before me
and then when i do bottom up i start
from the front
and work my way up right it's just it's
two different sides of the same coin
and usually these are interchangeable
we've been doing it
suffix wise because uh when
starting to learn dynamic programming
it's it's a lot
we read things from left to right and
things like that it's a lot easier to
figure out what's happening with the
first thing
and move forward conceptually it's
actually exactly the same thing
i could just flip my sequence
do the exact same thing with prefixes it
would be the exact same dynamic program
right so there's these things are
interchangeable
it's just it's really useful when
learning into dynamic program
to be able to switch back and forth
between these things
we'll be working on suffixes today on
the problems that we do
but these are interchangeable and
sometimes it's useful to be able to
conceptually think about it
in both directions okay
so aside from dealing with subsequences
of sequences in particular contiguous
ones
uh we also often multiply our subsets uh
across multiple inputs like if we have
uh
multiple sequences we might take indices
in each one of them to represent
prefixes or suffixes
and then we might have to remember
additional information by maintaining
some
auxiliary information like am i trying
to
maximize or minimize my sum in a
or evaluated expression in an arithmetic
parenthesization
or is it player one's turn or players
two turn
right uh or which finger where where was
my finger in when i was playing piano or
something like that right those are the
kinds of things that we might
expand our state on and in particular we
might expand our state based on the
numbers
in our problem if we're trying to for
example keep track of how much space is
left in a knapsack
or something like that right but in
general if i'm trying to
uh say pack a set of things it's useful
to know
how much space i have left
to pack okay so that's subproblems
this is really the key part about
dynamic programming
is the recursive part this is what makes
it hard is choosing a set of sub
problems
and it's often you build sub problems to
fit well with a relation so usually the
building what these sub problems are is
usual
usually closely coupled with the next
step which is relating the sub problems
recursively
and if i relate recursively i usually
what i want
is an expression a mathematical
expression
relating the uh
definition of a of a sub problem you had
in the previous section
relating those in math terms
to the other things this is it's really
important that you
write this in math because it needs to
be precise
to communicate this thing well now you
can write it in words
but i would suggest you write it as a
mathematical expression
because it's a lot more concise for us
to see what's happening
in your recursion so relate them
recursively
basically i'm going to write say that x
of some set of parameters
equals some function usually a
maximization or a minimization or a
summation
or an or or an and or some some other
combinator
of a bunch of choices that you might
make right
so uh or a bunch of sub-problems that
you might recurse on
basically you're going to depend on some
other sub-problems
that are smaller in some sense now
actually embedded in this the idea of a
smaller sub problem isn't really well
defined yet
right we haven't told you an ordering
of these sub-problems to be smaller
but that's what's going to come in the
third step right
so kind of a strategy for
figuring out what these recursive
relations might be is to identify some
question about the subproblem solution
right uh what do i do with the first
character in this string
or um you know
which cage do i put this tiger in right
to to figure out what sub problem should
i recurse on later i don't know the
answer to that question
but if i knew the answer to that
question then i could
recurse on a smaller sub problem because
i've figured out what to do with that
tiger right and so
it will let me reduce to smaller
subproblems and then
what dynamic programming does is because
i only have a polynomial
number of sub-problems and i've assumed
i've already computed what those
those are i've already already memorized
memoized
what the solutions to those sub-problems
are then i can just locally brute force
over all the possible answers to that
question and that's just one way to look
at dynamic programming
okay so then as we were talking about
topological order
arguing that relation is a cyclic
essentially just defining what smaller
means
when we say we're recursing on smaller
sub-problems what a smaller mean
usually you're saying that some
index or some parameter of my
sub-problem decrease always decreases or
increases
sometimes that's not always the case
some sometimes you have to maybe add a
couple
indices and see that that always
increases because
one may stay the same while the other
increases or something like that
but in general as long as you argue that
the relations are acyclic
then the subproblem graph is a dag and
you can compute in a bottom-up manner
and you don't get infinite loops in your
recursion right
okay the last thing uh the last couple
things are kind of bookkeeping
but if you don't write these on your
exam we can't give you points for them
so write these down uh base cases
if if you don't tell us base cases then
your algorithm cannot be
polynomial time it can't even be pi
finite time because your algorithm never
stops
right it just continues to recurse
forever and ever and ever
and so it's hard to give us points i
mean we will give you some points
if your sub problems in relation are
correct but
really if you write code without a base
case
it's going to be wrong right so base
cases are
really important basically for any
anything at the bounds of your
computation wherever your recursive
relation
would essentially go outside the bounds
of your memo
right let's say i'm i'm dealing with a
subsequence and at some point i'm
trying to point to a state where
i have zero or negative elements in my
sequence
that's probably a bad thing and so i
want to define
how to compute those things in constant
time
so that my algorithm can terminate when
it gets to one of those
you know base cases so for
it's really important that you cover all
of those possible
leaf locations where you want to be able
to return in constant time and we'll
we'll do some of that today
uh state solutions for all reachable
independent
sub-problems where the relation breaks
down essentially
i would be going outside the bounds of
my my thing or
you know anything where like maybe if
you've got one
item left you might say well i have no
choice on what to do with that item i
have to pick it or something like that
okay then for
your original problem you show how to
compute
solution to the original problem from
the solutions
of your sub-problems so uh so
that usually this is just here's a
sub-problem
it's the one that used all of the things
and that's going to be my answer right
that's not always the case right
sometimes like in
a longest increasing subsequence we had
to take a max over all of our sub
problems that we computed
or max sub array sum we also had to do
that
right uh but uh but in general
the output to our subproblems wants to
be some scalar value that we're trying
to optimize or a boolean or something
like that right
it's how we maximize or minimize
uh what we're doing we're not storing
the entire sequence of how we got there
because there could be an exponential
number of possible subsequences that got
there
that's the whole point of dynamic
programming we're kind of isolating the
complexity of one sub problem down to a
single number
right but in a lot of problems we might
want to reconstruct
say the placement of tigers into cages
and not just uh how
what's the minimum discomfort over all
tigers or something like that right like
you add in your problem set
right so i actually want to know where
to put tigers into cages
and to do that every time i maximize a
sub problem i can remember which sub
problem
or sub problems i depended on just
like storing parent pointers in shortest
paths
and then using those parent pointers i
can just walk back
in my subproblem graph and and figure
out which
uh path to a base case lead led me to
an optimal solution okay and then the
last thing
is analyzing running time generally
you're just summing the work done
by each sub problem because the
assumption is you're calculating all of
the sub problems you described to me
uh and but but if the work per
subproblem is bounded by
the same value you can just multiply it
out right so that's
that's generally a a weaker bound but
usually asymptotically equivalent to the
stronger
uh notion on the left uh
and and that's basically how you do
running time usually
it's enough to how do i define to
determine
how many sub problems i have well i look
at the possible values of each of my
parameters
and then i multiply those numbers
together right a lot of people will
maybe say oh i add them together
no because i'm able to choose each of
these independently
and so i multiply those things together
and then
the the work done by each sum problem is
usually
the size of the thing i'm maximizing
over or minimizing over or
summing in my relation right it's going
to be the size of that
the branching that i have the number of
sub problems i depend on
and so the number of subproblems you
probably look at your
sub problem statement definition to find
the work done
by each subproblem you look at your
recursive relation okay
so with that we've got this really nice
framework
and we're going to use it to solve some
practice problems
happy days and these are a little bit
longer
in terms of uh
description than our previous quiz 2
review
so uh i'm going to go ahead and read
them out for you
this one's a little shorter okay tiffany
bannon stumbles upon a lottery chart
dropped by a time traveler from the
future which lists winning lottery
numbers and positive integer cash
payouts for the next n days
anyone get the reference here tiffany
bannon
biff tannen from uh some
back to the future thing okay so this
was actually
i think it's the second back to the
future movie where this happens
um anyway tiffany wants to use this
information to make money because she
knows the future about the lottery
but is worried that if she plays winning
numbers every day lottery organizers
will get suspicious and shut her down
right so the idea here is
maybe it's still suspicious but decides
to play the lottery infrequently
at most twice in any seven day period
but an issue well she'll win right but
uh it's infrequent enough that eh maybe
that's by chance
maybe not describe a linear time
algorithm to determine the maximum
amount of lottery winnings tiff
tiffany can win in the next n days by
playing the lottery infrequently now
this was
a particularly difficult type of pset
uh or first pset on dynamic programming
problem but let's try to do it together
so this is problem one i'm gonna just
call it lotto
okay so how can we
deal with subproblems here well i might
wanna think about
what do i do on the first day
am i going to play the lottery or not
and then recurse on the rest
that sounds good right so some i might
have something like
uh well let's say that l of i
is the uh winnings
on day i
this is kind of just like i this doesn't
define me some notation on what the cash
payouts are and so i'm
making a variable to do that and
for the sake of what's written down on
my sheet i'm going to assume that these
is one indexed i don't know why
okay okay so i have days one to n
i know what their lottery payouts are so
i might when i'm doing my sort bot stuff
i have
sub problems right what i might want to
do
is see what happens on day one and
recurse on what's later
so i might have something like x of i
is max winnings
uh for i guess possible
for days i
to n okay anyone have a problem with
this
type of sub problem let's see let's kind
of
see what this type of sub problem would
lead me to
i can either in my relate step
what are my choices i can either play on
day i
or i cannot play on day i right if i
i'm i'm trying to maximize this thing
maximize
either if i play on day i get
l i and then i can recurse on the
remainder
or i don't play on l i and i recurse on
the remainder
anyone like this recurrence why don't we
like this recurrence
i'm just always going to pick this thing
these things are always positive i think
it's just positive integer payouts yeah
and so i'm always going to pick li and
the problem here is that it's not
obeying or dealing with this condition
that i have
which is i'm only allowed to play twice
a week or not
not quite twice a week it's not a fixed
week-long period
it's within any consecutive seven-day
period which is a little confusing
how can i remember what days i'm allowed
to pick later on it seems
a little daunting okay
in a sense for me to know right like
this is
max winning possible for days i to n but
in some sense it depends on
which days i picked before right because
if i picked i
minus one right i can't
pick another day for another six days
right if i have uh
right so i have let's do this precisely
this is i minus one
right i have seven day period one two
three
four five six seven
right if i uh
played the lottery here and i played the
lottery here
then i'm not allowed to play the lottery
here i'm not allowed to play here not
allowed to play here not allowed to play
here
not allowed to play here i am allowed to
play here
right so this is i plus 1 plus 2 plus 3
plus 4 plus 5 plus 6
i plus 6.
so depending on what happened before me
i might not be able to play until day i
plus six
but if i haven't played until since like
way back here i could potentially play
the next guy i don't actually know which
of these i can play on next
in some sense i need to remember which
days
i'm allowed to play on next and i want
to be able to jet like at the beginning
i have no restrictions i can i can just
play on this guy
next even if i if i played there
but in general i need i i will be
restricted in some way
between being able to play on this guy
and being able to play on this one guy
and so what i'm going to do is i'm going
to generalize my sub problems
by storing additional information so
that i can
rely on that information when i look
into the future
and recurse okay so instead of
uh i'm going to in some sense need to
remember
two days right
where was the last two places i played
i'm going to simplify that a little bit
by saying that
this sub problem max winnings possible
for days
i to n i'm going to
say that i have to play on day i okay
similar restriction as longest
increasing subsequence right
i'm definitely including this in my
subsequence that's just going to make it
easier
for me to be like oh i definitely know i
played on this day
right it's going to be make it easier
for my thinking so
assuming play
on day i
and actually i need to remember what's
the next day i can play
okay so i'm going to expand this sub
problem by
another i guess this is a j
okay assuming i play on day i
and i'm allowed to play
uh i guessed and next
allowable
play on
day i plus j
for
what are my possible range of days for
jay
i can either play the next day
but i never restricted past day i plus
six right because
the things before me further to the
right because i haven't dealt with them
yet right so
i only have to deal with this from one
to six
well this is nice because it expanded my
sub problems by a constant number
right so i actually didn't lose anything
asymptotically
by remembering this information but i'm
kind of
i'm able to remember all the things that
could have happened before me
i compress it into this one number okay
so
now let's rewrite our relation i'm
actually going to
go ahead and use some more board space
because
i think that's easier than erasing
all right so we're looking at my
relation
this is a pretty complicated relation
but what's happening now now
uh i'm assuming i play on day i
that actually simplifies things a little
bit because no matter what
i get the winnings on day i okay
now when i call this sub problem i
better make sure that it's okay that i
played on day i
but that's that's for my caller right i
am locally allowed to play on day i am
playing on day out right
that's the definition of my sub problem
so
x of i is i'm going to maximize over
some choice right max
of i guess i have l i no matter what
so this could actually come out of my
max
and then i'm going to choose what am i
choosing here i'm not choosing whether
i'm playing on day i
i'm choosing what my next day i play is
so that then i can recurse on that sub
problem
so what day can i play on well i'm kind
of restricted
by this j parameter that i didn't add
into my sub problem
on what possible days i can play next
right
i'm going to split that into a
kind of compress that into one thing
so x i can
play on i have a choice of
the next day i play somewhere between
j which is my next allowable play and
sometime in the future
right so i plus
k this is going to be my loop that i'm
looping over in terms of my max
and then what am i restricted on
in my play right it depends on
how far i am from i right
so if i'm here
this is i if i choose k
to be the next day i can't play
for many many times so
like the sub problem i'm going to
rehearse on
is uh this is
i plus k i'm going to recurse on i
plus k but i'm not
able to j needs to be the max it can be
right because i can't play uh
until i plus six right so this i
plus k plus six is going to be my thing
so
let's see so i'm going to put
let's see if i can unpack what i wrote
down here
max of 1 7 minus k
yuck
oh i'll put it here
1 7 minus k okay if i
if i pick k
i'm not aggressive as toward these
boards as justin is
um okay so
if i get if i pick a way down here
right they're not restricted at all
right and so the
the most permissive option i have here
is one
right so i definitely can't be worse
than one right
but if i pick uh
and then this needs to be some number
between
six and one right and so i can just
check the other bound right
if this is the most restrictive right
then this should be uh six
right so when k equals one this should
be six and it decreases
every time further back or further
forward i choose this k
right so that's what my sub problem is
going to be
and i'm choosing over k
in uh from j
j uh sorry i plus j
so sorry j thank you
until what
that's the question until what do i have
to
loop over n if i loop over and i'm going
to get a quadratic running time
which is worse than what i'm allowed to
do the assumption is
that i only have to check a constant
number of these and why might that be
any ideas let's say i'm
got my sub problem i'm recursing i've
got i
yeah i don't know where j is j is
somewhere over here
one two three maybe it's four or
something like that
let's say i pick some k down here what
is this this is i
plus so this is j is 4
5 6 7 8 9 10 11 12 13 14 15
15 way over here like two weeks later
is it ever optimal for me to do that
why not
yeah i could play the lotto in the
middle here right right i'm
i'm within seven like from here to there
that's a seven
where i only played once and from here
to here that's a seven day period where
i only played once
right so it's going to be more these are
positive values so it's going to be more
optimal for me to choose something in
here to play
right so how far i mean i could just use
that would satisfy right because i've
already argued to you that it's never
optimal to i can check this
it's not going to be optimal it's going
to be more optimal to play sometime over
here
right but how far do i have to check
well maybe i have to check up to seven
does that work
not quite so let's say i played here
and i played here
and i played here and i played here
right i actually
can't play here here here
here here right i'm not allowed to play
those
i guess these should be o's i played
there
and i'm not allowed to play here one two
three four
five right but i am allowed to play
anywhere in here
so i basically want to shrink this until
these x's
collide with each other because then it
it's possible that an optimal solution
would require me to pick these two
and then require me to pick these two
way over there right
so this is 10 things in the middle i
only have to go up to at most 11.
okay it's 11.
now you could use any constant above 11
and get the same running time bound but
that's that's my analysis
okay so we have our recursive relation
uh and so what am i doing i'm just
looping over my choices of next day to
play
i'm recursing on this thing where i
actually do play on that day
right but i'm remembering the
information about what i'm allowed to
play next
by limiting based on what my previous
value was
okay so that's the kind of key thing i'm
remembering something further in advance
or
i'm remembering what happened in the
past by
describing it as a restriction of
something in the future
okay so this was a pretty difficult
problem i think it was one of our first
dynamic programming problems on that
term
it was probably a little ambitious okay
yeah yes the recurrence goes up to 11
not ten
eleven okay uh
so we have our topological sort
what's a topological sort for these
subproblems anybody
k is always going to be a positive
number right because j goes from 1 to 6.
so i'm always going to be increasing in
this first quantity right so
for x of i j
i always uh or
sorry depends
on strictly
larger
i right so
this i when i call subproblems it always
calls subproblems with a larger eye
now this is a little weird because i
wanted me to depend on
smaller sub problems smaller
now it is smaller because i'm taking a
smaller suffix
but it's corresponding to using a larger
number
to me that's a little confusing but
that's okay because we're kind of
using things that are always
monotonically going in some direction
so this is corresponding to a smaller
sub problem
in some some measure right it's the
number of elements
that we're actually recursing on in some
sense if we
wrote this as a prefix we would have
us depending on strictly smaller i
and that would be more natural in terms
of a recursing on smaller sub-problems
but i digress okay all right then
we have our original subproblem
i'm gonna i can't move this board
i'll just keep going because we have
lots of boards
okay our original subproblem now
what could i do i have to start
somewhere
right here my sub problems assume that
i'm starting at i
but i don't know where i start i could
start by taking the first element but i
might not
so i could just take the max
over all you know i
overall i of x i
what
the first one i'm not restricted on what
i choose next
so what's the most permissive version of
jay
one right i'm allowed to take the next
today
right so if i just take the max over all
of these sub problems
i'll get the solution now actually this
is a little bit more work than i need
this is looping over all
n right
it's definitely correct right because i
have to start somewhere
but will i ever start after the first i
don't know seven
no right so i could just take this max
over the first some constant number
and that would be fine but that's okay
this is still smaller than the number of
subproblems that we have yeah
if i were being lazy during my exam and
i looked over jay
would that be correct if i looped over j
for every possible thing
took took the loop over this and j
yeah that would still be fine why not
it's just
less it's it's it's more restrictive of
sub problems
it will never be better to do that
but you could do that because it
wouldn't change your running time
uh could it change my running time if my
j accidentally moved too far
well j is restricted to be one to six so
i'm not
i i don't i don't think so but in a
different problem in a different context
it could
okay so that's the original and then
time here
what do we got we have a linear number
of subproblems
number of sub problems we've got uh
i actually like usually saying exactly
how many subproblems i have
oh we didn't do base case i missed bot
i missed my b
we'll do the original first and then the
base case okay
base case what do we have is our base
case here
well when i don't have anything to do
right
if i'm and actually
if i have this situation
for i equals
say n
right i've got my last thing
i could potentially start looping over
sub problems that are negative
in terms of my index i'm not going to
want to do that there's a couple ways i
can deal with that
i could set a value for all of my sub
problems for negative ah
that's one thing i could do but then i
have to kind of remember
or i have to figure out how far i go
into the negative
right that's one thing i could do and i
give a base case for each of those cases
i don't have anything
so i get like a i don't know
uh zero value for playing
in the future right because i have
negative things i can't do anything with
that
another way of handling that which i
think i did in my
solutions was restrict that
k to only be i guess
and restrict that i plus
k is less than or equal to n
and then i'll never go to negative sub
problems i'll never a curse on these
things
but that means that when i call this on
n
right when i only have one lottery day
left
this set will be empty
so what's the max over that thing max
over an empty set
i don't know i mean i could add on zero
here that's one way i could do it or i
could just say when i'm at n
and that thing is empty right
or you know whenever it's empty
right we can say the base case x i
j i guess we could put this at n
equals zero or sorry equals
l of i right
l of n thank you because
at the last guy i have to use ln
so there it is right now in actuality
if you write this correctly right i put
the li
outside and i union this with a zero
i can actually get away with just having
the relation
and no base case because my relation
actually reduces to a base case
because i of the way that i wrote my
relation
but in general you'll want to write some
kind of base case here
to either acknowledge that your relation
handles it
or being specific about what happens
when i can't do any more work right
right so and the last thing time we've
got
n sub problems exactly
times constant work per sub problem
because i'm looping
over 11 possible values actually it's
up to 11 right because j could be six
so this is order n work total
okay so this is a pretty daunting first
problem
but what in in terms of what uh
uh eric professor domain was talking
about
last uh lecture uh in terms of
categorization of subproblem
or categorization of azation of dynamic
programs
what do we got we've got a suffix
subproblem where we expanded by some
local information
right remembering how uh when's the next
time i can
i can play so that's kind of a
categorization of these sub problems
the recurrence relation has
constant branching but more than like
two branching
right and uh
i'm combining a bunch of sub problems
right in my original
evaluation right and if i wanted to
figure out what days tif should play
on the lottery you can store parent
pointers
when i'm do evaluating this max
right i figure out which subproblem
x i recursed that gave me the max
and i can walk back to see which choices
i made
to figure out which days i played the
lottery does that make sense
so any questions on problem one
that's the most that was i i want to
have the
most complicated one first so that we
could have an easier
way to go in in a sense this is the most
complicated
version of this kind of actually pretty
simple
dynamic programming setup why do i say
simple dynamic programming setup
it's just suffixes and i'm just doing a
constant amount of work
local to me it's just a very complicated
local setup
okay but that's what i mean by
simple when we're designing subproblems
this is one that we could
i mean when we're designing problems for
this dynamic programming setup
it's one of the hardest
from a it's one of the easiest from a
conceptual standpoint
but one of the hardest to actually
implement okay
so problem two this one's a longing
okay a wealthy family alice bob and
their young son charlie are sailing
around the world
when they encounter a massive storm
charlie is thrown overboard
presumed drowned okay this is very
colorful language for these problem set
writers
twenty years later a man comes to alice
and bob claiming to be charlie
having maybe been marooned on an island
for that long
okay alice and bob are excited but
skeptical and they order a dna matching
test from the genetic
testing company 46 and the
uh given alice and sorry
given three length n dna sequences
basically strings of cgta or something
like that
from each of alice bob and charlie the
testing center will determine
three uh their answer accessory
as follows if charlie's dna can be
partitioned
into two not necessarily contiguous
subsequences of equal length
so basically i take i can take the if i
have
n is a length five right or at length
six it's better be even
i need to find three characters in order
and then
the other three characters
must match to make some sub strings
in some subsequences in alice and bob's
dna
okay so uh there's that's a little hard
to parse so let's look at an example
here
for example alice's dna is aat
bob's dna is ccgg
if charlie's dna were c-a-t-g
they'd be matched right because c g
is a sub-sequence of charlie's dna and
is a subsequence of bob's
uh ba bob's dna
and a t is a subsequence of charlie's
dna
and is also a subsequence of alice's dna
and so we've partitioned them into two
equal length subsequences these are not
necessarily
consecutive subsequences but just any
subsequences
such that uh
that that uh they appear in alice and
bob
but if charlie would be found to be an
imposter if his dna sequence were
a g t c essentially it's easy to
to realize that because g and c
are swapped in terms of their ordering
and g c the letters gc
only appear in bob's dna and don't
appear in that order
right so it's easy to see that he's an
imposter with these strings but you can
imagine with longer strings this could
be difficult to solve
right so we want an n to the fourth time
algorithm
to determine whether charlie is a fraud
okay
so i actually shortened this last night
this was like twice as long on the
problem set so
yeah anyway so how do we approach this
problem yes
no they don't have to be contiguous like
in the example it would be matched if
c and g is a subsequence not contiguous
of c
a t g yeah so that's an important part
of this problem
i'm just i'm not trying to figure out if
there's
basically there are only two sub
contiguous subsequences of length 2n
that this thing can be partitioned and i
just look in the middle no
we're looking for subsequences not sub
strings
so they kind of interleave like this in
some way
and there's actually a number of
different ways i can partition that
there's actually an exponential number
of ways
so that's a problem potentially yes is
there a biological basis no there's no
biological basis to this thing
that i know of okay all right
so how do we solve this problem
what problem does this look like
i mean it seems like string matching
right so i might want to think it's
something like longest common
subsequence right
but here i have three sequences instead
of
two sequences and we've got this other
weird condition
where we kind of need an exact partition
of charlie
right i need to use all of the letters
in charlie but i don't have to use all
of the letters in
alice and bob right so let's just let's
get some notation here
you know a b and c are
n length
strings right so what could i do
let's define some sub sub problems
if i were to
go via longest common subsequence
i might keep track of an index of a
suffix or prefix
of each one of these strings right that
kind of makes sense
something like i j
k where we're talking about the
suffixes uh sorry
that's prefixes i
b j and
c k right
that seems reasonable at least right
it's it's what we would do
for longest common subsequence
what's the problem here i mean
i could match this guy with one of these
guys
or decide to skip it and match one of
these guys and decide to skip
it but if i do that
i might get a subsequence
but actually i always need to match all
of c
does that make sense always need to
match
all of c right
so in a sense
let's see let's see how can i do this uh
i need to match all of c but i also need
to make sure i'm using exactly n over
two characters
from c in blue and exactly n over two
characters
from c in a
does that make sense how can i
satisfy that condition now i understand
why i used prefixes before
and i swapped it to suffixes here
but we'll make it work how can i
remember
how many characters i assigned from
alice versus bob right as i'm
matching characters in alice and bob
i need to kind of remember where they
point to
or how many i've already used in in
charlie so that i can give you up the
remainder
right in here oh actually this
works in a different sense
there's like 18 different ways we could
do this so
okay so i need to remember
how many i've already used up so that i
can be sure to allocate exactly that
many characters in the future
to either alice or bob right
so how can i remember that
i can just remember how many do i
i'll do it the way that i did it before
which is i can remember i can remember
two different things here
i can remember how many things i have
left to match in alice
in c where i can remember how many
things i've
already matched nc to alice
okay if i talk about how many things
i've
already matched then i can index this
thing
by the sum of those things if i talk
about
how many things i have yet to match i
have to do like n
minus the things okay
so those are the different parameters we
can do
we'll do what's in my notes and i'll try
to fix it
okay so
what we're going to do is remember or
figure out how many things i'm still
needing to match
in c to alice and bob right so i'm going
to call this
k sorry
k i i is associated with a
and b is associated with j
and k j
okay this is going to be
the
i have to write this down well okay so
this is going to be
what kind of output do i want to my sub
problem i just want to know if these
things are
if he's a fraud or not so this is going
to be a boolean
right so true if
can match
k i
length
sub sequence of
suffix
a suffix is this guy
and length
uh kj i guess
kj length subsequence
of suffix
b j i
or bj suffix right
uh to
all characters
in and now what is this in this is the
hard part
do i need a separate index
for c to know where i am and see
in a sense yes i need to know where i am
in c
how much i have to match right but if i
need to match
k i to kj to all of them
then there better be ki plus j things
left in
c right so i in a sense i don't need to
remember that information again
it's not independent to my other
parameters i can compute it
right i can throw it in but i can
determine it from the other parameters
right so i want to match it with the
suffix
of c of length k i plus k
j so i think this is the only part that
is going to be annoying to me okay
so this should be suffix
of all of the things
minus k i minus kj
minus 1.
it's just this and why is that
okay if i've matched everything
k i and kj are both zero
and i should have nothing in c which
should be
n colon okay
we're zero index yes we are i use
whenever i use python notation
i better be zero index okay
does this make sense as a sub problem i
mean it's confusing
but hopefully it makes sense right what
i'm going to try to do is i'm going to
match
some number of characters in this subfix
which is
hopefully longer than kj ki right
otherwise it's i'm going to be in a base
case where this is impossible
right and some subsequence of this
matched completely into this all right
so that's
those are my sub problems i'm going to
try to relate them
now we have x
i j
k i k j
what is this going to equal all right
well we've got booleans so this is
and false
otherwise okay that's it's a problem
right
so i just need some sub problem i
recurse on to be true
so what's the combinator for sum
of a bunch of choices boolean cases
any one of which may be true
i want to combine a bunch of them i just
want to see if any of them are true
i'm going to or over them okay
and i'm going to or over four choices
okay what are my choices
either the the first thing in a
matches with c the first thing in b
matches with c or i don't match with
either
right so those are my four tropes
so if i match with a
i plus one i recurse on a smaller suffix
of a
and a
by adding oh this all just works great
kj this is i
if a i
equals c i
and a i
is greater than zero right so if
k i is greater than zero i need to match
an i
right so this this conditional doesn't
even make sense
unless i've evaluated this k i to be
bigger than zero otherwise i'm trying to
access i
of n right so i'm just putting this
conditional on there
same with matching b i
j plus one k i
k j plus one
if sorry this should be minus
one i'm i have fewer characters that i
have to
recurse on so that's a typo in my notes
uh b
j equals c
oh this is not ci what is this it's
whatever that thing is
so i'm going to just say question mark
and kj is greater than 0.
so i'll fill that in in the notes it's
going to be some complicated expression
that looks like that
okay it's exactly that expression
yes that it is so it's it's that thing
okay then
we have two more choices either i
if i if i didn't match a i
i may match bj in the future so i only
want to
reduce ai so x i
plus 1 i leave everything else the same
assuming if i
less than n right i don't want to
move off the end of this thing or
x i j plus 1
k i kj
if j is less than n
okay so those are my four choices if i
match the letter i'm great
otherwise i decrease the size of my sub
problem and i recurse
okay
so fun recursion topological sort right
these subproblems only
depend on
what larger i
not quite larger j
not quite changing
k or d don't even change here
so we're going to use depend on larger
i guess strictly
that's kind of an important thing i plus
j
right because at least one of these two
things is increasing
and then the nice thing about that is it
kind of tells us when we should stop
right we should stop when either i
or j get to n we should know
enough at that point to be able to
determine
if we succeeded or not possible
so we have our base case
what's the easy base case when
we succeeded when have we succeeded
if we have nothing left in a and b
and we have nothing left in c right i
have nothing left to match so i have
n n and i don't need to match anything
else
that's just going to be true right
all roads point to this sub problem
to get to a true solution right
otherwise we have some false space cases
if you set us as
something up like this and you only give
us a base case that's true
and you're oring over the things your
answer will always be true so you're not
having any discriminatory power at all
if you give us a
true base case you better be giving us
some false base cases
or one at least so in the case where
the first one is n
and we have some i kj
this is going to be false if
what
if we have nothing left in a i
or i o but
this guy is positive we got problems
right otherwise this thing is zero
and we'll just try to match everything
up here and eventually
we'll get down to this base case or
something where
this thing goes to zero and we've got a
problem
it's the same goes for the other side as
well if we run out of things
in b
when the number of things we need to
match in b is greater than zero okay so
those are our base cases
the original problem is what
yeah it's just gonna be one of our sub
problems n n
and then n over two and n over two right
i'm trying to match
half of the things in c with half of the
things
right
zero thank you uh
because we're zero index yes again
that's
switching from prefix suffixes in the
middle was fun so anyway
and it better be the case that n is two
or else it's obviously false or it is
even
or else this is obviously false okay
and then the last thing which i'm not
going to write down
is we have a constant work here
right because i'm just checking the
value of
four sub-problems and a conditional for
each
and i have how many sub problems i loops
over n
j loops over n k and k j loop over n
over two
so i get a quartic number of sub
problems
cortic running time as desired okay so
i'm not going to write that down
because i'm quite a bit late
i'm probably going to do just do one
more problem which is sad because the
last one is about gokimonpo
which is a fun fun problem gokimonpo
basically relies on i'm trying to catch
a bunch of pocket monsters
just monsters i think is in this and
you can either go to a location
and catch that monster for free
but that costs money because i have to
ride share there okay
or i don't have to go to that location
and i buy it on my in in-app purchase
but that cost me a different amount of
money okay
but buying it and i mean at purchase
kept me at the location i was previously
wherever i was
and so the the point of that problem is
i need to remember where i was
last so that i know how far i need to
travel
to get to my next monster okay so that's
going to be the last one that i'm not
going to be able to get to
number three is a problem about
tapas okay so
these all come from spring 18. 18 the
first two came from a problem set
uh these next two come from the final
exam that year
okay albert ratkins
uh he's on a diet uh but he has a
dinner at an upscale tapas bar where he
got many he's going to order many small
plates
okay there are n plates of food on the
menu
where you know each plate has a certain
information it has a volume a number of
calories in that dish
and a sweetness label basically zero or
one whether it's sweet or not
okay but he's on a diet and he wants to
eat no more than k calories during his
meal
but wants to fill his stomach as much as
possible because he wants to feel
full right so he wants to maximize the
volume that he fills
even though he wants to reduce the
number of calories like keep restrict
the number of calories
okay he also wants to order exactly
s sweet plates
okay so we've got this other condition
where
i need to make sure i'm eating a certain
number of sweet plates
it might be useful for me to remember
how many sweet plates i've already eaten
so i make sure that i eat that number
okay
without purchasing the same dish twice
okay so here's a condition
that's similar to the knapsack 0-1
problem versus a knapsack
kind of general problem am i allowed to
take more than one of these things or
not
here it's a restriction that i'm not
allowed to take
a plate more than once okay and i'm
going to try to describe
a order n k s time algorithm to find the
maximum
volume of food obert can eat given his
diet
okay so first thing i'm going to note
here is the the
one of the things that we talked about
at the last dynamic programming lecture
was is this a polynomial running time
that it's asking me for right actually
on your problem set eight
you were asked on each problem to
categorize whether the running time of
your algorithm was polynomial or not
and actually you don't have to solve the
problem in order to answer that question
if we give you the running time right if
we give you the running time you can
just take a look at that running time
and be like
oh is that polynomial in the size of my
input
and here it's is it all the ones
previously
were this one was the order n that was
an order n squared because
n was the number of things in my input
the number of words
it took to give you that input here
what do i have i have a triple of
numbers for each
plate there are n of them so n is
polynomial
s is polynomial because s
is smaller than n and it's positive
number
but k k is just some
number in my input right
is representable in potentially one word
that's the assumption
but it could have exponential size
depending on the size of my word
of my machine i don't know how big k is
relative to n
and so this is a pseudo-polynomial
running time
okay because k is just a number in my
problem
similar to subset sum similar to
knapsack which you guys did in lecture
and recitation and so if we ask you on
an exam
which we probably will whether certain
running times are polynomial or not
that's the logic that you go about it
how big is my input
what is my running time that i'm trying
to evaluate and
can i bound each of those terms in terms
of the size of my input
if not then you say it's
pseudopolynomial
okay all right so let's try to
tackle this problem now already because
we've got pseudopolynomial
uh you're thinking maybe this is going
to be knapsack-like or subset some like
okay what do i need to i'm just going to
go straight for sub problems here
uh actually i should probably say
what my things are meh this is fine
i gave notation up there didn't i okay
so
we're gonna have sub problems i'm gonna
i want to maximize the number
the volume of food so that should
probably be the output
of my sub problem the max volume on
some subset of dishes right
i'm going to choose suffixes here
i and some other stuff
is going to be max volume
of food possible
uh for plates
p i to p n i'm gonna assume one index
here because
why not
but do i need to remember information
along the way
yeah just like with subset sum or
knapsack
i need i have this calorie limit
right so it's going to be really useful
for me to know how many calories i've
already
eaten or how many calories i have left
in my budget
right so let's say j
uh using
at most j
calories right from the remaining dishes
and i need to make sure that i'm eating
exactly
some number of sweet plates in the
future
and i need to remember as i eat a sweet
plate
the number of sweet plates i need to eat
decreases and so i want to generalize
that i'm going to put
an s prime here to denote eating
exactly
s sweet
plates okay
so that's my sub problem
let's i've got tons of board space i'm
going to go ahead and use it
relation
we've got x i j s
prime equals okay i'm trying to maximize
volume
probably i want to be maximizing over
something right
this combinator is kind of what i like
to call it
right usually what you're doing in
dynamic programming is making some kind
of choice
or common combining combinating
combining some number of sub problems
and choosing which one's the best right
if you don't if you just list a bunch of
options here
and don't tell us how to combine them
that's going to be a problem because we
don't know what your dynamic program is
doing at all
so it's really useful for you to be able
to tell us
how you're combining your sub problems
here we're doing a maximization
over the different volumes possible if
we
decide to eat the plate i
then we get v i in volume
we fill our tummies with vi and volume
but then we have to recurse on using
one fewer plate because we can't use
that plate again
and we've decreased the amount of
calories in our budget
and i'm going to say s prime
minus s i because
s i is one if it's sweet
and zero if it's not so it's kind of
nice that they
kind of gave us this notation here i can
just subtract it off
if it's there i don't have to do this
conditional or something
and i don't ever want to go below these
budgets
so i'm just going to say if uh
c i is uh
less than or equal to j and s i
is less than or equal to s prime okay so
that's going to make sure
that i never have these guys go negative
okay otherwise i don't eat the plate and
that's kind of the easy case
because i just go i plus 1 j
s prime these things didn't change i
just have one
fewer thing left okay so i'm maximizing
over these things
this one's an always it's not in it
right okay so
i just have two choices and maximizing
over them
topological sort order here i'm always
recursing
on a thing with larger eye
depends on
larger eye so a cyclic
happy okay
base cases
what's the good case
i get to the end i've reached the end of
my menu
i can't look at any more plates i'm
stuffed
and i've already forbidden myself from
going negative on the calories so that
should be all good
but what do i want on the third
parameter
zero i better a i better have eaten
exactly uh s plates so i want to get
down to
x m plus
one because i'm one indexed j for any j
zero that's gonna be
zero right i get no calories there but
it's a good thing it's a good place
it's fine zero is good all right
this is uh
done i don't know okay there's another
base case right what's the bad base case
i get to the end
i'm always increasing i and so i better
be doing something on n plus one i got
to the end
j again is going to always be
non-negative
because we we're always going to be in
our in our calorie budget
but if this is anything
other than s prime
greater than z or if it's anything but
zero what is that going to be
minus infinity right i never want to be
in this situation
if i do my dynamic program and i get a
minus infinity up at the top
that means there is no path to this
subproblem here
where i'm happy i'm always sad
and so i return that the maximum value
volume of food obert can eat and
maintain his diet
is not possible essentially there
aren't s dishes sweet dishes in the
thing
whose calorie budget are below my limit
right and that's probably an easier
thing to check
then in this bound okay so we have
our original sub problems now solution
is given by
what
just one of our sub problems right it's
just seeing what's the maximum volume i
don't have to
retrace my steps to figure out my thing
i just
i say one of the sub problems it's
using all of the things on my menu using
my entire budget k
and trying to get exactly s
things that that's going to be my output
to my algorithm
and this takes what time
how many sub problems do i have i have n
plus one
sub problems for this
uh parameter i have a plus one
possible things for this parameter and i
have s plus one possible things for this
parameter
so i get order n k
s sub problems
sub problems
how much work per sub problem just a max
of two things
so constant work per subproblem
yields order n k s
time total okay
so those are three nice practice
problems for you
one two that are polynomial one that's
pseudopolynomial you have one more
example in there which is the goku
non-mon po problem
which is a fun problem it involves
remembering additional information
that's not an not really a pseudo
polynomial number
in your problem but it's the location of
where i was
last or uh where i was going okay
so take a look at that problem uh is
another
a kind of non-trivial way of expanding
sub-problems
okay and with that good luck on your
quiz 3.