good morning everybody
how's everybody doing nice uh long
weekend
we just came from i'm doing well i'm
actually getting over a little cold
uh oh yeah unfortunately uh
but after this i i don't have anything
else this week so that's good
um okay so last time
last week we talked about how
we looked at the search problem
that we talked about uh earlier that
week
and showed that in a certain model of
computation
where i kind of could only compare
two objects that i'm storing in my that
i'm storing
and get some constant number of outputs
on what i could
how i could identify these things like
equal or less than or something like
that
then we drew a decision tree and we got
this this bounds that
if i had n outputs right
i would require my decision tree to be
at least log n height
and so in this model i can't find the
things
in faster than log n time but luckily
we are in a model of computation which
has a stronger operation
namely random accessing and if we
stored uh the things that we're looking
for that
we have unique keys and those keys are
integers
then if i have an item with key k
i if i store it at index k in my
array then i can find it
and manipulate it in constant time right
that's pretty cool
that's what we call the direct access
array a direct access array really not
different than a regular array
except how we're using it when we're
talking about sequences
is we are giving kind of extrinsic
semantics
to the slots where we are storing these
things basically i could put
any item in any slot right
where it was in my array had nothing to
do with what those things were
here we are imposing
intrinsic semantics on my array that if
i have an item with k
k it must be at
index k right that's that's the
the thing that we're taking advantage of
here and then we can use this nice
powerful
linear branching random access operation
to find that thing in constant time
because that's our model of computation
okay
then what was the problem with this
direct access array
anyone shouted out
space right so we had to
instantiate a direct access array that
was the size of the space of our keys
right in general my index location is
could go from zero to some positive
number right if i have very large
positive numbers if i was sorting
if i was searching among your mit ids
i'd have to have a direct access array
that was that spans that space of
possible keys you could have
right and that could be much larger than
n and so
the rest of the time we talked about how
to fix that space problem
we can reduce the space by taking that
larger key space
from 0 to u which could be very large
and map it down to a small space
now in general if i give you a fixed
hash function there
that's not going to be good in for all
inputs if your inputs are you know very
well distributed over
over the key space then it is good but
in general there would be hash functions
with
some inputs that will be bad right
that's what we kind of argued
and so for the the rest of the time
there we talked about hash families
choosing a hash function randomly from
among
a large set of hash functions which had
a property
that if i chose this thing randomly and
you generating your input didn't know
which random numbers i was picking
the expectation over my random choice me
i'm the one running the algorithm not
you
giving me the input that random choice
my algorithm actually behaves really
well in expectation in particular
i got constant time for finding
inserting and deleting
into this data structure in expectation
we did a little
proof of of of that the chain lengths
where we stored collisions in our hash
function in our hash table
sorry those wouldn't be very long
and so if they were constant then i
don't have to search
more than a constant number of things
when i go to an index
a hashed index location does everyone
remember what we talked about
last week and we
then uh i didn't show you this chart at
the end
but i'm showing it to you now
essentially what we had was
we have a bunch of different ways to
deal with this set interface
and last week we talked about the sorted
array and then we talked about this
direct access array in this hash table
right
which do better for these uh
uh dictionary the find and insert and
delete operations
or at least better in an expected sense
right
what's the worst case performance of a
hash table
if i have to look up something in a hash
table and i happen to choose a bad hash
table
hash function what's the worst case here
what n right it's worse than
a sorted array right because potentially
i hashed everything that i was storing
to the same index in my hash table and
and to be able to distinguish between
them i can't do anything more than a
linear search
right i mean i could store a
another sets data structure as my chain
and do better that way
that's actually how java does it they
store
a data structure we're going to be
talking about next week
as the chains so that they can get worst
case log n
but in general
that hash table is only good if we're
allowing okay i want this to be expected
good
but in the worst case if i really need
that operation to be worst case right
i really can't afford linear time ever
for an operation of that kind
then i don't want to use a hash table
and so on your pset 2
everything we ask you for is worst case
so probably you don't want to be using
hash tables
right okay yes
what does the subject e mean that's
great in this chart
uh i have putting a subscript
on this is an expected runtime right
or an a meaning this is an amortized
runtime at the end
we talked about how if we had too many
things in our
hash table then as long as we didn't do
it too often
right this is a little handwave argument
but the same kinds of ideas as the
dynamic array
if whenever we got a linear
we were more than a linear factor away
from where we were
trying uh basically the fill factor we
were trying to be
then we could just completely rebuild
the hash table with a new
hash function randomly chosen from our
hash table with a new size
and we could get amortized bounce and so
that's what python
how python implements dictionaries or
sets or
even objects when when it's trying to
map
keys to different things uh
so that's hash tables that's great the
key thing here is
well actually if your range of keys
is small or if you as a programmer
have the ability to choose the keys that
you identify your objects with
you can actually choose that range to be
small to be linear to be
small with respect to your items and you
don't need a hash table you can just use
a direct access array
right because if you know your key space
is small
that's great so a lot of c
programmers probably would like to do
something like that because they don't
have access to
maybe c plus programmers would have
access to their hash table
any questions on this stuff before we
move on
why is it expected right when i'm
building
i could insert i'm inserting these
things from
x one by one into my hash table each of
those insert operations
i potentially have uh i'm looking up to
see whether that
an item with that key already exists in
my hash table and so i have to
look down a chain to see where it is
however
if i happen to know that all of my keys
are unique in my input
right all the items i'm trying to store
are unique then i don't have to do that
check and i can get
worst case linear time is that does that
make sense
all right it's a subtlety but that's a
great question
okay so uh today instead of talking
about searching we're talking about
sorting
okay last week we saw
a few ways to do sort some of them were
quadratic insertion sort and selection
sort
and then we had one that was n log n and
this this thing and log n
seemed pretty good but can i do better
right can i do better
well what we're going to show at the
beginning of this class is
in this comparison model no
and log n is optimal and we're going to
go through the exact same line of
reasoning
that we had last week so in the
comparison model
what did we use
when we were trying to make this
argument that any
comparison model algorithm
was going to take at least log n time
what we did was we said okay i can think
of any
model in the comparison model uh any
algorithm in the comparison model
as kind of this
some comparisons happen they branch in
a binary sense but you could have it
generalized to
any constant branching factor but for
our purposes binary is fine
and what we said was that there were at
least
n output really n plus 1 but
you know at least order n outputs and we
showed that
or we argued to you that the height of
this tree had to be at least
log n right
log the number of leaves it had to be at
least log the number of leaves
that was the height of the decision tree
and
if this decision tree represented a
search algorithm
i had to walk down and perform these
comparisons in order
reach a leaf where i would output
something so
i i need if if the minimum height of any
binary tree on a linear number of leaves
is log n then any algorithm
in the comparison model
also has to take log n time because it
has to do that many comparisons to
differentiate between
all possible outputs does that make
sense
all right so in the sort
problem
how many possible outputs are there
what is the output of a sorting
algorithm
what what's up
a list in particular given my input
right like some set of uh items a
that has size n
right what i'm going to give you is some
permutation
of that list right so for each
index say i could tell you where it goes
right another way i could say
is where does the first item go to
where does the second item go to where
does the third item go to blah blah blah
like that right so how many different
choices of
a permutation are there well how many
choices do i have for the first thing of
where it could
be in the final sorted array it could be
in any of the
places right so it's n
how about this one the second one well
it can't go to where this one went
right but it can go anywhere else so
it's n minus one
and since these are independent choices
i'm making if i multiply them all
together i get
n factorial permutations that are the
number of possible outputs that i have
to my sorting algorithm right
so for me to have an output to my
sorting algorithm be correct
i need at least n factorial leaves does
that make sense
okay
the nice thing about doing this last
week
is this is really just the number of
leaves
and this is really the number of leaves
right so what's the number of leaves
is theta n factorial here it's actually
n factorial
but i'm just going to put it there and
here
we get an n factorial
i think this is i see so
it's at least omega
n factorial does that make you happier
theta here thank you has to be at least
so this was right
okay so at least this many i i could
there are there are algorithms that if
it got
to it could take two different routes to
get to the same output
right so this is a lower bound on the
number of leaves
okay so what this argument is saying is
that
if i just replace the number of leaves n
here with n factorial
i get a similar comparison sort lower
bound now
so what is log of n factorial
this is familiar from p set one maybe
so one thing i could do is i could put
in sterling
formula right
and that'll give me something of the
form n log n but
what's another way i could lower bound n
factorial
well i have a bunch of things here
that's n factorial half of these things
these half and over two things
are bigger than or equal to n over 2.
that makes sense so i can certainly
lower bound this thing
by n over 2 to the n
over 2 that's a little easier thing to
take a log of right
if you take a log of that that's
asymptotically n log n so what we're
getting here is
any sorting algorithm here takes at
least
n log n comparisons and so merge sorts
the best we can do
okay that makes sense everybody
we're just piggybacking on the analysis
we had about decision trees
leaves with the minimum height of
any binary tree on that number of leaves
and just replacing n with n factorial
nothing super interesting here yeah
yeah sure you can just plug in sterling
formula but i
i did this so i might as well clarify
there are n terms here in the product
right
half of them are at least n over two
does that make sense
so i can replace i can lower bound this
product by
something smaller than half of the terms
the product of that and that'll be fine
right so i'm taking
n over two of them and i'm multiplying
n over two all together n over two times
does that make sense
okay it's just providing a lower bound
right i just need something that's
smaller than all of these terms
and multiply them all together and
that'll give me a lower bound
okay so we can't do better than n log n
in the comparison model
but what we did last week was use
random access and a direct access array
to do better okay
so how can anyone think of how to use
that idea
to sort faster and i'm going to give you
a caveat here
i'm going to let you assume that the
keys of the things you're trying to sort
are unique okay
and say they're in a bound in a small
range
so how could i use a direct access array
to sort faster any ideas
uh-huh
okay so what your colleague is saying is
exactly correct it's something that i
like to call direct
access array sort we won't really call
it that because there's something
more general that we'll talk about in
just a second
but what your colleague was saying is
instantiate a big direct access array
direct access array sort
right i'm instantiating this big
direct access array of this the space of
my keys
right and what your colleague was saying
was i take each one of the
items in my the things that i'm trying
to sort i look at each one of their keys
and i stick it in the direct access
array
exactly where it needs to go right
in constant time that's great now
i gave you this caveat that all the keys
were unique so i don't have to deal with
collisions here right but then after i'm
done with this
all of these things are now in sorted
order and what i can do is i can just
walk down this list a lot of these cells
are empty
potentially right well
some of the keys might not be there but
what i can do is just walk down this
list
pick off every item that does exist
stick them in an array i'm done right
so what's the uh stick a key
into here and then so all right
uh make direct access array
store items
uh item x in
index x dot key
walk down
[Music]
direct access array
and return
items seen
in order does that make sense to
everybody
all right how long does this step take
building a direct access array order you
okay so this is order u
long does this take
how many items do i have to insert order
n or just n
and how long does it take to insert each
one of these things
into my direct access array worst case
constant time
right so this is n
[Music]
times worst case constant time
great how long does this last one take
anyone of you also right because i'm
walking down the entire length of you
so this algorithm takes in total
n plus u time
this is great if u u is bigger than n
because we assumed
distinct keys right
but if u is on the order of n
then we now have a linear time sorting
algorithm yes
what's up
i'm sorry you have to speak up
uh how do i attach keys to my inputs
in my so uh in for a set
data structure that we've been talking
about all of my items have
keys that's just something that we
impose on our input
each of the keys is in this case it has
to be a number
right so it's a that's a nice
point right we do this to uh kind of
talk about
sorting items generally so that
uh we don't have to deal with
potentially if these keys have values
associated with or other stuff
associated with
put them on that item and they'll still
be there but in general
if you just wanted to sort integers you
could say that dot
key is points back to the object itself
if you want to just
sort some integers does that make sense
it's a good question though
okay so that gives us a linear time
algorithm when u is small
right and under this condition that i
have unique keys when i want to sort
right those are fairly restrictive
so we might want to generalize this a
little bit okay
so that's direct access array sort
what if we had a set of keys that was a
little larger
right instead of enforcing
so let's say u is
theta n implies
implies linear time sorting that's great
okay
so now what happens if we expand that
range a little bit
say u is less than or equal to n squared
maybe just less than
okay okay this is a bigger range
right and if we instantiated
a direct access array of quadratic size
we'd have a quadratic time algorithm
this is not helpful
right anyone
have a way in which we could sort
integers that are between zero and
n squared
maybe using the stuff that we had above
your colleague is saying exactly the
thing that i'm looking for which is
great
which is maybe
we could break this larger number
into two smaller numbers
right any uh integer
that is between zero and n squared can
be written
as a key
can be some a and b where
a is essentially the higher kind of
n and b is kind of the lower
n this is kind of weird okay so what do
i actually mean by this
i mean that let's let a be
k when i divide it by
n integer the floor right
key integer to divide by n
right and b
equals k
mod n so this is a number that's less
than
n and this is a number that's less than
n
does that make sense and actually i can
recover k
at any time by saying k equals a
n plus b i've essentially decomposed
this
into a base n representation of this
number
and i have two digits in that number
this is the
kind of nth n digit and this is the ones
digit
does that make sense all right so
now let's say i have this list of
numbers
um 17 3
24 22
12.
how i could here i have
five numbers so what's n in this case
five okay not so interesting
n is five here and i'm going to
represent this
as five pairs of numbers
that are each within the bounds of zero
to four
right does that make sense so
what is my a b representation of
seventeen
three two
okay so yeah so there are three
times 5 plus 2 that's good that's 17.
yeah i think i your colleague did that
right
uh i have all of these written down so
i'm just going to write it out
and i hope i did it correctly okay
three two zero three four four four two
two two okay
so now i have a bunch of things that i
want to sort
based on this function that i have right
these are no longer just integers that i
need to sort i need to sort by
this transformation of this thing into a
number
does that make sense so anyone have any
ideas
on how we could so by the way
these are both in uh constant time
operations
on your computer as long as it's an
integer division
right and this is mod python also has a
nice
thing i think in uh
in its uh standard operations which is
div mod of
kn is that right yeah
so if you want to use that you can
okay so how do we sort these tuples
these are tuples right
you guys are i'm sure very familiar with
tuples by now
okay how do i sort these tuples
what's the most important digit of this
thing
if i had to sort one of the digits and
get something that's close to sorted
what's more important the ones digit or
the ends digit
and okay we have discrepancy here
who says one who says
n someone who said n tell me what
oh you all think that way for no reason
yeah sorry this is a little confusing
this is the ones digit this is the ends
digit
this is the ends digit this is the ones
digit in how i'm writing this
does that make sense yeah
exactly yeah so what your your colleague
is saying is exactly correct
i could very be all i want right with
the same a
if i change a by one it doesn't matter
what b
is it's going to be bigger right
does that that make sense right the the
k
is much more sensitive to a than it is
to b
right so a is more important than b does
that make sense
so if i just wanted to get some
linear time algorithm i could just sort
by their
bigger digits and hope they don't
don't differ very much on the smaller
things i've
kind of sorted these things does that
make sense
okay what if i actually want to sort
these things
any hands
yeah i need to i need to sort on both in
some sense
in particular i like to think of what
i'm going to tell you right now
is is an algorithm that i like to call
tuple sort
but you can also think of it as like
excel spreadsheet
sort right i have an excel spreadsheet
of a bunch of data
i have a prioritization on how important
the keys are to me the columns
right and if i have a very important
column
and an order of the columns of how how
important they are to me
i can repeatedly sort on the columns
until they're sorted based on my
preference
that's something that you may have done
now if i have an ordering on the
preferences of my columns
do i start by sorting all of them
on the most important thing or the least
important thing
what who says most
who says least
there's discrepancy here all right
let's try it out all right tuple
sort let's start by sorting
these things by least significant first
and then
no most significant first and then least
significant that was the first thing i
asked you right
all right so these are the most
significant things the first ones and
these are the
less significant things all right
instead of writing it as tuples
i'm going to write them as 32 0 3
44 42 22 is everyone cool with that
this is just base 5 representation okay
all right so let's start by sorting all
of these things
by the most significant thing right
which is by this guy this guy this guy
this guy and this guy
okay so how do i do the first one is o3
second one is 22 the next one is 32
uh 42 and then 44.
maybe 44. i don't know
does it matter the order in which i put
these things
i don't know i'm just going to keep it
the same order for now all right
so i've sorted it by the least
significant or the most significant
sorry the leading term and now i'm going
to sort
by the least significant so what's the
least significant here
22 then 2 is also
this is also 2 this is also 2
this is 3 and
sorted list voila
why did that not work
yeah so what happened is i did take into
account the significant digit sort
but when i did the less significant
thing
it erased all of my work from up here
does that make sense
in the case of ties we want
the more significant thing to take
precedence so we want to do that thing
last
does that make sense so the right way to
do this
this is uh most significant first
add okay not good
all right least significant first let's
try that
uh so least significant here is
two okay so i see a uh
32 42
22 03 and then 44.
okay sound good
least significant first now i do
most significant i sort the most
significant thing okay so what's the
most significant thing
zero three
22 32
most significant 4 44 and 42.
cool we're sorted right
i did what you told me to do i sorted
by the most significant thing
what's what's the problem here
what did i do wrong you wanted me to put
42 here
and 44 here right
because 42 came first in the input
and 44 came second right
okay if a sorting algorithm maintains
this property that if they have
they are the same thing right
then the output maintains their order
from the input to the output their
relative order
that's what we call a stable sorting
algorithm right and so
if we have a stable sorting algorithm
when we're doing tuple sort
when we're sorting on different keys or
columns of a set
right we really want to be
using a stable sorting algorithm does
that make sense
because otherwise we may mess up work we
did before in a previous
sort of the less significant things and
so yes we want a
stable sorting algorithm here
because then we will end up sorting our
thing does that make sense yes
so what your colleague is saying
let's sort by most significant then look
at
all of the things with one of those
that that are the same and now sort that
that's something we could do okay how
long would that take well let's say
i didn't use half of my more significant
set of digits
right say i'm only using n over two
or that's not quite quite going to get
what i want
say say again
yeah so what we're going to do if we
have
direct access array sort if i then go
into each one of these digits and try to
sort
the things that are in there that's
going to take time right
it's going to take time for each of
those digits now
each there might be at uh a ton of
collisions
into one of the things and so i might
take
more time to sort that than linear does
that make sense
so i would prefer to do this tuple sort
kind of behavior
sorting the smaller thing sorting the
bigger thing
and because i only have a constant
number of things in my tuples this is
important
because i only have two things i'm
worried about here
i only have to do two passes of a
sorting algorithm
to be able to sort these numbers however
can i use direct access array sort here
what was the initial stipulation i had
on direct access array
that the keys were unique that's exactly
the opposite of what we have here
we have things that could be the same
so we give up can't do it
what do we do instead
we yeah
you've already said the thing that i'm
looking for so that's great
your your colleague said why can't we
just put more things
at a key right why can't we put a list
there
that's exactly what we do this is called
counting sort
and what we do here is we still have
this direct axis array
a space u minus 0 to u minus one
but instead of have storing one thing
here
at each key k we store
a pointer to a chain this sounds like
hashing right
but the important thing is that i need
to make sure
as i'm inserting things in here then i'm
maintaining the order in which they came
in
right i can't just throw them
willy-nilly or else we have this problem
up here that we had before
right so i need what i would say is a
sequence data structure
right something that will maintain the
order that i
the extrinsic order that i had when i'm
putting these things in right
so as i have multiple things with
k right
i'm going to put them in the order i can
basically i can put
have a pointer to a dynamic ray or a
linked list where i just add things to
the end
and then at the end of my algorithm when
i read off the things
i can just look at anyone that has a
non-empty
data structure under here and read them
off in the order that they came
does that make sense so for
this example
i'm just going to do this last
step here from the first
row to the second row i'm going to have
this
direct access array with 0 1
2 3 4 on the slots
right so how am i going to do this
counting sort now i have
32 42 22 03
and 44. i'm going to take the first one
32 i'm sorting by the most significant
thing
i stick it here 32
and then 42 4 okay 42 sorry 42
22 all right this is not so much
different yet
then dynamic array
direct access array sort but when we get
to this duplicate
uh right 44
here we now have two things in this
thing
and because we are keeping them in order
in this sequence
i'm appending to the end then when i go
and read off the different things
then i'm returning them in a stable way
in the way
that i want them to be does that make
sense
and it's not overriding the work i did
on the lower significant digits
okay so how long does this take
this also only takes order n plus u
because i'm instantiating this thing of
size u
and then how big are these data
structures well maybe i'm storing one
a constant amount for each index so
that's
a u overhead and then i'm paying one for
every item i'm storing
right these things are only
the lengths the sum total of their
lengths is n
right because i'm only storing n things
in there
so the total amount of space the total
amount of work i have to do
is order i need to be able to append
in constant time and i need to be able
to cycle through these things
iterate over them in linear time but if
i have that
i get n plus u yeah
ah so your uh
your colleague is saying how do i ensure
that the things in these lists that
there are they collide
how do you ensure that they're sorted i
don't i
just ensure that they came in in the
order that they came
right but as long as i sorted the lower
order digits
correctly in the previous things
then i'm assuming that their order as
they come in
will be sorted if they collide that's
the assumption
that's the reason why i'm doing these
building up from the least significant
to the most significant it's so that
i know that when they collide the
underlying stuff there is sorted already
in the input does that make sense great
yeah
so um
so this one is still i'm using a direct
access array on the keys though this is
n
this is n because i chose uh
so counting sword is general for any u i
just happen to pick
u being n in this case when i broke this
thing
up into n squared but this general
concept is
it uh it doesn't matter what i choose
for you
does that make sense
okay but we will use that right now to
sort
larger ranges of numbers okay
so the idea here this was exactly the
idea we're going to combine tuple sort
use counting sort as its auxiliary
sorting stab
a stable sorting algorithm right to do
all its work on these digits
right and so to sort
on n squared size numbers
i get linear time which is great right
because u
is n in this case okay
so but can i extend that what if i had
n cubed what if i had
up to size u equals n cubed or less than
n cubed how many digits would i have
there
how many size and digits would i need to
represent
a number of size n cubed
any ideas
what did we do here we divided off an n
we took it and stored it we're left with
something of size n
right if i had a number of size n cubed
i could divide off an n i'm left with
something of n squared
i don't know how to deal with something
of n squared actually i do
i can split it up into two size and
numbers right
so if i had numbers
bound upper bounded by a cubic right and
cubed
i could split it up into three digits
three is still constant
right and so i could split it up into
three digits
tuples sort them in their increasing
priority
and sort those again i'm doing linear
work
per digit i have a constant number of
digits so i get a linear time algorithm
yeah yeah so
it's always going to be big o of n plus
u
but because i'm bounding my digit size
to be
n u is n there
and so i'm getting linear time does that
make sense yeah so
the idea here this is what we call radix
sort
radix sort
break up
integers
uh max size
u into
a uh
a base n
tuple right
so basically each one of my digits can
range from zero to n
right how many digits do i have if i
have
how many base n digits do i have if i
have a number of size u
yeah log n of u number of digits
is log n of u
log base n of u right so how long
does ray and then
tuple sort on
digits using
counting sort
from least
to most significant
right that's the algorithm how long does
that take
how long does it take to sort on a digit
that spans the key 0 to n
linear time right order n time how many
times do i have to do this
tuple sort the number of digits times
right
so the running time of this algorithm
first i have to
you know i have to do this stuff break
up each of the integers that takes
n time right n times the number of
digits i had to create each one of these
uh tuples right so n
plus n times the number of digits right
log
log base n of u
right so here i had to loop through all
the things
and then here for each thing i broke it
up into
log base and view digits
and that's how long the first thing took
and then how long did it take me to
tuple sort
end time per digit so i also get this
factor
does that make sense
so how long did how long is that is that
good is that bad
for what values of u is this linear time
if u is less than
n to the c for some constancy
then this c comes out of the logarithm
log n
of n is one and we get a linear time
algorithm
does that make sense okay so that's
how we can sort in linear time if our
things are only
polynomially large right
so in counting sort we get n plus u
in radix sort we get also a stable
sorting algorithm
where the running time is n plus n times
log base n of u does that make sense
and then in the situations where
uh there's a typo there and counting
sort that should be when u is order n
counting sort runs in linear time and
it's linear time also
in the case of rating sort if our things
are bounded
by a polynomial in n right by n to the c
for some constant c
does that make sense all right
so that's how to sort in linear time
with the caveat that your numbers aren't
too big okay
see you next week