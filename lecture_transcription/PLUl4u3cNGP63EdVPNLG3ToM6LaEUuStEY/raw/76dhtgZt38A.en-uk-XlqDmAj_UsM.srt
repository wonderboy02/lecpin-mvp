1
00:00:12,880 --> 00:00:17,199
Okay, let's get started,

2
00:00:15,359 --> 00:00:18,559
welcome back to 006, today we're going to be

3
00:00:17,199 --> 00:00:20,160
creating some of the coolest

4
00:00:18,559 --> 00:00:21,519
data structures we'll see in this class,

5
00:00:20,160 --> 00:00:24,399
maybe some of the coolest

6
00:00:21,519 --> 00:00:27,039
data structures ever were binary trees,

7
00:00:24,399 --> 00:00:27,679
you've probably seen trees in many

8
00:00:27,039 --> 00:00:30,480
forms,

9
00:00:27,679 --> 00:00:32,238
in the past, including in this class

10
00:00:30,480 --> 00:00:32,960
we've talked about using trees as a

11
00:00:32,238 --> 00:00:36,320
lower bound tool

12
00:00:32,960 --> 00:00:38,399
for a decision tree model,

13
00:00:36,320 --> 00:00:40,079
but in this and the next lectures

14
00:00:38,399 --> 00:00:42,719
we're going to be creating

15
00:00:40,079 --> 00:00:44,000
one data structure that pretty much

16
00:00:42,719 --> 00:00:46,640
beats every

17
00:00:44,000 --> 00:00:48,000
data structure we've seen and can do

18
00:00:46,640 --> 00:00:51,439
almost everything

19
00:00:48,000 --> 00:00:53,119
very quickly, first recall all the

20
00:00:51,439 --> 00:00:54,000
data structures we've seen so far arrays

21
00:00:53,119 --> 00:00:57,359
linked lists

22
00:00:54,000 --> 00:01:00,079
dynamic arrays sorted arrays hash tables

23
00:00:57,359 --> 00:01:01,280
and two sets of operations that we

24
00:01:00,079 --> 00:01:03,359
want to support

25
00:01:01,280 --> 00:01:04,799
two interfaces are sequences

26
00:01:03,359 --> 00:01:06,400
where we store elements in a

27
00:01:04,799 --> 00:01:06,960
specific order, we want to be able to

28
00:01:06,400 --> 00:01:08,719
insert an

29
00:01:06,959 --> 00:01:10,399
element right after another or

30
00:01:08,719 --> 00:01:12,000
delete an element in the middle of the list

31
00:01:10,400 --> 00:01:13,760
and always be able to access the i-th

32
00:01:12,000 --> 00:01:15,280
element, we haven't seen any

33
00:01:13,760 --> 00:01:17,600
good data structures for this

34
00:01:15,280 --> 00:01:18,799
problem, we're really good at

35
00:01:17,599 --> 00:01:20,158
inserting  and delete

36
00:01:18,799 --> 00:01:22,640
at the beginning or end of

37
00:01:20,158 --> 00:01:24,479
the sequence, but we haven't seen anything

38
00:01:22,640 --> 00:01:26,320
that's efficient in

39
00:01:24,478 --> 00:01:27,519
inserting ins in the middle of a list or

40
00:01:26,319 --> 00:01:28,239
deleting in the middle of a linked list

41
00:01:28,239 --> 00:01:31,519
you can't even get to the middle in less

42
00:01:30,319 --> 00:01:33,359
than linear time

43
00:01:31,519 --> 00:01:34,959
uh array you can get to the middle but

44
00:01:33,359 --> 00:01:37,039
if you make any changes you need to make

45
00:01:34,959 --> 00:01:40,239
that shift very expensive

46
00:01:37,039 --> 00:01:42,158
so today or, sorry, next lecture

47
00:01:40,239 --> 00:01:46,319
we'll see

48
00:01:42,158 --> 00:01:46,320
all these operations efficient for the first time.

49
00:01:46,640 --> 00:01:51,680
I'll mention our goal where efficiency

50
00:01:50,399 --> 00:01:55,680
means

51
00:01:51,680 --> 00:01:57,759
logarithmic so we're not as good

52
00:01:55,680 --> 00:01:58,799
as linked lists and dynamic arrays in

53
00:01:57,759 --> 00:02:00,879
insertion and

54
00:01:58,799 --> 00:02:02,960
deletion at the ends of those that we

55
00:02:00,879 --> 00:02:03,679
reach constant or constant amortized

56
00:02:02,959 --> 00:02:05,839
time

57
00:02:03,680 --> 00:02:07,600
but up to that log factor we're going to

58
00:02:05,840 --> 00:02:08,000
get the best of all worlds where we can

59
00:02:07,599 --> 00:02:10,877
solve

60
00:02:08,000 --> 00:02:11,520
all the things all the operations that

61
00:02:10,877 --> 00:02:12,878
don't

62
00:02:11,520 --> 00:02:14,480
build or iterate the whole

63
00:02:12,878 --> 00:02:15,359
structure which of course takes linear

64
00:02:14,478 --> 00:02:16,478
time

65
00:02:15,360 --> 00:02:18,959
but we can do everything else in

66
00:02:16,478 --> 00:02:20,799
logarithmic time for

67
00:02:18,959 --> 00:02:22,000
sets sets were maintained by maintaining a bunch of

68
00:02:20,800 --> 00:02:25,120
elements that have

69
00:02:22,000 --> 00:02:28,318
internal keys and we want

70
00:02:25,120 --> 00:02:30,719
to search by key so hash tables are great

71
00:02:28,318 --> 00:02:32,159
if you're doing an exact search only if you

72
00:02:30,719 --> 00:02:33,759
want to find the key

73
00:02:32,159 --> 00:02:36,159
and get a yes or no answer of whether it's there and if it's

74
00:02:33,759 --> 00:02:39,120
there give me the element that's what

75
00:02:36,159 --> 00:02:39,439
python dictionaries do and

76
00:02:39,120 --> 00:02:41,439
they're

77
00:02:39,439 --> 00:02:42,959
great at inserting and deleting but

78
00:02:41,439 --> 00:02:46,317
they're really bad at

79
00:02:42,959 --> 00:02:48,478
finding the previous and next.  This is the

80
00:02:46,317 --> 00:02:50,799
unfortunate case of if I'm looking for a

81
00:02:48,478 --> 00:02:52,639
key and it's not in my structure,

82
00:02:50,800 --> 00:02:55,040
I'd like to know more than just

83
00:02:52,639 --> 00:02:57,039
the answer is no, I'd like to know what the

84
00:02:55,039 --> 00:02:58,478
previous and next elements

85
00:02:57,039 --> 00:03:00,719
are actually in the structure,

86
00:02:58,478 --> 00:03:03,119
so what are my closest matches when I

87
00:03:00,719 --> 00:03:05,199
search for a key, this is a natural query,

88
00:03:03,120 --> 00:03:07,360
and the only data structure that we have that's

89
00:03:05,199 --> 00:03:09,679
good at this is a sorted array

90
00:03:07,360 --> 00:03:11,599
because binary search gives us that,

91
00:03:09,680 --> 00:03:13,040
if we look for a key with binary search

92
00:03:11,598 --> 00:03:15,039
and don't find it,

93
00:03:13,039 --> 00:03:17,679
the position that we end up at is right

94
00:03:15,039 --> 00:03:19,359
between the previous and the next,

95
00:03:17,680 --> 00:03:20,719
but of course sorted arrays are terrible

96
00:03:19,360 --> 00:03:23,760
for dynamic

97
00:03:20,719 --> 00:03:25,519
operations that we don't know how to support,

98
00:03:23,759 --> 00:03:26,798
we can't support a sorted array without

99
00:03:25,519 --> 00:03:27,920
any gaps

100
00:03:26,799 --> 00:03:30,000
when we do insertions and

101
00:03:27,919 --> 00:03:32,158
deletions in a sense today,

102
00:03:30,000 --> 00:03:33,280
and binary trees of the next class allow us

103
00:03:32,158 --> 00:03:35,519
to represent the

104
00:03:33,280 --> 00:03:36,560
sorted order or the order of the

105
00:03:35,519 --> 00:03:39,680
elements

106
00:03:36,560 --> 00:03:42,319
dynamically and still allow us to do

107
00:03:39,680 --> 00:03:43,920
very fast things like go from i and

108
00:03:42,317 --> 00:03:45,839
find the previous key,

109
00:03:43,918 --> 00:03:47,679
so that's our goal, we  we're not going to

110
00:03:45,840 --> 00:03:52,000
fully achieve this goal today

111
00:03:47,680 --> 00:03:54,159
we're going to get an incomparable thing

112
00:03:52,000 --> 00:03:55,918
called tree height and then

113
00:03:54,158 --> 00:03:57,679
on thursday we're going to be able to complete and

114
00:03:55,918 --> 00:04:01,839
achieve this goal today just

115
00:03:57,680 --> 00:04:01,840
in service for this goal

116
00:04:02,239 --> 00:04:09,438
so what is a binary tree

117
00:04:05,680 --> 00:04:12,400
let me draw an example

118
00:04:09,438 --> 00:04:14,239
and then define it more precisely

119
00:04:12,400 --> 00:04:15,200
mathematicians would call it a rooted

120
00:04:14,239 --> 00:04:17,199
binary tree

121
00:04:15,199 --> 00:04:19,439
because if you saw this in o42

122
00:04:17,199 --> 00:04:19,439
say

123
00:04:19,839 --> 00:04:29,839
here's a picture

124
00:04:36,319 --> 00:04:40,399
so this is an example of a binary tree

125
00:04:39,040 --> 00:04:41,680
it has a bunch of nodes that we

126
00:04:40,399 --> 00:04:43,679
draw in circles

127
00:04:41,680 --> 00:04:45,439
in the nodes have elements that i'm

128
00:04:43,680 --> 00:04:48,319
writing here as letters

129
00:04:45,439 --> 00:04:49,040
so this is element a item b item c and it

130
00:04:48,319 --> 00:04:50,719
has these

131
00:04:49,040 --> 00:04:52,479
links between them it's like linked

132
00:04:50,720 --> 00:04:56,000
lists

133
00:04:52,478 --> 00:05:01,039
but in general node

134
00:04:56,000 --> 00:05:01,040
x will have a pointer to the parent the

135
00:05:01,519 --> 00:05:07,758
left child

136
00:05:04,560 --> 00:05:11,519
left pointer and the right child right

137
00:05:07,759 --> 00:05:14,479
pointer and

138
00:05:11,519 --> 00:05:16,000
inside of it there's also an element so i'm going to

139
00:05:14,478 --> 00:05:19,360
talk about node.left

140
00:05:16,000 --> 00:05:21,519
is a pointer  left,

141
00:05:19,360 --> 00:05:23,439
the node at the bottom node.right

142
00:05:21,519 --> 00:05:26,719
node.parent node.item

143
00:05:23,439 --> 00:05:29,839
gives me, so if I

144
00:05:26,720 --> 00:05:35,360
look at node a, its element is

145
00:05:29,839 --> 00:05:35,359
a, so let me draw

146
00:05:37,120 --> 00:05:56,879
some examples for you,

147
00:05:53,759 --> 00:05:57,439
okay, the parent node of a is nothing, so we

148
00:05:56,879 --> 00:05:58,719
call a the

149
00:05:57,439 --> 00:06:01,360
root node, there will be a

150
00:05:58,720 --> 00:06:04,400
unique node that has no parent element

151
00:06:01,360 --> 00:06:05,360
sadly there is no parent, but here,

152
00:06:05,360 --> 00:06:08,639
then we have node b,

153
00:06:08,639 --> 00:06:12,800
whose parent node c is the parent, its visible node

154
00:06:11,120 --> 00:06:15,600
d its parent node b

155
00:06:12,800 --> 00:06:18,160
node e its parent node b, and the parent node f is

156
00:06:15,600 --> 00:06:19,840
d in

157
00:06:18,160 --> 00:06:22,639
alphabetical order here, usually

158
00:06:19,839 --> 00:06:22,638
ordering parent,

159
00:06:23,038 --> 00:06:26,719
then we have the left pointers, I'll just do

160
00:06:24,720 --> 00:06:30,639
a few of them, so the left pointer

161
00:06:26,720 --> 00:06:33,280
a is b the right pointer a,

162
00:06:30,639 --> 00:06:35,600
sorry, b node, well that should be all be

163
00:06:33,279 --> 00:06:35,599
notes,

164
00:06:36,879 --> 00:06:40,079
I'm circling the nodes and just writing

165
00:06:38,639 --> 00:06:41,280
the letter for the element to

166
00:06:40,079 --> 00:06:43,839
make it clear that these are different

167
00:06:41,279 --> 00:06:47,198
things, right  the pointer to a

168
00:06:43,839 --> 00:06:51,038
is c the left pointer to b is d the

169
00:06:47,199 --> 00:06:52,560
right pointer to b is e and so on

170
00:06:51,038 --> 00:06:55,038
okay so in In other words each of these

171
00:06:52,560 --> 00:06:56,720
lines is a bidirectional pointer

172
00:06:55,038 --> 00:06:58,639
in this direction this is the parent

173
00:06:56,720 --> 00:07:00,080
direction in this direction in this case it's to the left

174
00:07:00,079 --> 00:07:04,318
because it's bidirectional we don't draw

175
00:07:01,598 --> 00:07:07,759
arrows we just draw

176
00:07:04,319 --> 00:07:09,280
undirected lines okay so

177
00:07:07,759 --> 00:07:11,280
this is basically what a binary tree looks like.

178
00:07:11,279 --> 00:07:15,038
The key invariant is that if you take a node

179
00:07:15,038 --> 00:07:22,399
and say go to its left pointer left child

180
00:07:18,079 --> 00:07:25,439
and then go to the parent node of that node,

181
00:07:22,399 --> 00:07:26,799
it has to be the same as the right node so

182
00:07:25,439 --> 00:07:29,120
it's just that they're

183
00:07:26,800 --> 00:07:30,478
in the parent, it's always the inverse of the

184
00:07:29,120 --> 00:07:33,840
left or right operation,

185
00:07:30,478 --> 00:07:33,839
it's also true for writing

186
00:07:34,478 --> 00:07:38,560
well, and it's a binary tree, now

187
00:07:36,639 --> 00:07:40,879
the intuition of what

188
00:07:38,560 --> 00:07:41,680
you might say we were

189
00:07:40,879 --> 00:07:44,639
inspired by the

190
00:07:41,680 --> 00:07:47,439
linked list.  A linked list had a very

191
00:07:44,639 --> 00:07:50,400
similar structure,

192
00:07:47,439 --> 00:07:51,918
maybe an element or a node, it

193
00:07:50,399 --> 00:07:54,318
had an element,

194
00:07:51,918 --> 00:07:56,560
it had a next pointer and a

195
00:07:54,319 --> 00:07:58,240
previous pointer

196
00:07:56,560 --> 00:07:59,680
so in a sense what we have is if it's

197
00:07:58,240 --> 00:08:01,280
doubly linked we had a previous pointer

198
00:07:59,680 --> 00:08:02,400
it was singly linked we only had a next

199
00:08:01,279 --> 00:08:05,519
pointer

200
00:08:02,399 --> 00:08:07,120
and if you think about the limitations of

201
00:08:05,519 --> 00:08:07,758
linked lists especially singly linked

202
00:08:07,120 --> 00:08:10,079
lists

203
00:08:07,759 --> 00:08:12,160
if you only have one pointer to a node

204
00:08:10,079 --> 00:08:16,079
you can only create a list

205
00:08:12,160 --> 00:08:16,080
and so the result is

206
00:08:17,120 --> 00:08:23,598
you know this node is going to have a

207
00:08:20,319 --> 00:08:25,840
depth linear depth means how many

208
00:08:23,598 --> 00:08:27,839
pointers do I have to follow to get here

209
00:08:25,839 --> 00:08:29,198
from the root the structure which for

210
00:08:27,839 --> 00:08:31,038
linked lists was the head

211
00:08:29,199 --> 00:08:32,639
it was doubly linked okay I can have a

212
00:08:31,038 --> 00:08:33,837
head and a tail and I can put

213
00:08:33,838 --> 00:08:37,599
bidirectionals here but still the middle element

214
00:08:35,599 --> 00:08:38,479
has linear depth so you can't

215
00:08:37,599 --> 00:08:40,320
get there in

216
00:08:38,479 --> 00:08:42,080
less than linear time with binary

217
00:08:40,320 --> 00:08:44,399
trees because we use

218
00:08:42,080 --> 00:08:45,440
two types of next  pointers left and

219
00:08:44,399 --> 00:08:47,440
right,

220
00:08:45,440 --> 00:08:49,040
we can build a tree, and we know that trees

221
00:08:47,440 --> 00:08:52,080
in general have logarithmic,

222
00:08:49,039 --> 00:08:55,278
can have logarithmic height,

223
00:08:52,080 --> 00:08:57,759
so you can get to

224
00:08:55,278 --> 00:08:59,759
any node in a tree starting from the root in only

225
00:08:57,759 --> 00:09:01,039
log n traversals, so that's the intuition of what's

226
00:09:01,039 --> 00:09:03,679
going on, today

227
00:09:04,799 --> 00:09:08,079
we're going to talk about the height of a

228
00:09:06,799 --> 00:09:11,120
tree,

229
00:09:08,080 --> 00:09:11,120
so let me define,

230
00:09:12,559 --> 00:09:16,239
I'm going to need a couple of definitions

231
00:09:14,080 --> 00:09:16,240
here

232
00:09:18,559 --> 00:09:27,039
subtree and

233
00:09:23,839 --> 00:09:30,480
node height,

234
00:09:27,039 --> 00:09:33,439
so a tree is decomposed into subtrees,

235
00:09:30,480 --> 00:09:35,039
so for example, a subtree with root b

236
00:09:33,440 --> 00:09:40,000
or subtree b

237
00:09:35,039 --> 00:09:40,000
is that part of the tree,

238
00:09:40,320 --> 00:09:44,640
so that's that node and all the

239
00:09:42,639 --> 00:09:46,080
descendants of that node, so since we

240
00:09:44,639 --> 00:09:48,958
have parents and children,

241
00:09:46,080 --> 00:09:49,600
we can generalize in the sense of a family tree,

242
00:09:49,600 --> 00:09:53,200
we can talk about the ancestors of a node, so the

243
00:09:52,000 --> 00:09:55,519
ancestors of f

244
00:09:53,200 --> 00:09:57,278
are its father, its grandfather and grandmother, its grandmother

245
00:09:55,519 --> 00:09:59,839
and grandfather, etc.

246
00:09:57,278 --> 00:10:01,200
together they're all called

247
00:09:59,839 --> 00:10:02,800
ancestors,

248
00:10:01,200 --> 00:10:04,959
this doesn't quite match the

249
00:10:02,799 --> 00:10:05,838
familiar trees, because in family trees

250
00:10:04,958 --> 00:10:07,679
you have

251
00:10:05,839 --> 00:10:10,000
two  parents, here you only have a unique

252
00:10:07,679 --> 00:10:13,199
parent,

253
00:10:10,000 --> 00:10:15,839
or the poor root has no parents,

254
00:10:13,200 --> 00:10:16,480
we also talk about this as a mixed

255
00:10:15,839 --> 00:10:19,519
metaphor of the

256
00:10:16,480 --> 00:10:22,079
leaves of a tree,

257
00:10:19,519 --> 00:10:22,078
these are

258
00:10:23,519 --> 00:10:27,679
people without children, parents will

259
00:10:26,720 --> 00:10:31,920
complain about this,

260
00:10:27,679 --> 00:10:33,359
but many, like many of us in this room, we do

261
00:10:31,919 --> 00:10:34,479
n't have children (children) yet, so we're called

262
00:10:33,360 --> 00:10:36,000
leaves,

263
00:10:34,480 --> 00:10:39,440
you can tell your parents, hey, I'm just a

264
00:10:36,000 --> 00:10:42,320
leaf, you know, blowing in the wind,

265
00:10:39,440 --> 00:10:43,440
so you know, like this is so many

266
00:10:42,320 --> 00:10:46,640
mixed metaphors, but we

267
00:10:43,440 --> 00:10:48,720
always draw trees down, like the

268
00:10:46,639 --> 00:10:51,600
structure of the root of a tree,

269
00:10:48,720 --> 00:10:52,639
but we call the ends of the roots leaves,

270
00:10:51,600 --> 00:10:55,920
which are still

271
00:10:52,639 --> 00:10:57,439
upside down, these are trees for you, lots of

272
00:10:55,919 --> 00:10:59,439
interesting analogies okay, but

273
00:10:57,440 --> 00:11:00,000
ancestors are useful, descendants are

274
00:10:59,440 --> 00:11:02,079
also useful,

275
00:11:00,000 --> 00:11:03,839
so the descendants of b are all of its children

276
00:11:02,078 --> 00:11:04,799
, all of its grandchildren,

277
00:11:03,839 --> 00:11:07,760
and everything way down,

278
00:11:04,799 --> 00:11:08,479
but only inside the subtree, so the subtree of

279
00:11:07,759 --> 00:11:15,838
x

280
00:11:08,480 --> 00:11:15,839
consists of x and its descendants,

281
00:11:16,879 --> 00:11:22,240
and we think of x as the root of

282
00:11:20,559 --> 00:11:24,239
that subtree, so we kind of

283
00:11:22,240 --> 00:11:25,120
forget about everything outside

284
00:11:24,240 --> 00:11:28,399
subtree

285
00:11:25,120 --> 00:11:29,440
when we talk about subtree x Let's

286
00:11:28,399 --> 00:11:32,240
talk about

287
00:11:29,440 --> 00:11:32,240
the depth of a node.

288
00:11:33,278 --> 00:11:36,399
The depth of a node is,

289
00:11:36,879 --> 00:11:47,120
I think, the number of its ancestors,

290
00:11:43,440 --> 00:11:47,360
um, but I usually think of it

291
00:11:47,120 --> 00:11:52,320
as

292
00:11:47,360 --> 00:11:52,320
the number of edges

293
00:11:52,879 --> 00:12:01,759
and on the path from

294
00:11:57,278 --> 00:12:01,759
x to the root

295
00:12:02,480 --> 00:12:06,159
so each node has a unique path that

296
00:12:04,879 --> 00:12:08,879
goes up until it ca

297
00:12:06,159 --> 00:12:09,679
n't go up anymore, so

298
00:12:08,879 --> 00:12:12,799
the depth of e is

299
00:12:09,679 --> 00:12:16,399
two because

300
00:12:12,799 --> 00:12:18,958
on the path from the root a to e there are two edges, one two,

301
00:12:16,399 --> 00:12:20,320
so maybe I'll write some depths well, the depth of

302
00:12:18,958 --> 00:12:22,559
e is two the

303
00:12:20,320 --> 00:12:24,399
depth of these guys is one the depth of the

304
00:12:22,559 --> 00:12:28,399
root is zero

305
00:12:24,399 --> 00:12:33,039
two three, so that's the

306
00:12:28,399 --> 00:12:38,879
depth, I'm going to

307
00:12:33,039 --> 00:12:41,278
clean this up a little bit

308
00:12:38,879 --> 00:12:43,039
so we can focus on the picture, all right,

309
00:12:41,278 --> 00:12:44,799
the height, so the depth is the measurement

310
00:12:43,039 --> 00:12:46,639
down because you know if you

311
00:12:44,799 --> 00:12:49,359
imagine depth in water, that's the

312
00:12:46,639 --> 00:12:51,200
surface of the water and

313
00:12:49,360 --> 00:12:52,159
then we measure how deep you are from

314
00:12:51,200 --> 00:12:54,160
the surface,

315
00:12:52,159 --> 00:12:56,000
the height in the opposite direction we

316
00:12:54,159 --> 00:12:58,078
'll measure from the level of the leaves

317
00:12:56,000 --> 00:12:59,600
up because the leaves are the bottom of the

318
00:12:58,078 --> 00:13:03,439
tree, so the height of

319
00:12:59,600 --> 00:13:07,200
the node is going to be

320
00:13:03,440 --> 00:13:11,519
the number of edges

321
00:13:07,200 --> 00:13:11,519
on the longest path down,

322
00:13:19,519 --> 00:13:26,000
okay, that's the same thing as the

323
00:13:22,799 --> 00:13:29,199
maximum depth of the node

324
00:13:26,000 --> 00:13:29,200
in the subtree x,

325
00:13:32,799 --> 00:13:39,120
let's denote the height in red,

326
00:13:37,039 --> 00:13:41,039
so what's the length of the longest path from

327
00:13:39,120 --> 00:13:42,159
f to the leaf, okay, f is a leaf, so all

328
00:13:41,039 --> 00:13:45,919
the leaves have

329
00:13:42,159 --> 00:13:49,278
zero depth, sorry, height zero,

330
00:13:45,919 --> 00:13:52,399
turn it back,

331
00:13:49,278 --> 00:13:54,399
um, there's this, so there's two

332
00:13:52,399 --> 00:13:56,480
ways down, this doesn't go to the

333
00:13:54,399 --> 00:13:59,600
leaf, uh, this one goes to the leaf,

334
00:13:56,480 --> 00:14:02,800
and its height is zero, so this height is

335
00:13:59,600 --> 00:14:05,199
one, here one edge of leaf b

336
00:14:02,799 --> 00:14:08,319
has two leaves that it can reach, we take the

337
00:14:05,198 --> 00:14:16,240
longest one, so it's length two, and it

338
00:14:08,320 --> 00:14:19,680
also has height three.

339
00:14:16,240 --> 00:14:20,480
Okay, the height we measure up, the depth

340
00:14:19,679 --> 00:14:23,359
we measure

341
00:14:20,480 --> 00:14:24,320
down, one thing that we care about

342
00:14:23,360 --> 00:14:27,360
is just the height of the

343
00:14:24,320 --> 00:14:31,839
whole tree, and this is the

344
00:14:27,360 --> 00:14:31,839
height of the root,

345
00:14:32,720 --> 00:14:36,879
and I'm going to call it h because

346
00:14:33,919 --> 00:14:36,879
we're going to use this a lot,

347
00:14:39,440 --> 00:14:43,199
and today we're going to get to the point where

348
00:14:41,519 --> 00:14:44,240
all these execution times instead of

349
00:14:43,198 --> 00:14:47,759
being logarithmic,

350
00:14:44,240 --> 00:14:47,759
they're going to be of order h,

351
00:14:48,720 --> 00:14:53,040
so our goal today is to make all of the

352
00:14:51,600 --> 00:14:56,320
important things for  us operations map

353
00:14:53,039 --> 00:14:56,319
in order h

354
00:14:57,039 --> 00:15:01,599
and then next we go to lecture to

355
00:14:59,519 --> 00:15:04,000
guarantee that h is always log n

356
00:15:01,600 --> 00:15:05,600
and then we get time log n so we need to

357
00:15:04,000 --> 00:15:07,120
do a bunch of work to get to log n

358
00:15:05,600 --> 00:15:08,480
today we're going to do the work i.e. all the

359
00:15:07,120 --> 00:15:10,480
tree manipulations

360
00:15:08,480 --> 00:15:12,879
and if your tree is nice and

361
00:15:10,480 --> 00:15:14,320
small it doesn't have a lot of height

362
00:15:12,879 --> 00:15:16,480
if it has logarithmic height everything

363
00:15:14,320 --> 00:15:18,079
will be logarithmic of course there are trees

364
00:15:16,480 --> 00:15:21,199
that are really bad

365
00:15:18,078 --> 00:15:21,198
right we can have a

366
00:15:24,799 --> 00:15:29,198
tree like this which is basically a

367
00:15:27,759 --> 00:15:31,120
linked list

368
00:15:29,198 --> 00:15:32,639
where we only use right pointers and all the

369
00:15:31,120 --> 00:15:34,799
left pointers are gone

370
00:15:32,639 --> 00:15:35,759
so there is height there are trees that are really tall

371
00:15:35,759 --> 00:15:40,079
have a lot of height hmm we want to avoid

372
00:15:38,639 --> 00:15:42,959
that but we won't worry about that until the

373
00:15:40,078 --> 00:15:42,958
next lecture question

374
00:15:45,440 --> 00:15:48,800
what is the height of node c the height of

375
00:15:47,198 --> 00:15:50,399
node c is zero

376
00:15:48,799 --> 00:15:52,000
because the length of the longest path

377
00:15:50,399 --> 00:15:54,720
the number of edges in the longest

378
00:15:52,000 --> 00:15:58,078
path down is zero so we

379
00:15:54,720 --> 00:15:58,079
count edges not vertices so

380
00:15:58,399 --> 00:16:03,600
yeah, the height of the tree,

381
00:16:02,399 --> 00:16:05,440
of course just the depth, the

382
00:16:03,600 --> 00:16:07,440
maximum depth, I think that's right,

383
00:16:05,440 --> 00:16:09,600
so the height here is

384
00:16:07,440 --> 00:16:11,199
three, and the maximum depth is a

385
00:16:09,600 --> 00:16:12,879
terribly drawn three,

386
00:16:11,198 --> 00:16:14,319
so they correspond in the

387
00:16:12,879 --> 00:16:17,278
maximum case,

388
00:16:14,320 --> 00:16:18,720
but we use height to always mean the maximum

389
00:16:17,278 --> 00:16:20,639
, so

390
00:16:18,720 --> 00:16:22,079
we're talking about the height of the tree, the

391
00:16:20,639 --> 00:16:25,919
depth of the tree is not defined,

392
00:16:22,078 --> 00:16:29,039
just the depth of the notes, okay,

393
00:16:25,919 --> 00:16:29,679
how can we use these trees to

394
00:16:29,039 --> 00:16:33,278
represent a

395
00:16:29,679 --> 00:16:36,638
sequence or a set, well,

396
00:16:33,278 --> 00:16:40,639
I argue that there is a natural order in trees

397
00:16:36,639 --> 00:16:40,639
called the traversal order of the

398
00:16:47,839 --> 00:16:54,399
nodes or elements

399
00:16:51,600 --> 00:16:55,920
and the tree, so I'll define a

400
00:16:54,399 --> 00:16:59,679
certain order, let

401
00:16:55,919 --> 00:17:04,240
's say in this example

402
00:16:59,679 --> 00:17:07,198
let's do an example first, the

403
00:17:04,240 --> 00:17:07,199
traversal order

404
00:17:09,838 --> 00:17:16,798
would be f

405
00:17:12,959 --> 00:17:16,798
d b

406
00:17:16,838 --> 00:17:23,358
e a

407
00:17:20,318 --> 00:17:25,438
c I feel like I'm in music class, this is

408
00:17:23,358 --> 00:17:26,878
my guitar or something like that, but it's not me I

409
00:17:25,439 --> 00:17:30,640
hope hmm

410
00:17:26,880 --> 00:17:32,960
if this is a coincidence then what is this

411
00:17:30,640 --> 00:17:34,480
order what I would like to do

412
00:17:32,960 --> 00:17:37,440
is

413
00:17:34,480 --> 00:17:38,720
recursively determine the order where the

414
00:17:37,440 --> 00:17:39,519
root of the tree is somewhere in the middle,

415
00:17:39,519 --> 00:17:42,960
and everything in  the left subtree comes

416
00:17:42,960 --> 00:17:47,120
before the root and

417
00:17:44,880 --> 00:17:50,160
everything in the right subtree comes after

418
00:17:47,119 --> 00:17:51,759
so you can see here c comes after a and

419
00:17:50,160 --> 00:17:55,919
then all the other nodes come before

420
00:17:51,759 --> 00:17:58,960
a and recursively if i look at node b

421
00:17:55,919 --> 00:18:00,240
this node b which here comes e

422
00:17:58,960 --> 00:18:03,120
to the right of it

423
00:18:00,240 --> 00:18:03,440
but it's all to the left of a so

424
00:18:03,119 --> 00:18:06,959
e

425
00:18:03,440 --> 00:18:08,960
is between b and a would be to the left

426
00:18:06,960 --> 00:18:10,720
and then f and d to the left of that

427
00:18:08,960 --> 00:18:14,640
and again f comes before d

428
00:18:10,720 --> 00:18:17,679
because f is in the left subtree d

429
00:18:14,640 --> 00:18:17,679
well so we say

430
00:18:18,000 --> 00:18:21,839
for each node the

431
00:18:24,400 --> 00:18:33,519
nodes

432
00:18:27,599 --> 00:18:33,519
at x dot left come before x

433
00:18:34,480 --> 00:18:43,120
and the nodes at x dot right come

434
00:18:37,919 --> 00:18:44,720
after x

435
00:18:43,119 --> 00:18:46,319
and this uniquely defines an order which

436
00:18:44,720 --> 00:18:48,000
is called the traversal order

437
00:18:46,319 --> 00:18:50,480
it is also called the traversal in order

438
00:18:48,000 --> 00:18:52,319
order it is called in order because it is

439
00:18:50,480 --> 00:18:54,079
in order of traversal so it is very

440
00:18:52,319 --> 00:18:55,759
circular but

441
00:18:54,079 --> 00:18:57,199
you may have seen the traversal in order it is the

442
00:18:55,759 --> 00:18:58,640
same there

443
00:18:57,200 --> 00:19:00,720
is a very simple algorithm to

444
00:18:58,640 --> 00:19:04,080
calculate this

445
00:19:00,720 --> 00:19:07,360
if i want  to iterate,

446
00:19:04,079 --> 00:19:08,319
let's call it this way, if I want to

447
00:19:07,359 --> 00:19:11,599
iterate over

448
00:19:08,319 --> 00:19:13,119
all the nodes in a subtree x, rooted

449
00:19:11,599 --> 00:19:16,558
at x,

450
00:19:13,119 --> 00:19:19,918
I'll just iterate over all the

451
00:19:16,558 --> 00:19:22,639
nodes in the left subtree, then output

452
00:19:19,919 --> 00:19:22,640
x itself,

453
00:19:22,798 --> 00:19:27,839
and then iterate over all the nodes in the

454
00:19:25,200 --> 00:19:27,840
right subtree,

455
00:19:30,720 --> 00:19:34,319
okay, you may have seen this algorithm

456
00:19:32,558 --> 00:19:35,678
before, this is just another way of

457
00:19:34,319 --> 00:19:37,519
codifying the same thing,

458
00:19:35,679 --> 00:19:39,600
the result is all the nodes in

459
00:19:37,519 --> 00:19:40,798
the subtree appear continuously without any

460
00:19:39,599 --> 00:19:43,359
breaks,

461
00:19:40,798 --> 00:19:44,798
and then the parent parent will

462
00:19:43,359 --> 00:19:48,079
precede after depending on whether

463
00:19:44,798 --> 00:19:48,079
it's a left or right child,

464
00:19:48,400 --> 00:19:52,720
okay, now it's just a matter of

465
00:19:51,359 --> 00:19:54,639
connecting the dots, since we're

466
00:19:52,720 --> 00:19:56,720
representing the order

467
00:19:54,640 --> 00:19:58,320
and for the sequence, what will that be the

468
00:19:56,720 --> 00:20:00,160
order of the sequence, if we want to store n

469
00:19:58,319 --> 00:20:02,798
elements from x0 to x1,

470
00:20:00,160 --> 00:20:04,159
we're going to create some kind of tree,

471
00:20:02,798 --> 00:20:07,519
we're going to put x0 here,

472
00:20:04,159 --> 00:20:09,520
x1 here, x2 here, x3 here, x4 here, x5

473
00:20:07,519 --> 00:20:10,960
here, you can see that I'm very used to

474
00:20:09,519 --> 00:20:11,759
dealing with traversal orders, this takes

475
00:20:10,960 --> 00:20:12,960
some time,

476
00:20:11,759 --> 00:20:15,519
you can also see it here, we're

477
00:20:12,960 --> 00:20:18,319
going to put x1 on this node  x2

478
00:20:15,519 --> 00:20:21,759
sorry x0 here x1 here x2 here and so on

479
00:20:18,319 --> 00:20:23,599
the same order that I specified

480
00:20:21,759 --> 00:20:25,119
okay this is for sequences for sets this

481
00:20:23,599 --> 00:20:25,759
order will just be a sorted

482
00:20:25,119 --> 00:20:27,199
order

483
00:20:25,759 --> 00:20:29,359
and we will effectively

484
00:20:27,200 --> 00:20:33,279
represent the sorted order of the keys let

485
00:20:29,359 --> 00:20:36,479
's say ascending but before we get to that

486
00:20:33,279 --> 00:20:38,879
let's talk about the different operations that we

487
00:20:36,480 --> 00:20:38,880
can do

488
00:20:39,519 --> 00:20:43,599
just by playing around with the traversal order

489
00:20:43,839 --> 00:20:47,599
and then we are going to use them to

490
00:20:45,119 --> 00:20:49,519
build the sequence and set up the operations

491
00:20:47,599 --> 00:20:52,719
that we are interested in

492
00:20:49,519 --> 00:20:55,440
so the first operation i

493
00:20:52,720 --> 00:20:58,159
will first call the subtree it seems appropriate that

494
00:20:55,440 --> 00:20:58,159
it is called first

495
00:20:58,480 --> 00:21:06,079
this is the first so given a node

496
00:21:02,640 --> 00:21:08,880
which i will call the node this defines a

497
00:21:06,079 --> 00:21:08,879
subtree

498
00:21:10,079 --> 00:21:16,240
which usually we draw subtrees as

499
00:21:12,480 --> 00:21:19,360
triangles hanging from a node

500
00:21:16,240 --> 00:21:21,200
so here i would write x

501
00:21:19,359 --> 00:21:23,119
and then there is some subtree of all the

502
00:21:21,200 --> 00:21:25,440
descendants of x

503
00:21:23,119 --> 00:21:26,399
so first the subtree i would like to

504
00:21:25,440 --> 00:21:31,840
say among

505
00:21:26,400 --> 00:21:31,840
all the nodes in this subtree

506
00:21:34,240 --> 00:21:38,798
which is the first in order  traversal,

507
00:21:43,119 --> 00:21:46,639
so just limiting myself to

508
00:21:46,960 --> 00:21:51,279
this subtree, so the tree of this,

509
00:21:55,038 --> 00:21:59,839
so where is it in this tree,

510
00:22:03,839 --> 00:22:07,199
the note is actually part of many

511
00:22:05,519 --> 00:22:10,000
subtrees, good question, uh,

512
00:22:07,200 --> 00:22:10,400
f f is its own in subtree f

513
00:22:10,000 --> 00:22:12,480
uh

514
00:22:10,400 --> 00:22:14,080
f is also in subtree d f is in

515
00:22:12,480 --> 00:22:15,839
subtree b, as i drew

516
00:22:14,079 --> 00:22:19,839
f is in subtree a, it's

517
00:22:15,839 --> 00:22:19,839
exactly in its ancestor subtree,

518
00:22:20,558 --> 00:22:24,000
but in this operation, when we define a

519
00:22:23,119 --> 00:22:26,319
node,

520
00:22:24,000 --> 00:22:28,079
our node defines only one subtree, it's the

521
00:22:26,319 --> 00:22:29,359
root of only one subtree,

522
00:22:28,079 --> 00:22:32,240
and it's this subtree that we

523
00:22:29,359 --> 00:22:34,558
I want to know, among all

524
00:22:32,240 --> 00:22:37,200
these nodes, which includes the node itself

525
00:22:34,558 --> 00:22:37,678
and other things, which one is

526
00:22:37,200 --> 00:22:39,279
first

527
00:22:37,679 --> 00:22:42,400
in this traversal order, it's similar to the

528
00:22:39,279 --> 00:22:45,759
practice with traversal orders,

529
00:22:42,400 --> 00:22:45,759
so where do I look for this node,

530
00:22:49,200 --> 00:22:54,960
yeah, the leftmost leaf

531
00:22:52,798 --> 00:22:57,119
in the image, it's here, but images

532
00:22:54,960 --> 00:23:00,240
can be misleading,

533
00:22:57,119 --> 00:23:02,479
we just want to go

534
00:23:00,240 --> 00:23:06,480
as far left as possible, when I say left, I

535
00:23:02,480 --> 00:23:06,480
mean this iteration node is equal to

536
00:23:06,839 --> 00:23:10,399
node.left,  you just look at our

537
00:23:08,798 --> 00:23:13,279
definition

538
00:23:10,400 --> 00:23:14,880
all the nodes on the left are before x

539
00:23:13,279 --> 00:23:16,319
and all the nodes on the right so

540
00:23:14,880 --> 00:23:18,559
it has to be in the left subtree if

541
00:23:16,319 --> 00:23:21,599
there is one of

542
00:23:18,558 --> 00:23:26,639
course we can't do this forever so

543
00:23:21,599 --> 00:23:26,639
say until we fall out of the tree which

544
00:23:28,159 --> 00:23:33,840
means the node is out of

545
00:23:34,720 --> 00:23:39,679
order but we stopped before that happens

546
00:23:39,679 --> 00:23:43,360
so it's like instructions like

547
00:23:41,599 --> 00:23:43,918
oh you keep going until you see the store

548
00:23:43,919 --> 00:23:47,679
and this is the block right before that that's

549
00:23:45,679 --> 00:23:49,519
fine this is not very useful

550
00:23:47,679 --> 00:23:50,960
so you keep repeating the node equals no

551
00:23:49,519 --> 00:23:53,839
dot until the node is

552
00:23:50,960 --> 00:23:55,200
zero and then you undo one step okay you

553
00:23:53,839 --> 00:23:55,918
all know how to program that it's not

554
00:23:55,200 --> 00:23:58,960
hard well so that

555
00:23:55,919 --> 00:24:00,880
last

556
00:23:58,960 --> 00:24:02,400
node that is not actually the root it

557
00:24:00,880 --> 00:24:04,880
could be a node

558
00:24:02,400 --> 00:24:06,960
maybe it has no left children but in

559
00:24:04,880 --> 00:24:08,880
that case i would argue that the node is first

560
00:24:06,960 --> 00:24:09,679
in its subtree traversal order

561
00:24:08,880 --> 00:24:11,919
because,

562
00:24:09,679 --> 00:24:15,120
if there are no nodes on the left,

563
00:24:11,919 --> 00:24:18,400
come before x, then x is actually the first,

564
00:24:15,119 --> 00:24:20,719
okay, and that's it, uh, returns

565
00:24:18,400 --> 00:24:20,720
the node,

566
00:24:22,400 --> 00:24:26,480
so I'm changing the node in place here and the

567
00:24:24,640 --> 00:24:27,440
last one before I hit none, that's

568
00:24:26,480 --> 00:24:29,679
the minimum,

569
00:24:27,440 --> 00:24:31,679
that's the first element in the

570
00:24:29,679 --> 00:24:32,798
traversal order, you can also define a subtree

571
00:24:31,679 --> 00:24:35,360
last,

572
00:24:32,798 --> 00:24:38,000
okay, let's make it more interesting one

573
00:24:35,359 --> 00:24:38,000
next

574
00:24:41,359 --> 00:24:45,439
node, so in this case I want to know what

575
00:24:45,038 --> 00:24:48,158
is

576
00:24:45,440 --> 00:24:48,159
next

577
00:24:50,000 --> 00:24:56,960
after the node in the

578
00:24:53,599 --> 00:24:58,839
overall traversal order of the tree, okay, here

579
00:24:56,960 --> 00:25:01,919
I've limited myself to

580
00:24:58,839 --> 00:25:03,519
one subtree now I'm thinking

581
00:25:01,919 --> 00:25:04,480
about the whole tree in the entire

582
00:25:03,519 --> 00:25:06,400
traversal order,

583
00:25:04,480 --> 00:25:08,079
and given a node, I want to know which one is

584
00:25:06,400 --> 00:25:11,360
next,

585
00:25:08,079 --> 00:25:11,759
call it a successor, I feel like I

586
00:25:11,359 --> 00:25:14,879
need to

587
00:25:11,759 --> 00:25:15,359
create some kind of Royal Family joke,

588
00:25:14,880 --> 00:25:18,640
but

589
00:25:15,359 --> 00:25:20,639
I don't know how to do that,

590
00:25:18,640 --> 00:25:22,640
each node has a unique successor, let's

591
00:25:20,640 --> 00:25:26,080
give some examples

592
00:25:22,640 --> 00:25:28,000
so we can start with f, the successor of

593
00:25:26,079 --> 00:25:31,119
f, if we just index this

594
00:25:28,000 --> 00:25:34,000
list, the successor is d, okay, the

595
00:25:31,119 --> 00:25:35,759
successor of d is b  successor b is simplicity

596
00:25:34,000 --> 00:25:36,159
well it's very easy to read successors

597
00:25:36,159 --> 00:25:39,440
when I wrote down the traversal order

598
00:25:37,599 --> 00:25:41,439
but let's think about how to do it

599
00:25:39,440 --> 00:25:44,880
in a tree

600
00:25:41,440 --> 00:25:44,880
well

601
00:25:45,038 --> 00:25:48,480
let's see there will be two

602
00:25:46,558 --> 00:25:52,158
cases

603
00:25:48,480 --> 00:25:53,839
if I look at successor a it has a

604
00:25:52,159 --> 00:25:56,159
right descendant

605
00:25:53,839 --> 00:25:57,918
and in that case the right descendant a is

606
00:25:56,159 --> 00:25:58,640
the successor but that's not always the case i

607
00:25:58,640 --> 00:26:04,080
don't have a good example but if i

608
00:26:01,759 --> 00:26:08,079
had another node here let's call it

609
00:26:04,079 --> 00:26:11,359
g well successor a is

610
00:26:08,079 --> 00:26:14,158
actually g right because

611
00:26:11,359 --> 00:26:14,879
all these elements come after a in

612
00:26:14,159 --> 00:26:17,200
order

613
00:26:14,880 --> 00:26:18,559
but which one comes first the leftmost

614
00:26:17,200 --> 00:26:20,720
leaf

615
00:26:18,558 --> 00:26:22,639
okay this is the problem we just solved

616
00:26:20,720 --> 00:26:24,720
so if a has a right child what

617
00:26:22,640 --> 00:26:25,679
we want is the leftmost leaf

618
00:26:24,720 --> 00:26:29,919
first

619
00:26:25,679 --> 00:26:29,919
in this subtree

620
00:26:30,000 --> 00:26:33,919
right subtree right child subtree

621
00:26:32,480 --> 00:26:37,759
so that's the first case

622
00:26:33,919 --> 00:26:40,799
if well node.right

623
00:26:37,759 --> 00:26:44,558
so if we have a right child then

624
00:26:40,798 --> 00:26:44,558
we want the

625
00:26:44,640 --> 00:26:47,520
subtree first

626
00:26:48,720 --> 00:26:53,839
right child

627
00:26:54,798 --> 00:26:58,720
Great, we can reduce to this other

628
00:26:56,798 --> 00:27:01,679
operation,

629
00:26:58,720 --> 00:27:02,720
but what if a node doesn't have the

630
00:27:01,679 --> 00:27:05,519
right child,

631
00:27:02,720 --> 00:27:06,000
so for example it could be a leaf, let's say

632
00:27:05,519 --> 00:27:08,400
we take the

633
00:27:06,000 --> 00:27:09,919
successor, I mean it doesn't have to

634
00:27:08,400 --> 00:27:11,600
be a leaf, it could be f which has no

635
00:27:09,919 --> 00:27:14,080
children, it could be d which has one child

636
00:27:11,599 --> 00:27:17,119
but doesn't have the right child,

637
00:27:14,079 --> 00:27:19,839
so what is the successor of f, is d

638
00:27:17,119 --> 00:27:21,519
which in this case is the parent, but

639
00:27:19,839 --> 00:27:22,398
that's not always the case, for example if we make

640
00:27:21,519 --> 00:27:24,480
the successor of e,

641
00:27:22,398 --> 00:27:26,479
its parent is actually earlier in

642
00:27:24,480 --> 00:27:29,200
order because e was the right child

643
00:27:26,480 --> 00:27:30,399
f was the left child, so its

644
00:27:29,200 --> 00:27:33,120
parent

645
00:27:30,398 --> 00:27:33,119
was

646
00:27:33,759 --> 00:27:39,440
the successor of d, it happens, b because

647
00:27:36,880 --> 00:27:40,159
it was the left child of its

648
00:27:39,440 --> 00:27:41,759
parent,

649
00:27:40,159 --> 00:27:43,200
okay, so it seems like a simple case, if

650
00:27:41,759 --> 00:27:47,038
we are the left child of our parent,

651
00:27:43,200 --> 00:27:49,038
then our successor is our parent, okay,

652
00:27:47,038 --> 00:27:50,240
based on that  a little example but we can

653
00:27:49,038 --> 00:27:52,798
argue about that in a moment

654
00:27:50,240 --> 00:27:55,120
what is the successor of e okay it's

655
00:27:52,798 --> 00:27:57,038
not b because that comes before actually

656
00:27:55,119 --> 00:27:59,519
everything in this subtree b

657
00:27:57,038 --> 00:28:03,759
comes before or equals

658
00:27:59,519 --> 00:28:05,599
e um so we have to keep moving up

659
00:28:03,759 --> 00:28:07,759
and then it turns out that the successor of e

660
00:28:05,599 --> 00:28:10,719
is a because that subtree

661
00:28:07,759 --> 00:28:12,398
was the left child of a because b was the left child of

662
00:28:10,720 --> 00:28:15,038
a

663
00:28:12,398 --> 00:28:17,519
so the general strategy is to go up the tree

664
00:28:17,519 --> 00:28:23,038
until we we go up the

665
00:28:20,798 --> 00:28:24,558
traversal the reverse direction of which

666
00:28:23,038 --> 00:28:27,919
will be left

667
00:28:24,558 --> 00:28:30,798
okay so go up the

668
00:28:27,919 --> 00:28:32,399
tree when i say i mean node

669
00:28:30,798 --> 00:28:34,960
equals node.parent

670
00:28:32,398 --> 00:28:34,959
iteration

671
00:28:40,319 --> 00:28:42,798
until

672
00:28:43,359 --> 00:28:49,199
we go up the left

673
00:28:46,798 --> 00:28:49,200
branch

674
00:28:50,480 --> 00:28:54,640
so that would mean the node before we

675
00:28:53,679 --> 00:29:00,240
make the change is

676
00:28:54,640 --> 00:29:00,240
equal to node.parent node.parent.left

677
00:29:02,960 --> 00:29:07,278
okay so we can check that and then after

678
00:29:04,960 --> 00:29:13,519
we do this traversal this  the parent node

679
00:29:07,278 --> 00:29:15,519
is the node we're looking for

680
00:29:13,519 --> 00:29:17,679
okay why is that true in general let me

681
00:29:15,519 --> 00:29:21,278
paint a more general picture

682
00:29:17,679 --> 00:29:21,278
so we start with some node

683
00:29:21,759 --> 00:29:27,440
and let's say its parent is on the right

684
00:29:25,359 --> 00:29:30,479
so it comes later in the order for

685
00:29:27,440 --> 00:29:33,360
a while sorry I'll take that back

686
00:29:30,480 --> 00:29:33,360
we make a descendant

687
00:29:34,480 --> 00:29:39,919
so it comes later on the left for a while

688
00:29:38,319 --> 00:29:41,278
so all these nodes will come

689
00:29:39,919 --> 00:29:42,480
earlier in the order because by

690
00:29:41,278 --> 00:29:43,919
definition everything in the right

691
00:29:42,480 --> 00:29:45,440
subtree comes after

692
00:29:43,919 --> 00:29:47,200
and at some point we have a parent that is on

693
00:29:45,440 --> 00:29:48,320
the right meaning this node

694
00:29:47,200 --> 00:29:50,960
was the left child of

695
00:29:48,319 --> 00:29:52,158
this parent and this node by

696
00:29:50,960 --> 00:29:55,278
definition will come

697
00:29:52,159 --> 00:29:57,200
after all the nodes here

698
00:29:55,278 --> 00:29:58,798
and can there be anything between the

699
00:29:57,200 --> 00:30:03,200
node and this well

700
00:29:58,798 --> 00:30:04,639
this parent ancestor grandparent

701
00:30:03,200 --> 00:30:06,960
only if something was in this

702
00:30:04,640 --> 00:30:08,799
subtree and we're in the case here

703
00:30:06,960 --> 00:30:10,240
where there is no right subtree of our

704
00:30:08,798 --> 00:30:12,079
source node

705
00:30:10,240 --> 00:30:13,759
so this is where all the nodes

706
00:30:12,079 --> 00:30:15,599
between the node and here will be

707
00:30:13,759 --> 00:30:17,679
but they are not there and  so this is a

708
00:30:15,599 --> 00:30:20,240
successor

709
00:30:17,679 --> 00:30:21,360
so this is kind of a general argument

710
00:30:20,240 --> 00:30:37,038
why does this

711
00:30:21,359 --> 00:30:38,558
work i see the question yes

712
00:30:37,038 --> 00:30:40,319
placed in the order of traversal so

713
00:30:38,558 --> 00:30:41,678
the order of traversal is never computed explicitly

714
00:30:41,679 --> 00:30:45,840
why we are taught it is always implicit

715
00:30:44,079 --> 00:30:49,199
we can't afford to maintain

716
00:30:45,839 --> 00:30:53,759
this let's say an array it's just

717
00:30:49,200 --> 00:30:57,519
in our heads maybe i'll draw this with a

718
00:30:53,759 --> 00:31:00,240
cloud around it we just think that's

719
00:30:57,519 --> 00:31:03,120
cool this is not in the computer explicitly

720
00:31:00,240 --> 00:31:05,120
in the computer everything we store this is this

721
00:31:03,119 --> 00:31:06,879
and the reason is it's expensive we

722
00:31:05,119 --> 00:31:08,319
we can't maintain an array of

723
00:31:06,880 --> 00:31:08,799
things and be able to insert in the

724
00:31:08,319 --> 00:31:10,960
middle

725
00:31:08,798 --> 00:31:12,558
because it's cheap i can afford to

726
00:31:10,960 --> 00:31:14,159
maintain this structure

727
00:31:12,558 --> 00:31:15,278
and do all these things

728
00:31:14,159 --> 00:31:16,640
so we talk about these

729
00:31:15,278 --> 00:31:18,960
operations because they are allowing us

730
00:31:16,640 --> 00:31:19,840
to manipulate the order or in this case

731
00:31:18,960 --> 00:31:21,919
allowing us to

732
00:31:19,839 --> 00:31:23,119
iterate the order so this was an

733
00:31:21,919 --> 00:31:24,159
algorithm to traverse the

734
00:31:23,119 --> 00:31:27,199
whole order

735
00:31:24,159 --> 00:31:29,200
but it takes linear time it was

736
00:31:27,200 --> 00:31:30,558
start in order find me

737
00:31:30,558 --> 00:31:34,960
first what was in order and it was given

738
00:31:32,240 --> 00:31:47,839
one node find me next

739
00:31:34,960 --> 00:31:47,840
how long do these operations take

740
00:31:56,480 --> 00:32:00,159
at most the height of the whole

741
00:31:58,398 --> 00:32:02,479
tree is actually going to be

742
00:32:00,159 --> 00:32:03,919
the depth of this first node but in the

743
00:32:02,480 --> 00:32:04,880
worst case it's going to be the height of the

744
00:32:03,919 --> 00:32:06,559
whole tree

745
00:32:04,880 --> 00:32:08,720
in total all of these operations

746
00:32:06,558 --> 00:32:11,200
are going to be of order h

747
00:32:08,720 --> 00:32:13,679
we need to think about that in every case

748
00:32:11,200 --> 00:32:16,240
except this one which is of order n

749
00:32:13,679 --> 00:32:17,840
so by going through everything hmm

750
00:32:16,240 --> 00:32:18,960
in this case we just

751
00:32:17,839 --> 00:32:20,879
call the subtree first so it

752
00:32:18,960 --> 00:32:22,480
takes up order h here we

753
00:32:20,880 --> 00:32:23,278
go up the tree not down but

754
00:32:22,480 --> 00:32:25,679
it's going to cost exactly the same as

755
00:32:23,278 --> 00:32:28,319
the height of the node that we

756
00:32:25,679 --> 00:32:30,640
stop earlier but in the worst case the order h

757
00:32:28,319 --> 00:32:31,918
for all of these operations that we're

758
00:32:30,640 --> 00:32:32,880
looking at today we just want to get the

759
00:32:31,919 --> 00:32:35,840
order h bound

760
00:32:32,880 --> 00:32:36,640
and later we'll bind the h so the point is

761
00:32:35,839 --> 00:32:39,918
they're

762
00:32:36,640 --> 00:32:41,759
fast if h is small like log n they're

763
00:32:39,919 --> 00:32:44,320
almost instantaneous

764
00:32:41,759 --> 00:32:45,359
whereas if i had to update an explicit

765
00:32:44,319 --> 00:32:47,119
traversal order like say an array

766
00:32:45,359 --> 00:32:49,678
i would have to spend

767
00:32:47,119 --> 00:32:52,479
linear time every time i make a change

768
00:32:49,679 --> 00:32:54,480
and yes it would be fast to make a successor

769
00:32:52,480 --> 00:32:56,319
if i kept it explicit

770
00:32:54,480 --> 00:32:57,599
but maintain  it would be impossible

771
00:32:56,319 --> 00:32:58,158
to maintain it efficiently it would be

772
00:32:57,599 --> 00:33:01,519
impossible

773
00:32:58,159 --> 00:33:01,519
question about questions

774
00:33:04,960 --> 00:33:11,840
so okay

775
00:33:13,839 --> 00:33:21,199
cool these were the queries that

776
00:33:17,679 --> 00:33:23,440
i want to follow

777
00:33:21,200 --> 00:33:25,278
see what's next in the

778
00:33:23,440 --> 00:33:26,960
traversal sequence now let's talk about actually

779
00:33:25,278 --> 00:33:28,798
changing the traversal sequence so these are

780
00:33:26,960 --> 00:33:31,519
insert and delete operations

781
00:33:28,798 --> 00:33:33,200
which will roughly correspond to an insert

782
00:33:31,519 --> 00:33:35,440
or delete

783
00:33:33,200 --> 00:33:36,640
but that's not quite we're not quite in the

784
00:33:35,440 --> 00:33:38,320
world of sequencing yet instead

785
00:33:36,640 --> 00:33:40,399
we're going to

786
00:33:38,319 --> 00:33:43,278
focus on inserting or deleting in the middle of a

787
00:33:40,398 --> 00:33:43,278
subtree

788
00:33:47,440 --> 00:33:53,840
so i'll have two nodes

789
00:33:56,240 --> 00:33:59,038
so in the

790
00:34:00,640 --> 00:34:06,720
traversal order

791
00:34:03,679 --> 00:34:08,639
so the node already exists in the tree new a

792
00:34:06,720 --> 00:34:10,159
new node that doesn't yet exist in the

793
00:34:08,639 --> 00:34:13,918
tree so i'm calling it new

794
00:34:10,159 --> 00:34:16,960
and what i would like to do is insert a new one

795
00:34:13,918 --> 00:34:18,638
right after the node and there's a symmetric

796
00:34:16,960 --> 00:34:19,918
operation that inserts before

797
00:34:18,639 --> 00:34:24,639
it is implemented almost

798
00:34:19,918 --> 00:34:26,398
identically so we'll just focus on that

799
00:34:24,639 --> 00:34:27,838
so i want to insert this new node into the

800
00:34:26,398 --> 00:34:28,799
traversal order which again is in our

801
00:34:27,838 --> 00:34:32,320
heads this is all

802
00:34:28,800 --> 00:34:32,320
in our thought bubble

803
00:34:33,280 --> 00:34:37,518
this is what we want  to achieve, and we

804
00:34:35,358 --> 00:34:39,759
have to do that by manipulating

805
00:34:37,518 --> 00:34:42,878
this tree and however we change the tree,

806
00:34:39,760 --> 00:34:49,839
it defines a new traversal order, so

807
00:34:42,878 --> 00:34:49,838
maybe let's do an example first,

808
00:35:01,679 --> 00:35:06,239
actually, I probably want this universal

809
00:35:04,639 --> 00:35:09,519
order

810
00:35:06,239 --> 00:35:13,358
to track this, so

811
00:35:09,519 --> 00:35:18,559
let's say the first thing we want to do

812
00:35:13,358 --> 00:35:18,559
is insert

813
00:35:19,280 --> 00:35:24,880
g before e

814
00:35:22,880 --> 00:35:27,440
i I want to illustrate both

815
00:35:24,880 --> 00:35:30,720
operations.

816
00:35:27,440 --> 00:35:34,079
Insert h

817
00:35:30,719 --> 00:35:36,239
after e,

818
00:35:37,920 --> 00:35:41,119
okay, well,

819
00:35:41,280 --> 00:35:46,480
insert g before e, so conceptually

820
00:35:44,559 --> 00:35:50,320
we want to insert g

821
00:35:46,480 --> 00:35:51,119
here and the way we get node

822
00:35:50,320 --> 00:35:53,440
e,

823
00:35:51,119 --> 00:35:54,960
and we get a sort of empty node I

824
00:35:53,440 --> 00:35:56,639
mean a node that only contains g, it

825
00:35:54,960 --> 00:35:59,519
doesn't have any pointers yet,

826
00:35:56,639 --> 00:36:02,000
and we would like to put it before e,

827
00:35:59,519 --> 00:36:05,679
where should I put its

828
00:36:02,000 --> 00:36:07,440
left child, okay,

829
00:36:05,679 --> 00:36:09,759
this is a simple case, if I'm trying to

830
00:36:07,440 --> 00:36:11,440
insert before, and there's no left child,

831
00:36:09,760 --> 00:36:13,200
insert it there, if I'm trying to insert

832
00:36:11,440 --> 00:36:15,760
after, and there's no right child,

833
00:36:13,199 --> 00:36:18,319
insert it there easily, so let me write the

834
00:36:15,760 --> 00:36:18,320
first case,

835
00:36:20,559 --> 00:36:24,838
so here we insert after, so if there's

836
00:36:23,199 --> 00:36:28,799
no

837
00:36:24,838 --> 00:36:28,799
right child,

838
00:36:31,358 --> 00:36:38,000
add a new one

839
00:36:34,480 --> 00:36:38,960
there, okay, I'm using informal language,

840
00:36:38,000 --> 00:36:42,719
put

841
00:36:38,960 --> 00:36:44,480
this new node

842
00:36:42,719 --> 00:36:47,598
b here instead of writing, for example,

843
00:36:44,480 --> 00:36:49,358
node.write equals new

844
00:36:47,599 --> 00:36:51,119
because it's just one operation you

845
00:36:49,358 --> 00:36:53,199
need to do, one thing you would do is set

846
00:36:51,119 --> 00:36:54,720
node.write equals new but  you also

847
00:36:53,199 --> 00:36:56,000
have to set the parent of new to

848
00:36:54,719 --> 00:36:58,239
node.write,

849
00:36:56,000 --> 00:36:59,599
so instead of worrying about these two

850
00:36:58,239 --> 00:37:01,039
pointer changes because we always do

851
00:36:59,599 --> 00:37:02,160
bidirectional pointer changes, I'm just

852
00:37:01,039 --> 00:37:03,679
going to use

853
00:37:02,159 --> 00:37:05,358
pseudocode and then in the recitation you'll

854
00:37:03,679 --> 00:37:07,440
see the actual python code that does all of this

855
00:37:05,358 --> 00:37:12,239
,

856
00:37:07,440 --> 00:37:12,240
so there's another case,

857
00:37:12,400 --> 00:37:16,000
so this should be the second example.

858
00:37:14,639 --> 00:37:20,400
insert h

859
00:37:16,000 --> 00:37:22,800
after right

860
00:37:20,400 --> 00:37:23,760
insert h after a so that we already have a

861
00:37:22,800 --> 00:37:28,640
node after a

862
00:37:23,760 --> 00:37:28,640
in the right child of this right subtree

863
00:37:29,119 --> 00:37:35,680
so where do I want to place

864
00:37:32,239 --> 00:37:38,879
h relative to

865
00:37:35,679 --> 00:37:40,399
the well it has to be to the right of a but

866
00:37:38,880 --> 00:37:43,280
it has to be

867
00:37:40,400 --> 00:37:45,119
before c it has to be to the left of c

868
00:37:43,280 --> 00:37:48,000
so that means we want to place it

869
00:37:45,119 --> 00:37:50,240
here okay in this case it was pretty

870
00:37:48,000 --> 00:37:52,000
easy because this tree was small

871
00:37:50,239 --> 00:37:54,879
where do I want to place it well

872
00:37:52,000 --> 00:37:54,880
wherever the

873
00:37:55,358 --> 00:37:59,838
subtree first tells me to put it right the

874
00:37:57,920 --> 00:38:01,680
subtree first gives me the

875
00:37:59,838 --> 00:38:05,039
successor it's all kind of

876
00:38:01,679 --> 00:38:07,118
parallel um

877
00:38:05,039 --> 00:38:08,800
we're now in the case where our node has a

878
00:38:07,119 --> 00:38:10,720
right child

879
00:38:08,800 --> 00:38:13,039
and then the successor tells us where the

880
00:38:10,719 --> 00:38:16,159
successor is this is the first

881
00:38:13,039 --> 00:38:16,559
node which is the leftmost child in the

882
00:38:16,559 --> 00:38:22,559
right subtree of the node okay there's

883
00:38:19,679 --> 00:38:22,960
a lot of pointers in this sentence but

884
00:38:22,559 --> 00:38:26,078
it's

885
00:38:22,960 --> 00:38:28,400
clearly visible in the image so this is

886
00:38:26,079 --> 00:38:30,800
in this case we had a node but it

887
00:38:28,400 --> 00:38:34,160
didn't have the right child so  we just added

888
00:38:30,800 --> 00:38:35,920
new to be its right child, okay

889
00:38:34,159 --> 00:38:41,039
otherwise

890
00:38:35,920 --> 00:38:43,599
we had a right child, so here's a node,

891
00:38:41,039 --> 00:38:44,800
there's this node here

892
00:38:43,599 --> 00:38:48,400
node.right

893
00:38:44,800 --> 00:38:48,400
which now we assume exists

894
00:38:49,039 --> 00:38:52,960
and it defines a whole subtree, there's

895
00:38:51,039 --> 00:38:56,719
this node

896
00:38:52,960 --> 00:38:58,320
which is the first node in the

897
00:38:56,719 --> 00:39:00,000
traversal order of the subtree, also known as the

898
00:38:58,320 --> 00:39:03,599
successor of the node,

899
00:39:00,000 --> 00:39:03,599
so I'll call this successor of the

900
00:39:04,239 --> 00:39:08,078
node in the current traversal order,

901
00:39:06,639 --> 00:39:10,960
but of course we'd like to make

902
00:39:08,079 --> 00:39:13,440
new the new successor of the node, so

903
00:39:10,960 --> 00:39:15,838
where does it go here,

904
00:39:16,880 --> 00:39:23,358
we want to add it as the left child

905
00:39:20,079 --> 00:39:23,359
of the old successor,

906
00:39:23,599 --> 00:39:31,519
okay so put well

907
00:39:28,559 --> 00:39:31,519
node,

908
00:39:40,320 --> 00:39:43,680
so take the successor and if you look at the

909
00:39:42,159 --> 00:39:45,519
code for the successor we're in this

910
00:39:43,679 --> 00:39:48,960
case so we know it's just going to call the

911
00:39:45,519 --> 00:39:50,000
subtree first from node.right and remember the

912
00:39:48,960 --> 00:39:52,720
subtree first

913
00:39:50,000 --> 00:39:54,400
went left as far as it could go so that

914
00:39:52,719 --> 00:39:56,000
means this  the

915
00:39:54,400 --> 00:39:58,720
successor node is guaranteed not to

916
00:39:56,000 --> 00:40:00,320
have a right left child node because it was

917
00:39:58,719 --> 00:40:02,399
defined by traversing right once and then

918
00:40:00,320 --> 00:40:04,240
traversing left as much as you could

919
00:40:02,400 --> 00:40:05,760
until there's no more left left left which means we

920
00:40:04,239 --> 00:40:09,199
can create another left

921
00:40:05,760 --> 00:40:11,040
just add a new one there and we're

922
00:40:09,199 --> 00:40:12,719
done if you look at the traversal order

923
00:40:11,039 --> 00:40:14,400
it's going to be node then new

924
00:40:12,719 --> 00:40:16,159
then old successor then the rest of

925
00:40:14,400 --> 00:40:19,358
this subtree

926
00:40:16,159 --> 00:40:22,639
okay that's cool in all cases

927
00:40:19,358 --> 00:40:24,239
i mean it was constant time

928
00:40:22,639 --> 00:40:26,879
here we spent constant time after we

929
00:40:24,239 --> 00:40:27,439
called the successor successor costs order h

930
00:40:26,880 --> 00:40:30,480
time

931
00:40:27,440 --> 00:40:30,480
so it's order h new new

932
00:40:34,239 --> 00:40:41,358
well

933
00:40:38,559 --> 00:40:41,358
put new there

934
00:40:44,639 --> 00:40:53,838
clearly well that was an insertion

935
00:40:47,679 --> 00:40:53,838
let's do a delete

936
00:40:54,400 --> 00:41:07,838
define the specification correctly and an example

937
00:41:10,318 --> 00:41:15,358
all of this will have two cases well

938
00:41:12,639 --> 00:41:19,199
let me

939
00:41:15,358 --> 00:41:20,480
i didn't update so now h after a

940
00:41:19,199 --> 00:41:22,000
so it should be like that

941
00:41:20,480 --> 00:41:25,280
you can check the new traversal order of

942
00:41:22,000 --> 00:41:25,280
this tree that's exactly what

943
00:41:26,159 --> 00:41:29,199
i'm going to do next a few

944
00:41:27,440 --> 00:41:32,079
deletions,

945
00:41:29,199 --> 00:41:32,078
let's

946
00:41:33,119 --> 00:41:41,519
delete f first and then we're going to

947
00:41:38,719 --> 00:41:41,519
okay, this is

948
00:41:42,000 --> 00:41:44,639
confusing,

949
00:41:47,599 --> 00:41:53,039
and then we're going to delete a, so

950
00:41:51,358 --> 00:41:55,039
where is f, we assume that we're given a

951
00:41:53,039 --> 00:41:57,039
pointer to f this node,

952
00:41:55,039 --> 00:41:59,519
okay, it's a leaf, so if I want to

953
00:41:57,039 --> 00:42:02,800
delete it I just erase it

954
00:41:59,519 --> 00:42:05,199
easily, leaves are easy to delete, there's nothing to

955
00:42:02,800 --> 00:42:06,560
work on, so that means I

956
00:42:05,199 --> 00:42:10,799
delete the pointer from d

957
00:42:06,559 --> 00:42:12,480
to f, okay, we just erase this guy,

958
00:42:10,800 --> 00:42:14,079
okay, now here's the trickier part,

959
00:42:12,480 --> 00:42:15,039
let's assume I want to delete the root of the

960
00:42:14,079 --> 00:42:17,599
tree, this is the

961
00:42:15,039 --> 00:42:20,239
trickiest case, but generally it's going to be

962
00:42:17,599 --> 00:42:22,720
somewhere in between a leaf and a root,

963
00:42:20,239 --> 00:42:24,318
so if I want to delete, if I just

964
00:42:22,719 --> 00:42:25,598
erase it, then suddenly these

965
00:42:24,318 --> 00:42:27,440
pointers to nowhere appear

966
00:42:25,599 --> 00:42:28,640
and I'm splitting the tree into two parts, I do

967
00:42:27,440 --> 00:42:30,400
n't want to do that, I need to keep

968
00:42:28,639 --> 00:42:34,078
my tree connected,

969
00:42:30,400 --> 00:42:36,880
so I'm going to resort to this trick,

970
00:42:34,079 --> 00:42:38,640
which is I forget whether I'm using a successor or a

971
00:42:36,880 --> 00:42:41,440
predecessor of a predecessor,

972
00:42:43,519 --> 00:42:49,119
so I'll see  on a we already

973
00:42:47,519 --> 00:42:51,519
defined the successor and

974
00:42:49,119 --> 00:42:53,760
there is the predecessor so i'm going to

975
00:42:51,519 --> 00:42:57,358
look at the predecessor of a

976
00:42:53,760 --> 00:42:58,000
which is e you can check that here the one

977
00:42:57,358 --> 00:43:01,199
before a is

978
00:42:58,000 --> 00:43:03,440
e this is the left subtree

979
00:43:01,199 --> 00:43:05,679
find me the rightmost element keep going

980
00:43:03,440 --> 00:43:07,200
until i can get this e

981
00:43:05,679 --> 00:43:09,039
so now these guys are next to each other in

982
00:43:07,199 --> 00:43:09,759
order and i'm going to remove from

983
00:43:09,039 --> 00:43:12,639
order

984
00:43:09,760 --> 00:43:13,839
so i can cheat for a moment and swap

985
00:43:12,639 --> 00:43:16,480
their labels

986
00:43:13,838 --> 00:43:17,838
i'm going to erase a and e here and put

987
00:43:16,480 --> 00:43:21,440
e

988
00:43:17,838 --> 00:43:23,519
after what because this is moving

989
00:43:21,440 --> 00:43:24,639
down the tree and if i get to a

990
00:43:23,519 --> 00:43:25,920
leaf i'm done so

991
00:43:24,639 --> 00:43:27,759
i'm not done yet because it's

992
00:43:25,920 --> 00:43:28,800
not a leaf so i look at the

993
00:43:27,760 --> 00:43:31,839
predecessor of a again now the

994
00:43:28,800 --> 00:43:34,960
predecessor of g

995
00:43:31,838 --> 00:43:38,000
we hope it's always in well further down the

996
00:43:34,960 --> 00:43:41,838
tree and then i change

997
00:43:38,000 --> 00:43:41,838
a to g

998
00:43:42,239 --> 00:43:45,759
well i've preserved the

999
00:43:44,559 --> 00:43:48,400
traversal order except when a

1000
00:43:45,760 --> 00:43:49,280
falls by just moving a earlier in

1001
00:43:48,400 --> 00:43:54,240
order here

1002
00:43:49,280 --> 00:43:56,160
and now a is a leaf and i  can erase it,

1003
00:43:54,239 --> 00:43:58,159
okay so this is what we're

1004
00:43:56,159 --> 00:43:59,358
going to follow now, actually it's a little

1005
00:43:58,159 --> 00:44:01,440
complicated, sometimes we need to use

1006
00:43:59,358 --> 00:44:05,598
predecessors sometimes we need to use

1007
00:44:01,440 --> 00:44:08,880
successor, okay so the cases are

1008
00:44:05,599 --> 00:44:13,838
if the node is a leaf, just

1009
00:44:08,880 --> 00:44:13,838
detach it from the parent,

1010
00:44:13,920 --> 00:44:18,880
that's kind of the base case in

1011
00:44:15,280 --> 00:44:18,880
recursion, otherwise there

1012
00:44:18,960 --> 00:44:24,639
are two cases, if

1013
00:44:22,000 --> 00:44:25,199
so if we're not a leaf that means we

1014
00:44:24,639 --> 00:44:27,838
have a

1015
00:44:25,199 --> 00:44:29,439
left child or a right child or

1016
00:44:27,838 --> 00:44:31,838
both, that would be an easy case,

1017
00:44:29,440 --> 00:44:33,358
but generally I either have a

1018
00:44:31,838 --> 00:44:36,400
left child

1019
00:44:33,358 --> 00:44:38,078
or I have a right child, either way

1020
00:44:36,400 --> 00:44:40,800
I'll be happy, so I don't need

1021
00:44:38,079 --> 00:44:44,079
both

1022
00:44:40,800 --> 00:44:45,119
okay what do I do if I have a

1023
00:44:44,079 --> 00:44:47,920
left child

1024
00:44:45,119 --> 00:44:48,640
that guarantees me that if the predecessor of a node

1025
00:44:48,639 --> 00:44:52,639
is inside the left subtree, which means

1026
00:44:50,639 --> 00:44:54,078
it's lower in the tree,

1027
00:44:52,639 --> 00:44:55,838
if I don't have a left child, the

1028
00:44:54,079 --> 00:44:57,760
predecessor will actually be higher in the

1029
00:44:55,838 --> 00:44:59,838
tree and I don't want to go higher,

1030
00:44:57,760 --> 00:45:01,440
okay so if in  I'm left with a child element, I know the

1031
00:44:59,838 --> 00:45:04,880
predecessor is lower,

1032
00:45:01,440 --> 00:45:08,800
so I'm going to swap

1033
00:45:04,880 --> 00:45:18,960
my item with the contents of my node

1034
00:45:08,800 --> 00:45:22,720
with the element of my predecessor,

1035
00:45:18,960 --> 00:45:32,720
and then I'm going to recursively remove the

1036
00:45:22,719 --> 00:45:34,239
predecessor.  Okay, this is the case

1037
00:45:32,719 --> 00:45:35,919
that we've been looking at in this code

1038
00:45:34,239 --> 00:45:37,838
in this example, because we've always had a

1039
00:45:35,920 --> 00:45:39,599
left child, if we have a right child but

1040
00:45:37,838 --> 00:45:41,279
no left child, we just do the opposite, we

1041
00:45:39,599 --> 00:45:43,760
swap places with our successor,

1042
00:45:41,280 --> 00:45:45,359
and then we remove the successor, in

1043
00:45:43,760 --> 00:45:47,119
any case we're going down,

1044
00:45:45,358 --> 00:45:50,239
so if we start at some node, like a

1045
00:45:47,119 --> 00:45:52,800
route, every time we do this operation,

1046
00:45:50,239 --> 00:45:53,679
we're going down and then we're

1047
00:45:52,800 --> 00:45:55,359
going down,

1048
00:45:53,679 --> 00:45:57,358
and in general we're going to keep going down,

1049
00:45:55,358 --> 00:45:59,199
picking up where we left off, which means that the

1050
00:45:57,358 --> 00:46:00,559
total amount of time we spend is

1051
00:45:59,199 --> 00:46:04,879
proportional to

1052
00:46:00,559 --> 00:46:04,880
the height of the tree in the worst case of

1053
00:46:12,838 --> 00:46:17,279
the question,

1054
00:46:15,519 --> 00:46:18,880
so we're not used to having a right child

1055
00:46:17,280 --> 00:46:20,079
, so we're changing the

1056
00:46:18,880 --> 00:46:22,640
node IDs when we do this,

1057
00:46:20,079 --> 00:46:23,599
because we did

1058
00:46:22,639 --> 00:46:25,279
n't actually move that

1059
00:46:23,599 --> 00:46:26,720
circle, the circle stayed in place, and

1060
00:46:25,280 --> 00:46:28,480
we changed the element that

1061
00:46:26,719 --> 00:46:32,000
was stored in that circle,

1062
00:46:28,480 --> 00:46:34,000
so do you call that  node e or a,

1063
00:46:32,000 --> 00:46:35,280
it doesn't matter, it's just the

1064
00:46:34,000 --> 00:46:37,039
root note,

1065
00:46:35,280 --> 00:46:38,800
okay, so we're going to play a lot of these

1066
00:46:37,039 --> 00:46:39,838
tricks, moving elements, which

1067
00:46:38,800 --> 00:46:40,800
we haven't done before, we've just been

1068
00:46:39,838 --> 00:46:44,000
creating

1069
00:46:40,800 --> 00:46:44,560
nodes and placing them somewhere, but now

1070
00:46:44,000 --> 00:46:45,920
we're

1071
00:46:44,559 --> 00:46:48,000
doing this delete operation, this is the first

1072
00:46:45,920 --> 00:46:49,119
time we're changing what's stored

1073
00:46:48,000 --> 00:46:50,719
in the nodes,

1074
00:46:49,119 --> 00:46:52,079
but we can still

1075
00:46:50,719 --> 00:46:55,358
get the traversal order right.  The traversal order of this

1076
00:46:52,079 --> 00:46:56,960
tree is dbgehc

1077
00:46:55,358 --> 00:46:59,358
this should be what we get here if I

1078
00:46:56,960 --> 00:47:01,519
remove f and

1079
00:46:59,358 --> 00:47:01,519
a

1080
00:47:02,800 --> 00:47:13,359
and sorry maybe f

1081
00:47:11,760 --> 00:47:15,520
trees won't keep the join

1082
00:47:13,358 --> 00:47:17,039
it's just the name of the game

1083
00:47:15,519 --> 00:47:18,559
we have to allow it otherwise we can't

1084
00:47:17,039 --> 00:47:22,159
do anything this is the short

1085
00:47:18,559 --> 00:47:24,239
version okay okay in the last few

1086
00:47:22,159 --> 00:47:27,279
minutes let me talk about how we take

1087
00:47:24,239 --> 00:47:30,078
these trees and implement a set

1088
00:47:27,280 --> 00:47:32,319
or a sequence okay i mentioned

1089
00:47:30,079 --> 00:47:32,318
this

1090
00:47:34,800 --> 00:47:39,839
so for a sequence

1091
00:47:40,159 --> 00:47:44,239
we just make the traversal order

1092
00:47:44,559 --> 00:47:49,119
equal to the order that we are trying to

1093
00:47:48,239 --> 00:47:53,439
represent the

1094
00:47:49,119 --> 00:47:55,358
order of the sequence

1095
00:47:53,440 --> 00:47:57,119
and if we are trying to get the elements of a set

1096
00:47:55,358 --> 00:48:00,000
with keys we will make the

1097
00:47:57,119 --> 00:48:00,000
traversal order

1098
00:48:00,800 --> 00:48:08,318
equal to ordered by increasing key

1099
00:48:04,838 --> 00:48:10,558
increasing key of element

1100
00:48:13,039 --> 00:48:17,119
some sense but then we need to

1101
00:48:15,280 --> 00:48:20,160
think about how we implement

1102
00:48:17,119 --> 00:48:23,440
all these operations so maybe the most

1103
00:48:20,159 --> 00:48:27,519
instructive to start with is

1104
00:48:23,440 --> 00:48:29,599
searching for a key in a tree

1105
00:48:27,519 --> 00:48:31,519
so this would correspond to binary

1106
00:48:29,599 --> 00:48:34,880
search

1107
00:48:31,519 --> 00:48:36,000
if i'm looking for a key let's say i'm

1108
00:48:34,880 --> 00:48:39,119
looking for

1109
00:48:36,000 --> 00:48:41,199
key g and i know this

1110
00:48:39,119 --> 00:48:43,680
can be hard in this example maybe i  I'll

1111
00:48:41,199 --> 00:48:48,558
replace all of this with numbers

1112
00:48:43,679 --> 00:48:51,679
so I can think about key values,

1113
00:48:48,559 --> 00:48:54,960
okay, so let's say 1 7

1114
00:48:51,679 --> 00:48:58,318
12 17

1115
00:48:54,960 --> 00:49:01,119
19 and 23.

1116
00:48:58,318 --> 00:49:02,239
this is now in key order if you think about

1117
00:49:01,119 --> 00:49:04,880
traversal order the

1118
00:49:02,239 --> 00:49:06,399
property is that all the keys in the

1119
00:49:04,880 --> 00:49:08,079
left subtree of the root are

1120
00:49:06,400 --> 00:49:09,440
less than the root and the root is

1121
00:49:08,079 --> 00:49:11,519
less than all the keys in the right

1122
00:49:09,440 --> 00:49:14,960
subtree and recursively all the way down

1123
00:49:11,519 --> 00:49:18,639
this is what's called the

1124
00:49:14,960 --> 00:49:21,760
binary search tree property bst property

1125
00:49:18,639 --> 00:49:22,799
these here we call them binary tree sets

1126
00:49:22,800 --> 00:49:27,280
or binary tree sets but they're

1127
00:49:25,599 --> 00:49:28,640
also known in the literature as

1128
00:49:27,280 --> 00:49:29,280
the term binary search trees which you may have heard

1129
00:49:28,639 --> 00:49:30,799
before so this is a

1130
00:49:29,280 --> 00:49:32,480
special case of what we

1131
00:49:30,800 --> 00:49:33,359
do where we keep the keys in

1132
00:49:32,480 --> 00:49:34,960
order

1133
00:49:33,358 --> 00:49:37,759
and then if I want to look up a key

1134
00:49:34,960 --> 00:49:40,000
like well 13

1135
00:49:37,760 --> 00:49:40,960
I compare this key to the root I see

1136
00:49:40,000 --> 00:49:43,519
oh it's not

1137
00:49:40,960 --> 00:49:44,000
equal and this is on the left because it's

1138
00:49:43,519 --> 00:49:47,759
less than

1139
00:49:44,000 --> 00:49:48,480
17. So  13 left from here 13 to the right of

1140
00:49:48,480 --> 00:49:54,318
13 to the right of 12 so I know that's

1141
00:49:51,599 --> 00:49:55,760
where 13 would belong

1142
00:49:54,318 --> 00:49:58,558
but there's no right child there so

1143
00:49:55,760 --> 00:50:01,359
I know I found I just returned nothing

1144
00:49:58,559 --> 00:50:03,440
if I was doing a search for the previous I would

1145
00:50:01,358 --> 00:50:05,759
return this note

1146
00:50:03,440 --> 00:50:08,159
because I tried to go right

1147
00:50:05,760 --> 00:50:09,599
last time before I fell off the tree

1148
00:50:08,159 --> 00:50:12,000
I tried to go right and

1149
00:50:09,599 --> 00:50:13,760
so the last note I had the

1150
00:50:12,000 --> 00:50:15,679
previous element if I was trying to determine the

1151
00:50:13,760 --> 00:50:18,160
next what I do is I would just take

1152
00:50:15,679 --> 00:50:20,000
this node and calculate its successor

1153
00:50:18,159 --> 00:50:21,679
which we already know how to do and it

1154
00:50:20,000 --> 00:50:24,000
turns out to be the root

1155
00:50:21,679 --> 00:50:25,519
okay now I can do these imprecise

1156
00:50:24,000 --> 00:50:26,719
searches where I find the previous and I

1157
00:50:25,519 --> 00:50:28,480
find the next as

1158
00:50:26,719 --> 00:50:29,838
I fall off the tree I find either the

1159
00:50:28,480 --> 00:50:31,519
previous or the next and

1160
00:50:29,838 --> 00:50:32,960
then with the predecessor or successor I

1161
00:50:31,519 --> 00:50:36,079
can find the other one

1162
00:50:32,960 --> 00:50:38,000
okay so how can we find and

1163
00:50:36,079 --> 00:50:42,800
find the previous

1164
00:50:38,000 --> 00:50:46,159
and find the next

1165
00:50:42,800 --> 00:50:47,119
sequences.  We need to

1166
00:50:46,159 --> 00:50:55,838
work a little more,

1167
00:50:47,119 --> 00:50:55,838
we'll do it next time

