1
00:00:14,480 --> 00:00:16,310

good morning good

2
00:00:16,310 --> 00:00:16,320
good morning good
 

3
00:00:16,320 --> 00:00:18,390
good morning good
morning welcome to double o six

4
00:00:18,390 --> 00:00:18,400
morning welcome to double o six
 

5
00:00:18,400 --> 00:00:20,550
morning welcome to double o six
introduction to algorithms lecture two

6
00:00:20,550 --> 00:00:20,560
introduction to algorithms lecture two
 

7
00:00:20,560 --> 00:00:23,670
introduction to algorithms lecture two
i am eric domain and i love algorithms

8
00:00:23,670 --> 00:00:23,680
i am eric domain and i love algorithms
 

9
00:00:23,680 --> 00:00:26,870
i am eric domain and i love algorithms
are you with me yeah

10
00:00:26,870 --> 00:00:26,880
are you with me yeah
 

11
00:00:26,880 --> 00:00:29,189
are you with me yeah
today we're not doing algorithms no

12
00:00:29,189 --> 00:00:29,199
today we're not doing algorithms no
 

13
00:00:29,199 --> 00:00:31,269
today we're not doing algorithms no
we're doing data structures it's okay

14
00:00:31,269 --> 00:00:31,279
we're doing data structures it's okay
 

15
00:00:31,279 --> 00:00:33,110
we're doing data structures it's okay
there's lots of algorithms in each data

16
00:00:33,110 --> 00:00:33,120
there's lots of algorithms in each data
 

17
00:00:33,120 --> 00:00:34,790
there's lots of algorithms in each data
structure it's like multiple algorithms

18
00:00:34,790 --> 00:00:34,800
structure it's like multiple algorithms
 

19
00:00:34,800 --> 00:00:36,069
structure it's like multiple algorithms
for free

20
00:00:36,069 --> 00:00:36,079
for free
 

21
00:00:36,079 --> 00:00:37,910
for free
we're going to talk about sequences and

22
00:00:37,910 --> 00:00:37,920
we're going to talk about sequences and
 

23
00:00:37,920 --> 00:00:39,350
we're going to talk about sequences and
sets and

24
00:00:39,350 --> 00:00:39,360
sets and
 

25
00:00:39,360 --> 00:00:42,549
sets and
linked lists and dynamic arrays fairly

26
00:00:42,549 --> 00:00:42,559
linked lists and dynamic arrays fairly
 

27
00:00:42,559 --> 00:00:43,990
linked lists and dynamic arrays fairly
simple data structures today this

28
00:00:43,990 --> 00:00:44,000
simple data structures today this
 

29
00:00:44,000 --> 00:00:45,990
simple data structures today this
is the beginning of several data

30
00:00:45,990 --> 00:00:46,000
is the beginning of several data
 

31
00:00:46,000 --> 00:00:47,110
is the beginning of several data
structures we'll be talking about the

32
00:00:47,110 --> 00:00:47,120
structures we'll be talking about the
 

33
00:00:47,120 --> 00:00:48,470
structures we'll be talking about the
next few lectures

34
00:00:48,470 --> 00:00:48,480
next few lectures
 

35
00:00:48,480 --> 00:00:51,510
next few lectures
uh but before we actually start with one

36
00:00:51,510 --> 00:00:51,520
uh but before we actually start with one
 

37
00:00:51,520 --> 00:00:54,630
uh but before we actually start with one
let me tell you slash remind you

38
00:00:54,630 --> 00:00:54,640
let me tell you slash remind you
 

39
00:00:54,640 --> 00:00:57,510
let me tell you slash remind you
of the idea the difference between an

40
00:00:57,510 --> 00:00:57,520
of the idea the difference between an
 

41
00:00:57,520 --> 00:00:58,389
of the idea the difference between an
interface

42
00:00:58,389 --> 00:00:58,399
interface
 

43
00:00:58,399 --> 00:01:00,470
interface
which you might call an api if you're a

44
00:01:00,470 --> 00:01:00,480
which you might call an api if you're a
 

45
00:01:00,480 --> 00:01:02,549
which you might call an api if you're a
programmer or an adt if you're an

46
00:01:02,549 --> 00:01:02,559
programmer or an adt if you're an
 

47
00:01:02,559 --> 00:01:04,789
programmer or an adt if you're an
ancient algorithms person like me

48
00:01:04,789 --> 00:01:04,799
ancient algorithms person like me
 

49
00:01:04,799 --> 00:01:11,270
ancient algorithms person like me
versus a data structure

50
00:01:11,270 --> 00:01:11,280

 

51
00:01:11,280 --> 00:01:14,710

these are useful distinctions uh the

52
00:01:14,710 --> 00:01:14,720
these are useful distinctions uh the
 

53
00:01:14,720 --> 00:01:15,910
these are useful distinctions uh the
idea is that

54
00:01:15,910 --> 00:01:15,920
idea is that
 

55
00:01:15,920 --> 00:01:18,469
idea is that
an interface says what you want to do a

56
00:01:18,469 --> 00:01:18,479
an interface says what you want to do a
 

57
00:01:18,479 --> 00:01:20,630
an interface says what you want to do a
data structure says how you do it

58
00:01:20,630 --> 00:01:20,640
data structure says how you do it
 

59
00:01:20,640 --> 00:01:25,510
data structure says how you do it
so you might call this a specification

60
00:01:25,510 --> 00:01:25,520

 

61
00:01:25,520 --> 00:01:27,190

and in the context of data structures

62
00:01:27,190 --> 00:01:27,200
and in the context of data structures
 

63
00:01:27,200 --> 00:01:28,870
and in the context of data structures
we're trying to store some data so the

64
00:01:28,870 --> 00:01:28,880
we're trying to store some data so the
 

65
00:01:28,880 --> 00:01:30,390
we're trying to store some data so the
interface will specify

66
00:01:30,390 --> 00:01:30,400
interface will specify
 

67
00:01:30,400 --> 00:01:35,510
interface will specify
what data you can store

68
00:01:35,510 --> 00:01:35,520

 

69
00:01:35,520 --> 00:01:37,270

whereas the data structure will give you

70
00:01:37,270 --> 00:01:37,280
whereas the data structure will give you
 

71
00:01:37,280 --> 00:01:39,350
whereas the data structure will give you
an actual representation

72
00:01:39,350 --> 00:01:39,360
an actual representation
 

73
00:01:39,360 --> 00:01:47,990
an actual representation
and tell you how to store it

74
00:01:47,990 --> 00:01:48,000

 

75
00:01:48,000 --> 00:01:50,870

this is pretty boring just storing data

76
00:01:50,870 --> 00:01:50,880
this is pretty boring just storing data
 

77
00:01:50,880 --> 00:01:52,389
this is pretty boring just storing data
is really easy you just

78
00:01:52,389 --> 00:01:52,399
is really easy you just
 

79
00:01:52,399 --> 00:01:54,710
is really easy you just
throw it in a file or something what

80
00:01:54,710 --> 00:01:54,720
throw it in a file or something what
 

81
00:01:54,720 --> 00:01:55,990
throw it in a file or something what
makes it interesting

82
00:01:55,990 --> 00:01:56,000
makes it interesting
 

83
00:01:56,000 --> 00:01:59,510
makes it interesting
is uh having operations on that data

84
00:01:59,510 --> 00:01:59,520
is uh having operations on that data
 

85
00:01:59,520 --> 00:02:03,190
is uh having operations on that data
so in the interface you specify

86
00:02:03,190 --> 00:02:03,200
so in the interface you specify
 

87
00:02:03,200 --> 00:02:06,310
so in the interface you specify
what the operations do what operations

88
00:02:06,310 --> 00:02:06,320
what the operations do what operations
 

89
00:02:06,320 --> 00:02:15,350
what the operations do what operations
are supported

90
00:02:15,350 --> 00:02:15,360

 

91
00:02:15,360 --> 00:02:22,710

and some sense what they mean

92
00:02:22,710 --> 00:02:22,720
and some sense what they mean
 

93
00:02:22,720 --> 00:02:25,190
and some sense what they mean
and the data structure actually gives

94
00:02:25,190 --> 00:02:25,200
and the data structure actually gives
 

95
00:02:25,200 --> 00:02:26,150
and the data structure actually gives
you algorithms

96
00:02:26,150 --> 00:02:26,160
you algorithms
 

97
00:02:26,160 --> 00:02:28,470
you algorithms
this is where the algorithms come in for

98
00:02:28,470 --> 00:02:28,480
this is where the algorithms come in for
 

99
00:02:28,480 --> 00:02:42,790
this is where the algorithms come in for
how to support those operations

100
00:02:42,790 --> 00:02:42,800

 

101
00:02:42,800 --> 00:02:45,670

all right so um in this class we're

102
00:02:45,670 --> 00:02:45,680
all right so um in this class we're
 

103
00:02:45,680 --> 00:02:46,949
all right so um in this class we're
going to focus on

104
00:02:46,949 --> 00:02:46,959
going to focus on
 

105
00:02:46,959 --> 00:02:51,509
going to focus on
two main interfaces

106
00:02:51,509 --> 00:02:51,519
two main interfaces
 

107
00:02:51,519 --> 00:02:54,710
two main interfaces
and various special cases of them

108
00:02:54,710 --> 00:02:54,720
and various special cases of them
 

109
00:02:54,720 --> 00:02:56,710
and various special cases of them
so the idea is to separate what you want

110
00:02:56,710 --> 00:02:56,720
so the idea is to separate what you want
 

111
00:02:56,720 --> 00:02:58,470
so the idea is to separate what you want
to do versus how to do it because

112
00:02:58,470 --> 00:02:58,480
to do versus how to do it because
 

113
00:02:58,480 --> 00:03:01,270
to do versus how to do it because
for you can think of this as the problem

114
00:03:01,270 --> 00:03:01,280
for you can think of this as the problem
 

115
00:03:01,280 --> 00:03:01,910
for you can think of this as the problem
statement

116
00:03:01,910 --> 00:03:01,920
statement
 

117
00:03:01,920 --> 00:03:04,869
statement
so yesterday or last class jason talked

118
00:03:04,869 --> 00:03:04,879
so yesterday or last class jason talked
 

119
00:03:04,879 --> 00:03:05,750
so yesterday or last class jason talked
about

120
00:03:05,750 --> 00:03:05,760
about
 

121
00:03:05,760 --> 00:03:08,790
about
problems and defined what a problem was

122
00:03:08,790 --> 00:03:08,800
problems and defined what a problem was
 

123
00:03:08,800 --> 00:03:11,509
problems and defined what a problem was
versus algorithmic solutions to the

124
00:03:11,509 --> 00:03:11,519
versus algorithmic solutions to the
 

125
00:03:11,519 --> 00:03:12,869
versus algorithmic solutions to the
problem

126
00:03:12,869 --> 00:03:12,879
problem
 

127
00:03:12,879 --> 00:03:14,550
problem
and this is the analogous notion for

128
00:03:14,550 --> 00:03:14,560
and this is the analogous notion for
 

129
00:03:14,560 --> 00:03:15,910
and this is the analogous notion for
data structures where we want to

130
00:03:15,910 --> 00:03:15,920
data structures where we want to
 

131
00:03:15,920 --> 00:03:17,030
data structures where we want to
maintain a data

132
00:03:17,030 --> 00:03:17,040
maintain a data
 

133
00:03:17,040 --> 00:03:18,869
maintain a data
maintain some data according to various

134
00:03:18,869 --> 00:03:18,879
maintain some data according to various
 

135
00:03:18,879 --> 00:03:20,949
maintain some data according to various
operations

136
00:03:20,949 --> 00:03:20,959
operations
 

137
00:03:20,959 --> 00:03:22,949
operations
so the same problem can be solved by

138
00:03:22,949 --> 00:03:22,959
so the same problem can be solved by
 

139
00:03:22,959 --> 00:03:24,390
so the same problem can be solved by
many different data structures and we're

140
00:03:24,390 --> 00:03:24,400
many different data structures and we're
 

141
00:03:24,400 --> 00:03:25,350
many different data structures and we're
going to see that

142
00:03:25,350 --> 00:03:25,360
going to see that
 

143
00:03:25,360 --> 00:03:26,789
going to see that
and different data structures are going

144
00:03:26,789 --> 00:03:26,799
and different data structures are going
 

145
00:03:26,799 --> 00:03:28,149
and different data structures are going
to have different advantages they might

146
00:03:28,149 --> 00:03:28,159
to have different advantages they might
 

147
00:03:28,159 --> 00:03:29,750
to have different advantages they might
support some operations faster than

148
00:03:29,750 --> 00:03:29,760
support some operations faster than
 

149
00:03:29,760 --> 00:03:30,229
support some operations faster than
others

150
00:03:30,229 --> 00:03:30,239
others
 

151
00:03:30,239 --> 00:03:31,830
others
and depending on what you actually use

152
00:03:31,830 --> 00:03:31,840
and depending on what you actually use
 

153
00:03:31,840 --> 00:03:33,910
and depending on what you actually use
those data structures for you choose

154
00:03:33,910 --> 00:03:33,920
those data structures for you choose
 

155
00:03:33,920 --> 00:03:35,990
those data structures for you choose
the right data structure but you can

156
00:03:35,990 --> 00:03:36,000
the right data structure but you can
 

157
00:03:36,000 --> 00:03:38,390
the right data structure but you can
maintain the same interface

158
00:03:38,390 --> 00:03:38,400
maintain the same interface
 

159
00:03:38,400 --> 00:03:39,910
maintain the same interface
we're going to think about two data

160
00:03:39,910 --> 00:03:39,920
we're going to think about two data
 

161
00:03:39,920 --> 00:03:42,229
we're going to think about two data
structures one is called a set

162
00:03:42,229 --> 00:03:42,239
structures one is called a set
 

163
00:03:42,239 --> 00:03:45,589
structures one is called a set
and one is called a sequence

164
00:03:45,589 --> 00:03:45,599
and one is called a sequence
 

165
00:03:45,599 --> 00:03:47,430
and one is called a sequence
these are highly loaded terms set means

166
00:03:47,430 --> 00:03:47,440
these are highly loaded terms set means
 

167
00:03:47,440 --> 00:03:48,789
these are highly loaded terms set means
something to a mathematician it means

168
00:03:48,789 --> 00:03:48,799
something to a mathematician it means
 

169
00:03:48,799 --> 00:03:50,309
something to a mathematician it means
someone else something else to a python

170
00:03:50,309 --> 00:03:50,319
someone else something else to a python
 

171
00:03:50,319 --> 00:03:51,190
someone else something else to a python
programmer

172
00:03:51,190 --> 00:03:51,200
programmer
 

173
00:03:51,200 --> 00:03:53,589
programmer
sequence similarly i guess there's not a

174
00:03:53,589 --> 00:03:53,599
sequence similarly i guess there's not a
 

175
00:03:53,599 --> 00:03:55,270
sequence similarly i guess there's not a
python sequence data type

176
00:03:55,270 --> 00:03:55,280
python sequence data type
 

177
00:03:55,280 --> 00:03:59,910
python sequence data type
built in um the idea is we want to store

178
00:03:59,910 --> 00:03:59,920
built in um the idea is we want to store
 

179
00:03:59,920 --> 00:04:00,390
built in um the idea is we want to store
n

180
00:04:00,390 --> 00:04:00,400
n
 

181
00:04:00,400 --> 00:04:02,789
n
things the things will be fairly

182
00:04:02,789 --> 00:04:02,799
things the things will be fairly
 

183
00:04:02,799 --> 00:04:03,429
things the things will be fairly
arbitrary

184
00:04:03,429 --> 00:04:03,439
arbitrary
 

185
00:04:03,439 --> 00:04:06,949
arbitrary
think of them as integers or strings and

186
00:04:06,949 --> 00:04:06,959
think of them as integers or strings and
 

187
00:04:06,959 --> 00:04:09,030
think of them as integers or strings and
on the one hand we care about their

188
00:04:09,030 --> 00:04:09,040
on the one hand we care about their
 

189
00:04:09,040 --> 00:04:10,070
on the one hand we care about their
values

190
00:04:10,070 --> 00:04:10,080
values
 

191
00:04:10,080 --> 00:04:11,910
values
and maybe we want to maintain them in

192
00:04:11,910 --> 00:04:11,920
and maybe we want to maintain them in
 

193
00:04:11,920 --> 00:04:13,910
and maybe we want to maintain them in
sorted order and be able to search for a

194
00:04:13,910 --> 00:04:13,920
sorted order and be able to search for a
 

195
00:04:13,920 --> 00:04:14,869
sorted order and be able to search for a
given value

196
00:04:14,869 --> 00:04:14,879
given value
 

197
00:04:14,879 --> 00:04:17,110
given value
which we'll call a key and on the other

198
00:04:17,110 --> 00:04:17,120
which we'll call a key and on the other
 

199
00:04:17,120 --> 00:04:19,749
which we'll call a key and on the other
hand we care about representing

200
00:04:19,749 --> 00:04:19,759
hand we care about representing
 

201
00:04:19,759 --> 00:04:22,870
hand we care about representing
a particular sequence that we care about

202
00:04:22,870 --> 00:04:22,880
a particular sequence that we care about
 

203
00:04:22,880 --> 00:04:25,590
a particular sequence that we care about
maybe we want to represent the numbers 5

204
00:04:25,590 --> 00:04:25,600
maybe we want to represent the numbers 5
 

205
00:04:25,600 --> 00:04:26,469
maybe we want to represent the numbers 5
2

206
00:04:26,469 --> 00:04:26,479
2
 

207
00:04:26,479 --> 00:04:29,990
2
9 7 in that order and store that

208
00:04:29,990 --> 00:04:30,000
9 7 in that order and store that
 

209
00:04:30,000 --> 00:04:32,390
9 7 in that order and store that
in python you could store that in a list

210
00:04:32,390 --> 00:04:32,400
in python you could store that in a list
 

211
00:04:32,400 --> 00:04:33,350
in python you could store that in a list
for example

212
00:04:33,350 --> 00:04:33,360
for example
 

213
00:04:33,360 --> 00:04:35,030
for example
and it will keep track of that order and

214
00:04:35,030 --> 00:04:35,040
and it will keep track of that order and
 

215
00:04:35,040 --> 00:04:36,950
and it will keep track of that order and
this is the first item the second item

216
00:04:36,950 --> 00:04:36,960
this is the first item the second item
 

217
00:04:36,960 --> 00:04:38,870
this is the first item the second item
the last item

218
00:04:38,870 --> 00:04:38,880
the last item
 

219
00:04:38,880 --> 00:04:41,749
the last item
today we're going to be focusing on this

220
00:04:41,749 --> 00:04:41,759
today we're going to be focusing on this
 

221
00:04:41,759 --> 00:04:43,270
today we're going to be focusing on this
sequence data structure although at the

222
00:04:43,270 --> 00:04:43,280
sequence data structure although at the
 

223
00:04:43,280 --> 00:04:44,629
sequence data structure although at the
end i'll mention

224
00:04:44,629 --> 00:04:44,639
end i'll mention
 

225
00:04:44,639 --> 00:04:46,550
end i'll mention
the interface for sets but we're going

226
00:04:46,550 --> 00:04:46,560
the interface for sets but we're going
 

227
00:04:46,560 --> 00:04:48,710
the interface for sets but we're going
to be actually solving sequences today

228
00:04:48,710 --> 00:04:48,720
to be actually solving sequences today
 

229
00:04:48,720 --> 00:04:50,310
to be actually solving sequences today
and in the next several lectures we'll

230
00:04:50,310 --> 00:04:50,320
and in the next several lectures we'll
 

231
00:04:50,320 --> 00:04:52,070
and in the next several lectures we'll
be bouncing back and forth between these

232
00:04:52,070 --> 00:04:52,080
be bouncing back and forth between these
 

233
00:04:52,080 --> 00:04:54,310
be bouncing back and forth between these
they're closely related

234
00:04:54,310 --> 00:04:54,320
they're closely related
 

235
00:04:54,320 --> 00:04:57,350
they're closely related
pretty abstract at the moment on the

236
00:04:57,350 --> 00:04:57,360
pretty abstract at the moment on the
 

237
00:04:57,360 --> 00:04:59,510
pretty abstract at the moment on the
other hand we're gonna have two

238
00:04:59,510 --> 00:04:59,520
other hand we're gonna have two
 

239
00:04:59,520 --> 00:05:03,110
other hand we're gonna have two
main

240
00:05:03,110 --> 00:05:03,120

 

241
00:05:03,120 --> 00:05:06,150

let's call them data structure

242
00:05:06,150 --> 00:05:06,160
let's call them data structure
 

243
00:05:06,160 --> 00:05:13,830
let's call them data structure
tools or approaches

244
00:05:13,830 --> 00:05:13,840

 

245
00:05:13,840 --> 00:05:18,390

one is arrays

246
00:05:18,390 --> 00:05:18,400
one is arrays
 

247
00:05:18,400 --> 00:05:21,590
one is arrays
and the other is pointers pointer based

248
00:05:21,590 --> 00:05:21,600
and the other is pointers pointer based
 

249
00:05:21,600 --> 00:05:23,430
and the other is pointers pointer based
or linked

250
00:05:23,430 --> 00:05:23,440
or linked
 

251
00:05:23,440 --> 00:05:26,629
or linked
data structures you may have seen these

252
00:05:26,629 --> 00:05:26,639
data structures you may have seen these
 

253
00:05:26,639 --> 00:05:28,150
data structures you may have seen these
they're used a lot in programming of

254
00:05:28,150 --> 00:05:28,160
they're used a lot in programming of
 

255
00:05:28,160 --> 00:05:30,550
they're used a lot in programming of
course but we're going to see both of

256
00:05:30,550 --> 00:05:30,560
course but we're going to see both of
 

257
00:05:30,560 --> 00:05:32,150
course but we're going to see both of
these today i'll come back to this

258
00:05:32,150 --> 00:05:32,160
these today i'll come back to this
 

259
00:05:32,160 --> 00:05:35,270
these today i'll come back to this
sort of highlight in a moment let's jump

260
00:05:35,270 --> 00:05:35,280
sort of highlight in a moment let's jump
 

261
00:05:35,280 --> 00:05:37,670
sort of highlight in a moment let's jump
into the sequence interface

262
00:05:37,670 --> 00:05:37,680
into the sequence interface
 

263
00:05:37,680 --> 00:05:41,510
into the sequence interface
which i conveniently have part of here

264
00:05:41,510 --> 00:05:41,520
which i conveniently have part of here
 

265
00:05:41,520 --> 00:05:43,029
which i conveniently have part of here
there's a few different levels of

266
00:05:43,029 --> 00:05:43,039
there's a few different levels of
 

267
00:05:43,039 --> 00:05:44,710
there's a few different levels of
sequences that we might care about i'm

268
00:05:44,710 --> 00:05:44,720
sequences that we might care about i'm
 

269
00:05:44,720 --> 00:05:46,550
sequences that we might care about i'm
going to start with the static

270
00:05:46,550 --> 00:05:46,560
going to start with the static
 

271
00:05:46,560 --> 00:05:50,629
going to start with the static
sequence interface this is where the

272
00:05:50,629 --> 00:05:50,639
sequence interface this is where the
 

273
00:05:50,639 --> 00:05:54,070
sequence interface this is where the
item the number of items doesn't change

274
00:05:54,070 --> 00:05:54,080
item the number of items doesn't change
 

275
00:05:54,080 --> 00:05:56,710
item the number of items doesn't change
uh though the actual items might so here

276
00:05:56,710 --> 00:05:56,720
uh though the actual items might so here
 

277
00:05:56,720 --> 00:05:57,830
uh though the actual items might so here
we have n

278
00:05:57,830 --> 00:05:57,840
we have n
 

279
00:05:57,840 --> 00:06:00,550
we have n
items i'm going to label them x 0 to x n

280
00:06:00,550 --> 00:06:00,560
items i'm going to label them x 0 to x n
 

281
00:06:00,560 --> 00:06:02,230
items i'm going to label them x 0 to x n
minus 1 as in python

282
00:06:02,230 --> 00:06:02,240
minus 1 as in python
 

283
00:06:02,240 --> 00:06:04,390
minus 1 as in python
so the number of items is n and the

284
00:06:04,390 --> 00:06:04,400
so the number of items is n and the
 

285
00:06:04,400 --> 00:06:06,390
so the number of items is n and the
operations i want to support are build

286
00:06:06,390 --> 00:06:06,400
operations i want to support are build
 

287
00:06:06,400 --> 00:06:10,629
operations i want to support are build
length iteration get and set

288
00:06:10,629 --> 00:06:10,639
length iteration get and set
 

289
00:06:10,639 --> 00:06:13,670
length iteration get and set
so what do these do build is how you get

290
00:06:13,670 --> 00:06:13,680
so what do these do build is how you get
 

291
00:06:13,680 --> 00:06:14,790
so what do these do build is how you get
started to build

292
00:06:14,790 --> 00:06:14,800
started to build
 

293
00:06:14,800 --> 00:06:17,029
started to build
a data structure in this interface you

294
00:06:17,029 --> 00:06:17,039
a data structure in this interface you
 

295
00:06:17,039 --> 00:06:18,390
a data structure in this interface you
call build of

296
00:06:18,390 --> 00:06:18,400
call build of
 

297
00:06:18,400 --> 00:06:21,590
call build of
x exactly how you specify x isn't too

298
00:06:21,590 --> 00:06:21,600
x exactly how you specify x isn't too
 

299
00:06:21,600 --> 00:06:23,110
x exactly how you specify x isn't too
important but the idea is i give you

300
00:06:23,110 --> 00:06:23,120
important but the idea is i give you
 

301
00:06:23,120 --> 00:06:24,870
important but the idea is i give you
some items in some order

302
00:06:24,870 --> 00:06:24,880
some items in some order
 

303
00:06:24,880 --> 00:06:27,029
some items in some order
in python this would be an iterable i'm

304
00:06:27,029 --> 00:06:27,039
in python this would be an iterable i'm
 

305
00:06:27,039 --> 00:06:29,430
in python this would be an iterable i'm
going to want to also know its length

306
00:06:29,430 --> 00:06:29,440
going to want to also know its length
 

307
00:06:29,440 --> 00:06:31,270
going to want to also know its length
and i want to make a new data structure

308
00:06:31,270 --> 00:06:31,280
and i want to make a new data structure
 

309
00:06:31,280 --> 00:06:33,670
and i want to make a new data structure
of size n a new static sequence of size

310
00:06:33,670 --> 00:06:33,680
of size n a new static sequence of size
 

311
00:06:33,680 --> 00:06:33,990
of size n a new static sequence of size
n

312
00:06:33,990 --> 00:06:34,000
n
 

313
00:06:34,000 --> 00:06:36,150
n
that has those items in that order so

314
00:06:36,150 --> 00:06:36,160
that has those items in that order so
 

315
00:06:36,160 --> 00:06:38,710
that has those items in that order so
that's how you build one of these

316
00:06:38,710 --> 00:06:38,720
that's how you build one of these
 

317
00:06:38,720 --> 00:06:40,309
that's how you build one of these
because somehow we have to specify n to

318
00:06:40,309 --> 00:06:40,319
because somehow we have to specify n to
 

319
00:06:40,319 --> 00:06:41,909
because somehow we have to specify n to
this data structure because n is not

320
00:06:41,909 --> 00:06:41,919
this data structure because n is not
 

321
00:06:41,919 --> 00:06:42,469
this data structure because n is not
going to

322
00:06:42,469 --> 00:06:42,479
going to
 

323
00:06:42,479 --> 00:06:44,550
going to
be allowed to change i'm going to give

324
00:06:44,550 --> 00:06:44,560
be allowed to change i'm going to give
 

325
00:06:44,560 --> 00:06:46,070
be allowed to change i'm going to give
you a length

326
00:06:46,070 --> 00:06:46,080
you a length
 

327
00:06:46,080 --> 00:06:49,189
you a length
method um these are

328
00:06:49,189 --> 00:06:49,199
method um these are
 

329
00:06:49,199 --> 00:06:51,909
method um these are
methods are the object-oriented way of

330
00:06:51,909 --> 00:06:51,919
methods are the object-oriented way of
 

331
00:06:51,919 --> 00:06:53,749
methods are the object-oriented way of
thinking of operations

332
00:06:53,749 --> 00:06:53,759
thinking of operations
 

333
00:06:53,759 --> 00:06:57,510
thinking of operations
that your interface supports

334
00:06:57,510 --> 00:06:57,520
that your interface supports
 

335
00:06:57,520 --> 00:06:58,950
that your interface supports
so length will just return this fixed

336
00:06:58,950 --> 00:06:58,960
so length will just return this fixed
 

337
00:06:58,960 --> 00:07:01,270
so length will just return this fixed
value and it or sequence this is the

338
00:07:01,270 --> 00:07:01,280
value and it or sequence this is the
 

339
00:07:01,280 --> 00:07:02,790
value and it or sequence this is the
sense in which we want to maintain the

340
00:07:02,790 --> 00:07:02,800
sense in which we want to maintain the
 

341
00:07:02,800 --> 00:07:05,029
sense in which we want to maintain the
order i want to be able to output x0

342
00:07:05,029 --> 00:07:05,039
order i want to be able to output x0
 

343
00:07:05,039 --> 00:07:07,589
order i want to be able to output x0
through xn minus 1 in the sequence order

344
00:07:07,589 --> 00:07:07,599
through xn minus 1 in the sequence order
 

345
00:07:07,599 --> 00:07:09,189
through xn minus 1 in the sequence order
in that specified order that they were

346
00:07:09,189 --> 00:07:09,199
in that specified order that they were
 

347
00:07:09,199 --> 00:07:09,990
in that specified order that they were
built in

348
00:07:09,990 --> 00:07:10,000
built in
 

349
00:07:10,000 --> 00:07:13,670
built in
or that it was changed to so uh

350
00:07:13,670 --> 00:07:13,680
or that it was changed to so uh
 

351
00:07:13,680 --> 00:07:16,070
or that it was changed to so uh
this is going to iterate through all the

352
00:07:16,070 --> 00:07:16,080
this is going to iterate through all the
 

353
00:07:16,080 --> 00:07:17,350
this is going to iterate through all the
items

354
00:07:17,350 --> 00:07:17,360
items
 

355
00:07:17,360 --> 00:07:18,710
items
so it's going to take at least linear

356
00:07:18,710 --> 00:07:18,720
so it's going to take at least linear
 

357
00:07:18,720 --> 00:07:21,110
so it's going to take at least linear
time to output that but more interesting

358
00:07:21,110 --> 00:07:21,120
time to output that but more interesting
 

359
00:07:21,120 --> 00:07:21,990
time to output that but more interesting
is we can

360
00:07:21,990 --> 00:07:22,000
is we can
 

361
00:07:22,000 --> 00:07:23,830
is we can
dynamically access anywhere in the

362
00:07:23,830 --> 00:07:23,840
dynamically access anywhere in the
 

363
00:07:23,840 --> 00:07:25,589
dynamically access anywhere in the
middle of the sequence

364
00:07:25,589 --> 00:07:25,599
middle of the sequence
 

365
00:07:25,599 --> 00:07:28,550
middle of the sequence
we can get the item x i given the value

366
00:07:28,550 --> 00:07:28,560
we can get the item x i given the value
 

367
00:07:28,560 --> 00:07:29,270
we can get the item x i given the value
i

368
00:07:29,270 --> 00:07:29,280
i
 

369
00:07:29,280 --> 00:07:32,230
i
and we can change x i to a given new

370
00:07:32,230 --> 00:07:32,240
and we can change x i to a given new
 

371
00:07:32,240 --> 00:07:33,909
and we can change x i to a given new
item

372
00:07:33,909 --> 00:07:33,919
item
 

373
00:07:33,919 --> 00:07:36,870
item
okay so that's called get at and set at

374
00:07:36,870 --> 00:07:36,880
okay so that's called get at and set at
 

375
00:07:36,880 --> 00:07:37,990
okay so that's called get at and set at
pretty straightforward

376
00:07:37,990 --> 00:07:38,000
pretty straightforward
 

377
00:07:38,000 --> 00:07:41,990
pretty straightforward
this should remind you very closely of

378
00:07:41,990 --> 00:07:42,000
this should remind you very closely of
 

379
00:07:42,000 --> 00:07:44,230
this should remind you very closely of
something a data structure so this is an

380
00:07:44,230 --> 00:07:44,240
something a data structure so this is an
 

381
00:07:44,240 --> 00:07:45,270
something a data structure so this is an
interface this is

382
00:07:45,270 --> 00:07:45,280
interface this is
 

383
00:07:45,280 --> 00:07:47,350
interface this is
something i might want to solve but what

384
00:07:47,350 --> 00:07:47,360
something i might want to solve but what
 

385
00:07:47,360 --> 00:07:48,790
something i might want to solve but what
is the obvious data structure that

386
00:07:48,790 --> 00:07:48,800
is the obvious data structure that
 

387
00:07:48,800 --> 00:07:49,430
is the obvious data structure that
solves

388
00:07:49,430 --> 00:07:49,440
solves
 

389
00:07:49,440 --> 00:07:53,110
solves
this problem yeah a list in python it's

390
00:07:53,110 --> 00:07:53,120
this problem yeah a list in python it's
 

391
00:07:53,120 --> 00:07:54,390
this problem yeah a list in python it's
called the list

392
00:07:54,390 --> 00:07:54,400
called the list
 

393
00:07:54,400 --> 00:07:57,589
called the list
i prefer to call it an array but to each

394
00:07:57,589 --> 00:07:57,599
i prefer to call it an array but to each
 

395
00:07:57,599 --> 00:07:58,309
i prefer to call it an array but to each
their own

396
00:07:58,309 --> 00:07:58,319
their own
 

397
00:07:58,319 --> 00:07:59,830
their own
we're gonna use this this could mean

398
00:07:59,830 --> 00:07:59,840
we're gonna use this this could mean
 

399
00:07:59,840 --> 00:08:01,670
we're gonna use this this could mean
many things um

400
00:08:01,670 --> 00:08:01,680
many things um
 

401
00:08:01,680 --> 00:08:07,670
many things um
but the uh solution

402
00:08:07,670 --> 00:08:07,680

 

403
00:08:07,680 --> 00:08:10,710

to this interface problem the

404
00:08:10,710 --> 00:08:10,720
to this interface problem the
 

405
00:08:10,720 --> 00:08:16,390
to this interface problem the
natural solution

406
00:08:16,390 --> 00:08:16,400

 

407
00:08:16,400 --> 00:08:23,029

is as what i'll call a static array

408
00:08:23,029 --> 00:08:23,039

 

409
00:08:23,039 --> 00:08:26,790

jason mentioned these in

410
00:08:26,790 --> 00:08:26,800
jason mentioned these in
 

411
00:08:26,800 --> 00:08:29,110
jason mentioned these in
uh in lecture one uh it's a little

412
00:08:29,110 --> 00:08:29,120
uh in lecture one uh it's a little
 

413
00:08:29,120 --> 00:08:30,469
uh in lecture one uh it's a little
tricky because there are no static

414
00:08:30,469 --> 00:08:30,479
tricky because there are no static
 

415
00:08:30,479 --> 00:08:32,149
tricky because there are no static
arrays in python there are only dynamic

416
00:08:32,149 --> 00:08:32,159
arrays in python there are only dynamic
 

417
00:08:32,159 --> 00:08:33,990
arrays in python there are only dynamic
arrays which is something we will get to

418
00:08:33,990 --> 00:08:34,000
arrays which is something we will get to
 

419
00:08:34,000 --> 00:08:35,909
arrays which is something we will get to
but uh i want to talk about what is a

420
00:08:35,909 --> 00:08:35,919
but uh i want to talk about what is a
 

421
00:08:35,919 --> 00:08:37,190
but uh i want to talk about what is a
static array

422
00:08:37,190 --> 00:08:37,200
static array
 

423
00:08:37,200 --> 00:08:40,230
static array
really and this relates to

424
00:08:40,230 --> 00:08:40,240
really and this relates to
 

425
00:08:40,240 --> 00:08:43,670
really and this relates to
our notion of our model of computation

426
00:08:43,670 --> 00:08:43,680
our notion of our model of computation
 

427
00:08:43,680 --> 00:08:45,670
our notion of our model of computation
which jason also talked about

428
00:08:45,670 --> 00:08:45,680
which jason also talked about
 

429
00:08:45,680 --> 00:08:52,829
which jason also talked about
which we call the word ram

430
00:08:52,829 --> 00:08:52,839

 

431
00:08:52,839 --> 00:08:58,150

remember

432
00:08:58,150 --> 00:08:58,160

 

433
00:08:58,160 --> 00:09:01,190

so the idea in word ram is that your

434
00:09:01,190 --> 00:09:01,200
so the idea in word ram is that your
 

435
00:09:01,200 --> 00:09:03,190
so the idea in word ram is that your
memory

436
00:09:03,190 --> 00:09:03,200
memory
 

437
00:09:03,200 --> 00:09:06,470
memory
is an array

438
00:09:06,470 --> 00:09:06,480
is an array
 

439
00:09:06,480 --> 00:09:09,190
is an array
of w bit words this is a bit circular

440
00:09:09,190 --> 00:09:09,200
of w bit words this is a bit circular
 

441
00:09:09,200 --> 00:09:10,070
of w bit words this is a bit circular
i'm going to define

442
00:09:10,070 --> 00:09:10,080
i'm going to define
 

443
00:09:10,080 --> 00:09:11,590
i'm going to define
an array in terms of the word ram which

444
00:09:11,590 --> 00:09:11,600
an array in terms of the word ram which
 

445
00:09:11,600 --> 00:09:15,350
an array in terms of the word ram which
is defined in terms of arrays but

446
00:09:15,350 --> 00:09:15,360

 

447
00:09:15,360 --> 00:09:19,590

i think you know the idea so we have

448
00:09:19,590 --> 00:09:19,600
i think you know the idea so we have
 

449
00:09:19,600 --> 00:09:22,070
i think you know the idea so we have
a big memory which goes off to infinity

450
00:09:22,070 --> 00:09:22,080
a big memory which goes off to infinity
 

451
00:09:22,080 --> 00:09:23,030
a big memory which goes off to infinity
maybe

452
00:09:23,030 --> 00:09:23,040
maybe
 

453
00:09:23,040 --> 00:09:26,310
maybe
it's divided into words

454
00:09:26,310 --> 00:09:26,320
it's divided into words
 

455
00:09:26,320 --> 00:09:29,829
it's divided into words
each word here is w bits long

456
00:09:29,829 --> 00:09:29,839
each word here is w bits long
 

457
00:09:29,839 --> 00:09:32,310
each word here is w bits long
this is word zero word one word two and

458
00:09:32,310 --> 00:09:32,320
this is word zero word one word two and
 

459
00:09:32,320 --> 00:09:32,949
this is word zero word one word two and
you can

460
00:09:32,949 --> 00:09:32,959
you can
 

461
00:09:32,959 --> 00:09:35,990
you can
access this array randomly random access

462
00:09:35,990 --> 00:09:36,000
access this array randomly random access
 

463
00:09:36,000 --> 00:09:38,870
access this array randomly random access
memory so i can give you the number five

464
00:09:38,870 --> 00:09:38,880
memory so i can give you the number five
 

465
00:09:38,880 --> 00:09:40,710
memory so i can give you the number five
and get zero one two three

466
00:09:40,710 --> 00:09:40,720
and get zero one two three
 

467
00:09:40,720 --> 00:09:44,310
and get zero one two three
four five the fifth word in this

468
00:09:44,310 --> 00:09:44,320
four five the fifth word in this
 

469
00:09:44,320 --> 00:09:48,630
four five the fifth word in this
round that's how actual memories work

470
00:09:48,630 --> 00:09:48,640
round that's how actual memories work
 

471
00:09:48,640 --> 00:09:51,350
round that's how actual memories work
uh you can access any of them equally

472
00:09:51,350 --> 00:09:51,360
uh you can access any of them equally
 

473
00:09:51,360 --> 00:09:53,430
uh you can access any of them equally
quickly

474
00:09:53,430 --> 00:09:53,440
quickly
 

475
00:09:53,440 --> 00:09:57,190
quickly
okay so that's memory

476
00:09:57,190 --> 00:09:57,200
okay so that's memory
 

477
00:09:57,200 --> 00:10:00,150
okay so that's memory
and so what we want to do is when we say

478
00:10:00,150 --> 00:10:00,160
and so what we want to do is when we say
 

479
00:10:00,160 --> 00:10:03,110
and so what we want to do is when we say
an array

480
00:10:03,110 --> 00:10:03,120

 

481
00:10:03,120 --> 00:10:09,509

we want this to be a consecutive

482
00:10:09,509 --> 00:10:09,519

 

483
00:10:09,519 --> 00:10:16,310

chunk of memory

484
00:10:16,310 --> 00:10:16,320

 

485
00:10:16,320 --> 00:10:21,750

let me get a color

486
00:10:21,750 --> 00:10:21,760

 

487
00:10:21,760 --> 00:10:23,110

so let's say i have an array of size

488
00:10:23,110 --> 00:10:23,120
so let's say i have an array of size
 

489
00:10:23,120 --> 00:10:25,750
so let's say i have an array of size
four and it lives

490
00:10:25,750 --> 00:10:25,760
four and it lives
 

491
00:10:25,760 --> 00:10:29,590
four and it lives
here

492
00:10:29,590 --> 00:10:29,600

 

493
00:10:29,600 --> 00:10:32,230

jason can't spell but i can't count so i

494
00:10:32,230 --> 00:10:32,240
jason can't spell but i can't count so i
 

495
00:10:32,240 --> 00:10:34,310
jason can't spell but i can't count so i
think that's four

496
00:10:34,310 --> 00:10:34,320
think that's four
 

497
00:10:34,320 --> 00:10:38,310
think that's four
we've got uh so the array starts here

498
00:10:38,310 --> 00:10:38,320
we've got uh so the array starts here
 

499
00:10:38,320 --> 00:10:42,710
we've got uh so the array starts here
and it ends over here it's of size four

500
00:10:42,710 --> 00:10:42,720
and it ends over here it's of size four
 

501
00:10:42,720 --> 00:10:45,829
and it ends over here it's of size four
and it's consecutive which means if i

502
00:10:45,829 --> 00:10:45,839
and it's consecutive which means if i
 

503
00:10:45,839 --> 00:10:46,550
and it's consecutive which means if i
want to

504
00:10:46,550 --> 00:10:46,560
want to
 

505
00:10:46,560 --> 00:10:49,590
want to
access um

506
00:10:49,590 --> 00:10:49,600
access um
 

507
00:10:49,600 --> 00:10:52,870
access um
the array at position

508
00:10:52,870 --> 00:10:52,880
the array at position
 

509
00:10:52,880 --> 00:10:56,150
the array at position
at index i then

510
00:10:56,150 --> 00:10:56,160
at index i then
 

511
00:10:56,160 --> 00:10:58,630
at index i then
this is the same thing as accessing my

512
00:10:58,630 --> 00:10:58,640
this is the same thing as accessing my
 

513
00:10:58,640 --> 00:11:01,110
this is the same thing as accessing my
memory array

514
00:11:01,110 --> 00:11:01,120
memory array
 

515
00:11:01,120 --> 00:11:04,949
memory array
at position wherever the array starts

516
00:11:04,949 --> 00:11:04,959
at position wherever the array starts
 

517
00:11:04,959 --> 00:11:10,310
at position wherever the array starts
which i'll call the address of the array

518
00:11:10,310 --> 00:11:10,320

 

519
00:11:10,320 --> 00:11:13,430

in python this is id of array

520
00:11:13,430 --> 00:11:13,440
in python this is id of array
 

521
00:11:13,440 --> 00:11:18,069
in python this is id of array
plus i okay this is just simple offset

522
00:11:18,069 --> 00:11:18,079
plus i okay this is just simple offset
 

523
00:11:18,079 --> 00:11:19,269
plus i okay this is just simple offset
arithmetic

524
00:11:19,269 --> 00:11:19,279
arithmetic
 

525
00:11:19,279 --> 00:11:21,030
arithmetic
if i want to know the zeroth item of the

526
00:11:21,030 --> 00:11:21,040
if i want to know the zeroth item of the
 

527
00:11:21,040 --> 00:11:22,870
if i want to know the zeroth item of the
array it's right here where it starts

528
00:11:22,870 --> 00:11:22,880
array it's right here where it starts
 

529
00:11:22,880 --> 00:11:24,630
array it's right here where it starts
the first item is one after that the

530
00:11:24,630 --> 00:11:24,640
the first item is one after that the
 

531
00:11:24,640 --> 00:11:26,310
the first item is one after that the
second item is one after that

532
00:11:26,310 --> 00:11:26,320
second item is one after that
 

533
00:11:26,320 --> 00:11:28,630
second item is one after that
so as long as i store my array

534
00:11:28,630 --> 00:11:28,640
so as long as i store my array
 

535
00:11:28,640 --> 00:11:30,150
so as long as i store my array
consecutively in memory

536
00:11:30,150 --> 00:11:30,160
consecutively in memory
 

537
00:11:30,160 --> 00:11:33,590
consecutively in memory
i can access the array in constant time

538
00:11:33,590 --> 00:11:33,600
i can access the array in constant time
 

539
00:11:33,600 --> 00:11:34,389
i can access the array in constant time
i can do get

540
00:11:34,389 --> 00:11:34,399
i can do get
 

541
00:11:34,399 --> 00:11:36,949
i can do get
at and set at as quickly as i can

542
00:11:36,949 --> 00:11:36,959
at and set at as quickly as i can
 

543
00:11:36,959 --> 00:11:38,630
at and set at as quickly as i can
randomly access the memory

544
00:11:38,630 --> 00:11:38,640
randomly access the memory
 

545
00:11:38,640 --> 00:11:41,030
randomly access the memory
and get a value or set a value which

546
00:11:41,030 --> 00:11:41,040
and get a value or set a value which
 

547
00:11:41,040 --> 00:11:41,990
and get a value or set a value which
we're assuming

548
00:11:41,990 --> 00:11:42,000
we're assuming
 

549
00:11:42,000 --> 00:11:44,270
we're assuming
is constant time so

550
00:11:44,270 --> 00:11:44,280
is constant time so
 

551
00:11:44,280 --> 00:11:51,269
is constant time so
[Music]

552
00:11:51,269 --> 00:11:51,279

 

553
00:11:51,279 --> 00:11:57,430

array access is constant time

554
00:11:57,430 --> 00:11:57,440
array access is constant time
 

555
00:11:57,440 --> 00:11:59,990
array access is constant time
okay this is what allows a static array

556
00:11:59,990 --> 00:12:00,000
okay this is what allows a static array
 

557
00:12:00,000 --> 00:12:01,829
okay this is what allows a static array
to actually solve this problem

558
00:12:01,829 --> 00:12:01,839
to actually solve this problem
 

559
00:12:01,839 --> 00:12:05,910
to actually solve this problem
in constant time per

560
00:12:05,910 --> 00:12:05,920

 

561
00:12:05,920 --> 00:12:09,430

get at and set at operation so this may

562
00:12:09,430 --> 00:12:09,440
get at and set at operation so this may
 

563
00:12:09,440 --> 00:12:11,590
get at and set at operation so this may
seem simple but we're really going to

564
00:12:11,590 --> 00:12:11,600
seem simple but we're really going to
 

565
00:12:11,600 --> 00:12:13,509
seem simple but we're really going to
need this model and really rely on this

566
00:12:13,509 --> 00:12:13,519
need this model and really rely on this
 

567
00:12:13,519 --> 00:12:14,150
need this model and really rely on this
model

568
00:12:14,150 --> 00:12:14,160
model
 

569
00:12:14,160 --> 00:12:15,430
model
increasingly as we get to more

570
00:12:15,430 --> 00:12:15,440
increasingly as we get to more
 

571
00:12:15,440 --> 00:12:17,269
increasingly as we get to more
interesting data structures this is the

572
00:12:17,269 --> 00:12:17,279
interesting data structures this is the
 

573
00:12:17,279 --> 00:12:20,230
interesting data structures this is the
first time we're actually needing it

574
00:12:20,230 --> 00:12:20,240
first time we're actually needing it
 

575
00:12:20,240 --> 00:12:23,030
first time we're actually needing it
uh let's see length is also constant

576
00:12:23,030 --> 00:12:23,040
uh let's see length is also constant
 

577
00:12:23,040 --> 00:12:23,509
uh let's see length is also constant
time

578
00:12:23,509 --> 00:12:23,519
time
 

579
00:12:23,519 --> 00:12:26,310
time
we're just going to store that number n

580
00:12:26,310 --> 00:12:26,320
we're just going to store that number n
 

581
00:12:26,320 --> 00:12:29,190
we're just going to store that number n
along with its address

582
00:12:29,190 --> 00:12:29,200
along with its address
 

583
00:12:29,200 --> 00:12:32,069
along with its address
and build is going to take linear time

584
00:12:32,069 --> 00:12:32,079
and build is going to take linear time
 

585
00:12:32,079 --> 00:12:33,910
and build is going to take linear time
iteration will take

586
00:12:33,910 --> 00:12:33,920
iteration will take
 

587
00:12:33,920 --> 00:12:42,790
iteration will take
linear time

588
00:12:42,790 --> 00:12:42,800

 

589
00:12:42,800 --> 00:12:46,550

okay pretty straightforward i guess one

590
00:12:46,550 --> 00:12:46,560
okay pretty straightforward i guess one
 

591
00:12:46,560 --> 00:12:48,790
okay pretty straightforward i guess one
thing here when defining build i need to

592
00:12:48,790 --> 00:12:48,800
thing here when defining build i need to
 

593
00:12:48,800 --> 00:12:50,230
thing here when defining build i need to
introduce a little bit more of our model

594
00:12:50,230 --> 00:12:50,240
introduce a little bit more of our model
 

595
00:12:50,240 --> 00:12:51,509
introduce a little bit more of our model
of computation which is

596
00:12:51,509 --> 00:12:51,519
of computation which is
 

597
00:12:51,519 --> 00:12:52,949
of computation which is
how do you create an array in the

598
00:12:52,949 --> 00:12:52,959
how do you create an array in the
 

599
00:12:52,959 --> 00:12:54,870
how do you create an array in the
beginning

600
00:12:54,870 --> 00:12:54,880
beginning
 

601
00:12:54,880 --> 00:12:57,269
beginning
i claim i can do it in linear time and

602
00:12:57,269 --> 00:12:57,279
i claim i can do it in linear time and
 

603
00:12:57,279 --> 00:12:58,870
i claim i can do it in linear time and
that's just part of the model

604
00:12:58,870 --> 00:12:58,880
that's just part of the model
 

605
00:12:58,880 --> 00:13:04,829
that's just part of the model
so this is called the memory allocation

606
00:13:04,829 --> 00:13:04,839

 

607
00:13:04,839 --> 00:13:09,269

model

608
00:13:09,269 --> 00:13:09,279

 

609
00:13:09,279 --> 00:13:10,949

there are a few possible choices here

610
00:13:10,949 --> 00:13:10,959
there are a few possible choices here
 

611
00:13:10,959 --> 00:13:12,470
there are a few possible choices here
but the cleanest one is just to assume

612
00:13:12,470 --> 00:13:12,480
but the cleanest one is just to assume
 

613
00:13:12,480 --> 00:13:13,509
but the cleanest one is just to assume
that you can

614
00:13:13,509 --> 00:13:13,519
that you can
 

615
00:13:13,519 --> 00:13:16,790
that you can
allocate an array

616
00:13:16,790 --> 00:13:16,800
allocate an array
 

617
00:13:16,800 --> 00:13:22,550
allocate an array
of size n

618
00:13:22,550 --> 00:13:22,560

 

619
00:13:22,560 --> 00:13:25,590

in theta n time

620
00:13:25,590 --> 00:13:25,600
in theta n time
 

621
00:13:25,600 --> 00:13:27,190
in theta n time
so it takes linear time to make an array

622
00:13:27,190 --> 00:13:27,200
so it takes linear time to make an array
 

623
00:13:27,200 --> 00:13:29,110
so it takes linear time to make an array
of size n

624
00:13:29,110 --> 00:13:29,120
of size n
 

625
00:13:29,120 --> 00:13:30,710
of size n
you could imagine this being constant it

626
00:13:30,710 --> 00:13:30,720
you could imagine this being constant it
 

627
00:13:30,720 --> 00:13:32,790
you could imagine this being constant it
doesn't really matter much but it does

628
00:13:32,790 --> 00:13:32,800
doesn't really matter much but it does
 

629
00:13:32,800 --> 00:13:35,030
doesn't really matter much but it does
take work and in particular if you just

630
00:13:35,030 --> 00:13:35,040
take work and in particular if you just
 

631
00:13:35,040 --> 00:13:36,550
take work and in particular if you just
allocate some chunk of memory you have

632
00:13:36,550 --> 00:13:36,560
allocate some chunk of memory you have
 

633
00:13:36,560 --> 00:13:38,069
allocate some chunk of memory you have
no idea whether it's initialized so

634
00:13:38,069 --> 00:13:38,079
no idea whether it's initialized so
 

635
00:13:38,079 --> 00:13:39,910
no idea whether it's initialized so
initializing that array to zeros

636
00:13:39,910 --> 00:13:39,920
initializing that array to zeros
 

637
00:13:39,920 --> 00:13:41,670
initializing that array to zeros
will cost linear time it won't really

638
00:13:41,670 --> 00:13:41,680
will cost linear time it won't really
 

639
00:13:41,680 --> 00:13:43,670
will cost linear time it won't really
matter constant versus linear but a nice

640
00:13:43,670 --> 00:13:43,680
matter constant versus linear but a nice
 

641
00:13:43,680 --> 00:13:45,189
matter constant versus linear but a nice
side effect of this model

642
00:13:45,189 --> 00:13:45,199
side effect of this model
 

643
00:13:45,199 --> 00:13:49,670
side effect of this model
is that space if you're just allocating

644
00:13:49,670 --> 00:13:49,680
is that space if you're just allocating
 

645
00:13:49,680 --> 00:13:51,750
is that space if you're just allocating
arrays the amount of space you use is at

646
00:13:51,750 --> 00:13:51,760
arrays the amount of space you use is at
 

647
00:13:51,760 --> 00:13:53,430
arrays the amount of space you use is at
most the amount of time you use

648
00:13:53,430 --> 00:13:53,440
most the amount of time you use
 

649
00:13:53,440 --> 00:13:57,189
most the amount of time you use
or i guess big o of that

650
00:13:57,189 --> 00:13:57,199

 

651
00:13:57,199 --> 00:14:00,470

so that's a nice feature it's pretty

652
00:14:00,470 --> 00:14:00,480
so that's a nice feature it's pretty
 

653
00:14:00,480 --> 00:14:01,750
so that's a nice feature it's pretty
weird if you imagine

654
00:14:01,750 --> 00:14:01,760
weird if you imagine
 

655
00:14:01,760 --> 00:14:03,509
weird if you imagine
it's unrealistic to imagine you can

656
00:14:03,509 --> 00:14:03,519
it's unrealistic to imagine you can
 

657
00:14:03,519 --> 00:14:04,870
it's unrealistic to imagine you can
allocate an array that's

658
00:14:04,870 --> 00:14:04,880
allocate an array that's
 

659
00:14:04,880 --> 00:14:06,629
allocate an array that's
infinite size and then just use a few

660
00:14:06,629 --> 00:14:06,639
infinite size and then just use a few
 

661
00:14:06,639 --> 00:14:08,470
infinite size and then just use a few
items out of it that won't be

662
00:14:08,470 --> 00:14:08,480
items out of it that won't be
 

663
00:14:08,480 --> 00:14:10,949
items out of it that won't be
give you a good data structure so we'll

664
00:14:10,949 --> 00:14:10,959
give you a good data structure so we'll
 

665
00:14:10,959 --> 00:14:12,150
give you a good data structure so we'll
assume it costs

666
00:14:12,150 --> 00:14:12,160
assume it costs
 

667
00:14:12,160 --> 00:14:14,629
assume it costs
to allocate memory and okay great we

668
00:14:14,629 --> 00:14:14,639
to allocate memory and okay great we
 

669
00:14:14,639 --> 00:14:16,790
to allocate memory and okay great we
solved the static sequence problem

670
00:14:16,790 --> 00:14:16,800
solved the static sequence problem
 

671
00:14:16,800 --> 00:14:18,629
solved the static sequence problem
very simple kind of boring these are

672
00:14:18,629 --> 00:14:18,639
very simple kind of boring these are
 

673
00:14:18,639 --> 00:14:21,670
very simple kind of boring these are
optimal running times

674
00:14:21,670 --> 00:14:21,680
optimal running times
 

675
00:14:21,680 --> 00:14:24,069
optimal running times
now let's make it interesting make sure

676
00:14:24,069 --> 00:14:24,079
now let's make it interesting make sure
 

677
00:14:24,079 --> 00:14:26,550
now let's make it interesting make sure
i didn't miss anything

678
00:14:26,550 --> 00:14:26,560
i didn't miss anything
 

679
00:14:26,560 --> 00:14:29,990
i didn't miss anything
and talk about

680
00:14:29,990 --> 00:14:30,000
and talk about
 

681
00:14:30,000 --> 00:14:32,629
and talk about
oh there is one thing i wanted to talk

682
00:14:32,629 --> 00:14:32,639
oh there is one thing i wanted to talk
 

683
00:14:32,639 --> 00:14:33,509
oh there is one thing i wanted to talk
about

684
00:14:33,509 --> 00:14:33,519
about
 

685
00:14:33,519 --> 00:14:36,710
about
in the word ram a side effect

686
00:14:36,710 --> 00:14:36,720
in the word ram a side effect
 

687
00:14:36,720 --> 00:14:38,949
in the word ram a side effect
of this assumption that array access

688
00:14:38,949 --> 00:14:38,959
of this assumption that array access
 

689
00:14:38,959 --> 00:14:40,629
of this assumption that array access
should take constant time

690
00:14:40,629 --> 00:14:40,639
should take constant time
 

691
00:14:40,639 --> 00:14:43,509
should take constant time
and that accessing these positions in my

692
00:14:43,509 --> 00:14:43,519
and that accessing these positions in my
 

693
00:14:43,519 --> 00:14:43,990
and that accessing these positions in my
memory

694
00:14:43,990 --> 00:14:44,000
memory
 

695
00:14:44,000 --> 00:14:49,350
memory
should take constant time is that

696
00:14:49,350 --> 00:14:49,360

 

697
00:14:49,360 --> 00:14:52,550

we need to assume w

698
00:14:52,550 --> 00:14:52,560
we need to assume w
 

699
00:14:52,560 --> 00:14:58,310
we need to assume w
is at least log n or so

700
00:14:58,310 --> 00:14:58,320
is at least log n or so
 

701
00:14:58,320 --> 00:15:00,949
is at least log n or so
w remember is the machine word size in

702
00:15:00,949 --> 00:15:00,959
w remember is the machine word size in
 

703
00:15:00,959 --> 00:15:03,590
w remember is the machine word size in
real computers this is currently 64.

704
00:15:03,590 --> 00:15:03,600
real computers this is currently 64.
 

705
00:15:03,600 --> 00:15:06,710
real computers this is currently 64.
um or 256 and some

706
00:15:06,710 --> 00:15:06,720
um or 256 and some
 

707
00:15:06,720 --> 00:15:09,509
um or 256 and some
bizarre instructions but uh we don't

708
00:15:09,509 --> 00:15:09,519
bizarre instructions but uh we don't
 

709
00:15:09,519 --> 00:15:11,030
bizarre instructions but uh we don't
usually think of the machine as getting

710
00:15:11,030 --> 00:15:11,040
usually think of the machine as getting
 

711
00:15:11,040 --> 00:15:12,310
usually think of the machine as getting
bigger over time

712
00:15:12,310 --> 00:15:12,320
bigger over time
 

713
00:15:12,320 --> 00:15:13,750
bigger over time
but you should think of the machine as

714
00:15:13,750 --> 00:15:13,760
but you should think of the machine as
 

715
00:15:13,760 --> 00:15:15,110
but you should think of the machine as
getting bigger over time this is a

716
00:15:15,110 --> 00:15:15,120
getting bigger over time this is a
 

717
00:15:15,120 --> 00:15:15,829
getting bigger over time this is a
statement

718
00:15:15,829 --> 00:15:15,839
statement
 

719
00:15:15,839 --> 00:15:18,310
statement
that says the word side has to grow with

720
00:15:18,310 --> 00:15:18,320
that says the word side has to grow with
 

721
00:15:18,320 --> 00:15:18,949
that says the word side has to grow with
n

722
00:15:18,949 --> 00:15:18,959
n
 

723
00:15:18,959 --> 00:15:20,550
n
it might grow faster than log n but it

724
00:15:20,550 --> 00:15:20,560
it might grow faster than log n but it
 

725
00:15:20,560 --> 00:15:22,550
it might grow faster than log n but it
has to grow at least as fast as log n

726
00:15:22,550 --> 00:15:22,560
has to grow at least as fast as log n
 

727
00:15:22,560 --> 00:15:25,189
has to grow at least as fast as log n
why do i say that because if i have n

728
00:15:25,189 --> 00:15:25,199
why do i say that because if i have n
 

729
00:15:25,199 --> 00:15:26,629
why do i say that because if i have n
things that i'm dealing with and here's

730
00:15:26,629 --> 00:15:26,639
things that i'm dealing with and here's
 

731
00:15:26,639 --> 00:15:27,750
things that i'm dealing with and here's
the problem size

732
00:15:27,750 --> 00:15:27,760
the problem size
 

733
00:15:27,760 --> 00:15:29,269
the problem size
maybe it's the array i'm trying to store

734
00:15:29,269 --> 00:15:29,279
maybe it's the array i'm trying to store
 

735
00:15:29,279 --> 00:15:32,069
maybe it's the array i'm trying to store
whatever if i'm having to

736
00:15:32,069 --> 00:15:32,079
whatever if i'm having to
 

737
00:15:32,079 --> 00:15:33,670
whatever if i'm having to
deal with n things in my memory at the

738
00:15:33,670 --> 00:15:33,680
deal with n things in my memory at the
 

739
00:15:33,680 --> 00:15:35,350
deal with n things in my memory at the
very least i need to be able to address

740
00:15:35,350 --> 00:15:35,360
very least i need to be able to address
 

741
00:15:35,360 --> 00:15:35,910
very least i need to be able to address
them

742
00:15:35,910 --> 00:15:35,920
them
 

743
00:15:35,920 --> 00:15:37,749
them
i should be able to say give me the ith

744
00:15:37,749 --> 00:15:37,759
i should be able to say give me the ith
 

745
00:15:37,759 --> 00:15:39,590
i should be able to say give me the ith
one and represent that number i

746
00:15:39,590 --> 00:15:39,600
one and represent that number i
 

747
00:15:39,600 --> 00:15:41,990
one and represent that number i
in a word otherwise because the machine

748
00:15:41,990 --> 00:15:42,000
in a word otherwise because the machine
 

749
00:15:42,000 --> 00:15:43,670
in a word otherwise because the machine
is designed to only work with w bit

750
00:15:43,670 --> 00:15:43,680
is designed to only work with w bit
 

751
00:15:43,680 --> 00:15:44,949
is designed to only work with w bit
words in constant time

752
00:15:44,949 --> 00:15:44,959
words in constant time
 

753
00:15:44,959 --> 00:15:46,389
words in constant time
if i want to be able to access the ith

754
00:15:46,389 --> 00:15:46,399
if i want to be able to access the ith
 

755
00:15:46,399 --> 00:15:48,710
if i want to be able to access the ith
word in constant time i need a word size

756
00:15:48,710 --> 00:15:48,720
word in constant time i need a word size
 

757
00:15:48,720 --> 00:15:50,310
word in constant time i need a word size
that's at least log n just to address

758
00:15:50,310 --> 00:15:50,320
that's at least log n just to address
 

759
00:15:50,320 --> 00:15:51,030
that's at least log n just to address
the n

760
00:15:51,030 --> 00:15:51,040
the n
 

761
00:15:51,040 --> 00:15:53,670
the n
things in my input so this is a totally

762
00:15:53,670 --> 00:15:53,680
things in my input so this is a totally
 

763
00:15:53,680 --> 00:15:55,269
things in my input so this is a totally
reasonable assumption it may seem weird

764
00:15:55,269 --> 00:15:55,279
reasonable assumption it may seem weird
 

765
00:15:55,279 --> 00:15:56,710
reasonable assumption it may seem weird
because you think of a real machine as

766
00:15:56,710 --> 00:15:56,720
because you think of a real machine as
 

767
00:15:56,720 --> 00:15:57,990
because you think of a real machine as
having constant size

768
00:15:57,990 --> 00:15:58,000
having constant size
 

769
00:15:58,000 --> 00:15:59,670
having constant size
but you know real machine has constant

770
00:15:59,670 --> 00:15:59,680
but you know real machine has constant
 

771
00:15:59,680 --> 00:16:01,269
but you know real machine has constant
size ram also

772
00:16:01,269 --> 00:16:01,279
size ram also
 

773
00:16:01,279 --> 00:16:03,350
size ram also
my machine has 24 gigs of ram or

774
00:16:03,350 --> 00:16:03,360
my machine has 24 gigs of ram or
 

775
00:16:03,360 --> 00:16:04,310
my machine has 24 gigs of ram or
whatever

776
00:16:04,310 --> 00:16:04,320
whatever
 

777
00:16:04,320 --> 00:16:06,949
whatever
that laptop has eight but uh you don't

778
00:16:06,949 --> 00:16:06,959
that laptop has eight but uh you don't
 

779
00:16:06,959 --> 00:16:08,470
that laptop has eight but uh you don't
think of that as changing over time but

780
00:16:08,470 --> 00:16:08,480
think of that as changing over time but
 

781
00:16:08,480 --> 00:16:09,990
think of that as changing over time but
of course if you wanted to process a

782
00:16:09,990 --> 00:16:10,000
of course if you wanted to process a
 

783
00:16:10,000 --> 00:16:11,189
of course if you wanted to process a
larger input you would

784
00:16:11,189 --> 00:16:11,199
larger input you would
 

785
00:16:11,199 --> 00:16:14,230
larger input you would
buy more ram so eventually

786
00:16:14,230 --> 00:16:14,240
buy more ram so eventually
 

787
00:16:14,240 --> 00:16:16,150
buy more ram so eventually
when our ends get really really big

788
00:16:16,150 --> 00:16:16,160
when our ends get really really big
 

789
00:16:16,160 --> 00:16:17,749
when our ends get really really big
we're going to have to increase w just

790
00:16:17,749 --> 00:16:17,759
we're going to have to increase w just
 

791
00:16:17,759 --> 00:16:20,310
we're going to have to increase w just
so we can address that round

792
00:16:20,310 --> 00:16:20,320
so we can address that round
 

793
00:16:20,320 --> 00:16:22,470
so we can address that round
that's the the intuition here but this

794
00:16:22,470 --> 00:16:22,480
that's the the intuition here but this
 

795
00:16:22,480 --> 00:16:24,069
that's the the intuition here but this
is a way to bridge

796
00:16:24,069 --> 00:16:24,079
is a way to bridge
 

797
00:16:24,079 --> 00:16:26,870
is a way to bridge
reality which are fixed machines with

798
00:16:26,870 --> 00:16:26,880
reality which are fixed machines with
 

799
00:16:26,880 --> 00:16:27,670
reality which are fixed machines with
theory in

800
00:16:27,670 --> 00:16:27,680
theory in
 

801
00:16:27,680 --> 00:16:29,670
theory in
in algorithms we care about scalability

802
00:16:29,670 --> 00:16:29,680
in algorithms we care about scalability
 

803
00:16:29,680 --> 00:16:31,350
in algorithms we care about scalability
for very large n we want to know what

804
00:16:31,350 --> 00:16:31,360
for very large n we want to know what
 

805
00:16:31,360 --> 00:16:32,629
for very large n we want to know what
that growth function is

806
00:16:32,629 --> 00:16:32,639
that growth function is
 

807
00:16:32,639 --> 00:16:34,470
that growth function is
and ignore the lead constant factor

808
00:16:34,470 --> 00:16:34,480
and ignore the lead constant factor
 

809
00:16:34,480 --> 00:16:36,389
and ignore the lead constant factor
that's what asymptotic notion notation

810
00:16:36,389 --> 00:16:36,399
that's what asymptotic notion notation
 

811
00:16:36,399 --> 00:16:37,189
that's what asymptotic notion notation
is all about

812
00:16:37,189 --> 00:16:37,199
is all about
 

813
00:16:37,199 --> 00:16:39,030
is all about
and for that we need a notion of word

814
00:16:39,030 --> 00:16:39,040
and for that we need a notion of word
 

815
00:16:39,040 --> 00:16:41,350
and for that we need a notion of word
size also changing in this asymptotic

816
00:16:41,350 --> 00:16:41,360
size also changing in this asymptotic
 

817
00:16:41,360 --> 00:16:42,470
size also changing in this asymptotic
way

818
00:16:42,470 --> 00:16:42,480
way
 

819
00:16:42,480 --> 00:16:44,870
way
all right that's uh that will be more

820
00:16:44,870 --> 00:16:44,880
all right that's uh that will be more
 

821
00:16:44,880 --> 00:16:45,590
all right that's uh that will be more
important

822
00:16:45,590 --> 00:16:45,600
important
 

823
00:16:45,600 --> 00:16:47,670
important
next week when we talk about hashing and

824
00:16:47,670 --> 00:16:47,680
next week when we talk about hashing and
 

825
00:16:47,680 --> 00:16:51,670
next week when we talk about hashing and
why hashing is a reasonable thing to do

826
00:16:51,670 --> 00:16:51,680
why hashing is a reasonable thing to do
 

827
00:16:51,680 --> 00:16:56,870
why hashing is a reasonable thing to do
but let's move on to dynamic sequences

828
00:16:56,870 --> 00:16:56,880
but let's move on to dynamic sequences
 

829
00:16:56,880 --> 00:17:01,350
but let's move on to dynamic sequences
which is where things get interesting

830
00:17:01,350 --> 00:17:01,360

 

831
00:17:01,360 --> 00:17:04,630

so i have the update here so we start

832
00:17:04,630 --> 00:17:04,640
so i have the update here so we start
 

833
00:17:04,640 --> 00:17:05,669
so i have the update here so we start
with

834
00:17:05,669 --> 00:17:05,679
with
 

835
00:17:05,679 --> 00:17:07,669
with
static sequences so all of these

836
00:17:07,669 --> 00:17:07,679
static sequences so all of these
 

837
00:17:07,679 --> 00:17:08,789
static sequences so all of these
operations

838
00:17:08,789 --> 00:17:08,799
operations
 

839
00:17:08,799 --> 00:17:10,870
operations
are still something we want to support

840
00:17:10,870 --> 00:17:10,880
are still something we want to support
 

841
00:17:10,880 --> 00:17:12,470
are still something we want to support
in a dynamic sequence but we add two

842
00:17:12,470 --> 00:17:12,480
in a dynamic sequence but we add two
 

843
00:17:12,480 --> 00:17:14,870
in a dynamic sequence but we add two
dynamic operations

844
00:17:14,870 --> 00:17:14,880
dynamic operations
 

845
00:17:14,880 --> 00:17:16,789
dynamic operations
somewhat controversial operations so

846
00:17:16,789 --> 00:17:16,799
somewhat controversial operations so
 

847
00:17:16,799 --> 00:17:18,230
somewhat controversial operations so
exciting

848
00:17:18,230 --> 00:17:18,240
exciting
 

849
00:17:18,240 --> 00:17:19,909
exciting
i want to be able to insert in the

850
00:17:19,909 --> 00:17:19,919
i want to be able to insert in the
 

851
00:17:19,919 --> 00:17:21,429
i want to be able to insert in the
middle of my sequence

852
00:17:21,429 --> 00:17:21,439
middle of my sequence
 

853
00:17:21,439 --> 00:17:23,110
middle of my sequence
and i want to be able to delete from the

854
00:17:23,110 --> 00:17:23,120
and i want to be able to delete from the
 

855
00:17:23,120 --> 00:17:25,029
and i want to be able to delete from the
middle of my sequence so

856
00:17:25,029 --> 00:17:25,039
middle of my sequence so
 

857
00:17:25,039 --> 00:17:26,949
middle of my sequence so
here's my sequence which i'm going to

858
00:17:26,949 --> 00:17:26,959
here's my sequence which i'm going to
 

859
00:17:26,959 --> 00:17:28,069
here's my sequence which i'm going to
think of

860
00:17:28,069 --> 00:17:28,079
think of
 

861
00:17:28,079 --> 00:17:29,590
think of
in a picture i'm going to draw it as an

862
00:17:29,590 --> 00:17:29,600
in a picture i'm going to draw it as an
 

863
00:17:29,600 --> 00:17:31,190
in a picture i'm going to draw it as an
array but it's stored however it's

864
00:17:31,190 --> 00:17:31,200
array but it's stored however it's
 

865
00:17:31,200 --> 00:17:32,390
array but it's stored however it's
stored we don't know

866
00:17:32,390 --> 00:17:32,400
stored we don't know
 

867
00:17:32,400 --> 00:17:33,669
stored we don't know
this is an interface not an

868
00:17:33,669 --> 00:17:33,679
this is an interface not an
 

869
00:17:33,679 --> 00:17:35,909
this is an interface not an
implementation so we have x0

870
00:17:35,909 --> 00:17:35,919
implementation so we have x0
 

871
00:17:35,919 --> 00:17:40,789
implementation so we have x0
x1 x2 x3

872
00:17:40,789 --> 00:17:40,799

 

873
00:17:40,799 --> 00:17:45,270

uh and let's say i insert at position

874
00:17:45,270 --> 00:17:45,280
uh and let's say i insert at position
 

875
00:17:45,280 --> 00:17:48,950
uh and let's say i insert at position
2 so position 2 is here

876
00:17:48,950 --> 00:17:48,960
2 so position 2 is here
 

877
00:17:48,960 --> 00:17:51,830
2 so position 2 is here
so i come in with my new x and i would

878
00:17:51,830 --> 00:17:51,840
so i come in with my new x and i would
 

879
00:17:51,840 --> 00:17:52,150
so i come in with my new x and i would
like

880
00:17:52,150 --> 00:17:52,160
like
 

881
00:17:52,160 --> 00:17:53,990
like
x to be the new x2 but i don't want to

882
00:17:53,990 --> 00:17:54,000
x to be the new x2 but i don't want to
 

883
00:17:54,000 --> 00:17:56,630
x to be the new x2 but i don't want to
lose any information if i did set at 2

884
00:17:56,630 --> 00:17:56,640
lose any information if i did set at 2
 

885
00:17:56,640 --> 00:17:58,549
lose any information if i did set at 2
then i would erase this and replace it

886
00:17:58,549 --> 00:17:58,559
then i would erase this and replace it
 

887
00:17:58,559 --> 00:18:00,710
then i would erase this and replace it
with x but i want to do insert at which

888
00:18:00,710 --> 00:18:00,720
with x but i want to do insert at which
 

889
00:18:00,720 --> 00:18:02,230
with x but i want to do insert at which
means all of these guys conceptually are

890
00:18:02,230 --> 00:18:02,240
means all of these guys conceptually are
 

891
00:18:02,240 --> 00:18:03,830
means all of these guys conceptually are
going to shift over by one in terms of

892
00:18:03,830 --> 00:18:03,840
going to shift over by one in terms of
 

893
00:18:03,840 --> 00:18:05,350
going to shift over by one in terms of
their indices

894
00:18:05,350 --> 00:18:05,360
their indices
 

895
00:18:05,360 --> 00:18:08,470
their indices
so then i would get this picture that's

896
00:18:08,470 --> 00:18:08,480
so then i would get this picture that's
 

897
00:18:08,480 --> 00:18:13,350
so then i would get this picture that's
one bigger

898
00:18:13,350 --> 00:18:13,360

 

899
00:18:13,360 --> 00:18:15,190

and now i've got the new x i've got what

900
00:18:15,190 --> 00:18:15,200
and now i've got the new x i've got what
 

901
00:18:15,200 --> 00:18:17,029
and now i've got the new x i've got what
was the old x2

902
00:18:17,029 --> 00:18:17,039
was the old x2
 

903
00:18:17,039 --> 00:18:20,150
was the old x2
which i don't hesitate to call x2

904
00:18:20,150 --> 00:18:20,160
which i don't hesitate to call x2
 

905
00:18:20,160 --> 00:18:21,830
which i don't hesitate to call x2
because that's its old name not its new

906
00:18:21,830 --> 00:18:21,840
because that's its old name not its new
 

907
00:18:21,840 --> 00:18:23,830
because that's its old name not its new
name i'm going to draw arrows to say

908
00:18:23,830 --> 00:18:23,840
name i'm going to draw arrows to say
 

909
00:18:23,840 --> 00:18:27,029
name i'm going to draw arrows to say
these guys get copied over

910
00:18:27,029 --> 00:18:27,039
these guys get copied over
 

911
00:18:27,039 --> 00:18:30,150
these guys get copied over
uh these ones are definitely unchanged

912
00:18:30,150 --> 00:18:30,160
uh these ones are definitely unchanged
 

913
00:18:30,160 --> 00:18:33,750
uh these ones are definitely unchanged
our new x2 which i'll call x2 prime is x

914
00:18:33,750 --> 00:18:33,760
our new x2 which i'll call x2 prime is x
 

915
00:18:33,760 --> 00:18:37,830
our new x2 which i'll call x2 prime is x
and this is x3 prime x4 prime

916
00:18:37,830 --> 00:18:37,840
and this is x3 prime x4 prime
 

917
00:18:37,840 --> 00:18:40,390
and this is x3 prime x4 prime
and so on i i want to be careful here

918
00:18:40,390 --> 00:18:40,400
and so on i i want to be careful here
 

919
00:18:40,400 --> 00:18:42,230
and so on i i want to be careful here
and of course the new n

920
00:18:42,230 --> 00:18:42,240
and of course the new n
 

921
00:18:42,240 --> 00:18:45,510
and of course the new n
prime is n plus one

922
00:18:45,510 --> 00:18:45,520
prime is n plus one
 

923
00:18:45,520 --> 00:18:47,590
prime is n plus one
uh i want to be careful about the

924
00:18:47,590 --> 00:18:47,600
uh i want to be careful about the
 

925
00:18:47,600 --> 00:18:48,950
uh i want to be careful about the
labeling because the key

926
00:18:48,950 --> 00:18:48,960
labeling because the key
 

927
00:18:48,960 --> 00:18:50,789
labeling because the key
what makes insert ad interesting is that

928
00:18:50,789 --> 00:18:50,799
what makes insert ad interesting is that
 

929
00:18:50,799 --> 00:18:52,150
what makes insert ad interesting is that
later when i call get

930
00:18:52,150 --> 00:18:52,160
later when i call get
 

931
00:18:52,160 --> 00:18:54,870
later when i call get
at it's with the new indexing so

932
00:18:54,870 --> 00:18:54,880
at it's with the new indexing so
 

933
00:18:54,880 --> 00:18:55,990
at it's with the new indexing so
previously

934
00:18:55,990 --> 00:18:56,000
previously
 

935
00:18:56,000 --> 00:18:59,510
previously
if i did get at 2 i would get this value

936
00:18:59,510 --> 00:18:59,520
if i did get at 2 i would get this value
 

937
00:18:59,520 --> 00:19:01,510
if i did get at 2 i would get this value
and afterwards if i did get at it 2 i

938
00:19:01,510 --> 00:19:01,520
and afterwards if i did get at it 2 i
 

939
00:19:01,520 --> 00:19:03,669
and afterwards if i did get at it 2 i
get the new value if i did get at it 3

940
00:19:03,669 --> 00:19:03,679
get the new value if i did get at it 3
 

941
00:19:03,679 --> 00:19:05,270
get the new value if i did get at it 3
down here i would get

942
00:19:05,270 --> 00:19:05,280
down here i would get
 

943
00:19:05,280 --> 00:19:08,070
down here i would get
i get the value that used to be x2 okay

944
00:19:08,070 --> 00:19:08,080
i get the value that used to be x2 okay
 

945
00:19:08,080 --> 00:19:09,750
i get the value that used to be x2 okay
that's maybe hard to track

946
00:19:09,750 --> 00:19:09,760
that's maybe hard to track
 

947
00:19:09,760 --> 00:19:12,230
that's maybe hard to track
but this is a useful conceptually very

948
00:19:12,230 --> 00:19:12,240
but this is a useful conceptually very
 

949
00:19:12,240 --> 00:19:13,430
but this is a useful conceptually very
useful thing to do

950
00:19:13,430 --> 00:19:13,440
useful thing to do
 

951
00:19:13,440 --> 00:19:15,750
useful thing to do
especially when you're inserting or

952
00:19:15,750 --> 00:19:15,760
especially when you're inserting or
 

953
00:19:15,760 --> 00:19:17,510
especially when you're inserting or
deleting at the ends

954
00:19:17,510 --> 00:19:17,520
deleting at the ends
 

955
00:19:17,520 --> 00:19:20,789
deleting at the ends
so we're going to define in particular

956
00:19:20,789 --> 00:19:20,799
so we're going to define in particular
 

957
00:19:20,799 --> 00:19:26,070
so we're going to define in particular
insert and delete

958
00:19:26,070 --> 00:19:26,080

 

959
00:19:26,080 --> 00:19:31,750

uh first and last

960
00:19:31,750 --> 00:19:31,760

 

961
00:19:31,760 --> 00:19:34,950

uh these are

962
00:19:34,950 --> 00:19:34,960
uh these are
 

963
00:19:34,960 --> 00:19:37,669
uh these are
sometimes given if if you have an insert

964
00:19:37,669 --> 00:19:37,679
sometimes given if if you have an insert
 

965
00:19:37,679 --> 00:19:39,510
sometimes given if if you have an insert
it has an x

966
00:19:39,510 --> 00:19:39,520
it has an x
 

967
00:19:39,520 --> 00:19:42,950
it has an x
if you do a delete it has no argument

968
00:19:42,950 --> 00:19:42,960
if you do a delete it has no argument
 

969
00:19:42,960 --> 00:19:45,270
if you do a delete it has no argument
so this means insert at the beginning of

970
00:19:45,270 --> 00:19:45,280
so this means insert at the beginning of
 

971
00:19:45,280 --> 00:19:47,430
so this means insert at the beginning of
the array which would be like adding it

972
00:19:47,430 --> 00:19:47,440
the array which would be like adding it
 

973
00:19:47,440 --> 00:19:48,549
the array which would be like adding it
here

974
00:19:48,549 --> 00:19:48,559
here
 

975
00:19:48,559 --> 00:19:51,750
here
and insert last means adding it on here

976
00:19:51,750 --> 00:19:51,760
and insert last means adding it on here
 

977
00:19:51,760 --> 00:19:53,270
and insert last means adding it on here
so insert last doesn't change the

978
00:19:53,270 --> 00:19:53,280
so insert last doesn't change the
 

979
00:19:53,280 --> 00:19:55,110
so insert last doesn't change the
indices of any of the old items that's a

980
00:19:55,110 --> 00:19:55,120
indices of any of the old items that's a
 

981
00:19:55,120 --> 00:19:57,350
indices of any of the old items that's a
nice feature of insert last insert first

982
00:19:57,350 --> 00:19:57,360
nice feature of insert last insert first
 

983
00:19:57,360 --> 00:19:59,830
nice feature of insert last insert first
changes all of them they all get

984
00:19:59,830 --> 00:19:59,840
changes all of them they all get
 

985
00:19:59,840 --> 00:20:02,310
changes all of them they all get
incremented by one

986
00:20:02,310 --> 00:20:02,320
incremented by one
 

987
00:20:02,320 --> 00:20:04,870
incremented by one
and we're also interested in the similar

988
00:20:04,870 --> 00:20:04,880
and we're also interested in the similar
 

989
00:20:04,880 --> 00:20:06,870
and we're also interested in the similar
things here we could do

990
00:20:06,870 --> 00:20:06,880
things here we could do
 

991
00:20:06,880 --> 00:20:10,149
things here we could do
get first

992
00:20:10,149 --> 00:20:10,159
get first
 

993
00:20:10,159 --> 00:20:14,149
get first
or last or

994
00:20:14,149 --> 00:20:14,159
or last or
 

995
00:20:14,159 --> 00:20:22,070
or last or
set first or last

996
00:20:22,070 --> 00:20:22,080

 

997
00:20:22,080 --> 00:20:24,310

okay which are the obvious special cases

998
00:20:24,310 --> 00:20:24,320
okay which are the obvious special cases
 

999
00:20:24,320 --> 00:20:26,310
okay which are the obvious special cases
of get ad and set out now these special

1000
00:20:26,310 --> 00:20:26,320
of get ad and set out now these special
 

1001
00:20:26,320 --> 00:20:28,230
of get ad and set out now these special
cases are particularly interesting

1002
00:20:28,230 --> 00:20:28,240
cases are particularly interesting
 

1003
00:20:28,240 --> 00:20:29,909
cases are particularly interesting
in an algorithms context if you were a

1004
00:20:29,909 --> 00:20:29,919
in an algorithms context if you were a
 

1005
00:20:29,919 --> 00:20:31,430
in an algorithms context if you were a
mathematician you would say well

1006
00:20:31,430 --> 00:20:31,440
mathematician you would say well
 

1007
00:20:31,440 --> 00:20:33,110
mathematician you would say well
why do i even bother this this is just

1008
00:20:33,110 --> 00:20:33,120
why do i even bother this this is just
 

1009
00:20:33,120 --> 00:20:34,470
why do i even bother this this is just
shorthand for

1010
00:20:34,470 --> 00:20:34,480
shorthand for
 

1011
00:20:34,480 --> 00:20:37,750
shorthand for
a particular call to get or set but what

1012
00:20:37,750 --> 00:20:37,760
a particular call to get or set but what
 

1013
00:20:37,760 --> 00:20:39,270
a particular call to get or set but what
makes it interesting

1014
00:20:39,270 --> 00:20:39,280
makes it interesting
 

1015
00:20:39,280 --> 00:20:40,950
makes it interesting
from a data structure's perspective is

1016
00:20:40,950 --> 00:20:40,960
from a data structure's perspective is
 

1017
00:20:40,960 --> 00:20:42,789
from a data structure's perspective is
that we care about algorithms for

1018
00:20:42,789 --> 00:20:42,799
that we care about algorithms for
 

1019
00:20:42,799 --> 00:20:45,029
that we care about algorithms for
supporting these operations and maybe

1020
00:20:45,029 --> 00:20:45,039
supporting these operations and maybe
 

1021
00:20:45,039 --> 00:20:47,350
supporting these operations and maybe
the algorithm for supporting get first

1022
00:20:47,350 --> 00:20:47,360
the algorithm for supporting get first
 

1023
00:20:47,360 --> 00:20:48,149
the algorithm for supporting get first
or set first

1024
00:20:48,149 --> 00:20:48,159
or set first
 

1025
00:20:48,159 --> 00:20:50,470
or set first
or in particular insert first or insert

1026
00:20:50,470 --> 00:20:50,480
or in particular insert first or insert
 

1027
00:20:50,480 --> 00:20:51,510
or in particular insert first or insert
last

1028
00:20:51,510 --> 00:20:51,520
last
 

1029
00:20:51,520 --> 00:20:53,190
last
might be more efficient maybe we can

1030
00:20:53,190 --> 00:20:53,200
might be more efficient maybe we can
 

1031
00:20:53,200 --> 00:20:54,789
might be more efficient maybe we can
solve this problem better

1032
00:20:54,789 --> 00:20:54,799
solve this problem better
 

1033
00:20:54,799 --> 00:20:57,270
solve this problem better
than we can solve insert at so while

1034
00:20:57,270 --> 00:20:57,280
than we can solve insert at so while
 

1035
00:20:57,280 --> 00:20:58,710
than we can solve insert at so while
ideally we could solve the entire

1036
00:20:58,710 --> 00:20:58,720
ideally we could solve the entire
 

1037
00:20:58,720 --> 00:21:00,549
ideally we could solve the entire
dynamics sequence interface

1038
00:21:00,549 --> 00:21:00,559
dynamics sequence interface
 

1039
00:21:00,559 --> 00:21:02,149
dynamics sequence interface
constant time per operation that's not

1040
00:21:02,149 --> 00:21:02,159
constant time per operation that's not
 

1041
00:21:02,159 --> 00:21:04,390
constant time per operation that's not
actually possible you can prove that

1042
00:21:04,390 --> 00:21:04,400
actually possible you can prove that
 

1043
00:21:04,400 --> 00:21:06,230
actually possible you can prove that
but special cases of it where we're just

1044
00:21:06,230 --> 00:21:06,240
but special cases of it where we're just
 

1045
00:21:06,240 --> 00:21:08,070
but special cases of it where we're just
inserting and deleting from the ends say

1046
00:21:08,070 --> 00:21:08,080
inserting and deleting from the ends say
 

1047
00:21:08,080 --> 00:21:10,710
inserting and deleting from the ends say
we can do that so that's why it's

1048
00:21:10,710 --> 00:21:10,720
we can do that so that's why it's
 

1049
00:21:10,720 --> 00:21:12,070
we can do that so that's why it's
interesting to introduce

1050
00:21:12,070 --> 00:21:12,080
interesting to introduce
 

1051
00:21:12,080 --> 00:21:16,149
interesting to introduce
special cases that we care about

1052
00:21:16,149 --> 00:21:16,159
special cases that we care about
 

1053
00:21:16,159 --> 00:21:17,669
special cases that we care about
cool that's the definition of the

1054
00:21:17,669 --> 00:21:17,679
cool that's the definition of the
 

1055
00:21:17,679 --> 00:21:19,350
cool that's the definition of the
dynamic sequence interface

1056
00:21:19,350 --> 00:21:19,360
dynamic sequence interface
 

1057
00:21:19,360 --> 00:21:26,789
dynamic sequence interface
now we're going to actually solve it

1058
00:21:26,789 --> 00:21:26,799

 

1059
00:21:26,799 --> 00:21:29,270

so uh our first data structure for this

1060
00:21:29,270 --> 00:21:29,280
so uh our first data structure for this
 

1061
00:21:29,280 --> 00:21:30,870
so uh our first data structure for this
is called

1062
00:21:30,870 --> 00:21:30,880
is called
 

1063
00:21:30,880 --> 00:21:37,590
is called
linked bliss i've taken

1064
00:21:37,590 --> 00:21:37,600

 

1065
00:21:37,600 --> 00:21:39,430

probably you've probably seen linked

1066
00:21:39,430 --> 00:21:39,440
probably you've probably seen linked
 

1067
00:21:39,440 --> 00:21:40,870
probably you've probably seen linked
lists before at some point

1068
00:21:40,870 --> 00:21:40,880
lists before at some point
 

1069
00:21:40,880 --> 00:21:42,950
lists before at some point
but the main new part here is we're

1070
00:21:42,950 --> 00:21:42,960
but the main new part here is we're
 

1071
00:21:42,960 --> 00:21:44,310
but the main new part here is we're
going to actually analyze them

1072
00:21:44,310 --> 00:21:44,320
going to actually analyze them
 

1073
00:21:44,320 --> 00:21:46,470
going to actually analyze them
and see how they how efficiently they

1074
00:21:46,470 --> 00:21:46,480
and see how they how efficiently they
 

1075
00:21:46,480 --> 00:21:48,070
and see how they how efficiently they
implement all these operations we might

1076
00:21:48,070 --> 00:21:48,080
implement all these operations we might
 

1077
00:21:48,080 --> 00:21:49,029
implement all these operations we might
care about

1078
00:21:49,029 --> 00:21:49,039
care about
 

1079
00:21:49,039 --> 00:21:52,549
care about
so first review what is a linked list

1080
00:21:52,549 --> 00:21:52,559
so first review what is a linked list
 

1081
00:21:52,559 --> 00:21:59,430
so first review what is a linked list
we store our items

1082
00:21:59,430 --> 00:21:59,440
we store our items
 

1083
00:21:59,440 --> 00:22:10,830
we store our items
in a bunch of nodes

1084
00:22:10,830 --> 00:22:10,840

 

1085
00:22:10,840 --> 00:22:12,390

um

1086
00:22:12,390 --> 00:22:12,400
um
 

1087
00:22:12,400 --> 00:22:16,789
um
each node has an item in it

1088
00:22:16,789 --> 00:22:16,799
each node has an item in it
 

1089
00:22:16,799 --> 00:22:19,990
each node has an item in it
and a next field

1090
00:22:19,990 --> 00:22:20,000

 

1091
00:22:20,000 --> 00:22:22,230

so you could think of these as class

1092
00:22:22,230 --> 00:22:22,240
so you could think of these as class
 

1093
00:22:22,240 --> 00:22:24,310
so you could think of these as class
objects with two

1094
00:22:24,310 --> 00:22:24,320
objects with two
 

1095
00:22:24,320 --> 00:22:27,190
objects with two
class variables the item and and a next

1096
00:22:27,190 --> 00:22:27,200
class variables the item and and a next
 

1097
00:22:27,200 --> 00:22:28,310
class variables the item and and a next
pointer

1098
00:22:28,310 --> 00:22:28,320
pointer
 

1099
00:22:28,320 --> 00:22:30,310
pointer
and we assemble those into this kind of

1100
00:22:30,310 --> 00:22:30,320
and we assemble those into this kind of
 

1101
00:22:30,320 --> 00:22:31,590
and we assemble those into this kind of
structure where we

1102
00:22:31,590 --> 00:22:31,600
structure where we
 

1103
00:22:31,600 --> 00:22:33,590
structure where we
store in the item fields we're going to

1104
00:22:33,590 --> 00:22:33,600
store in the item fields we're going to
 

1105
00:22:33,600 --> 00:22:35,750
store in the item fields we're going to
store the actual values

1106
00:22:35,750 --> 00:22:35,760
store the actual values
 

1107
00:22:35,760 --> 00:22:37,190
store the actual values
that we want to represent in our

1108
00:22:37,190 --> 00:22:37,200
that we want to represent in our
 

1109
00:22:37,200 --> 00:22:40,070
that we want to represent in our
sequence x zero through x n minus 1

1110
00:22:40,070 --> 00:22:40,080
sequence x zero through x n minus 1
 

1111
00:22:40,080 --> 00:22:43,270
sequence x zero through x n minus 1
in order and then we're going to use the

1112
00:22:43,270 --> 00:22:43,280
in order and then we're going to use the
 

1113
00:22:43,280 --> 00:22:45,590
in order and then we're going to use the
next pointers to link these all together

1114
00:22:45,590 --> 00:22:45,600
next pointers to link these all together
 

1115
00:22:45,600 --> 00:22:47,190
next pointers to link these all together
in that order so the next pointers are

1116
00:22:47,190 --> 00:22:47,200
in that order so the next pointers are
 

1117
00:22:47,200 --> 00:22:48,870
in that order so the next pointers are
what actually give us the order

1118
00:22:48,870 --> 00:22:48,880
what actually give us the order
 

1119
00:22:48,880 --> 00:22:50,390
what actually give us the order
and in addition we're going to keep

1120
00:22:50,390 --> 00:22:50,400
and in addition we're going to keep
 

1121
00:22:50,400 --> 00:22:52,310
and in addition we're going to keep
track of what's called the head of the

1122
00:22:52,310 --> 00:22:52,320
track of what's called the head of the
 

1123
00:22:52,320 --> 00:22:53,430
track of what's called the head of the
list

1124
00:22:53,430 --> 00:22:53,440
list
 

1125
00:22:53,440 --> 00:22:54,789
list
so the data structure is going to be

1126
00:22:54,789 --> 00:22:54,799
so the data structure is going to be
 

1127
00:22:54,799 --> 00:22:56,549
so the data structure is going to be
represented by head

1128
00:22:56,549 --> 00:22:56,559
represented by head
 

1129
00:22:56,559 --> 00:22:58,630
represented by head
if you wanted to you could also store

1130
00:22:58,630 --> 00:22:58,640
if you wanted to you could also store
 

1131
00:22:58,640 --> 00:23:00,390
if you wanted to you could also store
length

1132
00:23:00,390 --> 00:23:00,400
length
 

1133
00:23:00,400 --> 00:23:01,830
length
so this could be the data structure

1134
00:23:01,830 --> 00:23:01,840
so this could be the data structure
 

1135
00:23:01,840 --> 00:23:04,789
so this could be the data structure
itself

1136
00:23:04,789 --> 00:23:04,799

 

1137
00:23:04,799 --> 00:23:07,110

and it's pointing to all of these types

1138
00:23:07,110 --> 00:23:07,120
and it's pointing to all of these types
 

1139
00:23:07,120 --> 00:23:08,470
and it's pointing to all of these types
of data structures notice we've just

1140
00:23:08,470 --> 00:23:08,480
of data structures notice we've just
 

1141
00:23:08,480 --> 00:23:09,110
of data structures notice we've just
seen

1142
00:23:09,110 --> 00:23:09,120
seen
 

1143
00:23:09,120 --> 00:23:10,789
seen
an array based data structure which is

1144
00:23:10,789 --> 00:23:10,799
an array based data structure which is
 

1145
00:23:10,799 --> 00:23:12,549
an array based data structure which is
just a static

1146
00:23:12,549 --> 00:23:12,559
just a static
 

1147
00:23:12,559 --> 00:23:14,950
just a static
array and we've seen a pointer-based

1148
00:23:14,950 --> 00:23:14,960
array and we've seen a pointer-based
 

1149
00:23:14,960 --> 00:23:17,669
array and we've seen a pointer-based
data structure

1150
00:23:17,669 --> 00:23:17,679

 

1151
00:23:17,679 --> 00:23:19,430

and we're relying on the fact that

1152
00:23:19,430 --> 00:23:19,440
and we're relying on the fact that
 

1153
00:23:19,440 --> 00:23:20,870
and we're relying on the fact that
pointers

1154
00:23:20,870 --> 00:23:20,880
pointers
 

1155
00:23:20,880 --> 00:23:23,270
pointers
can be stored in a single word which

1156
00:23:23,270 --> 00:23:23,280
can be stored in a single word which
 

1157
00:23:23,280 --> 00:23:24,789
can be stored in a single word which
means we can de-reference them we can

1158
00:23:24,789 --> 00:23:24,799
means we can de-reference them we can
 

1159
00:23:24,799 --> 00:23:26,310
means we can de-reference them we can
see what's on the other side of the

1160
00:23:26,310 --> 00:23:26,320
see what's on the other side of the
 

1161
00:23:26,320 --> 00:23:27,590
see what's on the other side of the
pointer

1162
00:23:27,590 --> 00:23:27,600
pointer
 

1163
00:23:27,600 --> 00:23:30,630
pointer
in constant time in our word ram model

1164
00:23:30,630 --> 00:23:30,640
in constant time in our word ram model
 

1165
00:23:30,640 --> 00:23:33,430
in constant time in our word ram model
in reality each of these nodes is stored

1166
00:23:33,430 --> 00:23:33,440
in reality each of these nodes is stored
 

1167
00:23:33,440 --> 00:23:34,310
in reality each of these nodes is stored
somewhere

1168
00:23:34,310 --> 00:23:34,320
somewhere
 

1169
00:23:34,320 --> 00:23:37,990
somewhere
in the array of the computer

1170
00:23:37,990 --> 00:23:38,000
in the array of the computer
 

1171
00:23:38,000 --> 00:23:40,470
in the array of the computer
so maybe each one is two words long so

1172
00:23:40,470 --> 00:23:40,480
so maybe each one is two words long so
 

1173
00:23:40,480 --> 00:23:41,269
so maybe each one is two words long so
maybe

1174
00:23:41,269 --> 00:23:41,279
maybe
 

1175
00:23:41,279 --> 00:23:44,230
maybe
uh one node is the first node is here

1176
00:23:44,230 --> 00:23:44,240
uh one node is the first node is here
 

1177
00:23:44,240 --> 00:23:45,750
uh one node is the first node is here
maybe the second node is here the third

1178
00:23:45,750 --> 00:23:45,760
maybe the second node is here the third
 

1179
00:23:45,760 --> 00:23:46,549
maybe the second node is here the third
node is here

1180
00:23:46,549 --> 00:23:46,559
node is here
 

1181
00:23:46,559 --> 00:23:48,710
node is here
they're in some arbitrary order we're

1182
00:23:48,710 --> 00:23:48,720
they're in some arbitrary order we're
 

1183
00:23:48,720 --> 00:23:50,070
they're in some arbitrary order we're
using this fact

1184
00:23:50,070 --> 00:23:50,080
using this fact
 

1185
00:23:50,080 --> 00:23:53,110
using this fact
that we can allocate a an array

1186
00:23:53,110 --> 00:23:53,120
that we can allocate a an array
 

1187
00:23:53,120 --> 00:23:55,510
that we can allocate a an array
of size n in linear time in this case

1188
00:23:55,510 --> 00:23:55,520
of size n in linear time in this case
 

1189
00:23:55,520 --> 00:23:57,350
of size n in linear time in this case
we're going to have a raise of size 2.

1190
00:23:57,350 --> 00:23:57,360
we're going to have a raise of size 2.
 

1191
00:23:57,360 --> 00:23:59,269
we're going to have a raise of size 2.
we can just say oh please give me a new

1192
00:23:59,269 --> 00:23:59,279
we can just say oh please give me a new
 

1193
00:23:59,279 --> 00:24:00,710
we can just say oh please give me a new
array of size 2.

1194
00:24:00,710 --> 00:24:00,720
array of size 2.
 

1195
00:24:00,720 --> 00:24:04,390
array of size 2.
and that will give make us one of these

1196
00:24:04,390 --> 00:24:04,400
and that will give make us one of these
 

1197
00:24:04,400 --> 00:24:06,070
and that will give make us one of these
nodes

1198
00:24:06,070 --> 00:24:06,080
nodes
 

1199
00:24:06,080 --> 00:24:07,830
nodes
and then we're storing pointers pointers

1200
00:24:07,830 --> 00:24:07,840
and then we're storing pointers pointers
 

1201
00:24:07,840 --> 00:24:09,430
and then we're storing pointers pointers
are just indices

1202
00:24:09,430 --> 00:24:09,440
are just indices
 

1203
00:24:09,440 --> 00:24:11,909
are just indices
into the giant memory array they're just

1204
00:24:11,909 --> 00:24:11,919
into the giant memory array they're just
 

1205
00:24:11,919 --> 00:24:14,789
into the giant memory array they're just
what is the address of this little array

1206
00:24:14,789 --> 00:24:14,799
what is the address of this little array
 

1207
00:24:14,799 --> 00:24:15,990
what is the address of this little array
okay if you've ever wondered how

1208
00:24:15,990 --> 00:24:16,000
okay if you've ever wondered how
 

1209
00:24:16,000 --> 00:24:17,350
okay if you've ever wondered how
pointers are implemented they're just

1210
00:24:17,350 --> 00:24:17,360
pointers are implemented they're just
 

1211
00:24:17,360 --> 00:24:18,149
pointers are implemented they're just
numbers

1212
00:24:18,149 --> 00:24:18,159
numbers
 

1213
00:24:18,159 --> 00:24:20,789
numbers
that say where in memory is this thing

1214
00:24:20,789 --> 00:24:20,799
that say where in memory is this thing
 

1215
00:24:20,799 --> 00:24:21,430
that say where in memory is this thing
over here and

1216
00:24:21,430 --> 00:24:21,440
over here and
 

1217
00:24:21,440 --> 00:24:23,830
over here and
in memory they're an arbitrary order

1218
00:24:23,830 --> 00:24:23,840
in memory they're an arbitrary order
 

1219
00:24:23,840 --> 00:24:25,750
in memory they're an arbitrary order
this is really nice because it's

1220
00:24:25,750 --> 00:24:25,760
this is really nice because it's
 

1221
00:24:25,760 --> 00:24:27,750
this is really nice because it's
easy to manipulate the order of a linked

1222
00:24:27,750 --> 00:24:27,760
easy to manipulate the order of a linked
 

1223
00:24:27,760 --> 00:24:29,750
easy to manipulate the order of a linked
list without actually physically moving

1224
00:24:29,750 --> 00:24:29,760
list without actually physically moving
 

1225
00:24:29,760 --> 00:24:33,909
list without actually physically moving
nodes around whereas arrays

1226
00:24:33,909 --> 00:24:33,919
nodes around whereas arrays
 

1227
00:24:33,919 --> 00:24:35,350
nodes around whereas arrays
are problematic maybe it's worth

1228
00:24:35,350 --> 00:24:35,360
are problematic maybe it's worth
 

1229
00:24:35,360 --> 00:24:37,110
are problematic maybe it's worth
mentioning

1230
00:24:37,110 --> 00:24:37,120
mentioning
 

1231
00:24:37,120 --> 00:24:39,110
mentioning
let's start analyzing things so we care

1232
00:24:39,110 --> 00:24:39,120
let's start analyzing things so we care
 

1233
00:24:39,120 --> 00:24:41,029
let's start analyzing things so we care
about these dynamic sequence

1234
00:24:41,029 --> 00:24:41,039
about these dynamic sequence
 

1235
00:24:41,039 --> 00:24:44,630
about these dynamic sequence
operations and we could try to apply it

1236
00:24:44,630 --> 00:24:44,640
operations and we could try to apply it
 

1237
00:24:44,640 --> 00:24:47,830
operations and we could try to apply it
to the static array data structure or we

1238
00:24:47,830 --> 00:24:47,840
to the static array data structure or we
 

1239
00:24:47,840 --> 00:24:48,710
to the static array data structure or we
could try

1240
00:24:48,710 --> 00:24:48,720
could try
 

1241
00:24:48,720 --> 00:24:51,430
could try
to or sorry we could try to implement

1242
00:24:51,430 --> 00:24:51,440
to or sorry we could try to implement
 

1243
00:24:51,440 --> 00:24:53,830
to or sorry we could try to implement
these operations in a static array

1244
00:24:53,830 --> 00:24:53,840
these operations in a static array
 

1245
00:24:53,840 --> 00:24:56,310
these operations in a static array
it's possible just not going to be very

1246
00:24:56,310 --> 00:24:56,320
it's possible just not going to be very
 

1247
00:24:56,320 --> 00:24:57,590
it's possible just not going to be very
good

1248
00:24:57,590 --> 00:24:57,600
good
 

1249
00:24:57,600 --> 00:24:59,110
good
and we can try to implement it with

1250
00:24:59,110 --> 00:24:59,120
and we can try to implement it with
 

1251
00:24:59,120 --> 00:25:00,789
and we can try to implement it with
linked lists and it's also

1252
00:25:00,789 --> 00:25:00,799
linked lists and it's also
 

1253
00:25:00,799 --> 00:25:04,310
linked lists and it's also
not going to be that great let's

1254
00:25:04,310 --> 00:25:04,320
not going to be that great let's
 

1255
00:25:04,320 --> 00:25:11,029
not going to be that great let's
go over here

1256
00:25:11,029 --> 00:25:11,039

 

1257
00:25:11,039 --> 00:25:12,950

our goal is the next data structure

1258
00:25:12,950 --> 00:25:12,960
our goal is the next data structure
 

1259
00:25:12,960 --> 00:25:14,789
our goal is the next data structure
which is dynamic arrays

1260
00:25:14,789 --> 00:25:14,799
which is dynamic arrays
 

1261
00:25:14,799 --> 00:25:16,549
which is dynamic arrays
but linked lists and static arrays each

1262
00:25:16,549 --> 00:25:16,559
but linked lists and static arrays each
 

1263
00:25:16,559 --> 00:25:22,149
but linked lists and static arrays each
have their advantages

1264
00:25:22,149 --> 00:25:22,159

 

1265
00:25:22,159 --> 00:25:29,029

so let's first analyze dynamic

1266
00:25:29,029 --> 00:25:29,039
so let's first analyze dynamic
 

1267
00:25:29,039 --> 00:25:32,789
so let's first analyze dynamic
sequence operations

1268
00:25:32,789 --> 00:25:32,799

 

1269
00:25:32,799 --> 00:25:39,909

um first on a static array

1270
00:25:39,909 --> 00:25:39,919

 

1271
00:25:39,919 --> 00:25:46,470

and then on a linked list

1272
00:25:46,470 --> 00:25:46,480

 

1273
00:25:46,480 --> 00:25:49,510

so in a static array i think you all

1274
00:25:49,510 --> 00:25:49,520
so in a static array i think you all
 

1275
00:25:49,520 --> 00:25:53,110
so in a static array i think you all
see if i try to insert at the beginning

1276
00:25:53,110 --> 00:25:53,120
see if i try to insert at the beginning
 

1277
00:25:53,120 --> 00:25:54,549
see if i try to insert at the beginning
of the static array that's kind of the

1278
00:25:54,549 --> 00:25:54,559
of the static array that's kind of the
 

1279
00:25:54,559 --> 00:25:55,510
of the static array that's kind of the
worst case

1280
00:25:55,510 --> 00:25:55,520
worst case
 

1281
00:25:55,520 --> 00:25:59,029
worst case
if i insert first then everybody has to

1282
00:25:59,029 --> 00:25:59,039
if i insert first then everybody has to
 

1283
00:25:59,039 --> 00:25:59,830
if i insert first then everybody has to
shift over

1284
00:25:59,830 --> 00:25:59,840
shift over
 

1285
00:25:59,840 --> 00:26:01,750
shift over
if i'm going to maintain this invariant

1286
00:26:01,750 --> 00:26:01,760
if i'm going to maintain this invariant
 

1287
00:26:01,760 --> 00:26:04,230
if i'm going to maintain this invariant
that the ith item in the array

1288
00:26:04,230 --> 00:26:04,240
that the ith item in the array
 

1289
00:26:04,240 --> 00:26:06,549
that the ith item in the array
represents i guess i didn't write it

1290
00:26:06,549 --> 00:26:06,559
represents i guess i didn't write it
 

1291
00:26:06,559 --> 00:26:08,950
represents i guess i didn't write it
anywhere here

1292
00:26:08,950 --> 00:26:08,960
anywhere here
 

1293
00:26:08,960 --> 00:26:14,470
anywhere here
maybe here

1294
00:26:14,470 --> 00:26:14,480

 

1295
00:26:14,480 --> 00:26:16,390

static array we're going to maintain

1296
00:26:16,390 --> 00:26:16,400
static array we're going to maintain
 

1297
00:26:16,400 --> 00:26:18,230
static array we're going to maintain
this invariant that a of i

1298
00:26:18,230 --> 00:26:18,240
this invariant that a of i
 

1299
00:26:18,240 --> 00:26:21,430
this invariant that a of i
represents x i

1300
00:26:21,430 --> 00:26:21,440
represents x i
 

1301
00:26:21,440 --> 00:26:23,350
represents x i
okay if i want to maintain that at all

1302
00:26:23,350 --> 00:26:23,360
okay if i want to maintain that at all
 

1303
00:26:23,360 --> 00:26:25,190
okay if i want to maintain that at all
times when i insert a new thing in the

1304
00:26:25,190 --> 00:26:25,200
times when i insert a new thing in the
 

1305
00:26:25,200 --> 00:26:26,710
times when i insert a new thing in the
front because the indices of all the

1306
00:26:26,710 --> 00:26:26,720
front because the indices of all the
 

1307
00:26:26,720 --> 00:26:27,750
front because the indices of all the
previous items change

1308
00:26:27,750 --> 00:26:27,760
previous items change
 

1309
00:26:27,760 --> 00:26:29,990
previous items change
i have to spend time to copy those over

1310
00:26:29,990 --> 00:26:30,000
i have to spend time to copy those over
 

1311
00:26:30,000 --> 00:26:31,669
i have to spend time to copy those over
you can do it in linear time

1312
00:26:31,669 --> 00:26:31,679
you can do it in linear time
 

1313
00:26:31,679 --> 00:26:35,909
you can do it in linear time
but no better okay so

1314
00:26:35,909 --> 00:26:35,919
but no better okay so
 

1315
00:26:35,919 --> 00:26:39,190
but no better okay so
static array

1316
00:26:39,190 --> 00:26:39,200

 

1317
00:26:39,200 --> 00:26:44,710

insert and delete

1318
00:26:44,710 --> 00:26:44,720

 

1319
00:26:44,720 --> 00:26:50,830

anywhere

1320
00:26:50,830 --> 00:26:50,840

 

1321
00:26:50,840 --> 00:26:52,230

cost

1322
00:26:52,230 --> 00:26:52,240
cost
 

1323
00:26:52,240 --> 00:26:55,830
cost
and time

1324
00:26:55,830 --> 00:26:55,840

 

1325
00:26:55,840 --> 00:26:58,710

actually uh for two reasons uh reason

1326
00:26:58,710 --> 00:26:58,720
actually uh for two reasons uh reason
 

1327
00:26:58,720 --> 00:26:59,750
actually uh for two reasons uh reason
number one

1328
00:26:59,750 --> 00:26:59,760
number one
 

1329
00:26:59,760 --> 00:27:03,269
number one
is that uh if we're near the front

1330
00:27:03,269 --> 00:27:03,279
is that uh if we're near the front
 

1331
00:27:03,279 --> 00:27:07,510
is that uh if we're near the front
then we have to do shifting

1332
00:27:07,510 --> 00:27:07,520
then we have to do shifting
 

1333
00:27:07,520 --> 00:27:10,470
then we have to do shifting
okay what about insert or delete the

1334
00:27:10,470 --> 00:27:10,480
okay what about insert or delete the
 

1335
00:27:10,480 --> 00:27:13,510
okay what about insert or delete the
last element of an array

1336
00:27:13,510 --> 00:27:13,520
last element of an array
 

1337
00:27:13,520 --> 00:27:16,230
last element of an array
is that any easier because then if i

1338
00:27:16,230 --> 00:27:16,240
is that any easier because then if i
 

1339
00:27:16,240 --> 00:27:17,750
is that any easier because then if i
insert the very last element

1340
00:27:17,750 --> 00:27:17,760
insert the very last element
 

1341
00:27:17,760 --> 00:27:19,190
insert the very last element
none of the indices change i'm just

1342
00:27:19,190 --> 00:27:19,200
none of the indices change i'm just
 

1343
00:27:19,200 --> 00:27:23,990
none of the indices change i'm just
adding a new element

1344
00:27:23,990 --> 00:27:24,000

 

1345
00:27:24,000 --> 00:27:28,549

so i don't have to do shifting

1346
00:27:28,549 --> 00:27:28,559

 

1347
00:27:28,559 --> 00:27:31,029

so can i do insert and delete last in

1348
00:27:31,029 --> 00:27:31,039
so can i do insert and delete last in
 

1349
00:27:31,039 --> 00:27:39,830
so can i do insert and delete last in
constant time in a static array

1350
00:27:39,830 --> 00:27:39,840

 

1351
00:27:39,840 --> 00:27:41,510

no because the size is constant so our

1352
00:27:41,510 --> 00:27:41,520
no because the size is constant so our
 

1353
00:27:41,520 --> 00:27:43,590
no because the size is constant so our
model is that

1354
00:27:43,590 --> 00:27:43,600
model is that
 

1355
00:27:43,600 --> 00:27:45,750
model is that
uh remember our allocation model is that

1356
00:27:45,750 --> 00:27:45,760
uh remember our allocation model is that
 

1357
00:27:45,760 --> 00:27:48,230
uh remember our allocation model is that
we can allocate a static array

1358
00:27:48,230 --> 00:27:48,240
we can allocate a static array
 

1359
00:27:48,240 --> 00:27:51,669
we can allocate a static array
of size n but it's just a size n i can't

1360
00:27:51,669 --> 00:27:51,679
of size n but it's just a size n i can't
 

1361
00:27:51,679 --> 00:27:52,310
of size n but it's just a size n i can't
just say

1362
00:27:52,310 --> 00:27:52,320
just say
 

1363
00:27:52,320 --> 00:27:54,710
just say
please make it bigger by one i need i

1364
00:27:54,710 --> 00:27:54,720
please make it bigger by one i need i
 

1365
00:27:54,720 --> 00:27:56,950
please make it bigger by one i need i
need space to store this extra element

1366
00:27:56,950 --> 00:27:56,960
need space to store this extra element
 

1367
00:27:56,960 --> 00:27:58,870
need space to store this extra element
and if you think about where things are

1368
00:27:58,870 --> 00:27:58,880
and if you think about where things are
 

1369
00:27:58,880 --> 00:28:00,389
and if you think about where things are
in memory when you

1370
00:28:00,389 --> 00:28:00,399
in memory when you
 

1371
00:28:00,399 --> 00:28:02,230
in memory when you
call to this memory allocator which is

1372
00:28:02,230 --> 00:28:02,240
call to this memory allocator which is
 

1373
00:28:02,240 --> 00:28:03,669
call to this memory allocator which is
part of your operating system you say

1374
00:28:03,669 --> 00:28:03,679
part of your operating system you say
 

1375
00:28:03,679 --> 00:28:06,149
part of your operating system you say
please give me

1376
00:28:06,149 --> 00:28:06,159
please give me
 

1377
00:28:06,159 --> 00:28:08,470
please give me
some a chunk of memory it's going to

1378
00:28:08,470 --> 00:28:08,480
some a chunk of memory it's going to
 

1379
00:28:08,480 --> 00:28:10,389
some a chunk of memory it's going to
place them in various places in memory

1380
00:28:10,389 --> 00:28:10,399
place them in various places in memory
 

1381
00:28:10,399 --> 00:28:11,669
place them in various places in memory
and some of them might be next to each

1382
00:28:11,669 --> 00:28:11,679
and some of them might be next to each
 

1383
00:28:11,679 --> 00:28:12,710
and some of them might be next to each
other

1384
00:28:12,710 --> 00:28:12,720
other
 

1385
00:28:12,720 --> 00:28:14,630
other
so if i try to grow this array by one

1386
00:28:14,630 --> 00:28:14,640
so if i try to grow this array by one
 

1387
00:28:14,640 --> 00:28:15,990
so if i try to grow this array by one
there might already be something

1388
00:28:15,990 --> 00:28:16,000
there might already be something
 

1389
00:28:16,000 --> 00:28:17,430
there might already be something
there and that's not possible without

1390
00:28:17,430 --> 00:28:17,440
there and that's not possible without
 

1391
00:28:17,440 --> 00:28:19,350
there and that's not possible without
first shifting so even though in the

1392
00:28:19,350 --> 00:28:19,360
first shifting so even though in the
 

1393
00:28:19,360 --> 00:28:20,870
first shifting so even though in the
array i don't have to do any shifting in

1394
00:28:20,870 --> 00:28:20,880
array i don't have to do any shifting in
 

1395
00:28:20,880 --> 00:28:22,549
array i don't have to do any shifting in
memory i might have to do shifting

1396
00:28:22,549 --> 00:28:22,559
memory i might have to do shifting
 

1397
00:28:22,559 --> 00:28:24,630
memory i might have to do shifting
and that's outside the model so we're

1398
00:28:24,630 --> 00:28:24,640
and that's outside the model so we're
 

1399
00:28:24,640 --> 00:28:26,149
and that's outside the model so we're
going to stick to this model of just

1400
00:28:26,149 --> 00:28:26,159
going to stick to this model of just
 

1401
00:28:26,159 --> 00:28:27,590
going to stick to this model of just
you can allocate memory you can also

1402
00:28:27,590 --> 00:28:27,600
you can allocate memory you can also
 

1403
00:28:27,600 --> 00:28:30,230
you can allocate memory you can also
de-allocate memory just to keep space

1404
00:28:30,230 --> 00:28:30,240
de-allocate memory just to keep space
 

1405
00:28:30,240 --> 00:28:33,990
de-allocate memory just to keep space
usage small but the only way to get more

1406
00:28:33,990 --> 00:28:34,000
usage small but the only way to get more
 

1407
00:28:34,000 --> 00:28:35,830
usage small but the only way to get more
space is to ask for a new array and that

1408
00:28:35,830 --> 00:28:35,840
space is to ask for a new array and that
 

1409
00:28:35,840 --> 00:28:37,590
space is to ask for a new array and that
new array won't be contiguous to your

1410
00:28:37,590 --> 00:28:37,600
new array won't be contiguous to your
 

1411
00:28:37,600 --> 00:28:38,549
new array won't be contiguous to your
old one

1412
00:28:38,549 --> 00:28:38,559
old one
 

1413
00:28:38,559 --> 00:28:46,630
old one
so question

1414
00:28:46,630 --> 00:28:46,640

 

1415
00:28:46,640 --> 00:28:48,310

uh what is a dynamic array will be the

1416
00:28:48,310 --> 00:28:48,320
uh what is a dynamic array will be the
 

1417
00:28:48,320 --> 00:28:49,990
uh what is a dynamic array will be the
next topic so maybe we'll come back to

1418
00:28:49,990 --> 00:28:50,000
next topic so maybe we'll come back to
 

1419
00:28:50,000 --> 00:28:50,549
next topic so maybe we'll come back to
that

1420
00:28:50,549 --> 00:28:50,559
that
 

1421
00:28:50,559 --> 00:28:53,350
that
yeah okay so in a static array you're

1422
00:28:53,350 --> 00:28:53,360
yeah okay so in a static array you're
 

1423
00:28:53,360 --> 00:28:55,269
yeah okay so in a static array you're
just not allowed to make it bigger

1424
00:28:55,269 --> 00:28:55,279
just not allowed to make it bigger
 

1425
00:28:55,279 --> 00:29:00,070
just not allowed to make it bigger
and so you have to allocate a new array

1426
00:29:00,070 --> 00:29:00,080
and so you have to allocate a new array
 

1427
00:29:00,080 --> 00:29:02,070
and so you have to allocate a new array
which we say takes linear time even if

1428
00:29:02,070 --> 00:29:02,080
which we say takes linear time even if
 

1429
00:29:02,080 --> 00:29:03,430
which we say takes linear time even if
allocating the new array didn't take

1430
00:29:03,430 --> 00:29:03,440
allocating the new array didn't take
 

1431
00:29:03,440 --> 00:29:04,950
allocating the new array didn't take
linear time

1432
00:29:04,950 --> 00:29:04,960
linear time
 

1433
00:29:04,960 --> 00:29:07,269
linear time
you have to copy all the elements over

1434
00:29:07,269 --> 00:29:07,279
you have to copy all the elements over
 

1435
00:29:07,279 --> 00:29:08,710
you have to copy all the elements over
from the old array to the new one then

1436
00:29:08,710 --> 00:29:08,720
from the old array to the new one then
 

1437
00:29:08,720 --> 00:29:11,190
from the old array to the new one then
you can throw away the old one

1438
00:29:11,190 --> 00:29:11,200
you can throw away the old one
 

1439
00:29:11,200 --> 00:29:14,230
you can throw away the old one
so just the copying from an array of

1440
00:29:14,230 --> 00:29:14,240
so just the copying from an array of
 

1441
00:29:14,240 --> 00:29:16,310
so just the copying from an array of
size n to an array of size n plus one

1442
00:29:16,310 --> 00:29:16,320
size n to an array of size n plus one
 

1443
00:29:16,320 --> 00:29:17,750
size n to an array of size n plus one
that will take linear time so static

1444
00:29:17,750 --> 00:29:17,760
that will take linear time so static
 

1445
00:29:17,760 --> 00:29:19,590
that will take linear time so static
arrays are really bad for

1446
00:29:19,590 --> 00:29:19,600
arrays are really bad for
 

1447
00:29:19,600 --> 00:29:21,830
arrays are really bad for
dynamic operations no surprise but you

1448
00:29:21,830 --> 00:29:21,840
dynamic operations no surprise but you
 

1449
00:29:21,840 --> 00:29:22,870
dynamic operations no surprise but you
could do them

1450
00:29:22,870 --> 00:29:22,880
could do them
 

1451
00:29:22,880 --> 00:29:26,389
could do them
okay that's static array now linked

1452
00:29:26,389 --> 00:29:26,399
okay that's static array now linked
 

1453
00:29:26,399 --> 00:29:27,830
okay that's static array now linked
lists are going to be almost the

1454
00:29:27,830 --> 00:29:27,840
lists are going to be almost the
 

1455
00:29:27,840 --> 00:29:29,909
lists are going to be almost the
opposite

1456
00:29:29,909 --> 00:29:29,919
opposite
 

1457
00:29:29,919 --> 00:29:34,310
opposite
well almost so if we store

1458
00:29:34,310 --> 00:29:34,320
well almost so if we store
 

1459
00:29:34,320 --> 00:29:36,070
well almost so if we store
the length okay we can compute the

1460
00:29:36,070 --> 00:29:36,080
the length okay we can compute the
 

1461
00:29:36,080 --> 00:29:39,430
the length okay we can compute the
length of the array very quickly

1462
00:29:39,430 --> 00:29:39,440
length of the array very quickly
 

1463
00:29:39,440 --> 00:29:43,269
length of the array very quickly
we can insert and delete at the front

1464
00:29:43,269 --> 00:29:43,279
we can insert and delete at the front
 

1465
00:29:43,279 --> 00:29:45,430
we can insert and delete at the front
really efficiently if i want to add a

1466
00:29:45,430 --> 00:29:45,440
really efficiently if i want to add a
 

1467
00:29:45,440 --> 00:29:46,630
really efficiently if i want to add a
new item

1468
00:29:46,630 --> 00:29:46,640
new item
 

1469
00:29:46,640 --> 00:29:50,470
new item
at the begin as a new first item

1470
00:29:50,470 --> 00:29:50,480
at the begin as a new first item
 

1471
00:29:50,480 --> 00:29:53,029
at the begin as a new first item
then what do i do i allocate a new node

1472
00:29:53,029 --> 00:29:53,039
then what do i do i allocate a new node
 

1473
00:29:53,039 --> 00:29:54,230
then what do i do i allocate a new node
which i'll call x

1474
00:29:54,230 --> 00:29:54,240
which i'll call x
 

1475
00:29:54,240 --> 00:29:57,269
which i'll call x
so this is insert

1476
00:29:57,269 --> 00:29:57,279
so this is insert
 

1477
00:29:57,279 --> 00:30:01,029
so this is insert
first of x

1478
00:30:01,029 --> 00:30:01,039
first of x
 

1479
00:30:01,039 --> 00:30:03,830
first of x
i'll allocate a new array size 2. i'm

1480
00:30:03,830 --> 00:30:03,840
i'll allocate a new array size 2. i'm
 

1481
00:30:03,840 --> 00:30:04,230
i'll allocate a new array size 2. i'm
going to

1482
00:30:04,230 --> 00:30:04,240
going to
 

1483
00:30:04,240 --> 00:30:08,070
going to
change let me do it in red

1484
00:30:08,070 --> 00:30:08,080
change let me do it in red
 

1485
00:30:08,080 --> 00:30:10,870
change let me do it in red
i'm going to change this head pointer uh

1486
00:30:10,870 --> 00:30:10,880
i'm going to change this head pointer uh
 

1487
00:30:10,880 --> 00:30:11,990
i'm going to change this head pointer uh
maybe i should do that

1488
00:30:11,990 --> 00:30:12,000
maybe i should do that
 

1489
00:30:12,000 --> 00:30:14,630
maybe i should do that
later so i'm going to set the next

1490
00:30:14,630 --> 00:30:14,640
later so i'm going to set the next
 

1491
00:30:14,640 --> 00:30:16,549
later so i'm going to set the next
pointer here to this one

1492
00:30:16,549 --> 00:30:16,559
pointer here to this one
 

1493
00:30:16,559 --> 00:30:17,909
pointer here to this one
and then i'm going to change this head

1494
00:30:17,909 --> 00:30:17,919
and then i'm going to change this head
 

1495
00:30:17,919 --> 00:30:20,630
and then i'm going to change this head
pointer to point to here

1496
00:30:20,630 --> 00:30:20,640
pointer to point to here
 

1497
00:30:20,640 --> 00:30:22,789
pointer to point to here
and boom now i've got a linked list

1498
00:30:22,789 --> 00:30:22,799
and boom now i've got a linked list
 

1499
00:30:22,799 --> 00:30:24,710
and boom now i've got a linked list
again we don't know anything about the

1500
00:30:24,710 --> 00:30:24,720
again we don't know anything about the
 

1501
00:30:24,720 --> 00:30:26,149
again we don't know anything about the
order and memory of these

1502
00:30:26,149 --> 00:30:26,159
order and memory of these
 

1503
00:30:26,159 --> 00:30:27,830
order and memory of these
these lists we just care about the order

1504
00:30:27,830 --> 00:30:27,840
these lists we just care about the order
 

1505
00:30:27,840 --> 00:30:29,269
these lists we just care about the order
that's represented implicitly by

1506
00:30:29,269 --> 00:30:29,279
that's represented implicitly by
 

1507
00:30:29,279 --> 00:30:32,310
that's represented implicitly by
following the next pointers repeatedly

1508
00:30:32,310 --> 00:30:32,320
following the next pointers repeatedly
 

1509
00:30:32,320 --> 00:30:34,070
following the next pointers repeatedly
so now i've got a new list that has x in

1510
00:30:34,070 --> 00:30:34,080
so now i've got a new list that has x in
 

1511
00:30:34,080 --> 00:30:36,710
so now i've got a new list that has x in
front and then x0 and then x1

1512
00:30:36,710 --> 00:30:36,720
front and then x0 and then x1
 

1513
00:30:36,720 --> 00:30:39,190
front and then x0 and then x1
and so on so insert and delete first at

1514
00:30:39,190 --> 00:30:39,200
and so on so insert and delete first at
 

1515
00:30:39,200 --> 00:30:40,950
and so on so insert and delete first at
least are really efficient

1516
00:30:40,950 --> 00:30:40,960
least are really efficient
 

1517
00:30:40,960 --> 00:30:43,510
least are really efficient
we won't get much more than that but a

1518
00:30:43,510 --> 00:30:43,520
we won't get much more than that but a
 

1519
00:30:43,520 --> 00:30:44,789
we won't get much more than that but a
linked list

1520
00:30:44,789 --> 00:30:44,799
linked list
 

1521
00:30:44,799 --> 00:30:52,389
linked list
insert and delete uh

1522
00:30:52,389 --> 00:30:52,399

 

1523
00:30:52,399 --> 00:31:00,230

first our constant time

1524
00:31:00,230 --> 00:31:00,240

 

1525
00:31:00,240 --> 00:31:03,750

so that's cool however everything else

1526
00:31:03,750 --> 00:31:03,760
so that's cool however everything else
 

1527
00:31:03,760 --> 00:31:05,029
so that's cool however everything else
is going to be slow

1528
00:31:05,029 --> 00:31:05,039
is going to be slow
 

1529
00:31:05,039 --> 00:31:09,350
is going to be slow
if i want to get the 10th item

1530
00:31:09,350 --> 00:31:09,360
if i want to get the 10th item
 

1531
00:31:09,360 --> 00:31:11,750
if i want to get the 10th item
in a linked list i have to follow these

1532
00:31:11,750 --> 00:31:11,760
in a linked list i have to follow these
 

1533
00:31:11,760 --> 00:31:12,630
in a linked list i have to follow these
pointers

1534
00:31:12,630 --> 00:31:12,640
pointers
 

1535
00:31:12,640 --> 00:31:15,830
pointers
10 times i go 0 0 1

1536
00:31:15,830 --> 00:31:15,840
10 times i go 0 0 1
 

1537
00:31:15,840 --> 00:31:18,789
10 times i go 0 0 1
2 3 and it's on follow ten next pointers

1538
00:31:18,789 --> 00:31:18,799
2 3 and it's on follow ten next pointers
 

1539
00:31:18,799 --> 00:31:20,870
2 3 and it's on follow ten next pointers
and i'll get the tenth item

1540
00:31:20,870 --> 00:31:20,880
and i'll get the tenth item
 

1541
00:31:20,880 --> 00:31:23,029
and i'll get the tenth item
accessing the item is gonna take order i

1542
00:31:23,029 --> 00:31:23,039
accessing the item is gonna take order i
 

1543
00:31:23,039 --> 00:31:24,549
accessing the item is gonna take order i
time

1544
00:31:24,549 --> 00:31:24,559
time
 

1545
00:31:24,559 --> 00:31:29,029
time
so uh

1546
00:31:29,029 --> 00:31:29,039

 

1547
00:31:29,039 --> 00:31:38,230

get and set at need

1548
00:31:38,230 --> 00:31:38,240

 

1549
00:31:38,240 --> 00:31:44,830

i time which in the worst case is theta

1550
00:31:44,830 --> 00:31:44,840

 

1551
00:31:44,840 --> 00:31:47,990

n

1552
00:31:47,990 --> 00:31:48,000

 

1553
00:31:48,000 --> 00:31:50,310

okay so we have sort of complementary

1554
00:31:50,310 --> 00:31:50,320
okay so we have sort of complementary
 

1555
00:31:50,320 --> 00:31:51,830
okay so we have sort of complementary
data structures here on the one hand a

1556
00:31:51,830 --> 00:31:51,840
data structures here on the one hand a
 

1557
00:31:51,840 --> 00:31:53,190
data structures here on the one hand a
static array

1558
00:31:53,190 --> 00:31:53,200
static array
 

1559
00:31:53,200 --> 00:31:55,350
static array
can do constant time get at set at so

1560
00:31:55,350 --> 00:31:55,360
can do constant time get at set at so
 

1561
00:31:55,360 --> 00:31:57,190
can do constant time get at set at so
it's very fast at the random access

1562
00:31:57,190 --> 00:31:57,200
it's very fast at the random access
 

1563
00:31:57,200 --> 00:31:59,029
it's very fast at the random access
aspect because it's an array

1564
00:31:59,029 --> 00:31:59,039
aspect because it's an array
 

1565
00:31:59,039 --> 00:32:00,470
aspect because it's an array
linked lists are very bad at random

1566
00:32:00,470 --> 00:32:00,480
linked lists are very bad at random
 

1567
00:32:00,480 --> 00:32:02,149
linked lists are very bad at random
access but they're

1568
00:32:02,149 --> 00:32:02,159
access but they're
 

1569
00:32:02,159 --> 00:32:04,710
access but they're
better at being dynamic we can insert

1570
00:32:04,710 --> 00:32:04,720
better at being dynamic we can insert
 

1571
00:32:04,720 --> 00:32:06,549
better at being dynamic we can insert
and delete at the beginning at least

1572
00:32:06,549 --> 00:32:06,559
and delete at the beginning at least
 

1573
00:32:06,559 --> 00:32:09,750
and delete at the beginning at least
in constant time now if we want to

1574
00:32:09,750 --> 00:32:09,760
in constant time now if we want to
 

1575
00:32:09,760 --> 00:32:11,190
in constant time now if we want to
actually insert a delete

1576
00:32:11,190 --> 00:32:11,200
actually insert a delete
 

1577
00:32:11,200 --> 00:32:13,269
actually insert a delete
at a particular position that's still

1578
00:32:13,269 --> 00:32:13,279
at a particular position that's still
 

1579
00:32:13,279 --> 00:32:14,630
at a particular position that's still
hard because we have to walk to that

1580
00:32:14,630 --> 00:32:14,640
hard because we have to walk to that
 

1581
00:32:14,640 --> 00:32:15,509
hard because we have to walk to that
position

1582
00:32:15,509 --> 00:32:15,519
position
 

1583
00:32:15,519 --> 00:32:17,190
position
even inserting and deleting at the end

1584
00:32:17,190 --> 00:32:17,200
even inserting and deleting at the end
 

1585
00:32:17,200 --> 00:32:18,710
even inserting and deleting at the end
of the list is hard

1586
00:32:18,710 --> 00:32:18,720
of the list is hard
 

1587
00:32:18,720 --> 00:32:23,110
of the list is hard
although that's fixable

1588
00:32:23,110 --> 00:32:23,120

 

1589
00:32:23,120 --> 00:32:25,110

and maybe i'll leave that for problem

1590
00:32:25,110 --> 00:32:25,120
and maybe i'll leave that for problem
 

1591
00:32:25,120 --> 00:32:26,549
and maybe i'll leave that for problem
session or problem set

1592
00:32:26,549 --> 00:32:26,559
session or problem set
 

1593
00:32:26,559 --> 00:32:30,549
session or problem set
but uh an easy so here's here's a small

1594
00:32:30,549 --> 00:32:30,559
but uh an easy so here's here's a small
 

1595
00:32:30,559 --> 00:32:31,110
but uh an easy so here's here's a small
puzzle

1596
00:32:31,110 --> 00:32:31,120
puzzle
 

1597
00:32:31,120 --> 00:32:34,149
puzzle
suppose you wanted to solve uh get

1598
00:32:34,149 --> 00:32:34,159
suppose you wanted to solve uh get
 

1599
00:32:34,159 --> 00:32:38,630
suppose you wanted to solve uh get
last efficiently in a linked list

1600
00:32:38,630 --> 00:32:38,640
last efficiently in a linked list
 

1601
00:32:38,640 --> 00:32:40,830
last efficiently in a linked list
how would you solve that in constant

1602
00:32:40,830 --> 00:32:40,840
how would you solve that in constant
 

1603
00:32:40,840 --> 00:32:43,430
how would you solve that in constant
time

1604
00:32:43,430 --> 00:32:43,440
time
 

1605
00:32:43,440 --> 00:32:47,269
time
yeah double a linked list is a good idea

1606
00:32:47,269 --> 00:32:47,279
yeah double a linked list is a good idea
 

1607
00:32:47,279 --> 00:32:49,269
yeah double a linked list is a good idea
but actually not the right answer

1608
00:32:49,269 --> 00:32:49,279
but actually not the right answer
 

1609
00:32:49,279 --> 00:32:50,870
but actually not the right answer
that's an answer to the next question i

1610
00:32:50,870 --> 00:32:50,880
that's an answer to the next question i
 

1611
00:32:50,880 --> 00:32:56,310
that's an answer to the next question i
might ask yeah

1612
00:32:56,310 --> 00:32:56,320
might ask yeah
 

1613
00:32:56,320 --> 00:32:57,909
might ask yeah
store pointer to the last element that's

1614
00:32:57,909 --> 00:32:57,919
store pointer to the last element that's
 

1615
00:32:57,919 --> 00:32:59,430
store pointer to the last element that's
all we need here

1616
00:32:59,430 --> 00:32:59,440
all we need here
 

1617
00:32:59,440 --> 00:33:02,950
all we need here
and often a doubly linked list has this

1618
00:33:02,950 --> 00:33:02,960
and often a doubly linked list has this
 

1619
00:33:02,960 --> 00:33:04,549
and often a doubly linked list has this
i usually call this the tail

1620
00:33:04,549 --> 00:33:04,559
i usually call this the tail
 

1621
00:33:04,559 --> 00:33:07,509
i usually call this the tail
head and tail and if you always just

1622
00:33:07,509 --> 00:33:07,519
head and tail and if you always just
 

1623
00:33:07,519 --> 00:33:08,710
head and tail and if you always just
store a pointer

1624
00:33:08,710 --> 00:33:08,720
store a pointer
 

1625
00:33:08,720 --> 00:33:10,870
store a pointer
to the last list this is what we call

1626
00:33:10,870 --> 00:33:10,880
to the last list this is what we call
 

1627
00:33:10,880 --> 00:33:12,789
to the last list this is what we call
data structure augmentation where we add

1628
00:33:12,789 --> 00:33:12,799
data structure augmentation where we add
 

1629
00:33:12,799 --> 00:33:14,310
data structure augmentation where we add
some extra information to the data

1630
00:33:14,310 --> 00:33:14,320
some extra information to the data
 

1631
00:33:14,320 --> 00:33:14,950
some extra information to the data
structure and

1632
00:33:14,950 --> 00:33:14,960
structure and
 

1633
00:33:14,960 --> 00:33:16,950
structure and
mean we have to keep it up to date all

1634
00:33:16,950 --> 00:33:16,960
mean we have to keep it up to date all
 

1635
00:33:16,960 --> 00:33:18,549
mean we have to keep it up to date all
the time so if we do

1636
00:33:18,549 --> 00:33:18,559
the time so if we do
 

1637
00:33:18,559 --> 00:33:20,950
the time so if we do
an insert last or something insert last

1638
00:33:20,950 --> 00:33:20,960
an insert last or something insert last
 

1639
00:33:20,960 --> 00:33:22,870
an insert last or something insert last
also becomes easy because i can just

1640
00:33:22,870 --> 00:33:22,880
also becomes easy because i can just
 

1641
00:33:22,880 --> 00:33:24,789
also becomes easy because i can just
add a new node here and update the

1642
00:33:24,789 --> 00:33:24,799
add a new node here and update the
 

1643
00:33:24,799 --> 00:33:27,110
add a new node here and update the
pointer here delete last is trickier

1644
00:33:27,110 --> 00:33:27,120
pointer here delete last is trickier
 

1645
00:33:27,120 --> 00:33:28,389
pointer here delete last is trickier
that's where you need a doubly linked

1646
00:33:28,389 --> 00:33:28,399
that's where you need a doubly linked
 

1647
00:33:28,399 --> 00:33:29,509
that's where you need a doubly linked
list

1648
00:33:29,509 --> 00:33:29,519
list
 

1649
00:33:29,519 --> 00:33:31,430
list
but whenever i add something to the end

1650
00:33:31,430 --> 00:33:31,440
but whenever i add something to the end
 

1651
00:33:31,440 --> 00:33:33,110
but whenever i add something to the end
of this list i have to update the tail

1652
00:33:33,110 --> 00:33:33,120
of this list i have to update the tail
 

1653
00:33:33,120 --> 00:33:34,310
of this list i have to update the tail
pointer also

1654
00:33:34,310 --> 00:33:34,320
pointer also
 

1655
00:33:34,320 --> 00:33:36,149
pointer also
as long as i maintain this now suddenly

1656
00:33:36,149 --> 00:33:36,159
as long as i maintain this now suddenly
 

1657
00:33:36,159 --> 00:33:38,230
as long as i maintain this now suddenly
get last as fast in constant time

1658
00:33:38,230 --> 00:33:38,240
get last as fast in constant time
 

1659
00:33:38,240 --> 00:33:39,430
get last as fast in constant time
so link lists are great if you're

1660
00:33:39,430 --> 00:33:39,440
so link lists are great if you're
 

1661
00:33:39,440 --> 00:33:41,990
so link lists are great if you're
working on the ends even dynamically

1662
00:33:41,990 --> 00:33:42,000
working on the ends even dynamically
 

1663
00:33:42,000 --> 00:33:43,909
working on the ends even dynamically
arrays are great if you're doing random

1664
00:33:43,909 --> 00:33:43,919
arrays are great if you're doing random
 

1665
00:33:43,919 --> 00:33:45,750
arrays are great if you're doing random
access and nothing dynamic nothing

1666
00:33:45,750 --> 00:33:45,760
access and nothing dynamic nothing
 

1667
00:33:45,760 --> 00:33:46,389
access and nothing dynamic nothing
adding

1668
00:33:46,389 --> 00:33:46,399
adding
 

1669
00:33:46,399 --> 00:33:49,909
adding
or deleting at the ends or in the middle

1670
00:33:49,909 --> 00:33:49,919
or deleting at the ends or in the middle
 

1671
00:33:49,919 --> 00:33:53,110
or deleting at the ends or in the middle
okay so our final goal for today

1672
00:33:53,110 --> 00:33:53,120
okay so our final goal for today
 

1673
00:33:53,120 --> 00:33:55,269
okay so our final goal for today
is to get sort of the best of both

1674
00:33:55,269 --> 00:33:55,279
is to get sort of the best of both
 

1675
00:33:55,279 --> 00:33:56,950
is to get sort of the best of both
worlds with dynamic arrays we're going

1676
00:33:56,950 --> 00:33:56,960
worlds with dynamic arrays we're going
 

1677
00:33:56,960 --> 00:33:58,710
worlds with dynamic arrays we're going
to try to get

1678
00:33:58,710 --> 00:33:58,720
to try to get
 

1679
00:33:58,720 --> 00:34:00,230
to try to get
all the good running times of linked

1680
00:34:00,230 --> 00:34:00,240
all the good running times of linked
 

1681
00:34:00,240 --> 00:34:01,990
all the good running times of linked
lists and all the good running times of

1682
00:34:01,990 --> 00:34:02,000
lists and all the good running times of
 

1683
00:34:02,000 --> 00:34:03,350
lists and all the good running times of
static arrays

1684
00:34:03,350 --> 00:34:03,360
static arrays
 

1685
00:34:03,360 --> 00:34:04,950
static arrays
we won't get quite all of them but most

1686
00:34:04,950 --> 00:34:04,960
we won't get quite all of them but most
 

1687
00:34:04,960 --> 00:34:07,360
we won't get quite all of them but most
of them

1688
00:34:07,360 --> 00:34:07,370
of them
 

1689
00:34:07,370 --> 00:34:12,069
of them
[Applause]

1690
00:34:12,069 --> 00:34:12,079

 

1691
00:34:12,079 --> 00:34:17,270

and in some sense

1692
00:34:17,270 --> 00:34:17,280
and in some sense
 

1693
00:34:17,280 --> 00:34:20,710
and in some sense
another way to describe what these

1694
00:34:20,710 --> 00:34:20,720
another way to describe what these
 

1695
00:34:20,720 --> 00:34:23,270
another way to describe what these
introductory lectures are about is

1696
00:34:23,270 --> 00:34:23,280
introductory lectures are about is
 

1697
00:34:23,280 --> 00:34:25,030
introductory lectures are about is
telling you about how python

1698
00:34:25,030 --> 00:34:25,040
telling you about how python
 

1699
00:34:25,040 --> 00:34:27,750
telling you about how python
is implemented so what we're going to

1700
00:34:27,750 --> 00:34:27,760
is implemented so what we're going to
 

1701
00:34:27,760 --> 00:34:31,030
is implemented so what we're going to
talk about next dynamic arrays

1702
00:34:31,030 --> 00:34:31,040
talk about next dynamic arrays
 

1703
00:34:31,040 --> 00:34:36,470
talk about next dynamic arrays
i've alluded to many times but these are

1704
00:34:36,470 --> 00:34:36,480

 

1705
00:34:36,480 --> 00:34:42,950

what python calls lists

1706
00:34:42,950 --> 00:34:42,960

 

1707
00:34:42,960 --> 00:34:45,270

so you don't have to implement a dynamic

1708
00:34:45,270 --> 00:34:45,280
so you don't have to implement a dynamic
 

1709
00:34:45,280 --> 00:34:47,109
so you don't have to implement a dynamic
array by hand because it's already built

1710
00:34:47,109 --> 00:34:47,119
array by hand because it's already built
 

1711
00:34:47,119 --> 00:34:50,629
array by hand because it's already built
into many fancy new languages

1712
00:34:50,629 --> 00:34:50,639
into many fancy new languages
 

1713
00:34:50,639 --> 00:34:53,430
into many fancy new languages
for free because they're so darn useful

1714
00:34:53,430 --> 00:34:53,440
for free because they're so darn useful
 

1715
00:34:53,440 --> 00:34:54,470
for free because they're so darn useful
this lecture is about

1716
00:34:54,470 --> 00:34:54,480
this lecture is about
 

1717
00:34:54,480 --> 00:34:56,230
this lecture is about
how these are actually implemented and

1718
00:34:56,230 --> 00:34:56,240
how these are actually implemented and
 

1719
00:34:56,240 --> 00:34:59,030
how these are actually implemented and
why they're efficient

1720
00:34:59,030 --> 00:34:59,040
why they're efficient
 

1721
00:34:59,040 --> 00:35:00,870
why they're efficient
and in recitation notes you'll see how

1722
00:35:00,870 --> 00:35:00,880
and in recitation notes you'll see how
 

1723
00:35:00,880 --> 00:35:02,310
and in recitation notes you'll see how
to actually implement them if all you

1724
00:35:02,310 --> 00:35:02,320
to actually implement them if all you
 

1725
00:35:02,320 --> 00:35:04,310
to actually implement them if all you
had were static arrays

1726
00:35:04,310 --> 00:35:04,320
had were static arrays
 

1727
00:35:04,320 --> 00:35:06,230
had were static arrays
but luckily we have dynamic arrays so we

1728
00:35:06,230 --> 00:35:06,240
but luckily we have dynamic arrays so we
 

1729
00:35:06,240 --> 00:35:07,430
but luckily we have dynamic arrays so we
don't have to

1730
00:35:07,430 --> 00:35:07,440
don't have to
 

1731
00:35:07,440 --> 00:35:09,430
don't have to
actually implement them but in the in

1732
00:35:09,430 --> 00:35:09,440
actually implement them but in the in
 

1733
00:35:09,440 --> 00:35:11,270
actually implement them but in the in
inside the python interpreter

1734
00:35:11,270 --> 00:35:11,280
inside the python interpreter
 

1735
00:35:11,280 --> 00:35:14,310
inside the python interpreter
this is exactly what's happening okay so

1736
00:35:14,310 --> 00:35:14,320
this is exactly what's happening okay so
 

1737
00:35:14,320 --> 00:35:17,589
this is exactly what's happening okay so
the idea is to

1738
00:35:17,589 --> 00:35:17,599
the idea is to
 

1739
00:35:17,599 --> 00:35:21,030
the idea is to
relax the

1740
00:35:21,030 --> 00:35:21,040
relax the
 

1741
00:35:21,040 --> 00:35:25,109
relax the
constraint or the invariant whatever

1742
00:35:25,109 --> 00:35:25,119
constraint or the invariant whatever
 

1743
00:35:25,119 --> 00:35:30,390
constraint or the invariant whatever
that the size of the array we use

1744
00:35:30,390 --> 00:35:30,400
that the size of the array we use
 

1745
00:35:30,400 --> 00:35:34,950
that the size of the array we use
equals n which is the number of

1746
00:35:34,950 --> 00:35:34,960
equals n which is the number of
 

1747
00:35:34,960 --> 00:35:40,390
equals n which is the number of
items in the sequence

1748
00:35:40,390 --> 00:35:40,400

 

1749
00:35:40,400 --> 00:35:41,990

okay remember in the sequence problem

1750
00:35:41,990 --> 00:35:42,000
okay remember in the sequence problem
 

1751
00:35:42,000 --> 00:35:44,390
okay remember in the sequence problem
we're supposed to represent n items

1752
00:35:44,390 --> 00:35:44,400
we're supposed to represent n items
 

1753
00:35:44,400 --> 00:35:46,150
we're supposed to represent n items
with a static array we allocated an

1754
00:35:46,150 --> 00:35:46,160
with a static array we allocated an
 

1755
00:35:46,160 --> 00:35:48,630
with a static array we allocated an
array of size exactly n

1756
00:35:48,630 --> 00:35:48,640
array of size exactly n
 

1757
00:35:48,640 --> 00:35:50,230
array of size exactly n
so let's relax that let's not make it

1758
00:35:50,230 --> 00:35:50,240
so let's relax that let's not make it
 

1759
00:35:50,240 --> 00:35:52,310
so let's relax that let's not make it
exactly n let's make it

1760
00:35:52,310 --> 00:35:52,320
exactly n let's make it
 

1761
00:35:52,320 --> 00:35:55,430
exactly n let's make it
roughly n how roughly you can think

1762
00:35:55,430 --> 00:35:55,440
roughly n how roughly you can think
 

1763
00:35:55,440 --> 00:35:56,550
roughly n how roughly you can think
about for a while

1764
00:35:56,550 --> 00:35:56,560
about for a while
 

1765
00:35:56,560 --> 00:35:59,030
about for a while
uh but the from an algorithm's

1766
00:35:59,030 --> 00:35:59,040
uh but the from an algorithm's
 

1767
00:35:59,040 --> 00:36:00,710
uh but the from an algorithm's
perspective usually that when we say

1768
00:36:00,710 --> 00:36:00,720
perspective usually that when we say
 

1769
00:36:00,720 --> 00:36:01,349
perspective usually that when we say
roughly

1770
00:36:01,349 --> 00:36:01,359
roughly
 

1771
00:36:01,359 --> 00:36:03,109
roughly
we mean throw away constant factors and

1772
00:36:03,109 --> 00:36:03,119
we mean throw away constant factors and
 

1773
00:36:03,119 --> 00:36:04,310
we mean throw away constant factors and
that turns out to be the right answer

1774
00:36:04,310 --> 00:36:04,320
that turns out to be the right answer
 

1775
00:36:04,320 --> 00:36:05,910
that turns out to be the right answer
here it's not always the right answer

1776
00:36:05,910 --> 00:36:05,920
here it's not always the right answer
 

1777
00:36:05,920 --> 00:36:09,190
here it's not always the right answer
but we're gonna uh enforce

1778
00:36:09,190 --> 00:36:09,200
but we're gonna uh enforce
 

1779
00:36:09,200 --> 00:36:12,310
but we're gonna uh enforce
uh that the size of the array is

1780
00:36:12,310 --> 00:36:12,320
uh that the size of the array is
 

1781
00:36:12,320 --> 00:36:15,190
uh that the size of the array is
theta m probably also greater than or

1782
00:36:15,190 --> 00:36:15,200
theta m probably also greater than or
 

1783
00:36:15,200 --> 00:36:15,829
theta m probably also greater than or
equal to n

1784
00:36:15,829 --> 00:36:15,839
equal to n
 

1785
00:36:15,839 --> 00:36:18,470
equal to n
0.5 n would not be very helpful so it's

1786
00:36:18,470 --> 00:36:18,480
0.5 n would not be very helpful so it's
 

1787
00:36:18,480 --> 00:36:19,270
0.5 n would not be very helpful so it's
going to be at least

1788
00:36:19,270 --> 00:36:19,280
going to be at least
 

1789
00:36:19,280 --> 00:36:22,710
going to be at least
n and it's going to be at most

1790
00:36:22,710 --> 00:36:22,720
n and it's going to be at most
 

1791
00:36:22,720 --> 00:36:26,230
n and it's going to be at most
some constant times n 2n

1792
00:36:26,230 --> 00:36:26,240
some constant times n 2n
 

1793
00:36:26,240 --> 00:36:29,109
some constant times n 2n
10n 1.1 times n any of these constants

1794
00:36:29,109 --> 00:36:29,119
10n 1.1 times n any of these constants
 

1795
00:36:29,119 --> 00:36:30,790
10n 1.1 times n any of these constants
will work i'm going to use 2n

1796
00:36:30,790 --> 00:36:30,800
will work i'm going to use 2n
 

1797
00:36:30,800 --> 00:36:34,550
will work i'm going to use 2n
here but there are lots of options

1798
00:36:34,550 --> 00:36:34,560
here but there are lots of options
 

1799
00:36:34,560 --> 00:36:37,990
here but there are lots of options
uh and now things almost work

1800
00:36:37,990 --> 00:36:38,000
uh and now things almost work
 

1801
00:36:38,000 --> 00:36:39,270
uh and now things almost work
for free there's going to be one

1802
00:36:39,270 --> 00:36:39,280
for free there's going to be one
 

1803
00:36:39,280 --> 00:36:41,430
for free there's going to be one
subtlety here

1804
00:36:41,430 --> 00:36:41,440
subtlety here
 

1805
00:36:41,440 --> 00:36:44,470
subtlety here
and i'm going to focus on we're still

1806
00:36:44,470 --> 00:36:44,480
and i'm going to focus on we're still
 

1807
00:36:44,480 --> 00:36:48,550
and i'm going to focus on we're still
going to maintain

1808
00:36:48,550 --> 00:36:48,560

 

1809
00:36:48,560 --> 00:36:51,589

that the item of the array is

1810
00:36:51,589 --> 00:36:51,599
that the item of the array is
 

1811
00:36:51,599 --> 00:36:54,790
that the item of the array is
represents x i okay so this data

1812
00:36:54,790 --> 00:36:54,800
represents x i okay so this data
 

1813
00:36:54,800 --> 00:36:55,910
represents x i okay so this data
structure

1814
00:36:55,910 --> 00:36:55,920
structure
 

1815
00:36:55,920 --> 00:36:58,470
structure
let me draw a picture so we've got an

1816
00:36:58,470 --> 00:36:58,480
let me draw a picture so we've got an
 

1817
00:36:58,480 --> 00:36:59,990
let me draw a picture so we've got an
array of some size

1818
00:36:59,990 --> 00:37:00,000
array of some size
 

1819
00:37:00,000 --> 00:37:03,589
array of some size
the first few items

1820
00:37:03,589 --> 00:37:03,599
the first few items
 

1821
00:37:03,599 --> 00:37:06,870
the first few items
are used to store

1822
00:37:06,870 --> 00:37:06,880

 

1823
00:37:06,880 --> 00:37:08,310

the sequence but then there's going to

1824
00:37:08,310 --> 00:37:08,320
the sequence but then there's going to
 

1825
00:37:08,320 --> 00:37:10,710
the sequence but then there's going to
be some blank ones at the end

1826
00:37:10,710 --> 00:37:10,720
be some blank ones at the end
 

1827
00:37:10,720 --> 00:37:13,349
be some blank ones at the end
okay maybe we'll keep track of this so

1828
00:37:13,349 --> 00:37:13,359
okay maybe we'll keep track of this so
 

1829
00:37:13,359 --> 00:37:14,870
okay maybe we'll keep track of this so
the data structure itself

1830
00:37:14,870 --> 00:37:14,880
the data structure itself
 

1831
00:37:14,880 --> 00:37:16,550
the data structure itself
is going to have an array and it's going

1832
00:37:16,550 --> 00:37:16,560
is going to have an array and it's going
 

1833
00:37:16,560 --> 00:37:18,950
is going to have an array and it's going
to have a length

1834
00:37:18,950 --> 00:37:18,960
to have a length
 

1835
00:37:18,960 --> 00:37:20,470
to have a length
something like this so we're also going

1836
00:37:20,470 --> 00:37:20,480
something like this so we're also going
 

1837
00:37:20,480 --> 00:37:21,990
something like this so we're also going
to keep track of the length so

1838
00:37:21,990 --> 00:37:22,000
to keep track of the length so
 

1839
00:37:22,000 --> 00:37:25,750
to keep track of the length so
we know that the first length items are

1840
00:37:25,750 --> 00:37:25,760
we know that the first length items are
 

1841
00:37:25,760 --> 00:37:27,670
we know that the first length items are
where their data is and the remainder

1842
00:37:27,670 --> 00:37:27,680
where their data is and the remainder
 

1843
00:37:27,680 --> 00:37:30,069
where their data is and the remainder
are just are meaningless

1844
00:37:30,069 --> 00:37:30,079
are just are meaningless
 

1845
00:37:30,079 --> 00:37:32,150
are just are meaningless
okay so now if i want to go and do an

1846
00:37:32,150 --> 00:37:32,160
okay so now if i want to go and do an
 

1847
00:37:32,160 --> 00:37:37,670
okay so now if i want to go and do an
insert last

1848
00:37:37,670 --> 00:37:37,680
insert last
 

1849
00:37:37,680 --> 00:37:41,270
insert last
what do i do i just go to

1850
00:37:41,270 --> 00:37:41,280
what do i do i just go to
 

1851
00:37:41,280 --> 00:37:48,390
what do i do i just go to
a of length and set it to x

1852
00:37:48,390 --> 00:37:48,400

 

1853
00:37:48,400 --> 00:37:52,069

and then i increment length

1854
00:37:52,069 --> 00:37:52,079

 

1855
00:37:52,079 --> 00:37:56,870

boom easy constant time yeah

1856
00:37:56,870 --> 00:37:56,880

 

1857
00:37:56,880 --> 00:37:58,390

how do you know you have enough room

1858
00:37:58,390 --> 00:37:58,400
how do you know you have enough room
 

1859
00:37:58,400 --> 00:38:00,150
how do you know you have enough room
indeed i don't this was an incorrect

1860
00:38:00,150 --> 00:38:00,160
indeed i don't this was an incorrect
 

1861
00:38:00,160 --> 00:38:01,430
indeed i don't this was an incorrect
algorithm

1862
00:38:01,430 --> 00:38:01,440
algorithm
 

1863
00:38:01,440 --> 00:38:03,589
algorithm
but it's usually correct as long as i

1864
00:38:03,589 --> 00:38:03,599
but it's usually correct as long as i
 

1865
00:38:03,599 --> 00:38:05,349
but it's usually correct as long as i
have extra space this is all i need to

1866
00:38:05,349 --> 00:38:05,359
have extra space this is all i need to
 

1867
00:38:05,359 --> 00:38:06,069
have extra space this is all i need to
do

1868
00:38:06,069 --> 00:38:06,079
do
 

1869
00:38:06,079 --> 00:38:09,349
do
for insert last but uh

1870
00:38:09,349 --> 00:38:09,359
for insert last but uh
 

1871
00:38:09,359 --> 00:38:13,190
for insert last but uh
i'm also going to store the size

1872
00:38:13,190 --> 00:38:13,200
i'm also going to store the size
 

1873
00:38:13,200 --> 00:38:15,589
i'm also going to store the size
of the array this is the actual this

1874
00:38:15,589 --> 00:38:15,599
of the array this is the actual this
 

1875
00:38:15,599 --> 00:38:18,069
of the array this is the actual this
whole thing is size

1876
00:38:18,069 --> 00:38:18,079
whole thing is size
 

1877
00:38:18,079 --> 00:38:22,470
whole thing is size
and this part is length

1878
00:38:22,470 --> 00:38:22,480
and this part is length
 

1879
00:38:22,480 --> 00:38:23,750
and this part is length
so length is always going to be less

1880
00:38:23,750 --> 00:38:23,760
so length is always going to be less
 

1881
00:38:23,760 --> 00:38:26,550
so length is always going to be less
than or equal to size

1882
00:38:26,550 --> 00:38:26,560
than or equal to size
 

1883
00:38:26,560 --> 00:38:28,310
than or equal to size
and so there's a problem if length

1884
00:38:28,310 --> 00:38:28,320
and so there's a problem if length
 

1885
00:38:28,320 --> 00:38:29,829
and so there's a problem if length
equals size

1886
00:38:29,829 --> 00:38:29,839
equals size
 

1887
00:38:29,839 --> 00:38:35,990
equals size
then i don't have any space okay

1888
00:38:35,990 --> 00:38:36,000

 

1889
00:38:36,000 --> 00:38:41,030

just add to the end

1890
00:38:41,030 --> 00:38:41,040
just add to the end
 

1891
00:38:41,040 --> 00:38:45,750
just add to the end
unless

1892
00:38:45,750 --> 00:38:45,760

 

1893
00:38:45,760 --> 00:38:49,510

n equals size i'm using n

1894
00:38:49,510 --> 00:38:49,520
n equals size i'm using n
 

1895
00:38:49,520 --> 00:38:51,990
n equals size i'm using n
and length for the same thing uh so the

1896
00:38:51,990 --> 00:38:52,000
and length for the same thing uh so the
 

1897
00:38:52,000 --> 00:38:52,790
and length for the same thing uh so the
length here

1898
00:38:52,790 --> 00:38:52,800
length here
 

1899
00:38:52,800 --> 00:38:57,109
length here
is same as n that's our actual number of

1900
00:38:57,109 --> 00:38:57,119
is same as n that's our actual number of
 

1901
00:38:57,119 --> 00:38:58,150
is same as n that's our actual number of
things we're trying to

1902
00:38:58,150 --> 00:38:58,160
things we're trying to
 

1903
00:38:58,160 --> 00:39:00,790
things we're trying to
represent and size this is great this is

1904
00:39:00,790 --> 00:39:00,800
represent and size this is great this is
 

1905
00:39:00,800 --> 00:39:01,829
represent and size this is great this is
the interface

1906
00:39:01,829 --> 00:39:01,839
the interface
 

1907
00:39:01,839 --> 00:39:03,990
the interface
size this is what we're trying to

1908
00:39:03,990 --> 00:39:04,000
size this is what we're trying to
 

1909
00:39:04,000 --> 00:39:05,270
size this is what we're trying to
represent and this

1910
00:39:05,270 --> 00:39:05,280
represent and this
 

1911
00:39:05,280 --> 00:39:08,150
represent and this
is the representation size this is the

1912
00:39:08,150 --> 00:39:08,160
is the representation size this is the
 

1913
00:39:08,160 --> 00:39:09,190
is the representation size this is the
size of my array

1914
00:39:09,190 --> 00:39:09,200
size of my array
 

1915
00:39:09,200 --> 00:39:10,550
size of my array
these are the number of items i'm trying

1916
00:39:10,550 --> 00:39:10,560
these are the number of items i'm trying
 

1917
00:39:10,560 --> 00:39:12,390
these are the number of items i'm trying
to store in that array okay this is the

1918
00:39:12,390 --> 00:39:12,400
to store in that array okay this is the
 

1919
00:39:12,400 --> 00:39:14,069
to store in that array okay this is the
interface versus data structure

1920
00:39:14,069 --> 00:39:14,079
interface versus data structure
 

1921
00:39:14,079 --> 00:39:15,510
interface versus data structure
here's the interface here's the data

1922
00:39:15,510 --> 00:39:15,520
here's the interface here's the data
 

1923
00:39:15,520 --> 00:39:17,109
here's the interface here's the data
structure

1924
00:39:17,109 --> 00:39:17,119
structure
 

1925
00:39:17,119 --> 00:39:22,470
structure
okay cool um

1926
00:39:22,470 --> 00:39:22,480

 

1927
00:39:22,480 --> 00:39:26,829

what do i do in the case when n equals

1928
00:39:26,829 --> 00:39:26,839
what do i do in the case when n equals
 

1929
00:39:26,839 --> 00:39:33,190
what do i do in the case when n equals
size

1930
00:39:33,190 --> 00:39:33,200

 

1931
00:39:33,200 --> 00:39:35,670

i'm gonna have to make my array bigger

1932
00:39:35,670 --> 00:39:35,680
i'm gonna have to make my array bigger
 

1933
00:39:35,680 --> 00:39:36,550
i'm gonna have to make my array bigger
okay this should

1934
00:39:36,550 --> 00:39:36,560
okay this should
 

1935
00:39:36,560 --> 00:39:40,230
okay this should
sound just like static arrays

1936
00:39:40,230 --> 00:39:40,240
sound just like static arrays
 

1937
00:39:40,240 --> 00:39:41,910
sound just like static arrays
with static arrays we made our array

1938
00:39:41,910 --> 00:39:41,920
with static arrays we made our array
 

1939
00:39:41,920 --> 00:39:44,150
with static arrays we made our array
bigger every time we insert it

1940
00:39:44,150 --> 00:39:44,160
bigger every time we insert it
 

1941
00:39:44,160 --> 00:39:46,870
bigger every time we insert it
and that was this linear cost of

1942
00:39:46,870 --> 00:39:46,880
and that was this linear cost of
 

1943
00:39:46,880 --> 00:39:49,270
and that was this linear cost of
allocation

1944
00:39:49,270 --> 00:39:49,280
allocation
 

1945
00:39:49,280 --> 00:39:50,870
allocation
we're going to do that sometimes with

1946
00:39:50,870 --> 00:39:50,880
we're going to do that sometimes with
 

1947
00:39:50,880 --> 00:39:52,470
we're going to do that sometimes with
static rays we had to do it every single

1948
00:39:52,470 --> 00:39:52,480
static rays we had to do it every single
 

1949
00:39:52,480 --> 00:39:54,069
static rays we had to do it every single
time because size

1950
00:39:54,069 --> 00:39:54,079
time because size
 

1951
00:39:54,079 --> 00:39:56,710
time because size
equaled n now we have some flexibility

1952
00:39:56,710 --> 00:39:56,720
equaled n now we have some flexibility
 

1953
00:39:56,720 --> 00:39:59,589
equaled n now we have some flexibility
we're only going to do it sometimes

1954
00:39:59,589 --> 00:39:59,599
we're only going to do it sometimes
 

1955
00:39:59,599 --> 00:40:01,829
we're only going to do it sometimes
it's like uh cookies are a sometimes

1956
00:40:01,829 --> 00:40:01,839
it's like uh cookies are a sometimes
 

1957
00:40:01,839 --> 00:40:03,510
it's like uh cookies are a sometimes
food apparently

1958
00:40:03,510 --> 00:40:03,520
food apparently
 

1959
00:40:03,520 --> 00:40:06,630
food apparently
according to modern cookie monster um i

1960
00:40:06,630 --> 00:40:06,640
according to modern cookie monster um i
 

1961
00:40:06,640 --> 00:40:07,670
according to modern cookie monster um i
don't understand

1962
00:40:07,670 --> 00:40:07,680
don't understand
 

1963
00:40:07,680 --> 00:40:11,829
don't understand
but uh if n equals size

1964
00:40:11,829 --> 00:40:11,839
but uh if n equals size
 

1965
00:40:11,839 --> 00:40:16,390
but uh if n equals size
we're going to uh

1966
00:40:16,390 --> 00:40:16,400

 

1967
00:40:16,400 --> 00:40:20,390

uh allocate

1968
00:40:20,390 --> 00:40:20,400

 

1969
00:40:20,400 --> 00:40:24,790

a new array

1970
00:40:24,790 --> 00:40:24,800
a new array
 

1971
00:40:24,800 --> 00:40:30,069
a new array
of size

1972
00:40:30,069 --> 00:40:30,079

 

1973
00:40:30,079 --> 00:40:33,670

any suggestions bigger i like it

1974
00:40:33,670 --> 00:40:33,680
any suggestions bigger i like it
 

1975
00:40:33,680 --> 00:40:38,470
any suggestions bigger i like it
greater than size how much bigger

1976
00:40:38,470 --> 00:40:38,480
greater than size how much bigger
 

1977
00:40:38,480 --> 00:40:41,589
greater than size how much bigger
twice five

1978
00:40:41,589 --> 00:40:41,599
twice five
 

1979
00:40:41,599 --> 00:40:47,030
twice five
five things size plus five come on jason

1980
00:40:47,030 --> 00:40:47,040
five things size plus five come on jason
 

1981
00:40:47,040 --> 00:40:49,270
five things size plus five come on jason
trolling me all right so there are a

1982
00:40:49,270 --> 00:40:49,280
trolling me all right so there are a
 

1983
00:40:49,280 --> 00:40:50,550
trolling me all right so there are a
couple of natural

1984
00:40:50,550 --> 00:40:50,560
couple of natural
 

1985
00:40:50,560 --> 00:40:52,550
couple of natural
choices here one is a constant factor

1986
00:40:52,550 --> 00:40:52,560
choices here one is a constant factor
 

1987
00:40:52,560 --> 00:40:55,510
choices here one is a constant factor
larger you could use 1.1 or 1.01

1988
00:40:55,510 --> 00:40:55,520
larger you could use 1.1 or 1.01
 

1989
00:40:55,520 --> 00:40:58,790
larger you could use 1.1 or 1.01
or 2 or 5 or 10 they'll all work

1990
00:40:58,790 --> 00:40:58,800
or 2 or 5 or 10 they'll all work
 

1991
00:40:58,800 --> 00:41:01,750
or 2 or 5 or 10 they'll all work
or you could use jason's trolling answer

1992
00:41:01,750 --> 00:41:01,760
or you could use jason's trolling answer
 

1993
00:41:01,760 --> 00:41:06,309
or you could use jason's trolling answer
of size plus a constant like 5.

1994
00:41:06,309 --> 00:41:06,319
of size plus a constant like 5.
 

1995
00:41:06,319 --> 00:41:18,470
of size plus a constant like 5.
why is this bad

1996
00:41:18,470 --> 00:41:18,480

 

1997
00:41:18,480 --> 00:41:19,910

you'll have to do it again you'll have

1998
00:41:19,910 --> 00:41:19,920
you'll have to do it again you'll have
 

1999
00:41:19,920 --> 00:41:21,990
you'll have to do it again you'll have
to resize frequently

2000
00:41:21,990 --> 00:41:22,000
to resize frequently
 

2001
00:41:22,000 --> 00:41:25,190
to resize frequently
when five steps later so

2002
00:41:25,190 --> 00:41:25,200
when five steps later so
 

2003
00:41:25,200 --> 00:41:27,030
when five steps later so
uh in the original static array we were

2004
00:41:27,030 --> 00:41:27,040
uh in the original static array we were
 

2005
00:41:27,040 --> 00:41:29,270
uh in the original static array we were
reallocating every single time

2006
00:41:29,270 --> 00:41:29,280
reallocating every single time
 

2007
00:41:29,280 --> 00:41:31,589
reallocating every single time
that's like n plus one if we do n plus

2008
00:41:31,589 --> 00:41:31,599
that's like n plus one if we do n plus
 

2009
00:41:31,599 --> 00:41:33,109
that's like n plus one if we do n plus
five that really doesn't change things

2010
00:41:33,109 --> 00:41:33,119
five that really doesn't change things
 

2011
00:41:33,119 --> 00:41:33,990
five that really doesn't change things
if we ignore constant

2012
00:41:33,990 --> 00:41:34,000
if we ignore constant
 

2013
00:41:34,000 --> 00:41:36,150
if we ignore constant
factors now we'll have to spend linear

2014
00:41:36,150 --> 00:41:36,160
factors now we'll have to spend linear
 

2015
00:41:36,160 --> 00:41:38,069
factors now we'll have to spend linear
time every five steps instead of linear

2016
00:41:38,069 --> 00:41:38,079
time every five steps instead of linear
 

2017
00:41:38,079 --> 00:41:39,349
time every five steps instead of linear
time every one step

2018
00:41:39,349 --> 00:41:39,359
time every one step
 

2019
00:41:39,359 --> 00:41:41,750
time every one step
that's still linear time per operation

2020
00:41:41,750 --> 00:41:41,760
that's still linear time per operation
 

2021
00:41:41,760 --> 00:41:44,309
that's still linear time per operation
just we're changing the constant factor

2022
00:41:44,309 --> 00:41:44,319
just we're changing the constant factor
 

2023
00:41:44,319 --> 00:41:46,630
just we're changing the constant factor
okay whereas two times size well now we

2024
00:41:46,630 --> 00:41:46,640
okay whereas two times size well now we
 

2025
00:41:46,640 --> 00:41:48,470
okay whereas two times size well now we
have to think a little bit harder

2026
00:41:48,470 --> 00:41:48,480
have to think a little bit harder
 

2027
00:41:48,480 --> 00:41:51,190
have to think a little bit harder
um let's just think about the case where

2028
00:41:51,190 --> 00:41:51,200
um let's just think about the case where
 

2029
00:41:51,200 --> 00:41:51,990
um let's just think about the case where
we're

2030
00:41:51,990 --> 00:41:52,000
we're
 

2031
00:41:52,000 --> 00:41:54,230
we're
inserting at the end of an array so

2032
00:41:54,230 --> 00:41:54,240
inserting at the end of an array so
 

2033
00:41:54,240 --> 00:41:56,950
inserting at the end of an array so
let's say we do

2034
00:41:56,950 --> 00:41:56,960
let's say we do
 

2035
00:41:56,960 --> 00:42:01,190
let's say we do
n uh insert

2036
00:42:01,190 --> 00:42:01,200
n uh insert
 

2037
00:42:01,200 --> 00:42:04,309
n uh insert
last

2038
00:42:04,309 --> 00:42:04,319

 

2039
00:42:04,319 --> 00:42:11,910

from an empty array

2040
00:42:11,910 --> 00:42:11,920

 

2041
00:42:11,920 --> 00:42:14,870

when do we resize well at the beginning

2042
00:42:14,870 --> 00:42:14,880
when do we resize well at the beginning
 

2043
00:42:14,880 --> 00:42:16,230
when do we resize well at the beginning
i guess i didn't say what we do for an

2044
00:42:16,230 --> 00:42:16,240
i guess i didn't say what we do for an
 

2045
00:42:16,240 --> 00:42:18,309
i guess i didn't say what we do for an
empty array let's say size equals one

2046
00:42:18,309 --> 00:42:18,319
empty array let's say size equals one
 

2047
00:42:18,319 --> 00:42:20,309
empty array let's say size equals one
so we can insert one item for free as

2048
00:42:20,309 --> 00:42:20,319
so we can insert one item for free as
 

2049
00:42:20,319 --> 00:42:21,829
so we can insert one item for free as
soon as we insert the second item

2050
00:42:21,829 --> 00:42:21,839
soon as we insert the second item
 

2051
00:42:21,839 --> 00:42:24,309
soon as we insert the second item
then we have to resize that seems bad

2052
00:42:24,309 --> 00:42:24,319
then we have to resize that seems bad
 

2053
00:42:24,319 --> 00:42:25,910
then we have to resize that seems bad
immediately we have to resize

2054
00:42:25,910 --> 00:42:25,920
immediately we have to resize
 

2055
00:42:25,920 --> 00:42:28,309
immediately we have to resize
then we insert the third item okay now

2056
00:42:28,309 --> 00:42:28,319
then we insert the third item okay now
 

2057
00:42:28,319 --> 00:42:30,470
then we insert the third item okay now
let's draw a picture so we start with

2058
00:42:30,470 --> 00:42:30,480
let's draw a picture so we start with
 

2059
00:42:30,480 --> 00:42:31,190
let's draw a picture so we start with
one item

2060
00:42:31,190 --> 00:42:31,200
one item
 

2061
00:42:31,200 --> 00:42:34,309
one item
we fill it up uh then we

2062
00:42:34,309 --> 00:42:34,319
we fill it up uh then we
 

2063
00:42:34,319 --> 00:42:36,150
we fill it up uh then we
grow to size two because that's twice

2064
00:42:36,150 --> 00:42:36,160
grow to size two because that's twice
 

2065
00:42:36,160 --> 00:42:37,910
grow to size two because that's twice
one then we fill it up

2066
00:42:37,910 --> 00:42:37,920
one then we fill it up
 

2067
00:42:37,920 --> 00:42:39,510
one then we fill it up
immediately we have to resize again but

2068
00:42:39,510 --> 00:42:39,520
immediately we have to resize again but
 

2069
00:42:39,520 --> 00:42:41,190
immediately we have to resize again but
now we get start to get some benefit

2070
00:42:41,190 --> 00:42:41,200
now we get start to get some benefit
 

2071
00:42:41,200 --> 00:42:43,910
now we get start to get some benefit
now we have size four and so we can

2072
00:42:43,910 --> 00:42:43,920
now we have size four and so we can
 

2073
00:42:43,920 --> 00:42:45,750
now we have size four and so we can
insert two items before

2074
00:42:45,750 --> 00:42:45,760
insert two items before
 

2075
00:42:45,760 --> 00:42:47,910
insert two items before
we have to resize and now we're size

2076
00:42:47,910 --> 00:42:47,920
we have to resize and now we're size
 

2077
00:42:47,920 --> 00:42:50,150
we have to resize and now we're size
eight

2078
00:42:50,150 --> 00:42:50,160
eight
 

2079
00:42:50,160 --> 00:42:52,630
eight
and we get to insert four items before

2080
00:42:52,630 --> 00:42:52,640
and we get to insert four items before
 

2081
00:42:52,640 --> 00:42:53,829
and we get to insert four items before
we refill

2082
00:42:53,829 --> 00:42:53,839
we refill
 

2083
00:42:53,839 --> 00:42:58,230
we refill
so uh this is going to resize and again

2084
00:42:58,230 --> 00:42:58,240
so uh this is going to resize and again
 

2085
00:42:58,240 --> 00:42:59,270
so uh this is going to resize and again
resizes are

2086
00:42:59,270 --> 00:42:59,280
resizes are
 

2087
00:42:59,280 --> 00:43:01,109
resizes are
expensive both because we have to pay to

2088
00:43:01,109 --> 00:43:01,119
expensive both because we have to pay to
 

2089
00:43:01,119 --> 00:43:02,470
expensive both because we have to pay to
allocate the new array

2090
00:43:02,470 --> 00:43:02,480
allocate the new array
 

2091
00:43:02,480 --> 00:43:04,309
allocate the new array
i drew it as just extending it but in

2092
00:43:04,309 --> 00:43:04,319
i drew it as just extending it but in
 

2093
00:43:04,319 --> 00:43:05,829
i drew it as just extending it but in
fact we're creating a whole new

2094
00:43:05,829 --> 00:43:05,839
fact we're creating a whole new
 

2095
00:43:05,839 --> 00:43:07,589
fact we're creating a whole new
array and then we have to copy all of

2096
00:43:07,589 --> 00:43:07,599
array and then we have to copy all of
 

2097
00:43:07,599 --> 00:43:09,270
array and then we have to copy all of
the items over

2098
00:43:09,270 --> 00:43:09,280
the items over
 

2099
00:43:09,280 --> 00:43:10,630
the items over
so there's the allocation cost and then

2100
00:43:10,630 --> 00:43:10,640
so there's the allocation cost and then
 

2101
00:43:10,640 --> 00:43:12,309
so there's the allocation cost and then
the copying costs so it's linear either

2102
00:43:12,309 --> 00:43:12,319
the copying costs so it's linear either
 

2103
00:43:12,319 --> 00:43:13,430
the copying costs so it's linear either
way

2104
00:43:13,430 --> 00:43:13,440
way
 

2105
00:43:13,440 --> 00:43:16,630
way
but we're going to resize at n

2106
00:43:16,630 --> 00:43:16,640
but we're going to resize at n
 

2107
00:43:16,640 --> 00:43:20,470
but we're going to resize at n
equals 1 2 4 8

2108
00:43:20,470 --> 00:43:20,480
equals 1 2 4 8
 

2109
00:43:20,480 --> 00:43:22,309
equals 1 2 4 8
16. you know this sequence all the

2110
00:43:22,309 --> 00:43:22,319
16. you know this sequence all the
 

2111
00:43:22,319 --> 00:43:23,750
16. you know this sequence all the
powers of 2

2112
00:43:23,750 --> 00:43:23,760
powers of 2
 

2113
00:43:23,760 --> 00:43:25,750
powers of 2
because we're doubling that is exactly

2114
00:43:25,750 --> 00:43:25,760
because we're doubling that is exactly
 

2115
00:43:25,760 --> 00:43:28,150
because we're doubling that is exactly
powers of 2.

2116
00:43:28,150 --> 00:43:28,160
powers of 2.
 

2117
00:43:28,160 --> 00:43:31,270
powers of 2.
so we pay a linear cost

2118
00:43:31,270 --> 00:43:31,280
so we pay a linear cost
 

2119
00:43:31,280 --> 00:43:34,470
so we pay a linear cost
so this resize cost the allocation

2120
00:43:34,470 --> 00:43:34,480
so this resize cost the allocation
 

2121
00:43:34,480 --> 00:43:38,230
so this resize cost the allocation
and the copying is going to be it's

2122
00:43:38,230 --> 00:43:38,240
and the copying is going to be it's
 

2123
00:43:38,240 --> 00:43:39,750
and the copying is going to be it's
linear each time

2124
00:43:39,750 --> 00:43:39,760
linear each time
 

2125
00:43:39,760 --> 00:43:43,030
linear each time
so it's 1 plus 2 plus 4 plus

2126
00:43:43,030 --> 00:43:43,040
so it's 1 plus 2 plus 4 plus
 

2127
00:43:43,040 --> 00:43:47,109
so it's 1 plus 2 plus 4 plus
8 plus 16. okay really i should write

2128
00:43:47,109 --> 00:43:47,119
8 plus 16. okay really i should write
 

2129
00:43:47,119 --> 00:43:48,470
8 plus 16. okay really i should write
this as

2130
00:43:48,470 --> 00:43:48,480
this as
 

2131
00:43:48,480 --> 00:43:51,750
this as
a sum from i equals 1

2132
00:43:51,750 --> 00:43:51,760
a sum from i equals 1
 

2133
00:43:51,760 --> 00:43:56,230
a sum from i equals 1
to roughly log n log base 2 of n is lg

2134
00:43:56,230 --> 00:43:56,240
to roughly log n log base 2 of n is lg
 

2135
00:43:56,240 --> 00:44:00,630
to roughly log n log base 2 of n is lg
of 2 to the i

2136
00:44:00,630 --> 00:44:00,640

 

2137
00:44:00,640 --> 00:44:03,670

okay if you want a terminus here it's

2138
00:44:03,670 --> 00:44:03,680
okay if you want a terminus here it's
 

2139
00:44:03,680 --> 00:44:04,550
okay if you want a terminus here it's
roughly n

2140
00:44:04,550 --> 00:44:04,560
roughly n
 

2141
00:44:04,560 --> 00:44:06,470
roughly n
it's actually the next the previous

2142
00:44:06,470 --> 00:44:06,480
it's actually the next the previous
 

2143
00:44:06,480 --> 00:44:08,710
it's actually the next the previous
power of 2 of n or something

2144
00:44:08,710 --> 00:44:08,720
power of 2 of n or something
 

2145
00:44:08,720 --> 00:44:10,230
power of 2 of n or something
okay but uh that won't matter that'll

2146
00:44:10,230 --> 00:44:10,240
okay but uh that won't matter that'll
 

2147
00:44:10,240 --> 00:44:12,069
okay but uh that won't matter that'll
just affect things by a constant factor

2148
00:44:12,069 --> 00:44:12,079
just affect things by a constant factor
 

2149
00:44:12,079 --> 00:44:16,309
just affect things by a constant factor
what is the sum of two to the i

2150
00:44:16,309 --> 00:44:16,319
what is the sum of two to the i
 

2151
00:44:16,319 --> 00:44:19,109
what is the sum of two to the i
this is a geometric series anyone know

2152
00:44:19,109 --> 00:44:19,119
this is a geometric series anyone know
 

2153
00:44:19,119 --> 00:44:29,270
this is a geometric series anyone know
the answer

2154
00:44:29,270 --> 00:44:29,280

 

2155
00:44:29,280 --> 00:44:32,309

two to the uh top limit

2156
00:44:32,309 --> 00:44:32,319
two to the uh top limit
 

2157
00:44:32,319 --> 00:44:35,510
two to the uh top limit
uh plus one minus one yeah so this is

2158
00:44:35,510 --> 00:44:35,520
uh plus one minus one yeah so this is
 

2159
00:44:35,520 --> 00:44:36,550
uh plus one minus one yeah so this is
the identity

2160
00:44:36,550 --> 00:44:36,560
the identity
 

2161
00:44:36,560 --> 00:44:40,150
the identity
sum of two to the i uh from i equals one

2162
00:44:40,150 --> 00:44:40,160
sum of two to the i uh from i equals one
 

2163
00:44:40,160 --> 00:44:40,470
sum of two to the i uh from i equals one
to

2164
00:44:40,470 --> 00:44:40,480
to
 

2165
00:44:40,480 --> 00:44:45,589
to
k is two to the k plus one

2166
00:44:45,589 --> 00:44:45,599
k is two to the k plus one
 

2167
00:44:45,599 --> 00:44:48,390
k is two to the k plus one
plus one minus one so the plus one's

2168
00:44:48,390 --> 00:44:48,400
plus one minus one so the plus one's
 

2169
00:44:48,400 --> 00:44:49,109
plus one minus one so the plus one's
upstairs

2170
00:44:49,109 --> 00:44:49,119
upstairs
 

2171
00:44:49,119 --> 00:44:50,870
upstairs
minus one's downstairs an easy way to

2172
00:44:50,870 --> 00:44:50,880
minus one's downstairs an easy way to
 

2173
00:44:50,880 --> 00:44:53,190
minus one's downstairs an easy way to
remember this is if you think in binary

2174
00:44:53,190 --> 00:44:53,200
remember this is if you think in binary
 

2175
00:44:53,200 --> 00:44:54,550
remember this is if you think in binary
as we all should we're computer

2176
00:44:54,550 --> 00:44:54,560
as we all should we're computer
 

2177
00:44:54,560 --> 00:44:56,710
as we all should we're computer
scientists uh two to the i

2178
00:44:56,710 --> 00:44:56,720
scientists uh two to the i
 

2179
00:44:56,720 --> 00:44:58,790
scientists uh two to the i
is means you set the ith bit to one so

2180
00:44:58,790 --> 00:44:58,800
is means you set the ith bit to one so
 

2181
00:44:58,800 --> 00:44:59,750
is means you set the ith bit to one so
here's

2182
00:44:59,750 --> 00:44:59,760
here's
 

2183
00:44:59,760 --> 00:45:02,790
here's
uh here's a bit string this is the ith

2184
00:45:02,790 --> 00:45:02,800
uh here's a bit string this is the ith
 

2185
00:45:02,800 --> 00:45:03,109
uh here's a bit string this is the ith
bit

2186
00:45:03,109 --> 00:45:03,119
bit
 

2187
00:45:03,119 --> 00:45:05,750
bit
this is 2 to the i the zeros down here

2188
00:45:05,750 --> 00:45:05,760
this is 2 to the i the zeros down here
 

2189
00:45:05,760 --> 00:45:07,030
this is 2 to the i the zeros down here
if i sum them all up

2190
00:45:07,030 --> 00:45:07,040
if i sum them all up
 

2191
00:45:07,040 --> 00:45:10,390
if i sum them all up
what that means is i'm putting ones here

2192
00:45:10,390 --> 00:45:10,400
what that means is i'm putting ones here
 

2193
00:45:10,400 --> 00:45:12,470
what that means is i'm putting ones here
okay uh and if you think about what this

2194
00:45:12,470 --> 00:45:12,480
okay uh and if you think about what this
 

2195
00:45:12,480 --> 00:45:14,550
okay uh and if you think about what this
means this is up to k

2196
00:45:14,550 --> 00:45:14,560
means this is up to k
 

2197
00:45:14,560 --> 00:45:17,750
means this is up to k
from zero sorry i should do zero to be

2198
00:45:17,750 --> 00:45:17,760
from zero sorry i should do zero to be
 

2199
00:45:17,760 --> 00:45:19,670
from zero sorry i should do zero to be
proper

2200
00:45:19,670 --> 00:45:19,680
proper
 

2201
00:45:19,680 --> 00:45:22,950
proper
if i write so that's the left hand side

2202
00:45:22,950 --> 00:45:22,960
if i write so that's the left hand side
 

2203
00:45:22,960 --> 00:45:26,309
if i write so that's the left hand side
the right hand side is 2 to the k plus 1

2204
00:45:26,309 --> 00:45:26,319
the right hand side is 2 to the k plus 1
 

2205
00:45:26,319 --> 00:45:27,670
the right hand side is 2 to the k plus 1
which is a 1 here

2206
00:45:27,670 --> 00:45:27,680
which is a 1 here
 

2207
00:45:27,680 --> 00:45:30,790
which is a 1 here
and the rest 0s so if you know your

2208
00:45:30,790 --> 00:45:30,800
and the rest 0s so if you know your
 

2209
00:45:30,800 --> 00:45:31,990
and the rest 0s so if you know your
binary arithmetic you

2210
00:45:31,990 --> 00:45:32,000
binary arithmetic you
 

2211
00:45:32,000 --> 00:45:33,910
binary arithmetic you
subtract if you add one to this you get

2212
00:45:33,910 --> 00:45:33,920
subtract if you add one to this you get
 

2213
00:45:33,920 --> 00:45:35,270
subtract if you add one to this you get
this so if you subtract one from this

2214
00:45:35,270 --> 00:45:35,280
this so if you subtract one from this
 

2215
00:45:35,280 --> 00:45:36,230
this so if you subtract one from this
you get this

2216
00:45:36,230 --> 00:45:36,240
you get this
 

2217
00:45:36,240 --> 00:45:39,510
you get this
okay this is why this identity holds um

2218
00:45:39,510 --> 00:45:39,520
okay this is why this identity holds um
 

2219
00:45:39,520 --> 00:45:41,750
okay this is why this identity holds um
or the higher level thing is to say oh

2220
00:45:41,750 --> 00:45:41,760
or the higher level thing is to say oh
 

2221
00:45:41,760 --> 00:45:43,990
or the higher level thing is to say oh
this is a geometric series

2222
00:45:43,990 --> 00:45:44,000
this is a geometric series
 

2223
00:45:44,000 --> 00:45:46,309
this is a geometric series
so i know i you should know this i'm

2224
00:45:46,309 --> 00:45:46,319
so i know i you should know this i'm
 

2225
00:45:46,319 --> 00:45:47,270
so i know i you should know this i'm
telling you now

2226
00:45:47,270 --> 00:45:47,280
telling you now
 

2227
00:45:47,280 --> 00:45:49,750
telling you now
geometric series are dominated by the

2228
00:45:49,750 --> 00:45:49,760
geometric series are dominated by the
 

2229
00:45:49,760 --> 00:45:50,470
geometric series are dominated by the
last term

2230
00:45:50,470 --> 00:45:50,480
last term
 

2231
00:45:50,480 --> 00:45:52,390
last term
the biggest term if you have any series

2232
00:45:52,390 --> 00:45:52,400
the biggest term if you have any series
 

2233
00:45:52,400 --> 00:45:53,750
the biggest term if you have any series
you can identify as geometric which

2234
00:45:53,750 --> 00:45:53,760
you can identify as geometric which
 

2235
00:45:53,760 --> 00:45:54,950
you can identify as geometric which
means it's growing at least

2236
00:45:54,950 --> 00:45:54,960
means it's growing at least
 

2237
00:45:54,960 --> 00:45:56,309
means it's growing at least
exponentially

2238
00:45:56,309 --> 00:45:56,319
exponentially
 

2239
00:45:56,319 --> 00:45:59,190
exponentially
then in terms of theta notation you can

2240
00:45:59,190 --> 00:45:59,200
then in terms of theta notation you can
 

2241
00:45:59,200 --> 00:45:59,990
then in terms of theta notation you can
just look at the last

2242
00:45:59,990 --> 00:46:00,000
just look at the last
 

2243
00:46:00,000 --> 00:46:01,510
just look at the last
term and put a theta around it and

2244
00:46:01,510 --> 00:46:01,520
term and put a theta around it and
 

2245
00:46:01,520 --> 00:46:03,510
term and put a theta around it and
you're done so this is

2246
00:46:03,510 --> 00:46:03,520
you're done so this is
 

2247
00:46:03,520 --> 00:46:07,430
you're done so this is
theta the last term like 2 to the log n

2248
00:46:07,430 --> 00:46:07,440
theta the last term like 2 to the log n
 

2249
00:46:07,440 --> 00:46:12,870
theta the last term like 2 to the log n
which is theta n

2250
00:46:12,870 --> 00:46:12,880

 

2251
00:46:12,880 --> 00:46:16,790

cool linear time linear time for

2252
00:46:16,790 --> 00:46:16,800
cool linear time linear time for
 

2253
00:46:16,800 --> 00:46:18,710
cool linear time linear time for
all of my operations i'm doing n

2254
00:46:18,710 --> 00:46:18,720
all of my operations i'm doing n
 

2255
00:46:18,720 --> 00:46:19,910
all of my operations i'm doing n
operations here

2256
00:46:19,910 --> 00:46:19,920
operations here
 

2257
00:46:19,920 --> 00:46:22,069
operations here
and i spend linear total time to do all

2258
00:46:22,069 --> 00:46:22,079
and i spend linear total time to do all
 

2259
00:46:22,079 --> 00:46:23,910
and i spend linear total time to do all
the resizing

2260
00:46:23,910 --> 00:46:23,920
the resizing
 

2261
00:46:23,920 --> 00:46:27,109
the resizing
that's good that's like constant each

2262
00:46:27,109 --> 00:46:27,119
that's good that's like constant each
 

2263
00:46:27,119 --> 00:46:30,710
that's good that's like constant each
kind of the kind of is an important

2264
00:46:30,710 --> 00:46:30,720
kind of the kind of is an important
 

2265
00:46:30,720 --> 00:46:31,589
kind of the kind of is an important
notion

2266
00:46:31,589 --> 00:46:31,599
notion
 

2267
00:46:31,599 --> 00:46:40,829
notion
which we call

2268
00:46:40,829 --> 00:46:40,839

 

2269
00:46:40,839 --> 00:46:44,870

amortization

2270
00:46:44,870 --> 00:46:44,880

 

2271
00:46:44,880 --> 00:46:50,710

so i want to say an operation

2272
00:46:50,710 --> 00:46:50,720

 

2273
00:46:50,720 --> 00:46:54,870

takes

2274
00:46:54,870 --> 00:46:54,880

 

2275
00:46:54,880 --> 00:47:02,790

t of n amortized time

2276
00:47:02,790 --> 00:47:02,800

 

2277
00:47:02,800 --> 00:47:06,150

if um

2278
00:47:06,150 --> 00:47:06,160
if um
 

2279
00:47:06,160 --> 00:47:13,510
if um
let's say any k of those operations

2280
00:47:13,510 --> 00:47:13,520

 

2281
00:47:13,520 --> 00:47:16,790

take at most k

2282
00:47:16,790 --> 00:47:16,800
take at most k
 

2283
00:47:16,800 --> 00:47:20,150
take at most k
times t of n time this is a little bit

2284
00:47:20,150 --> 00:47:20,160
times t of n time this is a little bit
 

2285
00:47:20,160 --> 00:47:21,510
times t of n time this is a little bit
sloppy but

2286
00:47:21,510 --> 00:47:21,520
sloppy but
 

2287
00:47:21,520 --> 00:47:24,150
sloppy but
be good enough so the idea is here if

2288
00:47:24,150 --> 00:47:24,160
be good enough so the idea is here if
 

2289
00:47:24,160 --> 00:47:25,910
be good enough so the idea is here if
this works for n or k

2290
00:47:25,910 --> 00:47:25,920
this works for n or k
 

2291
00:47:25,920 --> 00:47:28,150
this works for n or k
to do n operations from an empty array

2292
00:47:28,150 --> 00:47:28,160
to do n operations from an empty array
 

2293
00:47:28,160 --> 00:47:29,109
to do n operations from an empty array
here

2294
00:47:29,109 --> 00:47:29,119
here
 

2295
00:47:29,119 --> 00:47:32,710
here
takes linear time which means uh

2296
00:47:32,710 --> 00:47:32,720
takes linear time which means uh
 

2297
00:47:32,720 --> 00:47:36,549
takes linear time which means uh
i would call this constant amortized

2298
00:47:36,549 --> 00:47:36,559
i would call this constant amortized
 

2299
00:47:36,559 --> 00:47:38,950
i would call this constant amortized
amortized means a particular kind of

2300
00:47:38,950 --> 00:47:38,960
amortized means a particular kind of
 

2301
00:47:38,960 --> 00:47:42,309
amortized means a particular kind of
averaging

2302
00:47:42,309 --> 00:47:42,319

 

2303
00:47:42,319 --> 00:47:43,829

averaging over the sequence of

2304
00:47:43,829 --> 00:47:43,839
averaging over the sequence of
 

2305
00:47:43,839 --> 00:47:45,589
averaging over the sequence of
operations so while individual

2306
00:47:45,589 --> 00:47:45,599
operations so while individual
 

2307
00:47:45,599 --> 00:47:47,109
operations so while individual
operations will be expensive

2308
00:47:47,109 --> 00:47:47,119
operations will be expensive
 

2309
00:47:47,119 --> 00:47:49,349
operations will be expensive
one near the end when i have to resize

2310
00:47:49,349 --> 00:47:49,359
one near the end when i have to resize
 

2311
00:47:49,359 --> 00:47:50,790
one near the end when i have to resize
the array is going to take linear time

2312
00:47:50,790 --> 00:47:50,800
the array is going to take linear time
 

2313
00:47:50,800 --> 00:47:52,710
the array is going to take linear time
just for that one operation

2314
00:47:52,710 --> 00:47:52,720
just for that one operation
 

2315
00:47:52,720 --> 00:47:54,309
just for that one operation
but most of the operations are cheap

2316
00:47:54,309 --> 00:47:54,319
but most of the operations are cheap
 

2317
00:47:54,319 --> 00:47:55,910
but most of the operations are cheap
most of them are constant

2318
00:47:55,910 --> 00:47:55,920
most of them are constant
 

2319
00:47:55,920 --> 00:47:59,910
most of them are constant
so i can think of charging that high

2320
00:47:59,910 --> 00:47:59,920
so i can think of charging that high
 

2321
00:47:59,920 --> 00:48:02,069
so i can think of charging that high
cost to all of the other operations that

2322
00:48:02,069 --> 00:48:02,079
cost to all of the other operations that
 

2323
00:48:02,079 --> 00:48:04,069
cost to all of the other operations that
made it happen

2324
00:48:04,069 --> 00:48:04,079
made it happen
 

2325
00:48:04,079 --> 00:48:09,430
made it happen
and so this is averaging

2326
00:48:09,430 --> 00:48:09,440

 

2327
00:48:09,440 --> 00:48:12,710

over the operation sequence every insert

2328
00:48:12,710 --> 00:48:12,720
over the operation sequence every insert
 

2329
00:48:12,720 --> 00:48:13,510
over the operation sequence every insert
last

2330
00:48:13,510 --> 00:48:13,520
last
 

2331
00:48:13,520 --> 00:48:17,030
last
over there uh only takes constant time

2332
00:48:17,030 --> 00:48:17,040
over there uh only takes constant time
 

2333
00:48:17,040 --> 00:48:19,510
over there uh only takes constant time
on average

2334
00:48:19,510 --> 00:48:19,520
on average
 

2335
00:48:19,520 --> 00:48:21,270
on average
over the the sequence of operations that

2336
00:48:21,270 --> 00:48:21,280
over the the sequence of operations that
 

2337
00:48:21,280 --> 00:48:23,510
over the the sequence of operations that
we do

2338
00:48:23,510 --> 00:48:23,520
we do
 

2339
00:48:23,520 --> 00:48:25,109
we do
and so it's almost constant it's not

2340
00:48:25,109 --> 00:48:25,119
and so it's almost constant it's not
 

2341
00:48:25,119 --> 00:48:27,190
and so it's almost constant it's not
quite as good as constant worst case

2342
00:48:27,190 --> 00:48:27,200
quite as good as constant worst case
 

2343
00:48:27,200 --> 00:48:29,589
quite as good as constant worst case
but it's almost as good and it's as good

2344
00:48:29,589 --> 00:48:29,599
but it's almost as good and it's as good
 

2345
00:48:29,599 --> 00:48:30,870
but it's almost as good and it's as good
as you could hope to do

2346
00:48:30,870 --> 00:48:30,880
as you could hope to do
 

2347
00:48:30,880 --> 00:48:34,950
as you could hope to do
in this dynamic array allocation model

2348
00:48:34,950 --> 00:48:34,960
in this dynamic array allocation model
 

2349
00:48:34,960 --> 00:48:37,589
in this dynamic array allocation model
let me put this into a table uh and

2350
00:48:37,589 --> 00:48:37,599
let me put this into a table uh and
 

2351
00:48:37,599 --> 00:48:39,030
let me put this into a table uh and
you'll find these in the lecture notes

2352
00:48:39,030 --> 00:48:39,040
you'll find these in the lecture notes
 

2353
00:48:39,040 --> 00:48:39,589
you'll find these in the lecture notes
also

2354
00:48:39,589 --> 00:48:39,599
also
 

2355
00:48:39,599 --> 00:48:41,349
also
so we have on the top the main

2356
00:48:41,349 --> 00:48:41,359
so we have on the top the main
 

2357
00:48:41,359 --> 00:48:43,349
so we have on the top the main
operations of the sequence interface

2358
00:48:43,349 --> 00:48:43,359
operations of the sequence interface
 

2359
00:48:43,359 --> 00:48:44,950
operations of the sequence interface
which we will revisit in lecture seven

2360
00:48:44,950 --> 00:48:44,960
which we will revisit in lecture seven
 

2361
00:48:44,960 --> 00:48:46,230
which we will revisit in lecture seven
we'll see some other data structures for

2362
00:48:46,230 --> 00:48:46,240
we'll see some other data structures for
 

2363
00:48:46,240 --> 00:48:47,030
we'll see some other data structures for
this

2364
00:48:47,030 --> 00:48:47,040
this
 

2365
00:48:47,040 --> 00:48:49,109
this
get ad and set ad in the first column

2366
00:48:49,109 --> 00:48:49,119
get ad and set ad in the first column
 

2367
00:48:49,119 --> 00:48:50,470
get ad and set ad in the first column
insert and delete first insert and

2368
00:48:50,470 --> 00:48:50,480
insert and delete first insert and
 

2369
00:48:50,480 --> 00:48:51,190
insert and delete first insert and
delete last

2370
00:48:51,190 --> 00:48:51,200
delete last
 

2371
00:48:51,200 --> 00:48:52,790
delete last
insert and delete at an arbitrary

2372
00:48:52,790 --> 00:48:52,800
insert and delete at an arbitrary
 

2373
00:48:52,800 --> 00:48:54,230
insert and delete at an arbitrary
position so

2374
00:48:54,230 --> 00:48:54,240
position so
 

2375
00:48:54,240 --> 00:48:56,630
position so
we've seen three data structures now

2376
00:48:56,630 --> 00:48:56,640
we've seen three data structures now
 

2377
00:48:56,640 --> 00:48:57,589
we've seen three data structures now
arrays

2378
00:48:57,589 --> 00:48:57,599
arrays
 

2379
00:48:57,599 --> 00:48:59,430
arrays
were really good at get at set at they

2380
00:48:59,430 --> 00:48:59,440
were really good at get at set at they
 

2381
00:48:59,440 --> 00:49:00,630
were really good at get at set at they
took constant time

2382
00:49:00,630 --> 00:49:00,640
took constant time
 

2383
00:49:00,640 --> 00:49:02,630
took constant time
that's the blue one we're omitting the

2384
00:49:02,630 --> 00:49:02,640
that's the blue one we're omitting the
 

2385
00:49:02,640 --> 00:49:04,069
that's the blue one we're omitting the
thetas here

2386
00:49:04,069 --> 00:49:04,079
thetas here
 

2387
00:49:04,079 --> 00:49:05,510
thetas here
all the other operations took linear

2388
00:49:05,510 --> 00:49:05,520
all the other operations took linear
 

2389
00:49:05,520 --> 00:49:07,190
all the other operations took linear
time no matter where they were

2390
00:49:07,190 --> 00:49:07,200
time no matter where they were
 

2391
00:49:07,200 --> 00:49:09,270
time no matter where they were
linked lists were really good at insert

2392
00:49:09,270 --> 00:49:09,280
linked lists were really good at insert
 

2393
00:49:09,280 --> 00:49:10,870
linked lists were really good at insert
and delete first they took constant time

2394
00:49:10,870 --> 00:49:10,880
and delete first they took constant time
 

2395
00:49:10,880 --> 00:49:12,390
and delete first they took constant time
but everything else took linear time in

2396
00:49:12,390 --> 00:49:12,400
but everything else took linear time in
 

2397
00:49:12,400 --> 00:49:13,510
but everything else took linear time in
the worst case

2398
00:49:13,510 --> 00:49:13,520
the worst case
 

2399
00:49:13,520 --> 00:49:16,630
the worst case
these new dynamic arrays achieve

2400
00:49:16,630 --> 00:49:16,640
these new dynamic arrays achieve
 

2401
00:49:16,640 --> 00:49:18,470
these new dynamic arrays achieve
get at and set out in constant time

2402
00:49:18,470 --> 00:49:18,480
get at and set out in constant time
 

2403
00:49:18,480 --> 00:49:21,190
get at and set out in constant time
because they maintain this invariant

2404
00:49:21,190 --> 00:49:21,200
because they maintain this invariant
 

2405
00:49:21,200 --> 00:49:25,109
because they maintain this invariant
uh here that a of i equals x

2406
00:49:25,109 --> 00:49:25,119
uh here that a of i equals x
 

2407
00:49:25,119 --> 00:49:27,670
uh here that a of i equals x
i so we can still do gets and set at

2408
00:49:27,670 --> 00:49:27,680
i so we can still do gets and set at
 

2409
00:49:27,680 --> 00:49:29,750
i so we can still do gets and set at
quickly

2410
00:49:29,750 --> 00:49:29,760
quickly
 

2411
00:49:29,760 --> 00:49:31,910
quickly
and we also just showed that insert last

2412
00:49:31,910 --> 00:49:31,920
and we also just showed that insert last
 

2413
00:49:31,920 --> 00:49:33,430
and we also just showed that insert last
is constant amortized

2414
00:49:33,430 --> 00:49:33,440
is constant amortized
 

2415
00:49:33,440 --> 00:49:36,470
is constant amortized
delete last uh

2416
00:49:36,470 --> 00:49:36,480
delete last uh
 

2417
00:49:36,480 --> 00:49:38,470
delete last uh
you don't have to resize the array you

2418
00:49:38,470 --> 00:49:38,480
you don't have to resize the array you
 

2419
00:49:38,480 --> 00:49:39,829
you don't have to resize the array you
could just decrease

2420
00:49:39,829 --> 00:49:39,839
could just decrease
 

2421
00:49:39,839 --> 00:49:41,990
could just decrease
length and boom you've deleted the last

2422
00:49:41,990 --> 00:49:42,000
length and boom you've deleted the last
 

2423
00:49:42,000 --> 00:49:42,870
length and boom you've deleted the last
item

2424
00:49:42,870 --> 00:49:42,880
item
 

2425
00:49:42,880 --> 00:49:44,390
item
it's not so satisfying because if you

2426
00:49:44,390 --> 00:49:44,400
it's not so satisfying because if you
 

2427
00:49:44,400 --> 00:49:46,630
it's not so satisfying because if you
insert n items and then delete n items

2428
00:49:46,630 --> 00:49:46,640
insert n items and then delete n items
 

2429
00:49:46,640 --> 00:49:48,390
insert n items and then delete n items
you'll still have an array of size theta

2430
00:49:48,390 --> 00:49:48,400
you'll still have an array of size theta
 

2431
00:49:48,400 --> 00:49:50,630
you'll still have an array of size theta
n even though your current value of n is

2432
00:49:50,630 --> 00:49:50,640
n even though your current value of n is
 

2433
00:49:50,640 --> 00:49:51,670
n even though your current value of n is
zero

2434
00:49:51,670 --> 00:49:51,680
zero
 

2435
00:49:51,680 --> 00:49:53,510
zero
um you can get around that with a little

2436
00:49:53,510 --> 00:49:53,520
um you can get around that with a little
 

2437
00:49:53,520 --> 00:49:55,349
um you can get around that with a little
bit more trickery which are described in

2438
00:49:55,349 --> 00:49:55,359
bit more trickery which are described in
 

2439
00:49:55,359 --> 00:49:56,549
bit more trickery which are described in
the lecture notes but

2440
00:49:56,549 --> 00:49:56,559
the lecture notes but
 

2441
00:49:56,559 --> 00:49:58,630
the lecture notes but
it's beyond the we're only going to do

2442
00:49:58,630 --> 00:49:58,640
it's beyond the we're only going to do
 

2443
00:49:58,640 --> 00:50:00,630
it's beyond the we're only going to do
very simple amortized analysis in this

2444
00:50:00,630 --> 00:50:00,640
very simple amortized analysis in this
 

2445
00:50:00,640 --> 00:50:01,349
very simple amortized analysis in this
class

2446
00:50:01,349 --> 00:50:01,359
class
 

2447
00:50:01,359 --> 00:50:03,030
class
to prove that that algorithm is also

2448
00:50:03,030 --> 00:50:03,040
to prove that that algorithm is also
 

2449
00:50:03,040 --> 00:50:04,950
to prove that that algorithm is also
constant amortized which it is

2450
00:50:04,950 --> 00:50:04,960
constant amortized which it is
 

2451
00:50:04,960 --> 00:50:07,190
constant amortized which it is
uh you'll see in o46 or you can find it

2452
00:50:07,190 --> 00:50:07,200
uh you'll see in o46 or you can find it
 

2453
00:50:07,200 --> 00:50:09,430
uh you'll see in o46 or you can find it
in the clrs book

2454
00:50:09,430 --> 00:50:09,440
in the clrs book
 

2455
00:50:09,440 --> 00:50:13,839
in the clrs book
uh that's it for today

