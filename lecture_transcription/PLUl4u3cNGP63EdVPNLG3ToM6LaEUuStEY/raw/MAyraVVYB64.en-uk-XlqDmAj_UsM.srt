1
00:00:00,000 --> 00:00:01,976
[SQUEAK]

2
00:00:01,976 --> 00:00:04,445
[SCRATCH]

3
00:00:04,445 --> 00:00:06,421
[CLICK]

4
00:00:13,359 --> 00:00:17,969
JASON KU: Welcome to our
fourth problem session.   Today

5
00:00:17,969 --> 00:00:21,460
we will mostly talk about
binary trees.

6
00:00:21,460 --> 00:00:24,429
We're going to talk a little bit
about binary heaps, it's a

7
00:00:24,429 --> 00:00:27,649
topic we won't
cover until next Tuesday,

8
00:00:27,649 --> 00:00:32,710
but it will appear in
very small ways

9
00:00:32,710 --> 00:00:36,460
in your Problem Set 4, which is due
next Friday.

10
00:00:36,460 --> 00:00:40,660
So I'm going to
look into this material a little bit today.

11
00:00:40,659 --> 00:00:43,149
But it's mostly a concern -- the

12
00:00:43,149 --> 00:00:48,879
subject matter
today is mostly binary trees,

13
00:00:48,880 --> 00:00:52,450
specifically, which are used
for set data structures

14
00:00:52,450 --> 00:00:57,400
and sequence data structures,
as Professor Demain talked

15
00:00:57,399 --> 00:01:01,339
to you about earlier this week.

16
00:01:01,340 --> 00:01:06,100
But by now-- actually,
as of yesterday--

17
00:01:06,099 --> 00:01:08,409
you've seen all the
data structures that we're

18
00:01:08,409 --> 00:01:10,090
going to cover--

19
00:01:10,090 --> 00:01:13,180
that implement the
set interface and the

20
00:01:13,180 --> 00:01:14,470
sequence interface.

21
00:01:14,469 --> 00:01:21,158
Those beautiful tables that
Professor Demain showed you are

22
00:01:21,158 --> 00:01:22,959
now ready.

23
00:01:22,959 --> 00:01:25,209
We have some
data structures that are

24
00:01:25,209 --> 00:01:28,929
really good - constant-time operations
for some operations.

25
00:01:28,930 --> 00:01:32,740
Therefore, we can use them
for some applications.

26
00:01:32,739 --> 00:01:36,519
And this week we've
been describing to

27
00:01:36,519 --> 00:01:40,149
you trees that
achieve, really, pretty

28
00:01:40,150 --> 00:01:43,660
good results for any kind of
query operation on my sets

29
00:01:43,658 --> 00:01:44,979
or sequences --

30
00:01:44,979 --> 00:01:48,320
pretty good, meaning logarithmic
time, not exactly constant.

31
00:01:48,319 --> 00:01:51,894
But for our purposes, log n -

32
00:01:51,894 --> 00:01:54,579
I mean, on your
computer, practically--

33
00:01:54,579 --> 00:01:56,890
not asymptotically,
but practically-- log

34
00:01:56,890 --> 00:02:00,430
n will be no more than
on your computer?

35
00:02:03,519 --> 00:02:07,030
Something like 64, right?

36
00:02:07,030 --> 00:02:11,620
Any input data you work with
, in machine terms,

37
00:02:11,620 --> 00:02:14,000
is your input data.

38
00:02:14,000 --> 00:02:16,000
You have to be able to
address all those machine

39
00:02:16,000 --> 00:02:18,550
words in your input.

40
00:02:18,550 --> 00:02:22,840
And on your computer, the
machine word address size

41
00:02:22,840 --> 00:02:25,030
is 64 bits, right?

42
00:02:25,030 --> 00:02:27,759
And we assume that the
word size is at least the

43
00:02:27,759 --> 00:02:33,699
logarithmic size of your input
so that you can address the input.

44
00:02:33,699 --> 00:02:37,060
So for your purposes,
on your computer,

45
00:02:37,060 --> 00:02:39,099
log n
will be no more than 64,

46
00:02:39,099 --> 00:02:42,460
which means you'll get
maybe a 50x overlap,

47
00:02:42,460 --> 00:02:45,670
or for smaller cases
it could be more than 10

48
00:02:45,668 --> 00:02:49,299
if you have 1000 things
you're working on.

49
00:02:49,300 --> 00:02:50,620
Not so bad, right?

50
00:02:50,620 --> 00:02:53,740
This is a constant - it's not a
constant factor for theoretical

51
00:02:53,740 --> 00:02:57,969
purposes, but for your purposes
log n is much better than a

52
00:02:57,969 --> 00:02:59,978
polynomial factor -

53
00:02:59,978 --> 00:03:03,250
another factor of n.

54
00:03:03,250 --> 00:03:05,800
You've seen all the code.

55
00:03:05,800 --> 00:03:08,950
You've seen implementations of
all those set and sequence interfaces

56
00:03:08,949 --> 00:03:10,299
, right?

57
00:03:10,300 --> 00:03:12,550
So I went ahead and
wrote a little bit...

58
00:03:12,550 --> 00:03:15,490
I put all this code together
from your recitation notes,

59
00:03:15,490 --> 00:03:18,610
all the different
interface implementations.

60
00:03:18,610 --> 00:03:22,720
I
wrote a small test program

61
00:03:22,719 --> 00:03:25,960
to see how they work
on a real machine.

62
00:03:25,960 --> 00:03:30,340
I have a small test code.

63
00:03:30,340 --> 00:03:35,409
I have a small folder that
lists an array that implements

64
00:03:35,409 --> 00:03:37,270
a sequence, a binary
tree that implements

65
00:03:37,270 --> 00:03:39,400
a sequence, a dynamic
array that implements...

66
00:03:39,400 --> 00:03:41,170
all of these things.

67
00:03:41,168 --> 00:03:45,250
Then set things up-- a sorted array, which
is a set in a binary tree,

68
00:03:45,250 --> 00:03:46,599
and a hash table.

69
00:03:46,599 --> 00:03:48,009
These are our implementations.

70
00:03:48,009 --> 00:03:50,709
I don't use
Python dictionaries for hash tables,

71
00:03:50,710 --> 00:03:55,329
I use the implementations
that are in your presentation.

72
00:03:55,329 --> 00:03:56,980
And I'm going to
run this little

73
00:03:56,978 --> 00:03:59,439
Python code efficiency test
that will basically just

74
00:03:59,439 --> 00:04:00,550
fire everyone.

75
00:04:00,550 --> 00:04:03,370
It will perform a series of
these different operations

76
00:04:03,370 --> 00:04:05,650
and measure to see
how long it took.

77
00:04:05,650 --> 00:04:07,719
I'm just recording
how long it took.

78
00:04:07,719 --> 00:04:11,379
This is not an asymptotic
analysis, but hopefully we

79
00:04:11,379 --> 00:04:13,329
see some separation.

80
00:04:13,330 --> 00:04:16,389
So when you click this,
it runs a bunch of tests.

81
00:04:16,389 --> 00:04:19,269
Let's take a look.

82
00:04:19,269 --> 00:04:20,620
good.

83
00:04:20,620 --> 00:04:23,660
I have a bunch of
consecutive operations.

84
00:04:23,660 --> 00:04:28,150
We have build, set_at,
get-at, insert, delete

85
00:04:28,149 --> 00:04:30,879
in different places.

86
00:04:30,879 --> 00:04:36,250
And these are actual
timings at a certain scale --

87
00:04:36,250 --> 00:04:39,610
at a certain resolution that I had
for these data structures.

88
00:04:39,610 --> 00:04:41,680
And you see that assembly--

89
00:04:41,680 --> 00:04:44,170
actually, assembly,
on this machine,

90
00:04:44,170 --> 00:04:46,270
just allocating some
array and cleaning it up,

91
00:04:46,269 --> 00:04:49,849
is a really efficient thing that
Python is going to do for me.

92
00:04:49,850 --> 00:04:54,520
And actually... this is a
misnomer for log n.

93
00:04:54,519 --> 00:04:57,969
But these other things,
get_at and set_at-- they're

94
00:04:57,970 --> 00:04:59,680
really, really fast, right?

95
00:04:59,680 --> 00:05:00,910
This is constant time.

96
00:05:00,910 --> 00:05:02,800
And then these other
things, I basically

97
00:05:02,800 --> 00:05:05,020
can't do any better than
scroll through it,

98
00:05:05,019 --> 00:05:06,729
so it takes linear time.

99
00:05:06,730 --> 00:05:11,500
And again the sequence,
setting_at and getting_at is

100
00:05:11,500 --> 00:05:15,250
slow, but by deleting and
removing from the first one,

101
00:05:15,250 --> 00:05:17,800
I'm just rebinding
the pointer, right?

102
00:05:17,800 --> 00:05:18,910
Dynamic arrays.

103
00:05:18,910 --> 00:05:23,439
Again, set_at, get_at are
fast because they are

104
00:05:23,439 --> 00:05:24,670
regular arrays.

105
00:05:24,670 --> 00:05:27,340
And then inserting
and removing the last one,

106
00:05:27,339 --> 00:05:30,009
it's
essentially constant time.

107
00:05:30,009 --> 00:05:32,680
Now I actually... when I
run these tests to deal

108
00:05:32,680 --> 00:05:34,180
with averages, I
actually run

109
00:05:34,180 --> 00:05:36,980
these things, many times,
and test their performance.

110
00:05:36,980 --> 00:05:41,500
And so I don't see the
worst case scenario, do I?

111
00:05:41,500 --> 00:05:43,420
I average all the
things, which is

112
00:05:43,420 --> 00:05:46,629
exactly what
depreciation means.

113
00:05:46,629 --> 00:05:50,560
That's why I get
good results here.

114
00:05:50,560 --> 00:05:51,939
Hash table.

115
00:05:51,939 --> 00:05:56,709
Again, really...
oh, this is what

116
00:05:56,709 --> 00:05:59,319
we talked about
in

117
00:05:59,319 --> 00:06:04,180
last week's problem session, implementing a
kind of two-way queue

118
00:06:04,180 --> 00:06:06,069
with a hash table.

119
00:06:06,069 --> 00:06:07,449
Here is the implementation.

120
00:06:07,449 --> 00:06:09,129
I just wanted to show it to you.

121
00:06:09,129 --> 00:06:10,459
But it's actually very good.

122
00:06:10,459 --> 00:06:14,079
This is what JavaScript
uses for arrays.

123
00:06:14,079 --> 00:06:19,240
And then a binary sequence
represented as a binary tree - a

124
00:06:19,240 --> 00:06:20,550
balanced binary tree.

125
00:06:20,550 --> 00:06:22,480
This is our AVL code that I had.

126
00:06:22,480 --> 00:06:25,720
And all the other things
were really bad

127
00:06:25,720 --> 00:06:28,338
in insert_at and
delete_at, but this one

128
00:06:28,338 --> 00:06:30,129
works comparably to all the
other things.

129
00:06:30,129 --> 00:06:34,060
Now you see that this is
a little more machine

130
00:06:34,060 --> 00:06:39,230
cycles than other things,
but it's really not that bad.

131
00:06:39,230 --> 00:06:41,710
And then,

132
00:06:41,709 --> 00:06:44,419
again, we had a sorted array.

133
00:06:44,420 --> 00:06:46,840
Sorry, this is a
set from an array.

134
00:06:46,839 --> 00:06:48,969
Essentially, it is an
unsorted array.

135
00:06:48,970 --> 00:06:52,480
I'm just looking for all
this - these are really bad times.  A

136
00:06:52,480 --> 00:06:54,970
sorted array makes these
operations great,

137
00:06:54,970 --> 00:06:58,040
but insertion and
deletion are bad.

138
00:06:58,040 --> 00:07:00,819
This is why we need binary trees.

139
00:07:00,819 --> 00:07:05,079
Hash tables get good dictionary
operations but very

140
00:07:05,079 --> 00:07:08,409
poor order operations.

141
00:07:08,410 --> 00:07:13,990
And then the binary
search tree, the tuned binary tree, again,

142
00:07:13,990 --> 00:07:16,490
does
all of these things pretty well.

143
00:07:16,490 --> 00:07:20,449
In fact, it gets
really quite good - somehow it

144
00:07:20,449 --> 00:07:22,300
gets better

145
00:07:22,300 --> 00:07:26,199
than even a sorted array.

146
00:07:26,199 --> 00:07:27,729
I don't know why.

147
00:07:27,730 --> 00:07:30,220
Our implementations are
not optimized at all.

148
00:07:30,220 --> 00:07:31,890
But it's pretty
good asymptotically.

149
00:07:31,889 --> 00:07:32,159
Yes?

150
00:07:32,159 --> 00:07:33,534
AUDIENCE: Can
you explain again

151
00:07:33,534 --> 00:07:38,470
why the first
data vault [INAUDIBLE] registers n?

152
00:07:38,470 --> 00:07:41,830
JASON KU: It's just
marked based on time.

153
00:07:41,829 --> 00:07:43,930
It so happens that

154
00:07:43,930 --> 00:07:47,199
there is probably an internal C under Python
that allocates this thing,

155
00:07:47,199 --> 00:07:49,060
and therefore does it very quickly.

156
00:07:49,060 --> 00:07:51,459
My program, which
looks at these numbers

157
00:07:51,459 --> 00:07:54,349
and tries to guess what the
asymptotic running time is,

158
00:07:54,350 --> 00:07:57,590
is just labels based
on these things, ranges.

159
00:07:57,589 --> 00:07:59,112
I just... it's mischaracterized.

160
00:07:59,112 --> 00:08:01,605
AUDIENCE: [INAUDIBLE]

161
00:08:01,605 --> 00:08:02,230
JASON KU: Yes.

162
00:08:02,230 --> 00:08:06,939
Well, I mean, actually,
if this was C code--

163
00:08:06,939 --> 00:08:09,730
if all of this stuff
was in C, maybe

164
00:08:09,730 --> 00:08:12,819
we would see that this strip would be
longer because it actually has to

165
00:08:12,819 --> 00:08:15,370
go through and
touch all of this memory.

166
00:08:15,370 --> 00:08:18,250
It's still being done here,
but all things Python are

167
00:08:18,250 --> 00:08:19,810
extremely terrible.

168
00:08:19,810 --> 00:08:23,110
It's about 100 times slower
than anything C does.

169
00:08:23,110 --> 00:08:26,730
And you see
that discrepancy.  Does

170
00:08:26,730 --> 00:08:27,920
this make sense?

171
00:08:27,920 --> 00:08:28,420
good.

172
00:08:28,420 --> 00:08:30,610
I just wanted to show you this.

173
00:08:30,610 --> 00:08:33,850
We could have released this for
you to play,

174
00:08:33,850 --> 00:08:36,308
but we just wanted to give
you a taste.

175
00:08:36,308 --> 00:08:41,009
Okay, any questions
before we continue?

176
00:08:41,009 --> 00:08:42,879
How do I turn this off?

177
00:08:42,879 --> 00:08:46,960
Up and away.

178
00:08:46,960 --> 00:08:47,680
Turn off.

179
00:08:51,750 --> 00:08:52,779
so

180
00:08:52,779 --> 00:08:53,279
good.

181
00:08:58,440 --> 00:09:02,640
Let's move on to the problems -
let's solve some problems.

182
00:09:02,639 --> 00:09:04,659
You have a set of
problems here.

183
00:09:04,659 --> 00:09:09,482
First, we
will consider an AVL sequence tree.

184
00:09:09,482 --> 00:09:10,649
This is an AVL sequence tree.

185
00:09:10,649 --> 00:09:11,442
How do I know this?

186
00:09:15,200 --> 00:09:16,759
You don't have to.

187
00:09:16,759 --> 00:09:19,460
But these things are
definitely not

188
00:09:19,460 --> 00:09:23,450
in the order of what
I store in them, right?

189
00:09:23,450 --> 00:09:26,420
So it's better not
to be a tuned AVL tree.

190
00:09:26,419 --> 00:09:27,529
Is this an AVL tree?  Is

191
00:09:27,529 --> 00:09:30,509
this balanced--
balanced in height?

192
00:09:30,509 --> 00:09:32,220
Yes, basically.

193
00:09:32,220 --> 00:09:36,810
In fact, if you calculate
the size of each subtree, the

194
00:09:36,809 --> 00:09:39,119
left and right subtrees
on all of these (you

195
00:09:39,120 --> 00:09:41,399
can verify for
yourself) are balanced.

196
00:09:41,399 --> 00:09:43,949
They are within plus or
minus 1 of each other.

197
00:09:43,950 --> 00:09:46,500
In fact, this is
so far from the balance

198
00:09:46,500 --> 00:09:50,549
you could get
for this many nodes while

199
00:09:50,549 --> 00:09:52,599
maintaining
height balance--

200
00:09:52,600 --> 00:09:54,720
while maintaining the
AVL property-- that

201
00:09:54,720 --> 00:09:56,040
it's an instructive example.

202
00:09:56,039 --> 00:09:58,740
It's like being on the edge.

203
00:09:58,740 --> 00:10:02,370
And what will I do?

204
00:10:02,370 --> 00:10:04,980
What is missing from this
image if I claim that

205
00:10:04,980 --> 00:10:08,789
it is a sequential AVL tree?

206
00:10:08,789 --> 00:10:11,849
Any ideas what's missing?

207
00:10:11,850 --> 00:10:14,700
What does the
AVL sequence tree store that I don't

208
00:10:14,700 --> 00:10:16,360
show in this image?

209
00:10:16,360 --> 00:10:17,190
AUDIENCE: Counts.

210
00:10:17,190 --> 00:10:17,490
JASON KU: What?

211
00:10:17,490 --> 00:10:18,282
AUDIENCE: Counts.

212
00:10:18,282 --> 00:10:18,990
JASON KU: It counts.

213
00:10:18,990 --> 00:10:19,490
and?

214
00:10:22,519 --> 00:10:25,360
This is a sequential AVL tree.

215
00:10:25,360 --> 00:10:27,320
Height, right?

216
00:10:27,320 --> 00:10:29,470
A sequence of AVL trees,
different from the established AVL trees,

217
00:10:29,470 --> 00:10:31,000
is complemented by
two things, right?

218
00:10:31,000 --> 00:10:34,690
Because I need to
maintain balance while

219
00:10:34,690 --> 00:10:36,910
spinning, so I
need to maintain altitude.

220
00:10:36,909 --> 00:10:39,490
I need to be able to determine
the height of these subtrees

221
00:10:39,490 --> 00:10:41,440
in constant time
as I climb the

222
00:10:41,440 --> 00:10:43,090
tree, fixing things.

223
00:10:43,090 --> 00:10:47,440
And consistency requires me
to store their subtree numbers

224
00:10:47,440 --> 00:10:50,200
there.

225
00:10:50,200 --> 00:10:52,030
I don't know... I
won't draw it

226
00:10:52,029 --> 00:10:55,269
for all these things, but
what about number four?

227
00:10:55,269 --> 00:10:56,049
What is its height?

228
00:10:59,669 --> 00:11:00,839
1, 2, 3.

229
00:11:00,840 --> 00:11:05,200
This is the longest path from the
root subtree.

230
00:11:05,200 --> 00:11:09,210
So this is height equal to 3.

231
00:11:09,210 --> 00:11:13,900
This came from height equal to
2, and height equal to 1. Does

232
00:11:13,899 --> 00:11:15,000
everyone see that?

233
00:11:15,000 --> 00:11:15,690
Yes?

234
00:11:15,690 --> 00:11:18,390
And then the size
here, how big is it?

235
00:11:18,389 --> 00:11:22,439
This is 1, 2, 3, 4, 5, 6, 7.

236
00:11:22,440 --> 00:11:27,060
This is... I'm going to
put a size here that's 7.

237
00:11:27,059 --> 00:11:31,769
And this comes from
this guy, 1, 2, 3, 4.

238
00:11:31,769 --> 00:11:33,105
And this guy is 2.

239
00:11:36,299 --> 00:11:39,699
So how do I calculate
the size of the subtree?

240
00:11:39,700 --> 00:11:43,830
This is the size of my left subtree plus the
size of my right subtree plus 1.

241
00:11:43,830 --> 00:11:47,100
And my height takes the
maximum value of 2 plus 1.

242
00:11:47,100 --> 00:11:47,600
Okay.

243
00:11:47,600 --> 00:11:50,279
So, we did all of this yesterday.

244
00:11:50,279 --> 00:11:52,860
I'm just marking these things.

245
00:11:52,860 --> 00:11:59,730
I am asking you
to perform a delete operation.

246
00:11:59,730 --> 00:12:02,250
This is a sequence tree.

247
00:12:02,250 --> 00:12:06,190
So I find things by
their index in the tree.

248
00:12:06,190 --> 00:12:08,790
So I'm going to ask you
to remove the eighth thing

249
00:12:08,789 --> 00:12:10,980
in my sequence.

250
00:12:10,980 --> 00:12:14,769
What is the 8th
in my sequence?

251
00:12:14,769 --> 00:12:15,370
Yes?

252
00:12:15,370 --> 00:12:17,889
AUDIENCE: To clarify,
because delete-8 is not a deletion of

253
00:12:17,889 --> 00:12:18,519
a number.

254
00:12:18,519 --> 00:12:19,269
JASON KU: That's right.

255
00:12:19,269 --> 00:12:21,360
Well, delete_at 8. Do

256
00:12:21,360 --> 00:12:22,236
you see that?

257
00:12:22,236 --> 00:12:23,319
This is a sequential operation.

258
00:12:23,320 --> 00:12:23,650
AUDIENCE: Oh, okay.

259
00:12:23,649 --> 00:12:24,194
[INAUDIBLE]

260
00:12:24,195 --> 00:12:24,820
JASON KU: Yes.

261
00:12:24,820 --> 00:12:27,160
Therefore, it is very
important

262
00:12:27,159 --> 00:12:30,339
to distinguish between
sequence and set semantics.

263
00:12:30,340 --> 00:12:32,139
If I'm dealing
with a sequence,

264
00:12:32,139 --> 00:12:35,439
I'd rather not
look for internal things

265
00:12:35,440 --> 00:12:38,390
in that data structure, because
it's not an internal

266
00:12:38,389 --> 00:12:38,889
data structure.

267
00:12:38,889 --> 00:12:39,909
This does not support this.

268
00:12:39,909 --> 00:12:46,870
If I wanted to support searching for,
say, key index 8

269
00:12:46,870 --> 00:12:50,409
or something like that,
then all I could do

270
00:12:50,409 --> 00:12:51,992
is look like an array.

271
00:12:51,993 --> 00:12:54,160
I would just need to scroll through the
entire sequence

272
00:12:54,159 --> 00:12:56,289
and tell me if there
is a thing in it.

273
00:12:56,289 --> 00:12:58,164
It's impossible to do better
than linear time.

274
00:12:58,164 --> 00:13:00,039
This data structure is
not designed for this.

275
00:13:00,039 --> 00:13:01,039
What is it for?

276
00:13:01,039 --> 00:13:05,139
It is designed to search for things
by their index in a sequence.

277
00:13:05,139 --> 00:13:12,129
So how do I find the 8th index?

278
00:13:12,129 --> 00:13:14,110
Well, I mean, I
look at the tree

279
00:13:14,110 --> 00:13:17,139
and I can just count
along the circuit in order.

280
00:13:17,139 --> 00:13:19,990
What is a walkthrough in order?

281
00:13:19,990 --> 00:13:24,850
0, 1, 2, 3, 4, 5, 6, 7.

282
00:13:24,850 --> 00:13:26,529
Okay, found 8.

283
00:13:26,529 --> 00:13:29,470
But what
does a sequential AVL tree do?

284
00:13:32,620 --> 00:13:34,990
I'm storing
the dimensions of the subtree, and when I'm here,

285
00:13:34,990 --> 00:13:38,110
I don't know what index I have.

286
00:13:38,110 --> 00:13:40,899
How can I find out what
my index is from the root?

287
00:13:40,899 --> 00:13:44,980
I look at my left subtree, I
see how many there are.  There

288
00:13:44,980 --> 00:13:47,990
are seven things here.

289
00:13:47,990 --> 00:13:52,909
1, 2, 3, 4, 5, 6, 7.

290
00:13:52,909 --> 00:13:53,409
Yes.

291
00:13:53,409 --> 00:13:57,279
Because I'm looking for the
9th item at index 8.

292
00:13:57,279 --> 00:14:01,059
That means
I'm the 8th item.

293
00:14:01,059 --> 00:14:03,484
I'm a guy with the index number 7. Does

294
00:14:03,485 --> 00:14:04,360
that make sense?

295
00:14:04,360 --> 00:14:07,310
Because I'm looking at the
size of the subtree.

296
00:14:07,309 --> 00:14:08,929
So what do I know?

297
00:14:08,929 --> 00:14:13,239
I know the index I'm
looking for is to my right.

298
00:14:13,240 --> 00:14:17,350
I come in here
and I happen to know...

299
00:14:17,350 --> 00:14:23,470
what index am I
looking for in this subtree?

300
00:14:23,470 --> 00:14:25,090
0, right?

301
00:14:25,090 --> 00:14:27,490
I want the first one
in the subtree.   Now

302
00:14:27,490 --> 00:14:32,379
my search index has changed
, because I have actually dealt

303
00:14:32,379 --> 00:14:35,740
with all eight of these points.

304
00:14:35,740 --> 00:14:38,990
Here I am looking for the
0th thing in my index.

305
00:14:38,990 --> 00:14:40,289
I look to the left—

306
00:14:40,289 --> 00:14:43,929
if I didn't have a left subtree,
I would be zero,

307
00:14:43,929 --> 00:14:45,009
and I would turn myself around.

308
00:14:45,009 --> 00:14:46,330
But there is something here.

309
00:14:46,330 --> 00:14:51,850
So I'm looking for the 0th thing here
, which is just him,

310
00:14:51,850 --> 00:14:53,560
and I'm returning it.

311
00:14:53,559 --> 00:14:56,889
And actually,
I'm deleting it.

312
00:14:56,889 --> 00:15:00,189
So I'm deleting it.

313
00:15:02,610 --> 00:15:05,382
What's the problem here?

314
00:15:05,381 --> 00:15:06,259
AUDIENCE: [INAUDIBLE]

315
00:15:06,259 --> 00:15:07,919
JASON KU: The height is unbalanced.

316
00:15:07,919 --> 00:15:10,610
What is unbalanced in height here?

317
00:15:10,610 --> 00:15:12,509
AUDIENCE: Left subtree -

318
00:15:12,509 --> 00:15:13,149
or, sorry.

319
00:15:13,149 --> 00:15:13,829
[INAUDIBLE]

320
00:15:13,830 --> 00:15:15,280
JASON KU: This guy doesn't have a
balanced growth, does he?

321
00:15:15,279 --> 00:15:17,100
AUDIENCE: --right subtree of
right [INAUDIBLE].

322
00:15:17,100 --> 00:15:19,557
JASON KU: This guy's subtree is
not balanced in height, right?

323
00:15:19,557 --> 00:15:20,250
This guy 2.

324
00:15:20,250 --> 00:15:22,379
This guy 1.

325
00:15:22,379 --> 00:15:24,299
So how do we fix this?

326
00:15:24,299 --> 00:15:25,740
AUDIENCE: Turn around.

327
00:15:25,740 --> 00:15:27,690
JASON KU: We do a few rotations.

328
00:15:27,690 --> 00:15:30,470
This is actually a
bad case, the

329
00:15:30,470 --> 00:15:33,570
third bad case
we talked about yesterday.

330
00:15:33,570 --> 00:15:37,260
If I tried to just
turn this guy to the left,

331
00:15:37,259 --> 00:15:38,539
what would it look like?

332
00:15:38,539 --> 00:15:40,740
This will be 12.

333
00:15:40,740 --> 00:15:42,240
This will be 10.

334
00:15:42,240 --> 00:15:45,360
And 8 will be added to that.

335
00:15:45,360 --> 00:15:48,090
Now the height is misbalanced
in the other direction, right?

336
00:15:48,090 --> 00:15:49,950
This is bad.

337
00:15:49,950 --> 00:15:53,490
So how do I solve
this case where

338
00:15:53,490 --> 00:15:59,100
I'm heavily skewed
to the right, but my right subtree is

339
00:15:59,100 --> 00:16:03,899
skewed to the left, I
have to do a rotation here,

340
00:16:03,899 --> 00:16:06,809
a rotation to the right, and
then do a rotation.

341
00:16:06,809 --> 00:16:08,879
This is a formula.

342
00:16:08,879 --> 00:16:10,919
Here we first do
a right rotation

343
00:16:10,919 --> 00:16:21,439
of 10, which gives me something
like 8, 10.

344
00:16:21,440 --> 00:16:25,150
Now, obviously, this is not
better than what was before,

345
00:16:25,149 --> 00:16:28,750
but it was an intermediate
step so that we could fix it.

346
00:16:28,750 --> 00:16:32,049
We turn right here, and
then we turn left here.

347
00:16:32,049 --> 00:16:34,289
By default, we
rotate to the left here,

348
00:16:34,289 --> 00:16:38,439
but since this has a
skew in the wrong direction,

349
00:16:38,440 --> 00:16:41,390
I need to rotate this to the right first,
and then we can do that.

350
00:16:41,389 --> 00:16:43,569
Now I rotate
all these guys

351
00:16:43,570 --> 00:16:50,004
and put 12
here, 8 here, 10 here.  Does

352
00:16:53,009 --> 00:16:56,700
everyone see what the
rotation looks like?

353
00:16:56,700 --> 00:16:57,230
good.   It will

354
00:16:57,230 --> 00:17:00,210
take you some time to understand
what

355
00:17:00,210 --> 00:17:02,970
transformation is, but
hopefully you

356
00:17:02,970 --> 00:17:04,282
have all followed this transformation.

357
00:17:04,281 --> 00:17:06,449
There was a bit of magic
when I tried to draw.

358
00:17:06,450 --> 00:17:06,930
Yes?

359
00:17:06,930 --> 00:17:08,500
AUDIENCE: I still don't
feel like this tree is

360
00:17:08,500 --> 00:17:09,269
balanced in height.

361
00:17:09,269 --> 00:17:10,980
JASON KU: That's not true.

362
00:17:10,980 --> 00:17:12,630
Good observation.

363
00:17:12,630 --> 00:17:13,890
why is that?

364
00:17:13,890 --> 00:17:15,750
This thing still has a height of 3.

365
00:17:15,750 --> 00:17:17,549
What is the height of
this thing?

366
00:17:17,549 --> 00:17:19,019
1, right?

367
00:17:19,019 --> 00:17:20,700
This is height 1.

368
00:17:20,700 --> 00:17:23,400
And actually when I
did this rotation,

369
00:17:23,400 --> 00:17:27,317
I needed to update all of
these extensions.

370
00:17:27,317 --> 00:17:28,859
What extensions did
I really need--

371
00:17:28,859 --> 00:17:31,619
what subtrees
changed during these things?

372
00:17:36,380 --> 00:17:38,810
I don't remember what
this thing looked like.

373
00:17:38,809 --> 00:17:41,779
What did the thing look like?

374
00:17:41,779 --> 00:17:46,859
10 had 8 in its subtree, so
its subtree definitely changed.

375
00:17:46,859 --> 00:17:48,139
Subtree 8 has been modified.

376
00:17:48,140 --> 00:17:49,220
AUDIENCE: [INAUDIBLE]

377
00:17:49,220 --> 00:17:51,000
JASON KU: 12 hasn't changed--

378
00:17:51,000 --> 00:17:51,500
after all.

379
00:17:51,500 --> 00:17:54,498
AUDIENCE: It's
10 and 8 [INAUDIBLE].

380
00:17:54,498 --> 00:17:55,039
JASON KU: Okay.

381
00:17:55,039 --> 00:17:57,920
So, there is a case analysis
that is in your lecture notes

382
00:17:57,920 --> 00:18:00,050
and was done during the recitation.

383
00:18:00,049 --> 00:18:03,799
This tells you that
these subtrees A, B, C, D

384
00:18:03,799 --> 00:18:06,859
,
the ones that can

385
00:18:06,859 --> 00:18:09,649
change in these things,
these subtrees don't change.

386
00:18:09,650 --> 00:18:12,290
The only subtree that
has changed during one

387
00:18:12,289 --> 00:18:15,619
of these patch operations, when
you do one or two rotations,

388
00:18:15,619 --> 00:18:18,859
are either the two nodes
or the three nodes

389
00:18:18,859 --> 00:18:20,240
whose subtree has changed.

390
00:18:20,240 --> 00:18:23,900
Here it could be that
three subtrees have changed

391
00:18:23,900 --> 00:18:26,000
.

392
00:18:26,000 --> 00:18:29,779
But in the easy case, only
two nodes-- x and y, I think,

393
00:18:29,779 --> 00:18:31,129
in the notes--

394
00:18:31,130 --> 00:18:32,040
could change.

395
00:18:32,039 --> 00:18:36,710
And so when I do that, I have to
recalculate their expansions

396
00:18:36,710 --> 00:18:39,200
from their expansions of
their children,

397
00:18:39,200 --> 00:18:42,110
but that's just a constant
number,

398
00:18:42,109 --> 00:18:45,779
so I just recalculate them
because the subtrees underneath me

399
00:18:45,779 --> 00:18:47,430
haven't changed.

400
00:18:47,430 --> 00:18:47,930
good.

401
00:18:47,930 --> 00:18:50,279
So we have a
height mismatch here.

402
00:18:50,279 --> 00:18:50,925
Yes?

403
00:18:50,925 --> 00:18:52,164
AUDIENCE: [INAUDIBLE]

404
00:18:56,742 --> 00:18:57,409
JASON KU: Yes.

405
00:18:57,410 --> 00:19:01,730
So, initially
in the image, 12

406
00:19:01,730 --> 00:19:04,009
has a bunch of things
in its subtree--

407
00:19:04,009 --> 00:19:08,349
10 and 8, and we just removed 7.

408
00:19:08,349 --> 00:19:09,849
So its subtree has
definitely changed.  There

409
00:19:09,849 --> 00:19:10,980
used to be three...

410
00:19:10,980 --> 00:19:12,039
AUDIENCE: [INAUDIBLE]

411
00:19:12,039 --> 00:19:14,129
JASON KU: Oh, no, sorry, that's what it was.  so So

412
00:19:14,680 --> 00:19:18,039
, here three subtrees of nodes have changed
.

413
00:19:18,039 --> 00:19:20,889
But this is actually the biggest thing.

414
00:19:20,890 --> 00:19:23,620
I'll show you the worst case scenario.

415
00:19:23,619 --> 00:19:25,869
Only three nodes
possible in performing

416
00:19:25,869 --> 00:19:28,142
one of these
double rotations

417
00:19:28,143 --> 00:19:29,559
could change
their subtrees.

418
00:19:29,559 --> 00:19:32,740
And so we just have to fix the
increase in these three

419
00:19:32,740 --> 00:19:33,609
things.

420
00:19:33,609 --> 00:19:36,879
In a mild case,
it's just two things.

421
00:19:36,880 --> 00:19:38,050
Okay,

422
00:19:38,049 --> 00:19:39,579
we're unbalanced.

423
00:19:39,579 --> 00:19:40,599
How can we fix this?

424
00:19:43,519 --> 00:19:45,889
I could have been angry.

425
00:19:45,890 --> 00:19:49,070
I want to be able to
rotate right here

426
00:19:49,069 --> 00:19:54,139
to restore balance, I could be
angry and switch these two.

427
00:19:54,140 --> 00:19:56,150
If I were to swap those
two, I would have to

428
00:19:56,150 --> 00:19:58,100
do two rotations
to fix this thing

429
00:19:58,099 --> 00:20:01,039
because the middle one is
heavier than the left one

430
00:20:01,039 --> 00:20:04,250
compared to what I'm doing.

431
00:20:04,250 --> 00:20:09,140
But I'm not that angry, so
I'm going to turn right.

432
00:20:09,140 --> 00:20:10,370
How do I do this?

433
00:20:10,369 --> 00:20:13,129
Well, turning right
by 6

434
00:20:13,130 --> 00:20:16,940
will drop all of
that below 4

435
00:20:16,940 --> 00:20:20,075
and attach that subtree
as the left child of 6.

436
00:20:20,075 --> 00:20:21,830
Does that make sense?

437
00:20:21,829 --> 00:20:22,437
Phew,

438
00:20:22,438 --> 00:20:23,730
this will be fun to draw.

439
00:20:28,099 --> 00:20:30,579
I'll just redraw it.

440
00:20:30,579 --> 00:20:32,389
That makes more sense, doesn't it?

441
00:20:32,390 --> 00:20:54,020
4, 11, 3, 2, 1, and
then 6, 5, 9, 8, 12, 10.

442
00:20:54,019 --> 00:20:57,730
That's the correct rotation for 6. Does

443
00:20:57,730 --> 00:21:00,519
everyone like that?

444
00:21:00,519 --> 00:21:05,139
Rotation - my
x is 6, my y is 4.

445
00:21:05,140 --> 00:21:09,400
I have subtrees A, B, C.

446
00:21:09,400 --> 00:21:12,610
What I'm doing is sort of
switching which of x and y

447
00:21:12,609 --> 00:21:15,609
is the root here.

448
00:21:15,609 --> 00:21:23,079
So now y is the root, and
subtrees B and C become

449
00:21:23,079 --> 00:21:25,480
descendants of x under y.

450
00:21:25,480 --> 00:21:29,110
And note that, hopefully,

451
00:21:29,109 --> 00:21:33,149
my order of operations has
not changed throughout this process.

452
00:21:33,150 --> 00:21:35,600
We had to update our
additions along the way,

453
00:21:35,599 --> 00:21:38,629
but that's a constant
as we climb the tree.

454
00:21:38,630 --> 00:21:41,510
And we only walk the tree a
logarithmic number of times.

455
00:21:41,509 --> 00:21:42,460
Yes?

456
00:21:42,460 --> 00:21:42,960
so

457
00:21:42,960 --> 00:21:43,880
AUDIENCE: [INAUDIBLE].

458
00:21:43,880 --> 00:21:46,778
So every time we do a
rotation, you just

459
00:21:46,778 --> 00:21:48,569
update the extension
with [INDISPENSABLE]

460
00:21:48,569 --> 00:21:49,849
before we do another rotation?

461
00:21:49,849 --> 00:21:50,144
JASON KU: Exactly.

462
00:21:50,144 --> 00:21:51,375
AUDIENCE: Part two.

463
00:21:51,375 --> 00:21:53,869
Updating
the increase means just

464
00:21:53,869 --> 00:21:57,379
updating the quantity,
height, and just

465
00:21:57,380 --> 00:21:58,510
the properties that remain...

466
00:21:58,509 --> 00:21:59,134
JASON KU: Yes.

467
00:21:59,134 --> 00:22:00,650
Essentially, what we
did was we defined--

468
00:22:00,650 --> 00:22:02,390
when we added--

469
00:22:02,390 --> 00:22:04,610
Professor Demain
defined for you yesterday

470
00:22:04,609 --> 00:22:07,099
what the subtree property is.

471
00:22:07,099 --> 00:22:10,490
This meant a property
that I could calculate just

472
00:22:10,490 --> 00:22:12,589
by looking at my children--

473
00:22:12,589 --> 00:22:16,250
incrementing my
children, recursively.

474
00:22:16,250 --> 00:22:20,569
So, instead of
trying to increment or trying to

475
00:22:20,569 --> 00:22:24,439
think locally what
that increment should be,

476
00:22:24,440 --> 00:22:26,990
I'm going to throw away
my old increment

477
00:22:26,990 --> 00:22:28,670
and just enumerate
it using its children,

478
00:22:28,670 --> 00:22:31,904
because that, recursively,
should be correct.  Does

479
00:22:31,904 --> 00:22:32,779
this make sense?

480
00:22:32,779 --> 00:22:33,462
Yes?

481
00:22:33,462 --> 00:22:35,629
AUDIENCE: So, just looking
at how the rotation works.

482
00:22:35,630 --> 00:22:38,420
It's hard for me to
wrap my head around.

483
00:22:38,420 --> 00:22:41,870
So, essentially, you swap
4 and 6, and so

484
00:22:41,869 --> 00:22:47,389
4 becomes the parent node
and 6 becomes the right node.

485
00:22:47,390 --> 00:22:50,480
JASON KU: I'm going to
draw this picture.

486
00:22:50,480 --> 00:22:52,279
It's just something
you have to remember.

487
00:22:55,420 --> 00:23:05,640
This is x, B, C, and A.
See this image?

488
00:23:05,640 --> 00:23:07,495
AUDIENCE: [INAUDIBLE]

489
00:23:07,494 --> 00:23:08,119
JASON KU: What?

490
00:23:08,119 --> 00:23:09,354
AUDIENCE: [INAUDIBLE]

491
00:23:09,355 --> 00:23:09,980
JASON KU: Yes.

492
00:23:09,980 --> 00:23:11,089
It's in your notes.

493
00:23:11,089 --> 00:23:12,779
It's not a big deal.

494
00:23:12,779 --> 00:23:15,139
But if you have a
structure like this

495
00:23:15,140 --> 00:23:19,009
where x has a left child,

496
00:23:19,009 --> 00:23:21,150
these subtrees
may or may not be empty.

497
00:23:21,150 --> 00:23:22,100
It doesn't really matter.

498
00:23:22,099 --> 00:23:25,490
What I can do is
go from here to there--

499
00:23:25,490 --> 00:23:30,779
has the same
traversal order,

500
00:23:30,779 --> 00:23:32,139
but has a different shape.

501
00:23:32,140 --> 00:23:34,050
In particular,
the height of the subtree has changed

502
00:23:34,049 --> 00:23:37,740
, which
may help us restore the balance of the tree.

503
00:23:37,740 --> 00:23:39,960
And that's the
whole point of AVL.  Does

504
00:23:39,960 --> 00:23:41,350
this make sense?

505
00:23:41,349 --> 00:23:43,319
AUDIENCE: Is this the
correct rotation?

506
00:23:43,319 --> 00:23:45,210
JASON KU: This...

507
00:23:45,210 --> 00:23:46,680
this is a right rotation.

508
00:23:46,680 --> 00:23:48,960
This is a left rotation.

509
00:23:48,960 --> 00:23:50,860
Any more questions?

510
00:23:50,859 --> 00:23:51,359
Yes?

511
00:23:51,359 --> 00:23:54,775
AUDIENCE: [INAUDIBLE]

512
00:23:58,529 --> 00:24:00,509
JASON KU: As I
climb the tree,

513
00:24:00,509 --> 00:24:03,720
every node I might have to
fix with a rebalance,

514
00:24:03,720 --> 00:24:07,289
but that rebalance does
at most two rotations,

515
00:24:07,289 --> 00:24:11,069
and there are at most log
n ancestors that I have,

516
00:24:11,069 --> 00:24:16,349
because my tree was
balanced at height 2

517
00:24:16,349 --> 00:24:19,109
log n or something like that.

518
00:24:19,109 --> 00:24:21,809
This means that
at maximum I might

519
00:24:21,809 --> 00:24:26,309
have to do four log n rotations
because each of them can

520
00:24:26,309 --> 00:24:27,309
do two rotations.  Does

521
00:24:27,309 --> 00:24:28,230
this make sense?

522
00:24:28,230 --> 00:24:31,680
Now, in fact, you can prove
that in a deletion operation

523
00:24:31,680 --> 00:24:34,049
, it's possible that you'll have to
do a logarithmic number of

524
00:24:34,049 --> 00:24:35,430
these rotations up the tree.

525
00:24:35,430 --> 00:24:38,190
It was a bad case.  The

526
00:24:38,190 --> 00:24:40,980
original tree I gave you
is called a Fibonacci tree.

527
00:24:40,980 --> 00:24:45,089
This is a few... this is
the largest balanced tree in height that

528
00:24:45,089 --> 00:24:47,384
you can have on a
given number of nodes.

529
00:24:52,619 --> 00:24:55,439
Yes, the smallest number of nodes
for a given height.

530
00:24:55,440 --> 00:24:56,820
You can think about it anyway.

531
00:24:56,819 --> 00:24:59,529
And if you generalize this
to a large enough thing,

532
00:24:59,529 --> 00:25:01,470
then that thing
will need a logarithmic number of

533
00:25:01,470 --> 00:25:02,759
revolutions going up.

534
00:25:02,759 --> 00:25:05,069
Now, actually,
with the insertion

535
00:25:05,069 --> 00:25:09,269
you can actually prove-- you can
go through the case analysis.  The

536
00:25:09,269 --> 00:25:12,089
insert operation
always rebalances the tree

537
00:25:12,089 --> 00:25:15,667
after one rebalancing operation
, which

538
00:25:15,667 --> 00:25:16,834
may include two rotations.  Does

539
00:25:16,835 --> 00:25:19,350
this make sense?

540
00:25:19,349 --> 00:25:20,052
Yes?

541
00:25:20,053 --> 00:25:21,930
AUDIENCE: [INAUDIBLE]

542
00:25:27,279 --> 00:25:27,920
JASON KU: Yes.

543
00:25:27,920 --> 00:25:30,414
Right spin, this guy
becomes the right kid.

544
00:25:30,414 --> 00:25:31,039
AUDIENCE: Yes.

545
00:25:31,039 --> 00:25:33,549
So, you can't... are there
certain rotations that you

546
00:25:33,549 --> 00:25:36,730
can't do, depending on
whether you've had a child...

547
00:25:36,730 --> 00:25:37,390
JASON KU: Yes.

548
00:25:37,390 --> 00:25:43,070
If I didn't have a left subtree, I would
n't be able to make a

549
00:25:43,069 --> 00:25:44,679
right turn.

550
00:25:44,680 --> 00:25:47,340
Right rotation requires
me to have a left child.

551
00:25:47,339 --> 00:25:48,519
So if you do this –

552
00:25:48,519 --> 00:25:50,440
and you'll see,
our code actually

553
00:25:50,440 --> 00:25:52,420
checks to see if
you have a left child element.

554
00:25:57,500 --> 00:25:59,869
This is a statement
you can

555
00:25:59,869 --> 00:26:02,959
make before
doing one of these rotations.

556
00:26:02,960 --> 00:26:03,700
Something else?

557
00:26:03,700 --> 00:26:04,559
Yes?

558
00:26:04,559 --> 00:26:06,393
AUDIENCE: Just
repeating, so it

559
00:26:06,393 --> 00:26:09,096
might take no more than two turns to insert
[INAUDIBLE]??

560
00:26:09,096 --> 00:26:09,680
JASON KU: Mmm.  A

561
00:26:09,680 --> 00:26:11,680
constant number of
revolutions, and removal

562
00:26:11,680 --> 00:26:14,539
may take a logarithmic
number of revolutions.

563
00:26:14,539 --> 00:26:16,490
This is not what
you need to know.

564
00:26:16,490 --> 00:26:19,460
That's not what I'm trying
to prove to you here.

565
00:26:19,460 --> 00:26:21,650
Just something
interesting.

566
00:26:21,650 --> 00:26:26,390
There are
rebalancing schemes, like in CRS.

567
00:26:26,390 --> 00:26:31,310
They introduce red and black
wood to introduce balance.

568
00:26:31,309 --> 00:26:34,669
And these trees actually
have weaker connections –

569
00:26:34,670 --> 00:26:39,680
they are not as
balanced as an AVL tree.

570
00:26:39,680 --> 00:26:44,029
This allows for more than skew 2.

571
00:26:44,029 --> 00:26:46,399
And since this is
supposedly a weaker constraint,

572
00:26:46,400 --> 00:26:49,470
they get away with only doing a
constant number of rotations -

573
00:26:49,470 --> 00:26:54,559
they can afford it
before fixing the tree.

574
00:26:54,559 --> 00:26:56,149
But it's a little more complicated.

575
00:26:56,150 --> 00:26:57,680
AUDIENCE: [INAUDIBLE]

576
00:27:00,457 --> 00:27:01,290
JASON KU: Very good.

577
00:27:01,289 --> 00:27:01,789
good.  Do

578
00:27:01,789 --> 00:27:02,779
you have any questions about this?

579
00:27:06,089 --> 00:27:10,549
Okay, now this is more of a
mechanical question that you will

580
00:27:10,549 --> 00:27:11,750
get in your problem sets.

581
00:27:11,750 --> 00:27:15,950
And now we will move on to
theoretical questions in more detail.

582
00:27:15,950 --> 00:27:19,230
These will be
issues of reduction.

583
00:27:19,230 --> 00:27:19,730
good.

584
00:27:19,730 --> 00:27:25,250
This is the first problem, Fik Nouri.

585
00:27:25,250 --> 00:27:26,839
Is this... someone?

586
00:27:26,839 --> 00:27:27,649
Nick Fury, right?

587
00:27:27,650 --> 00:27:31,280
So, this is a reference to the Avengers.

588
00:27:31,279 --> 00:27:33,799
So basically what
happens in this case is

589
00:27:33,799 --> 00:27:38,210
he has a list of
superheroes, each of whom

590
00:27:38,210 --> 00:27:41,150
has their own opinion on whether
they should go to battle with Thanos.

591
00:27:43,819 --> 00:27:49,220
And their opinion can
be strongly positive

592
00:27:49,220 --> 00:27:50,730
or strongly negative.

593
00:27:50,730 --> 00:27:54,319
So what Fick
is trying to do is

594
00:27:54,319 --> 00:27:59,960
find among
his Avengers who are the Avengers with the

595
00:27:59,960 --> 00:28:04,819
most extreme views
so

596
00:28:04,819 --> 00:28:05,887
he can talk to them.

597
00:28:05,887 --> 00:28:07,429
He doesn't want
to talk to everyone.

598
00:28:07,430 --> 00:28:10,039
He wants to talk to a
logarithmic number of them.

599
00:28:10,039 --> 00:28:11,029
good.

600
00:28:11,029 --> 00:28:14,720
It's like-- whatever.

601
00:28:14,720 --> 00:28:18,799
Essentially, we have a
secret situation

602
00:28:18,799 --> 00:28:22,759
where you are given as a
read-only input storage

603
00:28:22,759 --> 00:28:23,980
these things in an array.

604
00:28:26,900 --> 00:28:31,975
And I want to find
magazines with the strongest

605
00:28:31,974 --> 00:28:32,474
opinions.  Does

606
00:28:32,474 --> 00:28:34,137
this make sense?

607
00:28:34,137 --> 00:28:35,929
And I want to do that,
and the first problem

608
00:28:35,930 --> 00:28:39,440
is linear time.

609
00:28:39,440 --> 00:28:42,769
You don't really know
how to do it yet.

610
00:28:42,769 --> 00:28:47,809
You'll know how to do it with the
material you cover in--

611
00:28:47,809 --> 00:28:50,419
well, they'll teach you how
to do it one way in 046,

612
00:28:50,420 --> 00:28:53,690
but we're not going to
do it to you right now.   On Tuesday,

613
00:28:53,690 --> 00:28:59,400
we'll teach you another
way to do this

614
00:28:59,400 --> 00:29:01,370
using binary heaps.

615
00:29:01,369 --> 00:29:03,979
Binary heaps are an
interesting thing.

616
00:29:03,980 --> 00:29:14,390
It implements a subset of the
established interface.

617
00:29:14,390 --> 00:29:23,150
Really, it's simple-- you can
build on some iterated x.

618
00:29:23,150 --> 00:29:25,269
I'm collecting a bunch of things.

619
00:29:25,269 --> 00:29:26,779
These items have keys.   In the same way,

620
00:29:26,779 --> 00:29:29,089
it is a key data structure
.

621
00:29:29,089 --> 00:29:32,099
It implements what we call a
priority queue interface.

622
00:29:32,099 --> 00:29:33,859
I can build these things.

623
00:29:33,859 --> 00:29:39,379
I can insert things, but I'm
not going to do that here.

624
00:29:39,380 --> 00:29:43,490
All I really need
for this situation

625
00:29:43,490 --> 00:29:47,150
is the delete_superlative operation--

626
00:29:47,150 --> 00:29:50,870
in this case, probably max.

627
00:29:50,869 --> 00:29:52,114
Delete_max.

628
00:29:57,559 --> 00:29:58,399
So it's like--

629
00:29:58,400 --> 00:30:01,713
I have a data structure,
I call these things.  Does

630
00:30:01,712 --> 00:30:02,629
this make sense?

631
00:30:02,630 --> 00:30:02,890
Yes?

632
00:30:02,890 --> 00:30:04,190
AUDIENCE: What is
priority queue?

633
00:30:04,190 --> 00:30:04,519
JASON KU: Yes.

634
00:30:04,519 --> 00:30:06,559
Priority queue is
essentially what

635
00:30:06,559 --> 00:30:08,450
implements these two things.

636
00:30:08,450 --> 00:30:11,569
Actually, there's a third one
where I can put something new,

637
00:30:11,569 --> 00:30:13,279
but I wo
n't need it right now.

638
00:30:13,279 --> 00:30:14,738
That's what
priority queue is.

639
00:30:14,738 --> 00:30:15,890
And in fact, a set

640
00:30:15,890 --> 00:30:19,180
is a subset of the
set interface.

641
00:30:19,180 --> 00:30:20,299
right?  The

642
00:30:20,299 --> 00:30:22,250
nice thing about a

643
00:30:22,250 --> 00:30:25,160
heap-- I won't show
you how to do it,

644
00:30:25,160 --> 00:30:27,380
but what a heap can do--

645
00:30:27,380 --> 00:30:29,870
if I were to implement both of these
operations

646
00:30:29,869 --> 00:30:34,519
using a fixed AVL tree, how long would it
take me to do these things?

647
00:30:41,430 --> 00:30:43,566
How long does it take
to build a set of AVL trees?

648
00:30:46,970 --> 00:30:48,620
n log n, right?

649
00:30:48,619 --> 00:30:50,959
Because essentially I
get sorted order

650
00:30:50,960 --> 00:30:53,299
if I
insert these things one at a time

651
00:30:53,299 --> 00:30:55,220
,

652
00:30:55,220 --> 00:30:57,319
or I can sort them
and then put them

653
00:30:57,319 --> 00:31:00,500
into a tree in linear time,
like you saw a couple of days

654
00:31:00,500 --> 00:31:03,779
ago in the recitation.

655
00:31:03,779 --> 00:31:05,839
But I'll have to sort them out someday
, right?

656
00:31:07,339 --> 00:31:10,169
I need to take
at least n log n time,

657
00:31:10,170 --> 00:31:14,120
because if I want to get
their traversal order back

658
00:31:14,119 --> 00:31:18,109
in linear time, and I have a
lower bound of n log

659
00:31:18,109 --> 00:31:21,799
n for sorting, I needed to
spend n log n time here,

660
00:31:21,799 --> 00:31:23,029
right?

661
00:31:23,029 --> 00:31:26,523
And how long
will this delete_max take?

662
00:31:26,523 --> 00:31:28,631
AUDIENCE: This is sorted, so enter n.

663
00:31:28,632 --> 00:31:29,590
JASON KU: Log n, right?

664
00:31:29,589 --> 00:31:31,019
So this is a set of AVL trees.

665
00:31:31,019 --> 00:31:31,950
Where is my maximum?

666
00:31:31,950 --> 00:31:33,180
This is the most correct.

667
00:31:33,180 --> 00:31:35,519
I can just walk over this
thing, take it off.

668
00:31:35,519 --> 00:31:37,049
Maybe I need to rebalance.

669
00:31:37,049 --> 00:31:39,419
But this is a log n operation.

670
00:31:39,420 --> 00:31:44,400
This is the same as
inserting the last one in my subtree.

671
00:31:44,400 --> 00:31:46,860
For a fixed AVL tree,
this is n log n.

672
00:31:46,859 --> 00:31:47,669
This is magazine n.

673
00:31:50,609 --> 00:31:53,969
Now there is another
data structure that performs

674
00:31:53,970 --> 00:31:55,559
one of these operations better.

675
00:31:55,559 --> 00:32:01,019
And the same for the other one
we learned about earlier.  Does

676
00:32:01,019 --> 00:32:03,599
anyone remember?

677
00:32:03,599 --> 00:32:05,429
Fitting an AVL tree
didn't really give us

678
00:32:05,430 --> 00:32:11,910
anything over a sorted
array in a dynamic array.

679
00:32:11,910 --> 00:32:14,805
What this gave us was...

680
00:32:14,805 --> 00:32:17,730
we could sort this in n log n time
using merge sort or something

681
00:32:17,730 --> 00:32:18,789
like that.

682
00:32:18,789 --> 00:32:22,500
And then we could just
pull out the last n times.

683
00:32:22,500 --> 00:32:23,789
It would be amortized...

684
00:32:23,789 --> 00:32:26,837
I mean, if I didn't
care about taking

685
00:32:26,837 --> 00:32:29,129
that size, I could do it, at
worst, constant time.

686
00:32:29,130 --> 00:32:31,380
I just read
the first-- the last one.

687
00:32:31,380 --> 00:32:33,750
I never need to resize the
array.

688
00:32:33,750 --> 00:32:35,940
I can just ignore it.  Does

689
00:32:35,940 --> 00:32:37,150
this make sense?

690
00:32:37,150 --> 00:32:37,650
good.

691
00:32:37,650 --> 00:32:39,130
But that's... okay.

692
00:32:39,130 --> 00:32:43,230
If I had a data structure
that implemented these two

693
00:32:43,230 --> 00:32:49,769
operations, could someone
tell me an algorithm

694
00:32:49,769 --> 00:32:52,025
for creating fixed lists--

695
00:32:52,025 --> 00:32:54,150
don't worry about the
running time right now-- but that

696
00:32:54,150 --> 00:32:55,800
only uses these two operations?

697
00:32:59,269 --> 00:33:00,349
Yes?

698
00:33:00,349 --> 00:33:03,529
AUDIENCE: So we create
this data structure.

699
00:33:03,529 --> 00:33:05,134
It is ordered from
smallest to largest

700
00:33:05,134 --> 00:33:07,829
in the direction of the absolute value of x.

701
00:33:07,829 --> 00:33:11,879
JASON KU: Don't worry
about where they

702
00:33:11,880 --> 00:33:13,130
order things or anything like that.

703
00:33:13,130 --> 00:33:16,310
I'm not telling you how these
things are implemented, am I?

704
00:33:16,309 --> 00:33:20,329
I'm just saying that I can
take a bunch of this stuff,

705
00:33:20,329 --> 00:33:24,500
and I can remove the
maximum and bring it back.

706
00:33:24,500 --> 00:33:25,329
good?

707
00:33:25,329 --> 00:33:26,829
AUDIENCE: I think
we just create this--

708
00:33:26,829 --> 00:33:29,711
make sure you create this
so that the thought levels are the

709
00:33:29,711 --> 00:33:31,670
absolute value of the
thought levels, not--

710
00:33:31,670 --> 00:33:32,060
JASON KU: Sure.

711
00:33:32,059 --> 00:33:32,559
good.

712
00:33:32,559 --> 00:33:33,720
So that's a good thing.

713
00:33:33,720 --> 00:33:36,410
What I'm going to do, as
your colleague said,

714
00:33:36,410 --> 00:33:39,830
is I'm going to look at
all the things in my contribution.

715
00:33:39,829 --> 00:33:44,509
I'm going to copy it to
some memory storage for recording.

716
00:33:44,509 --> 00:33:47,150
This read-only thing is
irrelevant to this part of the

717
00:33:47,150 --> 00:33:48,807
problem.  What

718
00:33:48,807 --> 00:33:49,849
I'm going to do is...

719
00:33:56,950 --> 00:33:57,549
right.

720
00:33:57,549 --> 00:33:58,049
sorry

721
00:33:58,049 --> 00:34:00,789
I'm thinking about your
problem set that we're writing.

722
00:34:00,789 --> 00:34:01,750
I'm mixing it up.

723
00:34:01,750 --> 00:34:09,789
Okay, we'll copy it into
our new linear-sized array.

724
00:34:09,789 --> 00:34:11,679
But instead of putting
their values ​​there,

725
00:34:11,679 --> 00:34:13,422
I'm going to put the absolute
values ​​of their values.  Does

726
00:34:13,422 --> 00:34:14,170
this make sense?

727
00:34:14,170 --> 00:34:15,420
I'm just checking to see if it's negative.

728
00:34:15,420 --> 00:34:17,949
If so, I put
positivity there.

729
00:34:17,949 --> 00:34:19,300
good?

730
00:34:19,300 --> 00:34:23,440
Then I insert this
array into this assembly.

731
00:34:23,440 --> 00:34:26,619
I put it there.

732
00:34:26,619 --> 00:34:29,199
This will take some time,
regardless of the creation time.

733
00:34:29,199 --> 00:34:33,489
And then I can
delete at most k times.

734
00:34:33,489 --> 00:34:38,170
Or I can delete the maximum number of
times, however many things

735
00:34:38,170 --> 00:34:38,739
I need.

736
00:34:38,739 --> 00:34:39,760
right?

737
00:34:39,760 --> 00:34:44,050
If I want to register the top n things,
I can just register it n times,

738
00:34:44,050 --> 00:34:44,860
right?

739
00:34:44,860 --> 00:34:48,219
So, if I had a
data structure like this,

740
00:34:48,219 --> 00:34:51,579
I could do it in one
run of this operation

741
00:34:51,579 --> 00:34:55,174
and log n runs of
this operation.  Does

742
00:34:55,175 --> 00:34:56,050
this make sense?

743
00:34:56,050 --> 00:34:57,610
I could solve this
problem by reducing

744
00:34:57,610 --> 00:34:59,289
this data structure.

745
00:34:59,289 --> 00:35:05,980
Now, for a sorted array
or a fitted AVL tree,

746
00:35:05,980 --> 00:35:08,155
this operation is
already killing me.

747
00:35:08,155 --> 00:35:10,420
This takes n log n time.

748
00:35:10,420 --> 00:35:13,360
The nice thing
about the binary heap

749
00:35:13,360 --> 00:35:17,099
is that it performs this
operation in linear time.

750
00:35:20,059 --> 00:35:21,849
You'll see it on Tuesday.

751
00:35:21,849 --> 00:35:26,289
And it performs this
operation in log n time.

752
00:35:30,650 --> 00:35:34,220
What is the running time
if I use a binary heap

753
00:35:34,219 --> 00:35:37,519
to implement this
data structure?

754
00:35:37,519 --> 00:35:42,019
Order n times order
log n times log n.

755
00:35:42,019 --> 00:35:44,989
How big is log n squared--

756
00:35:44,989 --> 00:35:48,550
log n squared-- compared to n?

757
00:35:48,550 --> 00:35:49,835
It's smaller, right?

758
00:35:49,835 --> 00:35:51,710
So if I add these two
running times together,

759
00:35:51,710 --> 00:35:54,260
it will still be linear.

760
00:35:54,260 --> 00:35:57,020
This is how you solve the
first problem.

761
00:35:57,019 --> 00:35:59,750
I didn't need to tell you
what a binary heap is

762
00:35:59,750 --> 00:36:00,842
or how it does what it does.

763
00:36:00,842 --> 00:36:02,300
All I needed to
tell you was that

764
00:36:02,300 --> 00:36:04,220
this operation was performed
in linear time

765
00:36:04,219 --> 00:36:05,989
and this
operation was performed in log time n.

766
00:36:10,550 --> 00:36:11,720
Okay,

767
00:36:11,719 --> 00:36:14,779
the magic will be shown to
you on Tuesday.

768
00:36:14,780 --> 00:36:19,730
Part B says: now suppose that
Fick's computer

769
00:36:19,730 --> 00:36:22,550
is only allowed to write into
log n space.

770
00:36:22,550 --> 00:36:23,210
Well, okay.

771
00:36:23,210 --> 00:36:24,260
Here is the problem.

772
00:36:24,260 --> 00:36:29,570
Because before we copied the
entire array,

773
00:36:29,570 --> 00:36:34,137
filtered it, and
then performed some operations.

774
00:36:34,137 --> 00:36:35,720
But we couldn't even afford to do
that if we

775
00:36:35,719 --> 00:36:40,559
couldn't store it all
externally in writable memory.

776
00:36:40,559 --> 00:36:42,090
Therefore, we cannot do this.

777
00:36:42,090 --> 00:36:46,820
So in a way it's a
more restrictive environment.

778
00:36:46,820 --> 00:36:49,590
I can do fewer things.

779
00:36:49,590 --> 00:36:53,539
It is less powerful than my
previous situation where

780
00:36:53,539 --> 00:36:57,500
I had as much space
as I wanted to use.

781
00:36:57,500 --> 00:37:02,000
So it makes some
sense that I may

782
00:37:02,000 --> 00:37:07,489
not have been able to limit the working hours
that we had before.

783
00:37:07,489 --> 00:37:10,039
I may have to
sacrifice something

784
00:37:10,039 --> 00:37:13,059
because I am in more limited
computing conditions.

785
00:37:17,119 --> 00:37:19,563
Now this is something you
can solve with binary heaps,

786
00:37:19,563 --> 00:37:20,480
but it's not necessary.

787
00:37:20,480 --> 00:37:27,860
You can solve this
using a set of AVL trees.  Does

788
00:37:27,860 --> 00:37:29,960
anyone have any ideas
on how this can be solved

789
00:37:29,960 --> 00:37:32,750
using a fixed AVL tree?

790
00:37:32,750 --> 00:37:37,429
I'm limited by my number--
my space is at most log n.

791
00:37:40,710 --> 00:37:43,472
AUDIENCE: So how much space
does a set of AVL trees take up?

792
00:37:43,472 --> 00:37:44,139
JASON KU: That's right.

793
00:37:44,139 --> 00:37:47,079
Space - there is a constant
number of pointers

794
00:37:47,079 --> 00:37:49,029
to each of these nodes.

795
00:37:49,030 --> 00:37:52,510
And I keep it in
notes and space.

796
00:37:52,510 --> 00:37:57,520
Essentially, every data structure
we've shown you takes up space -

797
00:37:57,519 --> 00:38:00,130
the order of things
we store.

798
00:38:00,130 --> 00:38:02,269
This does not use any additional space.

799
00:38:02,269 --> 00:38:05,500
It may take longer
to do certain things,

800
00:38:05,500 --> 00:38:09,456
but the space is taken up by
the number of items

801
00:38:09,456 --> 00:38:11,539
we store plus
perhaps a constant factor.

802
00:38:14,260 --> 00:38:18,430
So I'm going to draw my contribution here
, which I can only read, but I

803
00:38:18,429 --> 00:38:20,072
can't write.

804
00:38:20,072 --> 00:38:20,739
Do I give it to you...

805
00:38:20,739 --> 00:38:26,169
I'll just call
it A. So that's my list of

806
00:38:26,170 --> 00:38:29,019
all the Revenger thoughts.

807
00:38:29,019 --> 00:38:31,659
I can only read.

808
00:38:31,659 --> 00:38:36,139
But my computer can only write
to this logarithmic amount of

809
00:38:36,139 --> 00:38:36,639
space.

810
00:38:42,659 --> 00:38:46,279
What can I put in this space?

811
00:38:46,280 --> 00:38:49,500
AUDIENCE: Magazine [INAUDIBLE]?

812
00:38:49,500 --> 00:38:53,250
JASON KU: Well, I can definitely
put log n things in there.

813
00:38:53,250 --> 00:38:55,090
So, if I'm given
this constraint,

814
00:38:55,090 --> 00:38:58,985
I'll probably want to create a
data structure of that size,

815
00:38:58,985 --> 00:39:00,360
holding that
many things.  Does

816
00:39:00,360 --> 00:39:02,797
this make sense?

817
00:39:02,797 --> 00:39:04,380
Because what
else are you going to do?

818
00:39:08,000 --> 00:39:10,380
So I gave you an idea.

819
00:39:10,380 --> 00:39:12,800
Maybe we could use an
AVL set here.

820
00:39:12,800 --> 00:39:16,460
I see the logarithm in my answer.

821
00:39:16,460 --> 00:39:21,170
It's possible that we
sorted arrays

822
00:39:21,170 --> 00:39:23,300
or set AVL things.

823
00:39:23,300 --> 00:39:26,360
These things give me a journal
somewhere in my work time,

824
00:39:26,360 --> 00:39:27,440
right?

825
00:39:27,440 --> 00:39:30,929
How logical
that I could

826
00:39:30,929 --> 00:39:32,599
have a set of AVL trees here.

827
00:39:32,599 --> 00:39:37,809
Why might a fitted AVL tree
be useful to me?

828
00:39:37,809 --> 00:39:38,309
Yes?

829
00:39:38,309 --> 00:39:39,750
AUDIENCE: Since
it's sorted and you

830
00:39:39,750 --> 00:39:41,284
don't have a
passing order,

831
00:39:41,284 --> 00:39:45,304
can you calculate the passing order
and insert [INAUDIBLE]??

832
00:39:45,304 --> 00:39:45,929
JASON KU: Of course.

833
00:39:45,929 --> 00:39:47,409
I can do all of this.

834
00:39:47,409 --> 00:39:49,319
But, specifically,
this will help

835
00:39:49,320 --> 00:39:54,860
me
find a big one quickly, right?

836
00:39:54,860 --> 00:40:00,340
If I have a set of
things, it's going to be...

837
00:40:00,340 --> 00:40:02,150
and I store
this data structure,

838
00:40:02,150 --> 00:40:05,960
by adding
elements to it,

839
00:40:05,960 --> 00:40:08,780
I can find out which one is the
largest--

840
00:40:08,780 --> 00:40:12,710
or the smallest--
pretty quickly in log n time.

841
00:40:12,710 --> 00:40:17,780
So if I have
n things in this tree here,

842
00:40:17,780 --> 00:40:19,242
what is the height of this thing?

843
00:40:19,242 --> 00:40:20,186
AUDIENCE: [INAUDIBLE]

844
00:40:20,186 --> 00:40:21,470
JASON KU: Journal of the magazine n.

845
00:40:21,469 --> 00:40:23,324
This looks familiar.

846
00:40:23,324 --> 00:40:24,199
So what can I afford?

847
00:40:24,199 --> 00:40:31,759
I can afford a linear number of
AVL tree option operations

848
00:40:31,760 --> 00:40:34,231
over this data structure.

849
00:40:34,231 --> 00:40:35,455
Okay, did you have a question?

850
00:40:35,454 --> 00:40:36,329
AUDIENCE: [INAUDIBLE]

851
00:40:36,329 --> 00:40:37,329
JASON KU: Okay, sorry.

852
00:40:37,329 --> 00:40:38,007
Yes?

853
00:40:38,007 --> 00:40:39,549
AUDIENCE: For this to
be an AVL tree,

854
00:40:39,550 --> 00:40:42,680
does it have to be a BTS tree?

855
00:40:42,679 --> 00:40:43,960
JASON KU: Uh, BTS...

856
00:40:43,960 --> 00:40:45,809
BST.

857
00:40:45,809 --> 00:40:48,110
So when I talk about...

858
00:40:48,110 --> 00:40:49,760
someone likes Korean K-Pop.

859
00:40:49,760 --> 00:40:50,610
good.

860
00:40:50,610 --> 00:40:55,820
So, BST-- but naturally-- in the

861
00:40:55,820 --> 00:40:58,610
jargon
that you're probably

862
00:40:58,610 --> 00:41:00,860
used to hearing
in other contexts,

863
00:41:00,860 --> 00:41:04,309
what we mean in this
class is an AVL tree.

864
00:41:04,309 --> 00:41:08,239
Sometimes what
people call a

865
00:41:08,239 --> 00:41:12,500
binary search tree doesn't
have balance semantics,

866
00:41:12,500 --> 00:41:16,190
so what we can call in
this class is a binary set tree.

867
00:41:16,190 --> 00:41:20,150
But they are actually beneficial
because they are balanced.

868
00:41:20,150 --> 00:41:22,309
So we will
usually just assume

869
00:41:22,309 --> 00:41:24,449
that we are talking about
balanced things here.

870
00:41:24,449 --> 00:41:28,730
Now the AVL tree set has this
semantics of a binary search tree

871
00:41:28,730 --> 00:41:30,789
where the keys are ordered.

872
00:41:30,789 --> 00:41:32,539
These items have keys
and they are ordered.

873
00:41:32,539 --> 00:41:34,369
This is the installed interface.

874
00:41:34,369 --> 00:41:36,980
Whereas we also introduced
you to the serial

875
00:41:36,980 --> 00:41:41,900
interface, for which these
things don't even have keys.

876
00:41:41,900 --> 00:41:45,440
How can I store the set semantics
there?

877
00:41:45,440 --> 00:41:47,059
So that's the
distinction we

878
00:41:47,059 --> 00:41:53,360
mean when we talk about a binary
search tree versus, actually, a set of

879
00:41:53,360 --> 00:41:54,660
AVL trees versus [INAUDIBLE].

880
00:41:54,659 --> 00:41:55,159
Yes?

881
00:41:55,159 --> 00:41:57,742
AUDIENCE: So if we look at this
to create an AVL tree from this, would that

882
00:41:57,742 --> 00:42:00,650
mean that when
we create a node, we're telling it that

883
00:42:00,650 --> 00:42:03,829
we're putting in an absolute
value of [INAUDIBLE]??

884
00:42:03,829 --> 00:42:09,349
JASON KU: Okay, when you
create a set of AVL trees,

885
00:42:09,349 --> 00:42:11,942
you have to tell us what--
if you're storing objects,

886
00:42:11,943 --> 00:42:13,610
you have to tell
me what their key is.

887
00:42:13,610 --> 00:42:15,170
You just keep
some numbers

888
00:42:15,170 --> 00:42:18,110
like I'm doing here.

889
00:42:18,110 --> 00:42:19,970
Now this is not an installed AVL tree.

890
00:42:19,969 --> 00:42:21,559
But if I'm just
storing numbers, I

891
00:42:21,559 --> 00:42:25,400
have to tell you that the elements
I'm storing are keys.

892
00:42:25,400 --> 00:42:26,684
And then everything follows.

893
00:42:26,684 --> 00:42:28,309
But if you have an
object that you're

894
00:42:28,309 --> 00:42:30,750
trying to sort, like the
students in this room,

895
00:42:30,750 --> 00:42:33,130
you have a lot of properties.

896
00:42:33,130 --> 00:42:38,599
I want all people to
have a phone number--

897
00:42:38,599 --> 00:42:41,299
maybe I want to
include your phone number for some reason.  Will

898
00:42:41,300 --> 00:42:44,150
this help me
find out where you live?

899
00:42:44,150 --> 00:42:45,680
I don't... it's
getting a little...

900
00:42:45,679 --> 00:42:47,269
I don't want to go there.

901
00:42:47,269 --> 00:42:50,282
But if I give you a
set of AVL trees,

902
00:42:50,282 --> 00:42:51,949
I have to tell you
what it is tuned to.

903
00:42:51,949 --> 00:42:55,789
If I give you a
sequential AVL tree, it

904
00:42:55,789 --> 00:42:57,920
will be obvious what
my traversal order will be,

905
00:42:57,920 --> 00:43:00,320
since
I am giving you the sequence.

906
00:43:00,320 --> 00:43:03,740
This is what the entrance was like.  Does

907
00:43:03,739 --> 00:43:05,149
this make sense?

908
00:43:05,150 --> 00:43:10,250
Okay, I have a
set of AVL trees of size log n.

909
00:43:10,250 --> 00:43:12,677
What should be the key to it?

910
00:43:12,677 --> 00:43:13,719
AUDIENCE: Absolute value.

911
00:43:13,719 --> 00:43:15,919
JASON KU: The absolute
value of their preferences--

912
00:43:15,920 --> 00:43:18,099
or their opinion.

913
00:43:18,099 --> 00:43:20,769
I don't remember what
it's called.

914
00:43:20,769 --> 00:43:23,489
But what kind of magazine items
can I put here?  I don't

915
00:43:28,239 --> 00:43:30,549
know.

916
00:43:30,550 --> 00:43:32,260
I don't know anything
about these things.

917
00:43:32,260 --> 00:43:35,270
What makes one
better than the other?

918
00:43:35,269 --> 00:43:37,900
Let's just put the
first log of n things.  Does

919
00:43:37,900 --> 00:43:39,680
this make sense?

920
00:43:39,679 --> 00:43:40,179
Okay,

921
00:43:40,179 --> 00:43:43,899
what can this tell me?

922
00:43:43,900 --> 00:43:45,490
Now I put this thing there.

923
00:43:45,489 --> 00:43:47,810
How long did it last?

924
00:43:47,811 --> 00:43:49,640
AUDIENCE: [INAUDIBLE]

925
00:43:49,639 --> 00:43:55,759
JASON KU: Register n times,
register, register n times, right?

926
00:43:55,760 --> 00:43:58,520
But it's much less
than our long-term time

927
00:43:58,519 --> 00:44:01,800
that we're looking for,
so I'm not concerned.

928
00:44:01,800 --> 00:44:04,760
I mean, I want you to
say how long it took,

929
00:44:04,760 --> 00:44:06,527
but for my purposes
I know it's

930
00:44:06,527 --> 00:44:08,360
less than the amount of time
I'm looking for.

931
00:44:08,360 --> 00:44:10,160
And I did such an operation once.

932
00:44:10,159 --> 00:44:12,139
I do
n't care about that anymore.

933
00:44:12,139 --> 00:44:12,859
Yes?

934
00:44:12,860 --> 00:44:14,720
AUDIENCE: How did you get
log n by multiplying log log n?

935
00:44:14,719 --> 00:44:16,302
JASON KU: Because
the number of things

936
00:44:16,302 --> 00:44:19,109
I store in this
thing is log n.

937
00:44:19,110 --> 00:44:24,050
So if I match the pattern to the
AVL tree creation time

938
00:44:24,050 --> 00:44:29,870
and put log n in there,
then it's going to be log n times log n.

939
00:44:29,869 --> 00:44:31,219
good.

940
00:44:31,219 --> 00:44:33,439
AUDIENCE: So this is
just one iteration?

941
00:44:33,440 --> 00:44:36,920
JASON KU: Well, right now,
I just created this thing.

942
00:44:36,920 --> 00:44:40,460
Maybe... I just built it once.

943
00:44:40,460 --> 00:44:44,630
I also argue that maybe
I don't need to build it again.

944
00:44:44,630 --> 00:44:47,660
What could I...
as far as I know...

945
00:44:47,659 --> 00:44:51,289
I didn't filter
my data at all.

946
00:44:51,289 --> 00:44:55,659
I just keep these things
in a certain order.

947
00:44:55,659 --> 00:44:59,779
What can I do to
maybe start processing

948
00:44:59,780 --> 00:45:01,670
the rest of the data?

949
00:45:01,670 --> 00:45:02,360
Yes?

950
00:45:02,360 --> 00:45:06,490
AUDIENCE: [INAUDIBLE] try to
scroll through the A list

951
00:45:06,489 --> 00:45:09,829
and try to find someone who is
bigger than...

952
00:45:09,829 --> 00:45:13,429
try to keep
the maximum [INAUDIBLE].

953
00:45:13,429 --> 00:45:16,099
JASON KU: Take this guy
through putting things in,

954
00:45:16,099 --> 00:45:18,980
and always supporting...

955
00:45:18,980 --> 00:45:20,990
if I do this, and I
keep sticking things in,

956
00:45:20,989 --> 00:45:23,489
I'll get this at the
end.

957
00:45:23,489 --> 00:45:28,909
And now I can just read the
largest k things.

958
00:45:28,909 --> 00:45:33,289
However, when I insert
things here,

959
00:45:33,289 --> 00:45:34,610
my thing grows.

960
00:45:34,610 --> 00:45:35,809
AUDIENCE: Okay, just
delete the smallest one.

961
00:45:35,809 --> 00:45:37,184
JASON KU: Oh,
remove the small stuff.

962
00:45:37,184 --> 00:45:38,293
I like this idea.

963
00:45:38,293 --> 00:45:39,710
AUDIENCE: So
replace it.

964
00:45:39,710 --> 00:45:40,940
JASON KU: Yeah,
basically replace it.

965
00:45:40,940 --> 00:45:41,630
right.

966
00:45:41,630 --> 00:45:43,010
What I'm going to do--

967
00:45:43,010 --> 00:45:44,810
here's a suggestion.

968
00:45:44,809 --> 00:45:49,070
We're going to take the
next guy, put him in.

969
00:45:49,070 --> 00:45:51,519
Perfectly.

970
00:45:51,519 --> 00:45:54,009
Which one do
I care about right now?

971
00:45:54,010 --> 00:45:55,600
The smallest one there.

972
00:45:55,599 --> 00:45:57,849
So drive out the smallest.

973
00:45:57,849 --> 00:46:00,099
Now this one
I got stuck in May.

974
00:46:00,099 --> 00:46:01,549
Be the smallest.

975
00:46:01,550 --> 00:46:03,580
So I just went
through it,

976
00:46:03,579 --> 00:46:05,299
but how long did it take me?

977
00:46:10,032 --> 00:46:11,490
This took me by
the height of this tree.

978
00:46:11,489 --> 00:46:12,194
What is the height of this tree?

979
00:46:12,195 --> 00:46:13,070
AUDIENCE: [INAUDIBLE]

980
00:46:13,070 --> 00:46:15,300
JASON KU: Journal of the magazine n.

981
00:46:15,300 --> 00:46:18,570
So I put one down and took the
other out.

982
00:46:18,570 --> 00:46:20,638
This is the smallest, right?

983
00:46:20,637 --> 00:46:22,679
And I will continue to do so
until the end.

984
00:46:22,679 --> 00:46:23,762
How long did it take me?

985
00:46:23,762 --> 00:46:25,069
JASON KU: [INAUDIBLE]

986
00:46:28,414 --> 00:46:29,039
JASON KU: Yes.

987
00:46:29,039 --> 00:46:34,889
Processing n minus log n
elements, which is basically equal to n.

988
00:46:34,889 --> 00:46:37,230
And each of these
operations took me as much

989
00:46:37,230 --> 00:46:39,119
time as a tree.

990
00:46:39,119 --> 00:46:40,920
This gives me the
running time we're

991
00:46:40,920 --> 00:46:45,960
looking for, n log log n.

992
00:46:45,960 --> 00:46:46,500
sense?

993
00:46:46,500 --> 00:46:48,840
AUDIENCE: Does this resemble the
sliding window technique?

994
00:46:48,840 --> 00:46:48,960
JASON KU: Yes.

995
00:46:48,960 --> 00:46:50,760
This is a kind of
sliding window technique.

996
00:46:50,760 --> 00:46:53,100
Maybe you've
used it recently.

997
00:46:56,469 --> 00:46:56,969
good.  Does

998
00:46:56,969 --> 00:46:58,321
everyone agree with this?

999
00:46:58,322 --> 00:46:58,858
Yes?

1000
00:46:58,858 --> 00:47:00,900
AUDIENCE: Could you just
remind me of the context

1001
00:47:00,900 --> 00:47:05,170
we're talking about, which is log
log n, like a tree and where...

1002
00:47:05,170 --> 00:47:07,170
JASON KU: So this thing...
the size of this thing is

1003
00:47:07,170 --> 00:47:08,494
log log n?

1004
00:47:08,494 --> 00:47:09,119
AUDIENCE: Yes.

1005
00:47:09,119 --> 00:47:10,452
JASON KU: I mean... sorry, magazine n.

1006
00:47:10,452 --> 00:47:15,438
And the height of this
thing is the size of a log.

1007
00:47:15,438 --> 00:47:19,065
AUDIENCE: I'm sorry, as far as
our small logs of size n

1008
00:47:19,065 --> 00:47:25,269
[INAUDIBLE] small
logs of logs of n trees, or...

1009
00:47:25,269 --> 00:47:27,150
JASON KU: No, yeah... sorry.

1010
00:47:27,150 --> 00:47:29,789
I'm taking this stuff-- there's

1011
00:47:29,789 --> 00:47:32,039
no intermediate
data structure here--

1012
00:47:32,039 --> 00:47:37,105
I'm just putting all
this stuff into an AVL set.

1013
00:47:37,105 --> 00:47:37,605
Yes?

1014
00:47:37,605 --> 00:47:39,030
AUDIENCE: [INAUDIBLE]

1015
00:47:39,030 --> 00:47:43,200
JASON KU: Into one
AVL set of size log n.

1016
00:47:43,199 --> 00:47:48,496
I put in a guy, I
put forward the worst guy.

1017
00:47:48,496 --> 00:47:49,829
Looking through all the things.

1018
00:47:49,829 --> 00:47:52,409
I need to make sure that
when I insert it,

1019
00:47:52,409 --> 00:47:55,739
I keep track of
which Revenger it is,

1020
00:47:55,739 --> 00:47:57,719
and that I take the
absolute value,

1021
00:47:57,719 --> 00:48:00,449
and all those
little things.

1022
00:48:00,449 --> 00:48:02,250
But that's the basic idea.

1023
00:48:02,250 --> 00:48:05,730
I just take it, I
close the window, I

1024
00:48:05,730 --> 00:48:07,829
put something in, I
take something out,

1025
00:48:07,829 --> 00:48:11,460
which may or may
not be the same.

1026
00:48:11,460 --> 00:48:14,490
And at the end of
this procedure, the

1027
00:48:14,489 --> 00:48:17,069
invariant that I
keep here is that

1028
00:48:17,070 --> 00:48:23,730
my thing always has the
k largest thoughts of the ones

1029
00:48:23,730 --> 00:48:24,925
I've processed so far.

1030
00:48:24,925 --> 00:48:26,550
This is obviously true
in the beginning

1031
00:48:26,550 --> 00:48:27,930
when I'm building this thing.

1032
00:48:27,929 --> 00:48:31,319
And when I get to the end, I've
processed all the stuff,

1033
00:48:31,320 --> 00:48:38,309
and it has a log of size n,
so I have a log of the biggest-- the

1034
00:48:38,309 --> 00:48:41,730
highest-- extremist thoughts.

1035
00:48:41,730 --> 00:48:43,990
And then I can just do a
detour of

1036
00:48:43,989 --> 00:48:46,139
this thing in order and come back.  Does

1037
00:48:46,139 --> 00:48:47,289
this make sense?

1038
00:48:47,289 --> 00:48:50,130
And I only used
logarithmic space.

1039
00:48:53,210 --> 00:48:53,710
Yes?

1040
00:48:53,710 --> 00:48:55,001
AUDIENCE: Wait, I don't understand.

1041
00:48:55,001 --> 00:49:00,090
Are all the thoughts
in this AVL tree?

1042
00:49:00,090 --> 00:49:02,340
JASON KU: Are all
the thoughts in this AVL tree?

1043
00:49:02,340 --> 00:49:05,519
All these thoughts
are in the AVL tree.

1044
00:49:05,519 --> 00:49:12,179
And at some point I
will insert each thought

1045
00:49:12,179 --> 00:49:14,039
into this AVL tree.

1046
00:49:14,039 --> 00:49:17,639
But I will delete
the ones I don't care about as I go along

1047
00:49:17,639 --> 00:49:18,222
.  Does

1048
00:49:18,222 --> 00:49:19,139
this make sense?

1049
00:49:19,139 --> 00:49:22,859
I always maintain the
invariants

1050
00:49:22,860 --> 00:49:26,010
that this thing, before
inserting anything,

1051
00:49:26,010 --> 00:49:29,100
contains exactly log n elements
, and then I

1052
00:49:29,099 --> 00:49:31,889
maintain this invariant
by inserting one, removing one

1053
00:49:31,889 --> 00:49:32,529
.

1054
00:49:32,530 --> 00:49:35,178
AUDIENCE: Oh, okay,
which one do you delete?

1055
00:49:35,177 --> 00:49:36,719
JASON KU: Always the
minimum because I

1056
00:49:36,719 --> 00:49:38,666
want the biggest.

1057
00:49:38,666 --> 00:49:40,500
AUDIENCE: And the min of
absolute value.

1058
00:49:40,500 --> 00:49:42,329
JASON KU: Yes.

1059
00:49:42,329 --> 00:49:45,210
I am guided by the absolute
value of these thoughts.

1060
00:49:45,210 --> 00:49:45,710
Yes?

1061
00:49:45,710 --> 00:49:48,510
AUDIENCE: [INAUDIBLE]?

1062
00:49:48,510 --> 00:49:51,390
JASON KU: Total working hours here?

1063
00:49:51,389 --> 00:49:52,829
This is accounting.  It

1064
00:49:52,829 --> 00:50:01,469
took me log n
times log log n time

1065
00:50:01,469 --> 00:50:05,429
to create this
data structure in the beginning,

1066
00:50:05,429 --> 00:50:11,039
plus n times log log n.

1067
00:50:11,039 --> 00:50:15,509
I did, essentially, n operations--
asymptotically n operations.

1068
00:50:15,510 --> 00:50:19,620
So it's actually
n minus log n operations.

1069
00:50:19,619 --> 00:50:22,739
And each of these
tree operations --

1070
00:50:22,739 --> 00:50:25,349
doing one insertion, one deletion --

1071
00:50:25,349 --> 00:50:28,750
each of them took up
the height of the tree's time.

1072
00:50:28,750 --> 00:50:31,440
And that's it.

1073
00:50:31,440 --> 00:50:32,820
good?

1074
00:50:32,820 --> 00:50:33,420
Yes?

1075
00:50:33,420 --> 00:50:36,249
AUDIENCE: If instead of one
we just insert and delete,

1076
00:50:36,248 --> 00:50:39,029
you can do a comparison and then...

1077
00:50:39,030 --> 00:50:42,720
JASON KU:
Inserting and deleting an

1078
00:50:42,719 --> 00:50:45,929
AVL tree
actually performs a comparison

1079
00:50:45,929 --> 00:50:47,069
in its data structures.

1080
00:50:47,070 --> 00:50:47,910
AUDIENCE: Just
compare with min.

1081
00:50:47,909 --> 00:50:48,409
And then...

1082
00:50:48,409 --> 00:50:50,489
JASON KU: Sure,
you could do that.

1083
00:50:50,489 --> 00:50:52,409
I could have done it differently.

1084
00:50:52,409 --> 00:50:56,789
I could remove
the smallest element here,

1085
00:50:56,789 --> 00:50:58,860
for starters, right?

1086
00:50:58,860 --> 00:51:00,870
And then I compare
it to this guy,

1087
00:51:00,869 --> 00:51:04,369
and then whichever is
bigger, I put it back in.

1088
00:51:04,369 --> 00:51:06,159
The same.

1089
00:51:06,159 --> 00:51:09,259
Just do I do
the delete first and then the insert,

1090
00:51:09,260 --> 00:51:12,940
or do I do
the insert first and then the delete?

1091
00:51:12,940 --> 00:51:14,829
Any more questions?  There are

1092
00:51:14,829 --> 00:51:15,590
many questions.

1093
00:51:15,590 --> 00:51:16,090
Okay

1094
00:51:16,090 --> 00:51:18,940
, well, I guess I'll have to
skip the problem.

1095
00:51:18,940 --> 00:51:22,059
We're going to move to CS--

1096
00:51:22,059 --> 00:51:23,529
no, SCLR.

1097
00:51:27,039 --> 00:51:28,396
What is the link here?

1098
00:51:28,396 --> 00:51:30,100
AUDIENCE: [INAUDIBLE]

1099
00:51:30,099 --> 00:51:32,230
JASON KU: Yes, CLRS.

1100
00:51:32,230 --> 00:51:34,630
These are four academics
who wrote a popular

1101
00:51:34,630 --> 00:51:37,519
computer science textbook.

1102
00:51:37,519 --> 00:51:39,880
This is the same type of
k.

1103
00:51:39,880 --> 00:51:44,769
They found first editions and
want to sell them at auction.

1104
00:51:44,769 --> 00:51:46,552
People can go
to their website.

1105
00:51:46,552 --> 00:51:47,469
They have a bidder ID.

1106
00:51:47,469 --> 00:51:49,899
This is a unique identifier.

1107
00:51:49,900 --> 00:51:53,829
And they can bet
on one of these books.

1108
00:51:53,829 --> 00:51:57,400
And they can change that
during the bidding period,

1109
00:51:57,400 --> 00:52:00,639
but at the end of the
bidding period,

1110
00:52:00,639 --> 00:52:06,112
academics want
to know who--

1111
00:52:06,112 --> 00:52:08,079
what is the expected
revenue I will

1112
00:52:08,079 --> 00:52:10,059
get by selling k to the
highest bidder?  Does

1113
00:52:10,059 --> 00:52:13,469
this make sense?

1114
00:52:13,469 --> 00:52:15,929
Yes?

1115
00:52:15,929 --> 00:52:16,589
good.

1116
00:52:16,590 --> 00:52:22,559
Note that before creating
this data structure,

1117
00:52:22,559 --> 00:52:24,690
I know what k is.
k is a fixed thing.

1118
00:52:27,360 --> 00:52:31,230
Since my run time of this
get-revenue depends on this k,

1119
00:52:31,230 --> 00:52:34,469
it is not an input
for this operation.

1120
00:52:34,469 --> 00:52:37,529
So k is like I don't
know what it is, a priori.

1121
00:52:37,530 --> 00:52:39,630
It could be n to the power of 2.

1122
00:52:39,630 --> 00:52:42,180
It could be log n.

1123
00:52:42,179 --> 00:52:43,589
It could be 1.

1124
00:52:46,559 --> 00:52:48,539
But the data structure
I create must

1125
00:52:48,539 --> 00:52:50,940
satisfy these
runtime properties,

1126
00:52:50,940 --> 00:52:55,329
no matter what choice of k the
scientists told me.  Does

1127
00:52:55,329 --> 00:52:57,900
this make sense?

1128
00:52:57,900 --> 00:53:03,090
What I need to do is that
over time

1129
00:53:03,090 --> 00:53:07,920
people place new bids
and update their bids.

1130
00:53:07,920 --> 00:53:11,889
And these updates
can take log n time.

1131
00:53:11,889 --> 00:53:14,639
But as soon as I
close the window,

1132
00:53:14,639 --> 00:53:21,250
I want to be able to determine
in constant time what the k

1133
00:53:21,250 --> 00:53:24,670
highest bids are.

1134
00:53:24,670 --> 00:53:26,460
Any ideas on how to do this?

1135
00:53:26,460 --> 00:53:28,210
What surgeries
should I have?

1136
00:53:28,210 --> 00:53:32,920
I have the opportunity
to make a new bet.  Associated

1137
00:53:32,920 --> 00:53:37,690
with the bidder is
an idea and a bid,

1138
00:53:37,690 --> 00:53:39,440
which is also a whole number—

1139
00:53:39,440 --> 00:53:41,440
how many dollars am I going to
pay for this book.

1140
00:53:44,050 --> 00:53:45,700
Update your bid.

1141
00:53:45,699 --> 00:53:48,460
In a sense, I need to find out
if this person has placed a

1142
00:53:48,460 --> 00:53:51,829
bet before, in
my data structure.

1143
00:53:51,829 --> 00:53:54,699
So at some point I will
need to find the bidder ID.  Does

1144
00:53:54,699 --> 00:53:57,500
this seem possible?

1145
00:53:57,500 --> 00:53:59,800
So I could have
some kind of dictionary of

1146
00:53:59,800 --> 00:54:01,930
bidder IDs.

1147
00:54:01,929 --> 00:54:05,259
When I say I want to have a
dictionary about something,

1148
00:54:05,260 --> 00:54:08,800
right, I'm
not yet telling you

1149
00:54:08,800 --> 00:54:11,080
how I'm going to
implement that dictionary.

1150
00:54:11,079 --> 00:54:13,014
What are my usual options?

1151
00:54:13,014 --> 00:54:14,779
Hash table.

1152
00:54:14,780 --> 00:54:16,750
But what if I need
time in the worst case scenario?  A

1153
00:54:19,389 --> 00:54:21,119
set of AVL trees, right?

1154
00:54:21,119 --> 00:54:23,739
This would be your
choice for the dictionary

1155
00:54:23,739 --> 00:54:26,114
because it would give
me time to look things up

1156
00:54:26,114 --> 00:54:28,619
using the key.

1157
00:54:28,619 --> 00:54:31,559
That's the only thing--
well, besides sorted--

1158
00:54:31,559 --> 00:54:33,869
you can also use a
sorted array,

1159
00:54:33,869 --> 00:54:36,179
but it
won't be dynamic.

1160
00:54:36,179 --> 00:54:38,699
And here we are constantly updating
who is in my data structure

1161
00:54:38,699 --> 00:54:39,779
.

1162
00:54:39,780 --> 00:54:43,850
People come in
and place bets -

1163
00:54:43,849 --> 00:54:45,119
new people place bets.

1164
00:54:45,119 --> 00:54:47,279
Therefore, my set of things
that interest me is

1165
00:54:47,280 --> 00:54:48,572
constantly changing.

1166
00:54:48,572 --> 00:54:50,280
So this will probably
steer me away

1167
00:54:50,280 --> 00:54:52,440
from sorted arrays
as they are not

1168
00:54:52,440 --> 00:54:55,920
suitable for dynamic operations.

1169
00:54:55,920 --> 00:54:59,610
So I would need
some kind of dictionary of bidder IDs,

1170
00:54:59,610 --> 00:55:06,120
but I would also need to
maintain the sum of the k

1171
00:55:06,119 --> 00:55:06,809
highest bidders.  Does

1172
00:55:06,809 --> 00:55:08,710
this make sense?

1173
00:55:08,710 --> 00:55:10,650
And so, in a
sense, I need to

1174
00:55:10,650 --> 00:55:18,878
keep track of an ordered notion of
bidders, the bids that

1175
00:55:18,878 --> 00:55:19,920
are in my data structure.  Does

1176
00:55:19,920 --> 00:55:22,079
this make sense?

1177
00:55:22,079 --> 00:55:24,460
So the order
in the bets will be important.

1178
00:55:24,460 --> 00:55:28,409
I will need to
review the bidder ID.

1179
00:55:28,409 --> 00:55:31,329
And that's about it, isn't it?

1180
00:55:31,329 --> 00:55:31,829
good.

1181
00:55:31,829 --> 00:55:32,099
Yes?

1182
00:55:32,099 --> 00:55:32,670
AUDIENCE: Just checking.

1183
00:55:32,670 --> 00:55:34,045
So, if something

1184
00:55:34,045 --> 00:55:38,550
is executed at the worst possible time, it
is executed as expected [INDISPENSABLE].

1185
00:55:38,550 --> 00:55:39,150
JASON KU: Yes.

1186
00:55:39,150 --> 00:55:40,260
Right.

1187
00:55:40,260 --> 00:55:42,390
yes

1188
00:55:42,389 --> 00:55:44,190
This is a very good observation.

1189
00:55:44,190 --> 00:55:46,590
If it runs at the worst possible
time, it also

1190
00:55:46,590 --> 00:55:47,972
runs at the expected time, right?

1191
00:55:47,972 --> 00:55:49,805
Because there is essentially
no randomization here, which is what

1192
00:55:49,804 --> 00:55:51,649
I'm talking about.

1193
00:55:51,650 --> 00:55:54,619
AUDIENCE: [INAUDIBLE]?

1194
00:55:54,619 --> 00:55:55,449
JASON KU: Yes.

1195
00:55:55,449 --> 00:55:58,889
So,
we want you to point out the stronger point,

1196
00:55:58,889 --> 00:56:01,769
which is that there is actually
no randomization here.

1197
00:56:01,769 --> 00:56:04,259
We don't use a hash table.

1198
00:56:04,260 --> 00:56:07,973
In this class, this is really the
only situation where

1199
00:56:07,972 --> 00:56:09,139
this would be a problem.

1200
00:56:11,880 --> 00:56:16,450
But if it's the case that this problem
says for every [INAUDIBLE],

1201
00:56:16,449 --> 00:56:19,169
regardless of whether your running time is
worst-case expected and/or

1202
00:56:19,170 --> 00:56:22,349
amortized, we're really
trying to get you to say

1203
00:56:22,349 --> 00:56:23,009
that it's...

1204
00:56:26,219 --> 00:56:28,169
estimate the
running time of your algorithm

1205
00:56:28,170 --> 00:56:30,840
with proper qualification.

1206
00:56:30,840 --> 00:56:32,280
If this was the worst
case scenario, I want you to

1207
00:56:32,280 --> 00:56:35,030
say it was the worst case scenario.

1208
00:56:35,030 --> 00:56:38,300
If it was needed... if you
used a hash table,

1209
00:56:38,300 --> 00:56:39,620
I want you to say expected.

1210
00:56:39,619 --> 00:56:43,849
And if these operations
were sometimes really bad,

1211
00:56:43,849 --> 00:56:46,429
but on average they're really
good-- if I did a lot of them,

1212
00:56:46,429 --> 00:56:49,549
it amortizes.

1213
00:56:49,550 --> 00:56:53,180
Or if I reduced
the use of the dynamic array,

1214
00:56:53,179 --> 00:56:54,919
or if I reduced
the use of the hash table,

1215
00:56:54,920 --> 00:56:59,530
those dynamic operations would
still be amortized.

1216
00:56:59,530 --> 00:57:00,350
good.

1217
00:57:00,349 --> 00:57:01,699
Dynamic.

1218
00:57:01,699 --> 00:57:04,519
The nice thing about
linked data structures

1219
00:57:04,519 --> 00:57:07,148
is that dynamic operations are
not amortized.

1220
00:57:07,148 --> 00:57:08,690
So we
can get one.

1221
00:57:08,690 --> 00:57:12,079
Now for this problem we can
actually get the worst case bounds,

1222
00:57:12,079 --> 00:57:13,860
so we'll try to do that.

1223
00:57:13,860 --> 00:57:16,700
You can also do this in an expected way
by using some hash tables

1224
00:57:16,699 --> 00:57:20,239
for this dictionary.

1225
00:57:20,239 --> 00:57:21,709
When you approach the problem of
data structures

1226
00:57:21,710 --> 00:57:26,630
in this class,
you want to first tell me

1227
00:57:26,630 --> 00:57:30,800
what exactly you are
storing.

1228
00:57:30,800 --> 00:57:34,300
Tell me what
these things should have--

1229
00:57:34,300 --> 00:57:35,970
some invariants in
this data structure

1230
00:57:35,969 --> 00:57:40,519
to make sure that when
I query later,

1231
00:57:40,519 --> 00:57:42,559
these things are
taken care of,

1232
00:57:42,559 --> 00:57:49,519
so that if I'm storing a
sorted array,

1233
00:57:49,519 --> 00:57:52,070
and I'm supporting
an operation to find the maximum,

1234
00:57:52,070 --> 00:57:52,850
I'm better off...

1235
00:57:52,849 --> 00:57:54,380
everything I do with
this data structure

1236
00:57:54,380 --> 00:57:56,448
should support
invariants that

1237
00:57:56,447 --> 00:57:57,989
these things
are in sorted order,

1238
00:57:57,989 --> 00:58:00,619
and the last thing
has the maximum element.

1239
00:58:00,619 --> 00:58:03,769
Because my maximum return thing
will be

1240
00:58:03,769 --> 00:58:05,539
to look there and return that.  Does

1241
00:58:05,539 --> 00:58:07,289
this make sense?

1242
00:58:07,289 --> 00:58:10,519
So you want to tell me
what is stored

1243
00:58:10,519 --> 00:58:13,280
at a common point in
time during your

1244
00:58:13,280 --> 00:58:15,860
data structure that is
stored

1245
00:58:15,860 --> 00:58:20,059
so that when I support a
dynamic operation or a query,

1246
00:58:20,059 --> 00:58:23,630
in the dynamic operation
I insert and coming out

1247
00:58:23,630 --> 00:58:26,180
of that, I
need to make sure that I

1248
00:58:26,179 --> 00:58:28,507
preserve those invariants.

1249
00:58:28,507 --> 00:58:30,049
And when I ask,
I can

1250
00:58:30,050 --> 00:58:34,250
rely on these invariants
to answer my query.  Does

1251
00:58:34,250 --> 00:58:36,380
this make sense?

1252
00:58:36,380 --> 00:58:40,030
So for this
problem-- it's 4-3.

1253
00:58:43,829 --> 00:58:45,409
Any ideas?

1254
00:58:45,409 --> 00:58:50,029
I have two types of keys that
I may have to deal with.

1255
00:58:50,030 --> 00:58:55,519
One is the bid ID and
the other is the bid, right?

1256
00:58:55,519 --> 00:59:00,380
So how can I, if I have two
keys that I might

1257
00:59:00,380 --> 00:59:03,619
want to order on one
and search on the other,

1258
00:59:03,619 --> 00:59:06,186
how many data structures do
you think I'm going to use?

1259
00:59:06,186 --> 00:59:06,769
AUDIENCE: Two.

1260
00:59:06,769 --> 00:59:07,353
JASON KU: Two.

1261
00:59:07,353 --> 00:59:10,130
That's a pretty good guess.

1262
00:59:10,130 --> 00:59:11,510
So one of them...

1263
00:59:11,510 --> 00:59:12,860
let's just guess, shall we?

1264
00:59:12,860 --> 00:59:15,920
I need to be able to
search for bids,

1265
00:59:15,920 --> 00:59:24,110
so let's store these bidders
in some kind of dictionary

1266
00:59:24,110 --> 00:59:26,539
that can
quickly look up these things.

1267
00:59:26,539 --> 00:59:28,880
So, two data structures.

1268
00:59:28,880 --> 00:59:41,222
One of them is a dictionary
with a bidder identifier.

1269
00:59:44,989 --> 00:59:47,889
What more do I want?

1270
00:59:47,889 --> 00:59:48,389
What's there?

1271
00:59:52,329 --> 00:59:56,380
On the contrary, a
dictionary stored at the rates?  Do

1272
00:59:56,380 --> 00:59:57,910
I want a dictionary here?

1273
00:59:57,909 --> 01:00:01,480
AUDIENCE: [INAUDIBLE]
set up an AVL tree [INAUDIBLE]??

1274
01:00:01,480 --> 01:00:03,490
JASON KU: I want to
maintain order somehow.

1275
01:00:03,489 --> 01:00:06,250
Because I want to
preserve the greatest thing

1276
01:00:06,250 --> 01:00:07,780
I've seen so far.

1277
01:00:07,780 --> 01:00:12,102
Right now, if I have...
at some point in time,

1278
01:00:12,101 --> 01:00:13,059
what will happen?

1279
01:00:13,059 --> 01:00:16,779
If I keep k the
largest at any given time,

1280
01:00:16,780 --> 01:00:19,630
it is possible that
one of these participants

1281
01:00:19,630 --> 01:00:24,400
lowers their bid so that
it is no longer the highest.

1282
01:00:24,400 --> 01:00:27,309
I'll also need to keep
an eye on the other guys

1283
01:00:27,309 --> 01:00:31,840
to see, for example, who I should bring back
to this set.

1284
01:00:31,840 --> 01:00:33,880
Here's an idea.

1285
01:00:33,880 --> 01:00:37,823
I'm going to save not just one
data structure, but two

1286
01:00:37,822 --> 01:00:38,739
other data structures.

1287
01:00:38,739 --> 01:00:40,809
Maybe it's a leap.

1288
01:00:40,809 --> 01:00:42,009
You shouldn't do this.

1289
01:00:42,010 --> 01:00:44,140
There is a way to do this
with just one other person.

1290
01:00:44,139 --> 01:00:46,909
But I'm going to keep two more.

1291
01:00:46,909 --> 01:00:49,899
One of them is a

1292
01:00:49,900 --> 01:01:01,099
data structure for
storing participants with a -

1293
01:01:01,099 --> 01:01:14,019
storing the k participants with the highest bid
and a data structure

1294
01:01:14,019 --> 01:01:22,570
for storing n minus
k participants with the highest bid.  Does

1295
01:01:22,570 --> 01:01:25,640
this make sense?

1296
01:01:25,639 --> 01:01:31,190
That pretty much sums up my problem
, doesn't it?

1297
01:01:31,190 --> 01:01:33,829
Every time someone
interacts with this

1298
01:01:33,829 --> 01:01:41,360
data structure, I can
check if it's

1299
01:01:41,360 --> 01:01:44,599
bigger than the
smallest thing here.

1300
01:01:44,599 --> 01:01:48,319
If that's the case, I can do the
same trick I did before.

1301
01:01:48,320 --> 01:01:52,610
I can take it off and put my
new one in there.

1302
01:01:52,610 --> 01:01:54,200
And here we go...
but I deleted it.

1303
01:01:54,199 --> 01:01:56,659
I have to maintain
this property.

1304
01:01:56,659 --> 01:01:58,574
So I'm inserting it here.

1305
01:01:58,574 --> 01:01:59,449
There is another case.

1306
01:01:59,449 --> 01:02:00,366
What other case?

1307
01:02:03,190 --> 01:02:05,460
He is smaller.

1308
01:02:05,460 --> 01:02:07,090
In this case, I'm
not doing anything

1309
01:02:07,090 --> 01:02:09,340
with this data structure, I'm
just inserting it here.  Does

1310
01:02:09,340 --> 01:02:12,390
this make sense?

1311
01:02:12,389 --> 01:02:14,460
What operations should
these data structures support

1312
01:02:14,460 --> 01:02:16,380
?

1313
01:02:16,380 --> 01:02:19,410
Finding the minimum or
maximum of these two sets.  Does

1314
01:02:19,409 --> 01:02:20,819
this make sense?

1315
01:02:20,820 --> 01:02:25,230
Actually, really, where are
those operations?

1316
01:02:25,230 --> 01:02:26,639
I don't have them anymore.

1317
01:02:26,639 --> 01:02:29,069
But these were the
first priority operations in the queue.

1318
01:02:29,070 --> 01:02:33,750
They had delete_max--
and also insert--

1319
01:02:33,750 --> 01:02:36,929
these are things he did well.

1320
01:02:36,929 --> 01:02:40,199
So any
priority queue, anything that

1321
01:02:40,199 --> 01:02:45,269
can deal with maximum
and minimum values, is fine.

1322
01:02:45,269 --> 01:02:47,610
And what
data structure do you know that

1323
01:02:47,610 --> 01:02:50,910
can handle maxima
and minima quite efficiently?

1324
01:02:50,909 --> 01:02:51,869
AVL set, right?

1325
01:02:51,869 --> 01:02:55,829
So instead of a
data structure here I will

1326
01:02:55,829 --> 01:02:59,074
say, set up AVL.

1327
01:03:03,420 --> 01:03:12,168
And, obviously, it
will be received with enthusiasm.

1328
01:03:12,168 --> 01:03:14,460
Because that's what
I want to find

1329
01:03:14,460 --> 01:03:15,389
the maximum and minimum values.

1330
01:03:18,070 --> 01:03:19,690
Everyone follows
the logic,

1331
01:03:19,690 --> 01:03:23,583
why do I keep
these things?

1332
01:03:23,583 --> 01:03:25,000
This is the level of
invariance

1333
01:03:25,000 --> 01:03:28,400
that I want to maintain
because when I,

1334
01:03:28,400 --> 01:03:33,430
for example, do this
get-revenue query,

1335
01:03:33,429 --> 01:03:36,889
I can just run through and
summarize all of these things.

1336
01:03:36,889 --> 01:03:38,259
Oh, wait.

1337
01:03:38,260 --> 01:03:40,780
How much time do I have?   Do

1338
01:03:40,780 --> 01:03:42,250
I have k time?

1339
01:03:42,250 --> 01:03:44,210
No, I don't have time.

1340
01:03:44,210 --> 01:03:48,788
So I don't... I can't afford to
summarize all these things

1341
01:03:48,788 --> 01:03:49,880
at the end of my topic.

1342
01:03:49,880 --> 01:03:52,720
I must return it to
you in a constant time.

1343
01:03:52,719 --> 01:03:54,879
Any ideas?

1344
01:03:54,880 --> 01:03:59,230
Yes, just calculate--
update the amount.

1345
01:03:59,230 --> 01:04:02,829
Along with this
data structure, I'm

1346
01:04:02,829 --> 01:04:05,500
going to store a
fourth thing, which

1347
01:04:05,500 --> 01:04:13,119
is just the total number of their bets.

1348
01:04:13,119 --> 01:04:14,380
I'm going to call it t.

1349
01:04:18,670 --> 01:04:20,380
And that's what
I support.

1350
01:04:20,380 --> 01:04:22,779
This is part of my data structure.

1351
01:04:22,779 --> 01:04:24,370
You can think of it
as me adding a

1352
01:04:24,369 --> 01:04:27,309
number to it.

1353
01:04:27,309 --> 01:04:30,130
And the point of increasing
this thing by a number

1354
01:04:30,130 --> 01:04:31,510
is that I can just--

1355
01:04:31,510 --> 01:04:34,120
if I need to know what the
total amount of this stuff is,

1356
01:04:34,119 --> 01:04:35,799
I can just look at this number.  Does

1357
01:04:35,800 --> 01:04:38,260
this make sense?

1358
01:04:38,260 --> 01:04:39,100
Okay

1359
01:04:39,099 --> 01:04:41,920
, so I think
we're almost done.

1360
01:04:41,920 --> 01:04:44,050
We're basically done, right?

1361
01:04:44,050 --> 01:04:45,860
How do we do this?

1362
01:04:45,860 --> 01:04:51,220
Someone tell
me how I can generate revenue

1363
01:04:51,219 --> 01:04:54,269
with this data structure.

1364
01:04:54,269 --> 01:04:56,869
I basically told you.

1365
01:04:56,869 --> 01:04:57,799
Look at this number.

1366
01:04:57,800 --> 01:04:59,240
Turn it over.

1367
01:04:59,239 --> 01:05:02,579
Because it's an invariant
that I've stored in my

1368
01:05:02,579 --> 01:05:03,079
data structure.

1369
01:05:03,079 --> 01:05:04,759
I rely on this invariant.

1370
01:05:04,760 --> 01:05:06,860
Now I better
make sure it's good

1371
01:05:06,860 --> 01:05:09,349
when I do dynamic operations.

1372
01:05:09,349 --> 01:05:11,029
I make sure to support him.

1373
01:05:11,029 --> 01:05:15,973
But if I use induction to guarantee
that all of this is good,

1374
01:05:15,971 --> 01:05:18,139
and when I perform a dynamic
operation, all of this is

1375
01:05:18,139 --> 01:05:21,230
preserved,
then I'm fine.

1376
01:05:21,230 --> 01:05:28,050
So it's very easy to get an income after I do all this
extra work.

1377
01:05:28,050 --> 01:05:31,730
I just look at that
number and turn around.

1378
01:05:31,730 --> 01:05:33,619
When we grade a
data structures problem,

1379
01:05:33,619 --> 01:05:36,710
we usually award you a few points,
first for setting up your

1380
01:05:36,710 --> 01:05:39,110
data structure, separate
from the operations,

1381
01:05:39,110 --> 01:05:42,320
then we give you
points for the operation

1382
01:05:42,320 --> 01:05:44,360
you successfully
completed, and then

1383
01:05:44,360 --> 01:05:47,130
a few points for correctness
and running time.

1384
01:05:47,130 --> 01:05:49,619
Yes, did you have a question?

1385
01:05:49,619 --> 01:05:51,559
AUDIENCE: So the
total is the thing

1386
01:05:51,559 --> 01:05:54,769
that we update
every time we mess

1387
01:05:54,769 --> 01:05:58,871
with the tree of the highest-bidding participants
and then the tree of the participants with n minus k?

1388
01:05:58,871 --> 01:06:00,760
JASON KU: Sorry, could you
repeat that?

1389
01:06:00,760 --> 01:06:03,790
AUDIENCE: Do we view
the total as an increment

1390
01:06:03,788 --> 01:06:05,538
that we update
every time we do something?

1391
01:06:05,538 --> 01:06:05,750
JASON KU: Yes.  so So

1392
01:06:06,250 --> 01:06:07,885
, it's just one number.

1393
01:06:07,885 --> 01:06:09,260
It's not actually a
data structure,

1394
01:06:09,260 --> 01:06:12,770
it's just one number that
I store in my database.

1395
01:06:16,820 --> 01:06:17,420
good

1396
01:06:17,420 --> 01:06:23,010
How do I implement a
new bidding operation?

1397
01:06:23,010 --> 01:06:23,510
Yes?

1398
01:06:23,510 --> 01:06:24,677
AUDIENCE: I have a question.

1399
01:06:24,677 --> 01:06:27,302
Can we assume that the
rates will also be unique?

1400
01:06:27,302 --> 01:06:29,510
JASON KU: Can you suggest
that the rates might be unique?

1401
01:06:29,510 --> 01:06:30,010
No.

1402
01:06:32,420 --> 01:06:39,050
This is actually a
very useful observation.

1403
01:06:39,050 --> 01:06:42,288
We talked about a
set of data structures

1404
01:06:42,288 --> 01:06:47,389
that require unique keys.

1405
01:06:47,389 --> 01:06:48,889
How can I work with
non-unique keys?

1406
01:06:48,889 --> 01:06:51,139
In fact,
it turns out that it is very important for a hash table

1407
01:06:51,139 --> 01:06:54,650

that these are unique keys.

1408
01:06:54,650 --> 01:06:56,930
Because I need to check
if it's there.

1409
01:06:56,929 --> 01:06:59,109
I am looking for that one key.

1410
01:06:59,110 --> 01:07:01,340
When I find it,
I must return.

1411
01:07:01,340 --> 01:07:03,230
If I had multiple
items with this key,

1412
01:07:03,230 --> 01:07:05,449
I might not get the one I'm
looking for back.  It

1413
01:07:05,449 --> 01:07:08,239
doesn't even make sense.

1414
01:07:08,239 --> 01:07:17,239
But you can generalize the
set infrastructure

1415
01:07:17,239 --> 01:07:19,229
to work with multiple sets.

1416
01:07:19,230 --> 01:07:21,420
How can I do this?

1417
01:07:21,420 --> 01:07:24,860
Well, with each key--

1418
01:07:24,860 --> 01:07:26,720
again, I store unique keys.

1419
01:07:26,719 --> 01:07:30,109
With each key, I can associate it
with a set of sequence structures

1420
01:07:30,110 --> 01:07:32,258
or any other data structure.

1421
01:07:32,257 --> 01:07:34,549
And what I'm going to do,
I'm going to do... anything

1422
01:07:34,550 --> 01:07:36,440
that has that key,
I'm going to put it

1423
01:07:36,440 --> 01:07:38,557
into this data structure.

1424
01:07:38,557 --> 01:07:40,099
So instead of storing
one item there,

1425
01:07:40,099 --> 01:07:42,266
I have the ability to
store many things there.

1426
01:07:42,266 --> 01:07:44,699
Now I have to change the
semantics here.

1427
01:07:44,699 --> 01:07:48,799
If I say, find on this
key, well, now, I could say,

1428
01:07:48,800 --> 01:07:51,800
I'm going to return all the
things with this key,

1429
01:07:51,800 --> 01:07:55,010
or I'm going to keep
some things with this key.

1430
01:07:55,010 --> 01:07:56,150
But you understand.

1431
01:07:56,150 --> 01:07:59,970
All I need to do is map this
to another data structure

1432
01:07:59,969 --> 01:08:01,159
to support [INAUDIBLE].

1433
01:08:01,159 --> 01:08:06,379
Maybe I need all the
things with this key.

1434
01:08:06,380 --> 01:08:09,440
I want to find the one
who has this key.

1435
01:08:09,440 --> 01:08:11,474
So maybe I'm referring to a
set of data structures

1436
01:08:11,474 --> 01:08:13,099
that can look up
other things, right?

1437
01:08:13,099 --> 01:08:15,409
But the idea is that
we maintain

1438
01:08:15,409 --> 01:08:18,108
this key property of uniqueness.

1439
01:08:18,109 --> 01:08:20,810
I need to loosen my
semantics so that I

1440
01:08:20,810 --> 01:08:23,609
store multiple things
in this key location.  Does

1441
01:08:23,609 --> 01:08:24,550
this make sense?

1442
01:08:24,550 --> 01:08:25,250
Yes?

1443
01:08:25,250 --> 01:08:27,250
AUDIENCE: Why does it
matter whether a

1444
01:08:27,250 --> 01:08:28,511
set of AVL trees has unique keys or not?

1445
01:08:31,220 --> 01:08:35,750
JASON KU: It will matter here
because I have stakes.

1446
01:08:35,750 --> 01:08:38,899
And the rates may
not be unique.

1447
01:08:38,899 --> 01:08:43,578
Two people can
have the same bet.

1448
01:08:43,578 --> 01:08:46,850
And according to our definition of a
data structure,

1449
01:08:46,850 --> 01:08:48,149
it must have unique keys.

1450
01:08:48,149 --> 01:08:50,868
So, if I get stuck with all
these things entered by the bidder,

1451
01:08:50,868 --> 01:08:53,510
you're going to have a problem.

1452
01:08:53,510 --> 01:08:54,979
Now, actually,
we can

1453
01:08:54,979 --> 01:08:57,439
avoid this by
essentially keeping a linked

1454
01:08:57,439 --> 01:09:00,529
list of all the things with
that key, and everything will be fine.

1455
01:09:03,109 --> 01:09:06,260
And then when I want to
return one, I can just do it.

1456
01:09:06,260 --> 01:09:10,550
But
in reality, a binary tree is

1457
01:09:10,550 --> 01:09:12,948
flexible enough that
in most implementations

1458
01:09:12,948 --> 01:09:15,920
you can just store
a bunch of these things.

1459
01:09:15,920 --> 01:09:20,840
But, in reality, our
running time is worse.

1460
01:09:20,840 --> 01:09:24,439
What does it mean
to find the next in my sequence?

1461
01:09:24,439 --> 01:09:29,750
What does it mean
to return the next bigger

1462
01:09:29,750 --> 01:09:32,029
thing above this key?

1463
01:09:32,029 --> 01:09:33,859
This doesn't really make
sense, as there

1464
01:09:33,859 --> 01:09:34,818
could be several.

1465
01:09:34,818 --> 01:09:36,200
Which one should I return?

1466
01:09:36,198 --> 01:09:41,269
And if I do find-next multiple times
on this data structure,

1467
01:09:41,270 --> 01:09:44,720
I might not loop through
all the stuff.

1468
01:09:44,720 --> 01:09:49,170
So, some things are
breaking in our interface.

1469
01:09:49,170 --> 01:09:54,980
So I would prefer using unique
keys in such a situation.

1470
01:09:54,979 --> 01:09:58,579
Next Tuesday, I think

1471
01:09:58,579 --> 01:10:02,720
we'll be dealing with non-unique keys with binary heaps.

1472
01:10:02,720 --> 01:10:04,230
that's fine.

1473
01:10:04,229 --> 01:10:09,439
But if you're going to use
non-unique keys here,

1474
01:10:09,439 --> 01:10:11,479
you just need
to be a little

1475
01:10:11,479 --> 01:10:13,919
careful about the semantics.

1476
01:10:13,920 --> 01:10:14,420
Yes?

1477
01:10:14,420 --> 01:10:15,409
AUDIENCE: [INAUDIBLE]?

1478
01:10:24,500 --> 01:10:27,619
JASON KU: You'll
get the same

1479
01:10:27,619 --> 01:10:29,960
amount of work – you'll just have to
change the semantics of what

1480
01:10:29,960 --> 01:10:32,510
you mean by
"find something."

1481
01:10:32,510 --> 01:10:35,570
I just want to return
anything with this key.

1482
01:10:35,568 --> 01:10:37,489
AUDIENCE: What if
everything has the same key.

1483
01:10:37,489 --> 01:10:38,189
Then...

1484
01:10:38,189 --> 01:10:39,899
JASON KU: Then it
takes constant time.

1485
01:10:39,899 --> 01:10:41,149
I'm just returning the first one.

1486
01:10:45,109 --> 01:10:48,409
I mean, these are
special cases that you

1487
01:10:48,409 --> 01:10:51,139
need to think about, right?

1488
01:10:51,140 --> 01:10:52,920
I don't like to
think about them.

1489
01:10:52,920 --> 01:10:55,460
That's why I just like
unique keys.

1490
01:10:55,460 --> 01:10:59,568
And if I need a situation
where I have non-unique keys,

1491
01:10:59,568 --> 01:11:02,869
I'm going to
put the collisions of that key

1492
01:11:02,869 --> 01:11:04,909
into a new data structure.   It's

1493
01:11:04,909 --> 01:11:06,539
just easier for me
to separate

1494
01:11:06,539 --> 01:11:08,300
what's happening in my head.

1495
01:11:08,300 --> 01:11:11,029
Because all the
runtimes we proposed

1496
01:11:11,029 --> 01:11:14,539
have very clear
definitions of the unique key.

1497
01:11:14,539 --> 01:11:16,970
When you're dealing
with a multiset,

1498
01:11:16,970 --> 01:11:20,150
it's a little
more common.

1499
01:11:20,149 --> 01:11:21,889
Any more questions?

1500
01:11:21,890 --> 01:11:25,910
We really need to
move on, don't we?

1501
01:11:25,909 --> 01:11:27,649
Dictionary with key on tender.

1502
01:11:27,649 --> 01:11:31,670
We haven't implemented
any dynamic operations yet.

1503
01:11:31,670 --> 01:11:32,359
New bet.

1504
01:11:32,359 --> 01:11:34,889
What should I do?

1505
01:11:34,890 --> 01:11:38,030
What will I
need to upgrade?

1506
01:11:38,029 --> 01:11:42,019
I will
need to find

1507
01:11:42,020 --> 01:11:44,120
in each of these
data structures

1508
01:11:44,119 --> 01:11:47,510
where this bidder is located.

1509
01:11:47,510 --> 01:11:51,890
And if I just
point to their rate,

1510
01:11:51,890 --> 01:11:54,770
the interface doesn't tell
me what their old rate was.

1511
01:11:54,770 --> 01:11:57,200
It just tells me what
their bidder ID is.

1512
01:11:57,199 --> 01:12:02,029
So if I only had the auctioneer ID
and the new bid, how the heck do

1513
01:12:02,029 --> 01:12:04,429
I figure out
which of these data – where

1514
01:12:04,430 --> 01:12:07,190
they are in these data structures?

1515
01:12:07,189 --> 01:12:11,629
What I can do is I can
store in this dictionary--

1516
01:12:11,630 --> 01:12:15,680
which I can look up after a
certain amount of time-- a

1517
01:12:15,680 --> 01:12:18,050
pointer to where it
exists in these things.  Does

1518
01:12:18,050 --> 01:12:20,690
this make sense?

1519
01:12:20,689 --> 01:12:21,919
This is called cross-linking.

1520
01:12:21,920 --> 01:12:24,800
Maybe you did a little bit of that
in

1521
01:12:24,800 --> 01:12:26,940
Problem Set 2 or something like that.

1522
01:12:26,939 --> 01:12:27,439
Yes?

1523
01:12:27,439 --> 01:12:30,589
AUDIENCE: Restore
a pointer to a specific participant?

1524
01:12:30,590 --> 01:12:32,779
JASON KU: Yeah, exactly.  The

1525
01:12:32,779 --> 01:12:34,177
invariant that we
have is that all the

1526
01:12:34,177 --> 01:12:35,720
bettors that we've
processed so far

1527
01:12:35,720 --> 01:12:38,420
exist in these data structures--

1528
01:12:38,420 --> 01:12:41,059
in one of these
data structures--

1529
01:12:41,059 --> 01:12:43,850
because we've used an
AVL tree set.

1530
01:12:43,850 --> 01:12:45,800
Specifically, it
exists in a node of one

1531
01:12:45,800 --> 01:12:47,659
of these data structures.

1532
01:12:47,659 --> 01:12:50,779
What we can do is

1533
01:12:50,779 --> 01:12:56,479
maintain pointers that map
each bidder ID

1534
01:12:56,479 --> 01:12:58,909
to its location in
these data structures.

1535
01:12:58,909 --> 01:13:00,920
And why would that be
useful?

1536
01:13:04,220 --> 01:13:06,289
Let's say I draw this dictionary.

1537
01:13:06,289 --> 01:13:07,789
What can I use
for this dictionary

1538
01:13:07,789 --> 01:13:10,579
to get the
required uptime?

1539
01:13:10,579 --> 01:13:13,340
I could use a hash
table or an AVL set.

1540
01:13:13,340 --> 01:13:16,520
If it's AVL set, I'll
get logarithmic time, worst

1541
01:13:16,520 --> 01:13:17,705
case.

1542
01:13:17,704 --> 01:13:19,579
With a hash table I
get constant time,

1543
01:13:19,579 --> 01:13:21,119
but that's expected.

1544
01:13:21,119 --> 01:13:24,920
So in the worst case, it could be linear
time.

1545
01:13:24,920 --> 01:13:27,020
We will use the installed
AVL tree because that is what

1546
01:13:27,020 --> 01:13:30,330
we are doing now.

1547
01:13:30,329 --> 01:13:32,809
And this
will lead to the worst case scenario.

1548
01:13:35,059 --> 01:13:36,393
I'm going to keep this pointer for each of these things.   The first thing

1549
01:13:36,393 --> 01:13:39,682
I'm going to
do is I'm going to

1550
01:13:39,682 --> 01:13:41,100
do that
surgery that we did.

1551
01:13:41,100 --> 01:13:49,100
If I add a new bettor,
I'll take D and B--

1552
01:13:49,100 --> 01:13:53,840
these two values, this
object, this bettor object

1553
01:13:53,840 --> 01:13:54,818
or whatever--

1554
01:13:54,818 --> 01:13:58,039
I'll look at the
smallest thing in this

1555
01:13:58,039 --> 01:14:06,470
data structure, see if their bet is
greater than what

1556
01:14:06,470 --> 01:14:07,682
I'm inserting.

1557
01:14:07,682 --> 01:14:10,100
If so, then I'm not going to
touch this data structure.

1558
01:14:10,100 --> 01:14:11,840
I'll just
paste it here.

1559
01:14:11,840 --> 01:14:13,992
And now, after
inserting it here, I

1560
01:14:13,992 --> 01:14:15,949
know exactly where it is
in the data structure.

1561
01:14:15,949 --> 01:14:19,369
I just inserted it.

1562
01:14:19,369 --> 01:14:22,010
So now, with
this in my hand-- the

1563
01:14:22,010 --> 01:14:27,680
node-- I can go and
insert this bidder here

1564
01:14:27,680 --> 01:14:29,990
by bid ID.

1565
01:14:29,989 --> 01:14:31,818
So, it
will take logarithmic time.

1566
01:14:31,818 --> 01:14:36,409
And now I can store
my pointer

1567
01:14:36,409 --> 01:14:37,564
to this data structure using this node.  Does

1568
01:14:37,564 --> 01:14:38,818
this make sense?

1569
01:14:38,818 --> 01:14:41,779
Otherwise, I
do the same thing.

1570
01:14:41,779 --> 01:14:45,050
If it's bigger than the smallest
thing here, I take this smaller

1571
01:14:45,050 --> 01:14:48,619
thing out, put it in there,
and I put my new guy in here,

1572
01:14:48,619 --> 01:14:52,859
connecting each of these
pointers as I go.

1573
01:14:52,859 --> 01:14:57,469
I hope this makes sense?

1574
01:14:57,470 --> 01:14:59,280
Like?

1575
01:14:59,279 --> 01:14:59,779
Like?

1576
01:14:59,779 --> 01:15:00,859
good.

1577
01:15:00,859 --> 01:15:03,469
And for the update it's very similar.

1578
01:15:03,470 --> 01:15:06,050
If I want to update a
particular bidder,

1579
01:15:06,050 --> 01:15:11,550
I look in this
data structure, find the bidder,

1580
01:15:11,550 --> 01:15:13,440
move that
pointer to where

1581
01:15:13,439 --> 01:15:16,979
it is in one of these
AVL trees, right?

1582
01:15:16,979 --> 01:15:22,049
If it's in there, I just
remove it from the tree

1583
01:15:22,050 --> 01:15:23,789
or remove it from the
tree and then

1584
01:15:23,789 --> 01:15:29,068
reinsert it with a
new bid.

1585
01:15:29,068 --> 01:15:32,009
And if it's in
this, I

1586
01:15:32,010 --> 01:15:35,190
remove it from the tree again,
insert it back into any

1587
01:15:35,189 --> 01:15:36,839
of these things,
and then I might have to

1588
01:15:36,840 --> 01:15:39,720
swap a constant
number of things back and

1589
01:15:39,720 --> 01:15:43,020
forth to maintain
that this has the highest k .

1590
01:15:43,020 --> 01:15:47,610
And when I do these
dynamic operations,

1591
01:15:47,609 --> 01:15:50,369
I always remove
some constant number of

1592
01:15:50,369 --> 01:15:53,340
nodes in each of these
trees and add back a

1593
01:15:53,340 --> 01:15:55,212
constant number of things.

1594
01:15:55,212 --> 01:15:57,630
And while I'm doing that, I'm just
updating this total

1595
01:15:57,630 --> 01:15:58,980
as I go.

1596
01:15:58,979 --> 01:16:04,679
This amount was the sum of
all the bets here.

1597
01:16:04,680 --> 01:16:07,320
And if I insert a
new rate here,

1598
01:16:07,318 --> 01:16:09,519
I have to add to this amount.

1599
01:16:09,520 --> 01:16:11,858
And if I remove one, I have to
remove from that total.

1600
01:16:11,858 --> 01:16:13,650
But again, it's a
constant number of things that

1601
01:16:13,649 --> 01:16:15,899
I'm putting in and out of
these data structures,

1602
01:16:15,899 --> 01:16:18,059
so it can update
that in constant time.  Does

1603
01:16:18,059 --> 01:16:19,800
this make sense?

1604
01:16:19,800 --> 01:16:23,760
Now, the search here, and the
insert and delete

1605
01:16:23,760 --> 01:16:29,130
here, each of them took
logarithmic time, in the worst case.

1606
01:16:29,130 --> 01:16:30,850
But I made a
steady number of them.

1607
01:16:30,850 --> 01:16:32,780
So, again the logarithm of time.  Does

1608
01:16:32,779 --> 01:16:33,929
this make sense?

1609
01:16:33,930 --> 01:16:37,680
That's essentially the
problem.

1610
01:16:37,680 --> 01:16:39,280
It's hard, right?  There are

1611
01:16:39,279 --> 01:16:41,469
a lot of
moving parts here.

1612
01:16:41,470 --> 01:16:44,610
But if you just break it down
and describe it to me...

1613
01:16:44,609 --> 01:16:47,279
like, you did a really
good job on this part,

1614
01:16:47,279 --> 01:16:50,789
describe it to me well, what
your data structure is, then

1615
01:16:50,789 --> 01:16:52,380
these descriptions of
these algorithms

1616
01:16:52,380 --> 01:16:53,920
can be pretty short.

1617
01:16:57,119 --> 01:16:59,939
In this case, you tell me
these three data structures,

1618
01:16:59,939 --> 01:17:03,629
you tell me this guy
maps to his location

1619
01:17:03,630 --> 01:17:07,770
and these things, I
serve this guy,

1620
01:17:07,770 --> 01:17:11,520
and then you just maintain these
things with dynamic operations,

1621
01:17:11,520 --> 01:17:14,910
and then you use these things
for query operations.  Does

1622
01:17:14,909 --> 01:17:15,898
this make sense?

1623
01:17:19,630 --> 01:17:20,960
Wow, do we have 10 more minutes?

1624
01:17:25,809 --> 01:17:32,830
I'll
make it 4-4 for you briefly.

1625
01:17:32,829 --> 01:17:33,699
Register of recipients.

1626
01:17:33,699 --> 01:17:36,880
We have a coach.

1627
01:17:36,880 --> 01:17:38,980
She has a bunch of
football players--

1628
01:17:38,979 --> 01:17:41,648
receivers.

1629
01:17:41,648 --> 01:17:45,789
And wanting to
start on her team,

1630
01:17:45,789 --> 01:17:50,380
a certain number of players who
have the highest efficiency.

1631
01:17:50,380 --> 01:17:52,930
And by performance, we
mean the average number of

1632
01:17:52,930 --> 01:17:54,970
points they played
in the games they

1633
01:17:54,970 --> 01:17:56,980
registered in their system.

1634
01:17:56,979 --> 01:18:00,279
But in reality, their
data is incomplete.

1635
01:18:00,279 --> 01:18:02,679
They don't know in which games
and how many they scored

1636
01:18:02,680 --> 01:18:03,680
and all that stuff.  There

1637
01:18:03,680 --> 01:18:05,090
may be errors.

1638
01:18:05,090 --> 01:18:08,318
And so these interns are
constantly

1639
01:18:08,318 --> 01:18:15,369
updating this database with
queries like "oh, never mind,

1640
01:18:15,369 --> 01:18:17,979
this person didn't
play this game,

1641
01:18:17,979 --> 01:18:21,849
or actually did play it and they
scored this many points."

1642
01:18:21,850 --> 01:18:25,780
This is... cleaning
and writing things down.

1643
01:18:25,779 --> 01:18:28,359
And then, at some
point in time, like

1644
01:18:28,359 --> 01:18:31,869
when we want to
play a game, I want to be

1645
01:18:31,869 --> 01:18:36,760
able to return
the shirt with the kth highest

1646
01:18:36,760 --> 01:18:40,270
efficiency in log n time.

1647
01:18:40,270 --> 01:18:45,370
This is a kind of
rank request, right?

1648
01:18:45,369 --> 01:18:46,135
k-th highest.

1649
01:18:48,670 --> 01:18:53,500
Now, actually, I can
return all the top k players

1650
01:18:53,500 --> 01:18:56,050
so that can be my list.

1651
01:18:56,050 --> 01:19:00,070
But this is a more
generalized request.

1652
01:19:00,068 --> 01:19:02,000
It's more specific, more...

1653
01:19:02,000 --> 01:19:04,029
it's not really comparable.

1654
01:19:04,029 --> 01:19:07,358
But you understand why this
can be useful for a coach.  I

1655
01:19:07,358 --> 01:19:07,900
don't know.

1656
01:19:07,898 --> 01:19:10,089
Maybe not.

1657
01:19:10,090 --> 01:19:11,666
So what's the idea here?   There are

1658
01:19:11,666 --> 01:19:13,750
many different things floating around us
.

1659
01:19:13,750 --> 01:19:15,279
We have games.

1660
01:19:15,279 --> 01:19:17,179
They have identifiers - unique identifiers.

1661
01:19:17,180 --> 01:19:18,039
We have receivers.

1662
01:19:18,039 --> 01:19:19,630
They have unique identifiers.

1663
01:19:19,630 --> 01:19:23,890
And each receiver could
play a lot of games.

1664
01:19:23,890 --> 01:19:26,590
Oh, that's kind of disturbing.

1665
01:19:26,590 --> 01:19:30,989
And many receivers can
play in one game.

1666
01:19:30,989 --> 01:19:32,679
These
many-to-one mappings are

1667
01:19:32,680 --> 01:19:34,490
a bit confusing.

1668
01:19:34,489 --> 01:19:39,109
And then each player--

1669
01:19:39,109 --> 01:19:42,199
receiver-- has a certain
number of points per game.

1670
01:19:42,199 --> 01:19:45,929
And we try to sort them
by performance,

1671
01:19:45,930 --> 01:19:47,943
which is a rational number.

1672
01:19:47,943 --> 01:19:50,480
Ugh, right?

1673
01:19:50,479 --> 01:19:52,879
Which is related to
the number of games played

1674
01:19:52,880 --> 01:19:55,880
and the total number of points.

1675
01:19:55,880 --> 01:19:59,420
Now I see a rational number,
I can't calculate it.

1676
01:19:59,420 --> 01:20:02,989
This is what we talked about in the
last problem session, right?

1677
01:20:02,989 --> 01:20:04,447
But what I can do
is keep track of the

1678
01:20:04,448 --> 01:20:05,990
total number of
games they have played

1679
01:20:05,989 --> 01:20:07,729
and the total number of
points they have.

1680
01:20:07,729 --> 01:20:09,829
And you can imagine that
with an extension

1681
01:20:09,829 --> 01:20:14,689
like this, every time
I add a game, one

1682
01:20:14,689 --> 01:20:18,979
of these little operations, I
can update this information

1683
01:20:18,979 --> 01:20:19,699
for each player.

1684
01:20:22,850 --> 01:20:25,039
If one of these
dynamic operations

1685
01:20:25,039 --> 01:20:27,439
only affects
one receiver, I

1686
01:20:27,439 --> 01:20:31,549
can update any information
in constant time,

1687
01:20:31,550 --> 01:20:35,059
perhaps if I just store the
player's

1688
01:20:35,059 --> 01:20:38,731
total number of games
recorded in the database

1689
01:20:38,731 --> 01:20:40,189
and the number of points
they have scored.

1690
01:20:40,189 --> 01:20:43,068
Then, if I have a
data structure that

1691
01:20:43,068 --> 01:20:47,789
requires sorting the receivers
by their performance

1692
01:20:47,789 --> 01:20:50,210
so that I can
find the kth one — the

1693
01:20:50,210 --> 01:20:56,739
kth largest — then I can't
compute that performance.

1694
01:20:56,739 --> 01:20:59,289
But what can I do?

1695
01:20:59,289 --> 01:21:02,818
I can compare two players based on
their performance using

1696
01:21:02,818 --> 01:21:05,429
cross multiplication.

1697
01:21:05,430 --> 01:21:07,740
Because I have the
numerator and denominator of

1698
01:21:07,739 --> 01:21:09,239
each of these
rational numbers, and I can

1699
01:21:09,239 --> 01:21:11,909
cross-multiply and
determine which is

1700
01:21:11,909 --> 01:21:13,329
greater or less.

1701
01:21:13,329 --> 01:21:15,029
And as long as I
have a comparator,

1702
01:21:15,029 --> 01:21:17,849
I can do AVL sets.  Does

1703
01:21:17,850 --> 01:21:19,120
this make sense?

1704
01:21:19,119 --> 01:21:20,609
good.

1705
01:21:20,609 --> 01:21:25,439
I'll just outline
the components of this

1706
01:21:25,439 --> 01:21:26,239
data structure.

1707
01:21:28,770 --> 01:21:32,730
Well, first, I'll
need to record the receiver.

1708
01:21:32,729 --> 01:21:34,779
And there can
be a lot of games in the receiver.

1709
01:21:34,779 --> 01:21:37,648
But the important thing is the problem
centered on the receiver

1710
01:21:37,648 --> 01:21:38,229
.

1711
01:21:38,229 --> 01:21:39,929
Does this make
sense to you guys?

1712
01:21:39,930 --> 01:21:42,960
I never want to
filter out all the receivers that

1713
01:21:42,960 --> 01:21:44,489
play a game.

1714
01:21:44,489 --> 01:21:50,489
I never delete a
game from the system,

1715
01:21:50,489 --> 01:21:53,039
I delete
the receiver so that it can never

1716
01:21:53,039 --> 01:21:54,420
play a certain game.  Does

1717
01:21:54,420 --> 01:21:55,630
this make sense?

1718
01:21:55,630 --> 01:21:59,430
So if I'm storing a
receiver, and each receiver

1719
01:21:59,430 --> 01:22:01,980
has certain games
associated with them, it

1720
01:22:01,979 --> 01:22:05,369
makes sense, I
could have a nested

1721
01:22:05,369 --> 01:22:08,159
data structure where s--

1722
01:22:08,159 --> 01:22:11,550
maybe I have a
dictionary about receivers.

1723
01:22:11,550 --> 01:22:14,400
And for each of them, I
store all the games

1724
01:22:14,398 --> 01:22:17,219
they played in a
different data structure.

1725
01:22:17,220 --> 01:22:20,347
With each receiver, I store a
different — its own

1726
01:22:20,346 --> 01:22:21,929
data structure containing
all of its games.  Does

1727
01:22:21,930 --> 01:22:23,640
this make sense?

1728
01:22:23,640 --> 01:22:26,280
Okay, that's an idea.

1729
01:22:26,279 --> 01:22:27,539
We have something like...

1730
01:22:27,539 --> 01:22:31,590
I need to be able to
look for receivers

1731
01:22:31,590 --> 01:22:35,970
because I'm clearing them
or recording them.

1732
01:22:35,970 --> 01:22:40,320
So I'm going to have a
dictionary or...

1733
01:22:40,318 --> 01:22:42,969
here, I'm looking for the
worst time journal.

1734
01:22:42,970 --> 01:22:45,869
So I'm going to skip the
dictionary abstraction

1735
01:22:45,869 --> 01:22:49,260
and go directly to the AVL set.

1736
01:22:49,260 --> 01:23:00,150
AVL key on receivers.

1737
01:23:00,148 --> 01:23:06,729
I before E, except
C. Is that I--

1738
01:23:06,729 --> 01:23:07,229
E-I?

1739
01:23:10,648 --> 01:23:11,849
This rule never works.

1740
01:23:11,850 --> 01:23:13,200
good.

1741
01:23:13,199 --> 01:23:17,939
Set up an AVL tree on the receivers,
and each of these nodes

1742
01:23:17,939 --> 01:23:23,009
with each of these
receivers I'm going to save--

1743
01:23:23,010 --> 01:23:32,250
for each one I'm going to save an
AVL set in the games.

1744
01:23:36,329 --> 01:23:38,460
Why do I keep an
AVL set in games?

1745
01:23:38,460 --> 01:23:42,480
Why don't I just save a
list of all the games?

1746
01:23:42,479 --> 01:23:45,359
Because if I want to remove
this game from the receiver,

1747
01:23:45,359 --> 01:23:47,250
I need to do it in log n time.

1748
01:23:47,250 --> 01:23:51,520
And here we say
that n is the number of games,

1749
01:23:51,520 --> 01:23:54,000
but the number of
players on a team is

1750
01:23:54,000 --> 01:23:56,760
always less than the
number of games.

1751
01:23:56,760 --> 01:24:02,039
If I search this AVL tree
and search its AVL tree,

1752
01:24:02,039 --> 01:24:07,050
I can be sure that these two
searches have only been registered n times.

1753
01:24:07,050 --> 01:24:08,840
Because I need to
delete the game, right?

1754
01:24:08,840 --> 01:24:11,710
So, here it is.

1755
01:24:11,710 --> 01:24:13,289
Then what do I do?

1756
01:24:13,289 --> 01:24:15,550
I return the kth
highest performance.

1757
01:24:15,550 --> 01:24:21,100
Well, I need-- with each
of these guys I also keep--

1758
01:24:21,100 --> 01:24:22,630
what was that increase?

1759
01:24:22,630 --> 01:24:28,029
The amount of points
saved in these games.

1760
01:24:28,029 --> 01:24:32,755
The sum of the points and--

1761
01:24:35,350 --> 01:24:40,000
what was that-- numbers games.

1762
01:24:40,000 --> 01:24:43,130
Because if I keep both of
these things in constant time,

1763
01:24:43,130 --> 01:24:46,449
I will be able to
calculate their performance,

1764
01:24:46,449 --> 01:24:49,000
where I will
be able to have the data I

1765
01:24:49,000 --> 01:24:51,289
need to compare performance.

1766
01:24:51,289 --> 01:24:52,600
AUDIENCE: [INAUDIBLE]?

1767
01:24:52,600 --> 01:24:53,530
JASON KU: Yes, that's right.

1768
01:24:53,529 --> 01:24:54,969
Just numbers.

1769
01:24:54,970 --> 01:24:56,090
These are data structures.

1770
01:24:56,090 --> 01:24:56,970
This is a data structure.

1771
01:24:56,970 --> 01:24:57,927
These are just numbers.

1772
01:25:00,398 --> 01:25:02,189
And I keep that
with every receiver.

1773
01:25:05,109 --> 01:25:08,859
But that won't help
me find the kth highest player.

1774
01:25:08,859 --> 01:25:13,579
None of these things are
sorted by performance.

1775
01:25:13,579 --> 01:25:15,635
So I need the last data structure.

1776
01:25:22,760 --> 01:25:31,130
Fifth, I need to store
something dynamically sorted

1777
01:25:31,130 --> 01:25:32,970
by performance.

1778
01:25:32,970 --> 01:25:33,720
AUDIENCE: Install AVL?

1779
01:25:33,720 --> 01:25:35,809
JASON KU: Install AVL, yes.

1780
01:25:35,809 --> 01:25:50,940
Install AVL that keeps receivers
tuned for performance.

1781
01:25:50,939 --> 01:25:55,579
Now, when I talk
about performance,

1782
01:25:55,579 --> 01:25:57,199
you want to mention
something about

1783
01:25:57,199 --> 01:25:58,909
cross multiplication.

1784
01:25:58,909 --> 01:26:01,220
For example, I store with
each of these things

1785
01:26:01,220 --> 01:26:04,070
this increment, and when
I compare two things,

1786
01:26:04,068 --> 01:26:05,898
I use cross multiplication.

1787
01:26:05,898 --> 01:26:08,839
But beyond that, we
can abstract from that, right?

1788
01:26:08,840 --> 01:26:10,699
We abstracted
this function call.

1789
01:26:10,699 --> 01:26:13,699
And I can imagine
comparing the two keys.

1790
01:26:13,699 --> 01:26:14,992
I can do it.

1791
01:26:14,992 --> 01:26:15,949
This is a theory.

1792
01:26:15,949 --> 01:26:18,199
I'm not asking you
to implement this.

1793
01:26:18,199 --> 01:26:22,279
But this is enough for me,
as a reader of your decision, to

1794
01:26:22,279 --> 01:26:26,809
say: yes, you
know what you're talking about.

1795
01:26:26,809 --> 01:26:28,100
Okay,

1796
01:26:28,100 --> 01:26:30,050
how do you combine these things?

1797
01:26:30,050 --> 01:26:32,480
The thing is, I'm going to
need to...

1798
01:26:32,479 --> 01:26:38,799
I need to update these things
when I insert or remove a game.

1799
01:26:41,359 --> 01:26:47,599
So how do I know where these
receivers are in this thing?

1800
01:26:47,600 --> 01:26:50,690
I'm storing a pointer to
this data structure, right?

1801
01:26:50,689 --> 01:26:57,710
So, I keep
a pointer to where

1802
01:26:57,710 --> 01:26:59,568
it is in the data structure.

1803
01:26:59,568 --> 01:27:01,279
Again, I keep
all the receivers.

1804
01:27:01,279 --> 01:27:04,068
It's the same size
as data structure number 1

1805
01:27:04,068 --> 01:27:06,529
there, has the
same number of receivers.

1806
01:27:09,590 --> 01:27:13,220
But we're not done yet
, because I don't

1807
01:27:13,220 --> 01:27:21,350
want to know who has the
best result.

1808
01:27:21,350 --> 01:27:25,170
I want to know who has the kth
best performance.

1809
01:27:25,170 --> 01:27:27,409
ugh

1810
01:27:27,409 --> 01:27:30,449
How do I find the kth
best thing in this tree?

1811
01:27:30,449 --> 01:27:31,220
I have a tree.

1812
01:27:34,068 --> 01:27:35,029
Install the AVL tree.

1813
01:27:35,029 --> 01:27:37,130
This is reflected in productivity.

1814
01:27:37,130 --> 01:27:38,989
I know where the last one is.

1815
01:27:38,989 --> 01:27:41,389
But if I want to find the
kth from the end,

1816
01:27:41,390 --> 01:27:44,360
how do I do that?

1817
01:27:44,359 --> 01:27:45,889
This AVL tree is a

1818
01:27:45,890 --> 01:27:47,300
tuned AVL tree.

1819
01:27:47,300 --> 01:27:50,070
All I keep is the heights.

1820
01:27:50,068 --> 01:27:54,689
Is there any surgery
you've been thinking about?

1821
01:27:54,689 --> 01:27:58,789
AUDIENCE: [INAUDIBLE] you
don't keep the size of each one.

1822
01:27:58,789 --> 01:28:00,769
JASON KU: The
default AVL tree

1823
01:28:00,770 --> 01:28:02,300
doesn't preserve dimensions, right?

1824
01:28:02,300 --> 01:28:04,220
That's what consistency does.

1825
01:28:04,220 --> 01:28:08,369
But do you think that maybe it would be
useful in this situation?

1826
01:28:08,369 --> 01:28:08,869
So

1827
01:28:08,869 --> 01:28:12,500
, actually, if I decided to
also increase in size,

1828
01:28:12,500 --> 01:28:17,239
I could do exactly the same
find_at sequence operation,

1829
01:28:17,239 --> 01:28:22,670
and I could
find the n minus the kth element here,

1830
01:28:22,670 --> 01:28:28,190
using the same
function for the subtree that I

1831
01:28:28,189 --> 01:28:32,000
had in the
AVL sequence of the tree material.

1832
01:28:32,000 --> 01:28:33,920
In fact, in CLRS
they don't even

1833
01:28:33,920 --> 01:28:35,930
worry about AVL sequence trees.

1834
01:28:35,930 --> 01:28:39,710
They jump right to the fact that if I wanted
this rank search feature

1835
01:28:39,710 --> 01:28:44,180
in an ordered order of
things,

1836
01:28:44,180 --> 01:28:47,329
I could increase the
subtree sizes.

1837
01:28:47,329 --> 01:28:51,318
But it's actually a much more
useful general property,

1838
01:28:51,318 --> 01:28:54,500
so we decided to present it to
you in the context of

1839
01:28:54,500 --> 01:28:56,779
AVL sequence trees, because then I
can just reduce

1840
01:28:56,779 --> 01:28:58,519
to it when I get here.

1841
01:28:58,520 --> 01:29:01,130
So, this is a kind of
data structure framework

1842
01:29:01,130 --> 01:29:02,420
that works on this problem.

1843
01:29:02,420 --> 01:29:04,818
I leave it as an
exercise for you to perform

1844
01:29:04,818 --> 01:29:06,920
all these operations
for yourself,

1845
01:29:06,920 --> 01:29:08,789
or take a look at the solution.

1846
01:29:08,789 --> 01:29:13,460
The latter
will be posted online - the

1847
01:29:13,460 --> 01:29:15,140
solution.

1848
01:29:15,140 --> 01:29:16,500
This is quite difficult.

1849
01:29:16,500 --> 01:29:19,489
This is what is called - you can
think of increasing the size of

1850
01:29:19,489 --> 01:29:22,369
finding-rank as a
one-way range query.

1851
01:29:22,369 --> 01:29:27,409
Essentially, how many things
are to the right of this value?

1852
01:29:27,409 --> 01:29:29,779
What the last problem does is
it walks you

1853
01:29:29,779 --> 01:29:32,329
through a two-way
range query where

1854
01:29:32,329 --> 01:29:37,068
I want to know how many nodes are
between these two values.

1855
01:29:37,068 --> 01:29:39,148
So, this is a step-by-step guide.

1856
01:29:39,148 --> 01:29:39,648
Okay,

1857
01:29:39,648 --> 01:29:40,549
thank you.

1858
01:29:40,550 --> 01:29:42,100
AUDIENCE: Thank you.

