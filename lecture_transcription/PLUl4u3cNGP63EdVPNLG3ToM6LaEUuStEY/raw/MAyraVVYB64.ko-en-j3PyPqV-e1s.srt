1
00:00:00,000 --> 00:00:01,976
[삐걱거리는 소리]

2
00:00:01,976 --> 00:00:04,446
[바스락거리는 소리]

3
00:00:04,446 --> 00:00:06,422
[딸깍거리는 소리]

4
00:00:13,360 --> 00:00:17,970
제이슨 쿠:
네 번째 문제 해결 시간에 오신 것을 환영합니다.

5
00:00:17,970 --> 00:00:21,460

오늘은 주로 이진 트리에 대해 이야기해 보겠습니다.

6
00:00:21,460 --> 00:00:24,430


7
00:00:24,430 --> 00:00:27,650

다음 주 화요일까지는 다루지 않을 주제이지만, 다음 주 금요일까지 제출해야 하는

8
00:00:27,650 --> 00:00:32,710


9
00:00:32,710 --> 00:00:36,460
문제 세트 4에 아주 작은 부분으로 등장할 이진 힙에 대해 간단히 이야기해 보겠습니다
.

10
00:00:36,460 --> 00:00:40,660

오늘은 그 내용 중 일부를 간략하게 살펴보겠습니다.

11
00:00:40,660 --> 00:00:43,150
하지만 가장 우려스러운 점은

12
00:00:43,150 --> 00:00:48,880

오늘 다룰 내용이 주로 이진 트리,

13
00:00:48,880 --> 00:00:52,450
특히 드메인 교수가 이번 주 초에 설명했듯이
집합 데이터 구조

14
00:00:52,450 --> 00:00:57,400
와 순차 데이터 구조에 적용되는 내용이라는 것입니다

15
00:00:57,400 --> 00:01:01,340
.

16
00:01:01,340 --> 00:01:06,100
하지만 지금은, 아니 정확히는
어제까지, 우리가 앞으로 다룰

17
00:01:06,100 --> 00:01:08,410
모든 데이터 구조, 즉

18
00:01:10,090 --> 00:01:13,180
set
인터페이스와 sequence

19
00:01:13,180 --> 00:01:14,470
인터페이스를 구현하는 데이터 구조들을 모두 살펴보았습니다.  드메인

20
00:01:14,470 --> 00:01:21,160
교수님께서 보여드렸던 그 멋진 테이블들이

21
00:01:21,160 --> 00:01:22,960
이제 완성되었습니다.

22
00:01:22,960 --> 00:01:25,210
저희는

23
00:01:25,210 --> 00:01:28,930

몇몇 연산에 대해 상수 시간 연산을 수행하는 매우 우수한 데이터 구조를 가지고 있습니다.

24
00:01:28,930 --> 00:01:32,740
그래서 우리는 그것들을
특정 용도로 사용할 수도 있습니다.

25
00:01:32,740 --> 00:01:36,520
이번 주에는 트리 구조에 대해
설명드렸는데요

26
00:01:36,520 --> 00:01:40,150
, 이 구조는

27
00:01:40,150 --> 00:01:43,660

제 데이터셋이나 시퀀스에 대한 모든 유형의 쿼리 연산에서 상당히

28
00:01:44,980 --> 00:01:48,320
좋은 성능을 보여줍니다
. 여기서 '꽤 좋다'는 것은 로그 시간 복잡도를 의미하며, 상수 시간 복잡도에 완전히 근접하지는 않는다는 뜻입니다.

29
00:01:48,320 --> 00:01:51,895
하지만 우리의 목적상, log n은—

30
00:01:51,895 --> 00:01:54,580
즉,
컴퓨터에서 실제로—

31
00:01:54,580 --> 00:01:56,890
점근적으로가 아니라
실질적으로—컴퓨터에서 log

32
00:01:56,890 --> 00:02:00,430
n은 최대
얼마가 될까요?

33
00:02:03,520 --> 00:02:07,030
64 정도였던가요?  기계어의 관점에서 보면, 연산에

34
00:02:07,030 --> 00:02:11,620
사용하는 모든 입력값이 바로

35
00:02:11,620 --> 00:02:14,000
입력값입니다.

36
00:02:14,000 --> 00:02:16,000


37
00:02:16,000 --> 00:02:18,550
입력에 포함된 모든 기계어 단어를 처리할 수 있어야 합니다.

38
00:02:18,550 --> 00:02:22,840
컴퓨터에서
머신 워드 주소의 크기는

39
00:02:22,840 --> 00:02:25,030
64비트죠, 그렇죠?

40
00:02:25,030 --> 00:02:27,760
그리고 우리는
단어 크기가

41
00:02:27,760 --> 00:02:33,700
입력 크기의 로그값 이상이어야
입력에 접근할 수 있다고 가정합니다.

42
00:02:33,700 --> 00:02:37,060
따라서
여러분의 컴퓨터에서

43
00:02:37,060 --> 00:02:39,100
log n은
최대 64가 될 것이며, 이는

44
00:02:39,100 --> 00:02:42,460

대략 50배의 오버헤드가 발생한다는 의미입니다. 작업량이

45
00:02:42,460 --> 00:02:45,670
적은 경우에는

46
00:02:45,670 --> 00:02:49,300
1,000개의 항목을 처리한다고 가정했을 때 10배 정도의 오버헤드가 발생할 수 있습니다
.  그렇게

47
00:02:49,300 --> 00:02:50,620
나쁘진 않죠, 그렇죠?

48
00:02:50,620 --> 00:02:53,740

이론적인 목적에서는 상수 인자가 아니지만

49
00:02:53,740 --> 00:02:57,970
, 여러분의 목적상
log n은

50
00:02:57,970 --> 00:02:59,980
다항식 인자(

51
00:02:59,980 --> 00:03:03,250
n의 또 다른 인자)보다 훨씬 더 적절합니다.

52
00:03:03,250 --> 00:03:05,800
당신은 모든 코드를 다 봤습니다.

53
00:03:05,800 --> 00:03:08,950
여러분은
이러한 집합 및 순서

54
00:03:08,950 --> 00:03:10,300
인터페이스의 구현 사례들을 모두 보셨을 겁니다, 그렇죠?

55
00:03:10,300 --> 00:03:12,550
그래서 저는

56
00:03:12,550 --> 00:03:15,490

여러분의 강의 노트에 있는

57
00:03:15,490 --> 00:03:18,610
모든
인터페이스 구현 코드를 모아서 조금 작성해 봤습니다.

58
00:03:18,610 --> 00:03:22,720
그래서 제가 한 일은,

59
00:03:22,720 --> 00:03:25,960
그것들이
실제 컴퓨터에서 어떻게 작동하는지 확인하기 위해 간단한 테스트 프로그램을 작성하는 것이었습니다.

60
00:03:25,960 --> 00:03:30,340
여기에 간단한 테스트 코드가 있습니다.

61
00:03:30,340 --> 00:03:35,410
저는 시퀀스를
구현하는 배열

62
00:03:35,410 --> 00:03:37,270
, 시퀀스를
구현하는 이진 트리

63
00:03:37,270 --> 00:03:39,400
, 시퀀스를 구현하는 동적
배열 등

64
00:03:39,400 --> 00:03:41,170
이러한 모든 종류의 구현체를 나열한 작은 폴더를 가지고 있습니다.

65
00:03:41,170 --> 00:03:45,250
그다음에는 설정을 합니다. 정렬된 배열은
이진 트리의 집합이고,

66
00:03:45,250 --> 00:03:46,600
해시 테이블도 마찬가지입니다.

67
00:03:46,600 --> 00:03:48,010
이것이 저희의 구현 방식입니다.

68
00:03:48,010 --> 00:03:50,710
저는 파이썬
딕셔너리를 해시 테이블로 사용하지 않고,

69
00:03:50,710 --> 00:03:55,330

강의 자료에 나와 있는 구현체를 사용하고 있습니다.

70
00:03:55,330 --> 00:03:56,980
그리고 이제 각 객체를 해제하는
간단한

71
00:03:56,980 --> 00:03:59,440
효율성 테스트 파이썬 코드를 실행하겠습니다

72
00:03:59,440 --> 00:04:00,550
.  이 프로그램은

73
00:04:00,550 --> 00:04:03,370

여러 가지 작업을 수행

74
00:04:03,370 --> 00:04:05,650
하고
소요 시간을 측정할 것입니다.

75
00:04:05,650 --> 00:04:07,720
저는 단지
소요 시간을 기록하고 있을 뿐입니다.

76
00:04:07,720 --> 00:04:11,380
점근적 분석은 아니지만,

77
00:04:11,380 --> 00:04:13,330
어느 정도 분리되는 모습을 볼 수 있기를 바랍니다.  그 버튼을

78
00:04:13,330 --> 00:04:16,390
누르면
여러 가지 테스트가 실행됩니다.  한번 살펴볼까요?

79
00:04:19,269 --> 00:04:20,620
좋아요.

80
00:04:20,620 --> 00:04:23,660

순차 연산 작업이 여러 개 있어요.

81
00:04:23,660 --> 00:04:28,150
빌드, 설정,
가져오기, 삽입, 삭제 등의 기능이

82
00:04:28,150 --> 00:04:30,880
여러 곳에 있습니다.

83
00:04:30,880 --> 00:04:36,250
그리고 이것들은

84
00:04:36,250 --> 00:04:39,610
제가
이러한 데이터 구조에 대해 가지고 있던 특정 규모, 즉 특정 해상도에서의 실제 시간 측정 결과입니다.

85
00:04:39,610 --> 00:04:41,680
그리고 보시다시피

86
00:04:41,680 --> 00:04:44,170
,
이 컴퓨터에서 빌드를 실행하면,

87
00:04:44,170 --> 00:04:46,270
단순히
배열을 할당하고 비우는 것만으로도 파이썬이

88
00:04:46,270 --> 00:04:49,850
매우 효율적으로 처리해 줍니다
.

89
00:04:49,850 --> 00:04:54,520
그래서 사실 그것은
log n으로 잘못 표기된 것입니다.

90
00:04:54,520 --> 00:04:57,970
하지만
get_at과 set_at 같은 다른 것들은

91
00:04:57,970 --> 00:04:59,680
정말, 정말 빠르죠, 그렇죠?

92
00:04:59,680 --> 00:05:00,910
그건 일정한 시간이에요.

93
00:05:00,910 --> 00:05:02,800
그리고 나머지 부분들은
제가 할 수 있는

94
00:05:02,800 --> 00:05:05,020
최선의 방법이 없어서 그냥 반복문을 사용하는 수밖에 없는데
,

95
00:05:05,020 --> 00:05:06,730
그래서 시간이 선형적으로 걸립니다.

96
00:05:06,730 --> 00:05:11,500
그리고 다시 말하지만, 순서 관련해서 `
setting_at`과 `getting_at`은

97
00:05:11,500 --> 00:05:15,250
느리지만,
첫 번째 항목에서 삭제하고 제거하는 것은 포인터를

98
00:05:15,250 --> 00:05:17,800
다시 연결하는 것일 뿐이죠
, 그렇죠?

99
00:05:17,800 --> 00:05:18,910
동적 배열.

100
00:05:18,910 --> 00:05:23,440
다시 말하지만, set_at과 get_at은

101
00:05:23,440 --> 00:05:24,670
일반 배열을 다루기 때문에 빠릅니다.

102
00:05:24,670 --> 00:05:27,340
그리고
마지막에 삽입하고 삭제하는 것은

103
00:05:27,340 --> 00:05:30,010

사실상 일정한 시간을 유지하는 것과 같습니다.

104
00:05:30,010 --> 00:05:32,680
사실 저는 평균값을
다루기 위해 이러한 테스트를 실행할 때,

105
00:05:32,680 --> 00:05:34,180


106
00:05:34,180 --> 00:05:36,980
여러 번 실행하면서
성능을 테스트합니다.

107
00:05:36,980 --> 00:05:41,500
그러니까
최악의 상황은 여기서 발생하지 않을 것 같네요, 그렇죠?

108
00:05:41,500 --> 00:05:43,420
저는 모든 항목에 대해 평균을 내고 있는데
, 이것이

109
00:05:43,420 --> 00:05:46,630
바로
감가상각의 의미입니다.

110
00:05:46,630 --> 00:05:50,560
그래서
여기서 좋은 성능을 얻고 있는 겁니다.

111
00:05:50,560 --> 00:05:51,940
해시 테이블.

112
00:05:51,940 --> 00:05:56,710
다시 말하지만,
아, 이게 바로 지난주

113
00:05:56,710 --> 00:05:59,320

문제 풀이 시간에 다뤘던 내용이군요.

114
00:05:59,320 --> 00:06:04,180


115
00:06:04,180 --> 00:06:06,070
해시 테이블을 이용한 양방향 큐 구현에 대해서요.

116
00:06:06,070 --> 00:06:07,450
이것이 바로 그 구현 방식입니다.  그냥

117
00:06:07,450 --> 00:06:09,130
당신에게 보여주고 싶었어요.

118
00:06:09,130 --> 00:06:10,460
하지만 사실 꽤 괜찮아요.

119
00:06:10,460 --> 00:06:14,080
이것이 자바스크립트가
배열에 사용하는 방식입니다.

120
00:06:14,080 --> 00:06:19,240
그리고 이진 시퀀스는
이진 트리, 즉

121
00:06:19,240 --> 00:06:20,550
균형 이진 트리로 표현됩니다.

122
00:06:20,550 --> 00:06:22,480
이것은 제가 가지고 있던 AVL 코드입니다.

123
00:06:22,480 --> 00:06:25,720
다른 모든 기능들은

124
00:06:25,720 --> 00:06:28,338
insert_at과
delete_at 작업에서 상당히 부실한 성능을 보였지만, 이 기능은

125
00:06:28,338 --> 00:06:30,130

다른 기능들과 비슷한 수준의 성능을 보여줍니다.

126
00:06:30,130 --> 00:06:34,060
보시다시피 이것들은

127
00:06:34,060 --> 00:06:39,230
다른 것들보다 기계 작동 주기가 조금 더 길지만,
사실 그렇게 나쁘지는 않습니다.

128
00:06:39,230 --> 00:06:41,710
그리고
집합 측면에서도

129
00:06:41,710 --> 00:06:44,420
마찬가지로 정렬된 배열이 있었습니다.

130
00:06:44,420 --> 00:06:46,840
죄송합니다. 이것은
배열에서 가져온 집합입니다.

131
00:06:46,840 --> 00:06:48,970
기본적으로
정렬되지 않은 배열입니다.

132
00:06:48,970 --> 00:06:52,480
저는 모든
것을 찾고 있어요. 정말 힘든 시기네요.

133
00:06:52,480 --> 00:06:54,970
정렬된 배열은 이러한
검색 작업에서는 매우 훌륭

134
00:06:54,970 --> 00:06:58,040
하지만, 삽입 및
삭제 작업에서는 성능이 떨어집니다.

135
00:06:58,040 --> 00:07:00,820
그래서 이진 트리가 필요한 겁니다.

136
00:07:00,820 --> 00:07:05,080
해시 테이블은 사전
연산에는 뛰어나지만,

137
00:07:05,080 --> 00:07:08,410
순서 정렬 연산에는 매우 취약합니다.

138
00:07:08,410 --> 00:07:13,990
그리고 이진 탐색
트리, 즉 집합 이진 트리는 이 모든 면

139
00:07:13,990 --> 00:07:16,490
에서 상당히 좋은 성능을 보여줍니다
.

140
00:07:16,490 --> 00:07:20,450
사실,
상당히 좋아지고 있어요.

141
00:07:20,450 --> 00:07:22,300

무슨 이유인지 모르겠지만,

142
00:07:22,300 --> 00:07:26,200
정렬된 배열보다도 더 좋아지고 있네요.

143
00:07:26,200 --> 00:07:27,730
이유는 모르겠어요.

144
00:07:27,730 --> 00:07:30,220
저희 구현 방식은
전혀 최적화되어 있지 않습니다.

145
00:07:30,220 --> 00:07:31,890
하지만 점근
적으로는 상당히 잘 작동합니다.

146
00:07:31,890 --> 00:07:32,160
응?

147
00:07:32,160 --> 00:07:33,535
청중:

148
00:07:33,535 --> 00:07:38,470
첫 번째 데이터
저장소 [알아들을 수 없는 부분] log n이 왜 그렇게 되는지 다시 한번 설명해 주시겠어요?

149
00:07:38,470 --> 00:07:41,830
제이슨 쿠: 이건 단순히
시간대를 기준으로 분류한 겁니다.  아마도

150
00:07:41,830 --> 00:07:43,930


151
00:07:43,930 --> 00:07:47,200
파이썬 내부에는
이 메모리를 할당하는 C 언어의 내장 함수가 있어서

152
00:07:47,200 --> 00:07:49,060
매우 빠르게 처리하는 것 같습니다.

153
00:07:49,060 --> 00:07:51,460
제 프로그램은
이러한 수치를 보고 점근

154
00:07:51,460 --> 00:07:54,350

적 실행 시간을 예측하려고 하는데,

155
00:07:54,350 --> 00:07:57,590
이것들은 단지
이러한 요소들, 즉 범위에 기반한 레이블일 뿐입니다.  제 생각에는…

156
00:07:57,590 --> 00:07:59,113
오해인 것 같아요.

157
00:07:59,113 --> 00:08:01,605
관객: [잘 안 들림]

158
00:08:01,605 --> 00:08:02,230
제이슨 쿠: 네.

159
00:08:02,230 --> 00:08:06,940
음, 사실
만약 이게 C 코드였다면, 그러니까

160
00:08:06,940 --> 00:08:09,730
이 모든 게
C로 작성되었다면, 아마도 막대

161
00:08:09,730 --> 00:08:12,820
그래프가 더 길어졌을 겁니다. 왜냐하면
실제로

162
00:08:12,820 --> 00:08:15,370

모든 메모리 영역을 탐색하고 접근해야 하기 때문이죠.

163
00:08:15,370 --> 00:08:18,250
여기서도 여전히 그런 현상이 나타나지만,
파이썬 관련 부분은 전부

164
00:08:18,250 --> 00:08:19,810
엉망입니다.

165
00:08:19,810 --> 00:08:23,110

C 언어가 하는 어떤 것보다 100배는 느린 것 같아요.

166
00:08:23,110 --> 00:08:26,730
그래서
그러한 격차가 나타나는 것입니다.

167
00:08:26,730 --> 00:08:27,920
이해가 되시나요?

168
00:08:27,920 --> 00:08:28,420
좋아요.

169
00:08:28,420 --> 00:08:30,610
그냥 그걸 보여드리고 싶었어요.  나중에 여러분이 직접 사용해 볼 수 있도록

170
00:08:30,610 --> 00:08:33,850
공개할 수도 있지만, 일단

171
00:08:33,850 --> 00:08:36,309

맛보기로 보여드리고 싶었습니다.

172
00:08:36,309 --> 00:08:41,010
네, 다음으로
넘어가기 전에 질문 있으신가요?

173
00:08:41,010 --> 00:08:42,879
어떻게 하면 이 기능을 끌 수 있나요?  위로 올라가서

174
00:08:42,879 --> 00:08:46,960
, 출발.  종료

175
00:08:46,960 --> 00:08:47,680
하세요.

176
00:08:51,750 --> 00:08:52,780
예.

177
00:08:52,780 --> 00:08:53,280
좋아요.  이제

178
00:08:58,440 --> 00:09:02,640
문제
풀이로 넘어가 보겠습니다.

179
00:09:02,640 --> 00:09:04,660

여기에는 당신이 해결해야 할 몇 가지 문제가 있습니다.

180
00:09:04,660 --> 00:09:09,483
첫 번째로,
시퀀스 AVL 트리를 살펴보겠습니다.

181
00:09:09,483 --> 00:09:10,650
이것은 시퀀스 AVL 트리입니다.  제가

182
00:09:10,650 --> 00:09:11,442
그걸 어떻게 알까요?  꼭 그럴 필요는

183
00:09:15,200 --> 00:09:16,760
없습니다.

184
00:09:16,760 --> 00:09:19,460
하지만 이것들은

185
00:09:19,460 --> 00:09:23,450

제가 보관하는 물건들 순서대로 정리되어 있는 건 절대 아니잖아요, 그렇죠?

186
00:09:23,450 --> 00:09:26,420
그러니
AVL 트리가 고정되어 있으면 안 될 텐데.

187
00:09:26,420 --> 00:09:27,530
AVL 트리인가요?

188
00:09:27,530 --> 00:09:30,510

높이 균형이 잘 잡혀 있나요?

189
00:09:30,510 --> 00:09:32,220
네, 기본적으로 그렇습니다.

190
00:09:32,220 --> 00:09:36,810
실제로
각 서브트리의 크기를 계산해 보면, 이 모든 것의

191
00:09:36,810 --> 00:09:39,120
왼쪽 서브트리와 오른쪽 서브트리가

192
00:09:39,120 --> 00:09:41,400

균형을 이루고 있다는 것을 직접 확인할 수 있습니다.  두 값은

193
00:09:41,400 --> 00:09:43,950

±1 오차 범위 내에 있습니다.

194
00:09:43,950 --> 00:09:46,500
사실, 이 정도

195
00:09:46,500 --> 00:09:50,550

노드 수를 가진 시스템에서

196
00:09:50,550 --> 00:09:52,600

높이 균형(

197
00:09:52,600 --> 00:09:54,720
AVL 속성)을 유지하면서 균형에서 최대한 벗어난 상태를 보여주는

198
00:09:54,720 --> 00:09:56,040
예시이기 때문에, 이는 매우 유익한 사례입니다.  거의

199
00:09:56,040 --> 00:09:58,740
한계에 다다른 것 같아요.

200
00:09:58,740 --> 00:10:02,370
그럼 난 어떻게 해야 하지?

201
00:10:02,370 --> 00:10:04,980

만약 제가

202
00:10:04,980 --> 00:10:08,790
이것이 순차적 AVL 트리라고 주장한다면, 이 그림에서 빠진 것은 무엇일까요?

203
00:10:08,790 --> 00:10:11,850
무엇이 빠진 건지 아시는 분 계신가요?  이 그림에 나타나지 않은 내용 중

204
00:10:11,850 --> 00:10:14,700
시퀀스 AVL
트리에 저장되는 정보는 무엇인가요

205
00:10:14,700 --> 00:10:16,360
?

206
00:10:16,360 --> 00:10:17,190
관객 수: 카운트됩니다.

207
00:10:17,190 --> 00:10:17,490
제이슨 쿠: 뭐라고요?

208
00:10:17,490 --> 00:10:18,282
관객 수: 카운트됩니다.

209
00:10:18,282 --> 00:10:18,990
제이슨 쿠: 네, 맞아요.

210
00:10:18,990 --> 00:10:19,490
그리고?

211
00:10:22,520 --> 00:10:25,360
이것은 시퀀스 AVL 트리입니다.

212
00:10:25,360 --> 00:10:27,320
높은 곳이죠, 그렇죠?

213
00:10:27,320 --> 00:10:29,470
시퀀스 AVL 트리는
세트 AVL 트리와 달리 두 가지 요소

214
00:10:29,470 --> 00:10:31,000
로 확장되는 거죠
?  회전하는

215
00:10:31,000 --> 00:10:34,690

동안 균형을 유지해야 하기 때문에

216
00:10:34,690 --> 00:10:36,910

높이를 저장해야 합니다.  나무 위로 올라가서 수리하는 동안,

217
00:10:36,910 --> 00:10:39,490

이 작은 나무들의 높이를

218
00:10:39,490 --> 00:10:41,440
지속적으로 파악할 수 있어야 합니다

219
00:10:41,440 --> 00:10:43,090
.

220
00:10:43,090 --> 00:10:47,440
그리고 그 순서 때문에 저는 거기에
서브트리 번호를 저장해야 합니다

221
00:10:47,440 --> 00:10:50,200
.

222
00:10:50,200 --> 00:10:52,030
글쎄요, 모든 항목에
그림을 그릴 생각은 없지만,

223
00:10:52,030 --> 00:10:55,270

4번은 어때요?

224
00:10:55,270 --> 00:10:56,050
높이가 얼마나 되나요?

225
00:10:59,670 --> 00:11:00,840
1, 2, 3.

226
00:11:00,840 --> 00:11:05,200
이것이
해당 루트 서브트리에서 가장 긴 경로입니다.

227
00:11:05,200 --> 00:11:09,210
그러니까 이건 높이가 3이라는 뜻이에요. 이건

228
00:11:09,210 --> 00:11:13,900
높이가
2일 때와 높이가 1일 때에서 나온 거죠.

229
00:11:13,900 --> 00:11:15,000
다들 이해되시나요?

230
00:11:15,000 --> 00:11:15,690
응?

231
00:11:15,690 --> 00:11:18,390
그럼
여기 크기는 얼마나 되나요?

232
00:11:18,390 --> 00:11:22,440
1, 2, 3, 4, 5, 6, 7입니다.

233
00:11:22,440 --> 00:11:27,060

여기에 크기를 7로 입력하겠습니다.

234
00:11:27,060 --> 00:11:31,770
그리고
이 숫자는 1, 2, 3, 4입니다.

235
00:11:31,770 --> 00:11:33,105
이 숫자는 2입니다.

236
00:11:36,300 --> 00:11:39,700
그렇다면
서브트리의 크기는 어떻게 계산하나요?

237
00:11:39,700 --> 00:11:43,830
왼쪽 서브트리 크기에
오른쪽 서브트리 크기를 더한 값에 1을 더한 값입니다.

238
00:11:43,830 --> 00:11:47,100
높이는 이
두 값 중 최댓값에 1을 더한 값입니다.

239
00:11:47,100 --> 00:11:47,600
알겠습니다.

240
00:11:47,600 --> 00:11:50,280
그래서 우리는 어제 그 모든 일을 했습니다.

241
00:11:50,280 --> 00:11:52,860
저는 단지 이것들에 이름을 붙이는 것뿐입니다.

242
00:11:52,860 --> 00:11:59,730
제가 여러분께 요청드리는 것은
삭제 작업을 수행해 달라는 것입니다.

243
00:11:59,730 --> 00:12:02,250
이것은 순서 트리입니다.

244
00:12:02,250 --> 00:12:06,190
그래서 저는
트리의 인덱스를 이용해서 항목을 찾고 있습니다.

245
00:12:06,190 --> 00:12:08,790
그래서

246
00:12:08,790 --> 00:12:10,980
제 순서에서 여덟 번째 항목을 삭제해 주시길 부탁드립니다.

247
00:12:10,980 --> 00:12:14,770

내 순서에서 여덟 번째는 무엇인가요?

248
00:12:14,770 --> 00:12:15,370
응?

249
00:12:15,370 --> 00:12:17,890
청중: 명확히 말씀드리자면,
delete-8은 숫자를 삭제하는 것이 아닙니다

250
00:12:17,890 --> 00:12:18,520
.

251
00:12:18,520 --> 00:12:19,270
제이슨 쿠: 맞습니다.

252
00:12:19,270 --> 00:12:21,360
음, delete_at 8.

253
00:12:21,360 --> 00:12:22,237
보이시나요?

254
00:12:22,237 --> 00:12:23,320
이것은 순차적인 작업입니다.

255
00:12:23,320 --> 00:12:23,650
청중: 아, 알겠습니다.

256
00:12:23,650 --> 00:12:24,195
[잘 안 들림]

257
00:12:24,195 --> 00:12:24,820
제이슨 쿠: 네.

258
00:12:24,820 --> 00:12:27,160
따라서

259
00:12:27,160 --> 00:12:30,340

순차적 의미론과 집합적 의미론을 구분하는 것이 매우 중요합니다.  시퀀스를

260
00:12:30,340 --> 00:12:32,140
다룰 때는

261
00:12:32,140 --> 00:12:35,440


262
00:12:35,440 --> 00:12:38,390
이 데이터 구조의 내재적인 속성을 찾아보지 않는 게 좋습니다. 왜냐하면 이
데이터 구조 자체가 내재적인 속성이 있는 구조가 아니기 때문입니다

263
00:12:38,390 --> 00:12:38,890
.

264
00:12:38,890 --> 00:12:39,910
그것은 그것을 뒷받침하지 않습니다.

265
00:12:39,910 --> 00:12:46,870
만약 제가 예를 들어
키 8의 인덱스를 찾는 것과 같은 기능을 지원하고 싶다면,

266
00:12:46,870 --> 00:12:50,410

제가 할 수 있는 일은

267
00:12:50,410 --> 00:12:51,993
배열과 비슷하게 작동하는 방식입니다.

268
00:12:51,993 --> 00:12:54,160

전체 시퀀스를 반복해서

269
00:12:54,160 --> 00:12:56,290

그 안에 해당 항목이 있는지 확인하면 될 것 같습니다.

270
00:12:56,290 --> 00:12:58,165

선형 시간보다 더 나은 방법은 딱히 없죠.

271
00:12:58,165 --> 00:13:00,040
이 데이터 구조는
그러한 용도로 설계되지 않았습니다.  이

272
00:13:00,040 --> 00:13:01,040
제품은 무엇을 위해 설계되었습니까?  이 프로그램은 순서도에서 인덱스를 이용하여

273
00:13:01,040 --> 00:13:05,140
항목을 찾도록 설계되었습니다
.

274
00:13:05,140 --> 00:13:12,130
그렇다면 8번째 인덱스는 어떻게 찾나요?

275
00:13:12,130 --> 00:13:14,110
음, 그러니까 저는
트리를 보고 있고, 중위 순회로 따라가면서

276
00:13:14,110 --> 00:13:17,140
셀 수 있다는 거죠
.

277
00:13:17,140 --> 00:13:19,990
중위 순회란 무엇인가요?

278
00:13:19,990 --> 00:13:24,850
0, 1, 2, 3, 4, 5, 6, 7.

279
00:13:24,850 --> 00:13:26,530
좋아요, 8을 찾았습니다.

280
00:13:26,530 --> 00:13:29,470
그런데
시퀀스 AVL 트리는 무슨 역할을 하나요?

281
00:13:32,620 --> 00:13:34,990
서브트리 크기를 저장하고 있는데
, 지금 이 위치에서는

282
00:13:34,990 --> 00:13:38,110
어떤 인덱스에 있는지 모르겠습니다.

283
00:13:38,110 --> 00:13:40,900

루트 디렉토리에서 현재 인덱스가 몇인지 어떻게 알 수 있나요?

284
00:13:40,900 --> 00:13:44,980
왼쪽 서브트리를 살펴보고
몇 개인지 확인합니다.

285
00:13:44,980 --> 00:13:47,990
여기에는 일곱 가지 물건이 있습니다.

286
00:13:47,990 --> 00:13:52,910
1, 2, 3, 4, 5, 6, 7.

287
00:13:52,910 --> 00:13:53,410
네.

288
00:13:53,410 --> 00:13:57,280
저는
인덱스 8번으로 9번째 항목을 찾고 있기 때문입니다.

289
00:13:57,280 --> 00:14:01,060
이것은
제가 8번째 항목이라는 것을 의미합니다.

290
00:14:01,060 --> 00:14:03,485
저는 인덱스 7에 있는 사람입니다. 이해되시나요

291
00:14:03,485 --> 00:14:04,360
?

292
00:14:04,360 --> 00:14:07,310
제가
여기서 서브트리의 크기를 보고 있기 때문입니다.

293
00:14:07,310 --> 00:14:08,930
그래서 내가 뭘 알겠어?

294
00:14:08,930 --> 00:14:13,240
제가
찾고 있는 색인이 오른쪽에 있다는 것을 알고 있습니다.

295
00:14:13,240 --> 00:14:17,350
제가 이쪽으로 내려가서 우연히
알게 된 건데,

296
00:14:17,350 --> 00:14:23,470

이 서브트리에서 어떤 인덱스를 찾아야 할까요?

297
00:14:23,470 --> 00:14:25,090
0이죠, 맞죠?

298
00:14:25,090 --> 00:14:27,490

서브트리에서 첫 번째 항목을 원합니다.

299
00:14:27,490 --> 00:14:32,380

제가

300
00:14:32,380 --> 00:14:35,740
그 여덟 가지 항목을 모두 처리했기 때문에 검색 색인이 변경되었습니다.

301
00:14:35,740 --> 00:14:38,990
여기서 저는
인덱스에서 0번째 항목을 찾고 있습니다.

302
00:14:38,990 --> 00:14:40,290
왼쪽을 보면,

303
00:14:40,290 --> 00:14:43,930
만약 왼쪽 서브트리가 없었다면
저는 0번째 항목이 되었을 것이고,

304
00:14:43,930 --> 00:14:45,010
저 자신을 반환했을 것입니다.

305
00:14:45,010 --> 00:14:46,330
하지만 여기 안에는 뭔가가 있어요.

306
00:14:46,330 --> 00:14:51,850
그래서 저는 여기서 0번째 항목
, 즉 그 사람 자체를 찾아서

307
00:14:51,850 --> 00:14:53,560
돌려주는 겁니다.

308
00:14:53,560 --> 00:14:56,890
사실 제가
하고 있는 건 그걸 삭제하는 거예요.

309
00:14:56,890 --> 00:15:00,190
그래서 삭제했어요.

310
00:15:00,190 --> 00:15:02,610
왝.

311
00:15:02,610 --> 00:15:05,382
여기서 문제점은 무엇인가요?

312
00:15:05,382 --> 00:15:06,260
관객: [잘 안 들림]

313
00:15:06,260 --> 00:15:07,920
제이슨 쿠: 키 균형이 안 맞네.

314
00:15:07,920 --> 00:15:10,610
여기서 높이 균형이 안 맞는 부분은 무엇인가요?

315
00:15:10,610 --> 00:15:12,510
청중: 왼쪽 하위 트리는...

316
00:15:12,510 --> 00:15:13,150
아니, 죄송합니다.

317
00:15:13,150 --> 00:15:13,830
[알아들을 수 없는 말]

318
00:15:13,830 --> 00:15:15,280
제이슨 쿠: 이 사람
키 균형이 안 맞는 것 같네, 그렇지?

319
00:15:15,280 --> 00:15:17,100
청중: --
오른쪽 [잘 안 들림]의 오른쪽 서브트리..

320
00:15:17,100 --> 00:15:19,558
제이슨 쿠: 이 사람 서브트리는
높이 균형이 안 맞죠?

321
00:15:19,558 --> 00:15:20,250
이 사람은 2살이고,

322
00:15:20,250 --> 00:15:22,380
이 사람은 1살이에요.

323
00:15:22,380 --> 00:15:24,300
그럼 어떻게 해결해야 할까요?

324
00:15:24,300 --> 00:15:25,740
관객: 회전하세요.

325
00:15:25,740 --> 00:15:27,690
제이슨 쿠: 저희는 교대 근무를 합니다.

326
00:15:27,690 --> 00:15:30,470
이것이 바로 어제 이야기했던

327
00:15:30,470 --> 00:15:33,570
세 번째 최악의 사례입니다
.

328
00:15:33,570 --> 00:15:37,260

이 캐릭터를 왼쪽으로만 회전시키면

329
00:15:37,260 --> 00:15:38,540
어떤 모습일까요?

330
00:15:38,540 --> 00:15:40,740
그러면 여기에 12가 놓이게 될 겁니다.

331
00:15:40,740 --> 00:15:42,240
그러면 여기에 10이 들어갈 겁니다.

332
00:15:42,240 --> 00:15:45,360
그리고 8이 거기에 붙을 것입니다.

333
00:15:45,360 --> 00:15:48,090
지금은 높이 균형이
반대 방향으로 틀어졌죠, 그렇죠?

334
00:15:48,090 --> 00:15:49,950
그건 안 좋아.

335
00:15:49,950 --> 00:15:53,490
따라서 전체 트리가

336
00:15:53,490 --> 00:15:59,100
오른쪽으로 심하게 치우쳐 있는데
오른쪽 하위 트리는

337
00:15:59,100 --> 00:16:03,900
왼쪽으로 치우쳐 있는 경우를 처리하려면
먼저

338
00:16:03,900 --> 00:16:06,810
오른쪽으로 회전한
다음 다시 회전해야 합니다.

339
00:16:06,810 --> 00:16:08,880
그게 바로 공식이에요.

340
00:16:08,880 --> 00:16:10,920
여기서 먼저 10도를 기준으로
오른쪽으로 회전시키면

341
00:16:10,920 --> 00:16:21,440

8, 10처럼 보이는 결과가 나옵니다.

342
00:16:21,440 --> 00:16:25,150
물론 이것은
이전보다 나은 것은 아니지만, 문제를

343
00:16:25,150 --> 00:16:28,750

해결하기 위한 중간 단계입니다.

344
00:16:28,750 --> 00:16:32,050
여기서 오른쪽으로 회전하고,
여기서 왼쪽으로 회전합니다.

345
00:16:32,050 --> 00:16:34,290
기본적으로는
왼쪽으로 회전시키지만,

346
00:16:34,290 --> 00:16:38,440
이 이미지는
기울기가 잘못된 방향이기 때문에 먼저

347
00:16:38,440 --> 00:16:41,390
오른쪽으로 회전시킨
다음 작업해야 합니다.  자,

348
00:16:41,390 --> 00:16:43,570
이제
이 녀석들을 모두 돌려서

349
00:16:43,570 --> 00:16:50,005

여기에 12개, 여기에 8개, 여기에 10개를 놓습니다.  회전이 이런 모습이라는 걸

350
00:16:53,010 --> 00:16:56,700
모두 알겠어요
?

351
00:16:56,700 --> 00:16:57,230
좋아요.  변화가 무엇인지 이해하는 데는

352
00:16:57,230 --> 00:17:00,210
시간이 좀 걸리겠지만,

353
00:17:00,210 --> 00:17:02,970

여러분 모두

354
00:17:02,970 --> 00:17:04,283
그 변화 과정을 잘 따라오셨기를 바랍니다.

355
00:17:04,283 --> 00:17:06,450

그림을 그리는 동안 작은 마법 같은 일이 일어났어요.

356
00:17:06,450 --> 00:17:06,930
응?

357
00:17:06,930 --> 00:17:08,500
청중: 저는 여전히
이 나무의

358
00:17:08,500 --> 00:17:09,270
높이 균형이 맞지 않는다고 생각해요.

359
00:17:09,270 --> 00:17:10,980
제이슨 쿠: 그렇지 않아요.

360
00:17:10,980 --> 00:17:12,630
훌륭한 관찰입니다.

361
00:17:12,630 --> 00:17:13,890
왜 그런가요?

362
00:17:13,890 --> 00:17:15,750
이 물체의 높이는 여전히 3입니다.

363
00:17:15,750 --> 00:17:17,550

이 물체의 높이는 얼마입니까?

364
00:17:17,550 --> 00:17:19,020
1번 맞죠?

365
00:17:19,020 --> 00:17:20,700
이게 높이 1입니다.

366
00:17:20,700 --> 00:17:23,400
그리고 사실, 제가
그 회전 작업을 할 때 이

367
00:17:23,400 --> 00:17:27,318
모든 증강 현실을 업데이트해야 했습니다
.

368
00:17:27,318 --> 00:17:28,860

내가 정말로 필요로 했던 확장 기능은 무엇이었을까요? 그리고 그 과정에서

369
00:17:28,860 --> 00:17:31,620
어떤 하위 트리가
변경되었을까요?  그게

370
00:17:36,380 --> 00:17:38,810
어떻게 생겼는지 기억이 안 나요
.

371
00:17:38,810 --> 00:17:41,780
그 물건은 어떻게 생겼었나요?

372
00:17:41,780 --> 00:17:46,860
10의 서브트리에 8이 있었으므로
서브트리가 확실히 변경되었습니다.

373
00:17:46,860 --> 00:17:48,140
8의 서브트리가 변경되었습니다.

374
00:17:48,140 --> 00:17:49,220
청중: [잘 안 들림]

375
00:17:49,220 --> 00:17:51,000
제이슨 쿠: 12는 결국 변하지 않았어

376
00:17:51,000 --> 00:17:51,500
.

377
00:17:51,500 --> 00:17:54,498
관객: 이건
10과 8이에요. [잘 안 들림]..

378
00:17:54,498 --> 00:17:55,040
제이슨 쿠: 알겠습니다.

379
00:17:55,040 --> 00:17:57,920

강의 노트에 나와 있고

380
00:17:57,920 --> 00:18:00,050
수업 시간에 다뤄졌던 사례 분석이 바로 그것입니다.

381
00:18:00,050 --> 00:18:03,800

이는 A, B, C, D와 같은

382
00:18:03,800 --> 00:18:06,860
하위 트리, 즉

383
00:18:06,860 --> 00:18:09,650
이러한 것들에서 변경될 수 있는
하위 트리가 변경되지 않는다는 것을 의미합니다.

384
00:18:09,650 --> 00:18:12,290


385
00:18:12,290 --> 00:18:15,620

한두 번의 회전을 수행하는 이러한 수정 작업 중에 변경되는 유일한 하위 트리는 하위 트리가 변경된 노드가

386
00:18:15,620 --> 00:18:18,860
두 개
또는 세 개입니다

387
00:18:18,860 --> 00:18:20,240
.

388
00:18:20,240 --> 00:18:23,900
여기서는
세 개의 하위 트리가

389
00:18:23,900 --> 00:18:26,000
변경되었을 가능성이 있습니다.

390
00:18:26,000 --> 00:18:29,780
하지만 간단한 경우에는,
제 생각에는 메모에 있는 x와 y, 이렇게 두 개의 노드만

391
00:18:31,130 --> 00:18:32,040
변경될 수 있었을 겁니다.

392
00:18:32,040 --> 00:18:36,710
그래서 그렇게 할 때, 자식 노드의 증강을 기반으로 해당 노드의
증강을 다시 계산해야

393
00:18:36,710 --> 00:18:39,200


394
00:18:39,200 --> 00:18:42,110
하지만, 그 수는 일정하기 때문에 그냥

395
00:18:42,110 --> 00:18:45,780
다시 계산하면 됩니다. 왜냐하면
제 아래의 서브트리는

396
00:18:45,780 --> 00:18:47,430
변경되지 않았기 때문입니다.

397
00:18:47,430 --> 00:18:47,930
좋아요.

398
00:18:47,930 --> 00:18:50,280

여기서 높이 차이가 발생하네요.

399
00:18:50,280 --> 00:18:50,926
응?

400
00:18:50,926 --> 00:18:52,165
관객: [잘 안 들림]

401
00:18:56,743 --> 00:18:57,410
제이슨 쿠: 네.

402
00:18:57,410 --> 00:19:01,730
원래
그림에서 12번

403
00:19:01,730 --> 00:19:04,010

노드의 하위 트리에는

404
00:19:04,010 --> 00:19:08,350
10번과 8번 노드가 있었는데, 7번 노드를 삭제했으니

405
00:19:08,350 --> 00:19:09,850
하위 트리 구조가
확실히 바뀌었습니다.  예전에는

406
00:19:09,850 --> 00:19:10,980
세 개가 있었는데...

407
00:19:10,980 --> 00:19:12,040
관객: [잘 안 들림]

408
00:19:12,040 --> 00:19:14,130
제이슨 쿠: 아, 죄송합니다. 세 개였죠.

409
00:19:14,130 --> 00:19:14,680
응.

410
00:19:14,680 --> 00:19:18,040
여기서는 세 개의 노드
서브트리가 변경되었습니다.

411
00:19:18,040 --> 00:19:20,890
하지만 그게 사실 최대치입니다.

412
00:19:20,890 --> 00:19:23,620
최악의 경우를 보여드리겠습니다.

413
00:19:23,620 --> 00:19:25,870


414
00:19:25,870 --> 00:19:28,143
이중
회전 작업을 수행할 때

415
00:19:28,143 --> 00:19:29,560

하위 트리가 변경될 수 있는 노드는 단 세 개뿐입니다.

416
00:19:29,560 --> 00:19:32,740
그래서 우리는
그 세 가지

417
00:19:32,740 --> 00:19:33,610
요소의 증강 문제를 해결해야 합니다.

418
00:19:33,610 --> 00:19:36,880
간단한 경우에는
두 가지뿐입니다.

419
00:19:36,880 --> 00:19:38,050
괜찮은.

420
00:19:38,050 --> 00:19:39,580
우리는 불균형 상태에 있습니다.

421
00:19:39,580 --> 00:19:40,600
이 문제를 어떻게 해결할 수 있을까요?

422
00:19:43,520 --> 00:19:45,890
나는 못되게 굴 수도 있었다.

423
00:19:45,890 --> 00:19:49,070

여기서 오른쪽으로 회전해서

424
00:19:49,070 --> 00:19:54,140
균형을 다시 맞추고 싶어요.
얄밉게도 이 두 위치를 바꿔버릴 수도 있었겠지만요.

425
00:19:54,140 --> 00:19:56,150
만약 저
두 개를 바꿔 끼우면,

426
00:19:56,150 --> 00:19:58,100

이 문제를 해결하려면 두 바퀴를 돌아야 할 거예요.

427
00:19:58,100 --> 00:20:01,040
왜냐하면 제가 하려는 동작에서는 가운데 있는 게
왼쪽 것보다 무겁거든요

428
00:20:01,040 --> 00:20:04,250
.

429
00:20:04,250 --> 00:20:09,140
하지만 난 그렇게 심술궂은 사람이 아니니까,
오른쪽으로 회전할 거야.

430
00:20:09,140 --> 00:20:10,370
어떻게 하면 되나요?

431
00:20:10,370 --> 00:20:13,130
음, 6에서 오른쪽으로 회전시키면 이

432
00:20:13,130 --> 00:20:16,940
모든 것이
4 아래로 내려가고

433
00:20:16,940 --> 00:20:20,075
이 서브트리가
6의 왼쪽 자식으로 고정될 거예요. 이해되시나요

434
00:20:20,075 --> 00:20:21,830
?

435
00:20:21,830 --> 00:20:22,438
왝.

436
00:20:22,438 --> 00:20:23,730
그거 그리면 재밌겠네요.  다시

437
00:20:28,100 --> 00:20:30,580
그릴게요.

438
00:20:30,580 --> 00:20:32,390
그게 더 말이 되죠, 그렇죠?

439
00:20:32,390 --> 00:20:54,020
4, 11, 3, 2, 1, 그리고
6, 5, 9, 8, 12, 10.

440
00:20:54,020 --> 00:20:57,730
6시 방향에서의 올바른 회전 순서입니다.

441
00:20:57,730 --> 00:21:00,520
모두 괜찮으신가요?

442
00:21:00,520 --> 00:21:05,140
회전은
x축이 6, y축이 4입니다.

443
00:21:05,140 --> 00:21:09,400
A, B, C 서브트리가 있습니다.

444
00:21:09,400 --> 00:21:12,610
제가 하려는 건
x와 y 중 어느 쪽이

445
00:21:12,610 --> 00:21:15,610
근인지 바꾸는 거예요.

446
00:21:15,610 --> 00:21:23,080
이제 y가 루트가 되고,
여기 있는 B와 C 서브트리는

447
00:21:23,080 --> 00:21:25,480
y 아래에 있는 x의 자식 트리가 됩니다.

448
00:21:25,480 --> 00:21:29,110
그리고 바라건대,
이 모든 과정을 통해

449
00:21:29,110 --> 00:21:33,150
제가 사용하는 순차 탐색 방식은
변하지 않았을 것입니다.

450
00:21:33,150 --> 00:21:35,600
우리는
도중에 증강현실 기능을 업데이트해야 했지만,

451
00:21:35,600 --> 00:21:38,630

나무 위로 올라갈 때마다 이 작업은 항상 동일하게 진행됩니다.

452
00:21:38,630 --> 00:21:41,510
그리고 우리는 나무 위로
로그 함수적인 횟수만큼만 올라갑니다.

453
00:21:41,510 --> 00:21:42,460
응?

454
00:21:42,460 --> 00:21:42,960
예.

455
00:21:42,960 --> 00:21:43,880
청중: [알아들을 수 없음].

456
00:21:43,880 --> 00:21:46,778
그럼
회전을 할 때마다 다른 회전을 하기 전에

457
00:21:46,778 --> 00:21:48,570

[알아들을 수 없는 부분]을 통해 증강 현실을 업데이트하는 건가요

458
00:21:48,570 --> 00:21:49,850
?

459
00:21:49,850 --> 00:21:50,145
제이슨 쿠: 맞습니다.

460
00:21:50,145 --> 00:21:51,375
관객: 두 번째 파트.  증강현실을

461
00:21:51,375 --> 00:21:53,870
업데이트한다는 것은

462
00:21:53,870 --> 00:21:57,380
개수,
높이, 그리고 그대로

463
00:21:57,380 --> 00:21:58,510
유지되는 속성들을 업데이트하는 것을 의미합니다. -

464
00:21:58,510 --> 00:21:59,135
제이슨 쿠: 네.

465
00:21:59,135 --> 00:22:00,650
기본적으로 저희가
한 일은, 즉 저희가 내용을

466
00:22:00,650 --> 00:22:02,390
보강할 때,

467
00:22:02,390 --> 00:22:04,610
드메인 교수가
어제 여러분께

468
00:22:04,610 --> 00:22:07,100
서브트리 속성이 무엇인지 정의해 드린 것입니다.

469
00:22:07,100 --> 00:22:10,490
그것은

470
00:22:10,490 --> 00:22:12,590
내 자식들, 즉 자식들의

471
00:22:12,590 --> 00:22:16,250
확장된 형태를
재귀적으로 살펴보아야만 계산할 수 있는 속성을 의미했습니다.

472
00:22:16,250 --> 00:22:20,570
그래서 여기서는, 점진적으로
증가시키거나

473
00:22:20,570 --> 00:22:24,440
로컬에서 이 확장이 무엇이어야 하는지 생각하려고 애쓰는 대신, 기존의

474
00:22:24,440 --> 00:22:26,990

확장을 버리고 자식 노드들로부터

475
00:22:26,990 --> 00:22:28,670
다시 계산할 것입니다.

476
00:22:28,670 --> 00:22:31,905
왜냐하면 자식 노드들은 재귀적으로
정확해야 하기 때문입니다.

477
00:22:31,905 --> 00:22:32,780
이해가 되시나요?

478
00:22:32,780 --> 00:22:33,463
응?

479
00:22:33,463 --> 00:22:35,630
청중: 그럼
회전 방식이 어떻게 되는지 살펴보죠.  도무지

480
00:22:35,630 --> 00:22:38,420
이해가 안 가네요
.

481
00:22:38,420 --> 00:22:41,870
그러니까 기본적으로
4와 6을 서로 바꾸는 건데, 그렇게 하면

482
00:22:41,870 --> 00:22:47,390
4가 부모 노드가
되고 6이 오른쪽 노드가 되는 겁니다.

483
00:22:47,390 --> 00:22:50,480
제이슨 쿠: 저는
이 그림을 그릴 거예요.  그냥

484
00:22:50,480 --> 00:22:52,280

외워야 하는 거예요.

485
00:22:55,420 --> 00:23:05,640
이것은 x, B, C, 그리고 A입니다.
그림이 보이시나요?

486
00:23:05,640 --> 00:23:07,495
관객: [잘 안 들림]

487
00:23:07,495 --> 00:23:08,120
제이슨 쿠: 뭐라고요?

488
00:23:08,120 --> 00:23:09,355
관객: [잘 안 들림]

489
00:23:09,355 --> 00:23:09,980
제이슨 쿠: 네.

490
00:23:09,980 --> 00:23:11,090
노트에 적혀 있어요.

491
00:23:11,090 --> 00:23:12,780
별일 아니에요.

492
00:23:12,780 --> 00:23:15,140
하지만

493
00:23:15,140 --> 00:23:19,010
x가 왼쪽 자식을 갖는 이러한 구조가 있다면,

494
00:23:19,010 --> 00:23:21,150
이러한 하위 트리는
비어 있을 수도 있고 그렇지 않을 수도 있습니다.

495
00:23:21,150 --> 00:23:22,100
별로 상관없어요.

496
00:23:22,100 --> 00:23:25,490
제가 할 수 있는 것은
여기에서 저기로 이동하는 것입니다.

497
00:23:25,490 --> 00:23:30,780

순회 순서는 같지만

498
00:23:30,780 --> 00:23:32,140
모양이 다릅니다.

499
00:23:32,140 --> 00:23:34,050
특히
서브트리의 높이가

500
00:23:34,050 --> 00:23:37,740
변경되었는데, 이는
트리의 균형을 다시 맞추는 데 도움이 될 수 있습니다.

501
00:23:37,740 --> 00:23:39,960
그게 바로
AVL의 핵심입니다.

502
00:23:39,960 --> 00:23:41,350
이해가 되시나요?

503
00:23:41,350 --> 00:23:43,320
관객: 저게
맞는 회전 방향인가요?

504
00:23:43,320 --> 00:23:45,210
제이슨 쿠:

505
00:23:45,210 --> 00:23:46,680
이건 오른쪽 회전입니다.

506
00:23:46,680 --> 00:23:48,960
이것은 좌회전입니다.

507
00:23:48,960 --> 00:23:50,860
다른 질문 있으신가요?

508
00:23:50,860 --> 00:23:51,360
응?

509
00:23:51,360 --> 00:23:54,776
청중: [잘 안 들림]

510
00:23:58,530 --> 00:24:00,510
제이슨 쿠:
트리를 올라가면서

511
00:24:00,510 --> 00:24:03,720
모든 노드를
재균형 조정을 통해 수정해야 할 수도 있지만,

512
00:24:03,720 --> 00:24:07,290
그 재균형 조정은
최대 두 번의 회전만 수행하며, 조상 노드는

513
00:24:07,290 --> 00:24:11,070
최대 log n개입니다.

514
00:24:11,070 --> 00:24:16,350
왜냐하면 제 트리는
2

515
00:24:16,350 --> 00:24:19,110
log n 정도의 높이로 균형이 맞춰져 있기 때문입니다.

516
00:24:19,110 --> 00:24:21,810
즉,
최대

517
00:24:21,810 --> 00:24:26,310
4번의 log n 회전을 해야 할 수도 있다는 뜻입니다.
왜냐하면 각 회전마다

518
00:24:26,310 --> 00:24:27,310
2번의 회전이 가능하기 때문입니다.

519
00:24:27,310 --> 00:24:28,230
이해가 되시나요?

520
00:24:28,230 --> 00:24:31,680
실제로
삭제 작업에서

521
00:24:31,680 --> 00:24:34,050


522
00:24:34,050 --> 00:24:35,430
트리를 따라 로그 함수적인 횟수만큼 회전해야 할 수도 있다는 것을 증명할 수 있습니다.

523
00:24:35,430 --> 00:24:38,190
이것이 바로 그 심각한 사례였다.

524
00:24:38,190 --> 00:24:40,980
제가 드린 원래 나무는
피보나치 나무라고 합니다.

525
00:24:40,980 --> 00:24:45,090
이는 주어진 노드 수에서 만들 수 있는
가장 높은 높이의 균형 트리입니다

526
00:24:45,090 --> 00:24:47,385

.

527
00:24:52,620 --> 00:24:55,440
네,
특정 높이에 필요한 최소 노드 수입니다.

528
00:24:55,440 --> 00:24:56,820
어느 쪽으로 생각해도 상관없습니다.

529
00:24:56,820 --> 00:24:59,530
그리고 그것을
충분히 큰 대상으로 일반화하면,

530
00:24:59,530 --> 00:25:01,470
그 대상은 회전
횟수가 로그 함수적으로 증가하게 될 것입니다

531
00:25:01,470 --> 00:25:02,760
.

532
00:25:02,760 --> 00:25:05,070
자, 사실
삽입을 통해

533
00:25:05,070 --> 00:25:09,270
실제로 증명할 수 있습니다. 즉,
사례 분석을 진행할 수 있습니다.

534
00:25:09,270 --> 00:25:12,090
삽입 작업은
항상

535
00:25:12,090 --> 00:25:15,668
한 번의 재균형
작업(

536
00:25:15,668 --> 00:25:16,835
두 번의 회전을 포함할 수 있음) 후에 트리의 균형을 다시 맞춥니다.

537
00:25:16,835 --> 00:25:19,350
이해가 되시나요?

538
00:25:19,350 --> 00:25:20,053
응?

539
00:25:20,053 --> 00:25:21,930
관객: [잘 안 들림]

540
00:25:27,280 --> 00:25:27,920
제이슨 쿠: 네.

541
00:25:27,920 --> 00:25:30,415
오른쪽으로 회전하면 이 사람은 정말
착한 아이가 됩니다.

542
00:25:30,415 --> 00:25:31,040
청중: 네.

543
00:25:31,040 --> 00:25:33,550
그렇다면 자녀가 있는지 여부에

544
00:25:33,550 --> 00:25:36,730
따라 수행할 수 없는 특정 회전 동작이 있나요?

545
00:25:36,730 --> 00:25:37,390
제이슨 쿠: 네.

546
00:25:37,390 --> 00:25:43,070
왼쪽 서브트리가 없으면
오른쪽 회전을 수행할 수 없습니다

547
00:25:43,070 --> 00:25:44,680
.

548
00:25:44,680 --> 00:25:47,340
오른쪽으로 회전하는 체위 때문에
저는 왼쪽 아이를 낳아야 합니다.

549
00:25:47,340 --> 00:25:48,520
그러니까 만약 여러분이 그렇게 한다면, 보시다시피

550
00:25:48,520 --> 00:25:50,440

저희 코드는 실제로

551
00:25:50,440 --> 00:25:52,420

왼쪽 자식이 있는지 확인합니다.

552
00:25:57,500 --> 00:25:59,870
그건 당신이

553
00:25:59,870 --> 00:26:02,960

이런 순환 근무를 시작하기 전에 반박하고 싶어할 만한 주장입니다.

554
00:26:02,960 --> 00:26:03,700
또 다른 질문 있으신가요?

555
00:26:03,700 --> 00:26:04,560
응?

556
00:26:04,560 --> 00:26:06,393
청중:
다시 한번 말씀드리자면, 삽입에는 최대

557
00:26:06,393 --> 00:26:09,097
두 바퀴가 걸릴 수 있다는 말씀이시죠?
[잘 안 들림]

558
00:26:09,097 --> 00:26:09,680
제이슨 쿠: 네.  회전

559
00:26:09,680 --> 00:26:11,680
횟수는 일정하지만
, 삭제에는

560
00:26:11,680 --> 00:26:14,540
로그
회전 횟수가 소요될 수 있습니다.  그건

561
00:26:14,540 --> 00:26:16,490

여러분이 알 필요가 없는 사실입니다.

562
00:26:16,490 --> 00:26:19,460
제가
여기서 당신에게 증명하려는 것이 아닙니다.

563
00:26:19,460 --> 00:26:21,650
그냥
흥미로운 점이 있어서요.

564
00:26:21,650 --> 00:26:26,390

CRS와 같은 자산 재조정 제도가 있습니다.

565
00:26:26,390 --> 00:26:31,310
그들은 균형을 맞추기 위해 붉은색과 검은색이 어우러진 나무를 도입했습니다
.

566
00:26:31,310 --> 00:26:34,670
그리고 그러한 계통수들은 실제로
경계가 더 약합니다.

567
00:26:34,670 --> 00:26:39,680

AVL 계통수처럼 단단하게 균형을 이루고 있지 않습니다.

568
00:26:39,680 --> 00:26:44,030
이는 왜곡도 2보다 높은 값을 허용합니다.

569
00:26:44,030 --> 00:26:46,400
그리고 비교적
약한 제약 조건이기 때문에, 트리 구조를 수정하기 전에

570
00:26:46,400 --> 00:26:49,470

일정한 회전 횟수만 수행해도 문제가

571
00:26:49,470 --> 00:26:54,560
해결됩니다. 즉, 그 정도의 회전 횟수를 감당할 수 있는 것입니다.

572
00:26:54,560 --> 00:26:56,150
하지만 조금 더 복잡합니다.

573
00:26:56,150 --> 00:26:57,680
관객: [잘 안 들림]

574
00:27:00,457 --> 00:27:01,290
제이슨 쿠: 아주 좋네요.

575
00:27:01,290 --> 00:27:01,790
좋아요.

576
00:27:01,790 --> 00:27:02,780
이와 관련해서 질문 있으신가요?

577
00:27:06,090 --> 00:27:10,550
자, 그럼 이제부터 나오는 문제는 여러분이 시험 문제에서 접하게 될 좀 더
기계적인 유형의 질문입니다

578
00:27:10,550 --> 00:27:11,750
.

579
00:27:11,750 --> 00:27:15,950
이제 좀 더
이론적인 질문들로 넘어가 보겠습니다.

580
00:27:15,950 --> 00:27:19,230
이 질문들은
환원형 질문이 될 것입니다.

581
00:27:19,230 --> 00:27:19,730
좋아요.

582
00:27:19,730 --> 00:27:25,250
첫 번째 문제는 Fick Nury입니다.

583
00:27:25,250 --> 00:27:26,840
이건… 누구 없나요?

584
00:27:26,840 --> 00:27:27,650
닉 퓨리 맞죠?

585
00:27:27,650 --> 00:27:31,280
그러니까 이건 어벤져스에 대한 언급이네요.

586
00:27:31,280 --> 00:27:33,800
그러니까 기본적으로
이 이야기에서는,

587
00:27:33,800 --> 00:27:38,210
그가 슈퍼히어로들의 목록을 가지고 있는데, 각
슈퍼히어로들은 사노스와 싸워야 할지

588
00:27:38,210 --> 00:27:41,150
말지에 대해 저마다의 의견을 가지고 있습니다
.

589
00:27:43,820 --> 00:27:49,220
그리고 그들의 의견은
매우 긍정적일 수도 있고

590
00:27:49,220 --> 00:27:50,730
매우 부정적일 수도 있습니다.

591
00:27:50,730 --> 00:27:54,320
그래서 픽이 하려는 것은

592
00:27:54,320 --> 00:27:59,960

자신의 리벤저스 구성원들 중에서

593
00:27:59,960 --> 00:28:04,820
가장 극단적인 의견을 가진
구성원이 누구인지 알아내어

594
00:28:04,820 --> 00:28:05,888
그들과 대화를 나누는 것입니다.

595
00:28:05,888 --> 00:28:07,430
그는
모든 사람과 이야기하고 싶어하지 않아요.

596
00:28:07,430 --> 00:28:10,040
그는
로그 함수적인 수의 사람들과 대화하고 싶어합니다.

597
00:28:10,040 --> 00:28:11,030
좋아요.  뭐, 그냥 그렇다는 거죠

598
00:28:11,030 --> 00:28:14,720
.

599
00:28:14,720 --> 00:28:18,800
기본적으로, 우리는
기밀 상황에 처해 있는데, 이 상황에서는

600
00:28:18,800 --> 00:28:22,760


601
00:28:22,760 --> 00:28:23,980
이러한 정보들이 배열 형태로 저장된 읽기 전용 입력 데이터가 제공됩니다.

602
00:28:26,900 --> 00:28:31,975
그리고 저는
가장 강한 의견을 가진 로그 n개의 로그를 찾고 싶습니다

603
00:28:31,975 --> 00:28:32,475
.

604
00:28:32,475 --> 00:28:34,138
이해가 되시나요?

605
00:28:34,138 --> 00:28:35,930
그리고 저는 그걸 하고 싶어요.
첫 번째 문제는

606
00:28:35,930 --> 00:28:39,440
선형 시간 복잡도를 가지고 있습니다.

607
00:28:39,440 --> 00:28:42,770
사실 당신은
아직 이걸 어떻게 하는지 모르는군요.

608
00:28:42,770 --> 00:28:47,810
여러분은 046 수업에서 배우는 내용을 통해 그 방법을 알게 될 겁니다.

609
00:28:47,810 --> 00:28:50,420

046 수업에서는 한 가지 방법을 가르쳐주지만, 지금 당장 그 방법을 알려드릴 생각은

610
00:28:50,420 --> 00:28:53,690
없습니다
.

611
00:28:53,690 --> 00:28:59,400

화요일에는

612
00:28:59,400 --> 00:29:01,370
이진 힙을 이용하는 또 다른 방법을 알려드리겠습니다.

613
00:29:01,370 --> 00:29:03,980
바이너리 힙은
흥미로운 개념입니다.  이 인터페이스는 집합 인터페이스의

614
00:29:03,980 --> 00:29:14,390
하위 집합을 구현합니다
.

615
00:29:14,390 --> 00:29:23,150
사실, 그냥
반복 가능한 x를 기반으로 구축할 수 있습니다.

616
00:29:23,150 --> 00:29:25,270
저는 여러 가지 물건을 수집해요.

617
00:29:25,270 --> 00:29:26,780
이 물건들에는 열쇠가 있습니다.  마찬가지로

618
00:29:26,780 --> 00:29:29,090
핵심적인 데이터 구조입니다
.

619
00:29:29,090 --> 00:29:32,100
이는 우리가
우선순위 큐 인터페이스라고 부르는 것을 구현하는 것입니다.

620
00:29:32,100 --> 00:29:33,860
저는 이런 것들을 만들 수 있어요.

621
00:29:33,860 --> 00:29:39,380
제가 뭔가를 삽입할 수는 있지만,
여기서는 그렇게 하지 않겠습니다.  이 상황에서

622
00:29:39,380 --> 00:29:43,490
제가 정말로 필요한 건

623
00:29:43,490 --> 00:29:47,150
delete_superlative
같은 연산입니다.

624
00:29:47,150 --> 00:29:50,870
이 경우에는 아마 max일 겁니다.  최대값을

625
00:29:50,870 --> 00:29:52,115
삭제합니다.

626
00:29:57,560 --> 00:29:58,400
그러니까 이건 마치

627
00:29:58,400 --> 00:30:01,713
제가 데이터 구조를 가지고 있고,
이것들을 이름으로 부르는 것과 같아요.

628
00:30:01,713 --> 00:30:02,630
이해가 되시나요?

629
00:30:02,630 --> 00:30:02,890
응?

630
00:30:02,890 --> 00:30:04,190
청중:
우선순위 대기열이란 무엇인가요?

631
00:30:04,190 --> 00:30:04,520
제이슨 쿠: 네.

632
00:30:04,520 --> 00:30:06,560
우선순위 큐는
본질적으로

633
00:30:06,560 --> 00:30:08,450
이 두 가지를 구현하는 것입니다.

634
00:30:08,450 --> 00:30:11,570
사실
새 항목을 삽입할 수 있는 세 번째 칸이 있는데,

635
00:30:11,570 --> 00:30:13,280

지금은 필요하지 않아요.  이게 바로 우선

636
00:30:13,280 --> 00:30:14,738

순위 큐의 정의입니다.

637
00:30:14,738 --> 00:30:15,890
그리고 실제로,

638
00:30:15,890 --> 00:30:19,180
이것은
집합 인터페이스의 부분 집합입니다.

639
00:30:19,180 --> 00:30:20,300
오른쪽?

640
00:30:20,300 --> 00:30:22,250
힙의 장점은 (구현 방법은

641
00:30:22,250 --> 00:30:25,160
보여드리지 않겠지만
,

642
00:30:25,160 --> 00:30:27,380
힙이 할 수 있는 일은)

643
00:30:27,380 --> 00:30:29,870
만약 이 두 가지
연산을 모두

644
00:30:29,870 --> 00:30:34,520
AVL 트리로 구현했다면, 처리 시간이 얼마나 걸릴지 궁금하다는 점입니다.

645
00:30:41,430 --> 00:30:43,566

AVL 트리 세트를 구축하는 데 얼마나 걸립니까?

646
00:30:46,970 --> 00:30:48,620
n log n 맞죠?

647
00:30:48,620 --> 00:30:50,960
기본적으로, 이 요소들을 하나씩 입력하면
정렬된 순서를 얻을 수 있습니다.

648
00:30:50,960 --> 00:30:53,300


649
00:30:55,220 --> 00:30:57,320
아니면, 정렬한
다음

650
00:30:57,320 --> 00:31:00,500

며칠

651
00:31:00,500 --> 00:31:03,780
전 강의 시간에 보셨던 것처럼 선형 시간 안에 트리 구조로 만들 수도 있습니다.

652
00:31:03,780 --> 00:31:05,840
하지만
언젠가는 정리해야 하잖아요, 그렇죠?  제 생각에는

653
00:31:07,340 --> 00:31:10,170

최소한 n log n 시간은 걸려야 할 것 같아요.

654
00:31:10,170 --> 00:31:14,120
왜냐하면
순회 순서를

655
00:31:14,120 --> 00:31:18,110
선형 시간 안에 반환할 수 있으려면 정렬에
n log n이라는 하한 시간이 있어야 하니까,

656
00:31:18,110 --> 00:31:21,800

여기서 n log n 시간을 써야 하는 거죠.

657
00:31:23,030 --> 00:31:26,524
그렇다면
delete_max를 실행하는 데 얼마나 걸릴까요?

658
00:31:26,524 --> 00:31:28,632
청중: 정렬됐으니, log n이라고 합시다.

659
00:31:28,632 --> 00:31:29,590
제이슨 쿠: 로그 n, 맞죠?

660
00:31:29,590 --> 00:31:31,020
그러니까 AVL 트리가 설정되어 있다는 거죠.

661
00:31:31,020 --> 00:31:31,950
내 최대치는 어디에 있나요?  가장

662
00:31:31,950 --> 00:31:33,180
오른쪽에 있는 것입니다.  그냥

663
00:31:33,180 --> 00:31:35,520
걸어 내려가서
벗으면 돼요.

664
00:31:35,520 --> 00:31:37,050
균형을 다시 맞춰야 할지도 모르겠네요.

665
00:31:37,050 --> 00:31:39,420
하지만 그건 log n개의 작업이 필요합니다.

666
00:31:39,420 --> 00:31:44,400

내 서브트리에서 insert-last와 동일합니다.

667
00:31:44,400 --> 00:31:46,860
AVL 트리 집합의 경우,
이는 n log n입니다.

668
00:31:46,860 --> 00:31:47,670
이것은 로그 n입니다.

669
00:31:50,610 --> 00:31:53,970
그런데 이러한 연산 중 하나에 더 나은 성능을 보이는 또 다른 데이터 구조가 있습니다

670
00:31:53,970 --> 00:31:55,560
.

671
00:31:55,560 --> 00:32:01,020
그리고
우리가 앞서 배웠던 다른 하나도 마찬가지입니다.  혹시

672
00:32:01,020 --> 00:32:03,600
기억하는 사람 있나요?  `

673
00:32:03,600 --> 00:32:05,430
Set AVL tree`는
실제로

674
00:32:05,430 --> 00:32:11,910

동적 배열에서 정렬된 배열 이상의 결과를 제공하지 않았습니다.

675
00:32:11,910 --> 00:32:14,805
그렇게 함으로써 우리는 병합 정렬이나 그와 유사한 방법을 사용하여

676
00:32:14,805 --> 00:32:17,730
n log n 시간 안에 정렬할 수 있게 되었습니다

677
00:32:17,730 --> 00:32:18,790
.

678
00:32:18,790 --> 00:32:22,500
그런 다음
마지막 하나를 n번 쏴버릴 수 있죠.

679
00:32:22,500 --> 00:32:23,790
그건 감가상각비가 붙는다는 뜻이죠. 그러니까

680
00:32:23,790 --> 00:32:26,838
, 만약 제가 그 정도 크기를
차지하는 것에 신경 쓰지 않는다면

681
00:32:26,838 --> 00:32:29,130
,
최악의 경우에도 일정한 시간 안에 해낼 수 있을 거예요.  방금

682
00:32:29,130 --> 00:32:31,380

첫 번째, 그러니까 마지막 하나를 읽어 봤어요.

683
00:32:31,380 --> 00:32:33,750
저는 배열 크기를 조정할 필요가
전혀 없습니다.

684
00:32:33,750 --> 00:32:35,940
그건 그냥 무시하면 돼요.

685
00:32:35,940 --> 00:32:37,150
이해가 되시나요?

686
00:32:37,150 --> 00:32:37,650
좋아요.

687
00:32:37,650 --> 00:32:39,130
하지만 괜찮아요.

688
00:32:39,130 --> 00:32:43,230
만약 제가
이 두 가지 연산을 구현하는 데이터 구조를 가지고 있다면

689
00:32:43,230 --> 00:32:49,770
, 이 두 가지 연산만을 사용하여

690
00:32:49,770 --> 00:32:52,025
고정된 리스트를 생성하는 알고리즘을 알려주실 수 있나요? (

691
00:32:52,025 --> 00:32:54,150
실행 시간은 고려하지 않아도 됩니다.)

692
00:32:59,270 --> 00:33:00,350
응?

693
00:33:00,350 --> 00:33:03,530
청중: 그래서 우리는
이런 데이터 구조를 만듭니다.  절댓값이 작은 순서대로 큰 순서대로

694
00:33:03,530 --> 00:33:05,135
나열되어 있습니다

695
00:33:05,135 --> 00:33:07,830
.

696
00:33:07,830 --> 00:33:11,880
제이슨 쿠:
물건들이 어디에

697
00:33:11,880 --> 00:33:13,130
놓여 있는지 같은 건 걱정하지 마세요.

698
00:33:13,130 --> 00:33:16,310
이런
것들이 어떻게 구현되는지는 제가 말씀드리지 않겠죠?

699
00:33:16,310 --> 00:33:20,330
제가 말씀드리고 싶은 건,
이런 것들을 여러 개 받아들인 다음

700
00:33:20,330 --> 00:33:24,500

최대값을 빼고 반환할 수 있다는 겁니다.

701
00:33:24,500 --> 00:33:25,330
좋아요?

702
00:33:25,330 --> 00:33:26,830
청중: 제 생각에는
그냥 구축하면 될 것 같아요.

703
00:33:26,830 --> 00:33:29,712

의견 수준이 의견 수준

704
00:33:29,712 --> 00:33:31,670
의 절대값이 되도록 구축해야지
, 아니면...

705
00:33:31,670 --> 00:33:32,060
제이슨 쿠: 네, 맞습니다.

706
00:33:32,060 --> 00:33:32,560
좋아요.  그건

707
00:33:32,560 --> 00:33:33,720
좋은 일이죠.

708
00:33:33,720 --> 00:33:36,410

동료분께서 말씀하신 것처럼, 제가 할 일은 제가

709
00:33:36,410 --> 00:33:39,830

입력한 모든 내용을 하나하나 살펴보는 것입니다.  쓰기 가능한

710
00:33:39,830 --> 00:33:44,510

메모리 저장소로 복사하겠습니다.

711
00:33:44,510 --> 00:33:47,150
읽기 전용 설정은 이 문제의 핵심과는
관련이 없습니다

712
00:33:47,150 --> 00:33:48,808
.

713
00:33:48,808 --> 00:33:49,850
제가 하려는 일은… 네.

714
00:33:57,550 --> 00:33:58,050
죄송합니다.

715
00:33:58,050 --> 00:34:00,790

우리가 함께 작성하고 있는 문제 세트에 대해 생각해 보고 있어요.

716
00:34:00,790 --> 00:34:01,750
저는 여러 가지를 섞어서 쓰고 있어요.

717
00:34:01,750 --> 00:34:09,790
좋아요, 그럼 이제 이 값을
새로운 선형 크기 배열로 복사해 봅시다.

718
00:34:09,790 --> 00:34:11,679
하지만 저는
그 값들을 직접 적는 대신,

719
00:34:11,679 --> 00:34:13,424

값들의 절댓값을 적겠습니다.

720
00:34:13,424 --> 00:34:14,170
이해가 되시나요?

721
00:34:14,170 --> 00:34:15,420
저는 결과가 음성인지 여부만 확인합니다.

722
00:34:15,420 --> 00:34:17,949
만약 그렇다면, 저는
거기에 긍정적인 내용을 적습니다.

723
00:34:17,949 --> 00:34:19,300
좋아요?

724
00:34:19,300 --> 00:34:23,440
그런 다음 해당
배열을 이 빌드에 넣습니다.

725
00:34:23,440 --> 00:34:26,620
제가 거기에 뒀어요.

726
00:34:26,620 --> 00:34:29,199
그건 좀 걸릴 거예요.
제작 기간이 얼마나 걸리는지는 모르겠지만요.

727
00:34:29,199 --> 00:34:33,489
그러면
최대 k번까지 삭제할 수 있습니다.

728
00:34:33,489 --> 00:34:38,170
아니면

729
00:34:38,170 --> 00:34:38,739
필요한 만큼 여러 번 삭제할 수도 있어요.

730
00:34:38,739 --> 00:34:39,760
오른쪽?

731
00:34:39,760 --> 00:34:44,050
만약 내가 log n번 가장 높은 값을 얻고 싶다면, 그냥
log n번 하면 되는 거

732
00:34:44,050 --> 00:34:44,860
아닌가요?

733
00:34:44,860 --> 00:34:48,219
그러니까
이런 데이터 구조가 있다면, 이 연산을

734
00:34:48,219 --> 00:34:51,580
한 번만 실행해서 원하는 결과를 얻고,

735
00:34:51,580 --> 00:34:55,175

이 연산을 n번 실행해서 로그 값을 계산할 수 있다는 거죠.

736
00:34:55,175 --> 00:34:56,050
이해가 되시나요?

737
00:34:56,050 --> 00:34:57,610
이
문제를

738
00:34:57,610 --> 00:34:59,290
데이터 구조로 단순화하면 해결할 수 있을 것 같습니다.

739
00:34:59,290 --> 00:35:05,980
정렬된 배열
이나 AVL 트리 집합의 경우,

740
00:35:05,980 --> 00:35:08,155
이 연산 자체가
저에게는 너무 어렵습니다.

741
00:35:08,155 --> 00:35:10,420
n log n 시간이 걸립니다.

742
00:35:10,420 --> 00:35:13,360

이진 힙의 장점은

743
00:35:13,360 --> 00:35:17,100
이
연산을 선형 시간 안에 수행한다는 것입니다.

744
00:35:20,060 --> 00:35:21,850
화요일에 확인하실 수 있을 겁니다.

745
00:35:21,850 --> 00:35:26,290
그리고 이
작업은 log n 시간 안에 수행됩니다.

746
00:35:30,650 --> 00:35:34,220


747
00:35:34,220 --> 00:35:37,520
이
데이터 구조를 구현하기 위해 바이너리 힙을 사용하면 실행 시간은 얼마나 걸릴까요?

748
00:35:37,520 --> 00:35:42,020
n 곱하기
log n 곱하기 log n.

749
00:35:42,020 --> 00:35:44,990
log n 제곱, 즉

750
00:35:44,990 --> 00:35:48,551
log 제곱 n은 n에 비해 얼마나 큰가요?

751
00:35:48,551 --> 00:35:49,835
더 작죠?

752
00:35:49,835 --> 00:35:51,710
그러니까 두
실행 시간을 더해도

753
00:35:51,710 --> 00:35:54,260
여전히 선형적인 관계라는 거죠.

754
00:35:54,260 --> 00:35:57,020
그렇게 하면
첫 번째 문제를 해결할 수 있습니다.

755
00:35:57,020 --> 00:35:59,750

바이너리 힙이 무엇인지,

756
00:35:59,750 --> 00:36:00,842
어떻게 작동하는지 굳이 설명할 필요는 없었겠죠.

757
00:36:00,842 --> 00:36:02,300
제가
여러분께 말씀드리고 싶었던 것은

758
00:36:02,300 --> 00:36:04,220
이 연산이
선형 시간 안에 수행되었고, 또 다른

759
00:36:04,220 --> 00:36:05,990

연산은 log n 시간 안에 수행되었다는 것입니다.

760
00:36:10,550 --> 00:36:11,720
괜찮은.

761
00:36:11,720 --> 00:36:14,780
그 마법은
화요일에 여러분께 보여드리겠습니다.

762
00:36:14,780 --> 00:36:19,730
파트 B에서는 이제
Fick의 컴퓨터가

763
00:36:19,730 --> 00:36:22,550

최대 log n 공간에만 쓸 수 있다고 가정해 보라고 합니다.

764
00:36:22,550 --> 00:36:23,210
네, 알겠습니다.

765
00:36:23,210 --> 00:36:24,260
그게 바로 문제입니다.

766
00:36:24,260 --> 00:36:29,570
이전에는
배열 전체를 복사하고,

767
00:36:29,570 --> 00:36:34,137
필터링한
다음 몇 가지 작업을 수행했기 때문입니다.

768
00:36:34,137 --> 00:36:35,720
하지만
만약 우리가

769
00:36:35,720 --> 00:36:40,560
전체 데이터를
외부 쓰기 가능한 메모리에 저장할 수 없었다면, 이마저도 감당할 수 없었을 겁니다.

770
00:36:40,560 --> 00:36:42,090
그래서 우리는 그렇게 할 수 없어요.

771
00:36:42,090 --> 00:36:46,820
어떤 의미에서는 이것이
더 제한적인 환경이라고 할 수 있습니다.

772
00:36:46,820 --> 00:36:49,590
나는 할 수 있는 일이 줄어들었다.  이전 상황

773
00:36:49,590 --> 00:36:53,540
보다 성능이 떨어지네요. 예전에는

774
00:36:53,540 --> 00:36:57,500

원하는 만큼 공간을 활용할 수 있었거든요.

775
00:36:57,500 --> 00:37:02,000
그래서
제가 이전처럼 정해진

776
00:37:02,000 --> 00:37:07,490
실행 시간
제한을 맞추지 못했던 것도 어쩌면 당연한 일일지도 모르겠습니다.

777
00:37:07,490 --> 00:37:10,040


778
00:37:10,040 --> 00:37:13,060
제가 처한 컴퓨팅 환경이 더 제한적이기 때문에 무언가를 희생해야 할지도 모르겠습니다
.

779
00:37:17,120 --> 00:37:19,563
이 문제는
이진 힙을 사용하면 해결할 수 있지만, 꼭 그렇게 할 필요는

780
00:37:19,563 --> 00:37:20,480
없습니다.

781
00:37:20,480 --> 00:37:27,860

AVL 트리를 설정하면 해결할 수 있습니다.

782
00:37:27,860 --> 00:37:29,960


783
00:37:29,960 --> 00:37:32,750
AVL 트리 집합을 사용하여 이 문제를 해결할 수 있는 방법을 아시는 분 계신가요?

784
00:37:32,750 --> 00:37:37,430
제게 주어진
공간은 최대 log n으로 제한되어 있습니다.

785
00:37:40,710 --> 00:37:43,473
청중: 그럼
AVL 트리 세트를 설치하려면 공간이 얼마나 필요할까요?

786
00:37:43,473 --> 00:37:44,140
제이슨 쿠: 맞습니다.

787
00:37:44,140 --> 00:37:47,080
공간 - 각 노드마다 일정한
수의 포인터가 존재합니다

788
00:37:47,080 --> 00:37:49,030
.

789
00:37:49,030 --> 00:37:52,510
그리고 저는
메모와 공간에 저장하고 있어요.

790
00:37:52,510 --> 00:37:57,520
기본적으로 지금까지 보여드린 모든 데이터 구조는 공간을 차지합니다. 즉, 저장하는

791
00:37:57,520 --> 00:38:00,130
데이터의 순서가 공간을 차지한다는 뜻입니다
.

792
00:38:00,130 --> 00:38:02,270
추가 공간을 차지하지 않습니다.  특정 작업을 하는 데

793
00:38:02,270 --> 00:38:05,500
시간이 더 걸릴 수도 있지만, 필요한

794
00:38:05,500 --> 00:38:09,457
공간은 보관하는
물품의 수에

795
00:38:09,457 --> 00:38:11,540

일정 비율을 더한 값입니다.

796
00:38:14,260 --> 00:38:18,430
그래서 제가 읽을 수만 있는 입력값을 여기에 그려볼게요. 저는

797
00:38:18,430 --> 00:38:20,073
쓸 수는 없거든요.  이 작품에 점수를

798
00:38:20,073 --> 00:38:20,740
줘야 할까요? 그냥

799
00:38:20,740 --> 00:38:26,170

A라고 할게요. 이게 제가 생각하는

800
00:38:26,170 --> 00:38:29,020
리벤저에 대한 모든 의견 목록입니다.

801
00:38:29,020 --> 00:38:31,660
저는 읽을 수만 있어요.

802
00:38:31,660 --> 00:38:36,140
하지만 제 컴퓨터는 로그
함수적인 크기의

803
00:38:36,140 --> 00:38:36,640
공간에만 데이터를 쓸 수 있습니다.

804
00:38:42,660 --> 00:38:46,280
저 공간에 무엇을 넣을 수 있을까요?

805
00:38:46,280 --> 00:38:49,500
청중: 로그 [잘 안 들림]?

806
00:38:49,500 --> 00:38:53,250
제이슨 쿠: 음, 물론
거기에 통나무 같은 걸 넣을 수 있죠.

807
00:38:53,250 --> 00:38:55,090
따라서
그러한 제약 조건이 주어진다면,

808
00:38:55,090 --> 00:38:58,985
저는 아마도
그 크기에 맞는

809
00:38:58,985 --> 00:39:00,360

개수의 항목을 포함하는 데이터 구조를 만들고 싶을 것입니다.

810
00:39:00,360 --> 00:39:02,797
이해가 되시나요?  달리

811
00:39:02,797 --> 00:39:04,380
어떻게 하겠어요
?

812
00:39:08,000 --> 00:39:10,380
그래서 제가 아이디어를 하나 드렸죠.

813
00:39:10,380 --> 00:39:12,800
아마
여기서 AVL 세트를 사용하면 될 것 같습니다.

814
00:39:12,800 --> 00:39:16,460
제 답변에 로그가 보이네요.

815
00:39:16,460 --> 00:39:21,170
우리가
정렬된 배열을 가지고 있거나

816
00:39:21,170 --> 00:39:23,300
AVL 설정을 해 놓았을 가능성이 매우 높습니다.

817
00:39:23,300 --> 00:39:26,360
그런 것들이
제 주행 기록 어딘가에 남게 되는 거죠,

818
00:39:26,360 --> 00:39:27,440
그렇죠?

819
00:39:27,440 --> 00:39:30,930
그래서
제가

820
00:39:30,930 --> 00:39:32,600
여기에 AVL 트리를 설정해 놓았을 가능성이 있다는 게 어느 정도 이해가 됩니다.

821
00:39:32,600 --> 00:39:37,810
AVL
트리를 설정하는 것이 저에게 어떤 도움이 될까요?

822
00:39:37,810 --> 00:39:38,310
응?

823
00:39:38,310 --> 00:39:39,750
청중:
정렬되어 있고

824
00:39:39,750 --> 00:39:41,285

순회 순서를 모르기 때문에

825
00:39:41,285 --> 00:39:45,305
순회
순서를 계산해서 [알아들을 수 없는 부분]을 삽입할 수 있나요?

826
00:39:45,305 --> 00:39:45,930
제이슨 쿠: 물론이죠.

827
00:39:45,930 --> 00:39:47,410
저는 그 모든 것들을 할 수 있습니다.

828
00:39:47,410 --> 00:39:49,320
특히,

829
00:39:49,320 --> 00:39:54,860

큰 것을 빨리 찾는 데 도움이 될 것 같네요, 그렇죠?

830
00:39:54,860 --> 00:40:00,340
만약 제가 여러 가지
요소들을 가지고 있고, 그

831
00:40:00,340 --> 00:40:02,150


832
00:40:02,150 --> 00:40:05,960
요소들을
점진적으로 추가하면서 데이터 구조를 유지한다면,

833
00:40:05,960 --> 00:40:08,780

가장 큰 요소가 무엇인지

834
00:40:08,780 --> 00:40:12,710
또는 가장 작은 요소가 무엇인지
매우 빠르게 찾을 수 있습니다 (로그 n 시간).

835
00:40:12,710 --> 00:40:17,780
만약
나무에 통나무 n개가 있다면,

836
00:40:17,780 --> 00:40:19,242
그 통나무의 높이는 얼마일까요?

837
00:40:19,242 --> 00:40:20,186
청중: [잘 안 들림]

838
00:40:20,186 --> 00:40:21,470
제이슨 쿠: 로그 로그 n.

839
00:40:21,470 --> 00:40:23,325
저거 왠지 익숙한데.

840
00:40:23,325 --> 00:40:24,200
그렇다면 제가 감당할 수 있는 금액은 얼마일까요?  저는 이 데이터 구조에 대해

841
00:40:24,200 --> 00:40:31,760
선형적인 횟수
의 옵트셋 AVL 트리 연산을 수행할 수 있습니다

842
00:40:31,760 --> 00:40:34,231
.

843
00:40:34,231 --> 00:40:35,455
네, 질문이 있으셨나요?

844
00:40:35,455 --> 00:40:36,330
관객: [잘 안 들림]

845
00:40:36,330 --> 00:40:37,330
제이슨 쿠: 네, 죄송합니다.

846
00:40:37,330 --> 00:40:38,008
응?

847
00:40:38,008 --> 00:40:39,550
청중:
AVL 트리가 되려면 꼭

848
00:40:39,550 --> 00:40:42,680
BTS 트리여야 하나요?

849
00:40:42,680 --> 00:40:43,960
제이슨 쿠: 어, BTS--

850
00:40:43,960 --> 00:40:45,810
BSTs.

851
00:40:45,810 --> 00:40:48,110
그래서 제가

852
00:40:48,110 --> 00:40:49,760
누군가가 한국 K팝을 좋아한다고 말할 때,

853
00:40:49,760 --> 00:40:50,610
좋아요.

854
00:40:50,610 --> 00:40:55,820
그러니까 BST, 그러니까 좀 더 자연스러운

855
00:40:55,820 --> 00:40:58,610
표현으로,
여러분이

856
00:40:58,610 --> 00:41:00,860

다른 맥락에서 들어보셨을 법한 용어로 말하자면,

857
00:41:00,860 --> 00:41:04,310
이 수업에서 우리가 의미하는 것은
AVL 트리 집합을 뜻합니다.

858
00:41:04,310 --> 00:41:08,240
자, 때때로
사람들이

859
00:41:08,240 --> 00:41:12,500
이진 검색 트리라고 부르는 것은
균형 의미론을 갖지 않습니다.

860
00:41:12,500 --> 00:41:16,190
그래서
이 수업에서는 그것을 집합 이진 트리라고 부를 수도 있습니다.

861
00:41:16,190 --> 00:41:20,150
하지만 사실 그것들이 유용한 이유는
균형이 잡혀 있기 때문입니다.

862
00:41:20,150 --> 00:41:22,310
그래서 우리는
보통

863
00:41:22,310 --> 00:41:24,450

여기서 균형 잡힌 것들을 이야기하고 있다고 가정할 것입니다.

864
00:41:24,450 --> 00:41:28,730
이제, 집합 AVL 트리는 키가 순서대로 정렬된
이진 검색 트리 의미론을 가지고 있습니다

865
00:41:28,730 --> 00:41:30,790
.

866
00:41:30,790 --> 00:41:32,540
이 물건들은 열쇠가 있고
순서대로 정리되어 있습니다.

867
00:41:32,540 --> 00:41:34,370
고정된 인터페이스입니다.

868
00:41:34,370 --> 00:41:36,980
반면에 우리는

869
00:41:36,980 --> 00:41:41,900
이러한
요소에 키조차 없는 순차 인터페이스를 여러분께 제시했습니다.

870
00:41:41,900 --> 00:41:45,440

집합 의미론을 거기에 어떻게 저장할 수 있을까요?

871
00:41:45,440 --> 00:41:47,060
그래서 우리가

872
00:41:47,060 --> 00:41:53,360
이진 검색
트리와, 실제로는 집합 AVL

873
00:41:53,360 --> 00:41:54,660
트리와 [알아들을 수 없는 부분]이라고 말할 때 의미하는 차이점은 바로 이것입니다.

874
00:41:54,660 --> 00:41:55,160
응?

875
00:41:55,160 --> 00:41:57,743
청중: 그럼
이걸로 AVL 트리를 만들려면,

876
00:41:57,743 --> 00:42:00,650

노드를 만들 때

877
00:42:00,650 --> 00:42:03,830

[알아들을 수 없는 부분]의 절댓값을 기준으로 키를 지정해야 한다는 뜻인가요?

878
00:42:03,830 --> 00:42:09,350
제이슨 쿠: 좋습니다.
AVL 트리를 만들 때는

879
00:42:09,350 --> 00:42:11,943

객체를 저장하는 경우

880
00:42:11,943 --> 00:42:13,610

해당 객체의 키가 무엇인지 알려주셔야 합니다.  제가 지금 하고 있는 것처럼 그냥 숫자를

881
00:42:13,610 --> 00:42:15,170
저장하는 것뿐입니다

882
00:42:15,170 --> 00:42:18,110
.

883
00:42:18,110 --> 00:42:19,970
자, 이것은 정해진 AVL 트리가 아닙니다.

884
00:42:19,970 --> 00:42:21,560
하지만 만약 제가 단순히
숫자만 저장하는 경우라면,

885
00:42:21,560 --> 00:42:25,400

제가 저장하는 항목들이 바로 키라는 것을 알려드려야 합니다.

886
00:42:25,400 --> 00:42:26,685
그리고 나서 모든 것이 따라옵니다.

887
00:42:26,685 --> 00:42:28,310
하지만

888
00:42:28,310 --> 00:42:30,750

이 방에 있는 학생들처럼 분류하려는 대상이 있다면, 그 대상은

889
00:42:30,750 --> 00:42:33,130
여러 가지 속성을 가지고 있습니다.  전화번호를 가진

890
00:42:33,130 --> 00:42:38,600
모든 사람의 정보가 필요해요.

891
00:42:38,600 --> 00:42:41,300
어쩌면
어떤 이유로든 당신의 전화번호를 알아야 할 수도 있거든요.

892
00:42:41,300 --> 00:42:44,150
그게 제가
당신이 어디 사는지 알아내는 데 도움이 될까요?

893
00:42:44,150 --> 00:42:45,680
나는… 이건
좀… 그 얘기는 하고 싶지

894
00:42:45,680 --> 00:42:47,270
않아.

895
00:42:47,270 --> 00:42:50,283
하지만 제가
AVL 트리를 하나 드린다면, 그 트리가

896
00:42:50,283 --> 00:42:51,950

무엇을 기준으로 하는지 알려드려야 합니다.

897
00:42:51,950 --> 00:42:55,790
만약 제가 여러분에게
순차 AVL 트리를 준다면, 제가

898
00:42:55,790 --> 00:42:57,920


899
00:42:57,920 --> 00:43:00,320

여러분에게 순차를 주고 있기 때문에 순회 순서가 어떻게 될지는 명백합니다.

900
00:43:00,320 --> 00:43:03,740
그게 입력값이었어요.

901
00:43:03,740 --> 00:43:05,150
이해가 되시나요?

902
00:43:05,150 --> 00:43:10,250
좋습니다. 제게는
크기가 log n인 AVL 트리 세트가 있습니다.

903
00:43:10,250 --> 00:43:12,678
어떤 기준으로 키를 눌러야 할까요?

904
00:43:12,678 --> 00:43:13,720
청중: 절대값.

905
00:43:13,720 --> 00:43:15,920
제이슨 쿠:
그들의 선호도,

906
00:43:15,920 --> 00:43:18,100
또는 의견의 절대적인 가치.

907
00:43:18,100 --> 00:43:20,770

이게 뭐라고 불리는지 기억이 안 나네요.

908
00:43:20,770 --> 00:43:23,490
그런데 여기에 어떤 로그 n가지 물건을
넣어야 하죠?  모르겠습니다

909
00:43:28,240 --> 00:43:30,550
.

910
00:43:30,550 --> 00:43:32,260
저는
이런 것들에 대해 아무것도 몰라요.

911
00:43:32,260 --> 00:43:35,270
어떤 점이 하나를
다른 하나보다 더 낫게 만드는 걸까요?  먼저

912
00:43:35,270 --> 00:43:37,900

첫 번째 통나무를 몇 개 놓겠습니다.

913
00:43:37,900 --> 00:43:39,680
이해가 되시나요?

914
00:43:39,680 --> 00:43:40,180
괜찮은.  그것은

915
00:43:40,180 --> 00:43:43,900
내게 무엇을 알려줄 수 있을까?  자

916
00:43:43,900 --> 00:43:45,490
, 이제 이걸 안에 넣었어요.

917
00:43:45,490 --> 00:43:47,811
그거 만드는데 얼마나 걸렸어요?

918
00:43:47,811 --> 00:43:49,640
청중: [잘 안 들림]

919
00:43:49,640 --> 00:43:55,760
제이슨 쿠: 로그 n 곱하기 로그
로그 n 곱하기, 맞죠?

920
00:43:55,760 --> 00:43:58,520
하지만 그건
우리가 원하는 상영 시간보다 훨씬 짧으니까

921
00:43:58,520 --> 00:44:01,800
,
저는 별로 상관없어요.

922
00:44:01,800 --> 00:44:04,760
그러니까,
얼마나 걸렸는지 말해줬으면 좋겠지만,

923
00:44:04,760 --> 00:44:06,527
제 목적상 제가

924
00:44:06,527 --> 00:44:08,360

원하는 실행 시간보다 짧다는 것만 알면 됩니다.

925
00:44:08,360 --> 00:44:10,160
그리고 저는 그 수술을 한 번 받았습니다.  이제는 더 이상

926
00:44:10,160 --> 00:44:12,140
신경 쓰지 않아요
.

927
00:44:12,140 --> 00:44:12,860
응?

928
00:44:12,860 --> 00:44:14,720
청중:
log n 곱하기 log log n은 어떻게 나온 건가요?

929
00:44:14,720 --> 00:44:16,303
제이슨 쿠: 왜냐하면

930
00:44:16,303 --> 00:44:19,110
제가 이 장치에 저장하는 것들의 개수는
log n이기 때문입니다.

931
00:44:19,110 --> 00:44:24,050
그래서
AVL 트리의 빌드 시간을 패턴 매칭하고

932
00:44:24,050 --> 00:44:29,870
거기에 log n을 넣으면,
그 값은 log n 곱하기 log n이 됩니다.

933
00:44:29,870 --> 00:44:31,220
좋아요.

934
00:44:31,220 --> 00:44:33,440
청중: 그럼 그건
단 한 번의 반복에 대한 결과라는 건가요?

935
00:44:33,440 --> 00:44:36,920
제이슨 쿠: 네, 방금
이 장치를 만들었어요.

936
00:44:36,920 --> 00:44:40,460
아마도요. 제가 딱 한 번 만들어 봤거든요.  저는 어쩌면

937
00:44:40,460 --> 00:44:44,630

그것을 다시 만들 필요가 없을지도 모른다고 주장하고 있습니다.

938
00:44:44,630 --> 00:44:47,660
내가 뭘 할 수 있었을까... 그러니까 이제는
알아. 난

939
00:44:47,660 --> 00:44:51,290

데이터를 전혀 필터링하지 않았어.

940
00:44:51,290 --> 00:44:55,660
저는 이 물건들을
어떤 식으로든 정렬된 순서대로 보관하고 있을 뿐입니다.  나머지 데이터를 처리하기

941
00:44:55,660 --> 00:44:59,780
위해 제가 할 수 있는 일은 무엇일까요

942
00:44:59,780 --> 00:45:01,670
?

943
00:45:01,670 --> 00:45:02,360
응?

944
00:45:02,360 --> 00:45:06,490
청중: [잘 안 들림]
목록 A를 스크롤해서 더 큰

945
00:45:06,490 --> 00:45:09,830
사람을 찾아보세요.

946
00:45:09,830 --> 00:45:13,430

최대한 [잘 안 들림]을 유지하려고 노력하세요.

947
00:45:13,430 --> 00:45:16,100
제이슨 쿠: 이 사람을 훑어보면서 이것
저것 삽입하고,

948
00:45:16,100 --> 00:45:18,980
항상 유지하면, 제가 그렇게 계속 이것저것 넣으면

949
00:45:18,980 --> 00:45:20,990


950
00:45:20,990 --> 00:45:23,490

마지막에는 이렇게 정리된 상태가 될 거예요.

951
00:45:23,490 --> 00:45:28,910
이제 저는 가장 중요한 몇 가지
사항만 읽어낼 수 있습니다.

952
00:45:28,910 --> 00:45:33,290
하지만
여기에 뭔가를 끼워 넣다 보니

953
00:45:33,290 --> 00:45:34,610
제 것이 점점 커지고 있어요.

954
00:45:34,610 --> 00:45:35,810
청중: 그럼, 제일
작은 것만 지우면 되겠네요.

955
00:45:35,810 --> 00:45:37,185
제이슨 쿠: 아,
사소한 것들을 삭제하세요.

956
00:45:37,185 --> 00:45:38,293
그 아이디어 마음에 드네요.

957
00:45:38,293 --> 00:45:39,710
청중: 그러니까
기본적으로 교체하라는 말씀이시군요.

958
00:45:39,710 --> 00:45:40,940
제이슨 쿠: 네,
기본적으로 교체하는 거죠.

959
00:45:40,940 --> 00:45:41,630
오른쪽.

960
00:45:41,630 --> 00:45:43,010
제가 하려는 일은 이렇습니다.

961
00:45:43,010 --> 00:45:44,810
제안 하나 드리겠습니다.

962
00:45:44,810 --> 00:45:49,070

다음 선수를 받아서 넣자.

963
00:45:49,070 --> 00:45:51,520
멋지다.

964
00:45:51,520 --> 00:45:54,010

지금 내가 신경 안 쓰는 건 어느 걸까?  저기 있는 것 중에 제일

965
00:45:54,010 --> 00:45:55,600
작은 거야.

966
00:45:55,600 --> 00:45:57,850
그러니 가장 작은 것부터 내쫓으세요.

967
00:45:57,850 --> 00:46:00,100
이건 제가
5월에 올린 거예요.  가장

968
00:46:00,100 --> 00:46:01,550
작아지세요.

969
00:46:01,550 --> 00:46:03,580
그래서 그냥
이 기계에 통과시켰는데, 시간이

970
00:46:03,580 --> 00:46:05,300
얼마나 걸렸을까요?  저

971
00:46:10,032 --> 00:46:11,490

나무 높이만큼 걸렸어요.

972
00:46:11,490 --> 00:46:12,195
이 나무의 높이는 얼마입니까?

973
00:46:12,195 --> 00:46:13,070
청중: [잘 안 들림]

974
00:46:13,070 --> 00:46:15,300
제이슨 쿠: 로그 로그 n.

975
00:46:15,300 --> 00:46:18,570
그래서 하나를 넣고,
하나를 빼냈어요.

976
00:46:18,570 --> 00:46:20,638
저게 제일 작은 거죠?

977
00:46:20,638 --> 00:46:22,680
그리고 저는 그 과정을 처음부터 끝까지 계속 그렇게 합니다
.

978
00:46:22,680 --> 00:46:23,763
그거 만드는데 얼마나 걸렸지?

979
00:46:23,763 --> 00:46:25,070
JASON KU: [들리지 않음]

980
00:46:28,415 --> 00:46:29,040
JASON KU: 네.  n에서

981
00:46:29,040 --> 00:46:34,890
log n을 뺀 값
, 즉 기본적으로 n개의 작업을 처리합니다.

982
00:46:34,890 --> 00:46:37,230
그리고 그 모든
작업에

983
00:46:37,230 --> 00:46:39,120
나무 높이만큼의 시간이 걸렸습니다.

984
00:46:39,120 --> 00:46:40,920
그러면
우리가 찾고 있는 실행 시간, 즉

985
00:46:40,920 --> 00:46:45,960
n log log n이 나옵니다.

986
00:46:45,960 --> 00:46:46,500
감각?

987
00:46:46,500 --> 00:46:48,840
청중: 이거 마치
미닫이창 기법을 떠올리게 하지 않나요?

988
00:46:48,840 --> 00:46:48,960
제이슨 쿠: 네.

989
00:46:48,960 --> 00:46:50,760
이건 마치 미닫이
창 기법과 같아요.

990
00:46:50,760 --> 00:46:53,100

최근에 하나를 사용했을 수도 있습니다.

991
00:46:56,470 --> 00:46:56,970
좋아요.

992
00:46:56,970 --> 00:46:58,322
모두 괜찮으신가요?

993
00:46:58,322 --> 00:46:58,858
응?

994
00:46:58,858 --> 00:47:00,900
청중: 지금

995
00:47:00,900 --> 00:47:05,170
우리가 이야기하고 있는 맥락이 log
log n, 예를 들어 나무 같은 거랑 관련해서 어떤 의미인지 다시 한번 설명해 주시겠어요?

996
00:47:05,170 --> 00:47:07,170
제이슨 쿠: 그러니까
이 물체의 크기가

997
00:47:07,170 --> 00:47:08,495
log log n이라는 거죠?

998
00:47:08,495 --> 00:47:09,120
청중: 네.

999
00:47:09,120 --> 00:47:10,453
제이슨 쿠: 그러니까... 죄송합니다, 로그 n.

1000
00:47:10,453 --> 00:47:15,438
그리고 이것의 높이는
통나무만 합니다.

1001
00:47:15,438 --> 00:47:19,065
관객: 죄송합니다만,
저희 작은 통나무 크기

1002
00:47:19,065 --> 00:47:25,270
[잘 안 들림] 작은
통나무 나무와 관련해서 말씀드린 건데, 아니면...

1003
00:47:25,270 --> 00:47:27,150
제이슨 쿠: 아니요, 죄송합니다.

1004
00:47:27,150 --> 00:47:29,790
저는 이 자료들을 가져오고 있는데,

1005
00:47:29,790 --> 00:47:32,040

여기에는 중간 데이터 구조가 없습니다. 그냥

1006
00:47:32,040 --> 00:47:37,105

이 모든 것들을 AVL 세트에 넣고 있습니다.

1007
00:47:37,105 --> 00:47:37,605
응?

1008
00:47:37,605 --> 00:47:39,030
청중: [잘 안 들림]

1009
00:47:39,030 --> 00:47:43,200
제이슨 쿠:
크기가 log n인 하나의 AVL 세트로.

1010
00:47:43,200 --> 00:47:48,497
나는 한 남자를 집어넣고, 가장 형편
없는 남자를 밖으로 뱉어내는 거야.

1011
00:47:48,497 --> 00:47:49,830
모든 것을 하나하나 살펴보고 있습니다.

1012
00:47:49,830 --> 00:47:52,410

삽입할 때

1013
00:47:52,410 --> 00:47:55,740

어떤 리벤저인지 정확히 확인하고, 절댓값을 제대로

1014
00:47:55,740 --> 00:47:57,720
계산하는지 등 세세한 부분까지 신경 써야 해요

1015
00:47:57,720 --> 00:48:00,450

.

1016
00:48:00,450 --> 00:48:02,250
하지만 그게 기본적인 아이디어입니다.

1017
00:48:02,250 --> 00:48:05,730
저는 그냥 이걸 가져가는 거예요.
창문을 안으로 밀어 넣고,

1018
00:48:05,730 --> 00:48:07,830
뭔가를 넣고,
뭔가를 꺼내는 거죠. 그게

1019
00:48:07,830 --> 00:48:11,460

같은 것일 수도 있고 아닐 수도 있고, 아마 아닐 거예요.

1020
00:48:11,460 --> 00:48:14,490
그리고 이 절차의 마지막에

1021
00:48:14,490 --> 00:48:17,070
제가 유지하려는 불변 조건은

1022
00:48:17,070 --> 00:48:23,730
제 항목이 지금까지 처리한 항목들 중에서 항상
가장 많은 k개의 의견을 가지고 있다는 것입니다

1023
00:48:23,730 --> 00:48:24,925
.

1024
00:48:24,925 --> 00:48:26,550

처음

1025
00:48:26,550 --> 00:48:27,930
이 시스템을 구축할 때는 당연히 그랬죠.

1026
00:48:27,930 --> 00:48:31,320
그리고 마지막에 이르면
모든 것을 처리하게 되는데, 그

1027
00:48:31,320 --> 00:48:38,310
크기는 log n이 됩니다.
따라서 저는 log n개의

1028
00:48:38,310 --> 00:48:41,730
가장 극단적인 의견들을 갖게 되는 것입니다.

1029
00:48:41,730 --> 00:48:43,990
그런 다음

1030
00:48:43,990 --> 00:48:46,140
이 항목을 중위 순회하고 반환하면 됩니다.

1031
00:48:46,140 --> 00:48:47,290
이해가 되시나요?

1032
00:48:47,290 --> 00:48:50,130
그리고 저는
로그 공간만 사용해 왔습니다.

1033
00:48:53,210 --> 00:48:53,710
응?

1034
00:48:53,710 --> 00:48:55,002
관객: 잠깐, 무슨 말인지 모르겠어요.

1035
00:48:55,002 --> 00:49:00,090

AVL 트리에 있는 의견들이 전부인가요?

1036
00:49:00,090 --> 00:49:02,340
제이슨 쿠:
AVL 트리에 모든 의견이 다 들어 있는 건가요?

1037
00:49:02,340 --> 00:49:05,520
이 모든 의견은
AVL 트리에 있습니다.

1038
00:49:05,520 --> 00:49:12,180
그리고 언젠가는
모든 의견을

1039
00:49:12,180 --> 00:49:14,040
이 AVL 트리 구조에 삽입할 것입니다.

1040
00:49:14,040 --> 00:49:17,640
하지만 앞으로
관심 없는 것들은 하나씩 삭제해 나갈 거예요

1041
00:49:17,640 --> 00:49:18,223
.

1042
00:49:18,223 --> 00:49:19,140
이해가 되시나요?

1043
00:49:19,140 --> 00:49:22,860
저는 항상

1044
00:49:22,860 --> 00:49:26,010

무언가를 삽입하기 전에

1045
00:49:26,010 --> 00:49:29,100

그 안에 정확히 log n개의 항목이 있다는 불변 조건을 유지하고, 하나를 넣고 하나를 빼는 과정을

1046
00:49:29,100 --> 00:49:31,890
통해 그 불변 조건을 유지합니다

1047
00:49:31,890 --> 00:49:32,530
.

1048
00:49:32,530 --> 00:49:35,178
청중: 아, 그렇군요. 그럼
어떤 걸 삭제하시는 거예요?

1049
00:49:35,178 --> 00:49:36,720
제이슨 쿠: 항상
최소 사이즈를 고릅니다. 왜냐하면 저는

1050
00:49:36,720 --> 00:49:38,667
가장 큰 사이즈를 원하거든요.

1051
00:49:38,667 --> 00:49:40,500
청중: 그리고
절댓값의 최솟값.

1052
00:49:40,500 --> 00:49:42,330
제이슨 쿠: 네.

1053
00:49:42,330 --> 00:49:45,210
저는
이 의견들의 절댓값을 기준으로 평가하고 있습니다.

1054
00:49:45,210 --> 00:49:45,710
응?

1055
00:49:45,710 --> 00:49:48,510
청중: [잘 안 들림]?

1056
00:49:48,510 --> 00:49:51,390
제이슨 쿠: 총 재생 시간은 얼마나 되나요?

1057
00:49:51,390 --> 00:49:52,830
회계 장부 정리입니다.  처음에 이 데이터 구조를 구축하는 데

1058
00:49:52,830 --> 00:50:01,470
log n 곱하기
log log n 시간이 걸렸고, 거기에

1059
00:50:01,470 --> 00:50:05,430


1060
00:50:05,430 --> 00:50:11,040
n 곱하기 log log n 시간이 더해졌습니다.

1061
00:50:11,040 --> 00:50:15,510
기본적으로 n번의 연산을 수행했습니다. 점근
적으로는 n번의 연산을 수행한 셈입니다.

1062
00:50:15,510 --> 00:50:19,620
이렇게 하면 실제로는
n에서 log n을 뺀 연산이 됩니다.

1063
00:50:19,620 --> 00:50:22,740
그리고
트리를 구성하는 각각의 작업, 즉

1064
00:50:22,740 --> 00:50:25,350
삽입 하나, 삭제 하나마다

1065
00:50:25,350 --> 00:50:28,750

트리 높이만큼의 시간이 소요되었습니다.

1066
00:50:28,750 --> 00:50:31,440
그래서 이것으로 끝입니다.

1067
00:50:31,440 --> 00:50:32,820
좋은?

1068
00:50:32,820 --> 00:50:33,420
응?

1069
00:50:33,420 --> 00:50:36,249
청중: 만약 한 번이 아니라
삽입과 삭제만 한다면, 비교를 할 수 있나요?

1070
00:50:39,030 --> 00:50:42,720
제이슨 쿠: AVL 트리 집합에서
삽입과 삭제는

1071
00:50:42,720 --> 00:50:45,930

실제로

1072
00:50:45,930 --> 00:50:47,070
데이터 구조 내에서 비교를 수행하는 것입니다.

1073
00:50:47,070 --> 00:50:47,910
청중:
최소값과 비교해 보세요.

1074
00:50:47,910 --> 00:50:48,410
그리고 나서—

1075
00:50:48,410 --> 00:50:50,490
제이슨 쿠: 물론 그렇게 하셔도 됩니다
.

1076
00:50:50,490 --> 00:50:52,410
다른 방법으로도 할 수 있어요.  우선 가장 작은 요소부터

1077
00:50:52,410 --> 00:50:56,790
제거해 볼 수 있겠죠

1078
00:50:56,790 --> 00:50:58,860
?

1079
00:50:58,860 --> 00:51:00,870
그런 다음
이 사람과 비교해 보고, 더

1080
00:51:00,870 --> 00:51:04,370

큰 쪽을 다시 집어넣습니다.

1081
00:51:04,370 --> 00:51:06,160
똑같은 방식입니다.

1082
00:51:06,160 --> 00:51:09,260
삭제를
먼저 하고 삽입을 해야 하는지,

1083
00:51:09,260 --> 00:51:12,940
아니면 삽입을
먼저 하고 삭제를 해야 하는지가 헷갈리네요.

1084
00:51:12,940 --> 00:51:14,830
다른 질문 있으신가요?

1085
00:51:14,830 --> 00:51:15,590
질문이 많네요.

1086
00:51:15,590 --> 00:51:16,090
괜찮은.

1087
00:51:16,090 --> 00:51:18,940
음, 아마
문제 하나는 건너뛰어야 할 것 같네요.  이제

1088
00:51:18,940 --> 00:51:22,060
CS로 넘어가겠습니다.

1089
00:51:22,060 --> 00:51:23,530
아니, SCLR로 넘어가죠.

1090
00:51:27,040 --> 00:51:28,396
여기서 말하는 참고 자료는 무엇인가요?

1091
00:51:28,396 --> 00:51:30,100
관객: [잘 안 들림]

1092
00:51:30,100 --> 00:51:32,230
제이슨 쿠: 네, 클라스.

1093
00:51:32,230 --> 00:51:34,630
이들은 컴퓨터 과학 분야에서
인기 있는 교과서를 쓴 네 명의 학자입니다

1094
00:51:34,630 --> 00:51:37,520
.

1095
00:51:37,520 --> 00:51:39,880
이것도 같은 종류의 일이에요
.

1096
00:51:39,880 --> 00:51:44,770
그들은 초판본들을 발견했고,
그것들을 경매에 부치고 싶어합니다.

1097
00:51:44,770 --> 00:51:46,553
사람들은
그들의 웹사이트에 접속할 수 있습니다.

1098
00:51:46,553 --> 00:51:47,470
그들은 입찰자 ID를 가지고 있습니다.

1099
00:51:47,470 --> 00:51:49,900
고유 식별자입니다.

1100
00:51:49,900 --> 00:51:53,830
그리고 그들은
이 책들 중 하나에 입찰할 수 있습니다.  입찰 기간 동안에는

1101
00:51:53,830 --> 00:51:57,400
가격을 변경할 수 있지만,

1102
00:51:57,400 --> 00:52:00,640

입찰 기간이 끝나면

1103
00:52:00,640 --> 00:52:06,112
학계 관계자들은 최고 입찰자 k명에게 판매했을 때

1104
00:52:06,112 --> 00:52:08,080
예상되는
수익이 얼마인지 알고 싶어합니다.

1105
00:52:08,080 --> 00:52:10,060


1106
00:52:10,060 --> 00:52:13,470
이해가 되시나요?

1107
00:52:13,470 --> 00:52:15,930
응?

1108
00:52:15,930 --> 00:52:16,590
좋아요.

1109
00:52:16,590 --> 00:52:22,560
참고로,
이 데이터 구조를 만들기 전에

1110
00:52:22,560 --> 00:52:24,690
저는 k가 무엇인지 알고 있습니다.
k는 고정된 값입니다.

1111
00:52:27,360 --> 00:52:31,230
이 수익 가져오기 작업의 실행 시간이 이
k 값에 따라 달라지기 때문에, k 값은

1112
00:52:31,230 --> 00:52:34,470

해당 작업의 입력값이 아닙니다.

1113
00:52:34,470 --> 00:52:37,530
그래서 k는 솔직히 뭔지 잘
모르겠어요.

1114
00:52:37,530 --> 00:52:39,630
n/2일 수도 있고,

1115
00:52:39,630 --> 00:52:42,180
log n일 수도 있습니다.

1116
00:52:42,180 --> 00:52:43,590
1일 수도 있습니다.

1117
00:52:46,560 --> 00:52:48,540
하지만
제가 구축해야 하는 데이터 구조는 학자들이 제시한 k 값과 관계없이

1118
00:52:48,540 --> 00:52:50,940
이러한
실행 시간 속성을 만족해야 합니다

1119
00:52:50,940 --> 00:52:55,330

.

1120
00:52:55,330 --> 00:52:57,900
이해가 되시나요?

1121
00:52:57,900 --> 00:53:03,090
제가 해야 할 일은
시간이 지남에 따라

1122
00:53:03,090 --> 00:53:07,920
사람들이 새로운 입찰을 하고
입찰가를 업데이트하는 것입니다.

1123
00:53:07,920 --> 00:53:11,890
그리고 그러한 업데이트는 매우
오랜 시간이 걸릴 수 있습니다.

1124
00:53:11,890 --> 00:53:14,640
하지만
창을 닫는 순간,

1125
00:53:14,640 --> 00:53:21,250


1126
00:53:21,250 --> 00:53:24,670
최고 입찰자가 누구인지 실시간으로 알 수 있기를 바랍니다.

1127
00:53:24,670 --> 00:53:26,460
이 문제를 해결할 방법을 아시는 분 계신가요?  제가 해야 할

1128
00:53:26,460 --> 00:53:28,210
작업은 무엇인가요
?

1129
00:53:28,210 --> 00:53:32,920

새로운 입찰을 할 수 있어야 합니다.

1130
00:53:32,920 --> 00:53:37,690
입찰자에게는
아이디어와 입찰 금액이 연결되어 있는데, 이 입찰 금액은

1131
00:53:37,690 --> 00:53:39,440
정수입니다. 즉,

1132
00:53:39,440 --> 00:53:41,440
제가
이 책을 사기 위해 얼마를 지불할 것인지를 나타냅니다.

1133
00:53:44,050 --> 00:53:45,700
입찰가를 업데이트하세요.

1134
00:53:45,700 --> 00:53:48,460
어떤 의미에서, 저는 제 데이터 구조에서
그 사람이

1135
00:53:48,460 --> 00:53:51,830
이전에 입찰을 했는지 여부를 찾아야 합니다
.

1136
00:53:51,830 --> 00:53:54,700
그래서 언젠가는
입찰자 ID를 찾아야 할 것 같아요.

1137
00:53:54,700 --> 00:53:57,500
그게 가능해 보이나요?

1138
00:53:57,500 --> 00:53:59,800
그래서

1139
00:53:59,800 --> 00:54:01,930
입찰자 ID에 대한 일종의 사전 같은 것을 만들어두고 싶을 수도 있습니다.  제가

1140
00:54:01,930 --> 00:54:05,260

어떤 것에 대한 딕셔너리를 만들고 싶다고 말할 때,

1141
00:54:05,260 --> 00:54:08,800

아직

1142
00:54:08,800 --> 00:54:11,080

그 딕셔너리를 어떻게 구현할지 구체적으로 말씀드리는 건 아니죠.

1143
00:54:11,080 --> 00:54:13,015
제가 일반적으로 선택할 수 있는 옵션은 무엇인가요?

1144
00:54:13,015 --> 00:54:14,780
해시 테이블.

1145
00:54:14,780 --> 00:54:16,750
하지만
최악의 경우를 대비한 시간이 필요하다면 어떻게 해야 할까요?

1146
00:54:19,390 --> 00:54:21,120
AVL 트리 세트 맞죠?

1147
00:54:21,120 --> 00:54:23,740
그게 바로 당신이
사전을 찾을 때 가장 먼저 참고하게 될 거예요.

1148
00:54:23,740 --> 00:54:26,115
왜냐하면 그걸 이용하면 키를 통해 원하는
걸 찾는 데 엄청난 시간이 걸릴 테니까요

1149
00:54:26,115 --> 00:54:28,620
.

1150
00:54:28,620 --> 00:54:31,560
그게 유일한 방법이에요.

1151
00:54:31,560 --> 00:54:33,870

정렬된 배열을 사용하는 것도 가능

1152
00:54:33,870 --> 00:54:36,180
하지만, 그러면
동적으로 정렬되지 않겠죠.

1153
00:54:36,180 --> 00:54:38,700
그리고 여기서는
내 데이터 구조에 있는 사람들을 계속해서 업데이트하고 있습니다

1154
00:54:38,700 --> 00:54:39,780
.

1155
00:54:39,780 --> 00:54:43,850
사람들이 들어와서
입찰을 하고 있습니다.

1156
00:54:43,850 --> 00:54:45,120
새로운 사람들이 입찰에 참여하고 있어요.

1157
00:54:45,120 --> 00:54:47,280
그래서 제가 중요하게 생각하는 것들은 끊임없이

1158
00:54:47,280 --> 00:54:48,572
변하고 있어요.

1159
00:54:48,572 --> 00:54:50,280
그래서 아마도
저는

1160
00:54:50,280 --> 00:54:52,440
정렬된 배열을 사용하지 않게 될 것 같습니다. 정렬된 배열은

1161
00:54:52,440 --> 00:54:55,920
동적 연산에 적합하지 않기 때문입니다.

1162
00:54:55,920 --> 00:54:59,610
그래서
입찰자 ID를 저장하는 일종의 딕셔너리가 필요할 뿐만

1163
00:54:59,610 --> 00:55:06,120
아니라, 최고 입찰자
k명의 합계도 유지해야 합니다

1164
00:55:06,120 --> 00:55:06,810
.

1165
00:55:06,810 --> 00:55:08,710
이해가 되시나요?

1166
00:55:08,710 --> 00:55:10,650
그래서 어떤
의미에서는

1167
00:55:10,650 --> 00:55:18,878


1168
00:55:18,878 --> 00:55:19,920
내 데이터 구조에 있는 입찰자들과 입찰들을 순서대로 정리해서 관리해야 합니다.

1169
00:55:19,920 --> 00:55:22,080
이해가 되시나요?

1170
00:55:22,080 --> 00:55:24,460
그러므로
입찰 순서가 중요할 것입니다.

1171
00:55:24,460 --> 00:55:28,410

입찰자 ID를 조회해야 할 것 같습니다.  그게 전부죠

1172
00:55:28,410 --> 00:55:31,330
, 그렇죠?

1173
00:55:31,330 --> 00:55:31,830
좋아요.

1174
00:55:31,830 --> 00:55:32,100
응?

1175
00:55:32,100 --> 00:55:32,670
청중: 확인차 여쭤보는 거예요.

1176
00:55:32,670 --> 00:55:34,045
그러니까
최악의 상황에서

1177
00:55:34,045 --> 00:55:38,550
최악의 시간에 실행된다면
예상대로 실행되는 거죠. [잘 안 들림]..

1178
00:55:38,550 --> 00:55:39,150
제이슨 쿠: 네.

1179
00:55:39,150 --> 00:55:40,260
옳은.

1180
00:55:40,260 --> 00:55:42,390
응.

1181
00:55:42,390 --> 00:55:44,190
정말 훌륭한 지적입니다.

1182
00:55:44,190 --> 00:55:46,590
최악의 경우에 걸리는 시간이라면
,

1183
00:55:46,590 --> 00:55:47,972
예상되는 시간에도 걸리는 거겠죠?

1184
00:55:47,972 --> 00:55:49,805
왜냐하면

1185
00:55:49,805 --> 00:55:51,650
제가 여기서 말하는 무작위성은 사실상 존재하지 않기 때문입니다.

1186
00:55:51,650 --> 00:55:54,620
청중: [잘 안 들림]?

1187
00:55:54,620 --> 00:55:55,450
제이슨 쿠: 네.

1188
00:55:55,450 --> 00:55:58,890
그래서 저희가
여러분께서 명확히 해주시기를 바라는 더 중요한 개념이 있는데, 그것은

1189
00:55:58,890 --> 00:56:01,770
실제로는
여기에 무작위화가 없다는 것입니다.

1190
00:56:01,770 --> 00:56:04,260
저희는 해시 테이블을 사용하지 않습니다.

1191
00:56:04,260 --> 00:56:07,973
이 수업에서는, 사실상

1192
00:56:07,973 --> 00:56:09,140
그게 문제가 될 수 있는 유일한 상황이에요.

1193
00:56:11,880 --> 00:56:16,450
하지만 만약 그렇다면, 이 문제가
각 [알아들을 수 없는 부분]에 대해 말하는 것은,

1194
00:56:16,450 --> 00:56:19,170
실행 시간이
최악의 경우 예상 시간인지 또는 상각

1195
00:56:19,170 --> 00:56:22,350
된 시간인지 여부와 관계없이, 우리가 실제로
여러분에게 묻고 싶은 것은

1196
00:56:26,220 --> 00:56:28,170


1197
00:56:28,170 --> 00:56:30,840
적절한 조건을 고려하여 알고리즘의 실행 시간을 평가하는 것입니다.

1198
00:56:30,840 --> 00:56:32,280
최악의
상황이 발생했다면,

1199
00:56:32,280 --> 00:56:35,030
최악의 상황이 발생했다고 말해 주세요.

1200
00:56:35,030 --> 00:56:38,300
만약 시간이 걸렸다면, 즉
해시 테이블을 사용했다면,

1201
00:56:38,300 --> 00:56:39,620
예상했던 시간이라고 말해 주세요.

1202
00:56:39,620 --> 00:56:43,850
그리고 이러한 작업들이
때때로 정말 형편없더라도

1203
00:56:43,850 --> 00:56:46,430
평균적으로는 정말
훌륭하다면, 제가 그런 작업을 많이 했다면

1204
00:56:46,430 --> 00:56:49,550
그 손실은 상각될 것입니다.

1205
00:56:49,550 --> 00:56:53,180
혹은
동적 배열을 사용

1206
00:56:53,180 --> 00:56:54,920
하거나
해시 테이블을 사용하더라도,

1207
00:56:54,920 --> 00:56:59,530
그러한 동적 연산은
여전히 ​​비용 상각이 가능합니다.

1208
00:56:59,530 --> 00:57:00,350
좋아요.

1209
00:57:00,350 --> 00:57:01,700
역동적인 사람들.

1210
00:57:01,700 --> 00:57:04,520

연결된 데이터 구조의 장점은

1211
00:57:04,520 --> 00:57:07,148
동적 연산에 대한
비용 상각이 필요 없다는 것입니다.

1212
00:57:07,148 --> 00:57:08,690
그래서 우리는
하나를 구할 수 있을 거예요.

1213
00:57:08,690 --> 00:57:12,080
자, 이 문제의 경우
최악의 경우 경계값을 구할 수 있으므로, 그렇게 해보겠습니다

1214
00:57:12,080 --> 00:57:13,860
.

1215
00:57:13,860 --> 00:57:16,700
예상되는 방식으로
해시 테이블을 사용하여

1216
00:57:16,700 --> 00:57:20,240
해당 사전을 처리할 수도 있습니다.

1217
00:57:20,240 --> 00:57:21,710


1218
00:57:21,710 --> 00:57:26,630
이 수업에서 자료구조 문제를 풀 때는

1219
00:57:26,630 --> 00:57:30,800

우선 무엇을 저장하는지 명확히 밝혀야 합니다.  저 요소들에는

1220
00:57:30,800 --> 00:57:34,300
어떤 것들이 있어야 하는지 알려주세요.

1221
00:57:34,300 --> 00:57:35,970


1222
00:57:35,970 --> 00:57:40,520

나중에 쿼리를 실행할 때

1223
00:57:40,520 --> 00:57:42,560
이러한 요소들이
유지되도록 데이터 구조에 대한 불변 조건 같은 것들이요. 예를 들어

1224
00:57:42,560 --> 00:57:49,520

정렬된 배열을 유지하고

1225
00:57:49,520 --> 00:57:52,070

최댓값을 찾는 연산을 지원해야 한다면,

1226
00:57:52,850 --> 00:57:54,380

이 데이터 구조에 어떤 작업을 하든 배열이

1227
00:57:54,380 --> 00:57:56,448


1228
00:57:56,448 --> 00:57:57,990

정렬된 상태를 유지하고

1229
00:57:57,990 --> 00:58:00,620
마지막 요소가
최댓값을 갖도록 해야 한다는 거죠.

1230
00:58:00,620 --> 00:58:03,770
제 최대 반환
값이

1231
00:58:03,770 --> 00:58:05,540
거기에서 나와서 그 값을 반환할 것이기 때문입니다.

1232
00:58:05,540 --> 00:58:07,290
이해가 되시나요?

1233
00:58:07,290 --> 00:58:10,520
그러니까

1234
00:58:10,520 --> 00:58:13,280

데이터 구조에서 특정 시점에 어떤 값이 저장되고 유지되는지

1235
00:58:13,280 --> 00:58:15,860
, 그리고

1236
00:58:15,860 --> 00:58:20,060

동적 연산이나 쿼리를 지원할 때, 즉 데이터를

1237
00:58:20,060 --> 00:58:23,630

삽입하거나 빼낼 때

1238
00:58:23,630 --> 00:58:26,180


1239
00:58:26,180 --> 00:58:28,508
이러한 불변 조건을 유지해야 한다는 것을 알려주시겠다는 말씀이시죠?

1240
00:58:28,508 --> 00:58:30,050
그리고 제가 쿼리를 실행할 때,
실제로

1241
00:58:30,050 --> 00:58:34,250
그러한 불변 조건들을 믿고
쿼리에 대한 답을 얻을 수 있습니다.

1242
00:58:34,250 --> 00:58:36,380
이해가 되시나요?

1243
00:58:36,380 --> 00:58:40,030
자, 이
문제의 경우 답은 4-3입니다.

1244
00:58:43,830 --> 00:58:45,410
아이디어 있으신가요?  제가 다뤄야 할

1245
00:58:45,410 --> 00:58:50,030
열쇠 종류가 두 가지 있습니다
.

1246
00:58:50,030 --> 00:58:55,520
하나는 입찰 ID이고,
하나는 입찰 금액이죠, 그렇죠?

1247
00:58:55,520 --> 00:59:00,380
만약 제가 두 개의
키를 가지고 있는데,

1248
00:59:00,380 --> 00:59:03,620
하나는 기준으로 정렬하고
다른 하나는 기준으로 조회하고 싶다면,

1249
00:59:03,620 --> 00:59:06,187
얼마나 많은 데이터 구조를
사용해야 할까요?

1250
00:59:06,187 --> 00:59:06,770
관객 수: 두 명.

1251
00:59:06,770 --> 00:59:07,353
제이슨 쿠: 둘.

1252
00:59:07,353 --> 00:59:10,130
꽤 정확한 추측이네요.

1253
00:59:10,130 --> 00:59:11,510
그럼 그중 한 명은… 그냥

1254
00:59:11,510 --> 00:59:12,860
추측해 볼까요?

1255
00:59:12,860 --> 00:59:15,920

입찰 정보를 조회해야 하므로,

1256
00:59:15,920 --> 00:59:24,110
입찰자들을
일종의 딕셔너리에 저장하여

1257
00:59:24,110 --> 00:59:26,540

빠르게 검색할 수 있도록 해야 합니다.

1258
00:59:26,540 --> 00:59:28,880
그래서 두 가지 데이터 구조가 있습니다.

1259
00:59:28,880 --> 00:59:41,222
하나는
입찰자 ID를 키로 하는 사전입니다.

1260
00:59:44,990 --> 00:59:47,890
내가 또 뭘 원하겠어?

1261
00:59:47,890 --> 00:59:48,390
무슨 일이야?

1262
00:59:52,330 --> 00:59:56,380
반대로,
입찰 정보에 사전이 저장된다는 말인가요?

1263
00:59:56,380 --> 00:59:57,910

내가 여기서 원하는 건 사전인가요?

1264
00:59:57,910 --> 01:00:01,480
청중: [잘 안 들림]
AVL 트리 설정 [잘 안 들림]??

1265
01:00:01,480 --> 01:00:03,490
제이슨 쿠:
어떻게든 질서를 유지하고 싶어요.  지금까지

1266
01:00:03,490 --> 01:00:06,250


1267
01:00:06,250 --> 01:00:07,780
제가 보고 경험한 가장 중요한 것들을 그대로 유지하고 싶기 때문입니다.

1268
01:00:07,780 --> 01:00:12,102
지금 만약 제가 그런 상황을 겪게 된다면
, 언젠가는

1269
01:00:12,102 --> 01:00:13,060
무슨 일이 일어날까요?

1270
01:00:13,060 --> 01:00:16,780
만약 제가
특정 시점에 가장 높은 입찰가를 유지하고 있다면,

1271
01:00:16,780 --> 01:00:19,630

입찰자 중 한 명이

1272
01:00:19,630 --> 01:00:24,400
입찰가를 낮춰서 더 이상
최고가에 들지 못할 가능성이 있습니다.  예를 들어,

1273
01:00:24,400 --> 01:00:27,310


1274
01:00:27,310 --> 01:00:31,840
어떤 선수들을 다시 팀에 포함시켜야 할지 알아보기 위해 다른 선수들의 상황도 계속 파악해야 할 거예요
.  좋은

1275
01:00:31,840 --> 01:00:33,880
생각이 하나 있어요.

1276
01:00:33,880 --> 01:00:37,823
저는
다른 데이터 구조를 하나만 유지하는 것이 아니라, 두 개를 더 유지할 것입니다

1277
01:00:37,823 --> 01:00:38,740
.

1278
01:00:38,740 --> 01:00:40,810
어쩌면 이건 너무 비약일지도 모르겠네요.

1279
01:00:40,810 --> 01:00:42,010
이렇게 하실 필요는 없어요.

1280
01:00:42,010 --> 01:00:44,140

단 한 사람과도 할 수 있는 방법이 있습니다.

1281
01:00:44,140 --> 01:00:46,910
하지만 저는 두 개를 더 저장할 거예요.

1282
01:00:46,910 --> 01:00:49,900
하나는 입찰자들을 저장하는

1283
01:00:49,900 --> 01:01:01,100
데이터 구조로,

1284
01:01:01,100 --> 01:01:14,020
가장 높은 입찰자 k명을 저장하고, 다른 하나는

1285
01:01:14,020 --> 01:01:22,570

가장 높은 입찰자 수에서 n을 뺀 수를 저장하는 데이터 구조입니다.

1286
01:01:22,570 --> 01:01:25,640
이해가 되시나요?

1287
01:01:25,640 --> 01:01:31,190
이렇게 하면 제 문제가
아주 잘 구분되죠?

1288
01:01:31,190 --> 01:01:33,830
누군가가
이 데이터 구조와 상호 작용할 때마다

1289
01:01:33,830 --> 01:01:41,360
, 저는
그 값이 이 구조

1290
01:01:41,360 --> 01:01:44,600

내에서 가장 작은 값보다 큰지 확인할 수 있습니다.

1291
01:01:44,600 --> 01:01:48,320
그렇다면
예전에 했던 것과 같은 묘기를 부릴 수 있어요.  기존

1292
01:01:48,320 --> 01:01:52,610
것을 제거하고
새 것을 그 자리에 끼울 수 있습니다.

1293
01:01:52,610 --> 01:01:54,200
우리는 가고 있었는데...
제가 그걸 삭제했어요.

1294
01:01:54,200 --> 01:01:56,660
나는
이 건물을 관리해야 한다.

1295
01:01:56,660 --> 01:01:58,575
그래서 여기에 넣는 거예요.

1296
01:01:58,575 --> 01:01:59,450
또 다른 사건이 있습니다.

1297
01:01:59,450 --> 01:02:00,367
다른 사건은 뭔가요?  더

1298
01:02:03,190 --> 01:02:05,460
작습니다.

1299
01:02:05,460 --> 01:02:07,090
이 경우에는

1300
01:02:07,090 --> 01:02:09,340
이 데이터 구조를 전혀 건드리지 않고 그냥
여기에 넣습니다.

1301
01:02:09,340 --> 01:02:12,390
이해가 되시나요?

1302
01:02:12,390 --> 01:02:14,460

이러한 데이터 구조가

1303
01:02:14,460 --> 01:02:16,380
유지해야 하는 연산은 무엇입니까?

1304
01:02:16,380 --> 01:02:19,410

이 두 집합의 최솟값 또는 최댓값을 찾는 것.

1305
01:02:19,410 --> 01:02:20,820
이해가 되시나요?

1306
01:02:20,820 --> 01:02:25,230
사실, 정말로,
그 작전들은 어디에서 진행되고 있는 거죠?

1307
01:02:25,230 --> 01:02:26,640
저는 더 이상 그것들을 가지고 있지 않습니다.

1308
01:02:26,640 --> 01:02:29,070
하지만 그것들은
우선순위 대기열 작업이었습니다.

1309
01:02:29,070 --> 01:02:33,750
delete_max
와 insert는 이 프로그램이

1310
01:02:33,750 --> 01:02:36,930
잘 수행했던 기능들이었습니다.

1311
01:02:36,930 --> 01:02:40,200
따라서

1312
01:02:40,200 --> 01:02:45,270
최대값
과 최소값을 처리할 수 있는 우선순위 큐라면 무엇이든 좋습니다.

1313
01:02:45,270 --> 01:02:47,610


1314
01:02:47,610 --> 01:02:50,910
최댓값
과 최솟값을 효율적으로 처리할 수 있는 데이터 구조가 있다면 알려주세요.

1315
01:02:50,910 --> 01:02:51,870
AVL 세트 맞죠?

1316
01:02:51,870 --> 01:02:55,830
그래서 여기서 데이터 구조 대신에

1317
01:02:55,830 --> 01:02:59,075
AVL을 설정하라고 하겠습니다.

1318
01:03:03,420 --> 01:03:12,168
그리고 당연히
입찰은 환영받을 것입니다.

1319
01:03:12,168 --> 01:03:14,460
왜냐하면
제가

1320
01:03:14,460 --> 01:03:15,390
최대값과 최소값을 찾고 싶은 부분이 바로 그 부분이기 때문입니다.

1321
01:03:18,070 --> 01:03:19,690


1322
01:03:19,690 --> 01:03:23,583
제가 왜
이런 것들을 유지하는지 논리적으로 이해하시는 분 계신가요?  제가 유지하고 싶은

1323
01:03:23,583 --> 01:03:25,000

불변 조건의 수준은 이렇습니다.

1324
01:03:25,000 --> 01:03:28,400


1325
01:03:28,400 --> 01:03:33,430
예를 들어, '
수익' 쿼리를 실행할 때

1326
01:03:33,430 --> 01:03:36,890

이 모든 항목을 합산할 수 있기 때문입니다.

1327
01:03:36,890 --> 01:03:38,260
아, 잠깐만요.

1328
01:03:38,260 --> 01:03:40,780
시간이 얼마나 있나요?

1329
01:03:40,780 --> 01:03:42,250
시간이 좀 있나요?

1330
01:03:42,250 --> 01:03:44,210
아니요, 시간이 없어요.

1331
01:03:44,210 --> 01:03:48,790
그래서 저는 제 글 말미에
이 모든 것들을 요약해서 설명할 여유가 없습니다

1332
01:03:48,790 --> 01:03:49,880
.

1333
01:03:49,880 --> 01:03:52,720
저는 그것을
정해진 시간 안에 당신에게 돌려줘야 합니다.

1334
01:03:52,720 --> 01:03:54,880
아이디어 있으신가요?

1335
01:03:54,880 --> 01:03:59,230
네, 그냥 계산하면 돼요.
합계를 업데이트하면 되죠.

1336
01:03:59,230 --> 01:04:02,830
이 데이터 구조와 함께

1337
01:04:02,830 --> 01:04:05,500

네 번째 항목으로

1338
01:04:05,500 --> 01:04:13,120
총 입찰액을 기록할 것입니다.

1339
01:04:13,120 --> 01:04:14,380
저는 그걸 t라고 부를 거예요.

1340
01:04:18,670 --> 01:04:20,380
그리고
저는 그 점을 유지하고 있습니다.

1341
01:04:20,380 --> 01:04:22,780
제 데이터 구조의 일부입니다.

1342
01:04:22,780 --> 01:04:24,370


1343
01:04:24,370 --> 01:04:27,310
이것을 숫자로 무언가를 더하는 것으로 생각하시면 됩니다.

1344
01:04:27,310 --> 01:04:30,130
그리고 여기에 숫자를 추가하는 이유는,

1345
01:04:31,510 --> 01:04:34,120
만약 제가
이 모든 것들의 총합이 얼마인지 알고 싶을 때,

1346
01:04:34,120 --> 01:04:35,800
그 숫자만 보면 되기 때문입니다.

1347
01:04:35,800 --> 01:04:38,260
이해가 되시나요?

1348
01:04:38,260 --> 01:04:39,100
괜찮은.  자

1349
01:04:39,100 --> 01:04:41,920
, 이제
거의 다 끝난 것 같네요.  이제

1350
01:04:41,920 --> 01:04:44,050
거의 끝난 거죠, 그렇죠?

1351
01:04:44,050 --> 01:04:45,860
우리는 어떻게 이것을 할까요?

1352
01:04:45,860 --> 01:04:51,220


1353
01:04:51,220 --> 01:04:54,270
이 데이터 구조를 이용해서 어떻게 수익을 창출할 수 있는지 자세히 설명해 주세요.

1354
01:04:54,270 --> 01:04:56,870
제가 이미 거의 다 말씀드렸잖아요.

1355
01:04:56,870 --> 01:04:57,800
이 숫자를 보세요.

1356
01:04:57,800 --> 01:04:59,240
돌려주세요.

1357
01:04:59,240 --> 01:05:02,580
왜냐하면 그것이 제가
데이터 구조에서 유지해 온 불변 조건이기 때문입니다

1358
01:05:02,580 --> 01:05:03,080
.

1359
01:05:03,080 --> 01:05:04,760
저는 이 불변량에 의존하고 있습니다.  자

1360
01:05:04,760 --> 01:05:06,860
, 이제

1361
01:05:06,860 --> 01:05:09,350
동적 연산을 할 때 이게 제대로 작동하는지 확인해야겠네요.  저는

1362
01:05:09,350 --> 01:05:11,030
그것을 꾸준히 유지하려고 노력합니다.

1363
01:05:11,030 --> 01:05:15,973
하지만 만약 제가 귀납법을 통해
이 모든 것들이 제대로 되어 있는지 확인하고,

1364
01:05:15,973 --> 01:05:18,140
동적
연산을 수행할 때에도 이 모든 것들이

1365
01:05:18,140 --> 01:05:21,230
유지되는지 확인한다면,
저는 아무 문제 없다고 생각합니다.

1366
01:05:21,230 --> 01:05:28,050
그래서 이 모든 추가 작업을 마친 후에는 수익 창출이
매우 쉬워졌습니다.

1367
01:05:28,050 --> 01:05:31,730
저는 이
숫자만 보고 바로 돌아갑니다.

1368
01:05:31,730 --> 01:05:33,620

데이터 구조 문제를 채점할 때,

1369
01:05:33,620 --> 01:05:36,710
일반적으로
먼저 연산과는 별도로 데이터 구조를 설정하는 것에 점수를 주고

1370
01:05:36,710 --> 01:05:39,110

,

1371
01:05:39,110 --> 01:05:42,320


1372
01:05:42,320 --> 01:05:44,360
성공적으로
처리한 연산마다 점수를 부여하며, 마지막으로

1373
01:05:44,360 --> 01:05:47,130
정확성
과 실행 시간에 대한 점수를 부여합니다.

1374
01:05:47,130 --> 01:05:49,620
네, 질문이 있으셨나요?

1375
01:05:49,620 --> 01:05:51,560
청중: 그럼
총액은

1376
01:05:51,560 --> 01:05:54,770

우리가

1377
01:05:54,770 --> 01:05:58,871
최고 입찰자 트리
와 n-k 입찰자 트리를 수정할 때마다 업데이트되는 건가요?

1378
01:05:58,871 --> 01:06:00,760
제이슨 쿠: 죄송합니다만,
다시 말씀해 주시겠습니까?

1379
01:06:00,760 --> 01:06:03,790
청중: 우리는
전체를

1380
01:06:03,790 --> 01:06:05,540
우리가
무언가를 할 때마다 업데이트하는 증강현실로 취급하고 있는 건가요?

1381
01:06:05,540 --> 01:06:05,750
제이슨 쿠: 네.

1382
01:06:05,750 --> 01:06:06,250
응.

1383
01:06:06,250 --> 01:06:07,885
그러니까 숫자는 하나뿐이에요.

1384
01:06:07,885 --> 01:06:09,260
사실
데이터 구조라기보다는

1385
01:06:09,260 --> 01:06:12,770

데이터베이스에 저장하는 숫자 하나일 뿐입니다.

1386
01:06:16,820 --> 01:06:17,420
괜찮은.

1387
01:06:17,420 --> 01:06:23,010

새로운 입찰 작업을 어떻게 구현하나요?

1388
01:06:23,010 --> 01:06:23,510
응?

1389
01:06:23,510 --> 01:06:24,677
청중: 질문이 있습니다.

1390
01:06:24,677 --> 01:06:27,302
입찰가 또한 모두 고유할 것이라고 가정해도 될까요
?

1391
01:06:27,302 --> 01:06:29,510
제이슨 쿠: 입찰가가 모두 다를 수 있다고 가정할 수 있나요
?

1392
01:06:29,510 --> 01:06:30,010
아니요.

1393
01:06:32,420 --> 01:06:39,050
그건
정말 유용한 지적입니다.  지금까지

1394
01:06:39,050 --> 01:06:42,290

집합 데이터 구조는

1395
01:06:42,290 --> 01:06:47,390
고유 키가 필요하다고 이야기해 왔습니다.  고유하지 않은 키를

1396
01:06:47,390 --> 01:06:48,890
어떻게 처리해야 할까요
?

1397
01:06:48,890 --> 01:06:51,140
실제로
해시 테이블에서는

1398
01:06:51,140 --> 01:06:54,650

키가 고유해야 한다는 점이 매우 중요합니다.  그 안에 있는지

1399
01:06:54,650 --> 01:06:56,930
확인해야 하기 때문입니다
.

1400
01:06:56,930 --> 01:06:59,110
저는 그 열쇠 하나를 찾고 있어요.

1401
01:06:59,110 --> 01:07:01,340
그것을 찾으면
돌아가야 해요.

1402
01:07:01,340 --> 01:07:03,230
만약 제가
그 열쇠로 여러 개의 물건을 가지고 있다면,

1403
01:07:03,230 --> 01:07:05,450

제가 찾고 있는 물건을 반품하지 않을 수도 있어요.

1404
01:07:05,450 --> 01:07:08,240
말이 안 되잖아.

1405
01:07:08,240 --> 01:07:17,240
하지만
집합 구조를 일반화하여

1406
01:07:17,240 --> 01:07:19,230
다중 집합을 처리할 수 있습니다.

1407
01:07:19,230 --> 01:07:21,420
어떻게 하면 그렇게 할 수 있을까요?

1408
01:07:21,420 --> 01:07:24,860
네, 각 키마다

1409
01:07:24,860 --> 01:07:26,720
고유한 키를 저장하고 있습니다.

1410
01:07:26,720 --> 01:07:30,110
각 키를 사용하여
시퀀스 집합 구조

1411
01:07:30,110 --> 01:07:32,258
또는 다른 데이터 구조에 연결할 수 있습니다.

1412
01:07:32,258 --> 01:07:34,550
그리고 제가 할 일은,

1413
01:07:34,550 --> 01:07:36,440
그 키를 가진 모든 것을

1414
01:07:36,440 --> 01:07:38,558
그 데이터 구조에 넣는 것입니다.

1415
01:07:38,558 --> 01:07:40,100
그래서 한 가지 물건만 보관하는 대신
,

1416
01:07:40,100 --> 01:07:42,267

여러 가지 물건을 보관할 수 있게 되었습니다.  자

1417
01:07:42,267 --> 01:07:44,700
, 이제
여기서 의미론을 바꿔야겠네요.

1418
01:07:44,700 --> 01:07:48,800
만약 제가 "이 키로 찾아줘"라고 말한다면
, 이제 저는 "

1419
01:07:48,800 --> 01:07:51,800

이 키로 찾은 모든 것을 반환할게요"라고 말할 수도 있고, "

1420
01:07:51,800 --> 01:07:55,010

이 키로 어떤 것을 저장할게요"라고 말할 수도 있습니다.

1421
01:07:55,010 --> 01:07:56,150
하지만 무슨 말인지 아시겠죠?

1422
01:07:56,150 --> 01:07:59,970
제가 해야 할 일은

1423
01:07:59,970 --> 01:08:01,160
[알아들을 수 없는 부분]을 유지하기 위해 다른 데이터 구조로 매핑하는 것뿐입니다.  예를 들어,

1424
01:08:01,160 --> 01:08:06,380

그 열쇠로 살 수 있는 모든 물건을 갖고 싶을 수도 있죠.

1425
01:08:06,380 --> 01:08:09,440
나는
다른 열쇠가 달린 것을 찾고 싶어.

1426
01:08:09,440 --> 01:08:11,475
그럼

1427
01:08:11,475 --> 01:08:13,100

다른 것들을 검색할 수 있는 데이터 구조에 링크를 걸 수도 있겠네요?

1428
01:08:13,100 --> 01:08:15,410
하지만 여기서 중요한 것은

1429
01:08:15,410 --> 01:08:18,109
이러한 고유성이라는 핵심 속성을 유지하는 것입니다.

1430
01:08:18,109 --> 01:08:20,810


1431
01:08:20,810 --> 01:08:23,609
여러 가지 정보를
해당 키 위치에 저장할 수 있도록 의미론을 완화해야 합니다.

1432
01:08:23,609 --> 01:08:24,550
이해가 되시나요?

1433
01:08:24,550 --> 01:08:25,250
응?

1434
01:08:25,250 --> 01:08:27,250
청중:
AVL

1435
01:08:27,250 --> 01:08:28,512
트리에 고유 키가 있는지 여부가 왜 중요한가요?

1436
01:08:31,220 --> 01:08:35,750
제이슨 쿠:
여기서는 그게 중요해요. 왜냐하면 제가 입찰을 했거든요.

1437
01:08:35,750 --> 01:08:38,899
그리고 입찰은
고유하지 않을 수도 있습니다.

1438
01:08:38,899 --> 01:08:43,580
두 사람이
동일한 입찰가를 제시할 수 있습니다.

1439
01:08:43,580 --> 01:08:46,850
그리고 우리가 정의한
집합 데이터 구조에 따르면,

1440
01:08:46,850 --> 01:08:48,149
고유한 키를 가져야 했습니다.

1441
01:08:48,149 --> 01:08:50,870
그래서 만약 제가
입찰자가 입력한 이 모든 것들을 입력해 버리면

1442
01:08:50,870 --> 01:08:53,510
문제가 생기는 겁니다.

1443
01:08:53,510 --> 01:08:54,979
실제로, 해당 키를 가진

1444
01:08:54,979 --> 01:08:57,439


1445
01:08:57,439 --> 01:09:00,529
모든 항목을 연결 리스트로 저장하면 아무 문제 없이 처리할 수 있습니다
.

1446
01:09:03,109 --> 01:09:06,260
그러면 나중에 언제든
반품하고 싶을 때 쉽게 할 수 있겠죠.

1447
01:09:06,260 --> 01:09:10,550
하지만 실제로
이진 트리는

1448
01:09:10,550 --> 01:09:12,950
매우 유연해서
대부분의 구현에서

1449
01:09:12,950 --> 01:09:15,920

그런 것들을 많이 저장할 수 있습니다.

1450
01:09:15,920 --> 01:09:20,840
하지만 실제로는
실행 시간이 더 오래 걸립니다.

1451
01:09:20,840 --> 01:09:24,439

내 시퀀스에서 다음을 찾는다는 것은 무엇을 의미합니까?

1452
01:09:24,439 --> 01:09:29,750


1453
01:09:29,750 --> 01:09:32,029
이 키보다 위에 있는 다음으로 큰 항목을 반환한다는 것은 무엇을 의미합니까?

1454
01:09:32,029 --> 01:09:33,859


1455
01:09:33,859 --> 01:09:34,819
여러 개가 있을 수 있으니 말이 안 되네요.

1456
01:09:34,819 --> 01:09:36,200
어떤 것을 반품해야 하나요?

1457
01:09:36,200 --> 01:09:41,270
그리고 이 데이터 구조에서 find-next를 반복적으로 수행하면

1458
01:09:41,270 --> 01:09:44,720

모든 항목을 순회하지 못할 수도 있습니다.

1459
01:09:44,720 --> 01:09:49,170

인터페이스에 몇 가지 문제가 발생했습니다.

1460
01:09:49,170 --> 01:09:54,980

이런 상황에서는 고유 키를 사용하는 것이 좋습니다.

1461
01:09:54,980 --> 01:09:58,580
다음 주 화요일에는
바이너리 힙을 이용해서 고유하지 않은

1462
01:09:58,580 --> 01:10:02,720
키를 다뤄볼 것 같습니다.

1463
01:10:02,720 --> 01:10:04,230
괜찮아요.

1464
01:10:04,230 --> 01:10:09,440
하지만
여기서 고유하지 않은 키를 사용하려면

1465
01:10:09,440 --> 01:10:11,480


1466
01:10:11,480 --> 01:10:13,920
의미론적인 측면에서 약간 주의해야 합니다.

1467
01:10:13,920 --> 01:10:14,420
응?

1468
01:10:14,420 --> 01:10:15,410
청중: [잘 안 들림]?

1469
01:10:24,500 --> 01:10:27,620
제이슨 쿠:
실행 시간은 똑같을 겁니다. 다만

1470
01:10:27,620 --> 01:10:29,960


1471
01:10:29,960 --> 01:10:32,510

"무언가를 찾다"라는 말의 의미를 바꿔야 할 뿐이죠.

1472
01:10:32,510 --> 01:10:35,570

이 키를 사용해서 무엇이든 반품하고 싶어요.

1473
01:10:35,570 --> 01:10:37,490
청중:
모든 악기의 키가 같다면 어떨까요?

1474
01:10:37,490 --> 01:10:38,190
그러면—

1475
01:10:38,190 --> 01:10:39,900
제이슨 쿠: 그러면
일정한 시간이 걸립니다.

1476
01:10:39,900 --> 01:10:41,150
저는 그냥 제일 먼저 나온 걸 반품해요.

1477
01:10:45,110 --> 01:10:48,410
제 말은, 이것들은 고려해야 할
특별한 경우들이라는 거죠

1478
01:10:48,410 --> 01:10:51,140
, 그렇죠?

1479
01:10:51,140 --> 01:10:52,920
나는
그들에 대해 생각하는 것을 좋아하지 않는다.

1480
01:10:52,920 --> 01:10:55,460
저는 그냥
각기 다른 키를 갖는 걸 좋아해요.

1481
01:10:55,460 --> 01:10:59,570
그리고 만약
키가 고유하지 않은 상황을 만들고 싶다면,

1482
01:10:59,570 --> 01:11:02,870

해당 키에서 발생하는 충돌을

1483
01:11:02,870 --> 01:11:04,910
새로운 데이터 구조에 저장할 것입니다.

1484
01:11:04,910 --> 01:11:06,540


1485
01:11:06,540 --> 01:11:08,300
머릿속으로 상황을 구분하는 게 저한테는 더 쉬워요.

1486
01:11:08,300 --> 01:11:11,030
왜냐하면
저희가 제안한 모든 실행 시간에는

1487
01:11:11,030 --> 01:11:14,540

고유 키에 대한 매우 명확한 정의가 있기 때문입니다.  여러 데이터셋을

1488
01:11:14,540 --> 01:11:16,970
다룰 때는 이런 현상이

1489
01:11:16,970 --> 01:11:20,150
좀
더 흔하게 나타납니다.

1490
01:11:20,150 --> 01:11:21,890
다른 질문 있으신가요?  이제 슬슬 다음으로

1491
01:11:21,890 --> 01:11:25,910

넘어가야겠죠?

1492
01:11:25,910 --> 01:11:27,650
입찰자를 기준으로 입력된 사전입니다.

1493
01:11:27,650 --> 01:11:31,670
우리는 아직
동적 연산을 구현하지 않았습니다.

1494
01:11:31,670 --> 01:11:32,360
새로운 입찰.

1495
01:11:32,360 --> 01:11:34,890
어떻게 해야 하죠?

1496
01:11:34,890 --> 01:11:38,030

업데이트를 하려면 무엇이 필요할까요?

1497
01:11:38,030 --> 01:11:42,020
저는
기본적으로 이러한

1498
01:11:42,020 --> 01:11:44,120
각
데이터 구조에서

1499
01:11:44,120 --> 01:11:47,510
해당 입찰자가 어디에 있는지 찾아야 합니다.

1500
01:11:47,510 --> 01:11:51,890
그리고 만약 제가
그들의 입찰가에 초점을 맞춰 놓았다면,

1501
01:11:51,890 --> 01:11:54,770
인터페이스는
그들의 이전 입찰가를 알려주지 않습니다.

1502
01:11:54,770 --> 01:11:57,200
그건 그냥
입찰자 ID만 알려줘요.

1503
01:11:57,200 --> 01:12:02,030
만약 제가 입찰자 ID
와 새로운 입찰가만 알고 있다면,

1504
01:12:02,030 --> 01:12:04,430


1505
01:12:04,430 --> 01:12:07,190
이 데이터
구조 속에서 그 데이터들이 어디에 있는지 어떻게 알아낼 수 있을까요?

1506
01:12:07,190 --> 01:12:11,630
제가 할 수 있는 것은,
이 사전에 해당 항목이

1507
01:12:11,630 --> 01:12:15,680


1508
01:12:15,680 --> 01:12:18,050
어디에
있는지 알려주는 포인터를 저장하는 것입니다. 그러면 나중에 이 사전에 있는 포인터를 찾아볼 수 있습니다.

1509
01:12:18,050 --> 01:12:20,690
이해가 되시나요?

1510
01:12:20,690 --> 01:12:21,920
이것을 가교결합이라고 합니다.

1511
01:12:21,920 --> 01:12:24,800

문제

1512
01:12:24,800 --> 01:12:26,940
세트 2에서 그런 문제를 조금 풀어봤을 수도 있어요.

1513
01:12:26,940 --> 01:12:27,440
응?

1514
01:12:27,440 --> 01:12:30,590
청중:
특정 입찰자를 가리키는 포인터를 복원하는 방법은 무엇인가요?

1515
01:12:30,590 --> 01:12:32,780
제이슨 쿠: 네, 맞아요.

1516
01:12:32,780 --> 01:12:34,178
우리가 가진 불변 조건은 지금까지 처리한
모든

1517
01:12:34,178 --> 01:12:35,720
입찰자가

1518
01:12:35,720 --> 01:12:38,420
이러한 데이터 구조 중 하나에 존재한다는 것입니다.

1519
01:12:38,420 --> 01:12:41,060


1520
01:12:41,060 --> 01:12:43,850
왜냐하면 우리는
AVL 트리 집합을 사용했기 때문입니다.

1521
01:12:43,850 --> 01:12:45,800
특히, 이는 이러한 데이터 구조 중
하나의 노드에 존재합니다

1522
01:12:45,800 --> 01:12:47,660
.

1523
01:12:47,660 --> 01:12:50,780
우리가 할 수 있는 것은
, 이 시스템에서

1524
01:12:50,780 --> 01:12:56,480

각 입찰자 ID를

1525
01:12:56,480 --> 01:12:58,910

해당 데이터 구조 내의 위치에 매핑하는 포인터를 유지하는 것입니다.

1526
01:12:58,910 --> 01:13:00,920
그렇다면 그게 왜
유용한 일일까요?

1527
01:13:04,220 --> 01:13:06,290
제가 이 사전을 매핑한다고 가정해 보겠습니다.  원하는 실행 시간을 얻으려면

1528
01:13:06,290 --> 01:13:07,790

이 사전에서 무엇을 사용해야 할까요

1529
01:13:07,790 --> 01:13:10,580

?

1530
01:13:10,580 --> 01:13:13,340
해시
테이블이나 AVL 세트를 사용할 수 있습니다.

1531
01:13:13,340 --> 01:13:16,520
만약 AVL이 설정되어 있다면,
최악의 경우 로그 시간 복잡도를 갖게 될 겁니다

1532
01:13:16,520 --> 01:13:17,705
.

1533
01:13:17,705 --> 01:13:19,580
해시 테이블을 사용하면
일정한 시간이 걸리지만,

1534
01:13:19,580 --> 01:13:21,120
이는 예상된 결과입니다.

1535
01:13:21,120 --> 01:13:24,920

최악의 경우 시간 경과가 선형적으로 진행될 수도 있습니다.

1536
01:13:24,920 --> 01:13:27,020


1537
01:13:27,020 --> 01:13:30,330
현재 우리가 사용하고 있는 방식대로 AVL 트리 설정을 사용하겠습니다.

1538
01:13:30,330 --> 01:13:32,810
그러면
최악의 상황이 발생할 겁니다.

1539
01:13:32,810 --> 01:13:35,060
제가 하려는 것은,
이 각각의 항목에 대해

1540
01:13:35,060 --> 01:13:36,393
해당 포인터를 저장하는 것입니다.

1541
01:13:36,393 --> 01:13:39,683
제가
먼저 할 일은, 저희가 진행했던

1542
01:13:39,683 --> 01:13:41,100

수술에 대해 설명하는 것입니다.

1543
01:13:41,100 --> 01:13:49,100
새로운 입찰자를 추가하는 경우,
D와 B, 즉

1544
01:13:49,100 --> 01:13:53,840
이 두 값과
해당 입찰자 객체

1545
01:13:53,840 --> 01:13:54,820
또는 무엇이든 간에,

1546
01:13:54,820 --> 01:13:58,040

이 데이터 구조에서 가장 작은 요소를 살펴보고

1547
01:13:58,040 --> 01:14:06,470
해당 입찰가가 새로 추가하는 항목의 입찰가보다 큰지 확인합니다

1548
01:14:06,470 --> 01:14:07,683
.

1549
01:14:07,683 --> 01:14:10,100
그렇다면 저는
이 데이터 구조를 건드리지 않겠습니다.

1550
01:14:10,100 --> 01:14:11,840

여기에 바로 삽입할게요.

1551
01:14:11,840 --> 01:14:13,992
이제
여기에 삽입하고 나니

1552
01:14:13,992 --> 01:14:15,950

데이터 구조에서 정확히 어디에 위치하는지 알 수 있습니다.

1553
01:14:15,950 --> 01:14:19,370
방금 삽입했어요.  자

1554
01:14:19,370 --> 01:14:22,010
, 이제
제 손에 있는 이

1555
01:14:22,010 --> 01:14:27,680
노드를 이용해서 입찰 ID로
해당 입찰자를 여기에 삽입할 수 있습니다

1556
01:14:27,680 --> 01:14:29,990
.

1557
01:14:29,990 --> 01:14:31,820
그래서
로그 시간(logi)이 걸릴 겁니다.

1558
01:14:31,820 --> 01:14:36,410
이제
해당 노드를 사용하여

1559
01:14:36,410 --> 01:14:37,565
이 데이터 구조에 대한 포인터를 저장할 수 있습니다.

1560
01:14:37,565 --> 01:14:38,820
이해가 되시나요?

1561
01:14:38,820 --> 01:14:41,780
그리고 다른 경우에도 저는 비슷한 방식으로
합니다.

1562
01:14:41,780 --> 01:14:45,050
만약 이게 여기 있는 가장 작은 것보다 크다면
, 저는 그 작은

1563
01:14:45,050 --> 01:14:48,620
것을 빼내고 거기에 넣은 다음,
새 부품을 여기에 넣고, 그

1564
01:14:48,620 --> 01:14:52,860

과정에서 각 포인터를 서로 연결합니다.  이해가 되시나요

1565
01:14:52,860 --> 01:14:57,470
?  거의

1566
01:14:57,470 --> 01:14:59,280
?  거의

1567
01:14:59,280 --> 01:14:59,780
?

1568
01:14:59,780 --> 01:15:00,860
좋아요.

1569
01:15:00,860 --> 01:15:03,470
그리고 업데이트 사항도 매우 유사합니다.

1570
01:15:03,470 --> 01:15:06,050

특정 입찰자의 정보를 업데이트하려면

1571
01:15:06,050 --> 01:15:11,550
이 데이터
구조에서 해당 입찰자를 찾고,

1572
01:15:11,550 --> 01:15:13,440
그 포인터를 따라

1573
01:15:13,440 --> 01:15:16,980

AVL 트리의 해당 위치로 이동하면 되는 거죠?

1574
01:15:16,980 --> 01:15:22,050
만약 이 항목에 있다면,
트리에서 그냥 제거하거나, 트리

1575
01:15:22,050 --> 01:15:23,790
에서 제거한
다음 새 입찰가

1576
01:15:23,790 --> 01:15:29,070
로 다시 삽입합니다
.

1577
01:15:29,070 --> 01:15:32,010
그리고 만약 이게 여기에 있다면
, 다시

1578
01:15:32,010 --> 01:15:35,190
트리에서 제거하고, 이 중
어느 곳에든 다시 삽입한 다음

1579
01:15:35,190 --> 01:15:36,840
,

1580
01:15:36,840 --> 01:15:39,720


1581
01:15:39,720 --> 01:15:43,020

이게 가장 높은 k 값을 갖도록 유지하기 위해 여기서 일정 수의 항목을 계속해서 바꿔야 할 수도 있습니다.

1582
01:15:43,020 --> 01:15:47,610
그리고 제가 이러한
동적 연산을 수행할 때,

1583
01:15:47,610 --> 01:15:50,370


1584
01:15:50,370 --> 01:15:53,340
각 트리에서 일정한 수의 노드를 제거하고 일정한 수의 노드를
다시 추가합니다

1585
01:15:53,340 --> 01:15:55,213
.

1586
01:15:55,213 --> 01:15:57,630
그리고 그렇게 하는 동안, 저는 진행 상황에 따라
이 총액을 계속 업데이트합니다

1587
01:15:57,630 --> 01:15:58,980
.

1588
01:15:58,980 --> 01:16:04,680
이 총액은
여기에 제시된 모든 입찰가의 합계입니다.

1589
01:16:04,680 --> 01:16:07,320
그리고 만약 제가
여기에 새로운 입찰가를 입력하면,

1590
01:16:07,320 --> 01:16:09,520
그 총액에 추가해야 합니다.

1591
01:16:09,520 --> 01:16:11,858
그리고 만약 제가 하나를 제거한다면,
그 총합에서 하나를 빼야 합니다.

1592
01:16:11,858 --> 01:16:13,650
하지만 다시 말하지만,

1593
01:16:13,650 --> 01:16:15,900

이러한 데이터 구조에 넣고 빼는 항목의 수는 일정하기

1594
01:16:15,900 --> 01:16:18,060
때문에
상수 시간 내에 업데이트가 가능합니다.

1595
01:16:18,060 --> 01:16:19,800
이해가 되시나요?

1596
01:16:19,800 --> 01:16:23,760
여기서의 조회와
삽입 및 삭제는

1597
01:16:23,760 --> 01:16:29,130

최악의 경우 각각 로그 시간 복잡도를 가집니다.

1598
01:16:29,130 --> 01:16:30,850
하지만 저는 그런 일들을 꾸준히 해냈습니다
.

1599
01:16:30,850 --> 01:16:32,780
그러니까 다시 한번, 로그 시간입니다.

1600
01:16:32,780 --> 01:16:33,930
이해가 되시나요?

1601
01:16:33,930 --> 01:16:37,680
본질적으로
이 문제는 바로 그것입니다.

1602
01:16:37,680 --> 01:16:39,280
어렵죠, 그렇죠?

1603
01:16:39,280 --> 01:16:41,470

여기에는 여러 가지 복잡한 요소들이 얽혀 있습니다.

1604
01:16:41,470 --> 01:16:44,610
하지만 만약 당신이 그것을
세분화해서 저에게 설명해 주신다면

1605
01:16:44,610 --> 01:16:47,280
, 예를 들어

1606
01:16:47,280 --> 01:16:50,790

데이터 구조에 대해 잘 설명해 주신다면,

1607
01:16:50,790 --> 01:16:52,380

알고리즘에 대한 설명은

1608
01:16:52,380 --> 01:16:53,920
실제로 꽤 간결해질 수 있습니다.

1609
01:16:57,120 --> 01:16:59,940
이 경우에는
세 가지 데이터 구조와 각 객체의 위치

1610
01:16:59,940 --> 01:17:03,630

매핑 등을 알려주시면, 저는 이

1611
01:17:03,630 --> 01:17:07,770

객체를 관리하고,

1612
01:17:07,770 --> 01:17:11,520
여러분은
동적 연산을 통해 이러한 객체들을 유지 관리한

1613
01:17:11,520 --> 01:17:14,910
다음
쿼리 연산에 사용하면 됩니다.

1614
01:17:14,910 --> 01:17:15,900
이해가 되시나요?

1615
01:17:19,630 --> 01:17:20,960
와, 10분이나 더 남았네?

1616
01:17:25,810 --> 01:17:32,830

4-4 포메이션에 대해 간단하게 설명해 드리겠습니다.

1617
01:17:32,830 --> 01:17:33,700
리시버 명단.

1618
01:17:33,700 --> 01:17:36,880
우리에겐 코치가 있어요.

1619
01:17:36,880 --> 01:17:38,980
그녀는 미식
축구 선수들, 특히

1620
01:17:38,980 --> 01:17:41,650
리시버들을 많이 보유하고 있어요.

1621
01:17:41,650 --> 01:17:45,790
그리고 그녀는

1622
01:17:45,790 --> 01:17:50,380

최고의 기량을 가진 선수들로 구성된 팀에서 시작하고 싶어합니다.  여기서 말하는

1623
01:17:50,380 --> 01:17:52,930
성과란, 선수들이

1624
01:17:52,930 --> 01:17:54,970


1625
01:17:54,970 --> 01:17:56,980
시스템에 기록한 게임에서 얻은 평균 점수를 의미합니다.

1626
01:17:56,980 --> 01:18:00,280
하지만 사실 그들의
데이터는 불완전합니다.

1627
01:18:00,280 --> 01:18:02,680
그들은 어떤 경기에서
몇 점을 넣었는지 등

1628
01:18:02,680 --> 01:18:03,680
모든 것을 모릅니다.

1629
01:18:03,680 --> 01:18:05,090
오류가 있을 수 있습니다.

1630
01:18:05,090 --> 01:18:08,320
그래서 이 인턴들은 "

1631
01:18:08,320 --> 01:18:15,370

아, 아니네요.

1632
01:18:15,370 --> 01:18:17,980
이 사람은
이 경기에 출전하지 않았어요."

1633
01:18:17,980 --> 01:18:21,850
또는 "사실 출전했고,
몇 점을 득점했어요."와 같은 쿼리를 통해 이 데이터베이스를 끊임없이 업데이트합니다.

1634
01:18:21,850 --> 01:18:25,780
그게 바로 명확하게
기록하는 거예요.

1635
01:18:25,780 --> 01:18:28,360
그리고 나서, 예를 들어

1636
01:18:28,360 --> 01:18:31,870

경기를 하고 싶을 때,

1637
01:18:31,870 --> 01:18:36,760


1638
01:18:36,760 --> 01:18:40,270
로그 n 시간 안에 k번째로 높은 성능을 보여준 유니폼을 돌려줄 수 있기를 바랍니다.

1639
01:18:40,270 --> 01:18:45,370
이건 일종의
순위 검색 쿼리 아닌가요?  k번째로

1640
01:18:45,370 --> 01:18:46,135
높은.

1641
01:18:48,670 --> 01:18:53,500
실제로 저는 가장 높은 점수를 받은
선수 k명을 모두 반환하여 최종

1642
01:18:53,500 --> 01:18:56,050
로스터를 구성하고 싶을 수도 있습니다.

1643
01:18:56,050 --> 01:19:00,070
하지만 이것은 좀 더
일반적인 질문입니다.

1644
01:19:00,070 --> 01:19:02,000
그건 더 구체적이고, 더...

1645
01:19:02,000 --> 01:19:04,030
사실 비교하기는 어렵습니다.

1646
01:19:04,030 --> 01:19:07,358
하지만 왜 그것이
코치에게 유용할 수 있는지에 대한 아이디어를 얻을 수 있을 겁니다.  모르겠습니다

1647
01:19:07,358 --> 01:19:07,900
.  아닐 수도 있죠

1648
01:19:07,900 --> 01:19:10,090
.

1649
01:19:10,090 --> 01:19:11,667
그래서 여기서 말하고자 하는 바는 무엇인가요?  주변에는

1650
01:19:11,667 --> 01:19:13,750
온갖 다양한
것들이 떠다니고 있어요.

1651
01:19:13,750 --> 01:19:15,280
우리에겐 게임이 있어요.

1652
01:19:15,280 --> 01:19:17,180
그들은 고유한 ID를 가지고 있습니다.

1653
01:19:17,180 --> 01:19:18,040
저희는 수신기를 가지고 있습니다.

1654
01:19:18,040 --> 01:19:19,630
그들은 고유한 ID를 가지고 있습니다.

1655
01:19:19,630 --> 01:19:23,890
그리고 각 리시버는
여러 경기에 출전할 수 있습니다.

1656
01:19:23,890 --> 01:19:26,590
아, 그건 좀 걱정스럽네요.

1657
01:19:26,590 --> 01:19:30,990
그리고 여러 명의 리시버들이
한 경기에 출전할 수도 있습니다.

1658
01:19:30,990 --> 01:19:32,680
이러한 다
대일 매핑은

1659
01:19:32,680 --> 01:19:34,490
다소 혼란스러울 수 있습니다.

1660
01:19:34,490 --> 01:19:39,110
그리고 각 선수(

1661
01:19:39,110 --> 01:19:42,200
리시버)는
경기당 정해진 점수를 갖게 됩니다.

1662
01:19:42,200 --> 01:19:45,930
그리고 우리는 그것들을
성과라는

1663
01:19:45,930 --> 01:19:47,944
합리적인 수치를 기준으로 분류하려고 합니다.

1664
01:19:47,944 --> 01:19:50,480
아, 그렇죠?

1665
01:19:50,480 --> 01:19:52,880
이는
그들이 치른 경기 수

1666
01:19:52,880 --> 01:19:55,880
와 총 득점과 관련이 있습니다.

1667
01:19:55,880 --> 01:19:59,420
유리수를 보니
계산이 안 되네요.

1668
01:19:59,420 --> 01:20:02,990

지난번 문제 풀이 시간에 얘기했던 게 그거잖아요, 그렇죠?

1669
01:20:02,990 --> 01:20:04,448
하지만 제가 할 수 있는 것은

1670
01:20:04,448 --> 01:20:05,990

그들이 플레이한 총 게임 수

1671
01:20:05,990 --> 01:20:07,730
와
획득한 총 점수를 저장하는 것입니다.

1672
01:20:07,730 --> 01:20:09,830
그리고 여러분도 짐작하시겠지만, 이와 유사한
증강 현실을 통해

1673
01:20:09,830 --> 01:20:14,690

게임을 추가할 때마다, 즉

1674
01:20:14,690 --> 01:20:18,980
이러한 작은 작업들을 통해

1675
01:20:18,980 --> 01:20:19,700
각 플레이어의 정보를 업데이트할 수 있습니다.

1676
01:20:22,850 --> 01:20:25,040
이러한 동적 작업 중 하나가

1677
01:20:25,040 --> 01:20:27,440

특정 수신자에게만 영향을 미치는 경우, 데이터베이스에 기록된

1678
01:20:27,440 --> 01:20:31,550


1679
01:20:31,550 --> 01:20:35,060

플레이어의

1680
01:20:35,060 --> 01:20:38,732
총 게임 수와

1681
01:20:38,732 --> 01:20:40,190

획득한 점수를 저장해 두면 아마도 일정한 시간 내에 해당 정보를 업데이트할 수 있을 것입니다.

1682
01:20:40,190 --> 01:20:43,070
그런데 만약

1683
01:20:43,070 --> 01:20:47,790
수신기를
성능 순으로 정렬해서

1684
01:20:47,790 --> 01:20:50,210

k번째 수신기(

1685
01:20:50,210 --> 01:20:56,740
k번째로 성능이 높은 수신기)를 찾아야 하는 데이터 구조가 있다면,
그 성능을 계산할 수가 없습니다.

1686
01:20:56,740 --> 01:20:59,290
하지만 제가 뭘 할 수 있겠어요?  교차 곱셈을 이용하면

1687
01:20:59,290 --> 01:21:02,820
두 선수의 경기력을 비교할 수 있습니다

1688
01:21:02,820 --> 01:21:05,430
.

1689
01:21:05,430 --> 01:21:07,740


1690
01:21:07,740 --> 01:21:09,240
각 유리수의 분자와 분모를 알고 있으므로,

1691
01:21:09,240 --> 01:21:11,910
교차 곱셈을 통해 어느 쪽이 더

1692
01:21:11,910 --> 01:21:13,330
큰지 더 작은지 알아낼 수 있습니다.

1693
01:21:13,330 --> 01:21:15,030

비교기만 있으면

1694
01:21:15,030 --> 01:21:17,850
AVL 설정 작업을 할 수 있습니다.

1695
01:21:17,850 --> 01:21:19,120
이해가 되시나요?

1696
01:21:19,120 --> 01:21:20,610
좋아요.

1697
01:21:20,610 --> 01:21:25,440

이 데이터 구조의 구성 요소를 간략하게 설명드리겠습니다

1698
01:21:25,440 --> 01:21:26,240
.

1699
01:21:28,770 --> 01:21:32,730
우선,
수신기를 녹음해야겠습니다.

1700
01:21:32,730 --> 01:21:34,780
그리고 리시버는
많은 경기에 출전할 수 있습니다.

1701
01:21:34,780 --> 01:21:37,650
하지만 중요한 것은, 이것은
수신자 중심적인

1702
01:21:37,650 --> 01:21:38,230
문제라는 점입니다.  제 말이 이해가 되시나요

1703
01:21:38,230 --> 01:21:39,930

?  저는 경기에 출전하는 모든 리시버를 필터링하고

1704
01:21:39,930 --> 01:21:42,960
싶은 건 절대 아닙니다

1705
01:21:42,960 --> 01:21:44,490
.

1706
01:21:44,490 --> 01:21:50,490
저는
시스템에서 게임을 삭제하는 게 아니라,

1707
01:21:50,490 --> 01:21:53,040


1708
01:21:53,040 --> 01:21:54,420
특정 게임에서 수신기가 더 이상 작동하지 않도록 하는 겁니다.

1709
01:21:54,420 --> 01:21:55,630
이해가 되시나요?

1710
01:21:55,630 --> 01:21:59,430
그러니까
수신기를 저장하고, 각 수신기에 연결된

1711
01:21:59,430 --> 01:22:01,980
게임이 있다면
,

1712
01:22:01,980 --> 01:22:05,370


1713
01:22:08,160 --> 01:22:11,550

수신기를 저장하는 딕셔너리 같은 중첩 데이터 구조를 사용하는 게 좋을 것 같다는 거죠.

1714
01:22:11,550 --> 01:22:14,400
그리고 각 플레이어에 대해, 그들이 플레이했던
모든 게임들을

1715
01:22:14,400 --> 01:22:17,220

다른 데이터 구조에 저장합니다.

1716
01:22:17,220 --> 01:22:20,347
각 수신기마다, 해당 수신기가 보유한 모든 게임을 담고 있는
자체 데이터 구조를 하나씩 저장합니다

1717
01:22:20,347 --> 01:22:21,930

.

1718
01:22:21,930 --> 01:22:23,640
이해가 되시나요?

1719
01:22:23,640 --> 01:22:26,280
네, 그게 요점입니다.  저는

1720
01:22:27,540 --> 01:22:31,590

수신기를 조회해야 하는데, 수신기를

1721
01:22:31,590 --> 01:22:35,970
초기화
하거나 녹음해야 하기 때문입니다.

1722
01:22:35,970 --> 01:22:40,320
그래서 저는
사전을 사용하거나, 아니면

1723
01:22:40,320 --> 01:22:42,970

최악의 경우 log n 시간을 찾고 있습니다.

1724
01:22:42,970 --> 01:22:45,870
그래서 저는
사전 추상화 단계를 건너뛰고

1725
01:22:45,870 --> 01:22:49,260
바로 집합 AVL로 넘어가겠습니다.

1726
01:22:49,260 --> 01:23:00,150
AVL은 수신기에 맞춰 작동합니다.  C 다음이

1727
01:23:00,150 --> 01:23:06,730
아닌 이상 I는 E 앞에 옵니다. 즉,
I-

1728
01:23:06,730 --> 01:23:07,230
E-I인가요?

1729
01:23:10,650 --> 01:23:11,850
그 규칙은 절대 통하지 않아.

1730
01:23:11,850 --> 01:23:13,200
좋아요.

1731
01:23:13,200 --> 01:23:17,940
수신기에 AVL 트리를 설정하고, 각 수신기와 연결된
각 노드에 대해

1732
01:23:17,940 --> 01:23:23,010


1733
01:23:23,010 --> 01:23:32,250
각각
게임에 대한 AVL 세트를 저장합니다.

1734
01:23:36,330 --> 01:23:38,460

게임에 AVL 값을 저장하는 이유는 무엇인가요?

1735
01:23:38,460 --> 01:23:42,480

게임 목록을 전부 저장해두면 되지 않을까요?

1736
01:23:42,480 --> 01:23:45,360
만약 제가
수신기에서 이 게임을 제거하려면, 그 작업을 매우 오랜

1737
01:23:45,360 --> 01:23:47,250
시간 동안 해야 하기 때문입니다.

1738
01:23:47,250 --> 01:23:51,520
여기서 우리가 말하는 것은
n은 경기 수이지만,

1739
01:23:51,520 --> 01:23:54,000

팀의 리시버 수는

1740
01:23:54,000 --> 01:23:56,760
항상
경기 수보다 적다는 것입니다.

1741
01:23:56,760 --> 01:24:02,040
이 AVL 트리에서 검색
하고 그 AVL 트리에서 검색하면,

1742
01:24:02,040 --> 01:24:07,050
이 두
검색에 소요되는 시간은 오직 log n 시간뿐이라는 것을 확신할 수 있습니다.

1743
01:24:07,050 --> 01:24:08,840

게임을 삭제해야 하니까요, 그렇죠?  자, 이제 아시겠죠?

1744
01:24:11,710 --> 01:24:13,290
그렇다면 나는 지금 무엇을 하고 있는 거지?

1745
01:24:13,290 --> 01:24:15,550
저는 k번째로
높은 성능을 반환합니다.

1746
01:24:15,550 --> 01:24:21,100
음, 저는
이 사람들 각각과 함께 저장해야 할 것이 있는데,

1747
01:24:21,100 --> 01:24:22,630
이 증강 기능이 뭐였더라?

1748
01:24:22,630 --> 01:24:28,030

이 게임들에 저장된 점수의 합계.

1749
01:24:28,030 --> 01:24:32,755
점수 합계랑...

1750
01:24:35,350 --> 01:24:40,000
뭐였더라... 숫자 게임.

1751
01:24:40,000 --> 01:24:43,130
왜냐하면 만약 제가
그 두 가지를 모두 상수 시간 안에 저장할 수 있다면,

1752
01:24:43,130 --> 01:24:46,450

성능을 계산할 수 있고,

1753
01:24:46,450 --> 01:24:49,000


1754
01:24:49,000 --> 01:24:51,290
성능 비교에 필요한 데이터를 얻을 수 있을 것이기 때문입니다.

1755
01:24:51,290 --> 01:24:52,600
청중: [잘 안 들림]?

1756
01:24:52,600 --> 01:24:53,530
제이슨 쿠: 네, 그렇습니다.  그저

1757
01:24:53,530 --> 01:24:54,970
숫자일 뿐입니다.

1758
01:24:54,970 --> 01:24:56,090
이것들은 데이터 구조입니다.

1759
01:24:56,090 --> 01:24:56,970
이것은 데이터 구조입니다.

1760
01:24:56,970 --> 01:24:57,928
이것들은 그저 숫자에 불과합니다.

1761
01:25:00,400 --> 01:25:02,190
그리고 그 정보를
각 수신기에 저장하고 있습니다.

1762
01:25:05,110 --> 01:25:08,860
하지만 그건 제가 k번째로 높은 점수를 받은
선수를 찾는 데 도움이 되지 않을 겁니다.

1763
01:25:08,860 --> 01:25:13,580
이 중 어느 것도
성능 순으로 정렬되어 있지 않습니다.

1764
01:25:13,580 --> 01:25:15,635
그래서 마지막으로 데이터 구조가 하나 더 필요합니다.

1765
01:25:22,760 --> 01:25:31,130
다섯째, 성능에 따라
동적으로 정렬되는 데이터를 저장해야 합니다

1766
01:25:31,130 --> 01:25:32,970
.

1767
01:25:32,970 --> 01:25:33,720
청중: AVL 설정하시겠습니까?

1768
01:25:33,720 --> 01:25:35,810
제이슨 쿠: AVL 설정, 네.  성능을 기준으로

1769
01:25:35,810 --> 01:25:50,940
수신기를 저장하는 AVL을 설정합니다
.

1770
01:25:50,940 --> 01:25:55,580
자, 제가
성능에 중점을 둔다고 말할 때,

1771
01:25:55,580 --> 01:25:57,200


1772
01:25:57,200 --> 01:25:58,910
크로스팟 곱셈에 대해서도 언급해야 할 것 같습니다.

1773
01:25:58,910 --> 01:26:01,220
예를 들어, 저는
이러한 각각의 요소에 대해

1774
01:26:01,220 --> 01:26:04,070
증강 값을 저장하고,
두 요소를 비교할 때는

1775
01:26:04,070 --> 01:26:05,900
교차 곱셈을 사용합니다.

1776
01:26:05,900 --> 01:26:08,840
하지만 그 외에는 추상적으로 처리할 수 있겠죠
?

1777
01:26:08,840 --> 01:26:10,700
우리는
해당 함수 호출을 추상화했습니다.

1778
01:26:10,700 --> 01:26:13,700

두 개의 열쇠를 비교하는 것을 상상할 수 있습니다.

1779
01:26:13,700 --> 01:26:14,992
저는 이걸 할 수 있어요.

1780
01:26:14,992 --> 01:26:15,950
이건 이론적인 문제예요.

1781
01:26:15,950 --> 01:26:18,200

그걸 실행하라는 게 아닙니다.

1782
01:26:18,200 --> 01:26:22,280
하지만 제가
당신의 해결책을 읽은 입장에서는, 그 정도면 "

1783
01:26:22,280 --> 01:26:26,810
네, 당신은
제대로 알고 계시는군요"라고 말하기에 충분합니다.

1784
01:26:26,810 --> 01:26:28,100
괜찮은.

1785
01:26:28,100 --> 01:26:30,050
이것들을 어떻게 연결하나요?

1786
01:26:30,050 --> 01:26:32,480
문제는,

1787
01:26:32,480 --> 01:26:38,800

게임을 넣거나 뺄 때마다 이 정보들을 업데이트해야 한다는 거예요.

1788
01:26:41,360 --> 01:26:47,600
그럼 이 기기에서 수신기가 어디에 있는지 어떻게 알 수 있나요
?

1789
01:26:47,600 --> 01:26:50,690

이 데이터 구조에 대한 포인터를 저장하는 거죠?

1790
01:26:50,690 --> 01:26:57,710
그래서 여기 위쪽에는

1791
01:26:57,710 --> 01:26:59,570
데이터 구조 내에서 해당 위치가 어디인지 가리키는 포인터를 저장합니다.  다시

1792
01:26:59,570 --> 01:27:01,280
말씀드리지만, 저는
모든 수신기를 보관하고 있습니다.

1793
01:27:01,280 --> 01:27:04,070
이것은 위에 있는
1번 데이터

1794
01:27:04,070 --> 01:27:06,530
구조와 크기가 같고,
수신자 수도 같습니다.

1795
01:27:09,590 --> 01:27:13,220
하지만 아직 끝난 게 아니에요.

1796
01:27:13,220 --> 01:27:21,350
누가 가장
뛰어난 활약을 펼쳤는지 알고 싶지 않거든요.

1797
01:27:21,350 --> 01:27:25,170

k번째로 좋은 성적을 낸 사람이 누구인지 알고 싶어요.

1798
01:27:25,170 --> 01:27:27,410
으윽.

1799
01:27:27,410 --> 01:27:30,450

이 트리에서 k번째로 좋은 것을 어떻게 찾을 수 있나요?

1800
01:27:30,450 --> 01:27:31,220
저는 나무 한 그루를 가지고 있어요.

1801
01:27:34,070 --> 01:27:35,030
AVL 트리를 설정합니다.

1802
01:27:35,030 --> 01:27:37,130
성능에 따라 평가됩니다.

1803
01:27:37,130 --> 01:27:38,990
마지막 하나가 어디 있는지 알아요.

1804
01:27:38,990 --> 01:27:41,390
하지만
끝에서 k번째 항목을 찾으려면

1805
01:27:41,390 --> 01:27:44,360
어떻게 해야 할까요?

1806
01:27:44,360 --> 01:27:45,890
이것은 AVL 트리, 즉

1807
01:27:45,890 --> 01:27:47,300
집합 AVL 트리입니다.

1808
01:27:47,300 --> 01:27:50,070
내가 저장하는 건 높이뿐이야.

1809
01:27:50,070 --> 01:27:54,690

생각해 보신 수술이 있으신가요?

1810
01:27:54,690 --> 01:27:58,790
청중: [잘 안 들림]
각 항목의 크기를 저장하지 않고 있잖아요.

1811
01:27:58,790 --> 01:28:00,770
제이슨 쿠:
기본적으로 AVL 트리는

1812
01:28:00,770 --> 01:28:02,300
크기를 저장하지 않죠, 그렇죠?

1813
01:28:02,300 --> 01:28:04,220
그게 바로 시퀀스의 역할입니다.

1814
01:28:04,220 --> 01:28:08,370
하지만 그런 점이
이 상황에 도움이 될 수도 있다고 생각하세요?

1815
01:28:08,370 --> 01:28:08,870
응.

1816
01:28:08,870 --> 01:28:12,500
그래서 실제로
크기별로 확장하기로 결정하면

1817
01:28:12,500 --> 01:28:17,240
정확히 동일한 종류
의 시퀀스 find_at 연산을 수행할 수 있고, 시퀀스 AVL 트리 관련 작업에서 사용했던 것과

1818
01:28:17,240 --> 01:28:22,670


1819
01:28:22,670 --> 01:28:28,190
동일한 함수를 사용하여 여기서 n에서 k번째 항목을 뺀 값을 찾을 수 있습니다

1820
01:28:28,190 --> 01:28:32,000

.

1821
01:28:32,000 --> 01:28:33,920
사실 CLRS에서는

1822
01:28:33,920 --> 01:28:35,930
시퀀스 AVL 트리를 아예 고려하지도 않습니다.  정렬된 순서로 항목을

1823
01:28:35,930 --> 01:28:39,710

찾는 기능을 원한다면

1824
01:28:39,710 --> 01:28:44,180


1825
01:28:44,180 --> 01:28:47,330

하위 트리의 크기를 늘리면 된다는 결론에 바로 도달합니다.

1826
01:28:47,330 --> 01:28:51,320
하지만 사실 이것은 훨씬
더 유용한 일반적인 속성이므로,

1827
01:28:51,320 --> 01:28:54,500

시퀀스 AVL 트리의 맥락에서 여러분께 제시하기로 했습니다.

1828
01:28:54,500 --> 01:28:56,780
그러면 제가 이 부분에 도달했을 때
기본적으로 이 속성

1829
01:28:56,780 --> 01:28:58,520
으로 환원할 수 있기 때문입니다.

1830
01:28:58,520 --> 01:29:01,130
이것이 바로 이 문제를 해결하는 데 사용되는
데이터 구조의 구조입니다

1831
01:29:01,130 --> 01:29:02,420
.

1832
01:29:02,420 --> 01:29:04,820


1833
01:29:04,820 --> 01:29:06,920
이 모든 연산을
직접 구현해 보시

1834
01:29:06,920 --> 01:29:08,790
거나, 제공된 해답을 살펴보시는 것을 연습 문제로 남겨두겠습니다.

1835
01:29:08,790 --> 01:29:13,460
마지막으로, 해답을
온라인에 공개할 예정입니다

1836
01:29:13,460 --> 01:29:15,140
.

1837
01:29:15,140 --> 01:29:16,500
꽤 복잡해요.

1838
01:29:16,500 --> 01:29:19,490

크기 증강 순위

1839
01:29:19,490 --> 01:29:22,370
찾기는
단측 범위 쿼리라고 생각할 수 있습니다.

1840
01:29:22,370 --> 01:29:27,410
기본적으로
이 값의 오른쪽에 있는 항목이 몇 개냐는 질문입니다.

1841
01:29:27,410 --> 01:29:29,780
마지막 문제는

1842
01:29:29,780 --> 01:29:32,330


1843
01:29:32,330 --> 01:29:37,070

두 값 사이에 노드가 몇 개 있는지 알고 싶은 양방향 범위 쿼리를 단계별로 안내합니다.

1844
01:29:37,070 --> 01:29:39,150
이건 공략 영상입니다.

1845
01:29:39,150 --> 01:29:39,650
괜찮은.

1846
01:29:39,650 --> 01:29:40,550
고마워요, 여러분.

1847
01:29:40,550 --> 01:29:42,100
청중: 감사합니다.

