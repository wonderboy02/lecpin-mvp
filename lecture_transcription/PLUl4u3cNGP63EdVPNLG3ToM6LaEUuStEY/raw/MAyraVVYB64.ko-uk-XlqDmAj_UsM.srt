1
00:00:00,000 --> 00:00:01,976
[쥐 우는 소리]

2
00:00:01,976 --> 00:00:04,445
[속삭임]

3
00:00:04,445 --> 00:00:06,421
[딸깍 하는 소리]

4
00:00:13,359 --> 00:00:17,969
제이슨 쿠: 저희 방송에 오신 것을 환영합니다
네 번째 문제 풀이 시간.  오늘

5
00:00:17,969 --> 00:00:21,460
우리는 주로 다음 내용에 대해 이야기할 것입니다.
이진 트리.

6
00:00:21,460 --> 00:00:24,429
잠깐 이야기 좀 나눠보죠.
이진 힙에 관하여, 이것은

7
00:00:24,429 --> 00:00:27,649
우리가 다루지 않을 주제
다음 주 화요일까지 고려해 보겠습니다.

8
00:00:27,649 --> 00:00:32,710
하지만 그녀는 나타날 것입니다
아주 작은 방식으로

9
00:00:32,710 --> 00:00:36,460
문제 세트 4에서,
다음 주 금요일이 될 거예요.

10
00:00:36,460 --> 00:00:40,660
그래서 저는 갑니다
오늘은 이 자료를 좀 더 자세히 살펴보겠습니다.

11
00:00:40,659 --> 00:00:43,149
하지만 그것은 대부분 우려 사항입니다.

12
00:00:43,149 --> 00:00:48,879
주제 자료
오늘날에는 대부분 이진 트리입니다.

13
00:00:48,880 --> 00:00:52,450
특히 적용되는 것
데이터 구조 집합의 경우

14
00:00:52,450 --> 00:00:57,400
및 순차 데이터 구조,
데메인 교수가 말했듯이

15
00:00:57,399 --> 00:01:01,339
이번 주 초에 당신과 함께 있었어요.

16
00:01:01,340 --> 00:01:06,100
하지만 지금은… 사실,
어제 기준으로 --

17
00:01:06,099 --> 00:01:08,409
여러분 모두 보셨죠
우리가 사용하는 데이터 구조

18
00:01:08,409 --> 00:01:10,090
우리는 다음 내용을 다룰 것입니다.

19
00:01:10,090 --> 00:01:13,180
구현하는 것
다이얼링 인터페이스 및

20
00:01:13,180 --> 00:01:14,470
시퀀스 인터페이스.

21
00:01:14,469 --> 00:01:21,158
저 아름다운 테이블들
데메인 교수가 보여드렸습니다.

22
00:01:21,158 --> 00:01:22,959
이제 준비되셨습니다.  안에

23
00:01:22,959 --> 00:01:25,209
우리 중에는 몇몇이 있습니다.
데이터 구조

24
00:01:25,209 --> 00:01:28,929
정말 훌륭합니다 - 지속적인 운영
일부 작업의 경우.

25
00:01:28,930 --> 00:01:32,740
그러므로 우리는 그것들을 사용할 수 있습니다.
일부 프로그램의 경우 그렇습니다.

26
00:01:32,739 --> 00:01:36,519
그리고 이번 주에는 저희는
설명됨

27
00:01:36,519 --> 00:01:40,149
당신 나무들
실제로 상당히 달성할 수 있습니다.

28
00:01:40,150 --> 00:01:43,660
어떤 유형이든 좋은 결과
내 데이터셋에 대한 쿼리 작업

29
00:01:43,658 --> 00:01:44,979
또는 시퀀스--

30
00:01:44,979 --> 00:01:48,320
꽤 괜찮다, 즉 로그적이다
시간은 일정하지 않다.

31
00:01:48,319 --> 00:01:51,894
하지만 우리의 목적을 위해서는 n을 입력하세요 -

32
00:01:51,894 --> 00:01:54,579
그러니까, 당신의
컴퓨터는 사실상...

33
00:01:54,579 --> 00:01:56,890
점근적으로는 아닙니다.
하지만 실제로는 -- 로그

34
00:01:56,890 --> 00:02:00,430
n은 이하입니다.
컴퓨터에서요?

35
00:02:03,519 --> 00:02:07,030
64 정도였던가요?

36
00:02:07,030 --> 00:02:11,620
작업 중인 모든 입력 데이터
기계어로 표현하자면,

37
00:02:11,620 --> 00:02:14,000
입력 데이터입니다.

38
00:02:14,000 --> 00:02:16,000
당신은 할 수 있어야 합니다.
그 모든 기계와 연락하기 위해

39
00:02:16,000 --> 00:02:18,550
자기소개에 단어들을 넣어보세요.

40
00:02:18,550 --> 00:02:22,840
그리고 컴퓨터에서 크기는
기계어 단어 주소

41
00:02:22,840 --> 00:02:25,030
64비트 맞죠?

42
00:02:25,030 --> 00:02:27,759
그리고 우리는 다음과 같이 가정합니다.
단어 크기 최소한

43
00:02:27,759 --> 00:02:33,699
입력값의 로그 크기,
입력값을 처리할 수 있도록 하기 위함입니다.

44
00:02:33,699 --> 00:02:37,060
그러므로, 당신의 목적에 맞게 말씀드리자면,
컴퓨터에서,

45
00:02:37,060 --> 00:02:39,099
로그 n
64명을 넘지 않을 것입니다.

46
00:02:39,099 --> 00:02:42,460
즉, 당신은 얻게 될 것입니다.
겹치는 부분이 50배 정도 될 수도 있겠네요.

47
00:02:42,460 --> 00:02:45,670
또는 소규모 사건의 경우
10개보다 많을 수도 있어요.

48
00:02:45,668 --> 00:02:49,299
만약 당신에게 1000개의 물건이 있다면
당신이 작업 중인 것.

49
00:02:49,300 --> 00:02:50,620
그렇게 나쁘진 않죠?

50
00:02:50,620 --> 00:02:53,740
이것은 상수입니다. 그렇지 않습니다.
이론값에 대한 상수 승수

51
00:02:53,740 --> 00:02:57,969
목표는 목표이지만, 당신의 목표를 위해서입니다.
log n은 훨씬 더 좋습니다.

52
00:02:57,969 --> 00:02:59,978
다항식 인수 -

53
00:02:59,978 --> 00:03:03,250
n의 또 다른 요소.

54
00:03:03,250 --> 00:03:05,800
당신은 모든 코드를 다 봤습니다.

55
00:03:05,800 --> 00:03:08,950
구현된 버전을 보셨나요?
이 모든 다이얼 및 시퀀스 인터페이스

56
00:03:08,949 --> 00:03:10,299
그렇지 않나요?

57
00:03:10,300 --> 00:03:12,550
그래서 저는 계속 진행했습니다.
조금 썼어요...

58
00:03:12,550 --> 00:03:15,490
이 모든 코드를 하나로 합쳤습니다.
필기 내용부터 낭독까지,

59
00:03:15,490 --> 00:03:18,610
모두 다릅니다
인터페이스 구현.

60
00:03:18,610 --> 00:03:22,720
나
간단한 테스트 프로그램을 작성했습니다.

61
00:03:22,719 --> 00:03:25,960
그들이 어떻게 작동하는지 보기 위해
실제 자동차에서.  안에

62
00:03:25,960 --> 00:03:30,340
간단한 테스트 코드가 있습니다.  안에

63
00:03:30,340 --> 00:03:35,409
제겐 작은 폴더가 하나 있는데, 그 안에
열거형 배열 구현

64
00:03:35,409 --> 00:03:37,270
순차, 이진수
구현하는 트리

65
00:03:37,270 --> 00:03:39,400
순서, 동적
구현하는 배열...

66
00:03:39,400 --> 00:03:41,170
이 모든 것들.

67
00:03:41,168 --> 00:03:45,250
그다음에는 설정을 하세요. 정렬된 배열을 만드는 것입니다.
이진 트리의 집합입니다.

68
00:03:45,250 --> 00:03:46,599
그리고 해시 테이블.

69
00:03:46,599 --> 00:03:48,009
이것이 저희의 구현 방식입니다.

70
00:03:48,009 --> 00:03:50,709
저는 사용하지 않습니다
해시 테이블을 위한 파이썬 딕셔너리,

71
00:03:50,710 --> 00:03:55,329
저는 구현체를 사용합니다.
프레젠테이션에 있는 내용입니다.

72
00:03:55,329 --> 00:03:56,980
그리고 난 갈 거야
이 간단한 테스트를 실행해 보세요

73
00:03:56,978 --> 00:03:59,439
파이썬 코드 효율성,
본질적으로 그것은 단순히

74
00:03:59,439 --> 00:04:00,550
모두를 자유롭게 할 것입니다.

75
00:04:00,550 --> 00:04:03,370
그는 일련의 공연을 펼칠 것입니다.
이러한 다양한 작전들

76
00:04:03,370 --> 00:04:05,650
그리고 확인할 수 있는 조치들,
얼마나 걸렸나요?

77
00:04:05,650 --> 00:04:07,719
지금 가입 중이에요.
얼마나 걸렸나요?

78
00:04:07,719 --> 00:04:11,379
이것은 점근선이 아닙니다.
분석이지만, 바라건대 우리는

79
00:04:11,379 --> 00:04:13,329
우리는 일정한 분리를 봅니다.

80
00:04:13,330 --> 00:04:16,389
그러니까 이걸 클릭하면,
여러 가지 테스트를 실행합니다.

81
00:04:16,389 --> 00:04:19,269
한번 살펴볼까요?

82
00:04:19,269 --> 00:04:20,620
좋은.  안에

83
00:04:20,620 --> 00:04:23,660
저는 많이 가지고 있어요.
연속적인 작업.  안에

84
00:04:23,660 --> 00:04:28,150
우리는 빌드, 설정,
접근, 삽입, 삭제

85
00:04:28,149 --> 00:04:30,879
다른 장소에서.

86
00:04:30,879 --> 00:04:36,250
그리고 이것들은 실제입니다
특정 규모의 타이밍 --

87
00:04:36,250 --> 00:04:39,610
제가 가지고 있던 특정 결의안에서
이러한 데이터 구조의 경우.

88
00:04:39,610 --> 00:04:41,680
그리고 여러분은 그 조립 과정을 보게 될 것입니다.

89
00:04:41,680 --> 00:04:44,170
사실, 그 컬렉션은,
이 차에 대해,

90
00:04:44,170 --> 00:04:46,270
몇 가지만 강조해 보겠습니다.
어레이 및 어레이 청소,

91
00:04:46,269 --> 00:04:49,849
정말 효과적인 것입니다
파이썬이 대신 해줄 거예요.

92
00:04:49,850 --> 00:04:54,520
사실… 이것은
잘못된 저널 명칭 n.

93
00:04:54,519 --> 00:04:57,969
하지만 다른 것들은,
get_at 및 set_at --

94
00:04:57,970 --> 00:04:59,680
정말 정말 빠르죠?

95
00:04:59,680 --> 00:05:00,910
이것은 일정한 시간입니다.

96
00:05:00,910 --> 00:05:02,800
그리고 나머지 사람들은 다음과 같습니다.
사실, 저는 여러 가지 일들을 하고 있습니다.

97
00:05:02,800 --> 00:05:05,020
저는 그보다 더 잘할 수 없어요.
스크롤하세요.

98
00:05:05,019 --> 00:05:06,729
그래서 선형적인 시간이 걸립니다.

99
00:05:06,730 --> 00:05:11,500
그리고 다시 그 순서로,
설정 및 가져오기

100
00:05:11,500 --> 00:05:15,250
느리지만 제거 중입니다.
첫 번째에서 제거하면,

101
00:05:15,250 --> 00:05:17,800
다시 접속하는 중입니다.
포인터 맞죠?

102
00:05:17,800 --> 00:05:18,910
동적 배열.

103
00:05:18,910 --> 00:05:23,439
다시 말해, set_at, get_at은 다음과 같습니다.
빠르다, 왜냐하면

104
00:05:23,439 --> 00:05:24,670
일반 배열.

105
00:05:24,670 --> 00:05:27,340
그리고 나서 삽입합니다
그리고 마지막 하나를 제거하면,

106
00:05:27,339 --> 00:05:30,009
그것,
본질적으로, 시간은 일정하다.

107
00:05:30,009 --> 00:05:32,680
사실 저는... 제가
저는 이 문제를 해결하기 위해 이러한 테스트를 실행하고 있습니다.

108
00:05:32,680 --> 00:05:34,180
평균값을 사용하면, 저는
실제로 출시

109
00:05:34,180 --> 00:05:36,980
이런 일들은 여러 번 일어납니다.
그리고 그들의 성과를 확인하세요.

110
00:05:36,980 --> 00:05:41,500
그래서 제가 못 보는 거예요
최악의 시나리오죠, 그렇죠?

111
00:05:41,500 --> 00:05:43,420
나는 모든 것을 평균으로 본다.
그 물건들

112
00:05:43,420 --> 00:05:46,629
정확히
감가상각을 의미합니다.

113
00:05:46,629 --> 00:05:50,560
그래서 제가 얻는 거예요
여기서 좋은 결과가 나왔습니다.

114
00:05:50,560 --> 00:05:51,939
해시 테이블.

115
00:05:51,939 --> 00:05:56,709
다시 한번, 정말로...
아, 그거예요.

116
00:05:56,709 --> 00:05:59,319
우리가 무슨 얘기를 하고 있었죠?
문제 해결 세션에서

117
00:05:59,319 --> 00:06:04,180
지난주에 시행했습니다.
양방향 대기열의 한 유형

118
00:06:04,180 --> 00:06:06,069
해시 테이블을 사용합니다.

119
00:06:06,069 --> 00:06:07,449
구현 방법은 다음과 같습니다.

120
00:06:07,449 --> 00:06:09,129
그냥 당신에게 보여주고 싶었어요.

121
00:06:09,129 --> 00:06:10,459
하지만 사실은 아주 좋아요.

122
00:06:10,459 --> 00:06:14,079
이것이 바로 자바스크립트입니다.
배열의 용도.

123
00:06:14,079 --> 00:06:19,240
그리고 나서 이진 시퀀스가 ​​나옵니다.
이진 트리로 표현됨 -

124
00:06:19,240 --> 00:06:20,550
균형 이진 트리.

125
00:06:20,550 --> 00:06:22,480
이것은 제가 가지고 있던 AVL 코드입니다.

126
00:06:22,480 --> 00:06:25,720
그리고 다른 모든 것들
매우 나빴다

127
00:06:25,720 --> 00:06:28,338
insert_at에서 그리고
delete_at이지만 이것은

128
00:06:28,338 --> 00:06:30,129
모든 것과 비교적 잘 작동합니다
다른 것들.

129
00:06:30,129 --> 00:06:34,060
이제 이게 뭔지 알겠죠?
조금 더 기계적으로 만들어진

130
00:06:34,060 --> 00:06:39,230
다른 것들보다 주기가 ​​더 중요합니다.
하지만 사실 그렇게 나쁘진 않아요.

131
00:06:39,230 --> 00:06:41,710
그런 다음,

132
00:06:41,709 --> 00:06:44,419
다시 말해, 우리는 정렬된 배열을 가지고 있었습니다.

133
00:06:44,420 --> 00:06:46,840
죄송합니다, 이것은
배열에서 가져온 값입니다.

134
00:06:46,839 --> 00:06:48,969
본질적으로 이것은
정렬되지 않은 배열.

135
00:06:48,970 --> 00:06:52,480
저는 그냥 모든 걸 다 찾아보고 있어요.
지금은 정말 힘든 시기입니다.

136
00:06:52,480 --> 00:06:54,970
정렬된 배열은 이러한 기능을 수행합니다.
운영은 훌륭합니다.

137
00:06:54,970 --> 00:06:58,040
하지만 삽입하면
제거는 좋지 않습니다.

138
00:06:58,040 --> 00:07:00,819
이것이 바로 이진 트리가 필요한 이유입니다.

139
00:07:00,819 --> 00:07:05,079
해시 테이블은 좋은 사전을 갖습니다.
운영이지만 매우

140
00:07:05,079 --> 00:07:08,409
잘못된 순서로 작업이 진행됩니다.

141
00:07:08,410 --> 00:07:13,990
그리고 나서 이진수
검색 트리, 튜닝된 이진 트리, 다시 한번,

142
00:07:13,990 --> 00:07:16,490
꽤 잘 대처합니다
이 모든 것들.

143
00:07:16,490 --> 00:07:20,449
사실, 그는 그렇게 된다
꽤 괜찮네요 - 무슨 이유인지는 모르겠지만요

144
00:07:20,449 --> 00:07:22,300
나아지고 있어요.

145
00:07:22,300 --> 00:07:26,199
정렬된 배열보다도 더 낫다.

146
00:07:26,199 --> 00:07:27,729
이유는 모르겠어요.

147
00:07:27,730 --> 00:07:30,220
우리의 구현
전혀 최적화되지 않았습니다.

148
00:07:30,220 --> 00:07:31,890
하지만 그 정도면 충분합니다.
점근적으로 그렇습니다.

149
00:07:31,889 --> 00:07:32,159
예?

150
00:07:32,159 --> 00:07:33,534
청중: 할 수 있나요?
다시 설명해 주시겠어요?

151
00:07:33,534 --> 00:07:38,470
왜 첫 번째인가
데이터 볼트 [필수]가 등록되었습니까?

152
00:07:38,470 --> 00:07:41,830
제이슨 쿠: 간단합니다.
시간에 따라 표시됩니다.

153
00:07:41,829 --> 00:07:43,930
그런 일이 종종 일어납니다.
아마,

154
00:07:43,930 --> 00:07:47,199
파이썬 내부에는 C 언어가 있습니다.
누가 이 점을 특별히 지적하는 걸까요?

155
00:07:47,199 --> 00:07:49,060
그래서 아주 빠르게 처리합니다.

156
00:07:49,060 --> 00:07:51,459
제 프로그램은,
이러한 수치를 고려합니다.

157
00:07:51,459 --> 00:07:54,349
그리고 어느 것인지 추측하려고 합니다.
점근적 실행 시간,

158
00:07:54,350 --> 00:07:57,590
이것들은 단지 라벨일 뿐입니다.
이러한 것들에 대해서는 범위가 있습니다.

159
00:07:57,589 --> 00:07:59,112
제 생각엔… 오해인 것 같아요.

160
00:07:59,112 --> 00:08:01,605
청중: [알아들을 수 없음]

161
00:08:01,605 --> 00:08:02,230
제이슨 쿠: 네.

162
00:08:02,230 --> 00:08:06,939
음, 사실은 말이죠,
만약 이게 C 코드였다면-

163
00:08:06,939 --> 00:08:09,730
만약 이 모든 것들이
C에 있었을지도 몰라요.

164
00:08:09,730 --> 00:08:12,819
우리는 이 스트립이 다음과 같다는 것을 알게 될 것입니다.
더 오래 걸리는 이유는 사실 그것이

165
00:08:12,819 --> 00:08:15,370
거쳐야 할 과정과
이 모든 추억을 되새겨보고 싶어.

166
00:08:15,370 --> 00:08:18,250
여기서는 아직도 그 작업이 진행되고 있어요.
하지만 파이썬에 관한 모든 것

167
00:08:18,250 --> 00:08:19,810
극도로 끔찍하다.

168
00:08:19,810 --> 00:08:23,110
이는 약 100배 더 느립니다.
C가 하는 어떤 일보다도 더 심하다.

169
00:08:23,110 --> 00:08:26,730
그리고 당신은 보게 될 겁니다
이러한 불일치.

170
00:08:26,730 --> 00:08:27,920
이해가 되시나요?

171
00:08:27,920 --> 00:08:28,420
좋은.

172
00:08:28,420 --> 00:08:30,610
이것 좀 보여드리고 싶었어요.

173
00:08:30,610 --> 00:08:33,850
우리는 이것을 공개할 수 있습니다
당신이 플레이하세요,

174
00:08:33,850 --> 00:08:36,308
하지만 그냥 드리고 싶었어요
한번 맛보셔야 해요.

175
00:08:36,308 --> 00:08:41,009
네, 질문이 하나 있어요.
계속하기 전에?

176
00:08:41,009 --> 00:08:42,879
어떻게 하면 이 기능을 끌 수 있나요?

177
00:08:42,879 --> 00:08:46,960
하늘 높이 날아오르자.

178
00:08:46,960 --> 00:08:47,680
꺼주세요.

179
00:08:51,750 --> 00:08:52,779
예

180
00:08:52,779 --> 00:08:53,279
좋은.

181
00:08:58,440 --> 00:09:02,640
이제 문제점으로 넘어가 보겠습니다.
우리는 몇 가지 문제를 해결합니다.  여기에서

182
00:09:02,639 --> 00:09:04,659
당신은 세트를 가지고 있습니다
문제점들.  에-

183
00:09:04,659 --> 00:09:09,482
첫째, 우리는
AVL 시퀀스 트리를 생각해 보세요.

184
00:09:09,482 --> 00:09:10,649
이것은 AVL 시퀀스 트리입니다.

185
00:09:10,649 --> 00:09:11,442
제가 이걸 어떻게 알까요?

186
00:09:15,200 --> 00:09:16,759
그럴 필요 없어요.

187
00:09:16,759 --> 00:09:19,460
하지만 이런 것들
절대 아닙니다

188
00:09:19,460 --> 00:09:23,450
무엇의 순서대로
제가 보관하는 거죠?

189
00:09:23,450 --> 00:09:26,420
그러니 안 하는 게 낫습니다.
구성된 AVL 트리여야 합니다.

190
00:09:26,419 --> 00:09:27,529
이것이 AVL 트리인가요?

191
00:09:27,529 --> 00:09:30,509
이것은 균형이 잡혀 있습니다.
높이가 균형 잡혀 있나요?

192
00:09:30,509 --> 00:09:32,220
네, 기본적으로 그렇습니다.

193
00:09:32,220 --> 00:09:36,810
사실, 계산해 보면
각 서브트리의 크기,

194
00:09:36,809 --> 00:09:39,119
왼쪽 및 오른쪽 서브트리
이 모든 것에 대해 (당신은)

195
00:09:39,120 --> 00:09:41,399
확인해 주시겠어요?
그 자체로) 균형을 이루고 있습니다.

196
00:09:41,399 --> 00:09:43,949
그들은 플러스 범위 내에 있습니다.
서로 1씩 빼세요.

197
00:09:43,950 --> 00:09:46,500
사실, 이것은
균형과는 거리가 멀다.

198
00:09:46,500 --> 00:09:50,549
얻을 수 있는 것
이 노드 수의 경우,

199
00:09:50,549 --> 00:09:52,599
유지
높이 균형--

200
00:09:52,600 --> 00:09:54,720
유지
AVL 속성 - 따라서

201
00:09:54,720 --> 00:09:56,040
이것은 유익한 사례입니다.

202
00:09:56,039 --> 00:09:58,740
마치 벼랑 끝에 서 있는 것 같아요.

203
00:09:58,740 --> 00:10:02,370
그럼 저는 어떻게 해야 할까요?

204
00:10:02,370 --> 00:10:04,980
이것에서 빠진 것은 무엇일까요?
이미지, 만약 내가 그렇게 주장한다면

205
00:10:04,980 --> 00:10:08,789
이것은 순차적인 AVL 트리인가요?

206
00:10:08,789 --> 00:10:11,849
무엇이 빠진 건지 아시는 분 계신가요?

207
00:10:11,850 --> 00:10:14,700
무엇
AVL 시퀀스 트리를 저장하는데, 저는 그걸 필요로 하지 않아요.

208
00:10:14,700 --> 00:10:16,360
이 이미지에 나타난 것은 무엇입니까?

209
00:10:16,360 --> 00:10:17,190
관객 수: 카운트됩니다.

210
00:10:17,190 --> 00:10:17,490
제이슨 쿠: 뭐라고요?

211
00:10:17,490 --> 00:10:18,282
관객 수: 카운트됩니다.

212
00:10:18,282 --> 00:10:18,990
제이슨 쿠: 맞아요.

213
00:10:18,990 --> 00:10:19,490
그리고?

214
00:10:22,519 --> 00:10:25,360
이것은 순차적인 AVL 트리입니다.

215
00:10:25,360 --> 00:10:27,320
키 말이죠?

216
00:10:27,320 --> 00:10:29,470
AVL 트리의 순서,
기존 AVL 트리와는 다릅니다.

217
00:10:29,470 --> 00:10:31,000
보충됨
두 가지죠, 그렇죠?

218
00:10:31,000 --> 00:10:34,690
왜냐하면 저는 필요하니까요
균형을 유지하는 동안

219
00:10:34,690 --> 00:10:36,910
회전이니까, 그래서 저는
고도를 유지해야 합니다.

220
00:10:36,909 --> 00:10:39,490
나는 판단할 수 있어야 한다
이 하위 트리들의 높이

221
00:10:39,490 --> 00:10:41,440
일정한 시간 동안,
내가 올라갈 때

222
00:10:41,440 --> 00:10:43,090
나무, 문제를 해결하는 것.

223
00:10:43,090 --> 00:10:47,440
그리고 일관성을 유지하려면 나에게 필요한 것이 있습니다.
서브트리 번호를 저장합니다.

224
00:10:47,440 --> 00:10:50,200
거기.

225
00:10:50,200 --> 00:10:52,030
모르겠어요... 저는
저는 이걸 그리지 않을 거예요.

226
00:10:52,029 --> 00:10:55,269
이 모든 것 때문에, 하지만
4번은 어때요?

227
00:10:55,269 --> 00:10:56,049
그것의 높이는 얼마입니까?

228
00:10:59,669 --> 00:11:00,839
1, 2, 3.

229
00:11:00,840 --> 00:11:05,200
이것은 ~에서 가장 먼 길입니다.
루트 서브트리.

230
00:11:05,200 --> 00:11:09,210
그래서 이 높이는 3입니다.

231
00:11:09,210 --> 00:11:13,900
이것은 다음과 같은 높이에서 나왔습니다.
2이고 높이는 1입니다.

232
00:11:13,899 --> 00:11:15,000
모두들 이걸 보고 있나요?

233
00:11:15,000 --> 00:11:15,690
예?

234
00:11:15,690 --> 00:11:18,390
그리고 나서 사이즈
이거 크기가 얼마나 되나요?

235
00:11:18,389 --> 00:11:22,439
이것들은 1, 2, 3, 4, 5, 6, 7입니다.

236
00:11:22,440 --> 00:11:27,060
이건... 내가 할 거야
여기에 사이즈 7을 입력하세요.

237
00:11:27,059 --> 00:11:31,769
그리고 이것은 다음에서 나옵니다.
이 사람, 1, 2, 3, 4.

238
00:11:31,769 --> 00:11:33,105
그리고 이 사람은 2살이에요.

239
00:11:36,299 --> 00:11:39,699
그럼 어떻게 계산하나요?
서브트리 크기?

240
00:11:39,700 --> 00:11:43,830
이것은 내 왼쪽 서브트리의 크기에 더한 값입니다.
내 오른쪽 서브트리의 크기에 1을 더한 값입니다.

241
00:11:43,830 --> 00:11:47,100
그리고 내 키는...
최댓값은 2 더하기 1입니다.

242
00:11:47,100 --> 00:11:47,600
좋은.

243
00:11:47,600 --> 00:11:50,279
그래서 우리는 이 모든 것을 어제 했습니다.

244
00:11:50,279 --> 00:11:52,860
저는 단지 이러한 것들을 표시하고 있을 뿐입니다.

245
00:11:52,860 --> 00:11:59,730
제발 부탁드립니다.
삭제 작업을 수행합니다.

246
00:11:59,730 --> 00:12:02,250
이것은 순서 트리입니다.

247
00:12:02,250 --> 00:12:06,190
그래서 저는 다음과 같은 방법으로 물건을 찾습니다.
트리에서의 인덱스입니다.

248
00:12:06,190 --> 00:12:08,790
그래서 제가 질문드리겠습니다.
여덟 번째 항목을 제거하세요

249
00:12:08,789 --> 00:12:10,980
내 순서에 따라.

250
00:12:10,980 --> 00:12:14,769
8은 무엇입니까?
내 순서에서 m은 무엇인가요?

251
00:12:14,769 --> 00:12:15,370
예?

252
00:12:15,370 --> 00:12:17,889
청중: 명확히 말씀드리자면,
delete-8은 삭제가 아니기 때문입니다.

253
00:12:17,889 --> 00:12:18,519
숫자.

254
00:12:18,519 --> 00:12:19,269
제이슨 쿠: 맞습니다.

255
00:12:19,269 --> 00:12:21,360
음, delete_at 8.

256
00:12:21,360 --> 00:12:22,236
보이시나요?

257
00:12:22,236 --> 00:12:23,319
이것은 순차적인 작업입니다.

258
00:12:23,320 --> 00:12:23,650
청중: 아, 알겠습니다.

259
00:12:23,649 --> 00:12:24,194
[없어서는 안될]

260
00:12:24,195 --> 00:12:24,820
제이슨 쿠: 네.

261
00:12:24,820 --> 00:12:27,160
그러므로 매우
중요하게도

262
00:12:27,159 --> 00:12:30,339
구별하다
순열 및 집합 의미론.

263
00:12:30,340 --> 00:12:32,139
만약 제게 사건이 있다면
일관성 있게,

264
00:12:32,139 --> 00:12:35,439
그러고 싶지 않아요.
내면적인 것들을 찾다

265
00:12:35,440 --> 00:12:38,390
이 데이터 구조에서는 다음과 같은 이유로
이것은 내부적인 것이 아닙니다.

266
00:12:38,389 --> 00:12:38,889
데이터 구조.

267
00:12:38,889 --> 00:12:39,909
이것은 이를 뒷받침하지 않습니다.

268
00:12:39,909 --> 00:12:46,870
만약 제가 그 수색을 지원하고 싶다면,
예를 들어, 키 인덱스 8

269
00:12:46,870 --> 00:12:50,409
뭐 그런 거죠.
그때 내가 할 수 있는 일은 그것뿐이었다.

270
00:12:50,409 --> 00:12:51,992
— 배열처럼 보이네요.

271
00:12:51,993 --> 00:12:54,160
스크롤만 하면 될 것 같아요.
전체 시퀀스

272
00:12:54,159 --> 00:12:56,289
그리고 내게 말해줘,
그 안에 뭔가 의미가 있다.

273
00:12:56,289 --> 00:12:58,164
이보다 더 잘할 순 없어요.
선형적인 시간보다.

274
00:12:58,164 --> 00:13:00,039
이 데이터 구조
이 용도로 제작된 것이 아닙니다.

275
00:13:00,039 --> 00:13:01,039
이것은 무엇에 쓰는 것입니까?

276
00:13:01,039 --> 00:13:05,139
물건을 찾도록 설계되었습니다.
순서도에서의 인덱스에 따라.

277
00:13:05,139 --> 00:13:12,129
그렇다면 8번째 인덱스는 어떻게 찾나요?

278
00:13:12,129 --> 00:13:14,110
음, 그러니까, 저는
나는 나무를 바라본다.

279
00:13:14,110 --> 00:13:17,139
그리고 저는 그냥 셀 수 있어요
우회도로를 따라 순서대로.

280
00:13:17,139 --> 00:13:19,990
워크스루 순서는 어떻게 되나요?

281
00:13:19,990 --> 00:13:24,850
0, 1, 2, 3, 4, 5, 6, 7.

282
00:13:24,850 --> 00:13:26,529
네, 8개를 찾았습니다.

283
00:13:26,529 --> 00:13:29,470
하지만 무엇
순차적인 AVL 트리를 생성합니까?

284
00:13:32,620 --> 00:13:34,990
나는 계속
서브트리의 크기, 그리고 제가 여기에 있을 때,

285
00:13:34,990 --> 00:13:38,110
내 지수가 얼마인지 모르겠어요.

286
00:13:38,110 --> 00:13:40,899
어느 쪽인지 어떻게 알 수 있을까요?
루트에서 인덱스를 가져오시겠습니까?

287
00:13:40,899 --> 00:13:44,980
왼쪽 서브트리를 살펴봅니다.
그가 얼마나 많은 것을 가지고 있는지 알겠어요.

288
00:13:44,980 --> 00:13:47,990
여기에는 일곱 가지 물건이 있습니다.

289
00:13:47,990 --> 00:13:52,909
1, 2, 3, 4, 5, 6, 7.

290
00:13:52,909 --> 00:13:53,409
예.

291
00:13:53,409 --> 00:13:57,279
제가 찾고 있는 것은
인덱스 8을 가진 9번째 제품입니다.

292
00:13:57,279 --> 00:14:01,059
이는 다음을 의미합니다.
저는 8번째 항목입니다.

293
00:14:01,059 --> 00:14:03,484
저는 인적 번호 7번인 남자입니다.

294
00:14:03,485 --> 00:14:04,360
이해가 되시나요?

295
00:14:04,360 --> 00:14:07,310
제가 보고 있기 때문에
서브트리 크기.

296
00:14:07,309 --> 00:14:08,929
그래서 내가 뭘 알겠어?

297
00:14:08,929 --> 00:14:13,239
나는 인덱스가 I라는 것을 알고 있습니다.
제가 찾고 있는 건 제 오른쪽에 있어요.

298
00:14:13,240 --> 00:14:17,350
제가 여기로 갈게요.
그리고 저는 우연히 알게 되었어요...

299
00:14:17,350 --> 00:14:23,470
나는 어떤 인덱스인가요?
내가 지금 이 하위 트리를 보고 있는 건가요?

300
00:14:23,470 --> 00:14:25,090
0이죠, 맞죠?

301
00:14:25,090 --> 00:14:27,490
나는 원해요
하위 트리에서 첫 번째 항목입니다.  지금

302
00:14:27,490 --> 00:14:32,379
내 검색 색인이 변경되었습니다
왜냐하면 저는 실제로 그 문제를 처리해야 했기 때문입니다.

303
00:14:32,379 --> 00:14:35,740
이 여덟 가지 사항을 모두 고려하면.

304
00:14:35,740 --> 00:14:38,990
제가 찾고 있는 것은 바로 여기입니다.
인덱스에서 0번째 항목입니다.

305
00:14:38,990 --> 00:14:40,289
나는 왼쪽을 바라본다 -

306
00:14:40,289 --> 00:14:43,929
만약 왼쪽 서브트리가 없었다면,
저는 0이 될 거예요.

307
00:14:43,929 --> 00:14:45,009
그러면 나는 몸을 돌릴 것이다.

308
00:14:45,009 --> 00:14:46,330
하지만 여기에 뭔가 의미 있는 것이 있습니다.

309
00:14:46,330 --> 00:14:51,850
그래서 저는 여기서 0번째 항목을 찾고 있습니다.
즉, 오직 그 사람뿐이라는 뜻입니다.

310
00:14:51,850 --> 00:14:53,560
그리고 저는 그것을 돌려드립니다.

311
00:14:53,559 --> 00:14:56,889
사실,
이걸 삭제할게요.

312
00:14:56,889 --> 00:15:00,189
그래서 삭제할게요.

313
00:15:00,190 --> 00:15:02,610
푸유

314
00:15:02,610 --> 00:15:05,382
여기서 무슨 문제가 있는 거죠?

315
00:15:05,381 --> 00:15:06,259
청중: [알아들을 수 없음]

316
00:15:06,259 --> 00:15:07,919
제이슨 쿠: 높이가 불균형해요.

317
00:15:07,919 --> 00:15:10,610
여기서 높이가 불균형한 부분은 무엇인가요?

318
00:15:10,610 --> 00:15:12,509
대상: 왼쪽 하위 트리 -

319
00:15:12,509 --> 00:15:13,149
또는, 실례합니다.

320
00:15:13,149 --> 00:15:13,829
[없어서는 안될]

321
00:15:13,830 --> 00:15:15,280
제이슨 쿠: 이 사람은 가지고 있지 않아
균형 잡힌 성장이겠죠?

322
00:15:15,279 --> 00:15:17,100
대상: --오른쪽 하위 트리
오른쪽 [표시 안 됨].

323
00:15:17,100 --> 00:15:19,557
제이슨 쿠: 이 사람의 하위 트리
높이가 균형이 안 맞죠?

324
00:15:19,557 --> 00:15:20,250
이 녀석은 2살이에요.

325
00:15:20,250 --> 00:15:22,379
이 사람은 1개를 가지고 있어요.

326
00:15:22,379 --> 00:15:24,299
그렇다면 이 문제를 어떻게 해결해야 할까요?

327
00:15:24,299 --> 00:15:25,740
관객: 뒤돌아보세요.

328
00:15:25,740 --> 00:15:27,690
제이슨 쿠: 저희는 몇 차례 순환 근무를 합니다.

329
00:15:27,690 --> 00:15:30,470
사실 그렇습니다.
불행,

330
00:15:30,470 --> 00:15:33,570
세 번째 나쁜 사례,
어제 이야기했던 내용입니다.

331
00:15:33,570 --> 00:15:37,260
내가 시도해봤다면
이 사람을 왼쪽으로 돌려,

332
00:15:37,259 --> 00:15:38,539
그건 어떤 모습일까요?

333
00:15:38,539 --> 00:15:40,740
여기에는 12명이 있을 겁니다.

334
00:15:40,740 --> 00:15:42,240
여기에는 10명이 있을 겁니다.

335
00:15:42,240 --> 00:15:45,360
그리고 거기에 8이 더해질 것입니다.

336
00:15:45,360 --> 00:15:48,090
지금은 높이 균형이 맞지 않습니다.
반대 방향으로요, 그렇죠?

337
00:15:48,090 --> 00:15:49,950
이건 안 좋은 일이야.

338
00:15:49,950 --> 00:15:53,490
그렇다면 어떻게 해결해야 할까요?
이 경우

339
00:15:53,490 --> 00:15:59,100
저는 매우 감동받았습니다.
오른쪽에 있지만, 내 오른쪽 하위 트리

340
00:15:59,100 --> 00:16:03,899
왼쪽으로 이동했습니다.
저는 여기서 실습을 해야 해요.

341
00:16:03,899 --> 00:16:06,809
오른쪽 회전, 그리고
그다음 회전을 수행합니다.

342
00:16:06,809 --> 00:16:08,879
이것은 공식입니다.

343
00:16:08,879 --> 00:16:10,919
여기서 먼저 실행합니다
오른쪽 회전

344
00:16:10,919 --> 00:16:21,439
10에 대한 내용인데, 그러면 뭔가 얻을 수 있어요.
8, 10처럼 보이네요.

345
00:16:21,440 --> 00:16:25,150
물론, 이것은 아닙니다.
이전보다 훨씬 나아졌습니다.

346
00:16:25,149 --> 00:16:28,750
하지만 그것은 중간 단계였습니다.
문제를 해결할 수 있도록 조치를 취해 주세요.

347
00:16:28,750 --> 00:16:32,049
여기서 오른쪽으로 돌면,
그런 다음 여기서 좌회전합니다.

348
00:16:32,049 --> 00:16:34,289
기본적으로 우리는
여기서 좌회전합니다.

349
00:16:34,289 --> 00:16:38,439
하지만 그것은 가지고 있기 때문에
잘못된 방향으로 치우치다

350
00:16:38,440 --> 00:16:41,390
먼저 이것을 오른쪽으로 돌려야 합니다.
그러면 우리가 할 수 있을 거예요.

351
00:16:41,389 --> 00:16:43,569
지금 저는 당직 중입니다.
이 사람들 모두

352
00:16:43,570 --> 00:16:50,004
그리고 저는 12에 걸겠습니다.
여기, 여기 8, 여기 10.

353
00:16:53,009 --> 00:16:56,700
모두가 그것을 본다
회전이 이런 모습인가요?

354
00:16:56,700 --> 00:16:57,230
좋은.  너

355
00:16:57,230 --> 00:17:00,210
이해하는 데 시간이 좀 걸릴 겁니다.
무엇

356
00:17:00,210 --> 00:17:02,970
그러한 변화는,
여러분 모두에게 희망을 드립니다

357
00:17:02,970 --> 00:17:04,282
이러한 변화에 순응했다.

358
00:17:04,281 --> 00:17:06,449
약간의 마법이 있었어요.
내가 그림을 그리려고 했을 때.

359
00:17:06,450 --> 00:17:06,930
예?

360
00:17:06,930 --> 00:17:08,500
청중: 저는 아직도 모르겠어요
이건 나무 같아요.

361
00:17:08,500 --> 00:17:09,269
높이가 균형 잡혀 있습니다.

362
00:17:09,269 --> 00:17:10,980
제이슨 쿠: 그건 사실이 아닙니다.

363
00:17:10,980 --> 00:17:12,630
훌륭한 관찰입니다.

364
00:17:12,630 --> 00:17:13,890
왜 그렇습니까?

365
00:17:13,890 --> 00:17:15,750
이건 여전히 높이가 3이에요.

366
00:17:15,750 --> 00:17:17,549
높이는 얼마인가요?
이거요?

367
00:17:17,549 --> 00:17:19,019
1번 맞죠?

368
00:17:19,019 --> 00:17:20,700
이것은 높이 1입니다.

369
00:17:20,700 --> 00:17:23,400
그리고 사실, 내가
이 회전을 했습니다.

370
00:17:23,400 --> 00:17:27,317
모든 것을 업데이트해야 했습니다.
이러한 확장 기능.

371
00:17:27,317 --> 00:17:28,859
확장 프로그램이란 무엇인가요?
정말 필요했어요-

372
00:17:28,859 --> 00:17:31,619
어떤 서브트리
이러한 일들 동안 변했나요?

373
00:17:36,380 --> 00:17:38,810
어떻게 했는지 기억이 안 나요.
이것은 그렇게 보였다.

374
00:17:38,809 --> 00:17:41,779
그 물건은 어떻게 생겼었나요?

375
00:17:41,779 --> 00:17:46,859
10의 하위 트리에는 8이 있었으므로
하위 트리가 확실히 변경되었습니다.

376
00:17:46,859 --> 00:17:48,139
서브트리 8이 수정되었습니다.

377
00:17:48,140 --> 00:17:49,220
청중: [알아들을 수 없음]

378
00:17:49,220 --> 00:17:51,000
제이슨 쿠: 12는 변하지 않았어.

379
00:17:51,000 --> 00:17:51,500
결국.

380
00:17:51,500 --> 00:17:54,498
청중: 이
10과 8 [필수].

381
00:17:54,498 --> 00:17:55,039
제이슨 쿠: 알겠습니다.

382
00:17:55,039 --> 00:17:57,920
그래서 사례 분석이 있습니다.
강의 노트에 나와 있는 내용입니다.

383
00:17:57,920 --> 00:18:00,050
그리고 그것은 낭송 중에 만들어졌습니다.

384
00:18:00,049 --> 00:18:03,799
이것은 당신에게 다음을 알려줍니다.
이 하위 트리 A, B, C, D

385
00:18:03,799 --> 00:18:06,859
,
할 수 있는 사람들

386
00:18:06,859 --> 00:18:09,649
이러한 것들을 변화시키기 위해,
이러한 하위 트리는 변경되지 않습니다.

387
00:18:09,650 --> 00:18:12,290
유일한 하위 트리
한 번 변경됨

388
00:18:12,289 --> 00:18:15,619
이러한 수정 작업으로부터
한두 바퀴를 돌면 됩니다.

389
00:18:15,619 --> 00:18:18,859
두 개의 노드이거나,
또는 세 개의 노드,

390
00:18:18,859 --> 00:18:20,240
하위 트리가 변경되었습니다.

391
00:18:20,240 --> 00:18:23,900
그럴 수도 있습니다
그래서 세 개의 하위 트리가 변경되었습니다.

392
00:18:23,900 --> 00:18:26,000
.

393
00:18:26,000 --> 00:18:29,779
하지만 경미한 경우에만 해당됩니다.
두 개의 노드, 즉 x와 y인 것 같습니다.

394
00:18:29,779 --> 00:18:31,129
메모에 --

395
00:18:31,130 --> 00:18:32,040
변경될 수 있습니다.

396
00:18:32,039 --> 00:18:36,710
그래서 제가 이렇게 할 때,
확장값을 다시 계산해야 합니다.

397
00:18:36,710 --> 00:18:39,200
증원군으로부터
그들의 자식 요소(자식들),

398
00:18:39,200 --> 00:18:42,110
하지만 그건 그냥 변함없는 사실이에요.
숫자,

399
00:18:42,109 --> 00:18:45,779
그래서 그냥 목록을 적어볼게요.
덤불이 내 발밑에 있기 때문입니다

400
00:18:45,779 --> 00:18:47,430
변하지 않았습니다.

401
00:18:47,430 --> 00:18:47,930
좋은.

402
00:18:47,930 --> 00:18:50,279
그래서 우리는 가지고 있습니다
여기에 높이 차이가 있습니다.

403
00:18:50,279 --> 00:18:50,925
예?

404
00:18:50,925 --> 00:18:52,164
청중: [알아들을 수 없음]

405
00:18:56,742 --> 00:18:57,409
제이슨 쿠: 네.

406
00:18:57,410 --> 00:19:01,730
자, 그럼 먼저
그림 12에서

407
00:19:01,730 --> 00:19:04,009
많은 것들을 가지고 있다
하위 트리에서 --

408
00:19:04,009 --> 00:19:08,349
10과 8인데, 7을 방금 제거했어요.

409
00:19:08,349 --> 00:19:09,849
따라서 그 하위 트리는 다음과 같습니다.
확실히 바뀌었어요.

410
00:19:09,849 --> 00:19:10,980
이전에는 세 개가 있었습니다...

411
00:19:10,980 --> 00:19:12,039
청중: [알아들을 수 없음]

412
00:19:12,039 --> 00:19:14,129
제이슨 쿠: 아, 아니, 죄송합니다. 바로 그거였어요.

413
00:19:14,130 --> 00:19:14,680
예

414
00:19:14,680 --> 00:19:18,039
따라서 여기서는 노드의 세 하위 트리가 변경되었습니다.
.

415
00:19:18,039 --> 00:19:20,889
하지만 사실 이게 가장 중요한 점입니다.

416
00:19:20,890 --> 00:19:23,620
최악의 시나리오를 보여드리겠습니다.

417
00:19:23,619 --> 00:19:25,869
노드는 단 세 개뿐입니다.
실행 중에 가능함

418
00:19:25,869 --> 00:19:28,142
이들 중 하나
이중 회전,

419
00:19:28,143 --> 00:19:29,559
바뀔 수 있습니다
하위 트리들.

420
00:19:29,559 --> 00:19:32,740
그래서 우리는 그것을 고쳐야 합니다.
이 세 가지의 증가

421
00:19:32,740 --> 00:19:33,609
것들.

422
00:19:33,609 --> 00:19:36,879
경미한 경우
이건 단지 두 가지일 뿐입니다.

423
00:19:36,880 --> 00:19:38,050
좋은

424
00:19:38,049 --> 00:19:39,579
우리는 균형을 잃었습니다.

425
00:19:39,579 --> 00:19:40,599
이 문제를 어떻게 해결할 수 있을까요?

426
00:19:43,519 --> 00:19:45,889
나는 화를 낼 수도 있었다.

427
00:19:45,890 --> 00:19:49,070
저는 그 기회를 갖고 싶습니다.
여기서 우회전하세요.

428
00:19:49,069 --> 00:19:54,139
균형을 되찾기 위해, 저는 할 수 있습니다.
악은 이 두 가지를 변화시킨다.

429
00:19:54,140 --> 00:19:56,150
내가 이것들을 바꾸면
두 번째라면, 저는 그렇게 해야 할 겁니다.

430
00:19:56,150 --> 00:19:58,100
두 바퀴 도세요.
이 문제를 해결하려면,

431
00:19:58,099 --> 00:20:01,039
평균이기 때문에
왼쪽 것보다 더 무겁다.

432
00:20:01,039 --> 00:20:04,250
제가 하는 일과 비교하면요.

433
00:20:04,250 --> 00:20:09,140
하지만 난 그 정도로 나쁘진 않아.
오른쪽으로 돌겠습니다.

434
00:20:09,140 --> 00:20:10,370
어떻게 하면 되나요?

435
00:20:10,369 --> 00:20:13,129
그럼, 오른쪽으로 도세요.
6개용

436
00:20:13,130 --> 00:20:16,940
모든 것을 생략하세요
4 미만입니다

437
00:20:16,940 --> 00:20:20,075
그리고 이 하위 트리를 첨부합니다.
왼쪽 자식 트리 6으로.

438
00:20:20,075 --> 00:20:21,830
이해가 되시나요?

439
00:20:21,829 --> 00:20:22,437
부

440
00:20:22,438 --> 00:20:23,730
이거 그리면 재밌겠네요.

441
00:20:28,099 --> 00:20:30,579
제가 다시 그려볼게요.

442
00:20:30,579 --> 00:20:32,389
그게 훨씬 더 말이 되죠, 그렇죠?

443
00:20:32,390 --> 00:20:54,020
4, 11, 3, 2, 1, a
그다음은 6, 5, 9, 8, 12, 10입니다.

444
00:20:54,019 --> 00:20:57,730
이것이 6의 올바른 회전 방향입니다.

445
00:20:57,730 --> 00:21:00,519
모두가 좋아하나요?

446
00:21:00,519 --> 00:21:05,139
회전은 내 거야
x는 6이고, y는 4입니다.

447
00:21:05,140 --> 00:21:09,400
저는 A, B, C라는 서브트리를 가지고 있습니다.

448
00:21:09,400 --> 00:21:12,610
제가 하고 있는 일은 일종의...
x와 y 중 어느 것을 전환하는 것

449
00:21:12,609 --> 00:21:15,609
이것이 핵심입니다.

450
00:21:15,609 --> 00:21:23,079
이제 y는 근이고,
서브트리 B와 C는 다음과 같습니다.

451
00:21:23,079 --> 00:21:25,480
y 아래의 x의 후손.

452
00:21:25,480 --> 00:21:29,110
그리고 다음 사항을 기억해 주셨으면 합니다.
이 과정 전체에 걸쳐

453
00:21:29,109 --> 00:21:33,149
우회로를 택해야겠군.
변하지 않았습니다.

454
00:21:33,150 --> 00:21:35,600
우리는 업데이트해야 했습니다.
진행 과정에서 추가된 내용들,

455
00:21:35,599 --> 00:21:38,629
하지만 그것은 변함없습니다.
우리가 나무에 올라갈 때.

456
00:21:38,630 --> 00:21:41,510
그리고 우리는 오직 나무 위를 걷는다
로그적인 횟수.

457
00:21:41,509 --> 00:21:42,460
예?

458
00:21:42,460 --> 00:21:42,960
예

459
00:21:42,960 --> 00:21:43,880
청중: [알아들을 수 없음].

460
00:21:43,880 --> 00:21:46,778
그래서 우리가 실행할 때마다
회전, 당신은 그냥

461
00:21:46,778 --> 00:21:48,569
확장 프로그램을 업데이트하세요
[필수적]을 사용

462
00:21:48,569 --> 00:21:49,849
다음 순환 근무를 시작하기 전에요?

463
00:21:49,849 --> 00:21:50,144
제이슨 쿠: 맞습니다.

464
00:21:50,144 --> 00:21:51,375
관객 여러분: 2부입니다.

465
00:21:51,375 --> 00:21:53,869
갱신
증가는 단지

466
00:21:53,869 --> 00:21:57,379
수량 업데이트,
높이와 단순히

467
00:21:57,380 --> 00:21:58,510
남아있는 속성들...

468
00:21:58,509 --> 00:21:59,134
제이슨 쿠: 네.

469
00:21:59,134 --> 00:22:00,650
본질적으로 우리가
완료되었습니다. 우리는 그렇게 결정했습니다.

470
00:22:00,650 --> 00:22:02,390
우리가 추가하고 있을 때-

471
00:22:02,390 --> 00:22:04,610
데메인 교수
어제 저는 당신을 위해 결정했습니다.

472
00:22:04,609 --> 00:22:07,099
서브트리 속성이란 무엇인가요?

473
00:22:07,099 --> 00:22:10,490
이는 해당 부동산을 의미했습니다.
제가 계산할 수 있는 것은 이것뿐입니다.

474
00:22:10,490 --> 00:22:12,589
내 자식 요소(자식들)를 살펴보고 있습니다.

475
00:22:12,589 --> 00:22:16,250
내 자회사를 늘리세요
요소(자식)는 재귀적으로 생성됩니다.

476
00:22:16,250 --> 00:22:20,569
그래서 대신에
늘리려고 노력하다 또는 시도하다

477
00:22:20,569 --> 00:22:24,439
지역적으로 생각하기, 어떻게
이러한 증가가 있어야 합니다.

478
00:22:24,440 --> 00:22:26,990
나는 그것을 버릴 거야.
당신의 기존 증가분

479
00:22:26,990 --> 00:22:28,670
그리고 그냥 세어보세요
자식 요소(자식들)의 도움을 받아

480
00:22:28,670 --> 00:22:31,904
왜냐하면 이것은 재귀적으로,
틀림없이 맞을 것이다.

481
00:22:31,904 --> 00:22:32,779
이해가 되시나요?

482
00:22:32,779 --> 00:22:33,462
예?

483
00:22:33,462 --> 00:22:35,629
청중: 그래서, 그냥 보고 있는 거예요.
회전이 어떻게 작동하는지에 대하여.

484
00:22:35,630 --> 00:22:38,420
저한테는 어려운 일이에요.
머리를 감싸다

485
00:22:38,420 --> 00:22:41,870
그러니까, 본질적으로는 서로 자리를 바꾸는 거죠.
4와 6, 따라서

486
00:22:41,869 --> 00:22:47,389
4가 부모 노드가 됩니다.
그리고 6이 오른쪽 노드가 됩니다.

487
00:22:47,390 --> 00:22:50,480
제이슨 쿠: 저는 갈 거예요
이 그림을 그리세요.

488
00:22:50,480 --> 00:22:52,279
그냥 그게
반드시 기억해야 합니다.

489
00:22:55,420 --> 00:23:05,640
이것들은 x, B, C, A입니다.
이 이미지가 보이시나요?

490
00:23:05,640 --> 00:23:07,495
청중: [알아들을 수 없음]

491
00:23:07,494 --> 00:23:08,119
제이슨 쿠: 뭐라고요?

492
00:23:08,119 --> 00:23:09,354
청중: [알아들을 수 없음]

493
00:23:09,355 --> 00:23:09,980
제이슨 쿠: 네.

494
00:23:09,980 --> 00:23:11,089
노트에 적혀 있어요.

495
00:23:11,089 --> 00:23:12,779
별일 아니에요.

496
00:23:12,779 --> 00:23:15,139
하지만 만약 당신이 가지고 있다면
그러한 구조,

497
00:23:15,140 --> 00:23:19,009
x에게 왼쪽 자식이 있는 경우,

498
00:23:19,009 --> 00:23:21,150
이러한 하위 트리
비어있을 수도 있고 아닐 수도 있습니다.

499
00:23:21,150 --> 00:23:22,100
사실 별로 상관없어요.

500
00:23:22,099 --> 00:23:25,490
제가 할 수 있는 것은 이것입니다.
여기에서 저기로 가기 위해-

501
00:23:25,490 --> 00:23:30,779
같은 것을 가지고 있다
우회 경로의 순서,

502
00:23:30,779 --> 00:23:32,139
하지만 모양은 다릅니다.

503
00:23:32,140 --> 00:23:34,050
특히, 그것은 변했습니다.
서브트리 높이

504
00:23:34,049 --> 00:23:37,740
저것
나무의 균형을 회복하는 데 도움이 될 수 있습니다.

505
00:23:37,740 --> 00:23:39,960
그리고 이것에서
AVL의 핵심은 바로 이것입니다.

506
00:23:39,960 --> 00:23:41,350
이해가 되시나요?

507
00:23:41,349 --> 00:23:43,319
청중: 이
올바른 회전 방향인가요?

508
00:23:43,319 --> 00:23:45,210
제이슨 쿠: 이것은...

509
00:23:45,210 --> 00:23:46,680
이것은 우측 회전입니다.

510
00:23:46,680 --> 00:23:48,960
이것은 좌회전입니다.

511
00:23:48,960 --> 00:23:50,860
더 궁금한 점 있으신가요?

512
00:23:50,859 --> 00:23:51,359
예?

513
00:23:51,359 --> 00:23:54,775
청중: [알아들을 수 없음]

514
00:23:58,529 --> 00:24:00,509
제이슨 쿠: 내가
나는 나무에 올라간다.

515
00:24:00,509 --> 00:24:03,720
내가 묶어야 할 모든 매듭
밸런스 조정을 통해 문제를 해결하세요.

516
00:24:03,720 --> 00:24:07,289
하지만 이 재조정은 제대로 작동합니다.
최대 두 번의 회전,

517
00:24:07,289 --> 00:24:11,069
그리고 최대 로그가 있습니다
내가 가진 조상들 중에서,

518
00:24:11,069 --> 00:24:16,349
내 나무가
높이 2에서 균형을 이룬다

519
00:24:16,349 --> 00:24:19,109
log n 또는 그와 비슷한 것.

520
00:24:19,109 --> 00:24:21,809
이는 다음을 의미합니다.
최대치로 말하자면,

521
00:24:21,809 --> 00:24:26,309
네 번의 log n 회전을 수행해야 합니다.
왜냐하면 그들 각자는 할 수 있기 때문입니다

522
00:24:26,309 --> 00:24:27,309
두 바퀴 도세요.

523
00:24:27,309 --> 00:24:28,230
이해가 되시나요?

524
00:24:28,230 --> 00:24:31,680
사실, 여러분은 다음을 증명할 수 있습니다.
삭제 작업에서

525
00:24:31,680 --> 00:24:34,049
당신은 그렇게 해야 할 수도 있습니다
로그 수를 계산합니다

526
00:24:34,049 --> 00:24:35,430
이러한 회전은 나무를 따라 올라갑니다.

527
00:24:35,430 --> 00:24:38,190
그건 심각한 사건이었어요.

528
00:24:38,190 --> 00:24:40,980
내가 너에게 주었던 원래 나무 말이야.
피보나치 트리라고 불립니다.

529
00:24:40,980 --> 00:24:45,089
이것들은 몇 가지... 이것들
높이 면에서 가장 균형 잡힌 나무는,

530
00:24:45,089 --> 00:24:47,384
당신은 가질 수 있습니다
일정 개수의 노드.

531
00:24:52,619 --> 00:24:55,439
네, 최소 노드 수입니다.
특정 높이까지.

532
00:24:55,440 --> 00:24:56,820
어쨌든 생각해 볼 수는 있어요.

533
00:24:56,819 --> 00:24:59,529
그리고 이것을 일반화하면
충분히 큰 무언가에,

534
00:24:59,529 --> 00:25:01,470
그럼 이 물건
로그 값을 필요로 합니다

535
00:25:01,470 --> 00:25:02,759
혁명이 위로 솟아오르고 있다.

536
00:25:02,759 --> 00:25:05,069
사실 지금은
삽입함으로써

537
00:25:05,069 --> 00:25:09,269
당신은 실제로 증명할 수 있습니다.
사례 분석을 거칩니다.

538
00:25:09,269 --> 00:25:12,089
삽입 작업
항상 나무의 균형을 재조정합니다

539
00:25:12,089 --> 00:25:15,667
한 번의 리밸런싱 작업 후
, 어느

540
00:25:15,667 --> 00:25:16,834
두 번의 회전이 포함될 수 있습니다.

541
00:25:16,835 --> 00:25:19,350
이해가 되시나요?

542
00:25:19,349 --> 00:25:20,052
예?

543
00:25:20,053 --> 00:25:21,930
청중: [알아들을 수 없음]

544
00:25:27,279 --> 00:25:27,920
제이슨 쿠: 네.

545
00:25:27,920 --> 00:25:30,414
회전이 정확하네요, 이 사람
제대로 된 아이가 된다.

546
00:25:30,414 --> 00:25:31,039
청중: 네.

547
00:25:31,039 --> 00:25:33,549
그러니까, 당신은 아닐 수도 있고… 아니면 있을 수도 있다는 거죠.
특정 회전

548
00:25:33,549 --> 00:25:36,730
상황에 따라 수행할 수 없습니다.
자녀가 있으셨나요...?

549
00:25:36,730 --> 00:25:37,390
제이슨 쿠: 네.

550
00:25:37,390 --> 00:25:43,070
만약 왼쪽 서브트리가 없었다면,
회전할 수 없을 것이다

551
00:25:43,069 --> 00:25:44,679
오른쪽.

552
00:25:44,680 --> 00:25:47,340
오른쪽으로 돌려면 다음이 필요합니다.
그래서 왼손잡이 아이를 가질 수 있도록요.

553
00:25:47,339 --> 00:25:48,519
그러니까, 만약 당신이 이렇게 한다면 –

554
00:25:48,519 --> 00:25:50,440
그러면 알게 될 겁니다.
저희 코드는 실제로는

555
00:25:50,440 --> 00:25:52,420
확인 여부
왼쪽 자식 요소가 있습니다.

556
00:25:57,500 --> 00:25:59,869
이 진술은,
당신이 할 수 있는

557
00:25:59,869 --> 00:26:02,959
이전에 표현하기
다음 회전 동작 중 하나를 하세요.

558
00:26:02,960 --> 00:26:03,700
다른 건 없으세요?

559
00:26:03,700 --> 00:26:04,559
예?

560
00:26:04,559 --> 00:26:06,393
청중: 단지
다시 말씀드리지만, 삽입을 위해서입니다.

561
00:26:06,393 --> 00:26:09,096
두 번 이하의 회전이 필요할 수 있습니다.
[표시 불가]??

562
00:26:09,096 --> 00:26:09,680
제이슨 쿠: 음.

563
00:26:09,680 --> 00:26:11,680
일정량
혁명과 제거

564
00:26:11,680 --> 00:26:14,539
로그를 취할 수 있습니다
회전수.

565
00:26:14,539 --> 00:26:16,490
이것은 그것이 아닙니다
당신은 알아야 합니다.

566
00:26:16,490 --> 00:26:19,460
이건 제 모습이 아닙니다.
제가 여기서 증명해 보이겠습니다.

567
00:26:19,460 --> 00:26:21,650
그냥 뭐든지
흥미로운.

568
00:26:21,650 --> 00:26:26,390
있다
CRS와 같은 리밸런싱 방식.

569
00:26:26,390 --> 00:26:31,310
그들은 빨간색과 검은색을 도입합니다.
균형을 가져다주는 나무.

570
00:26:31,309 --> 00:26:34,669
그리고 이 나무들은 실제로
연결이 약합니다.

571
00:26:34,670 --> 00:26:39,680
그들은 그다지 그렇지 않다
AVL 트리처럼 균형이 잡혀 있습니다.

572
00:26:39,680 --> 00:26:44,029
이를 통해 2보다 더 많은 왜곡이 발생할 수 있습니다.

573
00:26:44,029 --> 00:26:46,399
그리고 이것 이후로
겉보기에는 더 약한 제한,

574
00:26:46,400 --> 00:26:49,470
그들은 통제 불능 상태가 되어 오직 그것만을 행한다
일정한 회전 수 -

575
00:26:49,470 --> 00:26:54,559
그들은 그것을 감당할 수 있다.
나무를 고치기 전에.

576
00:26:54,559 --> 00:26:56,149
하지만 그보다 조금 더 복잡합니다.

577
00:26:56,150 --> 00:26:57,680
청중: [알아들을 수 없음]

578
00:27:00,457 --> 00:27:01,290
제이슨 쿠: 아주 좋습니다.

579
00:27:01,289 --> 00:27:01,789
좋은.

580
00:27:01,789 --> 00:27:02,779
이와 관련해서 궁금한 점이 있으신가요?

581
00:27:06,089 --> 00:27:10,549
좋아요, 이제 더 빨라졌네요.
당신이 묻는 기계적인 질문

582
00:27:10,549 --> 00:27:11,750
문제 풀이 과정에서 받게 될 것입니다.

583
00:27:11,750 --> 00:27:15,950
이제 좀 더 자세히 살펴보겠습니다.
이론적인 유형의 질문입니다.

584
00:27:15,950 --> 00:27:19,230
이것들은 다음과 같을 것입니다.
감축 문제.

585
00:27:19,230 --> 00:27:19,730
좋은.

586
00:27:19,730 --> 00:27:25,250
이것이 첫 번째 문제입니다, 픽 누리.

587
00:27:25,250 --> 00:27:26,839
이분은... 누구신가요?

588
00:27:26,839 --> 00:27:27,649
닉 퓨리 맞죠?

589
00:27:27,650 --> 00:27:31,280
이건 어벤져스를 언급하는 겁니다.

590
00:27:31,279 --> 00:27:33,799
그래서 본질적으로 무엇을
이 경우에는 다음과 같은 일이 일어나고 있습니다.

591
00:27:33,799 --> 00:27:38,210
그것들의 목록이 있습니다
슈퍼히어로들, 각각은

592
00:27:38,210 --> 00:27:41,150
~인지 아닌지에 대해 의견이 있다
그들은 사노스와 싸우러 가야 한다.

593
00:27:43,819 --> 00:27:49,220
그리고 그들의 의견은
매우 긍정적이다

594
00:27:49,220 --> 00:27:50,730
또는 매우 부정적입니다.

595
00:27:50,730 --> 00:27:54,319
그렇다면 Fick은 무엇일까요?
이것을 하려고 노력하고 있다

596
00:27:54,319 --> 00:27:59,960
그중에서 찾으세요
그들의 어벤져스는 바로 그 어벤져스입니다.

597
00:27:59,960 --> 00:28:04,819
가장 극단적인 견해들,
저것

598
00:28:04,819 --> 00:28:05,887
그는 그들과 대화할 수 있었다.

599
00:28:05,887 --> 00:28:07,429
그는 그러고 싶지 않아요.
모든 사람과 소통하세요.

600
00:28:07,430 --> 00:28:10,039
그는 이야기하고 싶어합니다
로그 함수적인 수의 그것들.

601
00:28:10,039 --> 00:28:11,029
좋은.

602
00:28:11,029 --> 00:28:14,720
뭐랄까, 그냥 그래.

603
00:28:14,720 --> 00:28:18,799
요컨대, 우리는 가지고 있습니다.
비밀 상황,

604
00:28:18,799 --> 00:28:22,759
당신에게 방법이 주어지는 곳
읽기 전용 입력 데이터 저장소

605
00:28:22,759 --> 00:28:23,980
이러한 것들을 배열 형태로 배열합니다.

606
00:28:26,900 --> 00:28:31,975
그리고 저는 찾고 싶어요
가장 강력한 잡지

607
00:28:31,974 --> 00:28:32,474
생각들.

608
00:28:32,474 --> 00:28:34,137
이해가 되시나요?

609
00:28:34,137 --> 00:28:35,929
그리고 저는 그걸 하고 싶어요.
그리고 첫 번째 문제

610
00:28:35,930 --> 00:28:39,440
선형 시간입니다.

611
00:28:39,440 --> 00:28:42,769
당신은 아직 잘 모르잖아요.
어떻게 하는가

612
00:28:42,769 --> 00:28:47,809
당신은 그 방법을 알게 될 것입니다.
당신이 다루는 내용은-

613
00:28:47,809 --> 00:28:50,419
그럼, 그들이 당신에게 가르쳐 줄 겁니다.
046에서 한 가지 방법으로 하세요.

614
00:28:50,420 --> 00:28:53,690
하지만 우리는 가지 않을 거예요
지금 당장 해야 해요.  화요일에

615
00:28:53,690 --> 00:28:59,400
하나 더 가르쳐 드리겠습니다
그렇게 하는 방법

616
00:28:59,400 --> 00:29:01,370
바이너리 힙을 사용합니다.

617
00:29:01,369 --> 00:29:03,979
바이너리 힙 —
흥미로운 일이네요.

618
00:29:03,980 --> 00:29:14,390
이는 부분집합을 구현합니다.
설치된 인터페이스.

619
00:29:14,390 --> 00:29:23,150
정말 간단해요. 당신도 할 수 있어요.
반복된 x를 기반으로 구축합니다.

620
00:29:23,150 --> 00:29:25,269
저는 여러 가지 물건을 모으고 있어요.

621
00:29:25,269 --> 00:29:26,779
이 물건들에는 열쇠가 있습니다.  마찬가지로

622
00:29:26,779 --> 00:29:29,089
이것은 핵심 데이터 구조입니다.
.

623
00:29:29,089 --> 00:29:32,099
그는 우리가 흔히 말하는 것을 실행합니다.
우선순위 큐 인터페이스.

624
00:29:32,099 --> 00:29:33,859
저는 이런 것들을 만들 수 있어요.

625
00:29:33,859 --> 00:29:39,379
저는 뭔가를 삽입할 수 있지만,
저는 여기서 그렇게 하지 않을 거예요.

626
00:29:39,380 --> 00:29:43,490
내가 정말 필요한 건
이러한 상황에서는,

627
00:29:43,490 --> 00:29:47,150
이것은 최상급 삭제 작업입니다.

628
00:29:47,150 --> 00:29:50,870
이 경우, 아마도 최대일 것입니다.

629
00:29:50,869 --> 00:29:52,114
최대값을 삭제합니다.

630
00:29:57,559 --> 00:29:58,399
그러니까, 마치- 안에 있는 것처럼요.

631
00:29:58,400 --> 00:30:01,713
저는 데이터 구조를 가지고 있습니다.
나는 이것들을 이렇게 부른다.

632
00:30:01,712 --> 00:30:02,629
이해가 되시나요?

633
00:30:02,630 --> 00:30:02,890
예?

634
00:30:02,890 --> 00:30:04,190
청중: 무엇인가요?
우선순위 대기열?

635
00:30:04,190 --> 00:30:04,519
제이슨 쿠: 네.

636
00:30:04,519 --> 00:30:06,559
우선순위 큐는 다음과 같습니다.
본질적으로, 무엇

637
00:30:06,559 --> 00:30:08,450
이 두 가지를 구현합니다.

638
00:30:08,450 --> 00:30:11,569
사실 세 번째 이유도 있습니다.
새로운 것을 삽입할 수 있는 곳,

639
00:30:11,569 --> 00:30:13,279
하지만 그는 내 거야
지금은 필요 없을 거예요.

640
00:30:13,279 --> 00:30:14,738
그게 바로 그거예요.
우선순위 대기열.

641
00:30:14,738 --> 00:30:15,890
그리고 사실, 그 세트는 -

642
00:30:15,890 --> 00:30:19,180
이것은 부분집합입니다.
전화 걸기 인터페이스.

643
00:30:19,180 --> 00:30:20,299
오른쪽?

644
00:30:20,299 --> 00:30:22,250
좋은 점은

645
00:30:22,250 --> 00:30:25,160
구매-- 보여주지 않겠습니다
어떻게 하는 건가요?

646
00:30:25,160 --> 00:30:27,380
하지만 그 무리가 할 수 있는 일은 무엇일까요?

647
00:30:27,380 --> 00:30:29,870
내가 이 두 가지를 모두 구현한다면
운영

648
00:30:29,869 --> 00:30:34,519
설치된 AVL 트리를 사용하여 얼마나 오래 걸릴까요?
이런 것들이 왜 필요할까요?

649
00:30:41,430 --> 00:30:43,566
얼마나 걸리나요?
AVL 트리 집합을 구성하려면 어떻게 해야 할까요?

650
00:30:46,970 --> 00:30:48,620
n log n 맞죠?

651
00:30:48,619 --> 00:30:50,959
사실, 저는
정렬된 주문을 받습니다.

652
00:30:50,960 --> 00:30:53,299
만약에
이것들을 넣고 있어요.

653
00:30:53,299 --> 00:30:55,220
차례로,

654
00:30:55,220 --> 00:30:57,319
아니면 제가 분류해 드릴 수도 있어요.
그런 다음 놓으세요

655
00:30:57,319 --> 00:31:00,500
선형 시간으로 트리 구조로 변환합니다.
며칠 전에 보셨듯이

656
00:31:00,500 --> 00:31:03,779
그러므로 암송에서.

657
00:31:03,779 --> 00:31:05,839
하지만 언젠가는 정리해야겠죠.
그렇지 않나요?

658
00:31:07,339 --> 00:31:10,169
나는 가져가야 해
적어도 n log n 시간,

659
00:31:10,170 --> 00:31:14,120
내가 원한다면
순회 순서를 반환합니다.

660
00:31:14,119 --> 00:31:18,109
선형 시간에서, 그리고 나는 가지고 있다
하한 n log

661
00:31:18,109 --> 00:31:21,799
정렬을 위해 n이 필요했습니다.
여기서 n log n 시간을 보냅니다.

662
00:31:21,799 --> 00:31:23,029
그렇지 않나요?

663
00:31:23,029 --> 00:31:26,523
그리고 얼마나 걸릴까요?
이 delete_max를 실행하는 데 시간이 걸릴까요?

664
00:31:26,523 --> 00:31:28,631
청중: 이것은 정렬되어 있으므로 n을 입력하세요.

665
00:31:28,632 --> 00:31:29,590
제이슨 쿠: 로그 n, 맞죠?

666
00:31:29,589 --> 00:31:31,019
이것은 AVL 트리의 집합입니다.

667
00:31:31,019 --> 00:31:31,950
내 최대치는 어디까지일까요?

668
00:31:31,950 --> 00:31:33,180
이것이 가장 정확한 설명입니다.

669
00:31:33,180 --> 00:31:35,519
이쪽으로 걸어가면 돼요.
이것저것, 벗어.

670
00:31:35,519 --> 00:31:37,049
균형을 다시 잡아야 할지도 모르겠네요.

671
00:31:37,049 --> 00:31:39,419
하지만 이것은 log n개의 작업이 필요합니다.

672
00:31:39,420 --> 00:31:44,400
이것은 다음과 같습니다.
마지막 항목을 하위 트리에 삽입합니다.

673
00:31:44,400 --> 00:31:46,860
설치된 AVL 트리의 경우
그것은 n log n입니다.

674
00:31:46,859 --> 00:31:47,669
이것은 잡지 n입니다.

675
00:31:50,609 --> 00:31:53,969
이제 또 다른 하나가 생겼습니다.
성능이 더 좋은 데이터 구조

676
00:31:53,970 --> 00:31:55,559
이러한 작전 중 하나.

677
00:31:55,559 --> 00:32:01,019
그리고 다른 하나도 마찬가지로, 대략
우리가 앞서 배웠던 내용입니다.

678
00:32:01,019 --> 00:32:03,599
혹시 기억하는 사람 있나요?

679
00:32:03,599 --> 00:32:05,429
AVL 트리 설치
우리에게 제대로 주지는 않았어요

680
00:32:05,430 --> 00:32:11,910
위에는 아무것도 정렬되어 있지 않습니다.
동적 배열의 배열.

681
00:32:11,910 --> 00:32:14,805
그것은 우리에게 무엇을 주었습니까? 우리는...

682
00:32:14,805 --> 00:32:17,730
우리는 이것을 n log n 시간 안에 해결할 수 있습니다.
병합 정렬 등을 사용해서

683
00:32:17,730 --> 00:32:18,789
비슷한.

684
00:32:18,789 --> 00:32:22,500
그러면 우리는 그냥
마지막 항목을 n번 추출합니다.

685
00:32:22,500 --> 00:32:23,789
감가상각될 것입니다...

686
00:32:23,789 --> 00:32:26,837
그러니까, 만약 내가 그러지 않았다면 말이죠.
돌보느라 신경 썼다

687
00:32:26,837 --> 00:32:29,129
이 정도 크기면 제가 할 수 있을 것 같아요.
최악의 경우, 시간은 일정하게 유지됩니다.

688
00:32:29,130 --> 00:32:31,380
방금 읽었어요.
처음-마지막.

689
00:32:31,380 --> 00:32:33,750
저는 크기를 조정할 필요가 전혀 없어요.
정렬.

690
00:32:33,750 --> 00:32:35,940
그냥 무시하면 돼요.

691
00:32:35,940 --> 00:32:37,150
이해가 되시나요?

692
00:32:37,150 --> 00:32:37,650
좋은.

693
00:32:37,650 --> 00:32:39,130
하지만 그건… 괜찮아요.

694
00:32:39,130 --> 00:32:43,230
만약 제가 데이터 구조를 가지고 있다면,
이 두 가지를 구현할 것입니다

695
00:32:43,230 --> 00:32:49,769
수술, 누군가 할 수 있을까요?
알고리즘을 알려주세요

696
00:32:49,769 --> 00:32:52,025
고정 목록을 생성하기 위해 --

697
00:32:52,025 --> 00:32:54,150
걱정하지 마세요
지금은 근무시간이지만, 이것은

698
00:32:54,150 --> 00:32:55,800
이 두 가지 연산만 사용합니까?

699
00:32:59,269 --> 00:33:00,349
예?

700
00:33:00,349 --> 00:33:03,529
청중: 그래서 우리는 만들어냅니다
이 데이터 구조.

701
00:33:03,529 --> 00:33:05,134
그것은 ~부터 배열되어 있습니다.
가장 작은 것부터 가장 큰 것까지

702
00:33:05,134 --> 00:33:07,829
x의 절댓값 방향으로.

703
00:33:07,829 --> 00:33:11,879
제이슨 쿠: 걱정하지 마세요.
어디에 대해

704
00:33:11,880 --> 00:33:13,130
물건 주문 같은 거요.

705
00:33:13,130 --> 00:33:16,310
이것들이 어떻게 작동하는지는 말해주지 않을 거예요
꿈꿔왔던 일들이 현실이 되어가고 있네요, 그렇죠?

706
00:33:16,309 --> 00:33:20,329
저는 제가 할 수 있다는 말을 하는 것뿐이에요.
이런 것들을 많이 받아들이는 것,

707
00:33:20,329 --> 00:33:24,500
그리고 저는 삭제할 수 있습니다
최대값을 반환하세요.

708
00:33:24,500 --> 00:33:25,329
좋은?

709
00:33:25,329 --> 00:33:26,829
청중: 저도 그렇게 생각해요.
우리는 그것을 만들어낼 뿐입니다.

710
00:33:26,829 --> 00:33:29,711
이것을 꼭 만들어주세요
그래서 사고의 수준은 다음과 같습니다.

711
00:33:29,711 --> 00:33:31,670
절댓값
사고의 단계, 아닙니다-

712
00:33:31,670 --> 00:33:32,060
제이슨 쿠: 물론이죠.

713
00:33:32,059 --> 00:33:32,559
좋은.

714
00:33:32,559 --> 00:33:33,720
그건 좋은 일이죠.

715
00:33:33,720 --> 00:33:36,410
나는 무엇을 해야 할까, 어떻게 해야 할까
당신의 동료가 말했습니다.

716
00:33:36,410 --> 00:33:39,830
제가 이 문제를 알아보겠습니다.
모든 것은 각자의 기여로 이루어진다.

717
00:33:39,829 --> 00:33:44,509
제가 복사할게요
녹화를 위한 일종의 메모리 저장 장치.

718
00:33:44,509 --> 00:33:47,150
이건 읽기 전용이에요.
이 부분과는 관련이 없습니다.

719
00:33:47,150 --> 00:33:48,807
문제점들.

720
00:33:48,807 --> 00:33:49,849
제가 하려는 일은...

721
00:33:56,950 --> 00:33:57,549
오른쪽.

722
00:33:57,549 --> 00:33:58,049
죄송합니다

723
00:33:58,049 --> 00:34:00,789
당신을 생각하고 있어요.
우리가 작성하는 문제 세트.

724
00:34:00,789 --> 00:34:01,750
저는 여러 가지를 섞어서 쓰고 있어요.

725
00:34:01,750 --> 00:34:09,789
알겠습니다, 복사해서 붙여넣겠습니다.
당사의 새로운 선형 크기 배열.

726
00:34:09,789 --> 00:34:11,679
하지만 놓는 대신에
그것들이 가진 의미는,

727
00:34:11,679 --> 00:34:13,422
저는 절대적인 것을 넣을 거예요
그것들의 의미가 갖는 의미.

728
00:34:13,422 --> 00:34:14,170
이해가 되시나요?

729
00:34:14,170 --> 00:34:15,420
결과가 음성인지 확인하는 것뿐이에요.

730
00:34:15,420 --> 00:34:17,949
그렇다면 투자하겠습니다.
긍정적인 면이 있습니다.

731
00:34:17,949 --> 00:34:19,300
좋은?

732
00:34:19,300 --> 00:34:23,440
그런 다음 이것을 삽입합니다.
배열을 이 어셈블리에 넣습니다.

733
00:34:23,440 --> 00:34:26,619
내가 거기에 놓았어.

734
00:34:26,619 --> 00:34:29,199
이 작업에는 시간이 좀 걸릴 것입니다.
창조 시기와 관계없이.

735
00:34:29,199 --> 00:34:33,489
그러면 저는 할 수 있어요
최대 k번까지 삭제할 수 있습니다.

736
00:34:33,489 --> 00:34:38,170
아니면 최대값을 제거할 수도 있습니다.
때로는 아무리 많은 것들이 있더라도

737
00:34:38,170 --> 00:34:38,739
저는 그게 필요 없어요.

738
00:34:38,739 --> 00:34:39,760
오른쪽?

739
00:34:39,760 --> 00:34:44,050
가장 높은 n개의 항목을 등록하고 싶다면,
저는 이 계산을 n번 반복할 수 있습니다.

740
00:34:44,050 --> 00:34:44,860
그렇지 않나요?

741
00:34:44,860 --> 00:34:48,219
그래서 만약 내가
그러한 데이터 구조,

742
00:34:48,219 --> 00:34:51,579
한 번에 할 수 있어요.
이 작업을 시작합니다

743
00:34:51,579 --> 00:34:55,174
그리고 n번 실행을 등록합니다
이 작전의.

744
00:34:55,175 --> 00:34:56,050
이해가 되시나요?

745
00:34:56,050 --> 00:34:57,610
저는 이 문제를 해결할 수 있습니다.
문제를 줄임으로써 해결

746
00:34:57,610 --> 00:34:59,289
이 데이터 구조.

747
00:34:59,289 --> 00:35:05,980
이제 정렬된 배열을 살펴보겠습니다.
또는 설치된 AVL 트리,

748
00:35:05,980 --> 00:35:08,155
이 작전
벌써부터 너무 힘들어요.

749
00:35:08,155 --> 00:35:10,420
이것은 n log n 시간이 걸립니다.

750
00:35:10,420 --> 00:35:13,360
좋은 것
이진 힙에서

751
00:35:13,360 --> 00:35:17,099
그것은 이것을 수행한다는 것입니다.
선형 시간에서의 연산.

752
00:35:20,059 --> 00:35:21,849
화요일에 보실 수 있을 거예요.

753
00:35:21,849 --> 00:35:26,289
그리고 그는 이렇게 합니다
log n 시간 동안의 작업.

754
00:35:30,650 --> 00:35:34,220
근무 시간은 어떻게 되나요?
바이너리 힙을 사용한다면

755
00:35:34,219 --> 00:35:37,519
이를 구현하기 위해
데이터 구조?

756
00:35:37,519 --> 00:35:42,019
n번 주문하세요
로그 n 곱하기 로그 n.

757
00:35:42,019 --> 00:35:44,989
log n 제곱은 얼마나 큰가요?

758
00:35:44,989 --> 00:35:48,550
n의 제곱은 n과 비교한 것일까요?

759
00:35:48,550 --> 00:35:49,835
더 작죠?

760
00:35:49,835 --> 00:35:51,710
그래서 이 두 가지를 더하면
함께 일했던 시간들,

761
00:35:51,710 --> 00:35:54,260
여전히 선형적일 것입니다.

762
00:35:54,260 --> 00:35:57,020
그러니 당신이 결정하세요.
첫 번째 과제.

763
00:35:57,019 --> 00:35:59,750
굳이 말씀드릴 필요는 없었잖아요.
바이너리 힙이란 무엇인가요?

764
00:35:59,750 --> 00:36:00,842
혹은 그녀가 어떻게 그 일을 해내는지.

765
00:36:00,842 --> 00:36:02,300
내가 필요했던 모든 것
여러분께 말씀드리고 싶은 것은, 이것이 바로 그것입니다.

766
00:36:02,300 --> 00:36:04,220
이 수술이 시행되었습니다
선형 시간에서

767
00:36:04,219 --> 00:36:05,989
그리고 이것은
해당 작업은 저널 시간 n에 실행되었습니다.

768
00:36:10,550 --> 00:36:11,720
좋은

769
00:36:11,719 --> 00:36:14,779
마법이 펼쳐질 것입니다
화요일에 당신에게.

770
00:36:14,780 --> 00:36:19,730
파트 B에서는 다음과 같이 말합니다. 이제 다음과 같이 가정해 봅시다.
픽의 컴퓨터

771
00:36:19,730 --> 00:36:22,550
다음에서만 녹음이 허용됩니다.
공간 로그 n.

772
00:36:22,550 --> 00:36:23,210
네, 알겠습니다.

773
00:36:23,210 --> 00:36:24,260
문제는 바로 이것입니다.

774
00:36:24,260 --> 00:36:29,570
우리는 예전에 복사를 했었으니까요.
전체 배열,

775
00:36:29,570 --> 00:36:34,137
필터링했고,
그 후 몇 가지 수술이 진행되었습니다.

776
00:36:34,137 --> 00:36:35,720
하지만 우리는 그것조차 할 수 없었어요.
그것을 살 여유가 있다면

777
00:36:35,719 --> 00:36:40,559
전부를 구할 순 없었어
외부 쓰기 가능한 메모리에 저장됩니다.

778
00:36:40,559 --> 00:36:42,090
그러므로 우리는 이것을 할 수 없습니다.

779
00:36:42,090 --> 00:36:46,820
어떤 의미에서는 그렇습니다.
보다 제한적인 환경.

780
00:36:46,820 --> 00:36:49,590
할 수 있는 일이 줄어들었어요.

781
00:36:49,590 --> 00:36:53,539
내 것보다 성능이 떨어집니다.
이전 상황에서

782
00:36:53,539 --> 00:36:57,500
공간이 정말 많았어요.
얼마나 사용하시겠어요?

783
00:36:57,500 --> 00:37:02,000
그래서 그것은 특정한 것을 가지고 있습니다.
즉, 내가 그럴 수도 있다는 뜻입니다.

784
00:37:02,000 --> 00:37:07,489
근무시간을 제한할 수 없었다.
우리가 이전에 가지고 있던 것.

785
00:37:07,489 --> 00:37:10,039
어쩌면 그래야 할지도 몰라요.
무언가를 희생하다

786
00:37:10,039 --> 00:37:13,059
왜냐하면 저는 더 제한적인 상황에 있기 때문입니다.
계산 조건.

787
00:37:17,119 --> 00:37:19,563
자, 이것이 바로 당신이 해야 할 일입니다.
이진 힙을 사용하면 해결할 수 있습니다.

788
00:37:19,563 --> 00:37:20,480
하지만 이는 필수적인 것은 아닙니다.

789
00:37:20,480 --> 00:37:27,860
당신은 이 문제를 해결할 수 있습니다.
AVL 트리 세트를 사용합니다.

790
00:37:27,860 --> 00:37:29,960
혹시 아이디어 있으신 분 계신가요?
해결 방법에 관하여

791
00:37:29,960 --> 00:37:32,750
고정된 AVL 트리를 사용하고 있나요?

792
00:37:32,750 --> 00:37:37,429
제 수량이 제한되어 있습니다.
내 공간은 최대 log n입니다.

793
00:37:40,710 --> 00:37:43,472
청중: 그럼 공간이 얼마나 되나요?
AVL 트리 집합을 차지합니까?

794
00:37:43,472 --> 00:37:44,139
제이슨 쿠: 맞습니다.

795
00:37:44,139 --> 00:37:47,079
공간 - 그것은 불변의 요소이다
포인터의 수

796
00:37:47,079 --> 00:37:49,029
각 노드에 대해.

797
00:37:49,030 --> 00:37:52,510
그리고 나는 그것을 마음속에 간직한다.
메모와 공간.

798
00:37:52,510 --> 00:37:57,520
본질적으로 모든 데이터 구조는
저희가 보여드린 것처럼 공간을 차지합니다.

799
00:37:57,519 --> 00:38:00,130
사물의 질서,
우리가 간직하고 있는 것.

800
00:38:00,130 --> 00:38:02,269
이것은 추가 공간을 차지하지 않습니다.

801
00:38:02,269 --> 00:38:05,500
시간이 더 걸릴 수도 있습니다.
특정한 일들을 하기 위해,

802
00:38:05,500 --> 00:38:09,456
하지만 공간이 차지됩니다
품목 수,

803
00:38:09,456 --> 00:38:11,539
우리가 보유하는 것 외에도,
어쩌면 일정한 요소일지도 모릅니다.

804
00:38:14,260 --> 00:38:18,430
그래서 저는 제 의견을 여기에 적어보겠습니다.
저는 읽을 수는 있지만,

805
00:38:18,429 --> 00:38:20,072
저는 글을 쓸 줄 몰라요.

806
00:38:20,072 --> 00:38:20,739
이것 좀 주시겠어요...?

807
00:38:20,739 --> 00:38:26,169
전화만 할게요
이게 A입니다. 자, 이게 제 목록입니다.

808
00:38:26,170 --> 00:38:29,019
모든 생각은 리벤저에게 향합니다.

809
00:38:29,019 --> 00:38:31,659
저는 읽기만 할 수 있어요.

810
00:38:31,659 --> 00:38:36,139
하지만 제 컴퓨터는 쓰기만 할 수 있습니다.
이 로그 볼륨에

811
00:38:36,139 --> 00:38:36,639
공간.

812
00:38:42,659 --> 00:38:46,279
이 공간에 무엇을 넣을 수 있을까요?

813
00:38:46,280 --> 00:38:49,500
청중: 잡지 [알아들을 수 없음]?

814
00:38:49,500 --> 00:38:53,250
제이슨 쿠: 네, 물론 할 수 있죠.
거기에 통나무와 여러 가지 물건들을 놓으세요.

815
00:38:53,250 --> 00:38:55,090
그래서 만약 내가 주어진다면
이것은 한계점입니다.

816
00:38:55,090 --> 00:38:58,985
저는 아마 만들고 싶을 거예요.
그러한 크기의 데이터 구조

817
00:38:58,985 --> 00:39:00,360
다음 내용을 포함합니다
여러 가지 것들.

818
00:39:00,360 --> 00:39:02,797
이해가 되시나요?

819
00:39:02,797 --> 00:39:04,380
왜냐하면 뭐 때문에?
그래도 하실 건가요?

820
00:39:08,000 --> 00:39:10,380
그래서 제가 아이디어를 하나 드렸죠.

821
00:39:10,380 --> 00:39:12,800
어쩌면 우리가 사용할 수 있을지도 몰라요
여기 AVL 세트가 있습니다.

822
00:39:12,800 --> 00:39:16,460
제 답변에 로그가 있는 것을 봤습니다.

823
00:39:16,460 --> 00:39:21,170
우리가 그럴 가능성이 꽤 높습니다.
정렬된 배열

824
00:39:21,170 --> 00:39:23,300
또는 AVL 관련 장비를 설치했거나.

825
00:39:23,300 --> 00:39:26,360
이것들은 내게 일기를 준다
근무 시간 중 어딘가에,

826
00:39:26,360 --> 00:39:27,440
그렇지 않나요?

827
00:39:27,440 --> 00:39:30,929
참 논리적이네요.
내가 뭘 할 수 있을까?

828
00:39:30,929 --> 00:39:32,599
여기에 AVL 트리 세트가 있을 것입니다.

829
00:39:32,599 --> 00:39:37,809
설치된 AVL 트리가 왜 그럴 수 있나요?
저에게 도움이 될까요?

830
00:39:37,809 --> 00:39:38,309
예?

831
00:39:38,309 --> 00:39:39,750
청중: 왜냐하면
정리가 완료되었고, 이제 가지셨습니다.

832
00:39:39,750 --> 00:39:41,284
아니요
통과의례, 당신

833
00:39:41,284 --> 00:39:45,304
통과 순서를 계산할 수 있습니다
[표시 불가]를 삽입하시겠습니까?

834
00:39:45,304 --> 00:39:45,929
제이슨 쿠: 물론이죠.

835
00:39:45,929 --> 00:39:47,409
저는 이 모든 것을 할 수 있습니다.

836
00:39:47,409 --> 00:39:49,319
하지만 특히,
이것은 도움이 될 것입니다

837
00:39:49,320 --> 00:39:54,860
나
큰 놈을 빨리 찾겠죠?

838
00:39:54,860 --> 00:40:00,340
만약 제가 세트를 가지고 있다면
일들은 그렇게 될 겁니다...

839
00:40:00,340 --> 00:40:02,150
그리고 나는 계속
이 데이터 구조,

840
00:40:02,150 --> 00:40:05,960
첨가
그것의 구성 요소,

841
00:40:05,960 --> 00:40:08,780
어느 것인지 알 수 있을까요?
가장 큰--

842
00:40:08,780 --> 00:40:12,710
또는 가장 작은 것—
로그 n 시간 안에 상당히 빠르게.

843
00:40:12,710 --> 00:40:17,780
그래서 만약 제가 가지고 있다면
나무에는 n개의 것들이 있습니다.

844
00:40:17,780 --> 00:40:19,242
이 물건은 키가 얼마나 되나요?

845
00:40:19,242 --> 00:40:20,186
청중: [알아들을 수 없음]

846
00:40:20,186 --> 00:40:21,470
제이슨 쿠: 매거진 매거진 n.

847
00:40:21,469 --> 00:40:23,324
이거 왠지 익숙한데.

848
00:40:23,324 --> 00:40:24,199
그렇다면 제가 감당할 수 있는 금액은 얼마일까요?

849
00:40:24,199 --> 00:40:31,759
저는 일정 금액을 감당할 수 있습니다.
AVL 트리의 옵션 연산

850
00:40:31,760 --> 00:40:34,231
이 데이터 구조에 대해서.

851
00:40:34,231 --> 00:40:35,455
네, 질문 있으셨나요?

852
00:40:35,454 --> 00:40:36,329
청중: [알아들을 수 없음]

853
00:40:36,329 --> 00:40:37,329
제이슨 쿠: 네, 죄송합니다.

854
00:40:37,329 --> 00:40:38,007
예?

855
00:40:38,007 --> 00:40:39,549
청중: 그래서
AVL 트리였습니다.

856
00:40:39,550 --> 00:40:42,680
이 나무를 BTS 나무로 만들어야 할까요?

857
00:40:42,679 --> 00:40:43,960
제이슨 쿠: 어, BTS…

858
00:40:43,960 --> 00:40:45,809
영국 서머타임.

859
00:40:45,809 --> 00:40:48,110
그래서 제가 ~에 대해 이야기할 때는…

860
00:40:48,110 --> 00:40:49,760
누군가는 한국 K팝을 좋아합니다.

861
00:40:49,760 --> 00:40:50,610
좋은.

862
00:40:50,610 --> 00:40:55,820
그러니까, BST는 당연히...

863
00:40:55,820 --> 00:40:58,610
특수 용어,
당신은 아마도 그럴 겁니다.

864
00:40:58,610 --> 00:41:00,860
듣는 것에 익숙해져 있다
다른 맥락에서,

865
00:41:00,860 --> 00:41:04,309
이것은 무슨 의미일까요?
클래스, 이것은 AVL 트리입니다.

866
00:41:04,309 --> 00:41:08,239
때때로 무엇이
사람들이 전화하다

867
00:41:08,239 --> 00:41:12,500
이진 검색 트리가 아닙니다.
균형 의미론을 가지고 있습니다.

868
00:41:12,500 --> 00:41:16,190
그렇다면 우리가 부를 수 있는 것은 무엇일까요?
이 클래스는 집합의 이진 트리입니다.

869
00:41:16,190 --> 00:41:20,150
하지만 사실 그것들은 유용합니다.
균형이 잡혀있기 때문입니다.

870
00:41:20,150 --> 00:41:22,309
그러므로 우리는
보통은 그냥 추측하죠.

871
00:41:22,309 --> 00:41:24,449
우리가 지금 무슨 이야기를 하고 있는 거죠?
균형 잡힌 것들.

872
00:41:24,449 --> 00:41:28,730
이제 AVL 트리 세트에는 이것이 있습니다.
이진 탐색 트리의 의미론,

873
00:41:28,730 --> 00:41:30,789
열쇠가 정렬되는 곳.

874
00:41:30,789 --> 00:41:32,539
이 물건들에는 열쇠가 있습니다.
그리고 그것들은 순서대로 배열되어 있습니다.

875
00:41:32,539 --> 00:41:34,369
이것은 설치된 인터페이스입니다.

876
00:41:34,369 --> 00:41:36,980
저희는 또한 다음과 같이 발표했습니다.
당신은 일관성이 있습니다

877
00:41:36,980 --> 00:41:41,900
이것들을 위한 인터페이스
저것들은 열쇠조차 없어요.

878
00:41:41,900 --> 00:41:45,440
어떻게 저장할 수 있나요?
거기에 집합 의미론이 존재하나요?

879
00:41:45,440 --> 00:41:47,059
자, 이것이 바로
우리가 가진 차이점은

880
00:41:47,059 --> 00:41:53,360
우리가 이진법에 대해 이야기할 때 의미하는 바는 다음과 같습니다.
탐색 트리 vs. 사실 집합

881
00:41:53,360 --> 00:41:54,660
AVL 트리 vs. [알아들을 수 없는 부분].

882
00:41:54,659 --> 00:41:55,159
예?

883
00:41:55,159 --> 00:41:57,742
청중: 그럼, 이걸 살펴보면,
이를 기반으로 AVL 트리를 생성하려면,

884
00:41:57,742 --> 00:42:00,650
이것은 언제라는 것을 의미할까요?
우리는 노드를 생성하고, 그 노드에게 다음과 같이 알려줍니다.

885
00:42:00,650 --> 00:42:03,829
우리는 절대의 영역으로 들어갑니다
값 [필수적]??

886
00:42:03,829 --> 00:42:09,349
제이슨 쿠: 좋아요, 당신이
AVL 트리 세트를 생성합니다.

887
00:42:09,349 --> 00:42:11,942
당신은 우리에게 무엇을 말하는지 알려줘야 합니다.
객체를 저장하는 경우,

888
00:42:11,943 --> 00:42:13,610
당신은 말해야 합니다
저한테, 그들의 열쇠는 뭐죠?

889
00:42:13,610 --> 00:42:15,170
그냥 저장하세요
몇 가지 숫자,

890
00:42:15,170 --> 00:42:18,110
제가 여기서 잘하고 있는 걸까요?

891
00:42:18,110 --> 00:42:19,970
현재 이것은 설치된 AVL 트리가 아닙니다.

892
00:42:19,969 --> 00:42:21,559
하지만 만약 내가 그냥
저는 숫자를 기록합니다.

893
00:42:21,559 --> 00:42:25,400
그 요소들에 대해 알려드려야겠습니다.
제가 보관하고 있는 것은 열쇠입니다.

894
00:42:25,400 --> 00:42:26,684
그리고 나서 모든 것이 따라옵니다.

895
00:42:26,684 --> 00:42:28,309
하지만 만약 당신이 가지고 있다면
당신이 가진 물건

896
00:42:28,309 --> 00:42:30,750
어떻게 해야 할지 알아내려고 노력 중
이 방에 있는 학생들은,

897
00:42:30,750 --> 00:42:33,130
당신은 많은 부동산을 소유하고 있습니다.

898
00:42:33,130 --> 00:42:38,599
저는 모든 사람들이
전화번호가 있었다.

899
00:42:38,599 --> 00:42:41,299
어쩌면 내가 원하는 걸지도 몰라
어떤 이유로든 전화번호를 제공해 주셔야 합니다.

900
00:42:41,300 --> 00:42:44,150
이것이 저에게 도움이 될 것입니다.
당신이 어디에 사는지 알아내려고요?

901
00:42:44,150 --> 00:42:45,680
난… 이게 아니야.
점점...

902
00:42:45,679 --> 00:42:47,269
나는 그곳에 가고 싶지 않아.

903
00:42:47,269 --> 00:42:50,282
하지만 내가 당신에게 준다면
AVL 트리 세트,

904
00:42:50,282 --> 00:42:51,949
제가 꼭 말씀드려야겠어요.
설정된 값입니다.

905
00:42:51,949 --> 00:42:55,789
내가 너에게 준다면
순차적 AVL 트리,

906
00:42:55,789 --> 00:42:57,920
어떤 모습일지 곧 명확해질 것입니다.
제 연산 순서는 다음과 같습니다.

907
00:42:57,920 --> 00:43:00,320
왜냐하면
순서를 알려드리겠습니다.

908
00:43:00,320 --> 00:43:03,740
입구는 이런 모습이었습니다.

909
00:43:03,739 --> 00:43:05,149
이해가 되시나요?

910
00:43:05,150 --> 00:43:10,250
네, 알겠습니다.
크기가 log n인 AVL 트리 집합.

911
00:43:10,250 --> 00:43:12,677
그것의 핵심은 무엇이어야 할까요?

912
00:43:12,677 --> 00:43:13,719
청중: 절대값.

913
00:43:13,719 --> 00:43:15,919
제이슨 쿠: 전적으로 동감합니다.
그들의 선호도의 가치 --

914
00:43:15,920 --> 00:43:18,099
또는 그들의 의견.

915
00:43:18,099 --> 00:43:20,769
기억이 안 나요.
저건 뭐라고 부르나요?

916
00:43:20,769 --> 00:43:23,489
그런데 잡지 관련 내용은 뭐죠?
여기에 놓아도 될까요?

917
00:43:28,239 --> 00:43:30,549
모르겠습니다.

918
00:43:30,550 --> 00:43:32,260
나는 아무것도 몰라요.
이런 것들에 대해서요.

919
00:43:32,260 --> 00:43:35,270
하나보다
다른 것보다 더 나은가요?

920
00:43:35,269 --> 00:43:37,900
그냥 넣어보자
n개의 사물을 다룬 첫 번째 잡지.

921
00:43:37,900 --> 00:43:39,680
이해가 되시나요?

922
00:43:39,679 --> 00:43:40,179
좋은

923
00:43:40,179 --> 00:43:43,899
이것은 내게 무엇을 알려줄 수 있을까?

924
00:43:43,900 --> 00:43:45,490
이제 저는 이걸 저기에 놓았습니다.

925
00:43:45,489 --> 00:43:47,810
얼마나 오래 지속되었나요?

926
00:43:47,811 --> 00:43:49,640
청중: [알아들을 수 없음]

927
00:43:49,639 --> 00:43:55,759
제이슨 쿠: n번 등록하세요.
등록, n번 등록하는 거죠?

928
00:43:55,760 --> 00:43:58,520
하지만 그 차이는 훨씬 적습니다.
우리보다 훨씬 오랜 시간 동안,

929
00:43:58,519 --> 00:44:01,800
우리가 찾고 있는 것,
그래서 난 상관없어.

930
00:44:01,800 --> 00:44:04,760
제 말은, 저는 당신이 그렇게 해주길 바란다는 뜻이에요.
그들은 얼마나 걸렸는지 말했다.

931
00:44:04,760 --> 00:44:06,527
하지만 제 목적상
이게 뭔지 알아요.

932
00:44:06,527 --> 00:44:08,360
보다
제가 원하는 근무 시간입니다.

933
00:44:08,360 --> 00:44:10,160
저도 그런 수술을 한 적이 있어요.

934
00:44:10,159 --> 00:44:12,139
나
이제는 상관없어요.

935
00:44:12,139 --> 00:44:12,859
예?

936
00:44:12,860 --> 00:44:14,720
청중: 어떻게 얻게 되셨어요?
log n을 log log n으로 곱하면 어떻게 될까요?

937
00:44:14,719 --> 00:44:16,302
제이슨 쿠: 왜냐하면
사물의 수

938
00:44:16,302 --> 00:44:19,109
나는 그것을 여기에 보관합니다
사물은 로그 n입니다.

939
00:44:19,110 --> 00:44:24,050
그래서 만약 제가 패턴을 맞춰본다면
AVL 트리 생성 시간

940
00:44:24,050 --> 00:44:29,870
그리고 거기에 log n을 삽입합니다.
그러면 log n 곱하기 log n이 됩니다.

941
00:44:29,869 --> 00:44:31,219
좋은.

942
00:44:31,219 --> 00:44:33,439
청중: 그래서 이건
단 한 번의 반복만으로 가능한가요?

943
00:44:33,440 --> 00:44:36,920
제이슨 쿠: 음, 지금 당장은요,
방금 이걸 만들었어요.

944
00:44:36,920 --> 00:44:40,460
어쩌면… 제가 한 번 만들어봤을 뿐이라서요.

945
00:44:40,460 --> 00:44:44,630
저는 또한 아마도 다음과 같이 주장합니다.
다시 만들 필요가 없어요.

946
00:44:44,630 --> 00:44:47,660
내가 뭘 할 수 있을까...
이제 알겠어요...

947
00:44:47,659 --> 00:44:51,289
저는 전혀 필터링을 하지 않았습니다.
귀하의 데이터입니다.

948
00:44:51,289 --> 00:44:55,659
저는 이런 것들을 그냥 간직하고 있어요.
특정한 순서대로.

949
00:44:55,659 --> 00:44:59,779
제가 할 수 있는 일은 무엇일까요?
처리 시작될 수도 있습니다

950
00:44:59,780 --> 00:45:01,670
나머지 데이터는요?

951
00:45:01,670 --> 00:45:02,360
예?

952
00:45:02,360 --> 00:45:06,490
청중: [잘 안 들림] 시도해 보세요
스크롤 목록 A

953
00:45:06,489 --> 00:45:09,829
그리고 그런 사람을 찾아보세요
~보다 더 큰

954
00:45:09,829 --> 00:45:13,429
저장하려고 노력하세요
최대 [표시 불가].

955
00:45:13,429 --> 00:45:16,099
제이슨 쿠: 이 사람 좀 연결해 줘.
물건을 넣는 것에 관해서,

956
00:45:16,099 --> 00:45:18,980
그리고 언제나 응원합니다...

957
00:45:18,980 --> 00:45:20,990
내가 이렇게 하면, 그리고
나는 자꾸 뭔가를 붙여버려.

958
00:45:20,989 --> 00:45:23,489
n 제가 이것을 가져갈게요
끝에는 무엇이 있을까요?

959
00:45:23,489 --> 00:45:28,909
이제 저는 읽을 수 있습니다.
가장 큰 k개 항목.

960
00:45:28,909 --> 00:45:33,289
하지만 제가 삽입하면
여기 있는 것들,

961
00:45:33,289 --> 00:45:34,610
제 물건이 점점 커지고 있어요.

962
00:45:34,610 --> 00:45:35,809
청중: 좋아요, 그럼요.
가장 작은 것을 제거하세요.

963
00:45:35,809 --> 00:45:37,184
제이슨 쿠: 오,
사소한 것들을 제거하세요.

964
00:45:37,184 --> 00:45:38,293
이 아이디어 마음에 드네요.

965
00:45:38,293 --> 00:45:39,710
청중: 그래서
교체하세요.

966
00:45:39,710 --> 00:45:40,940
제이슨 쿠: 네,
기본적으로 교체하는 겁니다.

967
00:45:40,940 --> 00:45:41,630
오른쪽.

968
00:45:41,630 --> 00:45:43,010
나는 어떻게 해야 하지?

969
00:45:43,010 --> 00:45:44,810
제안 하나 드리겠습니다.

970
00:45:44,809 --> 00:45:49,070
우리는 가져갈 것입니다
다음 사람, 그 사람을 투입하세요.

971
00:45:49,070 --> 00:45:51,519
아주.

972
00:45:51,519 --> 00:45:54,009
그들 중 어느 쪽?
지금 내가 신경 쓰겠어?

973
00:45:54,010 --> 00:45:55,600
저기 있는 것 중에 제일 작은 거야.

974
00:45:55,599 --> 00:45:57,849
그러니 가장 작은 것들을 내쫓으세요.

975
00:45:57,849 --> 00:46:00,099
자, 이것은,
나는 5월에 갇혀버렸어.

976
00:46:00,099 --> 00:46:01,549
가장 작아지세요.

977
00:46:01,550 --> 00:46:03,580
그래서 그냥 지나가 봤어요.
이 때문에,

978
00:46:03,579 --> 00:46:05,299
그럼 제가 얼마나 걸렸을까요?

979
00:46:10,032 --> 00:46:11,490
이것이 내 손을 잡았다.
이 나무의 높이.

980
00:46:11,489 --> 00:46:12,194
이 나무의 높이는 얼마입니까?

981
00:46:12,195 --> 00:46:13,070
청중: [알아들을 수 없음]

982
00:46:13,070 --> 00:46:15,300
제이슨 쿠: 매거진 매거진 n.

983
00:46:15,300 --> 00:46:18,570
그래서 하나를 내려놓았는데,
또 다른 발췌문입니다.

984
00:46:18,570 --> 00:46:20,638
이게 제일 작은 거죠?

985
00:46:20,637 --> 00:46:22,679
그리고 저는 계속해서 그렇게 하고 있습니다.
끝까지.

986
00:46:22,679 --> 00:46:23,762
얼마나 걸렸을까요?

987
00:46:23,762 --> 00:46:25,069
제이슨 쿠: [알아들을 수 없는 말]

988
00:46:28,414 --> 00:46:29,039
제이슨 쿠: 네.

989
00:46:29,039 --> 00:46:34,889
n에서 log n을 뺀 값을 처리합니다.
요소의 개수는 기본적으로 n과 같습니다.

990
00:46:34,889 --> 00:46:37,230
그리고 이들 각각
저는 수술을 받았습니다.

991
00:46:37,230 --> 00:46:39,119
나무 한 그루와 같은 시간.

992
00:46:39,119 --> 00:46:40,920
이것은 나에게
우리가 근무하는 시간

993
00:46:40,920 --> 00:46:45,960
우리는 n log log n을 찾고 있습니다.

994
00:46:45,960 --> 00:46:46,500
감각?

995
00:46:46,500 --> 00:46:48,840
청중: 이건 마치 ~을 떠올리게 하네요.
슬라이딩 윈도우 기법?

996
00:46:48,840 --> 00:46:48,960
제이슨 쿠: 네.

997
00:46:48,960 --> 00:46:50,760
이것은 일종의
슬라이딩 윈도우 기법.

998
00:46:50,760 --> 00:46:53,100
어쩌면 당신은
최근에 사용했어요.

999
00:46:56,469 --> 00:46:56,969
좋은.

1000
00:46:56,969 --> 00:46:58,321
모두 이 의견에 동의하시나요?

1001
00:46:58,322 --> 00:46:58,858
예?

1002
00:46:58,858 --> 00:47:00,900
청중: 잠깐만요
그 맥락을 다시 떠올려 주세요

1003
00:47:00,900 --> 00:47:05,170
우리는 이것이 로그라고 말합니다.
통나무 n, 나무처럼, 그리고 어디에...

1004
00:47:05,170 --> 00:47:07,170
제이슨 쿠: 그러니까 이 물건은...
이것의 크기는 —

1005
00:47:07,170 --> 00:47:08,494
로그 로그 n?

1006
00:47:08,494 --> 00:47:09,119
청중: 네.

1007
00:47:09,119 --> 00:47:10,452
제이슨 쿠: 아니... 죄송합니다, 잡지 n.

1008
00:47:10,452 --> 00:47:15,438
그리고 이것의 높이는
크기는 카드 한 벌 정도입니다.

1009
00:47:15,438 --> 00:47:19,065
청중: 죄송합니다.
크기가 n인 작은 통나무

1010
00:47:19,065 --> 00:47:25,269
[필수품] 소형
n그루의 나무를 통나무로 만든 로그, 또는...

1011
00:47:25,269 --> 00:47:27,150
제이슨 쿠: 아, 네... 죄송합니다.

1012
00:47:27,150 --> 00:47:29,789
저는 이 자료를 가져가겠습니다.

1013
00:47:29,789 --> 00:47:32,039
중간 단계는 없습니다
데이터 구조--

1014
00:47:32,039 --> 00:47:37,105
방금 모든 걸 다 넣었어요.
이것들을 AVL 세트에 넣으세요.

1015
00:47:37,105 --> 00:47:37,605
예?

1016
00:47:37,605 --> 00:47:39,030
청중: [알아들을 수 없음]

1017
00:47:39,030 --> 00:47:43,200
제이슨 쿠: 한 번에
AVL 세트의 크기는 log n입니다.

1018
00:47:43,199 --> 00:47:48,496
그 사람을 투입할게요.
저는 최악의 남자를 지명합니다.

1019
00:47:48,496 --> 00:47:49,829
모든 것을 살펴보고 있습니다.

1020
00:47:49,829 --> 00:47:52,409
저는 다음 사항을 확인해야 합니다.
제가 삽입하면,

1021
00:47:52,409 --> 00:47:55,739
추적 중입니다.
리벤저란 무엇인가요?

1022
00:47:55,739 --> 00:47:57,719
그렇다면 나는 무엇을 받아들이는가?
절댓값,

1023
00:47:57,719 --> 00:48:00,449
그리고 이 모든 것들
하찮은 일.

1024
00:48:00,449 --> 00:48:02,250
하지만 그게 기본적인 아이디어입니다.

1025
00:48:02,250 --> 00:48:05,730
그냥 가져갈게요.
나는 창문을 닫는다.

1026
00:48:05,730 --> 00:48:07,829
뭔가를 넣고 있어요.
나는 뭔가를 꺼낸다.

1027
00:48:07,829 --> 00:48:11,460
그럴 가능성이 있을 수도 있고 없을 수도 있습니다.
똑같지 않아요.

1028
00:48:11,460 --> 00:48:14,490
그리고 결국에는
이 절차

1029
00:48:14,489 --> 00:48:17,069
불변적인, 내가
제가 여기에 보관하는 것은 바로 이것입니다.

1030
00:48:17,070 --> 00:48:23,730
내 물건은 항상 그랬다
그중 가장 훌륭한 생각들,

1031
00:48:23,730 --> 00:48:24,925
지금까지 제가 처리한 내용입니다.

1032
00:48:24,925 --> 00:48:26,550
이것은 명백히 사실입니다.
일찍,

1033
00:48:26,550 --> 00:48:27,930
내가 이걸 만들 때.

1034
00:48:27,929 --> 00:48:31,319
그리고 마지막에 이르러서는, 저는
모든 것을 처리했습니다.

1035
00:48:31,320 --> 00:48:38,309
그리고 이것은 크기가 n인 로그를 가지고 있습니다.
그래서 저는 가장 큰...에 대한 일지를 가지고 있습니다.

1036
00:48:38,309 --> 00:48:41,730
가장 극단적인 생각들.

1037
00:48:41,730 --> 00:48:43,990
그러면 저는 그냥 하면 됩니다.
우회로

1038
00:48:43,989 --> 00:48:46,139
이건 괜찮으니 돌아오세요.

1039
00:48:46,139 --> 00:48:47,289
이해가 되시나요?

1040
00:48:47,289 --> 00:48:50,130
그리고 저는 오직 사용만 했습니다.
로그 공간.

1041
00:48:53,210 --> 00:48:53,710
예?

1042
00:48:53,710 --> 00:48:55,001
관객: 잠깐만요, 무슨 말인지 모르겠어요.

1043
00:48:55,001 --> 00:49:00,090
모든 생각은 다 무엇일까요?
이 AVL 트리에서요?

1044
00:49:00,090 --> 00:49:02,340
제이슨 쿠: 모두 다 있나요?
이 AVL 트리에 대한 의견이 있으신가요?

1045
00:49:02,340 --> 00:49:05,519
이 모든 생각들
AVL 트리에 있습니다.

1046
00:49:05,519 --> 00:49:12,179
그리고 어느 순간 나는
모든 생각을 담겠습니다.

1047
00:49:12,179 --> 00:49:14,039
이 AVL 트리에.

1048
00:49:14,039 --> 00:49:17,639
하지만 저는 삭제할 겁니다.
내가 신경 쓰지 않는 사람들,

1049
00:49:17,639 --> 00:49:18,222
업무 중에.

1050
00:49:18,222 --> 00:49:19,139
이해가 되시나요?

1051
00:49:19,139 --> 00:49:22,859
나는 항상 간직하고 있다
불변량,

1052
00:49:22,860 --> 00:49:26,010
이 물건은 이전에는
무언가를 삽입하기 위해,

1053
00:49:26,010 --> 00:49:29,100
정확히 log n개의 요소를 포함합니다.
그리고 나서 나는

1054
00:49:29,099 --> 00:49:31,889
나는 이것을 불변의 원칙으로 삼는다.
하나 삽입, 하나 제거

1055
00:49:31,889 --> 00:49:32,529
.

1056
00:49:32,530 --> 00:49:35,178
청중: 아, 그렇군요.
어떤 것을 삭제하시겠습니까?

1057
00:49:35,177 --> 00:49:36,719
제이슨 쿠: 언제나
적어도 나 때문에

1058
00:49:36,719 --> 00:49:38,666
제일 큰 걸로 주세요.

1059
00:49:38,666 --> 00:49:40,500
청중: 그리고 민
절댓값.

1060
00:49:40,500 --> 00:49:42,329
제이슨 쿠: 네.

1061
00:49:42,329 --> 00:49:45,210
저는 절대적인 것에 집중하고 있습니다.
이러한 생각들의 가치.

1062
00:49:45,210 --> 00:49:45,710
예?

1063
00:49:45,710 --> 00:49:48,510
청중: [잘 안 들림]?

1064
00:49:48,510 --> 00:49:51,390
제이슨 쿠: 여기서 총 근무 시간은 몇 시간인가요?

1065
00:49:51,389 --> 00:49:52,829
이것은 회계입니다.

1066
00:49:52,829 --> 00:50:01,469
저는 로그인이 필요했어요
시간 log log n 시간,

1067
00:50:01,469 --> 00:50:05,429
이것을 만들기 위해
처음에 데이터 구조를 살펴보겠습니다.

1068
00:50:05,429 --> 00:50:11,039
n 곱하기 log log n을 더합니다.

1069
00:50:11,039 --> 00:50:15,509
저는 기본적으로 n건의 수술을 했습니다.
점근적으로 n번의 연산.

1070
00:50:15,510 --> 00:50:19,620
그러므로 실제로는
n에서 log n을 뺀 연산.

1071
00:50:19,619 --> 00:50:22,739
그리고 이들 각각
트리 작업--

1072
00:50:22,739 --> 00:50:25,349
삽입 1회, 삭제 1회 수행 -

1073
00:50:25,349 --> 00:50:28,750
그들 각자는 차지했다
나무의 높이.

1074
00:50:28,750 --> 00:50:31,440
그게 다입니다.

1075
00:50:31,440 --> 00:50:32,820
좋은?

1076
00:50:32,820 --> 00:50:33,420
예?

1077
00:50:33,420 --> 00:50:36,249
청중: 하나 대신에
넣고 빼기만 하면 됩니다.

1078
00:50:36,248 --> 00:50:39,029
비교해본 다음...

1079
00:50:39,030 --> 00:50:42,720
제이슨 쿠:
삽입 및 삭제

1080
00:50:42,719 --> 00:50:45,929
AVL 트리
실제로 비교를 수행합니다.

1081
00:50:45,929 --> 00:50:47,069
데이터 구조에서.

1082
00:50:47,070 --> 00:50:47,910
청중: 단지
최소값과 비교하세요.

1083
00:50:47,909 --> 00:50:48,409
그런 다음...

1084
00:50:48,409 --> 00:50:50,489
제이슨 쿠: 물론이죠.
당신은 할 수 있어요.

1085
00:50:50,489 --> 00:50:52,409
나는 다르게 할 수도 있었다.

1086
00:50:52,409 --> 00:50:56,789
삭제할 수 있어요
여기에 가장 작은 요소가 있습니다.

1087
00:50:56,789 --> 00:50:58,860
우선, 그렇죠?

1088
00:50:58,860 --> 00:51:00,870
그리고 나서 비교해 봅니다.
이 사람이랑 같이 있어요.

1089
00:51:00,869 --> 00:51:04,369
그렇다면, 어느 쪽을 선택할까요?
더 이상은 안 되겠네요. 다시 제자리에 놓겠습니다.

1090
00:51:04,369 --> 00:51:06,159
똑같습니다.

1091
00:51:06,159 --> 00:51:09,259
난 그냥 그렇게 해.
먼저 삭제한 다음 삽입하세요.

1092
00:51:09,260 --> 00:51:12,940
내가 뭘 하고 있는 거지?
먼저 삽입하고, 그 다음 삭제하는 건가요?

1093
00:51:12,940 --> 00:51:14,829
더 궁금한 점 있으신가요?

1094
00:51:14,829 --> 00:51:15,590
질문이 많습니다.

1095
00:51:15,590 --> 00:51:16,090
좋은

1096
00:51:16,090 --> 00:51:18,940
음, 제 생각엔 제가
그 문제는 건너뛰어야 할 것 같습니다.

1097
00:51:18,940 --> 00:51:22,059
이제 컴퓨터 과학으로 넘어가겠습니다.

1098
00:51:22,059 --> 00:51:23,529
아니요, SCLR입니다.

1099
00:51:27,039 --> 00:51:28,396
여기서 연결 고리는 무엇인가요?

1100
00:51:28,396 --> 00:51:30,100
청중: [알아들을 수 없음]

1101
00:51:30,099 --> 00:51:32,230
제이슨 쿠: 네, 의원님들.

1102
00:51:32,230 --> 00:51:34,630
이들은 네 명의 학자입니다.
인기 있는 교과서를 쓴 사람

1103
00:51:34,630 --> 00:51:37,519
컴퓨터 과학 분야에서.

1104
00:51:37,519 --> 00:51:39,880
이것도 같은 종류입니다.
케이.

1105
00:51:39,880 --> 00:51:44,769
그들은 초판본들을 발견했고
그들은 그것들을 경매로 팔고 싶어합니다.

1106
00:51:44,769 --> 00:51:46,552
사람들은 바꿀 수 있습니다
그들의 웹사이트로.  안에

1107
00:51:46,552 --> 00:51:47,469
입찰자 식별자가 있습니다.

1108
00:51:47,469 --> 00:51:49,899
이것은 고유 식별자입니다.

1109
00:51:49,900 --> 00:51:53,829
그리고 그들은 내기할 수 있어요
이 책들 중 한 권을 위해서요.

1110
00:51:53,829 --> 00:51:57,400
그리고 그들은 그것을 바꿀 수 있습니다.
입찰 기간 동안,

1111
00:51:57,400 --> 00:52:00,639
하지만 결국에는
거래 기간

1112
00:52:00,639 --> 00:52:06,112
학자들은 원한다
누구인지 알기 위해-

1113
00:52:06,112 --> 00:52:08,079
예상되는
소득 I

1114
00:52:08,079 --> 00:52:10,059
나는 k를 그 사람들에게 팔아서 돈을 벌 것이다.
가장 높은 가격을 제시할 사람은 누구일까요?

1115
00:52:10,059 --> 00:52:13,469
이해가 되시나요?

1116
00:52:13,469 --> 00:52:15,929
예?

1117
00:52:15,929 --> 00:52:16,589
좋은.

1118
00:52:16,590 --> 00:52:22,559
생성하기 전에 다음 사항을 참고하세요.
이 데이터 구조,

1119
00:52:22,559 --> 00:52:24,690
저는 k가 무엇인지 압니다.
k는 고정된 값입니다.

1120
00:52:27,360 --> 00:52:31,230
제 근무 시간이...
get-revenue는 이 k에 따라 달라집니다.

1121
00:52:31,230 --> 00:52:34,469
이것은 입력 데이터가 아닙니다.
이 작업을 위해.

1122
00:52:34,469 --> 00:52:37,529
그러니까, k는 내가 그렇지 않다는 뜻이야.
나는 그것이 무엇인지 미리 알고 있다.

1123
00:52:37,530 --> 00:52:39,630
n 곱하기 2일 수도 있습니다.

1124
00:52:39,630 --> 00:52:42,180
로그 n일 수도 있습니다.

1125
00:52:42,179 --> 00:52:43,589
이것은 1일 수 있습니다.

1126
00:52:46,559 --> 00:52:48,539
하지만 데이터 구조는
나는 창조한다, 나는 반드시 창조한다

1127
00:52:48,539 --> 00:52:50,940
이것들을 만족시키세요
런타임 속성,

1128
00:52:50,940 --> 00:52:55,329
k의 선택과 관계없이
과학자들이 내게 말해줬어.

1129
00:52:55,329 --> 00:52:57,900
이해가 되시나요?

1130
00:52:57,900 --> 00:53:03,090
제가 해야 할 일은 그것과 함께 하는 것입니다.
시간이 지남에 따라

1131
00:53:03,090 --> 00:53:07,920
사람들이 새로운 베팅을 하고 있습니다
그리고 요금을 업데이트합니다.

1132
00:53:07,920 --> 00:53:11,889
그리고 이러한 업데이트
오랜 시간이 걸릴 수 있습니다.

1133
00:53:11,889 --> 00:53:14,639
하지만 방금 전에는
창문을 닫겠습니다.

1134
00:53:14,639 --> 00:53:21,250
나는 판단할 수 있기를 원한다
일정한 시간 동안, 즉

1135
00:53:21,250 --> 00:53:24,670
k 최고 요금.

1136
00:53:24,670 --> 00:53:26,460
이 문제를 해결할 방법을 아시는 분 계신가요?

1137
00:53:26,460 --> 00:53:28,210
어떤 작업들
어떻게 해야 할까요?

1138
00:53:28,210 --> 00:53:32,920
제게는 기회가 있습니다.
새로운 베팅을 하세요.

1139
00:53:32,920 --> 00:53:37,690
입찰자와 함께
관련 아이디어 및 내기,

1140
00:53:37,690 --> 00:53:39,440
이것 또한 정수입니다 —

1141
00:53:39,440 --> 00:53:41,440
저는 몇 달러를 받게 되나요?
이 책값을 지불하기 위해.

1142
00:53:44,050 --> 00:53:45,700
입찰가를 수정하세요.

1143
00:53:45,699 --> 00:53:48,460
어찌 보면, 저는 그걸 알아내야 해요.
이 사람이 한 일

1144
00:53:48,460 --> 00:53:51,829
더 일찍 베팅하세요,
내 데이터 구조.

1145
00:53:51,829 --> 00:53:54,699
그래서 어느 시점에서 저는
입찰자 ID를 찾아야 합니다.

1146
00:53:54,699 --> 00:53:57,500
이게 가능해 보이나요?

1147
00:53:57,500 --> 00:53:59,800
그래서 저는 그럴 수도 있었죠.
사전

1148
00:53:59,800 --> 00:54:01,930
입찰자 식별자.

1149
00:54:01,929 --> 00:54:05,259
내가 갖고 싶다고 말할 때
어떤 것에 관한 사전,

1150
00:54:05,260 --> 00:54:08,800
맞아요, 저요.
아직은 말해주지 않을게요.

1151
00:54:08,800 --> 00:54:11,080
나는 어떻게 가고 있나요?
이 사전을 구현하세요.

1152
00:54:11,079 --> 00:54:13,014
제가 일반적으로 선택할 수 있는 옵션은 무엇인가요?

1153
00:54:13,014 --> 00:54:14,779
해시 테이블.

1154
00:54:14,780 --> 00:54:16,750
하지만 만약 제가 필요하다면 어쩌죠?
최악의 경우 시간은 언제일까요?

1155
00:54:19,389 --> 00:54:21,119
AVL 트리 세트 맞죠?

1156
00:54:21,119 --> 00:54:23,739
이것은 당신의 것입니다.
사전에서 선택한 것,

1157
00:54:23,739 --> 00:54:26,114
왜냐하면 그것은 줄 것이기 때문입니다
저는 물건들을 찾아볼 시간이 있어요.

1158
00:54:26,114 --> 00:54:28,619
열쇠를 사용하여.

1159
00:54:28,619 --> 00:54:31,559
이것이 유일한 것입니다.
음, 정렬된 것들을 제외하고는-

1160
00:54:31,559 --> 00:54:33,869
또한 사용할 수도 있습니다.
정렬된 배열,

1161
00:54:33,869 --> 00:54:36,179
하지만 이것은
동적이지 않을 것입니다.

1162
00:54:36,179 --> 00:54:38,699
그리고 저희는 여기에서 지속적으로 업데이트하고 있습니다.
내 데이터 구조에 있는 사람은 누구인가요?

1163
00:54:38,699 --> 00:54:39,779
.

1164
00:54:39,780 --> 00:54:43,850
사람들이 들어온다.
그리고 베팅을 하세요 -

1165
00:54:43,849 --> 00:54:45,119
새로운 사람들이 베팅을 하고 있습니다.

1166
00:54:45,119 --> 00:54:47,279
그러므로, 제가 가진 것들은 다음과 같습니다.
제가 관심을 갖는 것들,

1167
00:54:47,280 --> 00:54:48,572
끊임없이 변화하고 있습니다.

1168
00:54:48,572 --> 00:54:50,280
그래서 이것은 아마도
내 집중을 방해할 것이다

1169
00:54:50,280 --> 00:54:52,440
정렬된 배열에서,
그들은 그렇지 않기 때문입니다.

1170
00:54:52,440 --> 00:54:55,920
동적 운영에 적합합니다.

1171
00:54:55,920 --> 00:54:59,610
그래서 저는 필요할 거예요
입찰자 식별자에 관한 일종의 사전 같은 것,

1172
00:54:59,610 --> 00:55:06,120
하지만 저에게는 또한 필요한 것이 있습니다.
합계 k를 유지합니다

1173
00:55:06,119 --> 00:55:06,809
가장 높은 참여율을 보인 참가자들.

1174
00:55:06,809 --> 00:55:08,710
이해가 되시나요?

1175
00:55:08,710 --> 00:55:10,650
그러므로 어떤 경우에는
즉, 나는 필요하다는 뜻입니다.

1176
00:55:10,650 --> 00:55:18,878
정렬된 개념을 추적하기 위해
입찰자, 입찰

1177
00:55:18,878 --> 00:55:19,920
내 데이터 구조에 있습니다.

1178
00:55:19,920 --> 00:55:22,079
이해가 되시나요?

1179
00:55:22,079 --> 00:55:24,460
그러므로 순서대로
금리 변동이 중요할 것입니다.

1180
00:55:24,460 --> 00:55:28,409
저는 필요할 거예요
입찰자 ID를 확인하세요.

1181
00:55:28,409 --> 00:55:31,329
그게 전부인 것 같죠?

1182
00:55:31,329 --> 00:55:31,829
좋은.

1183
00:55:31,829 --> 00:55:32,099
예?

1184
00:55:32,099 --> 00:55:32,670
청중: 확인차 여쭤보는 거예요.

1185
00:55:32,670 --> 00:55:34,045
그래서 만약 어떤 것이 있다면
최악의 시나리오

1186
00:55:34,045 --> 00:55:38,550
최악의 시기에 실행됩니다.
예상대로 작동합니다 [필수품].

1187
00:55:38,550 --> 00:55:39,150
제이슨 쿠: 네.

1188
00:55:39,150 --> 00:55:40,260
오른쪽.

1189
00:55:40,260 --> 00:55:42,390
예

1190
00:55:42,389 --> 00:55:44,190
아주 훌륭한 지적입니다.

1191
00:55:44,190 --> 00:55:46,590
최악의 상황에서 작동한다면
시간이 지나면 그는 또한

1192
00:55:46,590 --> 00:55:47,972
예정된 시간에 시작하는 거죠?

1193
00:55:47,972 --> 00:55:49,805
왜냐하면 본질적으로 여기서는,
무작위화 없음,

1194
00:55:49,804 --> 00:55:51,649
제가 말씀드리고 싶은 것은 바로 이것입니다.

1195
00:55:51,650 --> 00:55:54,619
청중: [잘 안 들림]?

1196
00:55:54,619 --> 00:55:55,449
제이슨 쿠: 네.

1197
00:55:55,449 --> 00:55:58,889
그러므로,
우리는 당신이 더 강력한 의견을 제시해주기를 바랍니다.

1198
00:55:58,889 --> 00:56:01,769
즉, 현실은 그렇다는 것입니다.
여기에는 무작위성이 없습니다.

1199
00:56:01,769 --> 00:56:04,259
저희는 해시 테이블을 사용하지 않습니다.

1200
00:56:04,260 --> 00:56:07,973
이 수업에서는 실제로 그렇습니다.
유일한 상황

1201
00:56:07,972 --> 00:56:09,139
이것은 문제가 될 것입니다.

1202
00:56:11,880 --> 00:56:16,450
그렇다면 이 문제는 도대체 무엇일까요?
모두를 대변하는 말 [알아들을 수 없음],

1203
00:56:16,449 --> 00:56:19,169
근무 시간이 어떻게 되든 상관없이
최악의 예상 및/또는

1204
00:56:19,170 --> 00:56:22,349
상각하면, 우리는 정말로
당신이 이렇게 말하도록 유도하려고 해요.

1205
00:56:22,349 --> 00:56:23,009
그게 뭐지...?

1206
00:56:26,219 --> 00:56:28,169
평가하다
알고리즘의 실행 시간

1207
00:56:28,170 --> 00:56:30,840
적절한 자격을 갖춘 경우.

1208
00:56:30,840 --> 00:56:32,280
만약 이것이 최악이었다면
이 경우, 저는 당신이

1209
00:56:32,280 --> 00:56:35,030
그들은 그것이 최악의 시나리오라고 말했다.

1210
00:56:35,030 --> 00:56:38,300
만약 필요하다면... 만약 당신이
해시 테이블을 사용했습니다.

1211
00:56:38,300 --> 00:56:39,620
예상했던 대로 말해 주셨으면 좋겠어요.

1212
00:56:39,619 --> 00:56:43,849
그리고 만약 이러한 작전들이
때로는 정말 형편없었어요.

1213
00:56:43,849 --> 00:56:46,429
하지만 평균적으로 보면 정말 그렇습니다.
좋은 것들 - 만약 내가 그런 것들을 많이 했다면,

1214
00:56:46,429 --> 00:56:49,549
감가상각이 됩니다.

1215
00:56:49,550 --> 00:56:53,180
아니면 제가 줄이면
동적 배열을 사용하여,

1216
00:56:53,179 --> 00:56:54,919
또는 내가 줄였다면
해시 테이블을 사용하여,

1217
00:56:54,920 --> 00:56:59,530
이러한 동적 작업
여전히 감가상각될 것입니다.

1218
00:56:59,530 --> 00:57:00,350
좋은.

1219
00:57:00,349 --> 00:57:01,699
동적.

1220
00:57:01,699 --> 00:57:04,519
좋은 것
관련 데이터 구조

1221
00:57:04,519 --> 00:57:07,148
동적 연산이란 무엇인가?
감가상각되지 않습니다.

1222
00:57:07,148 --> 00:57:08,690
그래서 우리는
하나 구할 수 있어요.

1223
00:57:08,690 --> 00:57:12,079
자, 이 문제에 대해 우리는 할 수 있습니다.
실제로 최악의 경우 범위를 구합니다.

1224
00:57:12,079 --> 00:57:13,860
그래서 저희는 그렇게 하도록 노력하겠습니다.

1225
00:57:13,860 --> 00:57:16,700
예상대로 이 작업도 수행할 수 있습니다.
해시 테이블을 사용하여

1226
00:57:16,699 --> 00:57:20,239
이 사전의 경우.

1227
00:57:20,239 --> 00:57:21,709
문제를 해결할 때
데이터 구조

1228
00:57:21,710 --> 00:57:26,630
이 수업에서,
먼저 저에게 말씀해 주시겠어요?

1229
00:57:26,630 --> 00:57:30,800
당신은 정확히 무엇인가요?
구하다.

1230
00:57:30,800 --> 00:57:34,300
그게 뭔지 말해줘.
이런 것들 속에 있기 위해-

1231
00:57:34,300 --> 00:57:35,970
일부 불변량
이 데이터 구조,

1232
00:57:35,969 --> 00:57:40,519
확실히 하기 위해
나중에 문의해 보겠습니다.

1233
00:57:40,519 --> 00:57:42,559
이런 것들
제공됩니다.

1234
00:57:42,559 --> 00:57:49,519
그래서 만약 내가 저장한다면
정렬된 배열,

1235
00:57:49,519 --> 00:57:52,070
그리고 저는 지지합니다
최댓값을 찾는 연산,

1236
00:57:52,070 --> 00:57:52,850
저는 괜찮아졌어요...

1237
00:57:52,849 --> 00:57:54,380
내가 하는 모든 일
이 데이터 구조,

1238
00:57:54,380 --> 00:57:56,448
지원해야 합니다
불변량은 다음과 같습니다.

1239
00:57:56,447 --> 00:57:57,989
이것들은 무엇인가요?
정렬 순서대로 배열됨,

1240
00:57:57,989 --> 00:58:00,619
그리고 마지막으로
최대 요소가 있습니다.

1241
00:58:00,619 --> 00:58:03,769
왜냐하면 저는 최대 수익을 추구하기 때문입니다.
될 것입니다

1242
00:58:03,769 --> 00:58:05,539
그곳에서 검색해서 돌려주세요.

1243
00:58:05,539 --> 00:58:07,289
이해가 되시나요?

1244
00:58:07,289 --> 00:58:10,519
그러니까, 당신은 제게 말하고 싶은 게 뭐죠?
저장된 내용

1245
00:58:10,519 --> 00:58:13,280
일반적인 순간에
당신의 시간 동안

1246
00:58:13,280 --> 00:58:15,860
데이터 구조
저장됨,

1247
00:58:15,860 --> 00:58:20,059
그래서 제가 지지할 때
동적 작업 또는 쿼리,

1248
00:58:20,059 --> 00:58:23,630
동적 작동 중
저는 입력 후 종료합니다.

1249
00:58:23,630 --> 00:58:26,180
이것으로부터, 나
나는 내가 반드시 확인해야 할 것이 있다

1250
00:58:26,179 --> 00:58:28,507
나는 이러한 불변성을 보존한다.

1251
00:58:28,507 --> 00:58:30,049
그리고 제가 물어보면,
나는 할 수 있다

1252
00:58:30,050 --> 00:58:34,250
이러한 불변량에 의존한다.
질문에 답변드리겠습니다.

1253
00:58:34,250 --> 00:58:36,380
이해가 되시나요?

1254
00:58:36,380 --> 00:58:40,030
그래서, 이것을 위해
과제들 - 4대3입니다.

1255
00:58:43,829 --> 00:58:45,409
아이디어 있으신가요?  안에

1256
00:58:45,409 --> 00:58:50,029
저는 두 종류의 열쇠를 가지고 있습니다.
제가 처리해야 할지도 모르는 문제입니다.

1257
00:58:50,030 --> 00:58:55,519
입찰 ID 하나, 그리고
또 내기하는 거지, 그렇지?

1258
00:58:55,519 --> 00:59:00,380
그렇다면 제가 두 개를 가지고 있다면 어떻게 할 수 있을까요?
내가 가진 열쇠

1259
00:59:00,380 --> 00:59:03,619
어쩌면 하나 주문하고 싶어질지도 몰라요
그리고 다른 것을 찾아보세요.

1260
00:59:03,619 --> 00:59:06,186
데이터 구조는 몇 개입니까?
제가 뭘 사용할 거라고 생각하세요?

1261
00:59:06,186 --> 00:59:06,769
관객 수: 두 명.

1262
00:59:06,769 --> 00:59:07,353
제이슨 쿠: 둘.

1263
00:59:07,353 --> 00:59:10,130
꽤 정확한 추측이네요.

1264
00:59:10,130 --> 00:59:11,510
그래서 그중 하나가...

1265
00:59:11,510 --> 00:59:12,860
한번 추측해 볼까요?

1266
00:59:12,860 --> 00:59:15,920
나는 할 수 있어야 한다
요금을 검색하세요,

1267
00:59:15,920 --> 00:59:24,110
그러니 이 입찰자들을 그대로 두도록 합시다.
어떤 사전에서는,

1268
00:59:24,110 --> 00:59:26,539
누가 할 수 있을까요?
이것들을 빠르게 검색해 보세요.

1269
00:59:26,539 --> 00:59:28,880
그래서 데이터 구조는 두 가지입니다.

1270
00:59:28,880 --> 00:59:41,222
그중 하나는 사전이다.
입찰자의 신분증과 함께.

1271
00:59:44,989 --> 00:59:47,889
내가 더 바라는 게 뭐가 있겠어?

1272
00:59:47,889 --> 00:59:48,389
저게 뭐지?

1273
00:59:52,329 --> 00:59:56,380
반대로,
연못에 저장된 사전인가요?

1274
00:59:56,380 --> 00:59:57,910
여기에 사전이 필요할까요?

1275
00:59:57,909 --> 01:00:01,480
청중: [알아들을 수 없음]
AVL 트리 구성 [분해 불가능]??

1276
01:00:01,480 --> 01:00:03,490
제이슨 쿠: 저는 원해요
어떻게든 질서를 유지해야 한다.

1277
01:00:03,489 --> 01:00:06,250
내가 원하기 때문에
가장 많이 절약하세요.

1278
01:00:06,250 --> 01:00:07,780
지금까지 내가 본 것은 무엇일까요?

1279
01:00:07,780 --> 01:00:12,102
지금 당장, 만약 제가…
어느 시점에선가,

1280
01:00:12,101 --> 01:00:13,059
무슨 일이 일어날까요?

1281
01:00:13,059 --> 01:00:16,779
내가 계속 k를 유지한다면
어느 시점이든 가장 많은 수,

1282
01:00:16,780 --> 01:00:19,630
아마도,
이 참가자들 중 누구라도

1283
01:00:19,630 --> 01:00:24,400
금리를 낮춥니다
그녀는 더 이상 가장 키가 큰 사람이 아니었다.

1284
01:00:24,400 --> 01:00:27,309
저에게도 필요한 것이 있습니다
다른 사람들을 따라가기 위해,

1285
01:00:27,309 --> 01:00:31,840
예를 들어, 누구를 돌려보내야 하는지 알아보기 위해서
이 세트에.

1286
01:00:31,840 --> 01:00:33,880
좋은 생각이 하나 있어요.

1287
01:00:33,880 --> 01:00:37,823
저는 하나 이상 소장할 거예요.
데이터 구조, 그리고 두 가지

1288
01:00:37,822 --> 01:00:38,739
기타 데이터 구조.

1289
01:00:38,739 --> 01:00:40,809
어쩌면 너무 비약적인 생각일지도 모르겠습니다.

1290
01:00:40,809 --> 01:00:42,009
이렇게 하면 안 돼요.

1291
01:00:42,010 --> 01:00:44,140
이 문제를 해결할 방법이 있습니다.
다른 한 명과 함께.

1292
01:00:44,139 --> 01:00:46,909
하지만 두 개는 더 남겨둘 거예요.

1293
01:00:46,909 --> 01:00:49,899
그중 하나는

1294
01:00:49,900 --> 01:01:01,099
데이터 구조
참가자를 저장하는 방법 -

1295
01:01:01,099 --> 01:01:14,019
가장 높은 입찰가를 제시한 k명의 참가자를 유지합니다.
데이터 구조

1296
01:01:14,019 --> 01:01:22,570
저장용 n 마이너스
가장 높은 입찰가를 제시한 참가자 k명.

1297
01:01:22,570 --> 01:01:25,640
이해가 되시나요?

1298
01:01:25,639 --> 01:01:31,190
이로써 제 문제가 상당히 명확해졌습니다.
그렇지 않나요?

1299
01:01:31,190 --> 01:01:33,829
매번 누군가가
이것과 상호작용합니다

1300
01:01:33,829 --> 01:01:41,360
데이터 구조, 저는 할 수 있습니다.
그녀가

1301
01:01:41,360 --> 01:01:44,599
보다 큰
여기 있는 가장 작은 것.

1302
01:01:44,599 --> 01:01:48,319
그렇다면 제가 할 수 있습니다.
전에 썼던 것과 같은 수법이야.

1303
01:01:48,320 --> 01:01:52,610
저는 그것을 빼냈다가 다시 넣을 수 있습니다.
이게 당신의 새 거예요.

1304
01:01:52,610 --> 01:01:54,200
그리고 우리는 갈 겁니다...
하지만 저는 그걸 삭제했어요.

1305
01:01:54,199 --> 01:01:56,659
나는 지지해야 한다
이것은 재산입니다.

1306
01:01:56,659 --> 01:01:58,574
그래서 여기에 삽입합니다.

1307
01:01:58,574 --> 01:01:59,449
또 다른 사례가 있습니다.

1308
01:01:59,449 --> 01:02:00,366
다른 사례는 무엇이 있나요?

1309
01:02:03,190 --> 01:02:05,460
그는 키가 더 작다.

1310
01:02:05,460 --> 01:02:07,090
이 경우 저는
저는 아무것도 안 하고 있어요.

1311
01:02:07,090 --> 01:02:09,340
이 데이터 구조를 사용하면
그냥 여기에 붙여넣는 거예요.

1312
01:02:09,340 --> 01:02:12,390
이해가 되시나요?

1313
01:02:12,389 --> 01:02:14,460
어떤 운영을 지원해야 할까요?
이러한 데이터 구조

1314
01:02:14,460 --> 01:02:16,380
?

1315
01:02:16,380 --> 01:02:19,410
최소값을 찾거나
이 두 집합 중 최댓값.

1316
01:02:19,409 --> 01:02:20,819
이해가 되시나요?

1317
01:02:20,820 --> 01:02:25,230
사실, 사실, 어디에
그러한 작전들 말인가요?  안에

1318
01:02:25,230 --> 01:02:26,639
저는 더 이상 그것들을 가지고 있지 않습니다.

1319
01:02:26,639 --> 01:02:29,069
하지만 이것들은
대기열에서 우선순위가 높은 작업입니다.

1320
01:02:29,070 --> 01:02:33,750
그들은 delete_max를 가지고 있었습니다.
그리고 또한 삽입하세요--

1321
01:02:33,750 --> 01:02:36,929
이것들은 그가 잘했던 것들입니다.

1322
01:02:36,929 --> 01:02:40,199
그래서, 어떤
우선순위 큐, 그 외 모든 것

1323
01:02:40,199 --> 01:02:45,269
최대치를 처리할 수 있습니다
그리고 최소값은 괜찮습니다.

1324
01:02:45,269 --> 01:02:47,610
그리고 무엇
데이터 구조 아시죠?

1325
01:02:47,610 --> 01:02:50,910
최대치와 함께 상당히 효과적으로 작동할 수 있습니다.
최소 금액은 어떻게 되나요?

1326
01:02:50,909 --> 01:02:51,869
AVL 세트 맞죠?

1327
01:02:51,869 --> 01:02:55,829
그래서 대신에
여기서는 데이터 구조를 살펴보겠습니다.

1328
01:02:55,829 --> 01:02:59,074
AVL을 설치하시는 걸 추천합니다.

1329
01:03:03,420 --> 01:03:12,168
그리고 당연히 이것은
열렬한 환영을 받을 것입니다.

1330
01:03:12,168 --> 01:03:14,460
그게 바로 그거니까요
나는 찾고 싶다

1331
01:03:14,460 --> 01:03:15,389
최대값과 최소값.

1332
01:03:18,070 --> 01:03:19,690
모두가 따라합니다
논리,

1333
01:03:19,690 --> 01:03:23,583
나는 왜 계속할까?
이런 것들 말인가요?

1334
01:03:23,583 --> 01:03:25,000
이것이 레벨입니다
불변량,

1335
01:03:25,000 --> 01:03:28,400
제가 지지하고 싶은 것입니다.
왜냐하면 내가

1336
01:03:28,400 --> 01:03:33,430
예를 들어, 저는 이렇게 합니다.
수익 요청,

1337
01:03:33,429 --> 01:03:36,889
저는 그냥 달려갈 수 있어요
이 모든 것을 요약하자면 다음과 같습니다.

1338
01:03:36,889 --> 01:03:38,259
아, 잠깐만요.

1339
01:03:38,260 --> 01:03:40,780
시간이 얼마나 있나요?  안에

1340
01:03:40,780 --> 01:03:42,250
시간이 있을까요?

1341
01:03:42,250 --> 01:03:44,210
아니요, 시간이 없어요.

1342
01:03:44,210 --> 01:03:48,788
그래서 저는... 저는 그걸 살 여유가 없어요.
이 모든 것을 요약하자면

1343
01:03:48,788 --> 01:03:49,880
제 주제의 끝부분에서요.

1344
01:03:49,880 --> 01:03:52,720
반품해야 해요.
당신에게 끊임없이 시간을 내어 드립니다.

1345
01:03:52,719 --> 01:03:54,879
아이디어 있으신가요?

1346
01:03:54,880 --> 01:03:59,230
네, 계산해 보세요.
금액을 업데이트하세요.

1347
01:03:59,230 --> 01:04:02,829
이와 함께
데이터 구조 I

1348
01:04:02,829 --> 01:04:05,500
나는 저축할 거야
네 번째

1349
01:04:05,500 --> 01:04:13,119
그건 그들이 건 총액일 뿐입니다.

1350
01:04:13,119 --> 01:04:14,380
저는 그걸 t라고 부를 거예요.

1351
01:04:18,670 --> 01:04:20,380
그리고 이것이 바로 그것입니다
저는 찬성합니다.

1352
01:04:20,380 --> 01:04:22,779
이것은 제 데이터 구조의 일부입니다.

1353
01:04:22,779 --> 01:04:24,370
이 점에 대해 생각해 보시는 게 좋을 것 같습니다.
마치 내가 더하는 것처럼

1354
01:04:24,369 --> 01:04:27,309
이것은 숫자입니다.

1355
01:04:27,309 --> 01:04:30,130
그리고 증가의 의미는
이 물건을 숫자로

1356
01:04:30,130 --> 01:04:31,510
제가 그냥 할 수 있다는 건...

1357
01:04:31,510 --> 01:04:34,120
어떤 건지 알아야 한다면
이 물질의 총량은 다음과 같습니다.

1358
01:04:34,119 --> 01:04:35,799
저는 이 숫자만 보면 됩니다.

1359
01:04:35,800 --> 01:04:38,260
이해가 되시나요?

1360
01:04:38,260 --> 01:04:39,100
좋은

1361
01:04:39,099 --> 01:04:41,920
그래서 저는 이렇게 생각합니다.
거의 다 끝났습니다.

1362
01:04:41,920 --> 01:04:44,050
이제 거의 끝난 거죠, 그렇죠?

1363
01:04:44,050 --> 01:04:45,860
우리는 어떻게 이것을 할까요?

1364
01:04:45,860 --> 01:04:51,220
누군가 말해줄 거예요
저는 어떻게 소득을 얻을 수 있을까요?

1365
01:04:51,219 --> 01:04:54,269
이 데이터 구조를 사용하면 됩니다.

1366
01:04:54,269 --> 01:04:56,869
제가 이미 말씀드렸잖아요.

1367
01:04:56,869 --> 01:04:57,799
이 숫자를 보세요.

1368
01:04:57,800 --> 01:04:59,240
뒤집어 보세요.

1369
01:04:59,239 --> 01:05:02,579
불변량이기 때문에,
내가 간직했던 것

1370
01:05:02,579 --> 01:05:03,079
데이터 구조.

1371
01:05:03,079 --> 01:05:04,759
나는 이 불변성에 의존한다.

1372
01:05:04,760 --> 01:05:06,860
지금은 기분이 좀 나아졌어요.
품질이 좋은지 확인하세요.

1373
01:05:06,860 --> 01:05:09,349
동적 연산을 수행할 때.

1374
01:05:09,349 --> 01:05:11,029
저는 그를 꼭 응원합니다.

1375
01:05:11,029 --> 01:05:15,973
하지만 만약 제가 귀납법으로 보장한다면,
이 모든 것이 좋다는 것입니다.

1376
01:05:15,971 --> 01:05:18,139
그리고 제가 다이내믹을 할 때
운영, 이 모든 것

1377
01:05:18,139 --> 01:05:21,230
저장됨,
그럼 전 괜찮아요.

1378
01:05:21,230 --> 01:05:28,050
제가 모든 작업을 완료한 후에 수입이 발생하도록 하겠습니다.
이 추가 작업은 아주 쉽습니다.

1379
01:05:28,050 --> 01:05:31,730
저는 지금 이것을 보고 있어요.
번호를 알려주시면 다시 연락드리겠습니다.

1380
01:05:31,730 --> 01:05:33,619
우리가 평가할 때
데이터 구조의 문제점

1381
01:05:33,619 --> 01:05:36,710
저희는 보통 몇 점을 드립니다.
먼저 설정을 확인하세요.

1382
01:05:36,710 --> 01:05:39,110
데이터 구조는 별도로
운영 측면에서,

1383
01:05:39,110 --> 01:05:42,320
그럼 저희가 드리겠습니다
작업당 포인트,

1384
01:05:42,320 --> 01:05:44,360
당신이 얼마나 성공했는지
관리되었고, 그 다음에는

1385
01:05:44,360 --> 01:05:47,130
정확성을 위한 몇 가지 사항
그리고 근무 시간.

1386
01:05:47,130 --> 01:05:49,619
네, 질문 있으신가요?

1387
01:05:49,619 --> 01:05:51,559
청중: 그래서,
총액은 중요한 요소입니다.

1388
01:05:51,559 --> 01:05:54,769
저희가 업데이트하고 있는 내용입니다.
우리가 장난칠 때마다

1389
01:05:54,769 --> 01:05:58,871
가장 높은 입찰가를 제시한 참가자들의 트리 구조로,
그다음에는 n에서 k를 뺀 멤버 트리를 사용하면 될까요?

1390
01:05:58,871 --> 01:06:00,760
제이슨 쿠: 죄송합니다.
다시 말씀해 주시겠어요?

1391
01:06:00,760 --> 01:06:03,790
청중: 우리가 고려하고 있는 건가요?
총액이 증가한 것입니다.

1392
01:06:03,788 --> 01:06:05,538
저희가 업데이트하고 있는 내용입니다.
우리가 뭔가를 할 때마다요?

1393
01:06:05,538 --> 01:06:05,750
제이슨 쿠: 네.

1394
01:06:05,750 --> 01:06:06,250
예

1395
01:06:06,250 --> 01:06:07,885
그러니까, 숫자는 하나뿐입니다.

1396
01:06:07,885 --> 01:06:09,260
사실은 그렇지 않습니다.
데이터 구조,

1397
01:06:09,260 --> 01:06:12,770
그건 그냥 숫자 하나일 뿐이야
저는 그것을 제 데이터베이스에 저장합니다.

1398
01:06:16,820 --> 01:06:17,420
좋은

1399
01:06:17,420 --> 01:06:23,010
구현 방법
새로운 입찰 운영인가요?

1400
01:06:23,010 --> 01:06:23,510
예?

1401
01:06:23,510 --> 01:06:24,677
청중: 질문이 있습니다.

1402
01:06:24,677 --> 01:06:27,302
우리는 그렇게 가정할 수 있을까요?
요금도 각기 다를까요?

1403
01:06:27,302 --> 01:06:29,510
제이슨 쿠: 맞춰보시겠어요?
요금이 다를 수 있다는 말씀이신가요?

1404
01:06:29,510 --> 01:06:30,010
아니요.

1405
01:06:32,420 --> 01:06:39,050
사실 그렇습니다.
매우 유용한 지적입니다.

1406
01:06:39,050 --> 01:06:42,288
우리는 ~에 대해 이야기했어요
데이터 구조 집합,

1407
01:06:42,288 --> 01:06:47,389
고유한 키가 필요합니다.

1408
01:06:47,389 --> 01:06:48,889
어떻게 하면 함께 일할 수 있을까요?
고유하지 않은 키인가요?

1409
01:06:48,889 --> 01:06:51,139
실제로
알고 보니 해시 테이블의 경우

1410
01:06:51,139 --> 01:06:54,650
매우 중요합니다.
그래서 이것들은 고유한 키가 됩니다.

1411
01:06:54,650 --> 01:06:56,930
확인해야 하니까요.
거기에 있나요?

1412
01:06:56,929 --> 01:06:59,109
저는 그 열쇠 하나를 찾고 있어요.

1413
01:06:59,110 --> 01:07:01,340
내가 그를 찾으면,
저는 돌아가야 해요.

1414
01:07:01,340 --> 01:07:03,230
만약 내게 몇 개 있었다면
이 열쇠로 된 물건들,

1415
01:07:03,230 --> 01:07:05,449
저는 돌아오지 않을지도 몰라요.
내가 찾던 바로 그거야.

1416
01:07:05,449 --> 01:07:08,239
말이 안 돼요.

1417
01:07:08,239 --> 01:07:17,239
하지만 일반화할 수는 있죠.
세트의 인프라

1418
01:07:17,239 --> 01:07:19,229
여러 데이터 세트를 사용하여 작업하기 위해.

1419
01:07:19,230 --> 01:07:21,420
어떻게 하면 될까요?

1420
01:07:21,420 --> 01:07:24,860
음, 각 키마다-

1421
01:07:24,860 --> 01:07:26,720
고유 키를 다시 저장하고 있습니다.

1422
01:07:26,719 --> 01:07:30,109
각 키와 연결할 수 있습니다.
일련의 시퀀스 구조를 사용하여

1423
01:07:30,110 --> 01:07:32,258
또는 다른 데이터 구조.

1424
01:07:32,257 --> 01:07:34,549
제가 하려는 일은 다음과 같습니다.
저는 모든 걸 다 할 거예요.

1425
01:07:34,550 --> 01:07:36,440
이 열쇠를 가진 사람은 누구인가요?
이것을 삽입하겠습니다.

1426
01:07:36,440 --> 01:07:38,557
이 데이터 구조로 변환합니다.

1427
01:07:38,557 --> 01:07:40,099
그래서 저장하는 대신에
물건이 하나 있습니다.

1428
01:07:40,099 --> 01:07:42,266
제게는 기회가 있습니다.
거기에 많은 물건을 보관하세요.

1429
01:07:42,266 --> 01:07:44,699
이제 나는 바꿔야 해
의미론적인 문제입니다.

1430
01:07:44,699 --> 01:07:48,799
제가 "여기서 찾아보세요"라고 말하면
열쇠요? 음, 지금은 그렇게 말할 수 있겠네요.

1431
01:07:48,800 --> 01:07:51,800
전부 반품할게요.
이 열쇠로 된 물건들,

1432
01:07:51,800 --> 01:07:55,010
아니면 계속 가지고 있을 건가요?
이 키로 할 수 있는 몇 가지가 있습니다.

1433
01:07:55,010 --> 01:07:56,150
하지만 당신은 이해하시잖아요.

1434
01:07:56,150 --> 01:07:59,970
제가 해야 할 일은 이것과 일치하는 것뿐입니다.
다른 데이터 구조를 사용하여,

1435
01:07:59,969 --> 01:08:01,159
[표시 불가]를 지원합니다.

1436
01:08:01,159 --> 01:08:06,379
어쩌면 그 모든 게 다 필요할지도 몰라.
이 열쇠로 된 물건들.

1437
01:08:06,380 --> 01:08:09,440
나는 그 사람을 찾고 싶어
이 열쇠를 가진 사람은 누구인가요?

1438
01:08:09,440 --> 01:08:11,474
그래서 제가 언급하는 건 아마도 이것일 겁니다.
데이터 구조 집합,

1439
01:08:11,474 --> 01:08:13,099
누가 검색할 수 있나요?
다른 것들도 있죠, 그렇죠?

1440
01:08:13,099 --> 01:08:15,409
하지만 핵심은 바로 이것입니다.
우리가 지지하는 것

1441
01:08:15,409 --> 01:08:18,108
이 핵심 속성은 바로 독창성입니다.

1442
01:08:18,109 --> 01:08:20,810
나는 긴장을 풀어야 해
의미론적으로 내가

1443
01:08:20,810 --> 01:08:23,609
몇 가지 물건을 간직했어요
이 핵심 위치에 있습니다.

1444
01:08:23,609 --> 01:08:24,550
이해가 되시나요?

1445
01:08:24,550 --> 01:08:25,250
예?

1446
01:08:25,250 --> 01:08:27,250
청중: 왜요?
그것이 중요한가

1447
01:08:27,250 --> 01:08:28,511
AVL 트리 집합은 고유한 키를 가지고 있습니까, 아니면 그렇지 않습니까?

1448
01:08:31,220 --> 01:08:35,750
제이슨 쿠: 바로 이 부분이 중요해질 겁니다.
내기가 걸려있기 때문입니다.

1449
01:08:35,750 --> 01:08:38,899
그리고 요금은 다음과 같습니다.
고유하지 않아야 합니다.

1450
01:08:38,899 --> 01:08:43,578
두 사람이 할 수 있습니다
동일한 요금을 갖습니다.

1451
01:08:43,578 --> 01:08:46,850
그리고 우리의 정의에 따르면
데이터 구조,

1452
01:08:46,850 --> 01:08:48,149
고유한 키를 가져야 합니다.

1453
01:08:48,149 --> 01:08:50,868
그래서 만약 내가 모든 것에 갇히게 된다면
입찰자가 제시한 이러한 사항들은 다음과 같습니다.

1454
01:08:50,868 --> 01:08:53,510
문제가 생길 겁니다.

1455
01:08:53,510 --> 01:08:54,979
자, 사실
우리는 할 수 있다

1456
01:08:54,979 --> 01:08:57,439
이를 피하려면 다음을 유지하세요.
본질적으로 연결되어 있음

1457
01:08:57,439 --> 01:09:00,529
모든 것의 목록
이 열쇠만 있으면 모든 게 괜찮을 거예요.

1458
01:09:03,109 --> 01:09:06,260
그리고 나서, 제가 원할 때
하나만 반환하면 됩니다.

1459
01:09:06,260 --> 01:09:10,550
하지만
실제로 이진 트리

1460
01:09:10,550 --> 01:09:12,948
충분히 유연해서
대부분의 구현에서

1461
01:09:12,948 --> 01:09:15,920
그냥 저장하면 됩니다
이런 것들이 잔뜩 있어요.

1462
01:09:15,920 --> 01:09:20,840
하지만 사실 우리의
재생 시간이 더 오래 걸린다.

1463
01:09:20,840 --> 01:09:24,439
그게 무슨 뜻인가요?
내 순서에서 다음 항목을 찾으시겠습니까?

1464
01:09:24,439 --> 01:09:29,750
그게 무슨 뜻인가요?
다음으로 더 큰 값을 반환합니다.

1465
01:09:29,750 --> 01:09:32,029
이 열쇠 위에 있는 것들?

1466
01:09:32,029 --> 01:09:33,859
사실 그럴 필요는 없어요.
일리가 있다, 왜냐하면

1467
01:09:33,859 --> 01:09:34,818
여러 개가 있을 수도 있습니다.

1468
01:09:34,818 --> 01:09:36,200
어떤 것을 반품해야 할까요?

1469
01:09:36,198 --> 01:09:41,269
그리고 만약 제가 find-next를 여러 번 실행한다면
이 데이터 구조에서,

1470
01:09:41,270 --> 01:09:44,720
스크롤이 안 돼요.
만사.

1471
01:09:44,720 --> 01:09:49,170
그래서 몇 가지가 있습니다.
인터페이스에 문제가 발생하고 있습니다.

1472
01:09:49,170 --> 01:09:54,980
그래서 저는 고유한 표현을 사용하는 것을 선호합니다.
그런 상황에서는 열쇠가 필요합니다.

1473
01:09:54,979 --> 01:09:58,579
다음 주 화요일쯤일 것 같아요.
이진 힙을 사용하면

1474
01:09:58,579 --> 01:10:02,720
우리는 고유하지 않은 키를 다룰 것입니다.

1475
01:10:02,720 --> 01:10:04,230
이것은 정상입니다

1476
01:10:04,229 --> 01:10:09,439
하지만 만약 당신이 사용하려 한다면
여기에는 고유하지 않은 키가 있습니다.

1477
01:10:09,439 --> 01:10:11,479
당신은 단지 필요해요
조금

1478
01:10:11,479 --> 01:10:13,919
의미론에 주의하세요.

1479
01:10:13,920 --> 01:10:14,420
예?

1480
01:10:14,420 --> 01:10:15,409
청중: [잘 안 들림]?

1481
01:10:24,500 --> 01:10:27,619
제이슨 쿠: 당신
당신도 똑같은 결과를 얻게 될 것입니다

1482
01:10:27,619 --> 01:10:29,960
근무 시간 – 당신은 다음을 해야 합니다.
의미론을 바꾸다

1483
01:10:29,960 --> 01:10:32,510
그게 무슨 뜻이에요?
"무언가를 찾다."

1484
01:10:32,510 --> 01:10:35,570
저는 그냥 돌아가고 싶어요
이 키를 가진 모든 것.

1485
01:10:35,568 --> 01:10:37,489
청중: 만약에
모든 것에 같은 키가 있습니다.

1486
01:10:37,489 --> 01:10:38,189
그 다음에...

1487
01:10:38,189 --> 01:10:39,899
제이슨 쿠: 그럼 이건
일정한 시간이 걸립니다.

1488
01:10:39,899 --> 01:10:41,149
첫 번째 제품만 반품하는 거예요.

1489
01:10:45,109 --> 01:10:48,409
제 말은, 이건
알아두어야 할 특별한 경우들

1490
01:10:48,409 --> 01:10:51,139
생각해야 하잖아요, 그렇죠?

1491
01:10:51,140 --> 01:10:52,920
나는 좋아하지 않아
그들에 대해 생각해 보세요.

1492
01:10:52,920 --> 01:10:55,460
그래서 전 그들을 좋아해요.
고유 키.

1493
01:10:55,460 --> 01:10:59,568
그리고 만약 제가 상황이 필요하다면,
고유하지 않은 키가 있을 때,

1494
01:10:59,568 --> 01:11:02,869
나는 간다
이 키의 충돌 위치

1495
01:11:02,869 --> 01:11:04,909
새로운 데이터 구조로 변환합니다.  나

1496
01:11:04,909 --> 01:11:06,539
그냥 더 쉬워요
분리된

1497
01:11:06,539 --> 01:11:08,300
머릿속에서 무슨 일이 일어나고 있는 걸까?

1498
01:11:08,300 --> 01:11:11,029
왜냐하면 모든 사람이
당사가 제안하는 리드 타임

1499
01:11:11,029 --> 01:11:14,539
매우 분명하다
고유 키를 정의합니다.

1500
01:11:14,539 --> 01:11:16,970
사건이 있을 때
멀티셋으로,

1501
01:11:16,970 --> 01:11:20,150
그는 조금
더 흔하다.

1502
01:11:20,149 --> 01:11:21,889
더 궁금한 점 있으신가요?

1503
01:11:21,890 --> 01:11:25,910
우리는 정말 필요해요
다음으로 넘어가죠, 그렇죠?

1504
01:11:25,909 --> 01:11:27,649
입찰서에 대한 설명이 포함된 사전.

1505
01:11:27,649 --> 01:11:31,670
아직 시행하지 않았습니다.
동적 연산이 없습니다.

1506
01:11:31,670 --> 01:11:32,359
새로운 베팅.

1507
01:11:32,359 --> 01:11:34,889
어떻게 해야 할까요?

1508
01:11:34,890 --> 01:11:38,030
무엇이 필요합니까?
업데이트에 필요할까요?

1509
01:11:38,029 --> 01:11:42,019
나
찾아야 할 것입니다

1510
01:11:42,020 --> 01:11:44,120
각각의 경우
데이터 구조,

1511
01:11:44,119 --> 01:11:47,510
이 입찰자는 어디에 거주하고 있습니까?

1512
01:11:47,510 --> 01:11:51,890
그리고 만약 내가 그냥
나는 그들의 이해관계를 지적한다.

1513
01:11:51,890 --> 01:11:54,770
인터페이스는 보고하지 않습니다
예전 요금이 얼마였는지 알려줘.

1514
01:11:54,770 --> 01:11:57,200
그건 나에게 어느 쪽인지 알려줄 뿐이야.
입찰자 ID.

1515
01:11:57,199 --> 01:12:02,029
만약 제가 경매인의 신분증만 가지고 있다면...
그리고 새로운 내기라니, 도대체 어떻게 된 거야?

1516
01:12:02,029 --> 01:12:04,429
제가 알아볼게요.
이 데이터 중 어느 것이 어디에

1517
01:12:04,430 --> 01:12:07,190
그것들은 이러한 데이터 구조에 있나요?

1518
01:12:07,189 --> 01:12:11,629
내가 뭘 할 수 있을까, 할 수 있어
이 사전에 저장하기-

1519
01:12:11,630 --> 01:12:15,680
내가 찾을 수 있는 것은
일정 기간 동안 --

1520
01:12:15,680 --> 01:12:18,050
그것이 있는 위치를 가리키는 포인터
이러한 것들 속에 존재한다.

1521
01:12:18,050 --> 01:12:20,690
이해가 되시나요?

1522
01:12:20,689 --> 01:12:21,919
이것을 가교결합이라고 합니다.

1523
01:12:21,920 --> 01:12:24,800
어쩌면 당신도 그런 일을 조금 했을지도 몰라요.
~에

1524
01:12:24,800 --> 01:12:26,940
문제 세트 2인가 뭐 그런 거요.

1525
01:12:26,939 --> 01:12:27,439
예?

1526
01:12:27,439 --> 01:12:30,589
대상: 복원
특정 참가자를 가리키는 것인가요?

1527
01:12:30,590 --> 01:12:32,779
제이슨 쿠: 네, 맞아요.

1528
01:12:32,779 --> 01:12:34,177
우리가 가진 불변량
우리가 가진 것은 모든 참가자들이

1529
01:12:34,177 --> 01:12:35,720
우리가 정한 요금
지금까지 처리된 내용

1530
01:12:35,720 --> 01:12:38,420
이러한 데이터 구조에 존재합니다.

1531
01:12:38,420 --> 01:12:41,059
이들 중 하나에서
데이터 구조--

1532
01:12:41,059 --> 01:12:43,850
우리가 사용했기 때문에
AVL 트리 세트.

1533
01:12:43,850 --> 01:12:45,800
특히 그는
하나의 노드에 존재합니다

1534
01:12:45,800 --> 01:12:47,659
이러한 데이터 구조로부터.

1535
01:12:47,659 --> 01:12:50,779
우리가 할 수 있는 일은 무엇일까요?
그러므로 그렇습니다.

1536
01:12:50,779 --> 01:12:56,479
반영하는 지표를 유지하십시오
각 입찰자 식별자

1537
01:12:56,479 --> 01:12:58,909
그 위치에 있어서
이러한 데이터 구조.

1538
01:12:58,909 --> 01:13:00,920
그렇다면 그 이유는 무엇일까요?
유용할까요?

1539
01:13:04,220 --> 01:13:06,289
제가 이 사전을 그린다고 가정해 봅시다.

1540
01:13:06,289 --> 01:13:07,789
무엇을 사용할 수 있을까요?
이 사전의 경우,

1541
01:13:07,789 --> 01:13:10,579
얻다
필수 근무 시간은 얼마인가요?

1542
01:13:10,579 --> 01:13:13,340
해시를 사용할 수 있습니다.
테이블 또는 AVL 세트.

1543
01:13:13,340 --> 01:13:16,520
AVL이 설치되어 있다면,
최악의 경우 로그 시간 복잡도를 얻게 될 것입니다.

1544
01:13:16,520 --> 01:13:17,705
사례.

1545
01:13:17,704 --> 01:13:19,579
해시 테이블을 사용하면 I
저는 일정한 시간을 얻습니다.

1546
01:13:19,579 --> 01:13:21,119
하지만 그건 예상했던 일이죠.

1547
01:13:21,119 --> 01:13:24,920
따라서 최악의 경우 선형적으로 진행될 수 있습니다.
시간.

1548
01:13:24,920 --> 01:13:27,020
설치된 것을 사용하겠습니다.
AVL 트리, 왜냐하면 그게 바로 그거니까요.

1549
01:13:27,020 --> 01:13:30,330
우리는 지금 무엇을 하고 있죠?

1550
01:13:30,329 --> 01:13:32,809
그리고 이것은
최악의 상황으로 이어질 것입니다.

1551
01:13:35,059 --> 01:13:36,393
이 포인터를 각각의 항목에 대해 계속 사용할 거예요.  첫 번째,

1552
01:13:36,393 --> 01:13:39,682
나는 어떻게 해야 할까?
해야 할 일, 나는

1553
01:13:39,682 --> 01:13:41,100
제가 그걸 하겠습니다.
우리가 수행한 수술.

1554
01:13:41,100 --> 01:13:49,100
새로운 입찰자를 추가하면,
저는 D와 B를 주세요.

1555
01:13:49,100 --> 01:13:53,840
이 두 값, 이것은
이 물건, 즉 베팅한 사람의 물건

1556
01:13:53,840 --> 01:13:54,818
또는 그 외의 다른 어떤 것 --

1557
01:13:54,818 --> 01:13:58,039
시청하겠습니다.
이것에서 가장 작은 것

1558
01:13:58,039 --> 01:14:06,470
데이터 구조를 살펴보고, 그 비율이 어떤지 확인해 보세요.
그것보다 더 큰

1559
01:14:06,470 --> 01:14:07,682
삽입합니다.

1560
01:14:07,682 --> 01:14:10,100
그렇다면 저는 그러지 않을 겁니다.
이 데이터 구조를 건드려 보세요.

1561
01:14:10,100 --> 01:14:11,840
저는 그냥
여기에 삽입하겠습니다.

1562
01:14:11,840 --> 01:14:13,992
그리고 이제, 그 후에
여기에 삽입하세요, 나

1563
01:14:13,992 --> 01:14:15,949
저는 그곳이 어디인지 정확히 알고 있습니다.
데이터 구조에서.

1564
01:14:15,949 --> 01:14:19,369
방금 삽입했어요.

1565
01:14:19,369 --> 01:14:22,010
그래서 지금, 잡고 있는 중
그것은 손에 쥐어져 있다.

1566
01:14:22,010 --> 01:14:27,680
노드 -- 저는 갈 수 있습니다
이 입찰자를 여기에 삽입하세요

1567
01:14:27,680 --> 01:14:29,990
입찰 ID별로.

1568
01:14:29,989 --> 01:14:31,818
자, 이것이 바로
로그 시간 복잡도로 걸릴 것입니다.

1569
01:14:31,818 --> 01:14:36,409
이제 저는 다음을 사용하여 저장할 수 있습니다.
이 노드는 내 포인터입니다.

1570
01:14:36,409 --> 01:14:37,564
이 데이터 구조에 대해서.

1571
01:14:37,564 --> 01:14:38,818
이해가 되시나요?

1572
01:14:38,818 --> 01:14:41,779
그렇지 않으면 저는
저도 마찬가지예요.

1573
01:14:41,779 --> 01:14:45,050
만약 그것이 가장 작은 것보다 크다면
여기 있는 거, 난 이 작은 걸로 살게.

1574
01:14:45,050 --> 01:14:48,619
저거, 저기에 놓을게요.
참고로 제 새 남자친구를 여기에 넣어볼게요.

1575
01:14:48,619 --> 01:14:52,859
이것들 각각을 연결하는
포인터.

1576
01:14:52,859 --> 01:14:57,469
이해가 되셨으면 좋겠습니다.

1577
01:14:57,470 --> 01:14:59,280
좋다?

1578
01:14:59,279 --> 01:14:59,779
좋다?

1579
01:14:59,779 --> 01:15:00,859
좋은.

1580
01:15:00,859 --> 01:15:03,469
업데이트 내용도 거의 비슷합니다.

1581
01:15:03,470 --> 01:15:06,050
업데이트하고 싶다면
내기 참가자 중 한 명,

1582
01:15:06,050 --> 01:15:11,550
저는 이것을 보고 있습니다.
데이터 구조, 승자를 찾으세요,

1583
01:15:11,550 --> 01:15:13,440
이것을 옮기다
포인터가 어디에 있는지

1584
01:15:13,439 --> 01:15:16,979
그는 이들 중 하나에 속해 있습니다.
AVL 트리 맞죠?

1585
01:15:16,979 --> 01:15:22,049
그가 여기에 연루되어 있다면, 난 그냥
나는 그것을 나무에서 떼어낸다.

1586
01:15:22,050 --> 01:15:23,789
또는 삭제
나무들, 그리고 나서

1587
01:15:23,789 --> 01:15:29,068
저는 다시 삽입하고 있습니다.
새로운 요금.

1588
01:15:29,068 --> 01:15:32,009
그리고 만약 그가 거기에 있다면
이거, 또 나야

1589
01:15:32,010 --> 01:15:35,190
나는 그것을 나무에서 떼어낸다.
나는 그것을 다시 아무 곳에나 삽입한다.

1590
01:15:35,189 --> 01:15:36,839
이러한 것들 중,
그럼 어쩌면 내가

1591
01:15:36,840 --> 01:15:39,720
영구적인 것을 바꿔야 할 것입니다
거기에 있는 것들의 수

1592
01:15:39,720 --> 01:15:43,020
-지원해 드리려고 왔습니다.
이것이 k 값이 가장 높다는 것입니다.

1593
01:15:43,020 --> 01:15:47,610
그리고 제가 이것들을 할 때
동적 운영,

1594
01:15:47,609 --> 01:15:50,369
저는 항상 삭제합니다.
일정한 양

1595
01:15:50,369 --> 01:15:53,340
이들 각각의 노드
나무를 추가하고 다시 추가합니다.

1596
01:15:53,340 --> 01:15:55,212
일정한 수의 것들.

1597
01:15:55,212 --> 01:15:57,630
그리고 제가 그렇게 하는 동안, 저는 그냥
이 총계를 업데이트합니다.

1598
01:15:57,630 --> 01:15:58,980
업무 중에.

1599
01:15:58,979 --> 01:16:04,679
이 금액은 다음과 같은 것들의 합계였습니다.
모든 베팅은 여기에.

1600
01:16:04,680 --> 01:16:07,320
그리고 만약 제가 삽입한다면
새로운 내기가 있습니다.

1601
01:16:07,318 --> 01:16:09,519
이 금액에 추가 금액을 더해야 합니다.

1602
01:16:09,520 --> 01:16:11,858
그리고 만약 제가 하나를 제거한다면, 저는 다른 하나를 제거해야 합니다.
이 총계에서 빼세요.

1603
01:16:11,858 --> 01:16:13,650
하지만 다시 생각해 보면, 이것은
일정한 수의 것들

1604
01:16:13,649 --> 01:16:15,899
나는 출입한다
이러한 데이터 구조,

1605
01:16:15,899 --> 01:16:18,059
그가 업데이트할 수 있도록
이것은 일정한 시간입니다.

1606
01:16:18,059 --> 01:16:19,800
이해가 되시나요?

1607
01:16:19,800 --> 01:16:23,760
자, 여기에서도 검색해 보세요.
삽입 및 삭제

1608
01:16:23,760 --> 01:16:29,130
여기서 그들 각자는 가져갔다
최악의 경우, 로그 시간 복잡도를 갖게 됩니다.

1609
01:16:29,130 --> 01:16:30,850
하지만 전 그랬어요.
그들의 수는 일정하다.

1610
01:16:30,850 --> 01:16:32,780
그러니까, 다시 시간의 로그를 생각해 봅시다.

1611
01:16:32,779 --> 01:16:33,929
이해가 되시나요?

1612
01:16:33,930 --> 01:16:37,680
요컨대, 여기서는
문제.

1613
01:16:37,680 --> 01:16:39,280
어렵죠, 그렇죠?

1614
01:16:39,279 --> 01:16:41,469
여기엔 많은 사람들이 있어요.
움직이는 부품.

1615
01:16:41,470 --> 01:16:44,610
하지만 그냥 나누면
그리고 그것을 내게 설명해 줘...

1616
01:16:44,609 --> 01:16:47,279
예를 들어, 당신은 정말로
이 부분을 잘 해냈어요.

1617
01:16:47,279 --> 01:16:50,789
무엇인지 자세히 설명해 주세요
데이터 구조를 알고 있다면,

1618
01:16:50,789 --> 01:16:52,380
이러한 설명들
이러한 알고리즘

1619
01:16:52,380 --> 01:16:53,920
꽤 짧을 수도 있습니다.

1620
01:16:57,119 --> 01:16:59,939
이 경우에는 당신이 내게 말해주세요
이 세 가지 데이터 구조,

1621
01:16:59,939 --> 01:17:03,629
당신은 이 사람이
위치와 일치합니다.

1622
01:17:03,630 --> 01:17:07,770
그리고 이런 것들에 대해, 저는
저는 이 손님을 모십니다.

1623
01:17:07,770 --> 01:17:11,520
그리고 나서 이것들을 지원하시면 됩니다.
동적 연산을 사용하는 것들,

1624
01:17:11,520 --> 01:17:14,910
그런 다음 이러한 것들을 사용합니다.
쿼리 작업의 경우.

1625
01:17:14,909 --> 01:17:15,898
이해가 되시나요?

1626
01:17:19,630 --> 01:17:20,960
와, 10분 더 남았네요?

1627
01:17:25,809 --> 01:17:32,830
저는 키가 작습니다.
4-4로 만들어 드릴게요.

1628
01:17:32,829 --> 01:17:33,699
수혜자 명부.  안에

1629
01:17:33,699 --> 01:17:36,880
우리에겐 코치가 있습니다.

1630
01:17:36,880 --> 01:17:38,980
그녀는 많이 가지고 있어요
축구 선수들--

1631
01:17:38,979 --> 01:17:41,648
수신기.

1632
01:17:41,648 --> 01:17:45,789
그리고 바라면서
그녀의 팀에서 시작하기 위해,

1633
01:17:45,789 --> 01:17:50,380
일정 수의 선수들
가장 높은 효율을 가지고 있습니다.

1634
01:17:50,380 --> 01:17:52,930
그리고 생산성 측면에서 우리는
우리는 평균값을 의미합니다.

1635
01:17:52,930 --> 01:17:54,970
그들이 플레이한 포인트
게임에서 그들은

1636
01:17:54,970 --> 01:17:56,980
그들의 시스템에 등록되었습니다.

1637
01:17:56,979 --> 01:18:00,279
하지만 사실 그들의
데이터가 불완전합니다.

1638
01:18:00,279 --> 01:18:02,679
그들은 어떤 게임인지 몰라요
그리고 그들이 몇 점을 득점했는지,

1639
01:18:02,680 --> 01:18:03,680
그리고 이 모든 것들.

1640
01:18:03,680 --> 01:18:05,090
오류가 있을 수 있습니다.

1641
01:18:05,090 --> 01:18:08,318
그래서 이 인턴들은
끊임없이

1642
01:18:08,318 --> 01:18:15,369
이 데이터베이스를 업데이트하세요
"아, 괜찮아요."와 같은 요청과 함께

1643
01:18:15,369 --> 01:18:17,979
이 사람은 아닙니다
이 게임을 플레이했습니다.

1644
01:18:17,979 --> 01:18:21,849
혹은 실제로 연주했거나, 그녀는
이만큼의 점수를 획득했습니다.

1645
01:18:21,850 --> 01:18:25,780
이것은... 청소
그리고 적어두세요.

1646
01:18:25,779 --> 01:18:28,359
그러다가 어느 시점에
예를 들어, 특정 순간

1647
01:18:28,359 --> 01:18:31,869
우리가 원할 때
게임하고 싶어요.

1648
01:18:31,869 --> 01:18:36,760
돌아갈 수 있도록
가장 높은 k를 가진 티셔츠

1649
01:18:36,760 --> 01:18:40,270
log n 시간에 대한 효율성.

1650
01:18:40,270 --> 01:18:45,370
이것은 일종의
순위 요청이시죠?

1651
01:18:45,369 --> 01:18:46,135
k번째로 높은.

1652
01:18:48,670 --> 01:18:53,500
사실, 저는 할 수 있어요
가장 높은 k명의 플레이어를 모두 반환합니다.

1653
01:18:53,500 --> 01:18:56,050
그래서 이것이 내 목록이 될 수 있도록요.

1654
01:18:56,050 --> 01:19:00,070
하지만 이것은 더 많은 것을 의미합니다.
일반화된 쿼리.

1655
01:19:00,068 --> 01:19:02,000
이것은 좀 더 구체적이고, 더...

1656
01:19:02,000 --> 01:19:04,029
전혀 비교할 수 없어요.

1657
01:19:04,029 --> 01:19:07,358
하지만 당신은 그 이유를 이해하시겠죠.
훈련 담당자에게 유용할 수 있습니다.

1658
01:19:07,358 --> 01:19:07,900
모르겠습니다.

1659
01:19:07,898 --> 01:19:10,089
아닐 수도 있죠.

1660
01:19:10,090 --> 01:19:11,666
그래서 여기서 말하고자 하는 바는 무엇인가요?  약

1661
01:19:11,666 --> 01:19:13,750
세상에는 다양한 종류의 사람들이 존재합니다.
것들.  안에

1662
01:19:13,750 --> 01:19:15,279
저희는 게임이 있어요.

1663
01:19:15,279 --> 01:19:17,179
그것들은 식별자, 즉 고유 식별자를 가지고 있습니다.  안에

1664
01:19:17,180 --> 01:19:18,039
우리는 수신자입니다.

1665
01:19:18,039 --> 01:19:19,630
그것들은 고유한 식별자를 가지고 있습니다.

1666
01:19:19,630 --> 01:19:23,890
그리고 모든 수신기는
게임을 많이 합니다.

1667
01:19:23,890 --> 01:19:26,590
어머, 그거 좀 충격적이네요.

1668
01:19:26,590 --> 01:19:30,989
그리고 많은 수신기가
게임 한 판 하세요.

1669
01:19:30,989 --> 01:19:32,679
그런
다대일 매핑

1670
01:19:32,680 --> 01:19:34,490
조금 헷갈리네요.

1671
01:19:34,489 --> 01:19:39,109
그리고 나서 각 선수들은—

1672
01:19:39,109 --> 01:19:42,199
수신기 - 특정 기능을 가지고 있습니다.
경기당 득점 수.

1673
01:19:42,199 --> 01:19:45,929
그리고 우리는 그것들을 해결하려고 노력합니다.
생산성 측면에서,

1674
01:19:45,930 --> 01:19:47,943
이는 유리수입니다.

1675
01:19:47,943 --> 01:19:50,480
아, 그렇죠?

1676
01:19:50,479 --> 01:19:52,879
무엇과 관련이 있습니까?
플레이한 게임 수

1677
01:19:52,880 --> 01:19:55,880
그리고 총점입니다.

1678
01:19:55,880 --> 01:19:59,420
이제 나는 유리수를 본다.
저는 계산할 수 없어요.

1679
01:19:59,420 --> 01:20:02,989
우리가 이야기했던 내용이 바로 이거예요.
이번이 마지막 문제 풀이 시간이죠?

1680
01:20:02,989 --> 01:20:04,447
하지만 제가 뭘 할 수 있겠어요?
이것은 저장하기 위한 것입니다.

1681
01:20:04,448 --> 01:20:05,990
총 개수
그들이 했던 게임들,

1682
01:20:05,989 --> 01:20:07,729
그리고 총 개수
그들이 가진 점수.

1683
01:20:07,729 --> 01:20:09,829
그리고 여러분은 그것을 상상할 수 있습니다.
확장 프로그램을 사용하면,

1684
01:20:09,829 --> 01:20:14,689
매번 이렇습니다.
게임을 추가하면, 하나는

1685
01:20:14,689 --> 01:20:18,979
이러한 소규모 운영을 통해 저는
이 정보를 업데이트할 수 있나요?

1686
01:20:18,979 --> 01:20:19,699
각 선수마다.

1687
01:20:22,850 --> 01:20:25,039
이들 중 하나라도
동적 연산

1688
01:20:25,039 --> 01:20:27,439
오직 영향만 미칩니다
수신기 하나, 나

1689
01:20:27,439 --> 01:20:31,549
저는 어떤 정보든 업데이트할 수 있습니다.
일정한 시간 동안,

1690
01:20:31,550 --> 01:20:35,059
어쩌면 저장하면 될지도 몰라
플레이어에게

1691
01:20:35,059 --> 01:20:38,731
총 게임 수,
데이터베이스에 기록됨

1692
01:20:38,731 --> 01:20:40,189
그리고 점수의 개수
그들이 득점했습니다.

1693
01:20:40,189 --> 01:20:43,068
그렇다면, 만약 제가 가지고 있다면
데이터 구조

1694
01:20:43,068 --> 01:20:47,789
수신기를 분류해야 합니다.
생산성으로 인해,

1695
01:20:47,789 --> 01:20:50,210
그래서 내가 할 수 있도록
k번째를 찾으세요 —

1696
01:20:50,210 --> 01:20:56,739
k번째로 큰 - 그렇다면 저는 할 수 없습니다
이 성능을 계산하세요.

1697
01:20:56,739 --> 01:20:59,289
하지만 제가 뭘 할 수 있겠어요?

1698
01:20:59,289 --> 01:21:02,818
나는 두 선수를 비교할 수 있다.
생산성을 통해

1699
01:21:02,818 --> 01:21:05,429
교차 곱셈.

1700
01:21:05,430 --> 01:21:07,740
왜냐하면 저는 가지고 있기 때문입니다
분자와 분모

1701
01:21:07,739 --> 01:21:09,239
이들 각각
유리수, 그리고 나는 할 수 있다

1702
01:21:09,239 --> 01:21:11,909
교차 곱셈을 하고
누가

1703
01:21:11,909 --> 01:21:13,329
대략 그렇습니다.

1704
01:21:13,329 --> 01:21:15,029
그리고 내가 가지고 있는 동안
비교기가 있습니다.

1705
01:21:15,029 --> 01:21:17,849
저는 AVL 세트를 만들 수 있습니다.

1706
01:21:17,850 --> 01:21:19,120
이해가 되시나요?

1707
01:21:19,119 --> 01:21:20,609
좋은.

1708
01:21:20,609 --> 01:21:25,439
간략하게 설명드리겠습니다.
이것의 구성 요소

1709
01:21:25,439 --> 01:21:26,239
데이터 구조.

1710
01:21:28,770 --> 01:21:32,730
우선, 저는
수신기를 녹음해야 합니다.

1711
01:21:32,729 --> 01:21:34,779
그리고 수신기에서는 가능합니다
많은 경기가 있을 것입니다.

1712
01:21:34,779 --> 01:21:37,648
하지만 중요한 건 문제 자체입니다.
수신기에 집중

1713
01:21:37,648 --> 01:21:38,229
.

1714
01:21:38,229 --> 01:21:39,929
이것은 가지고 있나요?
제 말이 이해가 되시나요?

1715
01:21:39,930 --> 01:21:42,960
나는 절대 그러고 싶지 않아
모든 수신기를 필터링합니다

1716
01:21:42,960 --> 01:21:44,489
게임을 하고 있어요.

1717
01:21:44,489 --> 01:21:50,489
나는 절대 삭제하지 않아
시스템에서 가져온 게임,

1718
01:21:50,489 --> 01:21:53,039
삭제하겠습니다.
수신기가 있어서 그는 결코 할 수 없었다.

1719
01:21:53,039 --> 01:21:54,420
특정 게임을 하기 위해.

1720
01:21:54,420 --> 01:21:55,630
이해가 되시나요?

1721
01:21:55,630 --> 01:21:59,430
그래서, 만약 내가 계속한다면
수신기, 그리고 각 수신기

1722
01:21:59,430 --> 01:22:01,980
특정 게임들이 있습니다.
그들과 관련된,

1723
01:22:01,979 --> 01:22:05,369
일리가 있네요, 저는 그렇게 생각해요.
임베드할 수 있습니다.

1724
01:22:05,369 --> 01:22:08,159
데이터 구조, 어디에서 유래--

1725
01:22:08,159 --> 01:22:11,550
어쩌면 내가 가지고 있을지도 몰라
수신기에 관한 사전.

1726
01:22:11,550 --> 01:22:14,400
그리고 그들 각각을 위해 나는
저는 모든 게임을 저장합니다.

1727
01:22:14,398 --> 01:22:17,219
그들이 연주했던 것에서,
또 다른 데이터 구조.

1728
01:22:17,220 --> 01:22:20,347
각 수신기마다 저는 다음과 같은 것들을 보관합니다.
또 다른 하나 - 당신 자신의 것

1729
01:22:20,346 --> 01:22:21,929
데이터 구조를 포함하는
그의 모든 경기.

1730
01:22:21,930 --> 01:22:23,640
이해가 되시나요?

1731
01:22:23,640 --> 01:22:26,280
좋아요, 좋은 생각인데요.  안에

1732
01:22:26,279 --> 01:22:27,539
저희는 그런 게 있어요...

1733
01:22:27,539 --> 01:22:31,590
나는 할 수 있어야 한다
수신기를 찾으세요.

1734
01:22:31,590 --> 01:22:35,970
제가 청소하기 때문입니다
혹은 제가 글을 씁니다.

1735
01:22:35,970 --> 01:22:40,320
그래서 저는 가질 거예요
사전 또는...

1736
01:22:40,318 --> 01:22:42,969
여기서, 제가 찾고 있는 것은
최악의 타임지.

1737
01:22:42,970 --> 01:22:45,869
그래서 저는 이 부분은 건너뛰겠습니다.
사전 추상화

1738
01:22:45,869 --> 01:22:49,260
그리고 AVL 세트로 바로 이동하세요.

1739
01:22:49,260 --> 01:23:00,150
수신기의 AVL 키.

1740
01:23:00,148 --> 01:23:06,729
E 앞에 I가 오는 경우, 단 예외는 제외
C. 이 사람은 나입니다--

1741
01:23:06,729 --> 01:23:07,229
E-I?

1742
01:23:10,648 --> 01:23:11,849
이 규칙은 절대 통하지 않아요.

1743
01:23:11,850 --> 01:23:13,200
좋은.

1744
01:23:13,199 --> 01:23:17,939
수신기에 AVL 트리를 설치하세요.
그리고 이들 노드 각각

1745
01:23:17,939 --> 01:23:23,009
이것들 각각과 함께
제가 계속 사용할 수신기들--

1746
01:23:23,010 --> 01:23:32,250
저는 모두를 위해 저축할 거예요
AVL은 게임에 적용됩니다.

1747
01:23:36,329 --> 01:23:38,460
나는 왜 계속할까?
게임에서 AVL 설정이 가능한가요?

1748
01:23:38,460 --> 01:23:42,480
그냥 저장하면 되지 않을까요?
모든 게임 목록은 무엇인가요?

1749
01:23:42,479 --> 01:23:45,359
삭제하고 싶다면
수신기로부터 온 이 게임,

1750
01:23:45,359 --> 01:23:47,250
이 작업을 log n 시간 안에 완료해야 합니다.

1751
01:23:47,250 --> 01:23:51,520
그리고 우리는 이렇게 말하고 있습니다.
여기서 n은 게임의 수입니다.

1752
01:23:51,520 --> 01:23:54,000
하지만 숫자는
팀의 선수들

1753
01:23:54,000 --> 01:23:56,760
항상 ~보다 작다
게임 수.

1754
01:23:56,760 --> 01:24:02,039
이 AVL 트리에서 검색하면
그리고 해당 AVL 트리에서 검색합니다.

1755
01:24:02,039 --> 01:24:07,050
나는 이 두 사람이
해당 검색은 n번만 등록되었습니다.

1756
01:24:07,050 --> 01:24:08,840
왜냐하면 저는 필요하니까요
게임을 삭제해야 하는 거죠?

1757
01:24:08,840 --> 01:24:11,710
자, 여기 있습니다.

1758
01:24:11,710 --> 01:24:13,289
그럼 저는 어떻게 해야 하나요?

1759
01:24:13,289 --> 01:24:15,550
나는 k번째를 반환합니다
최고의 성능.

1760
01:24:15,550 --> 01:24:21,100
음, 저는 각각이 필요해요.
이 사람들 중 일부도 제가 계속 데리고 있어요.

1761
01:24:21,100 --> 01:24:22,630
그 증가액은 얼마였나요?

1762
01:24:22,630 --> 01:24:28,029
점수의 합계,
이 게임들에 저장되어 있습니다.

1763
01:24:28,029 --> 01:24:32,755
점수의 합계와 --

1764
01:24:35,350 --> 01:24:40,000
그게 뭐였냐면, 숫자 게임이었어요.

1765
01:24:40,000 --> 01:24:43,130
왜냐하면 만약 내가 둘 다 가지게 된다면
이러한 것들은 끊임없이 시간에 따라 움직입니다.

1766
01:24:43,130 --> 01:24:46,449
나는 할 수 있다
생산성을 계산하세요.

1767
01:24:46,449 --> 01:24:49,000
내가 어디에 있지?
저는 데이터를 가질 수 있습니다.

1768
01:24:49,000 --> 01:24:51,289
성능 비교에 필요합니다.

1769
01:24:51,289 --> 01:24:52,600
청중: [잘 안 들림]?

1770
01:24:52,600 --> 01:24:53,530
제이슨 쿠: 네, 맞습니다.

1771
01:24:53,529 --> 01:24:54,969
그저 숫자일 뿐입니다.

1772
01:24:54,970 --> 01:24:56,090
이것들은 데이터 구조입니다.

1773
01:24:56,090 --> 01:24:56,970
이것은 데이터 구조입니다.

1774
01:24:56,970 --> 01:24:57,927
이것들은 그저 숫자에 불과합니다.

1775
01:25:00,398 --> 01:25:02,189
그리고 저는 그걸 간직하고 있어요.
각 수신기와 함께.

1776
01:25:05,109 --> 01:25:08,859
하지만 그건 도움이 안 될 거예요.
k번째로 높은 순위에 있는 선수를 찾아야 합니다.

1777
01:25:08,859 --> 01:25:13,579
이것들 중 어느 것도 아닙니다
성능 순으로 정렬했습니다.

1778
01:25:13,579 --> 01:25:15,635
그래서 저는 마지막 데이터 구조가 필요합니다.

1779
01:25:22,760 --> 01:25:31,130
다섯째, 저는 저축해야 합니다.
동적으로 정렬된 무언가

1780
01:25:31,130 --> 01:25:32,970
생산성 측면에서.

1781
01:25:32,970 --> 01:25:33,720
청중: AVL 설치하시겠습니까?

1782
01:25:33,720 --> 01:25:35,809
제이슨 쿠: AVL을 설치하세요, 네.

1783
01:25:35,809 --> 01:25:50,940
수신기를 저장하는 AVL을 설치하세요.
성능 향상을 위해 조정되었습니다.

1784
01:25:50,939 --> 01:25:55,579
이제 제가 말씀드리자면
생산성에 관해서,

1785
01:25:55,579 --> 01:25:57,199
기억하고 싶으세요?
무언가에 관한 것

1786
01:25:57,199 --> 01:25:58,909
교차 곱셈.

1787
01:25:58,909 --> 01:26:01,220
예를 들어, 저는 다음과 같이 저장합니다.
이것들 각각

1788
01:26:01,220 --> 01:26:04,070
이러한 증가, 그리고 언제
저는 두 가지를 비교하고 있습니다.

1789
01:26:04,068 --> 01:26:05,898
저는 교차 곱셈을 사용합니다.

1790
01:26:05,898 --> 01:26:08,839
하지만 그것 외에도, 우리는
이건 무시해도 되겠죠?

1791
01:26:08,840 --> 01:26:10,699
우리는 추상화했습니다
이 함수 호출.

1792
01:26:10,699 --> 01:26:13,699
그리고 저는 상상할 수 있어요
두 개의 키를 비교합니다.

1793
01:26:13,699 --> 01:26:14,992
저는 할 수 있어요.

1794
01:26:14,992 --> 01:26:15,949
이것은 이론일 뿐입니다.

1795
01:26:15,949 --> 01:26:18,199
난 너에게 묻는 게 아니야.
이를 실행하기 위해.

1796
01:26:18,199 --> 01:26:22,279
하지만 저는 이 정도면 충분합니다.
당신의 결정을 읽는 사람으로서,

1797
01:26:22,279 --> 01:26:26,809
네, 당신은 이렇게 말할 수 있습니다.
당신은 자신이 무슨 말을 하는지 잘 알고 있군요.

1798
01:26:26,809 --> 01:26:28,100
좋은

1799
01:26:28,100 --> 01:26:30,050
이 모든 것들을 어떻게 조합할 수 있을까요?

1800
01:26:30,050 --> 01:26:32,480
문제는, 저는
필요할 것입니다...

1801
01:26:32,479 --> 01:26:38,799
이것들을 업데이트해야 해요.
게임을 넣거나 뺄 때.

1802
01:26:41,359 --> 01:26:47,599
그럼 저는 이것들이 어디에 있는지 어떻게 알 수 있을까요?
이 장치에 수신기가 있나요?

1803
01:26:47,600 --> 01:26:50,690
나는 포인터를 계속 그 자리에 둡니다.
이 데이터 구조 말이죠?

1804
01:26:50,689 --> 01:26:57,710
그래서 저는 계속합니다.
포인터가 어디에 있는지

1805
01:26:57,710 --> 01:26:59,568
데이터 구조 안에 있습니다.

1806
01:26:59,568 --> 01:27:01,279
다시 한번, 저는 계속해서
모든 수신기.

1807
01:27:01,279 --> 01:27:04,068
크기가 같습니다.
데이터 구조 1번은 무엇인가요?

1808
01:27:04,068 --> 01:27:06,529
거기에는 있다
수신기의 수는 동일합니다.

1809
01:27:09,590 --> 01:27:13,220
하지만 아직 끝난 게 아닙니다.
나는 그렇지 않기 때문에

1810
01:27:13,220 --> 01:27:21,350
누가 가지고 있는지 알고 싶어요
더 나은 결과.

1811
01:27:21,350 --> 01:27:25,170
누가 가지고 있는지 알고 싶어요
k번째로 우수한 성능.

1812
01:27:25,170 --> 01:27:27,409
으윽

1813
01:27:27,409 --> 01:27:30,449
k번째 값을 어떻게 찾나요?
이 나무의 가장 좋은 점은 무엇일까요?  안에

1814
01:27:30,449 --> 01:27:31,220
저는 나무 한 그루를 가지고 있어요.

1815
01:27:34,068 --> 01:27:35,029
AVL 트리를 설치합니다.

1816
01:27:35,029 --> 01:27:37,130
이는 생산성에 반영됩니다.

1817
01:27:37,130 --> 01:27:38,989
마지막 하나가 어디 있는지 알아요.

1818
01:27:38,989 --> 01:27:41,389
하지만 내가 찾고 싶다면
끝에서 k번째,

1819
01:27:41,390 --> 01:27:44,360
어떻게 하면 되나요?

1820
01:27:44,359 --> 01:27:45,889
이것은 AVL 트리입니다.

1821
01:27:45,890 --> 01:27:47,300
AVL 트리가 구성되었습니다.

1822
01:27:47,300 --> 01:27:50,070
내게 남은 건 오직 높은 곳뿐이다.

1823
01:27:50,068 --> 01:27:54,689
수술이 진행 중인가요?
무슨 생각을 하고 있었어?

1824
01:27:54,689 --> 01:27:58,789
청중: [잘 안 들림] 당신
각 항목의 크기를 저장하지 마세요.

1825
01:27:58,789 --> 01:28:00,769
제이슨 쿠: 설립됨
기본 AVL 트리

1826
01:28:00,770 --> 01:28:02,300
차원을 유지하지 않는다는 거죠?

1827
01:28:02,300 --> 01:28:04,220
그게 바로 꾸준함의 힘입니다.

1828
01:28:04,220 --> 01:28:08,369
하지만 당신은 그것이 어쩌면 그럴지도 모른다고 생각하죠.
이런 상황에서 유용할까요?

1829
01:28:08,369 --> 01:28:08,869
예

1830
01:28:08,869 --> 01:28:12,500
그래서 사실, 만약 내가 결정한다면
크기도 커집니다.

1831
01:28:12,500 --> 01:28:17,239
저도 똑같이 할 수 있어요.
find_at 시퀀스 연산,

1832
01:28:17,239 --> 01:28:22,670
그리고 나는 할 수 있었다
여기서 n에서 k번째 요소를 뺀 값을 찾으세요.

1833
01:28:22,670 --> 01:28:28,190
동일한 것을 사용하여
내가 알고 있는 하위 트리에 대한 함수

1834
01:28:28,189 --> 01:28:32,000
순서대로 가지고 있었다
AVL 목재 소재.

1835
01:28:32,000 --> 01:28:33,920
실제로 CLRS에서는
그들은 심지어

1836
01:28:33,920 --> 01:28:35,930
AVL 시퀀스 트리에 관심이 있습니다.

1837
01:28:35,930 --> 01:28:39,710
그들은 내가 원한다면
이 순위 검색 기능

1838
01:28:39,710 --> 01:28:44,180
질서정연하게
것들,

1839
01:28:44,180 --> 01:28:47,329
저는 늘릴 수 있습니다
서브트리 크기.

1840
01:28:47,329 --> 01:28:51,318
하지만 실제로는 훨씬 더 심각합니다.
보다 유용한 일반적인 속성,

1841
01:28:51,318 --> 01:28:54,500
그래서 저희는 그것을 도입하기로 결정했습니다.
맥락 속에서의 당신

1842
01:28:54,500 --> 01:28:56,779
AVL 시퀀스 트리, 왜냐하면 그러면 나는
제가 그냥 꺼내볼 수 있어요.

1843
01:28:56,779 --> 01:28:58,519
제가 여기 도착하면 그녀에게 전할게요.

1844
01:28:58,520 --> 01:29:01,130
그래서 이건 일종의
데이터 구조 구조,

1845
01:29:01,130 --> 01:29:02,420
이 문제를 해결하기 위해 노력하고 있습니다.

1846
01:29:02,420 --> 01:29:04,818
어떻게 할지는 당신에게 맡기겠습니다.
운동을 하기 위해

1847
01:29:04,818 --> 01:29:06,920
이 모든 작업
나 자신에게는,

1848
01:29:06,920 --> 01:29:08,789
또는 해결책을 살펴보세요.

1849
01:29:08,789 --> 01:29:13,460
마지막
온라인에 게시될 예정입니다 -

1850
01:29:13,460 --> 01:29:15,140
결정.

1851
01:29:15,140 --> 01:29:16,500
이건 꽤 어렵네요.

1852
01:29:16,500 --> 01:29:19,489
이것이 바로 '할 수 있다'라고 불리는 것입니다.
규모를 늘리는 것을 고려하고 있습니다.

1853
01:29:19,489 --> 01:29:22,369
전문가로서 순위를 찾는 방법
단측 범위 쿼리.

1854
01:29:22,369 --> 01:29:27,409
사실, 얼마나 많은 것들이 있을까요?
이 값의 오른쪽에 있습니까?

1855
01:29:27,409 --> 01:29:29,779
마지막 문제는 무슨 역할을 하나요?
이것은 당신을 데려갑니다

1856
01:29:29,779 --> 01:29:32,329
양자간을 통해
범위 쿼리

1857
01:29:32,329 --> 01:29:37,068
매듭이 몇 개인지 알고 싶어요
이 두 값 사이의 값입니다.

1858
01:29:37,068 --> 01:29:39,148
자, 이것은 단계별 가이드입니다.

1859
01:29:39,148 --> 01:29:39,648
좋은

1860
01:29:39,648 --> 01:29:40,549
감사합니다.

1861
01:29:40,550 --> 01:29:42,100
청중: 감사합니다.

