1
00:00:12,559 --> 00:00:13,350


2
00:00:13,350 --> 00:00:13,360

 

3
00:00:13,360 --> 00:00:17,349

안녕하세요, 네 번째 문제 풀이 시간에 오신 것을 환영합니다.

4
00:00:17,349 --> 00:00:19,830
안녕하세요, 네 번째 문제 풀이 시간에 오신 것을 환영합니다.
 

5
00:00:19,830 --> 00:00:19,840

 

6
00:00:19,840 --> 00:00:21,990

오늘은 주로 이진 트리에 대해 이야기해 보겠습니다. 이진 힙에

7
00:00:21,990 --> 00:00:22,000
오늘은 주로 이진 트리에 대해 이야기해 보겠습니다. 이진 힙에
 

8
00:00:22,000 --> 00:00:23,189
오늘은 주로 이진 트리에 대해 이야기해 보겠습니다. 이진 힙에
대해서도 조금 다룰 예정인데,

9
00:00:23,189 --> 00:00:23,199
대해서도 조금 다룰 예정인데,
 

10
00:00:23,199 --> 00:00:25,750
대해서도 조금 다룰 예정인데,
이는

11
00:00:25,750 --> 00:00:26,630
이는
 

12
00:00:26,630 --> 00:00:26,640

 

13
00:00:26,640 --> 00:00:30,150

다음 주 화요일에 자세히 다룰 주제입니다. 하지만 다음 주 금요일까지 제출해야 하는 네 번째

14
00:00:30,150 --> 00:00:30,160
다음 주 화요일에 자세히 다룰 주제입니다. 하지만 다음 주 금요일까지 제출해야 하는 네 번째
 

15
00:00:30,160 --> 00:00:33,990
다음 주 화요일에 자세히 다룰 주제입니다. 하지만 다음 주 금요일까지 제출해야 하는 네 번째
문제 세트에 아주 작은 부분으로 등장할 것입니다. 그래서

16
00:00:33,990 --> 00:00:36,389
문제 세트에 아주 작은 부분으로 등장할 것입니다. 그래서
 

17
00:00:36,389 --> 00:00:38,630

 

18
00:00:38,630 --> 00:00:38,640

 

19
00:00:38,640 --> 00:00:40,470

오늘 이진 힙에 대한 내용을 조금 살펴보겠습니다.

20
00:00:40,470 --> 00:00:43,910
오늘 이진 힙에 대한 내용을 조금 살펴보겠습니다.
 

21
00:00:43,910 --> 00:00:43,920

 

22
00:00:43,920 --> 00:00:46,150

오늘 다룰 주요 내용은

23
00:00:46,150 --> 00:00:46,160
오늘 다룰 주요 내용은
 

24
00:00:46,160 --> 00:00:49,750
오늘 다룰 주요 내용은
이진 트리, 특히 도메인 교수님께서 이번 주 초에 말씀하셨듯이

25
00:00:49,750 --> 00:00:49,760
이진 트리, 특히 도메인 교수님께서 이번 주 초에 말씀하셨듯이
 

26
00:00:49,760 --> 00:00:52,630
이진 트리, 특히 도메인 교수님께서 이번 주 초에 말씀하셨듯이
집합 및

27
00:00:52,630 --> 00:00:52,640
집합 및
 

28
00:00:52,640 --> 00:00:54,229
집합 및
시퀀스 데이터 구조에 적용되는 이진 트리입니다.

29
00:00:54,229 --> 00:00:58,709
시퀀스 데이터 구조에 적용되는 이진 트리입니다.
 

30
00:00:58,709 --> 00:01:02,310

 

31
00:01:02,310 --> 00:01:02,320

 

32
00:01:02,320 --> 00:01:05,990

사실 어제까지

33
00:01:05,990 --> 00:01:06,000
사실 어제까지
 

34
00:01:06,000 --> 00:01:07,910
사실 어제까지
여러분은

35
00:01:07,910 --> 00:01:09,270
여러분은
 

36
00:01:09,270 --> 00:01:09,280

 

37
00:01:09,280 --> 00:01:11,910

집합

38
00:01:11,910 --> 00:01:11,920
집합
 

39
00:01:11,920 --> 00:01:14,070
집합
인터페이스와 시퀀스 인터페이스를 구현하는 모든 데이터 구조를 살펴보았습니다.

40
00:01:14,070 --> 00:01:17,270
인터페이스와 시퀀스 인터페이스를 구현하는 모든 데이터 구조를 살펴보았습니다.
 

41
00:01:17,270 --> 00:01:17,280

 

42
00:01:17,280 --> 00:01:19,510

도메인 교수님께서 보여주셨던 그 멋진 테이블들이죠.

43
00:01:19,510 --> 00:01:19,520
도메인 교수님께서 보여주셨던 그 멋진 테이블들이죠.
 

44
00:01:19,520 --> 00:01:20,310
도메인 교수님께서 보여주셨던 그 멋진 테이블들이죠.

45
00:01:20,310 --> 00:01:20,320

 

46
00:01:20,320 --> 00:01:23,749

이제 모든 것이 완성되었습니다.

47
00:01:23,749 --> 00:01:23,759
이제 모든 것이 완성되었습니다.
 

48
00:01:23,759 --> 00:01:25,910
이제 모든 것이 완성되었습니다.
몇몇 데이터 구조는

49
00:01:25,910 --> 00:01:27,190
몇몇 데이터 구조는
 

50
00:01:27,190 --> 00:01:27,200

 

51
00:01:27,200 --> 00:01:29,109

특정 연산에 대해 상수 시간 연산을 제공하기 때문에

52
00:01:29,109 --> 00:01:29,119
특정 연산에 대해 상수 시간 연산을 제공하기 때문에
 

53
00:01:29,119 --> 00:01:31,030
특정 연산에 대해 상수 시간 연산을 제공하기 때문에
특정

54
00:01:31,030 --> 00:01:31,040
특정
 

55
00:01:31,040 --> 00:01:35,190
특정
응용 프로그램에 적합할 수 있습니다. 이번 주에는

56
00:01:35,190 --> 00:01:38,310
응용 프로그램에 적합할 수 있습니다. 이번 주에는
 

57
00:01:38,310 --> 00:01:40,870

 

58
00:01:40,870 --> 00:01:43,190

 

59
00:01:43,190 --> 00:01:43,200

 

60
00:01:43,200 --> 00:01:45,910

집합이나 시퀀스에 대한 모든 유형의 쿼리 연산에서 매우 뛰어난 성능을 보이는 트리에 대해 설명했습니다.

61
00:01:45,910 --> 00:01:45,920
집합이나 시퀀스에 대한 모든 유형의 쿼리 연산에서 매우 뛰어난 성능을 보이는 트리에 대해 설명했습니다.
 

62
00:01:45,920 --> 00:01:48,149
집합이나 시퀀스에 대한 모든 유형의 쿼리 연산에서 매우 뛰어난 성능을 보이는 트리에 대해 설명했습니다.
로그 시간 복잡도는 상수가 아니지만,

63
00:01:48,149 --> 00:01:48,159
로그 시간 복잡도는 상수가 아니지만,
 

64
00:01:48,159 --> 00:01:51,830
로그 시간 복잡도는 상수가 아니지만,
우리 목적상

65
00:01:51,830 --> 00:01:51,840
우리 목적상
 

66
00:01:51,840 --> 00:01:54,149
우리 목적상
컴퓨터에서 실제로는

67
00:01:54,149 --> 00:01:56,389
컴퓨터에서 실제로는
 

68
00:01:56,389 --> 00:01:56,399

 

69
00:01:56,399 --> 00:01:59,590

log n은 최대

70
00:01:59,590 --> 00:02:03,429
log n은 최대
 

71
00:02:03,429 --> 00:02:03,439

 

72
00:02:03,439 --> 00:02:06,950

64 정도입니다. 입력값을 머신 워드로 처리해야 하는데,

73
00:02:06,950 --> 00:02:09,990
64 정도입니다. 입력값을 머신 워드로 처리해야 하는데,
 

74
00:02:09,990 --> 00:02:10,000

 

75
00:02:10,000 --> 00:02:13,589

입력값에 있는

76
00:02:13,589 --> 00:02:13,599
입력값에 있는
 

77
00:02:13,599 --> 00:02:15,270
입력값에 있는
모든

78
00:02:15,270 --> 00:02:15,280
모든
 

79
00:02:15,280 --> 00:02:16,869
모든
머신 워드를 주소 지정할 수 있어야 합니다.

80
00:02:16,869 --> 00:02:16,879
머신 워드를 주소 지정할 수 있어야 합니다.
 

81
00:02:16,879 --> 00:02:20,229
머신 워드를 주소 지정할 수 있어야 합니다.
컴퓨터에서

82
00:02:20,229 --> 00:02:20,239
컴퓨터에서
 

83
00:02:20,239 --> 00:02:22,710
컴퓨터에서
머신 워드 주소의 크기는

84
00:02:22,710 --> 00:02:22,720
머신 워드 주소의 크기는
 

85
00:02:22,720 --> 00:02:24,229
머신 워드 주소의 크기는
64비트이고,

86
00:02:24,229 --> 00:02:24,239
64비트이고,
 

87
00:02:24,239 --> 00:02:27,110
64비트이고,
워드 크기는

88
00:02:27,110 --> 00:02:28,630
워드 크기는
 

89
00:02:28,630 --> 00:02:28,640

 

90
00:02:28,640 --> 00:02:30,790

입력값의 로그 크기 이상이라고 가정합니다. 따라서 컴퓨터

91
00:02:30,790 --> 00:02:32,390
입력값의 로그 크기 이상이라고 가정합니다. 따라서 컴퓨터
 

92
00:02:32,390 --> 00:02:32,400

 

93
00:02:32,400 --> 00:02:35,670

에서

94
00:02:35,670 --> 00:02:35,680
에서
 

95
00:02:35,680 --> 00:02:36,869
에서

96
00:02:36,869 --> 00:02:36,879

 

97
00:02:36,879 --> 00:02:38,949

log n은 최대 64가 됩니다.

98
00:02:38,949 --> 00:02:38,959
log n은 최대 64가 됩니다.
 

99
00:02:38,959 --> 00:02:41,830
log n은 최대 64가 됩니다.
즉, 오버헤드가 50배 정도 발생할 수 있지만,

100
00:02:41,830 --> 00:02:41,840
즉, 오버헤드가 50배 정도 발생할 수 있지만,
 

101
00:02:41,840 --> 00:02:43,430
즉, 오버헤드가 50배 정도 발생할 수 있지만,
작은

102
00:02:43,430 --> 00:02:43,440
작은
 

103
00:02:43,440 --> 00:02:45,509
작은
경우에는 10배 정도일 수 있습니다. 처리해야 할 항목이

104
00:02:45,509 --> 00:02:46,550
경우에는 10배 정도일 수 있습니다. 처리해야 할 항목이
 

105
00:02:46,550 --> 00:02:46,560

 

106
00:02:46,560 --> 00:02:48,710

수천 개라면 그렇게 나쁘지는

107
00:02:48,710 --> 00:02:48,720
수천 개라면 그렇게 나쁘지는
 

108
00:02:48,720 --> 00:02:50,229
수천 개라면 그렇게 나쁘지는
않습니다.

109
00:02:50,229 --> 00:02:51,910
않습니다.
 

110
00:02:51,910 --> 00:02:51,920

 

111
00:02:51,920 --> 00:02:54,710

이론적인 상수 인자는 아니지만, 실제 작업에서는

112
00:02:54,710 --> 00:02:54,720
이론적인 상수 인자는 아니지만, 실제 작업에서는
 

113
00:02:54,720 --> 00:02:56,949
이론적인 상수 인자는 아니지만, 실제 작업에서는
log n이

114
00:02:56,949 --> 00:02:56,959
log n이
 

115
00:02:56,959 --> 00:02:59,030
log n이
다항식 인자보다 훨씬 낫습니다.

116
00:02:59,030 --> 00:03:02,070
다항식 인자보다 훨씬 낫습니다.
 

117
00:03:02,070 --> 00:03:02,080

 

118
00:03:02,080 --> 00:03:05,670

여러분은 강의 노트에 있는 모든 코드, 즉

119
00:03:05,670 --> 00:03:07,350
여러분은 강의 노트에 있는 모든 코드, 즉
 

120
00:03:07,350 --> 00:03:07,360

 

121
00:03:07,360 --> 00:03:10,229

집합 및 시퀀스 인터페이스의 구현들을 모두 보셨죠?

122
00:03:10,229 --> 00:03:10,239
집합 및 시퀀스 인터페이스의 구현들을 모두 보셨죠?
 

123
00:03:10,239 --> 00:03:12,630
집합 및 시퀀스 인터페이스의 구현들을 모두 보셨죠?
그래서 저는

124
00:03:12,630 --> 00:03:12,640
그래서 저는
 

125
00:03:12,640 --> 00:03:14,390
그래서 저는
여러분의

126
00:03:14,390 --> 00:03:14,400
여러분의
 

127
00:03:14,400 --> 00:03:16,790
여러분의
강의 노트에 있는 다양한

128
00:03:16,790 --> 00:03:16,800
강의 노트에 있는 다양한
 

129
00:03:16,800 --> 00:03:19,430
강의 노트에 있는 다양한
인터페이스 구현들을 모두 모아서

130
00:03:19,430 --> 00:03:20,630
인터페이스 구현들을 모두 모아서
 

131
00:03:20,630 --> 00:03:20,640

 

132
00:03:20,640 --> 00:03:23,110

간단한 테스트 프로그램을 작성했습니다.

133
00:03:23,110 --> 00:03:23,750
간단한 테스트 프로그램을 작성했습니다.
 

134
00:03:23,750 --> 00:03:23,760

 

135
00:03:23,760 --> 00:03:26,229

실제 컴퓨터에서 어떻게 실행되는지 확인하기 위해서요.

136
00:03:26,229 --> 00:03:26,239
실제 컴퓨터에서 어떻게 실행되는지 확인하기 위해서요.
 

137
00:03:26,239 --> 00:03:27,270
실제 컴퓨터에서 어떻게 실행되는지 확인하기 위해서요.

138
00:03:27,270 --> 00:03:27,280

 

139
00:03:27,280 --> 00:03:30,550

여기 테스트 코드가 있습니다. 네,

140
00:03:30,550 --> 00:03:30,560
여기 테스트 코드가 있습니다. 네,
 

141
00:03:30,560 --> 00:03:32,070
여기 테스트 코드가 있습니다. 네,
폴더에는

142
00:03:32,070 --> 00:03:34,710
폴더에는
 

143
00:03:34,710 --> 00:03:34,720

 

144
00:03:34,720 --> 00:03:36,550

시퀀스를 구현하는 배열, 시퀀스를 구현하는 이진 트리,

145
00:03:36,550 --> 00:03:38,550
시퀀스를 구현하는 배열, 시퀀스를 구현하는 이진 트리,
 

146
00:03:38,550 --> 00:03:38,560

 

147
00:03:38,560 --> 00:03:39,350


148
00:03:39,350 --> 00:03:39,360

 

149
00:03:39,360 --> 00:03:41,509

이러한 모든 종류의 구현을 구현하는 동적 배열, 그리고 집합을 구현하는

150
00:03:41,509 --> 00:03:41,519
이러한 모든 종류의 구현을 구현하는 동적 배열, 그리고 집합을 구현하는
 

151
00:03:41,519 --> 00:03:43,910
이러한 모든 종류의 구현을 구현하는 동적 배열, 그리고 집합을 구현하는
정렬된 배열,

152
00:03:43,910 --> 00:03:43,920
정렬된 배열,
 

153
00:03:43,920 --> 00:03:46,470
정렬된 배열,
이진 트리, 해시 테이블 등이 있습니다.

154
00:03:46,470 --> 00:03:46,480
이진 트리, 해시 테이블 등이 있습니다.
 

155
00:03:46,480 --> 00:03:48,149
이진 트리, 해시 테이블 등이 있습니다.
이것들이 바로 구현체입니다. 저는

156
00:03:48,149 --> 00:03:48,159
이것들이 바로 구현체입니다. 저는
 

157
00:03:48,159 --> 00:03:48,710
이것들이 바로 구현체입니다. 저는

158
00:03:48,710 --> 00:03:48,720

 

159
00:03:48,720 --> 00:03:50,789

해시 테이블에 파이썬 딕셔너리를 사용하지 않고, 강의 노트

160
00:03:50,789 --> 00:03:50,799
해시 테이블에 파이썬 딕셔너리를 사용하지 않고, 강의 노트
 

161
00:03:50,799 --> 00:03:53,110
해시 테이블에 파이썬 딕셔너리를 사용하지 않고, 강의 노트
에 있는 구현체를 사용했습니다. 이제

162
00:03:53,110 --> 00:03:53,120
에 있는 구현체를 사용했습니다. 이제
 

163
00:03:53,120 --> 00:03:54,149
에 있는 구현체를 사용했습니다. 이제

164
00:03:54,149 --> 00:03:54,159

 

165
00:03:54,159 --> 00:03:56,229

이

166
00:03:56,229 --> 00:03:56,239
이
 

167
00:03:56,239 --> 00:03:57,670
이
간단한 효율성 테스트

168
00:03:57,670 --> 00:03:57,680
간단한 효율성 테스트
 

169
00:03:57,680 --> 00:03:59,750
간단한 효율성 테스트
파이썬 코드를 실행해 보겠습니다. 이 코드는

170
00:03:59,750 --> 00:03:59,760
파이썬 코드를 실행해 보겠습니다. 이 코드는
 

171
00:03:59,760 --> 00:04:01,830
파이썬 코드를 실행해 보겠습니다. 이 코드는
각 인터페이스에 대해 여러 가지

172
00:04:01,830 --> 00:04:01,840
각 인터페이스에 대해 여러 가지
 

173
00:04:01,840 --> 00:04:03,270
각 인터페이스에 대해 여러 가지
연산을 수행하고

174
00:04:03,270 --> 00:04:03,280
연산을 수행하고
 

175
00:04:03,280 --> 00:04:05,270
연산을 수행하고
소요 시간을 측정합니다.

176
00:04:05,270 --> 00:04:05,280
소요 시간을 측정합니다.
 

177
00:04:05,280 --> 00:04:07,270
소요 시간을 측정합니다.
단순히 소요 시간을 로그로 기록하는 것이기 때문에 점근

178
00:04:07,270 --> 00:04:07,280
단순히 소요 시간을 로그로 기록하는 것이기 때문에 점근
 

179
00:04:07,280 --> 00:04:09,910
단순히 소요 시간을 로그로 기록하는 것이기 때문에 점근
적 분석은 아니지만,

180
00:04:09,910 --> 00:04:09,920
적 분석은 아니지만,
 

181
00:04:09,920 --> 00:04:11,589
적 분석은 아니지만,
어떤 차이가 나타나기를 기대합니다. 네, 실행 버튼을

182
00:04:11,589 --> 00:04:13,110
어떤 차이가 나타나기를 기대합니다. 네, 실행 버튼을
 

183
00:04:13,110 --> 00:04:13,120

 

184
00:04:13,120 --> 00:04:15,190

누르겠습니다.

185
00:04:15,190 --> 00:04:15,200
누르겠습니다.
 

186
00:04:15,200 --> 00:04:18,789
누르겠습니다.
여러 가지 테스트가 있으니 한번 살펴볼까요? 네,

187
00:04:18,789 --> 00:04:18,799
여러 가지 테스트가 있으니 한번 살펴볼까요? 네,
 

188
00:04:18,799 --> 00:04:21,990
여러 가지 테스트가 있으니 한번 살펴볼까요? 네,
순차적인 연산들이 많이 있죠. 생성, 설정, 가져오기,

189
00:04:21,990 --> 00:04:25,030
순차적인 연산들이 많이 있죠. 생성, 설정, 가져오기,
 

190
00:04:25,030 --> 00:04:25,040

 

191
00:04:25,040 --> 00:04:28,070

삽입, 삭제 등

192
00:04:28,070 --> 00:04:28,080
삽입, 삭제 등
 

193
00:04:28,080 --> 00:04:31,510
삽입, 삭제 등
다양한 위치에서 실행이 이루어집니다. 제가

194
00:04:31,510 --> 00:04:31,520
다양한 위치에서 실행이 이루어집니다. 제가
 

195
00:04:31,520 --> 00:04:33,909
다양한 위치에서 실행이 이루어집니다. 제가
보여드리는 것은

196
00:04:33,909 --> 00:04:35,430
보여드리는 것은
 

197
00:04:35,430 --> 00:04:37,830

 

198
00:04:37,830 --> 00:04:37,840

 

199
00:04:37,840 --> 00:04:39,510

이러한 데이터 구조에 대해 설정한 해상도에 따른 실제 실행 시간입니다.

200
00:04:39,510 --> 00:04:39,520
이러한 데이터 구조에 대해 설정한 해상도에 따른 실제 실행 시간입니다.
 

201
00:04:39,520 --> 00:04:43,030
이러한 데이터 구조에 대해 설정한 해상도에 따른 실제 실행 시간입니다.
보시다시피, 생성 작업은

202
00:04:43,030 --> 00:04:43,040
보시다시피, 생성 작업은
 

203
00:04:43,040 --> 00:04:45,270
보시다시피, 생성 작업은
이 머신에서 배열을 할당하고

204
00:04:45,270 --> 00:04:45,280
이 머신에서 배열을 할당하고
 

205
00:04:45,280 --> 00:04:46,629
이 머신에서 배열을 할당하고
비우는 것만으로도

206
00:04:46,629 --> 00:04:46,639
비우는 것만으로도
 

207
00:04:46,639 --> 00:04:48,629
비우는 것만으로도
파이썬이 매우 효율적으로 처리해 줍니다.

208
00:04:48,629 --> 00:04:49,590
파이썬이 매우 효율적으로 처리해 줍니다.
 

209
00:04:49,590 --> 00:04:49,600

 

210
00:04:49,600 --> 00:04:51,270

그래서 실제로는

211
00:04:51,270 --> 00:04:51,280
그래서 실제로는
 

212
00:04:51,280 --> 00:04:53,749
그래서 실제로는
log n으로 잘못 표시된 거죠.

213
00:04:53,749 --> 00:04:53,759
log n으로 잘못 표시된 거죠.
 

214
00:04:53,759 --> 00:04:56,310
log n으로 잘못 표시된 거죠.
하지만 가져

215
00:04:56,310 --> 00:04:56,320
하지만 가져
 

216
00:04:56,320 --> 00:04:57,909
하지만 가져
오기와 설정은

217
00:04:57,909 --> 00:04:57,919
오기와 설정은
 

218
00:04:57,919 --> 00:05:00,150
오기와 설정은
정말 빠릅니다. 상수

219
00:05:00,150 --> 00:05:00,160
정말 빠릅니다. 상수
 

220
00:05:00,160 --> 00:05:01,990
정말 빠릅니다. 상수
시간으로 처리되죠. 그리고 다른 작업들은

221
00:05:01,990 --> 00:05:02,000
시간으로 처리되죠. 그리고 다른 작업들은
 

222
00:05:02,000 --> 00:05:02,710
시간으로 처리되죠. 그리고 다른 작업들은
기본적으로 루프를 돌

223
00:05:02,710 --> 00:05:02,720
기본적으로 루프를 돌
 

224
00:05:02,720 --> 00:05:04,310
기본적으로 루프를 돌
수밖에 없기 때문에

225
00:05:04,310 --> 00:05:04,320
수밖에 없기 때문에
 

226
00:05:04,320 --> 00:05:06,710
수밖에 없기 때문에
선형 시간이 걸립니다. 순차적인 작업, 즉

227
00:05:06,710 --> 00:05:10,070
선형 시간이 걸립니다. 순차적인 작업, 즉
 

228
00:05:10,070 --> 00:05:10,080

 

229
00:05:10,080 --> 00:05:13,029

설정과 가져오기는 느리지만,

230
00:05:13,029 --> 00:05:13,039
설정과 가져오기는 느리지만,
 

231
00:05:13,039 --> 00:05:13,749
설정과 가져오기는 느리지만,

232
00:05:13,749 --> 00:05:13,759

 

233
00:05:13,759 --> 00:05:15,189

첫 번째 배열에서 삭제하는 것은

234
00:05:15,189 --> 00:05:15,199
첫 번째 배열에서 삭제하는 것은
 

235
00:05:15,199 --> 00:05:17,670
첫 번째 배열에서 삭제하는 것은
포인터를 다시 연결하는 것만으로도 가능합니다.

236
00:05:17,670 --> 00:05:17,680
포인터를 다시 연결하는 것만으로도 가능합니다.
 

237
00:05:17,680 --> 00:05:21,029
포인터를 다시 연결하는 것만으로도 가능합니다.
동적 배열의 경우, 설정과 가져오기는

238
00:05:21,029 --> 00:05:21,039
동적 배열의 경우, 설정과 가져오기는
 

239
00:05:21,039 --> 00:05:22,310
동적 배열의 경우, 설정과 가져오기는
빠릅니다.

240
00:05:22,310 --> 00:05:22,320
빠릅니다.
 

241
00:05:22,320 --> 00:05:24,710
빠릅니다.
동적 배열이기 때문이죠. 일반 배열과 마찬가지입니다. 마지막으로

242
00:05:24,710 --> 00:05:24,720
동적 배열이기 때문이죠. 일반 배열과 마찬가지입니다. 마지막으로
 

243
00:05:24,720 --> 00:05:25,590
동적 배열이기 때문이죠. 일반 배열과 마찬가지입니다. 마지막으로

244
00:05:25,590 --> 00:05:25,600

 

245
00:05:25,600 --> 00:05:27,430

삽입과 삭제는

246
00:05:27,430 --> 00:05:27,440
삽입과 삭제는
 

247
00:05:27,440 --> 00:05:29,909
삽입과 삭제는
거의 상수 시간으로 처리됩니다.

248
00:05:29,909 --> 00:05:31,670
거의 상수 시간으로 처리됩니다.
 

249
00:05:31,670 --> 00:05:31,680

 

250
00:05:31,680 --> 00:05:33,270

평균값을 다루기 위해 이러한 테스트를 실행하고 있습니다.

251
00:05:33,270 --> 00:05:33,280
평균값을 다루기 위해 이러한 테스트를 실행하고 있습니다.
 

252
00:05:33,280 --> 00:05:34,790
평균값을 다루기 위해 이러한 테스트를 실행하고 있습니다.
실제로 여러

253
00:05:34,790 --> 00:05:34,800
실제로 여러
 

254
00:05:34,800 --> 00:05:36,790
실제로 여러
번 실행하고 성능을 테스트하기 때문에

255
00:05:36,790 --> 00:05:36,800
번 실행하고 성능을 테스트하기 때문에
 

256
00:05:36,800 --> 00:05:40,150
번 실행하고 성능을 테스트하기 때문에
최악의 경우를 보여주는 것이 아닙니다.

257
00:05:40,150 --> 00:05:41,110
최악의 경우를 보여주는 것이 아닙니다.
 

258
00:05:41,110 --> 00:05:41,120

 

259
00:05:41,120 --> 00:05:42,790

모든 항목에 대한 평균을 내고 있는데, 이것이

260
00:05:42,790 --> 00:05:42,800
모든 항목에 대한 평균을 내고 있는데, 이것이
 

261
00:05:42,800 --> 00:05:43,909
모든 항목에 대한 평균을 내고 있는데, 이것이
바로

262
00:05:43,909 --> 00:05:43,919
바로
 

263
00:05:43,919 --> 00:05:45,749
바로
상각의

264
00:05:45,749 --> 00:05:45,759
상각의
 

265
00:05:45,759 --> 00:05:47,270
상각의
의미입니다. 그래서 좋은

266
00:05:47,270 --> 00:05:47,280
의미입니다. 그래서 좋은
 

267
00:05:47,280 --> 00:05:49,830
의미입니다. 그래서 좋은
성능이 나오는 것입니다.

268
00:05:49,830 --> 00:05:49,840
성능이 나오는 것입니다.
 

269
00:05:49,840 --> 00:05:53,110
성능이 나오는 것입니다.
해시 테이블은

270
00:05:53,110 --> 00:05:56,950
해시 테이블은
 

271
00:05:56,950 --> 00:05:56,960

 

272
00:05:56,960 --> 00:05:57,350


273
00:05:57,350 --> 00:05:57,360

 

274
00:05:57,360 --> 00:06:00,629

지난주 문제 풀이 시간에 다뤘던 내용입니다.

275
00:06:00,629 --> 00:06:03,749
지난주 문제 풀이 시간에 다뤘던 내용입니다.
 

276
00:06:03,749 --> 00:06:03,759

 

277
00:06:03,759 --> 00:06:05,510

해시 테이블을 사용한 양방향 큐 구현이죠.

278
00:06:05,510 --> 00:06:05,520
해시 테이블을 사용한 양방향 큐 구현이죠.
 

279
00:06:05,520 --> 00:06:07,510
해시 테이블을 사용한 양방향 큐 구현이죠.
이것이 바로 그 구현 코드입니다.

280
00:06:07,510 --> 00:06:07,520
이것이 바로 그 구현 코드입니다.
 

281
00:06:07,520 --> 00:06:09,590
이것이 바로 그 구현 코드입니다.
보여드리려고 보여드리는 건데, 실제로 꽤

282
00:06:09,590 --> 00:06:09,600
보여드리려고 보여드리는 건데, 실제로 꽤
 

283
00:06:09,600 --> 00:06:11,670
보여드리려고 보여드리는 건데, 실제로 꽤
괜찮습니다. 자바스크립트에서 배열을 표현하는 데 사용하는 방식이죠.

284
00:06:11,670 --> 00:06:13,909
괜찮습니다. 자바스크립트에서 배열을 표현하는 데 사용하는 방식이죠.
 

285
00:06:13,909 --> 00:06:13,919

 

286
00:06:13,919 --> 00:06:17,590

그리고 이진 시퀀스는 이진 트리를 나타냅니다.

287
00:06:17,590 --> 00:06:18,550
그리고 이진 시퀀스는 이진 트리를 나타냅니다.
 

288
00:06:18,550 --> 00:06:18,560

 

289
00:06:18,560 --> 00:06:20,710

균형 이진 트리죠. 이것은 제가

290
00:06:20,710 --> 00:06:20,720
균형 이진 트리죠. 이것은 제가
 

291
00:06:20,720 --> 00:06:22,390
균형 이진 트리죠. 이것은 제가
가지고 있던 AVL 코드입니다.

292
00:06:22,390 --> 00:06:22,400
가지고 있던 AVL 코드입니다.
 

293
00:06:22,400 --> 00:06:24,469
가지고 있던 AVL 코드입니다.
다른 것들은

294
00:06:24,469 --> 00:06:24,479
다른 것들은
 

295
00:06:24,479 --> 00:06:26,629
다른 것들은
삽입과 삭제 성능이 상당히 나빴지만,

296
00:06:26,629 --> 00:06:27,670
삽입과 삭제 성능이 상당히 나빴지만,
 

297
00:06:27,670 --> 00:06:27,680

 

298
00:06:27,680 --> 00:06:29,590

이 코드는

299
00:06:29,590 --> 00:06:29,600
이 코드는
 

300
00:06:29,600 --> 00:06:30,870
이 코드는
다른 것들과 비슷한 성능을 보여줍니다. 보시다시피

301
00:06:30,870 --> 00:06:32,230
다른 것들과 비슷한 성능을 보여줍니다. 보시다시피
 

302
00:06:32,230 --> 00:06:32,240

 

303
00:06:32,240 --> 00:06:35,029

다른 것들보다 머신 사이클이 조금 더 많이 소모되지만,

304
00:06:35,029 --> 00:06:35,830
다른 것들보다 머신 사이클이 조금 더 많이 소모되지만,
 

305
00:06:35,830 --> 00:06:35,840

 

306
00:06:35,840 --> 00:06:39,350

그렇게 나쁘지는 않습니다. 그리고

307
00:06:39,350 --> 00:06:39,360
그렇게 나쁘지는 않습니다. 그리고
 

308
00:06:39,360 --> 00:06:41,590
그렇게 나쁘지는 않습니다. 그리고
집합 쪽에서는

309
00:06:41,590 --> 00:06:41,600
집합 쪽에서는
 

310
00:06:41,600 --> 00:06:44,550
집합 쪽에서는
정렬된 배열을 사용했습니다. 죄송합니다.

311
00:06:44,550 --> 00:06:44,560
정렬된 배열을 사용했습니다. 죄송합니다.
 

312
00:06:44,560 --> 00:06:46,150
정렬된 배열을 사용했습니다. 죄송합니다.
이것은

313
00:06:46,150 --> 00:06:46,160
이것은
 

314
00:06:46,160 --> 00:06:48,469
이것은
기본적으로 배열에서 추출한 집합입니다.  정렬되지 않은 배열입니다. 저는

315
00:06:48,469 --> 00:06:49,749
기본적으로 배열에서 추출한 집합입니다.  정렬되지 않은 배열입니다. 저는
 

316
00:06:49,749 --> 00:06:52,390

 

317
00:06:52,390 --> 00:06:52,400

 

318
00:06:52,400 --> 00:06:54,469

정렬된 배열이

319
00:06:54,469 --> 00:06:54,479
정렬된 배열이
 

320
00:06:54,479 --> 00:06:56,390
정렬된 배열이
좋은 연산을 수행하지만 삽입과 삭제는 성능이 매우 떨어지는 모든 것들을 찾고 있습니다. 그렇죠?

321
00:06:56,390 --> 00:06:56,400
좋은 연산을 수행하지만 삽입과 삭제는 성능이 매우 떨어지는 모든 것들을 찾고 있습니다. 그렇죠?
 

322
00:06:56,400 --> 00:06:59,749
좋은 연산을 수행하지만 삽입과 삭제는 성능이 매우 떨어지는 모든 것들을 찾고 있습니다. 그렇죠?
그래서 이진

323
00:06:59,749 --> 00:06:59,759
그래서 이진
 

324
00:06:59,759 --> 00:07:00,710
그래서 이진
트리와

325
00:07:00,710 --> 00:07:00,720
트리와
 

326
00:07:00,720 --> 00:07:03,270
트리와
해시 테이블이 필요한 겁니다. 사전 연산은 잘 수행하지만 정렬 연산은 매우 어렵습니다.

327
00:07:03,270 --> 00:07:05,270
해시 테이블이 필요한 겁니다. 사전 연산은 잘 수행하지만 정렬 연산은 매우 어렵습니다.
 

328
00:07:05,270 --> 00:07:08,309

 

329
00:07:08,309 --> 00:07:08,319

 

330
00:07:08,319 --> 00:07:11,189

그리고 이진 검색 트리, 즉

331
00:07:11,189 --> 00:07:11,199
그리고 이진 검색 트리, 즉
 

332
00:07:11,199 --> 00:07:12,950
그리고 이진 검색 트리, 즉
집합 이진 트리가 있습니다. 이 트리는

333
00:07:12,950 --> 00:07:12,960
집합 이진 트리가 있습니다. 이 트리는
 

334
00:07:12,960 --> 00:07:15,350
집합 이진 트리가 있습니다. 이 트리는
이러한 모든 연산에서 상당히 좋은 성능을 보여줍니다.

335
00:07:15,350 --> 00:07:15,360
이러한 모든 연산에서 상당히 좋은 성능을 보여줍니다.
 

336
00:07:15,360 --> 00:07:16,309
이러한 모든 연산에서 상당히 좋은 성능을 보여줍니다.

337
00:07:16,309 --> 00:07:16,319

 

338
00:07:16,319 --> 00:07:20,230

사실, 점점 더 좋아지고 있습니다.

339
00:07:20,230 --> 00:07:20,240
사실, 점점 더 좋아지고 있습니다.
 

340
00:07:20,240 --> 00:07:22,469
사실, 점점 더 좋아지고 있습니다.
어떤 이유에서

341
00:07:22,469 --> 00:07:22,479
어떤 이유에서
 

342
00:07:22,479 --> 00:07:24,629
어떤 이유에서
인지 정렬된 배열보다도 더 좋아지고 있습니다.

343
00:07:24,629 --> 00:07:24,639
인지 정렬된 배열보다도 더 좋아지고 있습니다.
 

344
00:07:24,639 --> 00:07:27,670
인지 정렬된 배열보다도 더 좋아지고 있습니다.
왜 그런지는 모르겠지만,

345
00:07:27,670 --> 00:07:27,680
왜 그런지는 모르겠지만,
 

346
00:07:27,680 --> 00:07:29,830
왜 그런지는 모르겠지만,
우리 구현은 전혀 최적화되지 않았습니다.

347
00:07:29,830 --> 00:07:29,840
우리 구현은 전혀 최적화되지 않았습니다.
 

348
00:07:29,840 --> 00:07:31,110
우리 구현은 전혀 최적화되지 않았습니다.
하지만 점근적으로는 꽤 잘 작동합니다. 네.

349
00:07:31,110 --> 00:07:33,029
하지만 점근적으로는 꽤 잘 작동합니다. 네.
 

350
00:07:33,029 --> 00:07:33,830

 

351
00:07:33,830 --> 00:07:33,840

 

352
00:07:33,840 --> 00:07:38,390

수술 첫날 블로그에 레이블이 지정된 이유를 다시 설명해 주시겠습니까?

353
00:07:38,390 --> 00:07:38,400
수술 첫날 블로그에 레이블이 지정된 이유를 다시 설명해 주시겠습니까?
 

354
00:07:38,400 --> 00:07:40,230
수술 첫날 블로그에 레이블이 지정된 이유를 다시 설명해 주시겠습니까?
이것은 단순히 시간 기반으로 레이블이 지정된 것입니다.

355
00:07:40,230 --> 00:07:41,670
이것은 단순히 시간 기반으로 레이블이 지정된 것입니다.
 

356
00:07:41,670 --> 00:07:41,680

 

357
00:07:41,680 --> 00:07:43,830

아마도

358
00:07:43,830 --> 00:07:43,840
아마도
 

359
00:07:43,840 --> 00:07:45,830
아마도
파이썬 내부에

360
00:07:45,830 --> 00:07:45,840
파이썬 내부에
 

361
00:07:45,840 --> 00:07:47,589
파이썬 내부에
이 메모리를 할당하는 C 내장 함수가 있어서

362
00:07:47,589 --> 00:07:47,599
이 메모리를 할당하는 C 내장 함수가 있어서
 

363
00:07:47,599 --> 00:07:49,589
이 메모리를 할당하는 C 내장 함수가 있어서
매우 빠르게 처리하기 때문일 것입니다. 제

364
00:07:49,589 --> 00:07:49,599
매우 빠르게 처리하기 때문일 것입니다. 제
 

365
00:07:49,599 --> 00:07:51,270
매우 빠르게 처리하기 때문일 것입니다. 제
프로그램은 이러한 수치를 보고 점근

366
00:07:51,270 --> 00:07:51,280
프로그램은 이러한 수치를 보고 점근
 

367
00:07:51,280 --> 00:07:53,110
프로그램은 이러한 수치를 보고 점근
적

368
00:07:53,110 --> 00:07:53,120
적
 

369
00:07:53,120 --> 00:07:54,150
적
실행 시간을 예측하려고 하는데,

370
00:07:54,150 --> 00:07:54,160
실행 시간을 예측하려고 하는데,
 

371
00:07:54,160 --> 00:07:55,830
실행 시간을 예측하려고 하는데,
이것은 단지 이러한 범위에 기반한 레이블일 뿐입니다.

372
00:07:55,830 --> 00:07:57,430
이것은 단지 이러한 범위에 기반한 레이블일 뿐입니다.
 

373
00:07:57,430 --> 00:07:59,830

 

374
00:07:59,830 --> 00:07:59,840

 

375
00:07:59,840 --> 00:08:01,909

사실, 이것은 실제 상황을 제대로 반영하지 못하고 있습니다.  언제든지 빌드할 수 있죠. 네, 사실

376
00:08:01,909 --> 00:08:04,710
사실, 이것은 실제 상황을 제대로 반영하지 못하고 있습니다.  언제든지 빌드할 수 있죠. 네, 사실
 

377
00:08:04,710 --> 00:08:04,720

 

378
00:08:04,720 --> 00:08:05,350


379
00:08:05,350 --> 00:08:05,360

 

380
00:08:05,360 --> 00:08:08,309

C 코드였다면, 이 모든 게

381
00:08:08,309 --> 00:08:08,319
C 코드였다면, 이 모든 게
 

382
00:08:08,319 --> 00:08:09,110
C 코드였다면, 이 모든 게
C로 작성되었다면 아마 막대

383
00:08:09,110 --> 00:08:09,120
C로 작성되었다면 아마 막대
 

384
00:08:09,120 --> 00:08:11,589
C로 작성되었다면 아마 막대
그래프가 더

385
00:08:11,589 --> 00:08:11,599
그래프가 더
 

386
00:08:11,599 --> 00:08:13,029
그래프가 더
길어졌을 거예요. 왜냐하면

387
00:08:13,029 --> 00:08:13,039
길어졌을 거예요. 왜냐하면
 

388
00:08:13,039 --> 00:08:15,270
길어졌을 거예요. 왜냐하면
모든 메모리를 탐색하고 접근해야 하기 때문이죠.

389
00:08:15,270 --> 00:08:15,280
모든 메모리를 탐색하고 접근해야 하기 때문이죠.
 

390
00:08:15,280 --> 00:08:17,270
모든 메모리를 탐색하고 접근해야 하기 때문이죠.
여기에서도 마찬가지지만,

391
00:08:17,270 --> 00:08:17,280
여기에서도 마찬가지지만,
 

392
00:08:17,280 --> 00:08:19,830
여기에서도 마찬가지지만,
파이썬 코드는 굉장히 정교해서

393
00:08:19,830 --> 00:08:19,840
파이썬 코드는 굉장히 정교해서
 

394
00:08:19,840 --> 00:08:20,230
파이썬 코드는 굉장히 정교해서

395
00:08:20,230 --> 00:08:20,240

 

396
00:08:20,240 --> 00:08:22,390

C 코드보다 100배는 느린 것 같아요.

397
00:08:22,390 --> 00:08:22,400
C 코드보다 100배는 느린 것 같아요.
 

398
00:08:22,400 --> 00:08:23,749
C 코드보다 100배는 느린 것 같아요.
그래서

399
00:08:23,749 --> 00:08:23,759
그래서
 

400
00:08:23,759 --> 00:08:26,550
그래서
이런 차이가 보이는 거죠. 이해되시나요? 네, 그냥

401
00:08:26,550 --> 00:08:27,830
이런 차이가 보이는 거죠. 이해되시나요? 네, 그냥
 

402
00:08:27,830 --> 00:08:27,840

 

403
00:08:27,840 --> 00:08:29,749

보여드리고 싶었던 거예요. 나중에

404
00:08:29,749 --> 00:08:32,149
보여드리고 싶었던 거예요. 나중에
 

405
00:08:32,149 --> 00:08:32,159

 

406
00:08:32,159 --> 00:08:34,389

여러분이 직접 사용해 볼 수 있도록 공개할 수도 있지만,

407
00:08:34,389 --> 00:08:35,190
여러분이 직접 사용해 볼 수 있도록 공개할 수도 있지만,
 

408
00:08:35,190 --> 00:08:35,200

 

409
00:08:35,200 --> 00:08:37,670

맛보기로 보여드린 거예요.

410
00:08:37,670 --> 00:08:37,680
맛보기로 보여드린 거예요.
 

411
00:08:37,680 --> 00:08:39,829
맛보기로 보여드린 거예요.
질문 있으신가요? 다음으로 넘어가시죠.

412
00:08:39,829 --> 00:08:39,839
질문 있으신가요? 다음으로 넘어가시죠.
 

413
00:08:39,839 --> 00:08:43,110
질문 있으신가요? 다음으로 넘어가시죠.
어떻게 끄고 종료하나요?

414
00:08:43,110 --> 00:08:46,949
어떻게 끄고 종료하나요?
 

415
00:08:46,949 --> 00:08:47,770

 

416
00:08:47,770 --> 00:08:47,780

 

417
00:08:47,780 --> 00:08:51,670

[음악]

418
00:08:51,670 --> 00:08:51,680

 

419
00:08:51,680 --> 00:08:56,550

네, 알겠습니다. 그럼

420
00:08:56,550 --> 00:08:56,560

 

421
00:08:56,560 --> 00:08:59,590

문제를 풀어보도록 하죠.

422
00:08:59,590 --> 00:09:03,030
문제를 풀어보도록 하죠.
 

423
00:09:03,030 --> 00:09:03,040

 

424
00:09:03,040 --> 00:09:04,790

여기 문제들이 있습니다. 첫 번째 문제는 시퀀스

425
00:09:04,790 --> 00:09:07,750
여기 문제들이 있습니다. 첫 번째 문제는 시퀀스
 

426
00:09:07,750 --> 00:09:07,760

 

427
00:09:07,760 --> 00:09:10,310

AVL 트리를 살펴보는 거예요. 이게 시퀀스 AVL

428
00:09:10,310 --> 00:09:10,320
AVL 트리를 살펴보는 거예요. 이게 시퀀스 AVL
 

429
00:09:10,320 --> 00:09:15,030
AVL 트리를 살펴보는 거예요. 이게 시퀀스 AVL
트리죠. 어떻게 아냐고요? 꼭 그럴

430
00:09:15,030 --> 00:09:15,040

 

431
00:09:15,040 --> 00:09:18,310

필요는 없지만, 이 요소들은

432
00:09:18,310 --> 00:09:19,430
필요는 없지만, 이 요소들은
 

433
00:09:19,430 --> 00:09:21,590

 

434
00:09:21,590 --> 00:09:21,600

 

435
00:09:21,600 --> 00:09:22,550

정렬된 순서대로 나열된 건 아니니까요.

436
00:09:22,550 --> 00:09:22,560
정렬된 순서대로 나열된 건 아니니까요.
 

437
00:09:22,560 --> 00:09:25,750
정렬된 순서대로 나열된 건 아니니까요.
그러니까 집합 AVL 트리가 아니겠죠?  이 트리는

438
00:09:25,750 --> 00:09:25,760
그러니까 집합 AVL 트리가 아니겠죠?  이 트리는
 

439
00:09:25,760 --> 00:09:28,150
그러니까 집합 AVL 트리가 아니겠죠?  이 트리는
AVL 트리인가요?

440
00:09:28,150 --> 00:09:28,160
AVL 트리인가요?
 

441
00:09:28,160 --> 00:09:30,470
AVL 트리인가요?
높이 균형이 잘 잡혀 있나요?

442
00:09:30,470 --> 00:09:30,480
높이 균형이 잘 잡혀 있나요?
 

443
00:09:30,480 --> 00:09:33,350
높이 균형이 잘 잡혀 있나요?
네, 기본적으로

444
00:09:33,350 --> 00:09:33,360
네, 기본적으로
 

445
00:09:33,360 --> 00:09:35,590
네, 기본적으로
각 서브트리의 크기를 계산해 보면,

446
00:09:35,590 --> 00:09:35,600
각 서브트리의 크기를 계산해 보면,
 

447
00:09:35,600 --> 00:09:38,550
각 서브트리의 크기를 계산해 보면,
왼쪽과 오른쪽 서브트리의 크기가

448
00:09:38,550 --> 00:09:40,070
왼쪽과 오른쪽 서브트리의 크기가
 

449
00:09:40,070 --> 00:09:40,080

 

450
00:09:40,080 --> 00:09:41,670

균형이 잘 잡혀 있음을 직접 확인할 수 있습니다.

451
00:09:41,670 --> 00:09:41,680
균형이 잘 잡혀 있음을 직접 확인할 수 있습니다.
 

452
00:09:41,680 --> 00:09:43,910
균형이 잘 잡혀 있음을 직접 확인할 수 있습니다.
서로 ±1 이내의 차이를 보입니다.

453
00:09:43,910 --> 00:09:43,920
서로 ±1 이내의 차이를 보입니다.
 

454
00:09:43,920 --> 00:09:45,910
서로 ±1 이내의 차이를 보입니다.
사실 이 정도

455
00:09:45,910 --> 00:09:47,590
사실 이 정도
 

456
00:09:47,590 --> 00:09:47,600

 

457
00:09:47,600 --> 00:09:51,110

노드 수에서

458
00:09:51,110 --> 00:09:51,120
노드 수에서
 

459
00:09:51,120 --> 00:09:53,350
노드 수에서
높이 균형과 AVL 속성을 유지하면서 균형에서 가장 멀리 떨어진 경우입니다.

460
00:09:53,350 --> 00:09:53,360
높이 균형과 AVL 속성을 유지하면서 균형에서 가장 멀리 떨어진 경우입니다.
 

461
00:09:53,360 --> 00:09:53,910
높이 균형과 AVL 속성을 유지하면서 균형에서 가장 멀리 떨어진 경우입니다.

462
00:09:53,910 --> 00:09:53,920

 

463
00:09:53,920 --> 00:09:55,509

이것이 바로 이 트리가 유익한

464
00:09:55,509 --> 00:09:55,519
이것이 바로 이 트리가 유익한
 

465
00:09:55,519 --> 00:09:57,509
이것이 바로 이 트리가 유익한
예시인 이유입니다. 거의 한계에 가까운 상태죠. 자, 그럼

466
00:09:57,509 --> 00:10:00,710
예시인 이유입니다. 거의 한계에 가까운 상태죠. 자, 그럼
 

467
00:10:00,710 --> 00:10:02,389

 

468
00:10:02,389 --> 00:10:02,399

 

469
00:10:02,399 --> 00:10:03,990

이 그림에서 무엇이 빠져 있는지 살펴보겠습니다. 제가

470
00:10:03,990 --> 00:10:04,000
이 그림에서 무엇이 빠져 있는지 살펴보겠습니다. 제가
 

471
00:10:04,000 --> 00:10:05,829
이 그림에서 무엇이 빠져 있는지 살펴보겠습니다. 제가
이 트리를 시퀀스 AVL 트리라고 주장한다면,

472
00:10:05,829 --> 00:10:05,839
이 트리를 시퀀스 AVL 트리라고 주장한다면,
 

473
00:10:05,839 --> 00:10:08,630
이 트리를 시퀀스 AVL 트리라고 주장한다면,

474
00:10:08,630 --> 00:10:08,640

 

475
00:10:08,640 --> 00:10:11,670

무엇이 빠져 있을까요?

476
00:10:11,670 --> 00:10:14,230
무엇이 빠져 있을까요?
 

477
00:10:14,230 --> 00:10:17,030

 

478
00:10:17,030 --> 00:10:22,310

 

479
00:10:22,310 --> 00:10:22,320

 

480
00:10:22,320 --> 00:10:25,910

시퀀스 AVL 트리에서 중요한 것은 무엇일까요? 이 그림에는 나와 있지 않지만, 중요한 것은 높이입니다. 시퀀스 AVL 트리는

481
00:10:25,910 --> 00:10:28,150
시퀀스 AVL 트리에서 중요한 것은 무엇일까요? 이 그림에는 나와 있지 않지만, 중요한 것은 높이입니다. 시퀀스 AVL 트리는
 

482
00:10:28,150 --> 00:10:28,160

 

483
00:10:28,160 --> 00:10:29,430

세트 사용 가능 트리와는 다릅니다.

484
00:10:29,430 --> 00:10:29,440
세트 사용 가능 트리와는 다릅니다.
 

485
00:10:29,440 --> 00:10:31,590
세트 사용 가능 트리와는 다릅니다.
두 가지 요소가 추가되는데, 회전

486
00:10:31,590 --> 00:10:31,600
두 가지 요소가 추가되는데, 회전
 

487
00:10:31,600 --> 00:10:34,550
두 가지 요소가 추가되는데, 회전
중에 균형을 유지해야 하기 때문입니다.

488
00:10:34,550 --> 00:10:34,560
중에 균형을 유지해야 하기 때문입니다.
 

489
00:10:34,560 --> 00:10:36,790
중에 균형을 유지해야 하기 때문입니다.
즉, 각

490
00:10:36,790 --> 00:10:38,230
즉, 각
 

491
00:10:38,230 --> 00:10:38,240

 

492
00:10:38,240 --> 00:10:39,590

서브트리의 높이를

493
00:10:39,590 --> 00:10:39,600
서브트리의 높이를
 

494
00:10:39,600 --> 00:10:40,790
서브트리의 높이를
상수 시간 안에 계산할 수 있어야 합니다.  저는

495
00:10:40,790 --> 00:10:40,800
상수 시간 안에 계산할 수 있어야 합니다.  저는
 

496
00:10:40,800 --> 00:10:43,190
상수 시간 안에 계산할 수 있어야 합니다.  저는
트리를 따라 올라가면서 문제를 해결하고 있는데,

497
00:10:43,190 --> 00:10:43,200
트리를 따라 올라가면서 문제를 해결하고 있는데,
 

498
00:10:43,200 --> 00:10:43,990
트리를 따라 올라가면서 문제를 해결하고 있는데,
순서대로

499
00:10:43,990 --> 00:10:44,000
순서대로
 

500
00:10:44,000 --> 00:10:46,790
순서대로
서브트리의 번호를 저장해야 합니다.

501
00:10:46,790 --> 00:10:47,910
서브트리의 번호를 저장해야 합니다.
 

502
00:10:47,910 --> 00:10:51,350

 

503
00:10:51,350 --> 00:10:51,360

 

504
00:10:51,360 --> 00:10:53,430

모든 서브트리를 다 그릴 수는 없지만,

505
00:10:53,430 --> 00:10:53,440
모든 서브트리를 다 그릴 수는 없지만,
 

506
00:10:53,440 --> 00:10:55,110
모든 서브트리를 다 그릴 수는 없지만,
4번 서브트리의

507
00:10:55,110 --> 00:10:55,120
4번 서브트리의
 

508
00:10:55,120 --> 00:10:59,590
4번 서브트리의
높이는

509
00:10:59,590 --> 00:11:03,030

 

510
00:11:03,030 --> 00:11:05,190

 

511
00:11:05,190 --> 00:11:06,550

 

512
00:11:06,550 --> 00:11:10,150

 

513
00:11:10,150 --> 00:11:13,990

 

514
00:11:13,990 --> 00:11:14,870

 

515
00:11:14,870 --> 00:11:14,880

 

516
00:11:14,880 --> 00:11:17,990

얼마일까요? 1, 2, 3, 3, 4, 5, 6, 7, 1, 6, 7 ...  네,

517
00:11:17,990 --> 00:11:19,110
얼마일까요? 1, 2, 3, 3, 4, 5, 6, 7, 1, 6, 7 ...  네,
 

518
00:11:19,110 --> 00:11:22,150

 

519
00:11:22,150 --> 00:11:22,870

 

520
00:11:22,870 --> 00:11:26,069

 

521
00:11:26,069 --> 00:11:28,069

 

522
00:11:28,069 --> 00:11:29,269

 

523
00:11:29,269 --> 00:11:32,389

 

524
00:11:32,389 --> 00:11:35,590

 

525
00:11:35,590 --> 00:11:38,630

 

526
00:11:38,630 --> 00:11:38,640

 

527
00:11:38,640 --> 00:11:39,590


528
00:11:39,590 --> 00:11:41,670

 

529
00:11:41,670 --> 00:11:43,269

 

530
00:11:43,269 --> 00:11:45,430

 

531
00:11:45,430 --> 00:11:47,110

 

532
00:11:47,110 --> 00:11:49,910

 

533
00:11:49,910 --> 00:11:50,790

 

534
00:11:50,790 --> 00:11:53,509

 

535
00:11:53,509 --> 00:11:56,150

 

536
00:11:56,150 --> 00:11:59,590

 

537
00:11:59,590 --> 00:12:02,949

 

538
00:12:02,949 --> 00:12:05,190

 

539
00:12:05,190 --> 00:12:05,200

 

540
00:12:05,200 --> 00:12:07,030

그럼

541
00:12:07,030 --> 00:12:08,710
그럼
 

542
00:12:08,710 --> 00:12:08,720

 

543
00:12:08,720 --> 00:12:11,110

제 시퀀스에서 여덟 번째 요소를 삭제해 달라고 부탁드리겠습니다.

544
00:12:11,110 --> 00:12:11,120
제 시퀀스에서 여덟 번째 요소를 삭제해 달라고 부탁드리겠습니다.
 

545
00:12:11,120 --> 00:12:14,629
제 시퀀스에서 여덟 번째 요소를 삭제해 달라고 부탁드리겠습니다.
시퀀스에서 여덟 번째 요소는 무엇일까요?

546
00:12:14,629 --> 00:12:14,639

 

547
00:12:14,639 --> 00:12:17,350

네, 맞습니다. 숫자를 삭제하는 게 아니라,

548
00:12:17,350 --> 00:12:17,360
네, 맞습니다. 숫자를 삭제하는 게 아니라,
 

549
00:12:17,360 --> 00:12:17,829
네, 맞습니다. 숫자를 삭제하는 게 아니라,

550
00:12:17,829 --> 00:12:21,030

 

551
00:12:21,030 --> 00:12:21,040

 

552
00:12:21,040 --> 00:12:22,870

8번째 요소를 삭제하는 겁니다. 보시다시피, 이건 순차 연산입니다.

553
00:12:22,870 --> 00:12:22,880
8번째 요소를 삭제하는 겁니다. 보시다시피, 이건 순차 연산입니다.
 

554
00:12:22,880 --> 00:12:24,230
8번째 요소를 삭제하는 겁니다. 보시다시피, 이건 순차 연산입니다.

555
00:12:24,230 --> 00:12:27,030

 

556
00:12:27,030 --> 00:12:28,069

 

557
00:12:28,069 --> 00:12:28,079

 

558
00:12:28,079 --> 00:12:30,389

시퀀스와 집합의 의미론을 구분하는 것이 매우 중요합니다.

559
00:12:30,389 --> 00:12:30,399
시퀀스와 집합의 의미론을 구분하는 것이 매우 중요합니다.
 

560
00:12:30,399 --> 00:12:31,990
시퀀스와 집합의 의미론을 구분하는 것이 매우 중요합니다.
시퀀스를 다룰 때는

561
00:12:31,990 --> 00:12:34,790
시퀀스를 다룰 때는
 

562
00:12:34,790 --> 00:12:34,800

 

563
00:12:34,800 --> 00:12:36,949

이 데이터 구조의 내장 요소를 직접 조회해서는 안 됩니다.

564
00:12:36,949 --> 00:12:36,959
이 데이터 구조의 내장 요소를 직접 조회해서는 안 됩니다.
 

565
00:12:36,959 --> 00:12:38,389
이 데이터 구조의 내장 요소를 직접 조회해서는 안 됩니다.
왜냐하면 이 데이터

566
00:12:38,389 --> 00:12:38,399
왜냐하면 이 데이터
 

567
00:12:38,399 --> 00:12:39,910
왜냐하면 이 데이터
구조는 내장 요소를 지원하지 않기 때문입니다. 예를 들어,

568
00:12:39,910 --> 00:12:39,920
구조는 내장 요소를 지원하지 않기 때문입니다. 예를 들어,
 

569
00:12:39,920 --> 00:12:40,389
구조는 내장 요소를 지원하지 않기 때문입니다. 예를 들어,

570
00:12:40,389 --> 00:12:43,430

 

571
00:12:43,430 --> 00:12:43,440

 

572
00:12:43,440 --> 00:12:46,710

8번째 키의 인덱스를 찾고 싶다면

573
00:12:46,710 --> 00:12:49,910
8번째 키의 인덱스를 찾고 싶다면
 

574
00:12:49,910 --> 00:12:51,509

 

575
00:12:51,509 --> 00:12:51,519

 

576
00:12:51,519 --> 00:12:53,190

배열처럼

577
00:12:53,190 --> 00:12:53,200
배열처럼
 

578
00:12:53,200 --> 00:12:54,790
배열처럼
전체 시퀀스를 순회하면서 해당

579
00:12:54,790 --> 00:12:54,800
전체 시퀀스를 순회하면서 해당
 

580
00:12:54,800 --> 00:12:55,509
전체 시퀀스를 순회하면서 해당
요소가 있는지 확인하는 수밖에

581
00:12:55,509 --> 00:12:55,519
요소가 있는지 확인하는 수밖에
 

582
00:12:55,519 --> 00:12:57,430
요소가 있는지 확인하는 수밖에
없습니다. 선형

583
00:12:57,430 --> 00:12:57,440
없습니다. 선형
 

584
00:12:57,440 --> 00:12:59,509
없습니다. 선형
시간보다 효율적인 방법은 없습니다. 이 데이터 구조는 그런 용도로 설계된 것이 아니기 때문입니다. 그렇다면 이 데이터 구조는

585
00:12:59,509 --> 00:12:59,519
시간보다 효율적인 방법은 없습니다. 이 데이터 구조는 그런 용도로 설계된 것이 아니기 때문입니다. 그렇다면 이 데이터 구조는
 

586
00:12:59,519 --> 00:13:00,870
시간보다 효율적인 방법은 없습니다. 이 데이터 구조는 그런 용도로 설계된 것이 아니기 때문입니다. 그렇다면 이 데이터 구조는
무엇을 위해 설계되었을까요?

587
00:13:00,870 --> 00:13:03,190
무엇을 위해 설계되었을까요?
 

588
00:13:03,190 --> 00:13:03,200

 

589
00:13:03,200 --> 00:13:06,710

시퀀스에서 인덱스를 이용해 요소를 찾는 용도입니다. 그럼

590
00:13:06,710 --> 00:13:06,720
시퀀스에서 인덱스를 이용해 요소를 찾는 용도입니다. 그럼
 

591
00:13:06,720 --> 00:13:11,910
시퀀스에서 인덱스를 이용해 요소를 찾는 용도입니다. 그럼
여덟 번째 인덱스를 어떻게 찾을까요?

592
00:13:11,910 --> 00:13:11,920
여덟 번째 인덱스를 어떻게 찾을까요?
 

593
00:13:11,920 --> 00:13:14,069
여덟 번째 인덱스를 어떻게 찾을까요?
트리를 보고 중위

594
00:13:14,069 --> 00:13:14,949
트리를 보고 중위
 

595
00:13:14,949 --> 00:13:16,470

 

596
00:13:16,470 --> 00:13:16,480

 

597
00:13:16,480 --> 00:13:18,829

순회를 하면서 하나씩 세어볼 수 있겠죠.  중위 순회

598
00:13:18,829 --> 00:13:18,839
순회를 하면서 하나씩 세어볼 수 있겠죠.  중위 순회
 

599
00:13:18,839 --> 00:13:21,750
순회를 하면서 하나씩 세어볼 수 있겠죠.  중위 순회
오른쪽 0 1 2 3 4 5 6 7

600
00:13:21,750 --> 00:13:21,760
오른쪽 0 1 2 3 4 5 6 7
 

601
00:13:21,760 --> 00:13:25,190
오른쪽 0 1 2 3 4 5 6 7
8 좋아요,

602
00:13:25,190 --> 00:13:25,200
8 좋아요,
 

603
00:13:25,200 --> 00:13:28,710
8 좋아요,
8을 찾았네요. 그런데 순차 AVL 트리는 어떻게 작동하나요? 서브트리

604
00:13:28,710 --> 00:13:30,150
8을 찾았네요. 그런데 순차 AVL 트리는 어떻게 작동하나요? 서브트리
 

605
00:13:30,150 --> 00:13:30,160

 

606
00:13:30,160 --> 00:13:33,990

크기를 저장하고 있는데, 지금 이 위치에서

607
00:13:33,990 --> 00:13:35,590
크기를 저장하고 있는데, 지금 이 위치에서
 

608
00:13:35,590 --> 00:13:35,600

 

609
00:13:35,600 --> 00:13:37,910

인덱스가 뭔지 모르겠어요.

610
00:13:37,910 --> 00:13:39,670
인덱스가 뭔지 모르겠어요.
 

611
00:13:39,670 --> 00:13:39,680

 

612
00:13:39,680 --> 00:13:42,150

루트에서 어떻게 인덱스를 알 수 있을까요? 왼쪽 서브트리를 보면

613
00:13:42,150 --> 00:13:42,160
루트에서 어떻게 인덱스를 알 수 있을까요? 왼쪽 서브트리를 보면
 

614
00:13:42,160 --> 00:13:44,150
루트에서 어떻게 인덱스를 알 수 있을까요? 왼쪽 서브트리를 보면
몇 개인지 알 수 있죠.

615
00:13:44,150 --> 00:13:44,160
몇 개인지 알 수 있죠.
 

616
00:13:44,160 --> 00:13:47,350
몇 개인지 알 수 있죠.
여기 7개가 있네요.

617
00:13:47,350 --> 00:13:47,360
여기 7개가 있네요.
 

618
00:13:47,360 --> 00:13:51,350
여기 7개가 있네요.
1 2 3 4 5 7

619
00:13:51,350 --> 00:13:51,360
1 2 3 4 5 7
 

620
00:13:51,360 --> 00:13:53,990
1 2 3 4 5 7
8. 네,

621
00:13:53,990 --> 00:13:55,269
8. 네,
 

622
00:13:55,269 --> 00:13:55,279

 

623
00:13:55,279 --> 00:13:57,829

인덱스 8에 있는 9번째 항목을 찾고 있으니까요. 그러니까 지금

624
00:13:57,829 --> 00:13:57,839
인덱스 8에 있는 9번째 항목을 찾고 있으니까요. 그러니까 지금
 

625
00:13:57,839 --> 00:13:59,350
인덱스 8에 있는 9번째 항목을 찾고 있으니까요. 그러니까 지금
제가 8번째 항목이라는 거죠.

626
00:13:59,350 --> 00:13:59,360
제가 8번째 항목이라는 거죠.
 

627
00:13:59,360 --> 00:14:03,430
제가 8번째 항목이라는 거죠.
인덱스 7에 있는 항목은요.

628
00:14:03,430 --> 00:14:04,870
인덱스 7에 있는 항목은요.
 

629
00:14:04,870 --> 00:14:04,880

 

630
00:14:04,880 --> 00:14:07,110

서브트리 크기를 보고 있으니까요. 제가

631
00:14:07,110 --> 00:14:07,120
서브트리 크기를 보고 있으니까요. 제가
 

632
00:14:07,120 --> 00:14:09,829
서브트리 크기를 보고 있으니까요. 제가
뭘 알 수 있을까요?

633
00:14:09,829 --> 00:14:09,839
뭘 알 수 있을까요?
 

634
00:14:09,839 --> 00:14:12,150
뭘 알 수 있을까요?
제가 찾고 있는 인덱스가 오른쪽에 있다는 걸 알 수 있죠. 그럼 아래로 내려가서

635
00:14:12,150 --> 00:14:15,430
제가 찾고 있는 인덱스가 오른쪽에 있다는 걸 알 수 있죠. 그럼 아래로 내려가서
 

636
00:14:15,430 --> 00:14:18,389

 

637
00:14:18,389 --> 00:14:19,350

 

638
00:14:19,350 --> 00:14:19,360

 

639
00:14:19,360 --> 00:14:23,430

이 서브트리에서 찾고 있는 인덱스가 뭔지 알 수 있겠죠. 0이요.

640
00:14:23,430 --> 00:14:25,910
이 서브트리에서 찾고 있는 인덱스가 뭔지 알 수 있겠죠. 0이요.
 

641
00:14:25,910 --> 00:14:25,920

 

642
00:14:25,920 --> 00:14:27,350

이 서브트리의 첫 번째 항목을 찾고 싶어요.

643
00:14:27,350 --> 00:14:27,360
이 서브트리의 첫 번째 항목을 찾고 싶어요.
 

644
00:14:27,360 --> 00:14:30,310
이 서브트리의 첫 번째 항목을 찾고 싶어요.
검색 인덱스가 바뀌었네요.

645
00:14:30,310 --> 00:14:30,320
검색 인덱스가 바뀌었네요.
 

646
00:14:30,320 --> 00:14:30,949
검색 인덱스가 바뀌었네요.
왜냐하면 저는 이미

647
00:14:30,949 --> 00:14:33,350
왜냐하면 저는 이미
 

648
00:14:33,350 --> 00:14:33,360

 

649
00:14:33,360 --> 00:14:34,710

8개의 항목을 모두 처리했으니까요.

650
00:14:34,710 --> 00:14:34,720
8개의 항목을 모두 처리했으니까요.
 

651
00:14:34,720 --> 00:14:37,430
8개의 항목을 모두 처리했으니까요.
이제 인덱스 0에 있는 항목을 찾고 있으니

652
00:14:37,430 --> 00:14:38,790
이제 인덱스 0에 있는 항목을 찾고 있으니
 

653
00:14:38,790 --> 00:14:38,800

 

654
00:14:38,800 --> 00:14:40,949

왼쪽을 보면...

655
00:14:40,949 --> 00:14:40,959
왼쪽을 보면...
 

656
00:14:40,959 --> 00:14:43,269
왼쪽을 보면...
왼쪽 서브트리가 없었다면 저는 0이 되었을 거고,

657
00:14:43,269 --> 00:14:43,279
왼쪽 서브트리가 없었다면 저는 0이 되었을 거고,
 

658
00:14:43,279 --> 00:14:45,350
왼쪽 서브트리가 없었다면 저는 0이 되었을 거고,
저를 반환했을 겁니다. 하지만

659
00:14:45,350 --> 00:14:45,360
저를 반환했을 겁니다. 하지만
 

660
00:14:45,360 --> 00:14:47,350
저를 반환했을 겁니다. 하지만
여기에 뭔가가 있으니까, 저는 여기서 0을 찾고 있는 거죠. 그게

661
00:14:47,350 --> 00:14:50,629
여기에 뭔가가 있으니까, 저는 여기서 0을 찾고 있는 거죠. 그게
 

662
00:14:50,629 --> 00:14:50,639

 

663
00:14:50,639 --> 00:14:53,430

바로 그 사람인데, 그걸 반환하면 됩니다.

664
00:14:53,430 --> 00:14:53,440
바로 그 사람인데, 그걸 반환하면 됩니다.
 

665
00:14:53,440 --> 00:14:54,550
바로 그 사람인데, 그걸 반환하면 됩니다.
그리고 사실 제가 하고 있는 건

666
00:14:54,550 --> 00:14:55,350
그리고 사실 제가 하고 있는 건
 

667
00:14:55,350 --> 00:14:55,360

 

668
00:14:55,360 --> 00:15:00,150

삭제하는 겁니다. 그래서 삭제했죠. 으악. 여기서

669
00:15:00,150 --> 00:15:00,160
삭제하는 겁니다. 그래서 삭제했죠. 으악. 여기서
 

670
00:15:00,160 --> 00:15:06,470
삭제하는 겁니다. 그래서 삭제했죠. 으악. 여기서
뭐가 문제죠?

671
00:15:06,470 --> 00:15:06,480

 

672
00:15:06,480 --> 00:15:08,310

높이 균형이 안 맞네요. 이상하네요.

673
00:15:08,310 --> 00:15:08,320
높이 균형이 안 맞네요. 이상하네요.
 

674
00:15:08,320 --> 00:15:10,150
높이 균형이 안 맞네요. 이상하네요.
여기서 높이 균형이 안 맞는 건 뭘까요?

675
00:15:10,150 --> 00:15:10,160
여기서 높이 균형이 안 맞는 건 뭘까요?
 

676
00:15:10,160 --> 00:15:13,430
여기서 높이 균형이 안 맞는 건 뭘까요?
음, 러그 서브트리가 지구라서

677
00:15:13,430 --> 00:15:13,440
음, 러그 서브트리가 지구라서
 

678
00:15:13,440 --> 00:15:15,990
음, 러그 서브트리가 지구라서
이 사람은 높이 균형이 안 맞네요. 이

679
00:15:15,990 --> 00:15:16,000
이 사람은 높이 균형이 안 맞네요. 이
 

680
00:15:16,000 --> 00:15:16,949
이 사람은 높이 균형이 안 맞네요. 이

681
00:15:16,949 --> 00:15:16,959

 

682
00:15:16,959 --> 00:15:18,949

사람의 서브트리도 높이 균형이 안 맞네요.

683
00:15:18,949 --> 00:15:18,959
사람의 서브트리도 높이 균형이 안 맞네요.
 

684
00:15:18,959 --> 00:15:21,430
사람의 서브트리도 높이 균형이 안 맞네요.
이 사람은 2이고, 이 사람은 1이네요.

685
00:15:21,430 --> 00:15:21,440
이 사람은 2이고, 이 사람은 1이네요.
 

686
00:15:21,440 --> 00:15:25,590
이 사람은 2이고, 이 사람은 1이네요.
그럼 어떻게 고칠까요?

687
00:15:25,590 --> 00:15:25,600

 

688
00:15:25,600 --> 00:15:27,990

회전을 좀 해보면 되죠. 이건

689
00:15:27,990 --> 00:15:28,000
회전을 좀 해보면 되죠. 이건
 

690
00:15:28,000 --> 00:15:28,870
회전을 좀 해보면 되죠. 이건
사실

691
00:15:28,870 --> 00:15:31,350
사실
 

692
00:15:31,350 --> 00:15:31,360

 

693
00:15:31,360 --> 00:15:32,790

어제 얘기했던 세 번째 최악의 경우와 같은 상황입니다.

694
00:15:32,790 --> 00:15:32,800
어제 얘기했던 세 번째 최악의 경우와 같은 상황입니다.
 

695
00:15:32,800 --> 00:15:35,670
어제 얘기했던 세 번째 최악의 경우와 같은 상황입니다.
만약 이 사람을 왼쪽으로 회전시키면

696
00:15:35,670 --> 00:15:35,680
만약 이 사람을 왼쪽으로 회전시키면
 

697
00:15:35,680 --> 00:15:36,230
만약 이 사람을 왼쪽으로 회전시키면

698
00:15:36,230 --> 00:15:36,240

 

699
00:15:36,240 --> 00:15:39,430

어떻게 될까요?

700
00:15:39,430 --> 00:15:39,440
어떻게 될까요?
 

701
00:15:39,440 --> 00:15:42,710
어떻게 될까요?
여기에 12가 생기고, 여기에 10이 생기고, 8이

702
00:15:42,710 --> 00:15:42,720
여기에 12가 생기고, 여기에 10이 생기고, 8이
 

703
00:15:42,720 --> 00:15:45,269
여기에 12가 생기고, 여기에 10이 생기고, 8이
거기에 붙겠죠.

704
00:15:45,269 --> 00:15:45,279
거기에 붙겠죠.
 

705
00:15:45,279 --> 00:15:46,949
거기에 붙겠죠.
이제 반대 방향으로 높이 균형이 안 맞는 겁니다.

706
00:15:46,949 --> 00:15:46,959
이제 반대 방향으로 높이 균형이 안 맞는 겁니다.
 

707
00:15:46,959 --> 00:15:49,590
이제 반대 방향으로 높이 균형이 안 맞는 겁니다.
좋지 않죠.

708
00:15:49,590 --> 00:15:49,600
좋지 않죠.
 

709
00:15:49,600 --> 00:15:52,150
좋지 않죠.
그래서

710
00:15:52,150 --> 00:15:52,160
그래서
 

711
00:15:52,160 --> 00:15:53,430
그래서

712
00:15:53,430 --> 00:15:53,440

 

713
00:15:53,440 --> 00:15:56,550

제가 오른쪽으로 심하게 치우쳐 있는데,

714
00:15:56,550 --> 00:15:56,560
제가 오른쪽으로 심하게 치우쳐 있는데,
 

715
00:15:56,560 --> 00:15:59,269
제가 오른쪽으로 심하게 치우쳐 있는데,
오른쪽 서브트리도 심하게 치우쳐 있는 이 경우를 처리하는 방법은 다음과 같습니다.

716
00:15:59,269 --> 00:15:59,279
오른쪽 서브트리도 심하게 치우쳐 있는 이 경우를 처리하는 방법은 다음과 같습니다.
 

717
00:15:59,279 --> 00:16:01,030
오른쪽 서브트리도 심하게 치우쳐 있는 이 경우를 처리하는 방법은 다음과 같습니다.
왼쪽으로 기울어져 있어서

718
00:16:01,030 --> 00:16:01,040
왼쪽으로 기울어져 있어서
 

719
00:16:01,040 --> 00:16:03,990
왼쪽으로 기울어져 있어서
여기서 회전을 해야 해요. 오른쪽으로

720
00:16:03,990 --> 00:16:04,000
여기서 회전을 해야 해요. 오른쪽으로
 

721
00:16:04,000 --> 00:16:04,629
여기서 회전을 해야 해요. 오른쪽으로
회전한

722
00:16:04,629 --> 00:16:04,639
회전한
 

723
00:16:04,639 --> 00:16:06,870
회전한
다음 다시 회전을 해야 하죠. 이게

724
00:16:06,870 --> 00:16:06,880
다음 다시 회전을 해야 하죠. 이게
 

725
00:16:06,880 --> 00:16:08,470
다음 다시 회전을 해야 하죠. 이게
공식이에요. 자,

726
00:16:08,470 --> 00:16:08,480
공식이에요. 자,
 

727
00:16:08,480 --> 00:16:10,949
공식이에요. 자,
먼저 10도 오른쪽 회전을 합니다. 그러면

728
00:16:10,949 --> 00:16:10,959
먼저 10도 오른쪽 회전을 합니다. 그러면
 

729
00:16:10,959 --> 00:16:11,990
먼저 10도 오른쪽 회전을 합니다. 그러면

730
00:16:11,990 --> 00:16:15,030

 

731
00:16:15,030 --> 00:16:15,040

 

732
00:16:15,040 --> 00:16:18,230


733
00:16:18,230 --> 00:16:18,240

 

734
00:16:18,240 --> 00:16:21,269

8, 10처럼 보이죠. 음,

735
00:16:21,269 --> 00:16:21,279
8, 10처럼 보이죠. 음,
 

736
00:16:21,279 --> 00:16:24,150
8, 10처럼 보이죠. 음,
분명히 이전보다 나아진 건 아니지만,

737
00:16:24,150 --> 00:16:25,430
분명히 이전보다 나아진 건 아니지만,
 

738
00:16:25,430 --> 00:16:25,440

 

739
00:16:25,440 --> 00:16:27,110

수정하기 위한 중간 단계입니다.

740
00:16:27,110 --> 00:16:27,120
수정하기 위한 중간 단계입니다.
 

741
00:16:27,120 --> 00:16:28,629
수정하기 위한 중간 단계입니다.

742
00:16:28,629 --> 00:16:28,639

 

743
00:16:28,639 --> 00:16:30,310

여기서 오른쪽으로 회전하고,

744
00:16:30,310 --> 00:16:30,320
여기서 오른쪽으로 회전하고,
 

745
00:16:30,320 --> 00:16:31,829
여기서 오른쪽으로 회전하고,
여기서 왼쪽으로 회전합니다.

746
00:16:31,829 --> 00:16:31,839
여기서 왼쪽으로 회전합니다.
 

747
00:16:31,839 --> 00:16:33,829
여기서 왼쪽으로 회전합니다.
기본적으로는 왼쪽으로 회전하지만, 기울어진

748
00:16:33,829 --> 00:16:36,069
기본적으로는 왼쪽으로 회전하지만, 기울어진
 

749
00:16:36,069 --> 00:16:36,079

 

750
00:16:36,079 --> 00:16:38,629

방향이 잘못되었기 때문에 먼저

751
00:16:38,629 --> 00:16:38,639
방향이 잘못되었기 때문에 먼저
 

752
00:16:38,639 --> 00:16:39,110
방향이 잘못되었기 때문에 먼저

753
00:16:39,110 --> 00:16:39,120

 

754
00:16:39,120 --> 00:16:40,790

오른쪽으로 회전해야 합니다.

755
00:16:40,790 --> 00:16:40,800
오른쪽으로 회전해야 합니다.
 

756
00:16:40,800 --> 00:16:42,230
오른쪽으로 회전해야 합니다.
이제

757
00:16:42,230 --> 00:16:42,240
이제
 

758
00:16:42,240 --> 00:16:45,990
이제
이 모든 것을 오른쪽으로 회전하고

759
00:16:45,990 --> 00:16:46,000
이 모든 것을 오른쪽으로 회전하고
 

760
00:16:46,000 --> 00:16:49,269
이 모든 것을 오른쪽으로 회전하고
여기에 12, 여기에 8, 여기에 10을 넣습니다. 끝!

761
00:16:49,269 --> 00:16:52,870
여기에 12, 여기에 8, 여기에 10을 넣습니다. 끝!
 

762
00:16:52,870 --> 00:16:52,880

 

763
00:16:52,880 --> 00:16:54,550

모두 회전이 어떻게 되는지 보셨죠?

764
00:16:54,550 --> 00:16:56,550
모두 회전이 어떻게 되는지 보셨죠?
 

765
00:16:56,550 --> 00:16:58,710

 

766
00:16:58,710 --> 00:16:59,829

 

767
00:16:59,829 --> 00:16:59,839

 

768
00:16:59,839 --> 00:17:02,150

변환 과정을 이해하는 데 시간이 좀 걸렸지만, 모두 잘 따라오셨기를 바랍니다.

769
00:17:02,150 --> 00:17:03,670
변환 과정을 이해하는 데 시간이 좀 걸렸지만, 모두 잘 따라오셨기를 바랍니다.
 

770
00:17:03,670 --> 00:17:05,029

 

771
00:17:05,029 --> 00:17:05,039

 

772
00:17:05,039 --> 00:17:06,870

그림을 그리는 동안 약간의 마법이 있었거든요. 네,

773
00:17:06,870 --> 00:17:06,880
그림을 그리는 동안 약간의 마법이 있었거든요. 네,
 

774
00:17:06,880 --> 00:17:08,470
그림을 그리는 동안 약간의 마법이 있었거든요. 네,
저는 여전히 이 나무의

775
00:17:08,470 --> 00:17:08,480
저는 여전히 이 나무의
 

776
00:17:08,480 --> 00:17:10,870
저는 여전히 이 나무의
균형이 잘 맞지 않는 것 같아요.

777
00:17:10,870 --> 00:17:10,880
균형이 잘 맞지 않는 것 같아요.
 

778
00:17:10,880 --> 00:17:14,309
균형이 잘 맞지 않는 것 같아요.
관찰력이 좋지 않네요. 왜 이 부분의

779
00:17:14,309 --> 00:17:14,319
관찰력이 좋지 않네요. 왜 이 부분의
 

780
00:17:14,319 --> 00:17:15,590
관찰력이 좋지 않네요. 왜 이 부분의
높이가 여전히 3일까요?

781
00:17:15,590 --> 00:17:15,600
높이가 여전히 3일까요?
 

782
00:17:15,600 --> 00:17:18,150
높이가 여전히 3일까요?
이 부분의 높이는 1이죠.

783
00:17:18,150 --> 00:17:18,160
이 부분의 높이는 1이죠.
 

784
00:17:18,160 --> 00:17:18,789
이 부분의 높이는 1이죠.
맞아요, 이 부분의

785
00:17:18,789 --> 00:17:18,799
맞아요, 이 부분의
 

786
00:17:18,799 --> 00:17:21,350
맞아요, 이 부분의
높이는 1입니다. 그리고 실제로  회전 작업을

787
00:17:21,350 --> 00:17:21,360
높이는 1입니다. 그리고 실제로  회전 작업을
 

788
00:17:21,360 --> 00:17:23,270
높이는 1입니다. 그리고 실제로  회전 작업을
하면서

789
00:17:23,270 --> 00:17:23,280
하면서
 

790
00:17:23,280 --> 00:17:24,549
하면서
모든

791
00:17:24,549 --> 00:17:24,559
모든
 

792
00:17:24,559 --> 00:17:26,870
모든
증강 값을 업데이트해야 했는데,

793
00:17:26,870 --> 00:17:26,880
증강 값을 업데이트해야 했는데,
 

794
00:17:26,880 --> 00:17:28,549
증강 값을 업데이트해야 했는데,
어떤 증강 값을 업데이트해야 하는지,

795
00:17:28,549 --> 00:17:28,559
어떤 증강 값을 업데이트해야 하는지,
 

796
00:17:28,559 --> 00:17:30,549
어떤 증강 값을 업데이트해야 하는지,
어떤 서브트리가 변경되었는지 정확히

797
00:17:30,549 --> 00:17:36,230
어떤 서브트리가 변경되었는지 정확히
 

798
00:17:36,230 --> 00:17:36,240

 

799
00:17:36,240 --> 00:17:37,990

기억이 나지 않네요. 10번 노드의

800
00:17:37,990 --> 00:17:40,070
기억이 나지 않네요. 10번 노드의
 

801
00:17:40,070 --> 00:17:44,230

 

802
00:17:44,230 --> 00:17:44,240

 

803
00:17:44,240 --> 00:17:46,789

서브트리는 8개였으니 서브트리가 확실히 변경되었겠죠.

804
00:17:46,789 --> 00:17:46,799
서브트리는 8개였으니 서브트리가 확실히 변경되었겠죠.
 

805
00:17:46,799 --> 00:17:49,110
서브트리는 8개였으니 서브트리가 확실히 변경되었겠죠.
8번 노드의 서브트리가 변경되었고,

806
00:17:49,110 --> 00:17:49,120
8번 노드의 서브트리가 변경되었고,
 

807
00:17:49,120 --> 00:17:54,630
8번 노드의 서브트리가 변경되었고,
12번 노드는 변경되지 않았습니다. 자,

808
00:17:54,630 --> 00:17:57,029

 

809
00:17:57,029 --> 00:17:57,039

 

810
00:17:57,039 --> 00:17:58,310

강의 노트에 나와 있고 복습 시간에도 했던 사례 분석이 있죠? 거기에는 a,

811
00:17:58,310 --> 00:17:58,320
강의 노트에 나와 있고 복습 시간에도 했던 사례 분석이 있죠? 거기에는 a,
 

812
00:17:58,320 --> 00:17:59,510
강의 노트에 나와 있고 복습 시간에도 했던 사례 분석이 있죠? 거기에는 a,

813
00:17:59,510 --> 00:17:59,520

 

814
00:17:59,520 --> 00:18:02,710

b, c,

815
00:18:02,710 --> 00:18:02,720
b, c,
 

816
00:18:02,720 --> 00:18:06,070
b, c,
d 같은 서브트리가 있는데, 이런

817
00:18:06,070 --> 00:18:07,350
d 같은 서브트리가 있는데, 이런
 

818
00:18:07,350 --> 00:18:09,430

 

819
00:18:09,430 --> 00:18:11,909

 

820
00:18:11,909 --> 00:18:11,919

 

821
00:18:11,919 --> 00:18:13,669

고정 연산 중에 변경될 수 있는 서브트리는 변경되지 않습니다.

822
00:18:13,669 --> 00:18:13,679
고정 연산 중에 변경될 수 있는 서브트리는 변경되지 않습니다.
 

823
00:18:13,679 --> 00:18:15,590
고정 연산 중에 변경될 수 있는 서브트리는 변경되지 않습니다.
한두 번의 회전 작업을 할 때 서브트리가 변경되는 노드는

824
00:18:15,590 --> 00:18:15,600
한두 번의 회전 작업을 할 때 서브트리가 변경되는 노드는
 

825
00:18:15,600 --> 00:18:18,710
한두 번의 회전 작업을 할 때 서브트리가 변경되는 노드는
두 개 또는 세 개뿐입니다.

826
00:18:18,710 --> 00:18:18,720
두 개 또는 세 개뿐입니다.
 

827
00:18:18,720 --> 00:18:21,590
두 개 또는 세 개뿐입니다.
여기서는

828
00:18:21,590 --> 00:18:21,600
여기서는
 

829
00:18:21,600 --> 00:18:23,029
여기서는
세 개의

830
00:18:23,029 --> 00:18:23,039
세 개의
 

831
00:18:23,039 --> 00:18:26,630
세 개의
서브트리가 변경될 수도 있었지만,

832
00:18:26,630 --> 00:18:26,640
서브트리가 변경될 수도 있었지만,
 

833
00:18:26,640 --> 00:18:27,590
서브트리가 변경될 수도 있었지만,
간단한 경우에는 노트에 나와 있듯이

834
00:18:27,590 --> 00:18:27,600
간단한 경우에는 노트에 나와 있듯이
 

835
00:18:27,600 --> 00:18:30,310
간단한 경우에는 노트에 나와 있듯이
x와 y 두 노드만

836
00:18:30,310 --> 00:18:30,320
x와 y 두 노드만
 

837
00:18:30,320 --> 00:18:30,950
x와 y 두 노드만

838
00:18:30,950 --> 00:18:30,960

 

839
00:18:30,960 --> 00:18:33,110

변경될 수 있습니다. 그래서 저는

840
00:18:33,110 --> 00:18:35,270
변경될 수 있습니다. 그래서 저는
 

841
00:18:35,270 --> 00:18:37,270

 

842
00:18:37,270 --> 00:18:37,280

 

843
00:18:37,280 --> 00:18:39,110

자식 노드의 증강 값을 기반으로 해당 노드의 증강 값을 다시 계산해야 하는데,

844
00:18:39,110 --> 00:18:41,669
자식 노드의 증강 값을 기반으로 해당 노드의 증강 값을 다시 계산해야 하는데,
 

845
00:18:41,669 --> 00:18:41,679

 

846
00:18:41,679 --> 00:18:42,870

그 수는 일정하기 때문에 그냥 다시 계산하면 됩니다. 왜냐하면

847
00:18:42,870 --> 00:18:45,270
그 수는 일정하기 때문에 그냥 다시 계산하면 됩니다. 왜냐하면
 

848
00:18:45,270 --> 00:18:45,280

 

849
00:18:45,280 --> 00:18:46,470

제 아래에 있는 서브트리들이 있기 때문입니다.  바뀌지 않았죠?

850
00:18:46,470 --> 00:18:49,350
제 아래에 있는 서브트리들이 있기 때문입니다.  바뀌지 않았죠?
 

851
00:18:49,350 --> 00:18:49,360

 

852
00:18:49,360 --> 00:18:50,510


853
00:18:50,510 --> 00:18:50,520

 

854
00:18:50,520 --> 00:18:53,830

네, 여기 높이 불일치가 있네요. 8이 있어야 할 위치죠.

855
00:18:53,830 --> 00:18:56,870
네, 여기 높이 불일치가 있네요. 8이 있어야 할 위치죠.
 

856
00:18:56,870 --> 00:18:56,880

 

857
00:18:56,880 --> 00:19:00,870

원래 그림에서

858
00:19:00,870 --> 00:19:00,880
원래 그림에서
 

859
00:19:00,880 --> 00:19:03,190
원래 그림에서
12는 서브트리에

860
00:19:03,190 --> 00:19:03,200
12는 서브트리에
 

861
00:19:03,200 --> 00:19:03,990
12는 서브트리에

862
00:19:03,990 --> 00:19:04,000

 

863
00:19:04,000 --> 00:19:08,230

10과 8을 포함한 여러 노드가 있었는데, 방금 7을 삭제했잖아요.

864
00:19:08,230 --> 00:19:08,240
10과 8을 포함한 여러 노드가 있었는데, 방금 7을 삭제했잖아요.
 

865
00:19:08,240 --> 00:19:09,830
10과 8을 포함한 여러 노드가 있었는데, 방금 7을 삭제했잖아요.
그래서 서브트리가 확실히 바뀌었네요.

866
00:19:09,830 --> 00:19:09,840
그래서 서브트리가 확실히 바뀌었네요.
 

867
00:19:09,840 --> 00:19:11,909
그래서 서브트리가 확실히 바뀌었네요.
원래는 3개였는데...

868
00:19:11,909 --> 00:19:11,919
원래는 3개였는데...
 

869
00:19:11,919 --> 00:19:15,350
원래는 3개였는데...
아, 죄송합니다. 그랬네요. 네, 여기

870
00:19:15,350 --> 00:19:15,360
아, 죄송합니다. 그랬네요. 네, 여기
 

871
00:19:15,360 --> 00:19:18,789
아, 죄송합니다. 그랬네요. 네, 여기
3개의 노드 서브트리가

872
00:19:18,789 --> 00:19:21,029
3개의 노드 서브트리가
 

873
00:19:21,029 --> 00:19:21,990

 

874
00:19:21,990 --> 00:19:25,510

 

875
00:19:25,510 --> 00:19:26,470

 

876
00:19:26,470 --> 00:19:28,390

 

877
00:19:28,390 --> 00:19:28,400

 

878
00:19:28,400 --> 00:19:29,909

바뀌었지만, 사실 제가 보여드리는 건 최악의 경우일 뿐이에요. 이중 회전을 하면 서브트리가 바뀔 수 있는 노드는 최대 3개뿐이죠.

879
00:19:29,909 --> 00:19:30,870
바뀌었지만, 사실 제가 보여드리는 건 최악의 경우일 뿐이에요. 이중 회전을 하면 서브트리가 바뀔 수 있는 노드는 최대 3개뿐이죠.
 

880
00:19:30,870 --> 00:19:32,630

 

881
00:19:32,630 --> 00:19:32,640

 

882
00:19:32,640 --> 00:19:34,870

쉬운 경우에는 2

883
00:19:34,870 --> 00:19:34,880
쉬운 경우에는 2
 

884
00:19:34,880 --> 00:19:35,750
쉬운 경우에는 2
개만 바뀌면 되고요. 자, 이제

885
00:19:35,750 --> 00:19:35,760
개만 바뀌면 되고요. 자, 이제
 

886
00:19:35,760 --> 00:19:39,350
개만 바뀌면 되고요. 자, 이제
균형을

887
00:19:39,350 --> 00:19:39,360
균형을
 

888
00:19:39,360 --> 00:19:43,430
균형을
어떻게 맞출까요? 좀 심술궂게 굴 수도 있겠네요. 오른쪽으로

889
00:19:43,430 --> 00:19:46,630

 

890
00:19:46,630 --> 00:19:47,350

 

891
00:19:47,350 --> 00:19:47,360

 

892
00:19:47,360 --> 00:19:50,390

회전해서 균형을 맞출 수도 있겠죠. 두 노드를

893
00:19:50,390 --> 00:19:51,909
회전해서 균형을 맞출 수도 있겠죠. 두 노드를
 

894
00:19:51,909 --> 00:19:51,919

 

895
00:19:51,919 --> 00:19:53,190


896
00:19:53,190 --> 00:19:53,200

 

897
00:19:53,200 --> 00:19:55,990

바꿀 수도 있지만, 그렇게 하면

898
00:19:55,990 --> 00:19:57,750
바꿀 수도 있지만, 그렇게 하면
 

899
00:19:57,750 --> 00:19:57,760

 

900
00:19:57,760 --> 00:19:59,590

가운데 노드가 왼쪽 노드보다 더 무겁기 때문에 두 번 회전해야 할 거예요.

901
00:19:59,590 --> 00:20:00,150
가운데 노드가 왼쪽 노드보다 더 무겁기 때문에 두 번 회전해야 할 거예요.
 

902
00:20:00,150 --> 00:20:04,149

 

903
00:20:04,149 --> 00:20:04,159

 

904
00:20:04,159 --> 00:20:08,149

하지만 그렇게까지 심술궂게 굴고 싶진 않으니

905
00:20:08,149 --> 00:20:08,159
하지만 그렇게까지 심술궂게 굴고 싶진 않으니
 

906
00:20:08,159 --> 00:20:10,549
하지만 그렇게까지 심술궂게 굴고 싶진 않으니
오른쪽으로 회전할게요. 어떻게 하죠? 오른쪽으로

907
00:20:10,549 --> 00:20:10,559
오른쪽으로 회전할게요. 어떻게 하죠? 오른쪽으로
 

908
00:20:10,559 --> 00:20:11,350
오른쪽으로 회전할게요. 어떻게 하죠? 오른쪽으로
회전하면 됩니다.

909
00:20:11,350 --> 00:20:11,360
회전하면 됩니다.
 

910
00:20:11,360 --> 00:20:14,630
회전하면 됩니다.
6에서 이 모든 것을

911
00:20:14,630 --> 00:20:14,640
6에서 이 모든 것을
 

912
00:20:14,640 --> 00:20:17,590
6에서 이 모든 것을
4 아래로 가져와서 이

913
00:20:17,590 --> 00:20:17,600
4 아래로 가져와서 이
 

914
00:20:17,600 --> 00:20:18,310
4 아래로 가져와서 이
서브트리를

915
00:20:18,310 --> 00:20:18,320
서브트리를
 

916
00:20:18,320 --> 00:20:20,630
서브트리를
6의 왼쪽 자식으로 만들 거예요.

917
00:20:20,630 --> 00:20:20,640
6의 왼쪽 자식으로 만들 거예요.
 

918
00:20:20,640 --> 00:20:21,750
6의 왼쪽 자식으로 만들 거예요.
이해가 되나요?

919
00:20:21,750 --> 00:20:21,760
이해가 되나요?
 

920
00:20:21,760 --> 00:20:27,990
이해가 되나요?
으, 그림 그리기 재밌겠네요.

921
00:20:27,990 --> 00:20:28,000

 

922
00:20:28,000 --> 00:20:30,870

다시 그릴게요. 이제 좀

923
00:20:30,870 --> 00:20:30,880
다시 그릴게요. 이제 좀
 

924
00:20:30,880 --> 00:20:33,750
다시 그릴게요. 이제 좀
더 이해가 되죠? 음,

925
00:20:33,750 --> 00:20:33,760

 

926
00:20:33,760 --> 00:20:37,909

11, 3, 2, 1,

927
00:20:37,909 --> 00:20:37,919
11, 3, 2, 1,
 

928
00:20:37,919 --> 00:20:43,350
11, 3, 2, 1,
그리고 6, 5, 9, 8, 12,

929
00:20:43,350 --> 00:20:47,190

 

930
00:20:47,190 --> 00:20:51,990

 

931
00:20:51,990 --> 00:20:52,000

 

932
00:20:52,000 --> 00:20:55,350

10. 이게

933
00:20:55,350 --> 00:20:55,360
10. 이게
 

934
00:20:55,360 --> 00:21:00,230
10. 이게
6에서의 회전이에요. 모두 괜찮나요?

935
00:21:00,230 --> 00:21:00,240
6에서의 회전이에요. 모두 괜찮나요?
 

936
00:21:00,240 --> 00:21:04,630
6에서의 회전이에요. 모두 괜찮나요?
회전이요. 제 x는 6이고 y는 4

937
00:21:04,630 --> 00:21:04,640
회전이요. 제 x는 6이고 y는 4
 

938
00:21:04,640 --> 00:21:08,310
회전이요. 제 x는 6이고 y는 4
예요. a, b, c 서브트리가 있죠. 제가

939
00:21:08,310 --> 00:21:08,320
예요. a, b, c 서브트리가 있죠. 제가
 

940
00:21:08,320 --> 00:21:10,390
예요. a, b, c 서브트리가 있죠. 제가
하는 건

941
00:21:10,390 --> 00:21:10,400
하는 건
 

942
00:21:10,400 --> 00:21:11,350
하는 건

943
00:21:11,350 --> 00:21:11,360

 

944
00:21:11,360 --> 00:21:15,510

x와 y 중 어느 쪽이 루트가 될지 바꾸는 거예요.

945
00:21:15,510 --> 00:21:15,520
x와 y 중 어느 쪽이 루트가 될지 바꾸는 거예요.
 

946
00:21:15,520 --> 00:21:19,350
x와 y 중 어느 쪽이 루트가 될지 바꾸는 거예요.
이제 y가 루트가 되고,

947
00:21:19,350 --> 00:21:19,360
이제 y가 루트가 되고,
 

948
00:21:19,360 --> 00:21:22,870
이제 y가 루트가 되고,
b와 c 서브트리는 y 아래에 있는

949
00:21:22,870 --> 00:21:22,880
b와 c 서브트리는 y 아래에 있는
 

950
00:21:22,880 --> 00:21:24,470
b와 c 서브트리는 y 아래에 있는
x의 자식이 되는 거죠. 이

951
00:21:24,470 --> 00:21:27,270
x의 자식이 되는 거죠. 이
 

952
00:21:27,270 --> 00:21:27,280

 

953
00:21:27,280 --> 00:21:28,870

모든 과정에서

954
00:21:28,870 --> 00:21:28,880
모든 과정에서
 

955
00:21:28,880 --> 00:21:32,950
모든 과정에서
중위 순회는 변하지 않았다는 걸 알아차리셨나요?

956
00:21:32,950 --> 00:21:32,960
중위 순회는 변하지 않았다는 걸 알아차리셨나요?
 

957
00:21:32,960 --> 00:21:35,110
중위 순회는 변하지 않았다는 걸 알아차리셨나요?
중간에 증강을 업데이트해야 했지만,

958
00:21:35,110 --> 00:21:36,870
중간에 증강을 업데이트해야 했지만,
 

959
00:21:36,870 --> 00:21:36,880

 

960
00:21:36,880 --> 00:21:38,549

트리를 올라갈 때마다 상수가 유지돼요. 트리를 올라가는 횟수는 로그

961
00:21:38,549 --> 00:21:40,070
트리를 올라갈 때마다 상수가 유지돼요. 트리를 올라가는 횟수는 로그
 

962
00:21:40,070 --> 00:21:40,080

 

963
00:21:40,080 --> 00:21:42,549

함수적으로만 늘어나죠. 네, 맞아요.

964
00:21:42,549 --> 00:21:42,559
함수적으로만 늘어나죠. 네, 맞아요.
 

965
00:21:42,559 --> 00:21:45,830
함수적으로만 늘어나죠. 네, 맞아요.
회전을 할 때마다 다른 루틴을 실행하기 전에

966
00:21:45,830 --> 00:21:46,870
회전을 할 때마다 다른 루틴을 실행하기 전에
 

967
00:21:46,870 --> 00:21:46,880

 

968
00:21:46,880 --> 00:21:48,149

증강을 바로 업데이트하면 돼요.

969
00:21:48,149 --> 00:21:49,350
증강을 바로 업데이트하면 돼요.
 

970
00:21:49,350 --> 00:21:50,390

 

971
00:21:50,390 --> 00:21:50,400

 

972
00:21:50,400 --> 00:21:52,789

두 번째 부분은 문서 업데이트인데,

973
00:21:52,789 --> 00:21:53,830
두 번째 부분은 문서 업데이트인데,
 

974
00:21:53,830 --> 00:21:53,840

 

975
00:21:53,840 --> 00:21:56,950

카운트를 업데이트하는 걸 의미해요.  그리고 높이,

976
00:21:56,950 --> 00:21:56,960
카운트를 업데이트하는 걸 의미해요.  그리고 높이,
 

977
00:21:56,960 --> 00:21:58,630
카운트를 업데이트하는 걸 의미해요.  그리고 높이,
속성 같은 것들 말이죠. 네,

978
00:21:58,630 --> 00:21:58,640
속성 같은 것들 말이죠. 네,
 

979
00:21:58,640 --> 00:21:59,990
속성 같은 것들 말이죠. 네,
기본적으로 우리가

980
00:21:59,990 --> 00:22:02,630
기본적으로 우리가
 

981
00:22:02,630 --> 00:22:02,640

 

982
00:22:02,640 --> 00:22:03,669

어제 정의했던 건, 도메인 교수님께서 서브트리

983
00:22:03,669 --> 00:22:03,679
어제 정의했던 건, 도메인 교수님께서 서브트리
 

984
00:22:03,679 --> 00:22:05,830
어제 정의했던 건, 도메인 교수님께서 서브트리
속성이 뭔지 설명해 주셨잖아요. 서브트리 속성은 자식 노드들을

985
00:22:05,830 --> 00:22:07,029
속성이 뭔지 설명해 주셨잖아요. 서브트리 속성은 자식 노드들을
 

986
00:22:07,029 --> 00:22:09,990

 

987
00:22:09,990 --> 00:22:10,000

 

988
00:22:10,000 --> 00:22:12,390

보고 재귀적으로 계산할 수 있는 속성이에요.

989
00:22:12,390 --> 00:22:12,400
보고 재귀적으로 계산할 수 있는 속성이에요.
 

990
00:22:12,400 --> 00:22:14,390
보고 재귀적으로 계산할 수 있는 속성이에요.
자식 노드들의 확장 값을 재귀적으로 계산하는 거죠.

991
00:22:14,390 --> 00:22:16,149
자식 노드들의 확장 값을 재귀적으로 계산하는 거죠.
 

992
00:22:16,149 --> 00:22:16,159

 

993
00:22:16,159 --> 00:22:19,510

그러니까, 기존 확장 값을 그대로 사용하거나

994
00:22:19,510 --> 00:22:19,520
그러니까, 기존 확장 값을 그대로 사용하거나
 

995
00:22:19,520 --> 00:22:21,830
그러니까, 기존 확장 값을 그대로 사용하거나
로컬에서 어떻게 계산해야 할지 고민하는 대신,

996
00:22:21,830 --> 00:22:24,310
로컬에서 어떻게 계산해야 할지 고민하는 대신,
 

997
00:22:24,310 --> 00:22:24,320

 

998
00:22:24,320 --> 00:22:25,510

기존 확장 값을 버리고 자식 노드들을 이용해서

999
00:22:25,510 --> 00:22:25,520
기존 확장 값을 버리고 자식 노드들을 이용해서
 

1000
00:22:25,520 --> 00:22:27,909
기존 확장 값을 버리고 자식 노드들을 이용해서
다시 계산하는 거예요.

1001
00:22:27,909 --> 00:22:29,190
다시 계산하는 거예요.
 

1002
00:22:29,190 --> 00:22:31,830

 

1003
00:22:31,830 --> 00:22:32,710

 

1004
00:22:32,710 --> 00:22:35,110

 

1005
00:22:35,110 --> 00:22:35,120

 

1006
00:22:35,120 --> 00:22:38,390


1007
00:22:38,390 --> 00:22:41,270

 

1008
00:22:41,270 --> 00:22:41,280

 

1009
00:22:41,280 --> 00:22:43,270

자식 노드들의 확장 값이 재귀적으로 정확해야 하니까요. 이해되시죠? 네. 회전이 어떻게 작동하는지 보면, 기본적으로 4와 6을 바꾸는 거예요. 그러면 4가 부모 노드가 되고

1010
00:22:43,270 --> 00:22:43,280
자식 노드들의 확장 값이 재귀적으로 정확해야 하니까요. 이해되시죠? 네. 회전이 어떻게 작동하는지 보면, 기본적으로 4와 6을 바꾸는 거예요. 그러면 4가 부모 노드가 되고
 

1011
00:22:43,280 --> 00:22:43,909
자식 노드들의 확장 값이 재귀적으로 정확해야 하니까요. 이해되시죠? 네. 회전이 어떻게 작동하는지 보면, 기본적으로 4와 6을 바꾸는 거예요. 그러면 4가 부모 노드가 되고

1012
00:22:43,909 --> 00:22:43,919

 

1013
00:22:43,919 --> 00:22:47,270

6이 오른쪽 노드가 되는 거죠. 제가

1014
00:22:47,270 --> 00:22:47,280
6이 오른쪽 노드가 되는 거죠. 제가
 

1015
00:22:47,280 --> 00:22:50,390
6이 오른쪽 노드가 되는 거죠. 제가
그림을 그려서 보여드릴게요. 그냥

1016
00:22:50,390 --> 00:22:50,400
그림을 그려서 보여드릴게요. 그냥
 

1017
00:22:50,400 --> 00:22:52,870
그림을 그려서 보여드릴게요. 그냥
외워야 하는 건데,

1018
00:22:52,870 --> 00:22:52,880
외워야 하는 건데,
 

1019
00:22:52,880 --> 00:22:55,750
외워야 하는 건데,

1020
00:22:55,750 --> 00:22:55,760

 

1021
00:22:55,760 --> 00:22:58,560

이게 x, b,

1022
00:22:58,560 --> 00:22:58,570
이게 x, b,
 

1023
00:22:58,570 --> 00:23:00,390
이게 x, b,
[음악]

1024
00:23:00,390 --> 00:23:00,400
[음악]
 

1025
00:23:00,400 --> 00:23:03,590
[음악]
c, a예요.

1026
00:23:03,590 --> 00:23:03,600
c, a예요.
 

1027
00:23:03,600 --> 00:23:09,510
c, a예요.
그림 보이세요? 네,

1028
00:23:09,510 --> 00:23:09,520

 

1029
00:23:09,520 --> 00:23:11,510

노트에 있을 거예요. 별거 아니죠?

1030
00:23:11,510 --> 00:23:12,549
노트에 있을 거예요. 별거 아니죠?
 

1031
00:23:12,549 --> 00:23:12,559

 

1032
00:23:12,559 --> 00:23:15,830

하지만

1033
00:23:15,830 --> 00:23:15,840
하지만
 

1034
00:23:15,840 --> 00:23:18,870
하지만
x에 왼쪽 자식이 있고,

1035
00:23:18,870 --> 00:23:18,880
x에 왼쪽 자식이 있고,
 

1036
00:23:18,880 --> 00:23:20,950
x에 왼쪽 자식이 있고,
서브트리가 비어있든 아니든 상관없이,

1037
00:23:20,950 --> 00:23:23,029
서브트리가 비어있든 아니든 상관없이,
 

1038
00:23:23,029 --> 00:23:23,039

 

1039
00:23:23,039 --> 00:23:23,590


1040
00:23:23,590 --> 00:23:23,600

 

1041
00:23:23,600 --> 00:23:26,070

여기서 저기로 이동할 수 있다는 거예요. 중위

1042
00:23:26,070 --> 00:23:26,080
여기서 저기로 이동할 수 있다는 거예요. 중위
 

1043
00:23:26,080 --> 00:23:27,990
여기서 저기로 이동할 수 있다는 거예요. 중위
순서는 똑같아요.  순회 순서는

1044
00:23:27,990 --> 00:23:28,000
순서는 똑같아요.  순회 순서는
 

1045
00:23:28,000 --> 00:23:32,230
순서는 똑같아요.  순회 순서는
맞지만 모양이 다르고

1046
00:23:32,230 --> 00:23:32,240
맞지만 모양이 다르고
 

1047
00:23:32,240 --> 00:23:33,510
맞지만 모양이 다르고
특히 서브트리

1048
00:23:33,510 --> 00:23:33,520
특히 서브트리
 

1049
00:23:33,520 --> 00:23:36,149
특히 서브트리
높이가 바뀌었다는 것은

1050
00:23:36,149 --> 00:23:36,159
높이가 바뀌었다는 것은
 

1051
00:23:36,159 --> 00:23:37,590
높이가 바뀌었다는 것은
트리의 균형을 맞추는 데 도움이 된다는 뜻입니다. 이것이 바로

1052
00:23:37,590 --> 00:23:37,600
트리의 균형을 맞추는 데 도움이 된다는 뜻입니다. 이것이 바로
 

1053
00:23:37,600 --> 00:23:39,750
트리의 균형을 맞추는 데 도움이 된다는 뜻입니다. 이것이 바로
AVL의 핵심입니다. 이해되시죠? 이게 오른쪽 회전이고,

1054
00:23:39,750 --> 00:23:41,029
AVL의 핵심입니다. 이해되시죠? 이게 오른쪽 회전이고,
 

1055
00:23:41,029 --> 00:23:44,070

 

1056
00:23:44,070 --> 00:23:44,080

 

1057
00:23:44,080 --> 00:23:46,950

이게

1058
00:23:46,950 --> 00:23:46,960
이게
 

1059
00:23:46,960 --> 00:23:48,870
이게
왼쪽 회전입니다.

1060
00:23:48,870 --> 00:23:48,880
왼쪽 회전입니다.
 

1061
00:23:48,880 --> 00:23:58,070
왼쪽 회전입니다.
다른 질문 있으신가요?

1062
00:23:58,070 --> 00:23:58,080

 

1063
00:23:58,080 --> 00:24:01,110

트리를 올라가면서 각 노드마다

1064
00:24:01,110 --> 00:24:01,120
트리를 올라가면서 각 노드마다
 

1065
00:24:01,120 --> 00:24:03,510
트리를 올라가면서 각 노드마다
균형을 맞춰야 할 수도 있지만,

1066
00:24:03,510 --> 00:24:03,520
균형을 맞춰야 할 수도 있지만,
 

1067
00:24:03,520 --> 00:24:05,430
균형을 맞춰야 할 수도 있지만,
이 균형 맞추기 작업은 최대 두 번 회전합니다.

1068
00:24:05,430 --> 00:24:05,440
이 균형 맞추기 작업은 최대 두 번 회전합니다.
 

1069
00:24:05,440 --> 00:24:07,269
이 균형 맞추기 작업은 최대 두 번 회전합니다.

1070
00:24:07,269 --> 00:24:07,279

 

1071
00:24:07,279 --> 00:24:10,470

그리고 조상 노드는 최대 log n개입니다.

1072
00:24:10,470 --> 00:24:10,950
그리고 조상 노드는 최대 log n개입니다.
 

1073
00:24:10,950 --> 00:24:10,960

 

1074
00:24:10,960 --> 00:24:15,350

트리의 높이 균형이

1075
00:24:15,350 --> 00:24:15,360
트리의 높이 균형이
 

1076
00:24:15,360 --> 00:24:17,430
트리의 높이 균형이
2/2 log n 정도이기 때문입니다. 즉, 최대

1077
00:24:17,430 --> 00:24:17,440
2/2 log n 정도이기 때문입니다. 즉, 최대
 

1078
00:24:17,440 --> 00:24:18,950
2/2 log n 정도이기 때문입니다. 즉, 최대

1079
00:24:18,950 --> 00:24:21,909

 

1080
00:24:21,909 --> 00:24:21,919

 

1081
00:24:21,919 --> 00:24:22,390


1082
00:24:22,390 --> 00:24:22,400

 

1083
00:24:22,400 --> 00:24:25,029

4 log n번 회전하면 됩니다. 각 노드가

1084
00:24:25,029 --> 00:24:26,149
4 log n번 회전하면 됩니다. 각 노드가
 

1085
00:24:26,149 --> 00:24:26,159

 

1086
00:24:26,159 --> 00:24:28,310

두 번씩 회전할 수 있기 때문입니다. 이제 이해가 되시죠?

1087
00:24:28,310 --> 00:24:28,320
두 번씩 회전할 수 있기 때문입니다. 이제 이해가 되시죠?
 

1088
00:24:28,320 --> 00:24:30,230
두 번씩 회전할 수 있기 때문입니다. 이제 이해가 되시죠?
실제로

1089
00:24:30,230 --> 00:24:30,240
실제로
 

1090
00:24:30,240 --> 00:24:31,590
실제로
삭제 작업에서는 트리를 따라 로그

1091
00:24:31,590 --> 00:24:33,110
삭제 작업에서는 트리를 따라 로그
 

1092
00:24:33,110 --> 00:24:33,120

 

1093
00:24:33,120 --> 00:24:34,789

함수적인 횟수만큼 회전해야 할 수도 있다는 것을 증명할 수 있습니다.

1094
00:24:34,789 --> 00:24:35,269
함수적인 횟수만큼 회전해야 할 수도 있다는 것을 증명할 수 있습니다.
 

1095
00:24:35,269 --> 00:24:35,279

 

1096
00:24:35,279 --> 00:24:38,070

이것은 최악의 경우였고,

1097
00:24:38,070 --> 00:24:38,080
이것은 최악의 경우였고,
 

1098
00:24:38,080 --> 00:24:39,830
이것은 최악의 경우였고,
제가 드린 원래 트리는

1099
00:24:39,830 --> 00:24:39,840
제가 드린 원래 트리는
 

1100
00:24:39,840 --> 00:24:40,870
제가 드린 원래 트리는
피보나치 트리라고 합니다.

1101
00:24:40,870 --> 00:24:43,909
피보나치 트리라고 합니다.
 

1102
00:24:43,909 --> 00:24:43,919

 

1103
00:24:43,919 --> 00:24:45,990

높이 균형이 가장 잘 잡힌 트리 중 하나입니다.

1104
00:24:45,990 --> 00:24:46,000
높이 균형이 가장 잘 잡힌 트리 중 하나입니다.
 

1105
00:24:46,000 --> 00:24:48,470
높이 균형이 가장 잘 잡힌 트리 중 하나입니다.
주어진 노드 수, 음, 그게 다

1106
00:24:48,470 --> 00:24:52,549
주어진 노드 수, 음, 그게 다
 

1107
00:24:52,549 --> 00:24:52,559

 

1108
00:24:52,559 --> 00:24:54,390

예요. 특정 높이에 대한 최소 노드 수를 말하는 거죠.

1109
00:24:54,390 --> 00:24:54,400
예요. 특정 높이에 대한 최소 노드 수를 말하는 거죠.
 

1110
00:24:54,400 --> 00:24:56,230
예요. 특정 높이에 대한 최소 노드 수를 말하는 거죠.
어떻게 생각하든 상관없고,

1111
00:24:56,230 --> 00:24:56,240
어떻게 생각하든 상관없고,
 

1112
00:24:56,240 --> 00:24:56,710
어떻게 생각하든 상관없고,

1113
00:24:56,710 --> 00:24:56,720

 

1114
00:24:56,720 --> 00:24:58,310

그걸 충분히 큰 규모로 일반화하면

1115
00:24:58,310 --> 00:24:58,320
그걸 충분히 큰 규모로 일반화하면
 

1116
00:24:58,320 --> 00:25:00,390
그걸 충분히 큰 규모로 일반화하면
그 규모는...

1117
00:25:00,390 --> 00:25:02,630
그 규모는...
 

1118
00:25:02,630 --> 00:25:02,640

 

1119
00:25:02,640 --> 00:25:05,269

실제로 삽입 작업의 경우 회전 횟수가 로그 함수적으로 증가합니다.

1120
00:25:05,269 --> 00:25:06,710
실제로 삽입 작업의 경우 회전 횟수가 로그 함수적으로 증가합니다.
 

1121
00:25:06,710 --> 00:25:08,870

 

1122
00:25:08,870 --> 00:25:08,880

 

1123
00:25:08,880 --> 00:25:11,110

삽입 작업은 항상

1124
00:25:11,110 --> 00:25:11,120
삽입 작업은 항상
 

1125
00:25:11,120 --> 00:25:13,590
삽입 작업은 항상
한 번의 재균형 작업 후에 트리의 균형을 맞추는데, 이

1126
00:25:13,590 --> 00:25:13,600
한 번의 재균형 작업 후에 트리의 균형을 맞추는데, 이
 

1127
00:25:13,600 --> 00:25:15,669
한 번의 재균형 작업 후에 트리의 균형을 맞추는데, 이
재균형 작업에는

1128
00:25:15,669 --> 00:25:15,679
재균형 작업에는
 

1129
00:25:15,679 --> 00:25:17,190
재균형 작업에는
두 번의 회전이 포함될 수 있습니다. 이해되시나요?

1130
00:25:17,190 --> 00:25:27,190
두 번의 회전이 포함될 수 있습니다. 이해되시나요?
 

1131
00:25:27,190 --> 00:25:29,430

 

1132
00:25:29,430 --> 00:25:30,710

 

1133
00:25:30,710 --> 00:25:30,720

 

1134
00:25:30,720 --> 00:25:34,149


1135
00:25:34,149 --> 00:25:36,630

 

1136
00:25:36,630 --> 00:25:37,269

 

1137
00:25:37,269 --> 00:25:40,630

 

1138
00:25:40,630 --> 00:25:42,950

 

1139
00:25:42,950 --> 00:25:42,960

 

1140
00:25:42,960 --> 00:25:43,669


1141
00:25:43,669 --> 00:25:43,679

 

1142
00:25:43,679 --> 00:25:46,070

네, 그래서 오른쪽 회전에서 이 노드는 오른쪽 자식이 됩니다. 자식이 있는지 여부에 따라 달라지죠. 왼쪽 서브트리가 없으면 오른쪽 회전을 수행할 수 없습니다. 따라서 오른쪽 회전을 하려면

1143
00:25:46,070 --> 00:25:46,080
네, 그래서 오른쪽 회전에서 이 노드는 오른쪽 자식이 됩니다. 자식이 있는지 여부에 따라 달라지죠. 왼쪽 서브트리가 없으면 오른쪽 회전을 수행할 수 없습니다. 따라서 오른쪽 회전을 하려면
 

1144
00:25:46,080 --> 00:25:47,590
네, 그래서 오른쪽 회전에서 이 노드는 오른쪽 자식이 됩니다. 자식이 있는지 여부에 따라 달라지죠. 왼쪽 서브트리가 없으면 오른쪽 회전을 수행할 수 없습니다. 따라서 오른쪽 회전을 하려면
왼쪽 자식이 있어야 합니다.

1145
00:25:47,590 --> 00:25:48,390
왼쪽 자식이 있어야 합니다.
 

1146
00:25:48,390 --> 00:25:48,400

 

1147
00:25:48,400 --> 00:25:50,710

코드를 보면

1148
00:25:50,710 --> 00:25:50,720
코드를 보면
 

1149
00:25:50,720 --> 00:25:52,710
코드를 보면
왼쪽 자식이 있는지 확인하는 부분이 있습니다. 이 부분은 회전 작업을 수행하기

1150
00:25:52,710 --> 00:25:57,510
왼쪽 자식이 있는지 확인하는 부분이 있습니다. 이 부분은 회전 작업을 수행하기
 

1151
00:25:57,510 --> 00:25:59,510

 

1152
00:25:59,510 --> 00:25:59,520

 

1153
00:25:59,520 --> 00:26:00,950

전에 실행해야 하는 어설션입니다.

1154
00:26:00,950 --> 00:26:02,870
전에 실행해야 하는 어설션입니다.
 

1155
00:26:02,870 --> 00:26:02,880

 

1156
00:26:02,880 --> 00:26:06,230

삽입은

1157
00:26:06,230 --> 00:26:06,240
삽입은
 

1158
00:26:06,240 --> 00:26:06,870
삽입은

1159
00:26:06,870 --> 00:26:06,880

 

1160
00:26:06,880 --> 00:26:10,070

최대 두 번의 회전으로 일정한

1161
00:26:10,070 --> 00:26:10,080
최대 두 번의 회전으로 일정한
 

1162
00:26:10,080 --> 00:26:11,430
최대 두 번의 회전으로 일정한
회전 횟수를 달성할 수 있지만, 삭제는

1163
00:26:11,430 --> 00:26:11,440
회전 횟수를 달성할 수 있지만, 삭제는
 

1164
00:26:11,440 --> 00:26:12,710
회전 횟수를 달성할 수 있지만, 삭제는
로그 함수적인

1165
00:26:12,710 --> 00:26:12,720
로그 함수적인
 

1166
00:26:12,720 --> 00:26:14,390
로그 함수적인
파티션 수만큼 회전이 필요할 수 있습니다. 이건

1167
00:26:14,390 --> 00:26:14,400
파티션 수만큼 회전이 필요할 수 있습니다. 이건
 

1168
00:26:14,400 --> 00:26:16,070
파티션 수만큼 회전이 필요할 수 있습니다. 이건
여러분이 알아야 할 내용은 아니고,

1169
00:26:16,070 --> 00:26:16,080
여러분이 알아야 할 내용은 아니고,
 

1170
00:26:16,080 --> 00:26:17,669
여러분이 알아야 할 내용은 아니고,
제가 여기서 증명하려는 것도 아닙니다. 그냥

1171
00:26:17,669 --> 00:26:18,630
제가 여기서 증명하려는 것도 아닙니다. 그냥
 

1172
00:26:18,630 --> 00:26:20,950

 

1173
00:26:20,950 --> 00:26:20,960

 

1174
00:26:20,960 --> 00:26:22,549

흥미로운 점일 뿐입니다.

1175
00:26:22,549 --> 00:26:23,750
흥미로운 점일 뿐입니다.
 

1176
00:26:23,750 --> 00:26:23,760

 

1177
00:26:23,760 --> 00:26:27,029

트리의 균형을 맞추는 방식에는 여러 가지가 있습니다.  균형을

1178
00:26:27,029 --> 00:26:27,039
트리의 균형을 맞추는 방식에는 여러 가지가 있습니다.  균형을
 

1179
00:26:27,039 --> 00:26:30,149
트리의 균형을 맞추는 방식에는 여러 가지가 있습니다.  균형을
도입하기 위해 레드 블랙 트리를 소개하겠습니다.

1180
00:26:30,149 --> 00:26:30,159
도입하기 위해 레드 블랙 트리를 소개하겠습니다.
 

1181
00:26:30,159 --> 00:26:31,190
도입하기 위해 레드 블랙 트리를 소개하겠습니다.

1182
00:26:31,190 --> 00:26:31,200

 

1183
00:26:31,200 --> 00:26:32,870

이 트리는 실제로

1184
00:26:32,870 --> 00:26:34,710
이 트리는 실제로
 

1185
00:26:34,710 --> 00:26:37,590

 

1186
00:26:37,590 --> 00:26:38,390

 

1187
00:26:38,390 --> 00:26:38,400

 

1188
00:26:38,400 --> 00:26:41,669

AVL 트리처럼 높이 균형이 엄격하지 않고, 오른쪽으로 치우친 기울기를 허용하기

1189
00:26:41,669 --> 00:26:41,679
AVL 트리처럼 높이 균형이 엄격하지 않고, 오른쪽으로 치우친 기울기를 허용하기
 

1190
00:26:41,679 --> 00:26:44,950
AVL 트리처럼 높이 균형이 엄격하지 않고, 오른쪽으로 치우친 기울기를 허용하기
때문에 제약 조건이 약합니다. 이러한 약한

1191
00:26:44,950 --> 00:26:44,960
때문에 제약 조건이 약합니다. 이러한 약한
 

1192
00:26:44,960 --> 00:26:46,470
때문에 제약 조건이 약합니다. 이러한 약한
제약 조건 덕분에

1193
00:26:46,470 --> 00:26:48,549
제약 조건 덕분에
 

1194
00:26:48,549 --> 00:26:50,710

 

1195
00:26:50,710 --> 00:26:53,510

 

1196
00:26:53,510 --> 00:26:53,520

 

1197
00:26:53,520 --> 00:26:54,230

트리를 수정하기 전에 필요한 만큼의 회전만 수행할 수 있습니다.

1198
00:26:54,230 --> 00:26:54,240
트리를 수정하기 전에 필요한 만큼의 회전만 수행할 수 있습니다.
 

1199
00:26:54,240 --> 00:26:55,669
트리를 수정하기 전에 필요한 만큼의 회전만 수행할 수 있습니다.
조금 더

1200
00:26:55,669 --> 00:26:55,679
조금 더
 

1201
00:26:55,679 --> 00:27:00,549
조금 더
복잡하지만 좋습니다.

1202
00:27:00,549 --> 00:27:00,559

 

1203
00:27:00,559 --> 00:27:05,909

질문 있으신가요? 자,

1204
00:27:05,909 --> 00:27:05,919
질문 있으신가요? 자,
 

1205
00:27:05,919 --> 00:27:06,710
질문 있으신가요? 자,

1206
00:27:06,710 --> 00:27:06,720

 

1207
00:27:06,720 --> 00:27:08,950

이제 이것은

1208
00:27:08,950 --> 00:27:10,230
이제 이것은
 

1209
00:27:10,230 --> 00:27:10,240

 

1210
00:27:10,240 --> 00:27:11,909

문제 세트에서 접하게 될 기계적인 문제이고, 이제

1211
00:27:11,909 --> 00:27:13,669
문제 세트에서 접하게 될 기계적인 문제이고, 이제
 

1212
00:27:13,669 --> 00:27:13,679

 

1213
00:27:13,679 --> 00:27:16,149

이론적인 문제로 넘어가겠습니다. 이것들은

1214
00:27:16,149 --> 00:27:16,159
이론적인 문제로 넘어가겠습니다. 이것들은
 

1215
00:27:16,159 --> 00:27:18,789
이론적인 문제로 넘어가겠습니다. 이것들은
환원형 문제입니다.

1216
00:27:18,789 --> 00:27:18,799
환원형 문제입니다.
 

1217
00:27:18,799 --> 00:27:22,149
환원형 문제입니다.
첫 번째 문제는 닉 퓨리입니다.

1218
00:27:22,149 --> 00:27:25,750
첫 번째 문제는 닉 퓨리입니다.
 

1219
00:27:25,750 --> 00:27:29,669

 

1220
00:27:29,669 --> 00:27:29,679

 

1221
00:27:29,679 --> 00:27:32,230

어벤져스 관련 문제죠. 기본적으로

1222
00:27:32,230 --> 00:27:32,240
어벤져스 관련 문제죠. 기본적으로
 

1223
00:27:32,240 --> 00:27:33,990
어벤져스 관련 문제죠. 기본적으로
이 문제에서 그는

1224
00:27:33,990 --> 00:27:34,870
이 문제에서 그는
 

1225
00:27:34,870 --> 00:27:34,880

 

1226
00:27:34,880 --> 00:27:39,430

슈퍼히어로 목록을 가지고 있는데, 각 슈퍼히어로는 산타와 싸워야 할지 말지에 대한 의견을 가지고 있습니다.

1227
00:27:39,430 --> 00:27:42,389
슈퍼히어로 목록을 가지고 있는데, 각 슈퍼히어로는 산타와 싸워야 할지 말지에 대한 의견을 가지고 있습니다.
 

1228
00:27:42,389 --> 00:27:42,399

 

1229
00:27:42,399 --> 00:27:43,830


1230
00:27:43,830 --> 00:27:43,840

 

1231
00:27:43,840 --> 00:27:47,350

그들의 의견은

1232
00:27:47,350 --> 00:27:47,360
그들의 의견은
 

1233
00:27:47,360 --> 00:27:49,510
그들의 의견은
매우 긍정적일 수도 있고 매우

1234
00:27:49,510 --> 00:27:49,520
매우 긍정적일 수도 있고 매우
 

1235
00:27:49,520 --> 00:27:50,549
매우 긍정적일 수도 있고 매우
부정적일 수도 있습니다.

1236
00:27:50,549 --> 00:27:50,559
부정적일 수도 있습니다.
 

1237
00:27:50,559 --> 00:27:54,230
부정적일 수도 있습니다.
퓨리는

1238
00:27:54,230 --> 00:27:54,240
퓨리는
 

1239
00:27:54,240 --> 00:27:55,830
퓨리는
자신의 복수자들 중에서 어떤 의견을 가지고 있는지, 즉

1240
00:27:55,830 --> 00:27:59,590
자신의 복수자들 중에서 어떤 의견을 가지고 있는지, 즉
 

1241
00:27:59,590 --> 00:27:59,600

 

1242
00:27:59,600 --> 00:28:02,950

로그를 찾는 것입니다.  가장 극단적인

1243
00:28:02,950 --> 00:28:02,960
로그를 찾는 것입니다.  가장 극단적인
 

1244
00:28:02,960 --> 00:28:04,950
로그를 찾는 것입니다.  가장 극단적인
의견을 가진 복수자들을 찾아서

1245
00:28:04,950 --> 00:28:04,960
의견을 가진 복수자들을 찾아서
 

1246
00:28:04,960 --> 00:28:06,549
의견을 가진 복수자들을 찾아서
대화하는 겁니다. 모든 사람과 대화하고 싶어하는 게 아니라, 로그 n개의 사람들과 대화하고 싶어하는 거죠. 뭐, 어쨌든 그렇습니다.

1247
00:28:06,549 --> 00:28:08,470
대화하는 겁니다. 모든 사람과 대화하고 싶어하는 게 아니라, 로그 n개의 사람들과 대화하고 싶어하는 거죠. 뭐, 어쨌든 그렇습니다.
 

1248
00:28:08,470 --> 00:28:10,789

 

1249
00:28:10,789 --> 00:28:12,230

 

1250
00:28:12,230 --> 00:28:12,240

 

1251
00:28:12,240 --> 00:28:15,430

그래서 기본적으로

1252
00:28:15,430 --> 00:28:15,440
그래서 기본적으로
 

1253
00:28:15,440 --> 00:28:18,710
그래서 기본적으로
우리는 기밀 상황에 놓여 있는데,

1254
00:28:18,710 --> 00:28:18,720
우리는 기밀 상황에 놓여 있는데,
 

1255
00:28:18,720 --> 00:28:21,510
우리는 기밀 상황에 놓여 있는데,
읽기 전용 입력

1256
00:28:21,510 --> 00:28:21,520
읽기 전용 입력
 

1257
00:28:21,520 --> 00:28:22,630
읽기 전용 입력
데이터로

1258
00:28:22,630 --> 00:28:22,640
데이터로
 

1259
00:28:22,640 --> 00:28:26,789
데이터로
배열에 저장된 이러한 의견들을 찾아야 합니다. 저는

1260
00:28:26,789 --> 00:28:30,149
배열에 저장된 이러한 의견들을 찾아야 합니다. 저는
 

1261
00:28:30,149 --> 00:28:30,159

 

1262
00:28:30,159 --> 00:28:32,710

가장 강한 의견을 가진 log n개의 의견을 가진 사람들을 찾고 싶습니다.

1263
00:28:32,710 --> 00:28:32,720
가장 강한 의견을 가진 log n개의 의견을 가진 사람들을 찾고 싶습니다.
 

1264
00:28:32,720 --> 00:28:33,990
가장 강한 의견을 가진 log n개의 의견을 가진 사람들을 찾고 싶습니다.
이해가 되시나요?

1265
00:28:33,990 --> 00:28:34,000
이해가 되시나요?
 

1266
00:28:34,000 --> 00:28:35,350
이해가 되시나요?
그리고 이

1267
00:28:35,350 --> 00:28:35,360
그리고 이
 

1268
00:28:35,360 --> 00:28:38,470
그리고 이
문제를 선형 시간 안에 풀어야 합니다.

1269
00:28:38,470 --> 00:28:40,070
문제를 선형 시간 안에 풀어야 합니다.
 

1270
00:28:40,070 --> 00:28:40,080

 

1271
00:28:40,080 --> 00:28:42,630

아직 이 문제를 어떻게 푸는지 모르시겠지만,

1272
00:28:42,630 --> 00:28:44,870

 

1273
00:28:44,870 --> 00:28:45,750

 

1274
00:28:45,750 --> 00:28:49,110

 

1275
00:28:49,110 --> 00:28:49,120

 

1276
00:28:49,120 --> 00:28:51,430

046 강의에서 배우는 내용을 통해 알게 될 겁니다. 지금은 그 방법을 알려드릴 게 아니라,

1277
00:28:51,430 --> 00:28:54,389
046 강의에서 배우는 내용을 통해 알게 될 겁니다. 지금은 그 방법을 알려드릴 게 아니라,
 

1278
00:28:54,389 --> 00:28:55,909

 

1279
00:28:55,909 --> 00:28:55,919

 

1280
00:28:55,919 --> 00:28:58,950

화요일에 다른 방법을 알려드리겠습니다.

1281
00:28:58,950 --> 00:28:58,960
화요일에 다른 방법을 알려드리겠습니다.
 

1282
00:28:58,960 --> 00:29:01,269
화요일에 다른 방법을 알려드리겠습니다.
바로 이진 힙을 이용하는 방법입니다. 이진 힙은

1283
00:29:01,269 --> 00:29:03,830
바로 이진 힙을 이용하는 방법입니다. 이진 힙은
 

1284
00:29:03,830 --> 00:29:10,149

 

1285
00:29:10,149 --> 00:29:10,159

 

1286
00:29:10,159 --> 00:29:14,230

Set 인터페이스의 일부를 구현하는 흥미로운 개념입니다. 간단히 말해서,

1287
00:29:14,230 --> 00:29:20,389
Set 인터페이스의 일부를 구현하는 흥미로운 개념입니다. 간단히 말해서,
 

1288
00:29:20,389 --> 00:29:20,399

 

1289
00:29:20,399 --> 00:29:23,669

반복 가능한 객체 x를 기반으로 구축할 수 있습니다. x는

1290
00:29:23,669 --> 00:29:23,679
반복 가능한 객체 x를 기반으로 구축할 수 있습니다. x는
 

1291
00:29:23,679 --> 00:29:25,510
반복 가능한 객체 x를 기반으로 구축할 수 있습니다. x는
여러 항목을 수집하고, 각 항목에는

1292
00:29:25,510 --> 00:29:25,520
여러 항목을 수집하고, 각 항목에는
 

1293
00:29:25,520 --> 00:29:27,110
여러 항목을 수집하고, 각 항목에는
키가 있습니다. 키

1294
00:29:27,110 --> 00:29:27,120
키가 있습니다. 키
 

1295
00:29:27,120 --> 00:29:29,190
키가 있습니다. 키
데이터 구조인 셈이죠.  마찬가지로 우선

1296
00:29:29,190 --> 00:29:29,200
데이터 구조인 셈이죠.  마찬가지로 우선
 

1297
00:29:29,200 --> 00:29:31,190
데이터 구조인 셈이죠.  마찬가지로 우선
순위

1298
00:29:31,190 --> 00:29:31,200
순위
 

1299
00:29:31,200 --> 00:29:33,750
순위
큐 인터페이스라고 부르는 것을 구현하고 있습니다. 이런 것들을 만들고,

1300
00:29:33,750 --> 00:29:33,760
큐 인터페이스라고 부르는 것을 구현하고 있습니다. 이런 것들을 만들고,
 

1301
00:29:33,760 --> 00:29:37,430
큐 인터페이스라고 부르는 것을 구현하고 있습니다. 이런 것들을 만들고,
요소를 삽입할 수도 있지만,

1302
00:29:37,430 --> 00:29:37,440
요소를 삽입할 수도 있지만,
 

1303
00:29:37,440 --> 00:29:39,590
요소를 삽입할 수도 있지만,
여기서는 그럴 필요가 없습니다.

1304
00:29:39,590 --> 00:29:39,600
여기서는 그럴 필요가 없습니다.
 

1305
00:29:39,600 --> 00:29:42,549
여기서는 그럴 필요가 없습니다.
이

1306
00:29:42,549 --> 00:29:42,559
이
 

1307
00:29:42,559 --> 00:29:46,389
이
상황에서 필요한 것은 삭제, 즉 최상위

1308
00:29:46,389 --> 00:29:46,399
상황에서 필요한 것은 삭제, 즉 최상위
 

1309
00:29:46,399 --> 00:29:47,990
상황에서 필요한 것은 삭제, 즉 최상위
연산입니다.

1310
00:29:47,990 --> 00:29:48,000
연산입니다.
 

1311
00:29:48,000 --> 00:29:53,269
연산입니다.
아마도 `max delete

1312
00:29:53,269 --> 00:29:53,279
아마도 `max delete
 

1313
00:29:53,279 --> 00:29:56,870
아마도 `max delete
max`가 될 것입니다. 자,

1314
00:29:56,870 --> 00:29:56,880

 

1315
00:29:56,880 --> 00:29:59,190

이것은 일종의 데이터

1316
00:29:59,190 --> 00:29:59,200
이것은 일종의 데이터
 

1317
00:29:59,200 --> 00:30:00,470
이것은 일종의 데이터
구조입니다. 제가

1318
00:30:00,470 --> 00:30:00,480
구조입니다. 제가
 

1319
00:30:00,480 --> 00:30:01,990
구조입니다. 제가
이것들을 '우선순위'라고 부르는 것이죠.

1320
00:30:01,990 --> 00:30:02,000
이것들을 '우선순위'라고 부르는 것이죠.
 

1321
00:30:02,000 --> 00:30:04,070
이것들을 '우선순위'라고 부르는 것이죠.
이해가 되시나요? 네, 우선순위

1322
00:30:04,070 --> 00:30:04,080
이해가 되시나요? 네, 우선순위
 

1323
00:30:04,080 --> 00:30:05,830
이해가 되시나요? 네, 우선순위
큐입니다. 우선순위 큐는 기본적으로

1324
00:30:05,830 --> 00:30:05,840
큐입니다. 우선순위 큐는 기본적으로
 

1325
00:30:05,840 --> 00:30:07,350
큐입니다. 우선순위 큐는 기본적으로
이 두 가지 기능을 구현하는 것입니다.

1326
00:30:07,350 --> 00:30:07,360
이 두 가지 기능을 구현하는 것입니다.
 

1327
00:30:07,360 --> 00:30:08,389
이 두 가지 기능을 구현하는 것입니다.

1328
00:30:08,389 --> 00:30:08,399

 

1329
00:30:08,399 --> 00:30:09,750

사실 세 번째 기능도 있는데,

1330
00:30:09,750 --> 00:30:09,760
사실 세 번째 기능도 있는데,
 

1331
00:30:09,760 --> 00:30:11,750
사실 세 번째 기능도 있는데,
새로운 요소를 삽입하는 기능입니다. 하지만

1332
00:30:11,750 --> 00:30:11,760
새로운 요소를 삽입하는 기능입니다. 하지만
 

1333
00:30:11,760 --> 00:30:13,029
새로운 요소를 삽입하는 기능입니다. 하지만
지금은 필요하지 않습니다. 이것이 우선

1334
00:30:13,029 --> 00:30:13,039
지금은 필요하지 않습니다. 이것이 우선
 

1335
00:30:13,039 --> 00:30:14,630
지금은 필요하지 않습니다. 이것이 우선
순위 큐입니다. 그리고

1336
00:30:14,630 --> 00:30:14,640
순위 큐입니다. 그리고
 

1337
00:30:14,640 --> 00:30:16,950
순위 큐입니다. 그리고
집합(Set)은 집합 인터페이스의 하위 집합입니다.

1338
00:30:16,950 --> 00:30:16,960
집합(Set)은 집합 인터페이스의 하위 집합입니다.
 

1339
00:30:16,960 --> 00:30:17,430
집합(Set)은 집합 인터페이스의 하위 집합입니다.

1340
00:30:17,430 --> 00:30:20,789

 

1341
00:30:20,789 --> 00:30:20,799

 

1342
00:30:20,799 --> 00:30:21,269


1343
00:30:21,269 --> 00:30:21,279

 

1344
00:30:21,279 --> 00:30:23,510

힙의 장점은 (구현 방법은 보여드리지 않겠지만)

1345
00:30:23,510 --> 00:30:23,520
힙의 장점은 (구현 방법은 보여드리지 않겠지만)
 

1346
00:30:23,520 --> 00:30:24,310
힙의 장점은 (구현 방법은 보여드리지 않겠지만)

1347
00:30:24,310 --> 00:30:24,320

 

1348
00:30:24,320 --> 00:30:27,590

힙이 할 수 있는 것들입니다.

1349
00:30:27,590 --> 00:30:27,600
힙이 할 수 있는 것들입니다.
 

1350
00:30:27,600 --> 00:30:29,190
힙이 할 수 있는 것들입니다.
만약 이 두 가지 연산을

1351
00:30:29,190 --> 00:30:30,789
만약 이 두 가지 연산을
 

1352
00:30:30,789 --> 00:30:30,799

 

1353
00:30:30,799 --> 00:30:34,070

집합 AVL 트리를 사용하여 구현한다면, 이 작업들을 수행하는 데 얼마나 걸릴까요?

1354
00:30:34,070 --> 00:30:41,269
집합 AVL 트리를 사용하여 구현한다면, 이 작업들을 수행하는 데 얼마나 걸릴까요?
 

1355
00:30:41,269 --> 00:30:41,279

 

1356
00:30:41,279 --> 00:30:43,110

집합 AVL 트리를 구축

1357
00:30:43,110 --> 00:30:43,120
집합 AVL 트리를 구축
 

1358
00:30:43,120 --> 00:30:46,870
집합 AVL 트리를 구축

1359
00:30:46,870 --> 00:30:46,880

 

1360
00:30:46,880 --> 00:30:49,669

하고 로그인하는 데 얼마나 걸릴까요? 기본적으로 저는

1361
00:30:49,669 --> 00:30:49,679
하고 로그인하는 데 얼마나 걸릴까요? 기본적으로 저는
 

1362
00:30:49,679 --> 00:30:51,669
하고 로그인하는 데 얼마나 걸릴까요? 기본적으로 저는
이 구조를 통해 정렬된 순서를 얻고 있습니다.

1363
00:30:51,669 --> 00:30:51,679
이 구조를 통해 정렬된 순서를 얻고 있습니다.
 

1364
00:30:51,679 --> 00:30:53,350
이 구조를 통해 정렬된 순서를 얻고 있습니다.
요소를 하나씩 삽입하든,

1365
00:30:53,350 --> 00:30:55,110
요소를 하나씩 삽입하든,
 

1366
00:30:55,110 --> 00:30:55,120

 

1367
00:30:55,120 --> 00:30:57,190

아니면...  정렬한 다음

1368
00:30:57,190 --> 00:30:57,200
아니면...  정렬한 다음
 

1369
00:30:57,200 --> 00:30:59,750
아니면...  정렬한 다음
트리 구조에 넣는 데는 며칠 전 강의에서 봤듯이 선형 시간 안에 할 수 있지만, 결국

1370
00:30:59,750 --> 00:31:03,509
트리 구조에 넣는 데는 며칠 전 강의에서 봤듯이 선형 시간 안에 할 수 있지만, 결국
 

1371
00:31:03,509 --> 00:31:03,519

 

1372
00:31:03,519 --> 00:31:05,350

정렬을 해야 하잖아요? 정렬 순서(순서대로

1373
00:31:05,350 --> 00:31:07,190
정렬을 해야 하잖아요? 정렬 순서(순서대로
 

1374
00:31:07,190 --> 00:31:09,909

 

1375
00:31:09,909 --> 00:31:09,919

 

1376
00:31:09,919 --> 00:31:10,710


1377
00:31:10,710 --> 00:31:12,630

 

1378
00:31:12,630 --> 00:31:12,640

 

1379
00:31:12,640 --> 00:31:14,470

반환하는 데 걸리는 시간)를 선형 시간 안에 반환하려면 최소한 n log n 시간은 걸려야 합니다.

1380
00:31:14,470 --> 00:31:14,480
반환하는 데 걸리는 시간)를 선형 시간 안에 반환하려면 최소한 n log n 시간은 걸려야 합니다.
 

1381
00:31:14,480 --> 00:31:16,149
반환하는 데 걸리는 시간)를 선형 시간 안에 반환하려면 최소한 n log n 시간은 걸려야 합니다.

1382
00:31:16,149 --> 00:31:18,149

 

1383
00:31:18,149 --> 00:31:18,159

 

1384
00:31:18,159 --> 00:31:20,630

정렬에 대한 하한값이 m log n이므로,

1385
00:31:20,630 --> 00:31:21,110
정렬에 대한 하한값이 m log n이므로,
 

1386
00:31:21,110 --> 00:31:21,120

 

1387
00:31:21,120 --> 00:31:23,590

여기에도 n log n 시간이 필요합니다. 그럼

1388
00:31:23,590 --> 00:31:23,600
여기에도 n log n 시간이 필요합니다. 그럼
 

1389
00:31:23,600 --> 00:31:26,789
여기에도 n log n 시간이 필요합니다. 그럼
최대값을 삭제하는 데 얼마나 걸릴까요? 일단 n log n 시간이 걸리네요.

1390
00:31:26,789 --> 00:31:29,750

 

1391
00:31:29,750 --> 00:31:29,760

 

1392
00:31:29,760 --> 00:31:30,950

AVL 트리에서

1393
00:31:30,950 --> 00:31:30,960
AVL 트리에서
 

1394
00:31:30,960 --> 00:31:33,029
AVL 트리에서
최대값은 가장 오른쪽에 있는 요소인데, 트리를 따라 내려가면서

1395
00:31:33,029 --> 00:31:34,710
최대값은 가장 오른쪽에 있는 요소인데, 트리를 따라 내려가면서
 

1396
00:31:34,710 --> 00:31:34,720

 

1397
00:31:34,720 --> 00:31:36,950

삭제하면 됩니다. 재조정이 필요할 수도 있지만, 이것도

1398
00:31:36,950 --> 00:31:38,310
삭제하면 됩니다. 재조정이 필요할 수도 있지만, 이것도
 

1399
00:31:38,310 --> 00:31:40,389

 

1400
00:31:40,389 --> 00:31:42,149

 

1401
00:31:42,149 --> 00:31:45,750

 

1402
00:31:45,750 --> 00:31:45,760

 

1403
00:31:45,760 --> 00:31:48,870

n log n 시간이 걸리는 작업이죠. 마치 배열에 마지막 요소를 삽입하는 것과 같습니다. AVL 트리에서 이 작업은 n log n 시간이 걸립니다. 그런데

1404
00:31:48,870 --> 00:31:52,070
n log n 시간이 걸리는 작업이죠. 마치 배열에 마지막 요소를 삽입하는 것과 같습니다. AVL 트리에서 이 작업은 n log n 시간이 걸립니다. 그런데
 

1405
00:31:52,070 --> 00:31:53,509

 

1406
00:31:53,509 --> 00:31:53,519

 

1407
00:31:53,519 --> 00:31:55,590

이 두 작업 중 하나와 다른 하나에서 더 나은 성능을 보이는 다른 자료 구조가 있습니다.

1408
00:31:55,590 --> 00:31:57,029
이 두 작업 중 하나와 다른 하나에서 더 나은 성능을 보이는 다른 자료 구조가 있습니다.
 

1409
00:31:57,029 --> 00:31:57,039

 

1410
00:31:57,039 --> 00:32:00,789

예전에 배웠던

1411
00:32:00,789 --> 00:32:00,799
예전에 배웠던
 

1412
00:32:00,799 --> 00:32:04,630
예전에 배웠던
AVL 트리가

1413
00:32:04,630 --> 00:32:06,789
AVL 트리가
 

1414
00:32:06,789 --> 00:32:06,799

 

1415
00:32:06,799 --> 00:32:09,830

동적 배열의 정렬된 배열보다 특별히 나은 점이 없다고 했던 것을 기억하시나요?

1416
00:32:09,830 --> 00:32:13,190
동적 배열의 정렬된 배열보다 특별히 나은 점이 없다고 했던 것을 기억하시나요?
 

1417
00:32:13,190 --> 00:32:13,200

 

1418
00:32:13,200 --> 00:32:16,070

우리가 잘했던 점은 병합 정렬 같은 걸 사용해서 n log n 시간 안에 정렬할 수 있다는 거였죠.

1419
00:32:16,070 --> 00:32:17,590
우리가 잘했던 점은 병합 정렬 같은 걸 사용해서 n log n 시간 안에 정렬할 수 있다는 거였죠.
 

1420
00:32:17,590 --> 00:32:18,549

 

1421
00:32:18,549 --> 00:32:18,559

 

1422
00:32:18,559 --> 00:32:20,149

그리고 마지막 요소를 제거하는 데는 무한대가 걸리겠죠. 그러니까 상각

1423
00:32:20,149 --> 00:32:20,159
그리고 마지막 요소를 제거하는 데는 무한대가 걸리겠죠. 그러니까 상각
 

1424
00:32:20,159 --> 00:32:22,310
그리고 마지막 요소를 제거하는 데는 무한대가 걸리겠죠. 그러니까 상각
시간 복잡도 같은 겁니다.

1425
00:32:22,310 --> 00:32:22,320
시간 복잡도 같은 겁니다.
 

1426
00:32:22,320 --> 00:32:24,549
시간 복잡도 같은 겁니다.
만약 배열

1427
00:32:24,549 --> 00:32:26,470
만약 배열
 

1428
00:32:26,470 --> 00:32:26,480

 

1429
00:32:26,480 --> 00:32:27,909

크기를 신경 쓰지 않는다면

1430
00:32:27,909 --> 00:32:27,919
크기를 신경 쓰지 않는다면
 

1431
00:32:27,919 --> 00:32:29,830
크기를 신경 쓰지 않는다면
최악의 경우에도 상수 시간 안에 할 수 있어요. 그냥

1432
00:32:29,830 --> 00:32:29,840
최악의 경우에도 상수 시간 안에 할 수 있어요. 그냥
 

1433
00:32:29,840 --> 00:32:30,389
최악의 경우에도 상수 시간 안에 할 수 있어요. 그냥
첫 번째 요소와

1434
00:32:30,389 --> 00:32:30,399
첫 번째 요소와
 

1435
00:32:30,399 --> 00:32:32,310
첫 번째 요소와
마지막 요소를 읽어들이면 되니까요. 배열 크기를 조정할 필요도 없고, 그냥

1436
00:32:32,310 --> 00:32:34,230
마지막 요소를 읽어들이면 되니까요. 배열 크기를 조정할 필요도 없고, 그냥
 

1437
00:32:34,230 --> 00:32:34,240

 

1438
00:32:34,240 --> 00:32:37,509

무시하면 되죠. 이해가 되시나요? 네,

1439
00:32:37,509 --> 00:32:37,519
무시하면 되죠. 이해가 되시나요? 네,
 

1440
00:32:37,519 --> 00:32:40,830
무시하면 되죠. 이해가 되시나요? 네,
괜찮습니다. 만약

1441
00:32:40,830 --> 00:32:40,840
괜찮습니다. 만약
 

1442
00:32:40,840 --> 00:32:41,990
괜찮습니다. 만약

1443
00:32:41,990 --> 00:32:42,000

 

1444
00:32:42,000 --> 00:32:43,830

이 두 가지 연산을 구현하는 데이터 구조가 있다면,

1445
00:32:43,830 --> 00:32:47,190
이 두 가지 연산을 구현하는 데이터 구조가 있다면,
 

1446
00:32:47,190 --> 00:32:50,389

 

1447
00:32:50,389 --> 00:32:50,399

 

1448
00:32:50,399 --> 00:32:53,190

실행

1449
00:32:53,190 --> 00:32:53,200
실행
 

1450
00:32:53,200 --> 00:32:54,789
실행
시간은 신경 쓰지 말고 이

1451
00:32:54,789 --> 00:32:54,799
시간은 신경 쓰지 말고 이
 

1452
00:32:54,799 --> 00:32:59,190
시간은 신경 쓰지 말고 이
두 가지 연산만 사용하는 고정 리스트 생성 알고리즘을 알려주실 수 있나요?

1453
00:32:59,190 --> 00:32:59,200

 

1454
00:32:59,200 --> 00:33:03,430

네, 음, 우리는 절댓값이 작은 순서대로 큰 순서대로 정렬된 데이터 구조를 만들었습니다.

1455
00:33:03,430 --> 00:33:05,509
네, 음, 우리는 절댓값이 작은 순서대로 큰 순서대로 정렬된 데이터 구조를 만들었습니다.
 

1456
00:33:05,509 --> 00:33:06,630

 

1457
00:33:06,630 --> 00:33:06,640

 

1458
00:33:06,640 --> 00:33:11,190

그러니까 순서나 그런 건 신경 쓰지 마세요.

1459
00:33:11,190 --> 00:33:12,630
그러니까 순서나 그런 건 신경 쓰지 마세요.
 

1460
00:33:12,630 --> 00:33:14,070

 

1461
00:33:14,070 --> 00:33:14,080

 

1462
00:33:14,080 --> 00:33:14,549


1463
00:33:14,549 --> 00:33:14,559

 

1464
00:33:14,559 --> 00:33:16,950

구현 방식은 제가 설명하지 않을 겁니다. 제가 말하고 싶은 건,

1465
00:33:16,950 --> 00:33:17,909
구현 방식은 제가 설명하지 않을 겁니다. 제가 말하고 싶은 건,
 

1466
00:33:17,909 --> 00:33:17,919

 

1467
00:33:17,919 --> 00:33:20,389

이런 요소들을 입력받아서

1468
00:33:20,389 --> 00:33:21,190
이런 요소들을 입력받아서
 

1469
00:33:21,190 --> 00:33:21,200

 

1470
00:33:21,200 --> 00:33:24,310

가장 큰 요소를 제거하고 반환할 수 있다는 겁니다.

1471
00:33:24,310 --> 00:33:24,320
가장 큰 요소를 제거하고 반환할 수 있다는 겁니다.
 

1472
00:33:24,320 --> 00:33:26,470
가장 큰 요소를 제거하고 반환할 수 있다는 겁니다.
네, 어쨌든 그냥 만들어 보세요. 단, 각 요소

1473
00:33:26,470 --> 00:33:28,710
네, 어쨌든 그냥 만들어 보세요. 단, 각 요소
 

1474
00:33:28,710 --> 00:33:28,720

 

1475
00:33:28,720 --> 00:33:30,470

의 절댓값이 가장 큰 값들이 되도록 만들어야 합니다.

1476
00:33:30,470 --> 00:33:30,480
의 절댓값이 가장 큰 값들이 되도록 만들어야 합니다.
 

1477
00:33:30,480 --> 00:33:32,389
의 절댓값이 가장 큰 값들이 되도록 만들어야 합니다.
의견 수준, 네, 좋습니다.

1478
00:33:32,389 --> 00:33:32,399
의견 수준, 네, 좋습니다.
 

1479
00:33:32,399 --> 00:33:33,830
의견 수준, 네, 좋습니다.
좋은 일이네요.

1480
00:33:33,830 --> 00:33:33,840
좋은 일이네요.
 

1481
00:33:33,840 --> 00:33:36,230
좋은 일이네요.
동료분이 말씀하신 대로 입력된

1482
00:33:36,230 --> 00:33:36,240
동료분이 말씀하신 대로 입력된
 

1483
00:33:36,240 --> 00:33:38,710
동료분이 말씀하신 대로 입력된
모든 항목을 살펴보고 쓰기 가능한

1484
00:33:38,710 --> 00:33:40,149
모든 항목을 살펴보고 쓰기 가능한
 

1485
00:33:40,149 --> 00:33:40,159

 

1486
00:33:40,159 --> 00:33:42,630

메모리 저장소로 복사하겠습니다.

1487
00:33:42,630 --> 00:33:42,640
메모리 저장소로 복사하겠습니다.
 

1488
00:33:42,640 --> 00:33:43,190
메모리 저장소로 복사하겠습니다.

1489
00:33:43,190 --> 00:33:43,200

 

1490
00:33:43,200 --> 00:33:45,830

읽기 전용은

1491
00:33:45,830 --> 00:33:45,840
읽기 전용은
 

1492
00:33:45,840 --> 00:33:47,909
읽기 전용은
이 문제 해결과는 관련이 없죠.

1493
00:33:47,909 --> 00:33:47,919
이 문제 해결과는 관련이 없죠.
 

1494
00:33:47,919 --> 00:33:56,870
이 문제 해결과는 관련이 없죠.
제가 하려는 것은... 아, 죄송합니다.

1495
00:33:56,870 --> 00:33:59,430

 

1496
00:33:59,430 --> 00:33:59,440

 

1497
00:33:59,440 --> 00:34:00,710

우리가 작성 중인 문제 세트 때문에 헷갈렸네요. 어쨌든,

1498
00:34:00,710 --> 00:34:03,990
우리가 작성 중인 문제 세트 때문에 헷갈렸네요. 어쨌든,
 

1499
00:34:03,990 --> 00:34:04,000

 

1500
00:34:04,000 --> 00:34:04,310


1501
00:34:04,310 --> 00:34:04,320

 

1502
00:34:04,320 --> 00:34:07,830

새 배열(크기가 선형인

1503
00:34:07,830 --> 00:34:07,840
새 배열(크기가 선형인
 

1504
00:34:07,840 --> 00:34:10,629
새 배열(크기가 선형인
배열)로 복사합니다. 그런데 값을 직접 넣는 대신

1505
00:34:10,629 --> 00:34:12,069
배열)로 복사합니다. 그런데 값을 직접 넣는 대신
 

1506
00:34:12,069 --> 00:34:12,079

 

1507
00:34:12,079 --> 00:34:13,589

절댓값을 넣을 겁니다. 음수인지

1508
00:34:13,589 --> 00:34:13,599
절댓값을 넣을 겁니다. 음수인지
 

1509
00:34:13,599 --> 00:34:15,190
절댓값을 넣을 겁니다. 음수인지
확인하고, 음수이면 양수를

1510
00:34:15,190 --> 00:34:15,200
확인하고, 음수이면 양수를
 

1511
00:34:15,200 --> 00:34:16,710
확인하고, 음수이면 양수를
넣습니다. 그리고 이

1512
00:34:16,710 --> 00:34:21,190
넣습니다. 그리고 이
 

1513
00:34:21,190 --> 00:34:21,200

 

1514
00:34:21,200 --> 00:34:23,430

배열을 빌드에 넣습니다.

1515
00:34:23,430 --> 00:34:24,230
배열을 빌드에 넣습니다.
 

1516
00:34:24,230 --> 00:34:27,430

 

1517
00:34:27,430 --> 00:34:27,440

 

1518
00:34:27,440 --> 00:34:29,829

빌드 시간이 좀 걸리겠죠. 그런 다음

1519
00:34:29,829 --> 00:34:29,839
빌드 시간이 좀 걸리겠죠. 그런 다음
 

1520
00:34:29,839 --> 00:34:31,270
빌드 시간이 좀 걸리겠죠. 그런 다음

1521
00:34:31,270 --> 00:34:31,280

 

1522
00:34:31,280 --> 00:34:35,349

최대 k번 또는 원하는 횟수만큼 삭제할 수 있습니다.

1523
00:34:35,349 --> 00:34:37,990
최대 k번 또는 원하는 횟수만큼 삭제할 수 있습니다.
 

1524
00:34:37,990 --> 00:34:38,629

 

1525
00:34:38,629 --> 00:34:38,639

 

1526
00:34:38,639 --> 00:34:41,190

예를 들어 가장 큰 값을 log n개 삭제하고 싶다면

1527
00:34:41,190 --> 00:34:42,790
예를 들어 가장 큰 값을 log n개 삭제하고 싶다면
 

1528
00:34:42,790 --> 00:34:42,800

 

1529
00:34:42,800 --> 00:34:46,069

log n번 삭제하면 됩니다.

1530
00:34:46,069 --> 00:34:46,079
log n번 삭제하면 됩니다.
 

1531
00:34:46,079 --> 00:34:48,470
log n번 삭제하면 됩니다.
만약 이런 데이터가 있다면...  이 구조를 사용하면

1532
00:34:48,470 --> 00:34:48,480
만약 이런 데이터가 있다면...  이 구조를 사용하면
 

1533
00:34:48,480 --> 00:34:51,510
만약 이런 데이터가 있다면...  이 구조를 사용하면
한 번의 연산으로

1534
00:34:51,510 --> 00:34:55,430
한 번의 연산으로
 

1535
00:34:55,430 --> 00:34:55,440

 

1536
00:34:55,440 --> 00:34:57,030

이 문제를 해결할 수 있고, 여러 번 연산을 실행할 수도 있습니다. 이해가 되시나요?

1537
00:34:57,030 --> 00:34:59,190
이 문제를 해결할 수 있고, 여러 번 연산을 실행할 수도 있습니다. 이해가 되시나요?
 

1538
00:34:59,190 --> 00:34:59,200

 

1539
00:34:59,200 --> 00:35:04,069

정렬된 배열이나

1540
00:35:04,069 --> 00:35:04,079
정렬된 배열이나
 

1541
00:35:04,079 --> 00:35:06,790
정렬된 배열이나
포화된 AVL 트리를 예로 들면, 이 연산은 이미

1542
00:35:06,790 --> 00:35:06,800
포화된 AVL 트리를 예로 들면, 이 연산은 이미
 

1543
00:35:06,800 --> 00:35:08,230
포화된 AVL 트리를 예로 들면, 이 연산은 이미
저에게 엄청난 부담을 줍니다. 그런데

1544
00:35:08,230 --> 00:35:10,790
저에게 엄청난 부담을 줍니다. 그런데
 

1545
00:35:10,790 --> 00:35:10,800

 

1546
00:35:10,800 --> 00:35:13,270

이진 힙의 장점은

1547
00:35:13,270 --> 00:35:13,280
이진 힙의 장점은
 

1548
00:35:13,280 --> 00:35:19,829
이진 힙의 장점은
이 연산을 선형 시간 안에 처리한다는 것입니다.

1549
00:35:19,829 --> 00:35:19,839

 

1550
00:35:19,839 --> 00:35:22,470

화요일에 자세히 보여드리겠습니다. 그리고

1551
00:35:22,470 --> 00:35:22,480
화요일에 자세히 보여드리겠습니다. 그리고
 

1552
00:35:22,480 --> 00:35:23,510
화요일에 자세히 보여드리겠습니다. 그리고
이 연산은

1553
00:35:23,510 --> 00:35:23,520
이 연산은
 

1554
00:35:23,520 --> 00:35:28,310
이 연산은
로그 시간 안에 처리됩니다. 자, 그렇다면

1555
00:35:28,310 --> 00:35:31,589

 

1556
00:35:31,589 --> 00:35:31,599

 

1557
00:35:31,599 --> 00:35:34,230

이진 힙을 사용하여

1558
00:35:34,230 --> 00:35:34,240
이진 힙을 사용하여
 

1559
00:35:34,240 --> 00:35:37,349
이진 힙을 사용하여
이 데이터 구조를 구현하면 실행 시간은 어떻게 될까요? n

1560
00:35:37,349 --> 00:35:37,359
이 데이터 구조를 구현하면 실행 시간은 어떻게 될까요? n
 

1561
00:35:37,359 --> 00:35:40,790
이 데이터 구조를 구현하면 실행 시간은 어떻게 될까요? n
곱하기 log n

1562
00:35:40,790 --> 00:35:40,800
곱하기 log n
 

1563
00:35:40,800 --> 00:35:44,870
곱하기 log n
곱하기 log n입니다. log n 제곱

1564
00:35:44,870 --> 00:35:44,880
곱하기 log n입니다. log n 제곱
 

1565
00:35:44,880 --> 00:35:48,710
곱하기 log n입니다. log n 제곱
log n은 n에 비해 훨씬

1566
00:35:48,710 --> 00:35:48,720
log n은 n에 비해 훨씬
 

1567
00:35:48,720 --> 00:35:50,790
log n은 n에 비해 훨씬
작습니다. 따라서 두

1568
00:35:50,790 --> 00:35:50,800
작습니다. 따라서 두
 

1569
00:35:50,800 --> 00:35:52,230
작습니다. 따라서 두
실행 시간을 더해도 여전히 선형 시간입니다. 자,

1570
00:35:52,230 --> 00:35:52,240
실행 시간을 더해도 여전히 선형 시간입니다. 자,
 

1571
00:35:52,240 --> 00:35:53,510
실행 시간을 더해도 여전히 선형 시간입니다. 자,

1572
00:35:53,510 --> 00:35:53,520

 

1573
00:35:53,520 --> 00:35:55,589

이렇게 첫 번째 문제를 해결했습니다.

1574
00:35:55,589 --> 00:35:56,870
이렇게 첫 번째 문제를 해결했습니다.
 

1575
00:35:56,870 --> 00:35:56,880

 

1576
00:35:56,880 --> 00:35:58,390

이진 힙이 무엇인지, 어떻게 작동하는지는 설명할 필요가 없었습니다.

1577
00:35:58,390 --> 00:35:58,400
이진 힙이 무엇인지, 어떻게 작동하는지는 설명할 필요가 없었습니다.
 

1578
00:35:58,400 --> 00:36:01,030
이진 힙이 무엇인지, 어떻게 작동하는지는 설명할 필요가 없었습니다.
제가

1579
00:36:01,030 --> 00:36:01,040
제가
 

1580
00:36:01,040 --> 00:36:02,550
제가
알려드리면 된 것은 이

1581
00:36:02,550 --> 00:36:02,560
알려드리면 된 것은 이
 

1582
00:36:02,560 --> 00:36:04,069
알려드리면 된 것은 이
연산을 선형 시간 안에 처리하고 로그 시간 안에 처리한다는 것뿐이었습니다.

1583
00:36:04,069 --> 00:36:05,910
연산을 선형 시간 안에 처리하고 로그 시간 안에 처리한다는 것뿐이었습니다.
 

1584
00:36:05,910 --> 00:36:05,920

 

1585
00:36:05,920 --> 00:36:09,190


1586
00:36:09,190 --> 00:36:09,200

 

1587
00:36:09,200 --> 00:36:12,630

네, 화요일에 비법을 공개하겠습니다.

1588
00:36:12,630 --> 00:36:15,270
네, 화요일에 비법을 공개하겠습니다.
 

1589
00:36:15,270 --> 00:36:15,280

 

1590
00:36:15,280 --> 00:36:19,109

파트 B는 고정된 컴퓨터에

1591
00:36:19,109 --> 00:36:19,119
파트 B는 고정된 컴퓨터에
 

1592
00:36:19,119 --> 00:36:21,750
파트 B는 고정된 컴퓨터에
최대 쓰기 용량이 제한되어 있다고 가정해 봅시다.  로그

1593
00:36:21,750 --> 00:36:21,760
최대 쓰기 용량이 제한되어 있다고 가정해 봅시다.  로그
 

1594
00:36:21,760 --> 00:36:22,550
최대 쓰기 용량이 제한되어 있다고 가정해 봅시다.  로그
와 공간,

1595
00:36:22,550 --> 00:36:22,560
와 공간,
 

1596
00:36:22,560 --> 00:36:24,069
와 공간,
음, 이게 문제죠.

1597
00:36:24,069 --> 00:36:24,079
음, 이게 문제죠.
 

1598
00:36:24,079 --> 00:36:27,990
음, 이게 문제죠.
이전에는

1599
00:36:27,990 --> 00:36:28,000
이전에는
 

1600
00:36:28,000 --> 00:36:32,870
이전에는
배열 전체를 복사하고 필터링한

1601
00:36:32,870 --> 00:36:32,880
배열 전체를 복사하고 필터링한
 

1602
00:36:32,880 --> 00:36:34,310
배열 전체를 복사하고 필터링한
다음 몇 가지 연산을 수행했는데, 쓰기 가능한

1603
00:36:34,310 --> 00:36:35,829
다음 몇 가지 연산을 수행했는데, 쓰기 가능한
 

1604
00:36:35,829 --> 00:36:37,030

 

1605
00:36:37,030 --> 00:36:37,040

 

1606
00:36:37,040 --> 00:36:40,150

외부 메모리에 전체를 저장할 수 없다면 이런 작업조차 할 수 없었을 겁니다.

1607
00:36:40,150 --> 00:36:40,160
외부 메모리에 전체를 저장할 수 없다면 이런 작업조차 할 수 없었을 겁니다.
 

1608
00:36:40,160 --> 00:36:42,390
외부 메모리에 전체를 저장할 수 없다면 이런 작업조차 할 수 없었을 겁니다.
그렇죠? 그래서 지금은 그렇게 할 수 없으니, 어떤

1609
00:36:42,390 --> 00:36:42,400
그렇죠? 그래서 지금은 그렇게 할 수 없으니, 어떤
 

1610
00:36:42,400 --> 00:36:43,910
그렇죠? 그래서 지금은 그렇게 할 수 없으니, 어떤
의미에서는 더 제한적인

1611
00:36:43,910 --> 00:36:43,920
의미에서는 더 제한적인
 

1612
00:36:43,920 --> 00:36:45,270
의미에서는 더 제한적인
환경입니다.

1613
00:36:45,270 --> 00:36:48,470
환경입니다.
 

1614
00:36:48,470 --> 00:36:51,349

 

1615
00:36:51,349 --> 00:36:51,359

 

1616
00:36:51,359 --> 00:36:53,190

이전처럼

1617
00:36:53,190 --> 00:36:53,200
이전처럼
 

1618
00:36:53,200 --> 00:36:55,030
이전처럼
원하는 만큼 공간을

1619
00:36:55,030 --> 00:36:55,040
원하는 만큼 공간을
 

1620
00:36:55,040 --> 00:36:57,430
원하는 만큼 공간을
사용할 수 있었던 상황보다 할 수 있는 일이 적습니다. 즉, 성능이 떨어지는 거죠. 따라서

1621
00:36:57,430 --> 00:37:00,870
사용할 수 있었던 상황보다 할 수 있는 일이 적습니다. 즉, 성능이 떨어지는 거죠. 따라서
 

1622
00:37:00,870 --> 00:37:04,310

 

1623
00:37:04,310 --> 00:37:05,829

 

1624
00:37:05,829 --> 00:37:05,839

 

1625
00:37:05,839 --> 00:37:07,349

이전처럼 실행 시간 제한을 맞추지 못하는 것도 당연합니다.

1626
00:37:07,349 --> 00:37:09,910
이전처럼 실행 시간 제한을 맞추지 못하는 것도 당연합니다.
 

1627
00:37:09,910 --> 00:37:09,920

 

1628
00:37:09,920 --> 00:37:11,829

더 제한적인 컴퓨팅 환경에 있기 때문에 무언가를 희생해야 하는 거죠.

1629
00:37:11,829 --> 00:37:17,109
더 제한적인 컴퓨팅 환경에 있기 때문에 무언가를 희생해야 하는 거죠.
 

1630
00:37:17,109 --> 00:37:17,119

 

1631
00:37:17,119 --> 00:37:18,790

이 문제는

1632
00:37:18,790 --> 00:37:18,800
이 문제는
 

1633
00:37:18,800 --> 00:37:20,310
이 문제는
이진 힙으로 해결할 수 있지만, 꼭 그럴 필요는 없습니다. 집합 AVL 트리를 사용해서

1634
00:37:20,310 --> 00:37:20,320
이진 힙으로 해결할 수 있지만, 꼭 그럴 필요는 없습니다. 집합 AVL 트리를 사용해서
 

1635
00:37:20,320 --> 00:37:21,750
이진 힙으로 해결할 수 있지만, 꼭 그럴 필요는 없습니다. 집합 AVL 트리를 사용해서
해결할 수도 있습니다.

1636
00:37:21,750 --> 00:37:27,750
해결할 수도 있습니다.
 

1637
00:37:27,750 --> 00:37:29,510

 

1638
00:37:29,510 --> 00:37:29,520

 

1639
00:37:29,520 --> 00:37:32,630

집합 AVL 트리를 사용해서 해결할 수 있는 아이디어가 있으신가요? 제게는 마우스

1640
00:37:32,630 --> 00:37:32,640
집합 AVL 트리를 사용해서 해결할 수 있는 아이디어가 있으신가요? 제게는 마우스
 

1641
00:37:32,640 --> 00:37:35,829
집합 AVL 트리를 사용해서 해결할 수 있는 아이디어가 있으신가요? 제게는 마우스
개수와

1642
00:37:35,829 --> 00:37:35,839
개수와
 

1643
00:37:35,839 --> 00:37:40,069
개수와
최대 log n개의 공간이 제한되어 있습니다.

1644
00:37:40,069 --> 00:37:40,079

 

1645
00:37:40,079 --> 00:37:41,589

네, 그럼

1646
00:37:41,589 --> 00:37:41,599
네, 그럼
 

1647
00:37:41,599 --> 00:37:43,430
네, 그럼
이 초기 트리는 얼마나 많은 공간을 차지할까요?

1648
00:37:43,430 --> 00:37:46,069
이 초기 트리는 얼마나 많은 공간을 차지할까요?
 

1649
00:37:46,069 --> 00:37:46,079

 

1650
00:37:46,079 --> 00:37:47,589

포인터의 개수는 일정합니다.  각각의

1651
00:37:47,589 --> 00:37:47,599
포인터의 개수는 일정합니다.  각각의
 

1652
00:37:47,599 --> 00:37:48,630
포인터의 개수는 일정합니다.  각각의

1653
00:37:48,630 --> 00:37:48,640

 

1654
00:37:48,640 --> 00:37:51,670

노드에 저장하고 있는데,

1655
00:37:51,670 --> 00:37:51,680
노드에 저장하고 있는데,
 

1656
00:37:51,680 --> 00:37:53,990
노드에 저장하고 있는데,
기본적으로 지금까지 보여드린 모든 데이터 구조는 공간을 차지합니다.

1657
00:37:53,990 --> 00:37:55,589
기본적으로 지금까지 보여드린 모든 데이터 구조는 공간을 차지합니다.
 

1658
00:37:55,589 --> 00:37:58,790

 

1659
00:37:58,790 --> 00:37:58,800

 

1660
00:37:58,800 --> 00:37:59,670

저장하는 항목의 순서가 공간을 차지하는 것이지,

1661
00:37:59,670 --> 00:37:59,680
저장하는 항목의 순서가 공간을 차지하는 것이지,
 

1662
00:37:59,680 --> 00:38:02,230
저장하는 항목의 순서가 공간을 차지하는 것이지,
추가 공간을 사용하는 것은 아닙니다.

1663
00:38:02,230 --> 00:38:03,109
추가 공간을 사용하는 것은 아닙니다.
 

1664
00:38:03,109 --> 00:38:03,119

 

1665
00:38:03,119 --> 00:38:05,670

특정 작업을 수행하는 데 시간이 더 걸릴 수는 있지만,

1666
00:38:05,670 --> 00:38:05,680
특정 작업을 수행하는 데 시간이 더 걸릴 수는 있지만,
 

1667
00:38:05,680 --> 00:38:06,630
특정 작업을 수행하는 데 시간이 더 걸릴 수는 있지만,
공간은

1668
00:38:06,630 --> 00:38:09,589
공간은
 

1669
00:38:09,589 --> 00:38:09,599

 

1670
00:38:09,599 --> 00:38:10,230

저장하는 항목 수에

1671
00:38:10,230 --> 00:38:10,240
저장하는 항목 수에
 

1672
00:38:10,240 --> 00:38:13,670
저장하는 항목 수에
상수 인자를 더한 만큼입니다. 자,

1673
00:38:13,670 --> 00:38:13,680

 

1674
00:38:13,680 --> 00:38:16,950

여기 제 입력값을 그려볼게요.

1675
00:38:16,950 --> 00:38:16,960
여기 제 입력값을 그려볼게요.
 

1676
00:38:16,960 --> 00:38:19,910
여기 제 입력값을 그려볼게요.
읽기만 가능하고 쓰기는 안 되지만, 그냥

1677
00:38:19,910 --> 00:38:19,920
읽기만 가능하고 쓰기는 안 되지만, 그냥
 

1678
00:38:19,920 --> 00:38:22,310
읽기만 가능하고 쓰기는 안 되지만, 그냥
로그 함수라고 부르겠습니다.

1679
00:38:22,310 --> 00:38:22,320
로그 함수라고 부르겠습니다.
 

1680
00:38:22,320 --> 00:38:26,069
로그 함수라고 부르겠습니다.
이건

1681
00:38:26,069 --> 00:38:26,079

 

1682
00:38:26,079 --> 00:38:29,109

모든 리벤저 의견 목록입니다. 읽기만 가능하고,

1683
00:38:29,109 --> 00:38:31,510
모든 리벤저 의견 목록입니다. 읽기만 가능하고,
 

1684
00:38:31,510 --> 00:38:31,520

 

1685
00:38:31,520 --> 00:38:35,190

제 컴퓨터는 로그

1686
00:38:35,190 --> 00:38:35,200
제 컴퓨터는 로그
 

1687
00:38:35,200 --> 00:38:42,550
제 컴퓨터는 로그
함수 크기의 공간만 쓸 수 있습니다.

1688
00:38:42,550 --> 00:38:42,560

 

1689
00:38:42,560 --> 00:38:48,790

이 공간에 무엇을 넣을 수 있을까요?

1690
00:38:48,790 --> 00:38:48,800

 

1691
00:38:48,800 --> 00:38:50,710

log n개의 항목을 넣을 수 있습니다.

1692
00:38:50,710 --> 00:38:53,190
log n개의 항목을 넣을 수 있습니다.
 

1693
00:38:53,190 --> 00:38:53,200

 

1694
00:38:53,200 --> 00:38:55,430

이런 제약 조건이 있다면, 당연히

1695
00:38:55,430 --> 00:38:56,870
이런 제약 조건이 있다면, 당연히
 

1696
00:38:56,870 --> 00:38:56,880

 

1697
00:38:56,880 --> 00:38:57,750

그 크기의 데이터 구조를 만들고 싶을 겁니다.

1698
00:38:57,750 --> 00:38:57,760
그 크기의 데이터 구조를 만들고 싶을 겁니다.
 

1699
00:38:57,760 --> 00:38:59,910
그 크기의 데이터 구조를 만들고 싶을 겁니다.
그 개수만큼의 항목을 담는 구조 말이죠.

1700
00:38:59,910 --> 00:39:02,790
그 개수만큼의 항목을 담는 구조 말이죠.
 

1701
00:39:02,790 --> 00:39:02,800

 

1702
00:39:02,800 --> 00:39:07,430

다른 방법이 있을까요? 제가

1703
00:39:07,430 --> 00:39:07,440

 

1704
00:39:07,440 --> 00:39:10,550

아이디어를 드렸는데,

1705
00:39:10,550 --> 00:39:10,560
아이디어를 드렸는데,
 

1706
00:39:10,560 --> 00:39:12,069
아이디어를 드렸는데,
여기서 집합 AVL을 사용할 수도 있겠네요.

1707
00:39:12,069 --> 00:39:12,079
여기서 집합 AVL을 사용할 수도 있겠네요.
 

1708
00:39:12,079 --> 00:39:15,270
여기서 집합 AVL을 사용할 수도 있겠네요.
제 답변에 로그 함수가 보이시죠?

1709
00:39:15,270 --> 00:39:18,150
제 답변에 로그 함수가 보이시죠?
 

1710
00:39:18,150 --> 00:39:18,160

 

1711
00:39:18,160 --> 00:39:18,950


1712
00:39:18,950 --> 00:39:18,960

 

1713
00:39:18,960 --> 00:39:22,790

정렬된 배열을 사용할 수도 있을 것 같습니다.  또는 AVL 트리를 설정하면

1714
00:39:22,790 --> 00:39:23,589
정렬된 배열을 사용할 수도 있을 것 같습니다.  또는 AVL 트리를 설정하면
 

1715
00:39:23,589 --> 00:39:25,510

 

1716
00:39:25,510 --> 00:39:25,520

 

1717
00:39:25,520 --> 00:39:27,349

실행 시간에 로그가 남습니다. 그래서

1718
00:39:27,349 --> 00:39:30,950
실행 시간에 로그가 남습니다. 그래서
 

1719
00:39:30,950 --> 00:39:30,960

 

1720
00:39:30,960 --> 00:39:33,510

AVL 트리를 사용하는 것이 좋을 것 같습니다. 왜 AVL 트리가

1721
00:39:33,510 --> 00:39:33,520
AVL 트리를 사용하는 것이 좋을 것 같습니다. 왜 AVL 트리가
 

1722
00:39:33,520 --> 00:39:37,750
AVL 트리를 사용하는 것이 좋을 것 같습니다. 왜 AVL 트리가
유용할까요? 네, AVL 트리는

1723
00:39:37,750 --> 00:39:39,829

 

1724
00:39:39,829 --> 00:39:39,839

 

1725
00:39:39,839 --> 00:39:41,190

직접 러셀 순서(DRO)를 사용하고,

1726
00:39:41,190 --> 00:39:41,200
직접 러셀 순서(DRO)를 사용하고,
 

1727
00:39:41,200 --> 00:39:43,109
직접 러셀 순서(DRO)를 사용하고,
순회 순서를 계산하고, 데이터를 빠르게

1728
00:39:43,109 --> 00:39:43,119
순회 순서를 계산하고, 데이터를 빠르게
 

1729
00:39:43,119 --> 00:39:46,390
순회 순서를 계산하고, 데이터를 빠르게
삽입할 수 있기 때문입니다. 물론

1730
00:39:46,390 --> 00:39:46,400
삽입할 수 있기 때문입니다. 물론
 

1731
00:39:46,400 --> 00:39:48,550
삽입할 수 있기 때문입니다. 물론
이러한 모든 작업을 수행할 수 있지만, 특히

1732
00:39:48,550 --> 00:39:51,910
이러한 모든 작업을 수행할 수 있지만, 특히
 

1733
00:39:51,910 --> 00:39:51,920

 

1734
00:39:51,920 --> 00:39:55,670

큰 값을 빠르게 찾는 데 도움이 됩니다. 예를 들어,

1735
00:39:55,670 --> 00:39:59,430
큰 값을 빠르게 찾는 데 도움이 됩니다. 예를 들어,
 

1736
00:39:59,430 --> 00:39:59,910

 

1737
00:39:59,910 --> 00:39:59,920

 

1738
00:39:59,920 --> 00:40:01,589

데이터 집합이 있고, 이 데이터

1739
00:40:01,589 --> 00:40:01,599
데이터 집합이 있고, 이 데이터
 

1740
00:40:01,599 --> 00:40:03,589
데이터 집합이 있고, 이 데이터
구조에 데이터를 점진적으로 추가하면서 유지 관리한다고 가정해 보겠습니다. 그러면

1741
00:40:03,589 --> 00:40:04,550
구조에 데이터를 점진적으로 추가하면서 유지 관리한다고 가정해 보겠습니다. 그러면
 

1742
00:40:04,550 --> 00:40:04,560

 

1743
00:40:04,560 --> 00:40:07,589

가장 큰

1744
00:40:07,589 --> 00:40:07,599
가장 큰
 

1745
00:40:07,599 --> 00:40:08,550
가장 큰
값

1746
00:40:08,550 --> 00:40:08,560
값
 

1747
00:40:08,560 --> 00:40:10,790
값
이나 가장 작은 값을 매우 빠르게 찾을 수 있습니다. 즉,

1748
00:40:10,790 --> 00:40:10,800
이나 가장 작은 값을 매우 빠르게 찾을 수 있습니다. 즉,
 

1749
00:40:10,800 --> 00:40:12,150
이나 가장 작은 값을 매우 빠르게 찾을 수 있습니다. 즉,
로그 시간 내에 찾을 수 있습니다. 예를 들어,

1750
00:40:12,150 --> 00:40:15,670
로그 시간 내에 찾을 수 있습니다. 예를 들어,
 

1751
00:40:15,670 --> 00:40:15,680

 

1752
00:40:15,680 --> 00:40:18,150

트리에 log n개의 데이터가 있다면, 트리의 높이는

1753
00:40:18,150 --> 00:40:20,550
트리에 log n개의 데이터가 있다면, 트리의 높이는
 

1754
00:40:20,550 --> 00:40:20,560

 

1755
00:40:20,560 --> 00:40:23,430

log n이 됩니다. 익숙한 계산 방식이죠?

1756
00:40:23,430 --> 00:40:23,440
log n이 됩니다. 익숙한 계산 방식이죠?
 

1757
00:40:23,440 --> 00:40:26,550
log n이 됩니다. 익숙한 계산 방식이죠?
저는 이 데이터 구조에 대해

1758
00:40:26,550 --> 00:40:26,560
저는 이 데이터 구조에 대해
 

1759
00:40:26,560 --> 00:40:31,030
저는 이 데이터 구조에 대해
선형적인 수의 AVL 트리

1760
00:40:31,030 --> 00:40:31,040
선형적인 수의 AVL 트리
 

1761
00:40:31,040 --> 00:40:34,390
선형적인 수의 AVL 트리
연산을 수행할 수 있습니다. 네,

1762
00:40:34,390 --> 00:40:34,400
연산을 수행할 수 있습니다. 네,
 

1763
00:40:34,400 --> 00:40:37,190
연산을 수행할 수 있습니다. 네,
질문이 있으셨군요. 죄송합니다.

1764
00:40:37,190 --> 00:40:38,710
질문이 있으셨군요. 죄송합니다.
 

1765
00:40:38,710 --> 00:40:38,720

 

1766
00:40:38,720 --> 00:40:41,589

AVL 트리가 필요한데, 반드시 특정 형식이어야 하나요?  BTS 트리,

1767
00:40:41,589 --> 00:40:41,599
AVL 트리가 필요한데, 반드시 특정 형식이어야 하나요?  BTS 트리,
 

1768
00:40:41,599 --> 00:40:41,910
AVL 트리가 필요한데, 반드시 특정 형식이어야 하나요?  BTS 트리,

1769
00:40:41,910 --> 00:40:45,349

 

1770
00:40:45,349 --> 00:40:45,359

 

1771
00:40:45,359 --> 00:40:48,390

그러니까 BTS BST 맞아요. 누군가가

1772
00:40:48,390 --> 00:40:48,400
그러니까 BTS BST 맞아요. 누군가가
 

1773
00:40:48,400 --> 00:40:49,510
그러니까 BTS BST 맞아요. 누군가가
한국 K팝을 좋아한다고 말할 때, BST라고 하죠.

1774
00:40:49,510 --> 00:40:52,790
한국 K팝을 좋아한다고 말할 때, BST라고 하죠.
 

1775
00:40:52,790 --> 00:40:52,800

 

1776
00:40:52,800 --> 00:40:56,950

하지만

1777
00:40:56,950 --> 00:40:56,960
하지만
 

1778
00:40:56,960 --> 00:40:58,870
하지만
여러분이

1779
00:40:58,870 --> 00:40:58,880
여러분이
 

1780
00:40:58,880 --> 00:41:00,710
여러분이
다른 맥락에서 들어본 적 있는 용어로 말하자면,

1781
00:41:00,710 --> 00:41:00,720
다른 맥락에서 들어본 적 있는 용어로 말하자면,
 

1782
00:41:00,720 --> 00:41:02,710
다른 맥락에서 들어본 적 있는 용어로 말하자면,
이 수업에서 말하는 BST는 집합 이진 트리(Set ADL

1783
00:41:02,710 --> 00:41:02,720
이 수업에서 말하는 BST는 집합 이진 트리(Set ADL
 

1784
00:41:02,720 --> 00:41:04,230
이 수업에서 말하는 BST는 집합 이진 트리(Set ADL
Tree)를 의미합니다.

1785
00:41:04,230 --> 00:41:04,240
Tree)를 의미합니다.
 

1786
00:41:04,240 --> 00:41:07,270
Tree)를 의미합니다.
사람들이 흔히

1787
00:41:07,270 --> 00:41:07,280
사람들이 흔히
 

1788
00:41:07,280 --> 00:41:09,910
사람들이 흔히
이진 검색 트리라고 부르는 것은

1789
00:41:09,910 --> 00:41:09,920
이진 검색 트리라고 부르는 것은
 

1790
00:41:09,920 --> 00:41:10,950
이진 검색 트리라고 부르는 것은
균형

1791
00:41:10,950 --> 00:41:10,960
균형
 

1792
00:41:10,960 --> 00:41:13,349
균형
의미론을 갖지 않죠. 그래서 이

1793
00:41:13,349 --> 00:41:13,359
의미론을 갖지 않죠. 그래서 이
 

1794
00:41:13,359 --> 00:41:15,190
의미론을 갖지 않죠. 그래서 이
수업에서는 집합 이진 트리라고 부를 수도 있지만,

1795
00:41:15,190 --> 00:41:15,200
수업에서는 집합 이진 트리라고 부를 수도 있지만,
 

1796
00:41:15,200 --> 00:41:18,230
수업에서는 집합 이진 트리라고 부를 수도 있지만,
실제로는

1797
00:41:18,230 --> 00:41:18,240
실제로는
 

1798
00:41:18,240 --> 00:41:20,069
실제로는
균형이 잡혀 있기 때문에 유용합니다.

1799
00:41:20,069 --> 00:41:20,079
균형이 잡혀 있기 때문에 유용합니다.
 

1800
00:41:20,079 --> 00:41:22,150
균형이 잡혀 있기 때문에 유용합니다.
따라서 우리는 보통

1801
00:41:22,150 --> 00:41:22,710
따라서 우리는 보통
 

1802
00:41:22,710 --> 00:41:22,720

 

1803
00:41:22,720 --> 00:41:24,870

여기서 균형이 잡힌 것들을 이야기한다고 가정할 겁니다.

1804
00:41:24,870 --> 00:41:24,880
여기서 균형이 잡힌 것들을 이야기한다고 가정할 겁니다.
 

1805
00:41:24,880 --> 00:41:27,190
여기서 균형이 잡힌 것들을 이야기한다고 가정할 겁니다.
집합 AVL 트리는 이진 검색

1806
00:41:27,190 --> 00:41:27,200
집합 AVL 트리는 이진 검색
 

1807
00:41:27,200 --> 00:41:28,630
집합 AVL 트리는 이진 검색
트리의 의미론을 가지고 있습니다.

1808
00:41:28,630 --> 00:41:28,640
트리의 의미론을 가지고 있습니다.
 

1809
00:41:28,640 --> 00:41:31,270
트리의 의미론을 가지고 있습니다.
키는 순서대로 정렬되어 있고, 항목들은

1810
00:41:31,270 --> 00:41:31,280
키는 순서대로 정렬되어 있고, 항목들은
 

1811
00:41:31,280 --> 00:41:33,030
키는 순서대로 정렬되어 있고, 항목들은
키를 가지고 있으며 순서대로 정렬되어 있죠. 집합 인터페이스를 사용하는 겁니다.

1812
00:41:33,030 --> 00:41:34,230
키를 가지고 있으며 순서대로 정렬되어 있죠. 집합 인터페이스를 사용하는 겁니다.
 

1813
00:41:34,230 --> 00:41:34,240

 

1814
00:41:34,240 --> 00:41:36,870

반면에 시퀀스

1815
00:41:36,870 --> 00:41:36,880
반면에 시퀀스
 

1816
00:41:36,880 --> 00:41:38,150
반면에 시퀀스
인터페이스도 있는데,

1817
00:41:38,150 --> 00:41:38,160
인터페이스도 있는데,
 

1818
00:41:38,160 --> 00:41:41,030
인터페이스도 있는데,
이것들은

1819
00:41:41,030 --> 00:41:41,040
이것들은
 

1820
00:41:41,040 --> 00:41:43,030
이것들은
키조차 없습니다. 어떻게

1821
00:41:43,030 --> 00:41:43,040
키조차 없습니다. 어떻게
 

1822
00:41:43,040 --> 00:41:45,589
키조차 없습니다. 어떻게
집합 의미론을 저장할 수 있을까요?

1823
00:41:45,589 --> 00:41:45,599
집합 의미론을 저장할 수 있을까요?
 

1824
00:41:45,599 --> 00:41:47,270
집합 의미론을 저장할 수 있을까요?
이것이 바로

1825
00:41:47,270 --> 00:41:48,470
이것이 바로
 

1826
00:41:48,470 --> 00:41:48,480

 

1827
00:41:48,480 --> 00:41:52,150

이진 검색 트리와

1828
00:41:52,150 --> 00:41:52,160
이진 검색 트리와
 

1829
00:41:52,160 --> 00:41:55,430
이진 검색 트리와
집합 AVL 트리의 차이점입니다. 자, 그럼 이것들을 이용해서

1830
00:41:55,430 --> 00:41:55,440
집합 AVL 트리의 차이점입니다. 자, 그럼 이것들을 이용해서
 

1831
00:41:55,440 --> 00:41:57,030
집합 AVL 트리의 차이점입니다. 자, 그럼 이것들을 이용해서
AVL 트리를 만들면 어떻게 될까요?

1832
00:41:57,030 --> 00:41:58,550
AVL 트리를 만들면 어떻게 될까요?
 

1833
00:41:58,550 --> 00:41:58,560

 

1834
00:41:58,560 --> 00:42:00,710

우리가 노드를 만들 때

1835
00:42:00,710 --> 00:42:00,720
우리가 노드를 만들 때
 

1836
00:42:00,720 --> 00:42:03,750
우리가 노드를 만들 때
절대값을 기준으로 키를 지정하잖아요. 그러니까

1837
00:42:03,750 --> 00:42:06,870
절대값을 기준으로 키를 지정하잖아요. 그러니까
 

1838
00:42:06,870 --> 00:42:06,880

 

1839
00:42:06,880 --> 00:42:09,910

집합-AVL 트리를 만들 때,

1840
00:42:09,910 --> 00:42:10,630
집합-AVL 트리를 만들 때,
 

1841
00:42:10,630 --> 00:42:10,640

 

1842
00:42:10,640 --> 00:42:12,150

객체를 저장하는 경우라면 해당 객체의

1843
00:42:12,150 --> 00:42:12,160
객체를 저장하는 경우라면 해당 객체의
 

1844
00:42:12,160 --> 00:42:13,510
객체를 저장하는 경우라면 해당 객체의
키가 무엇인지 알려줘야 해요.

1845
00:42:13,510 --> 00:42:15,030
키가 무엇인지 알려줘야 해요.
 

1846
00:42:15,030 --> 00:42:15,040

 

1847
00:42:15,040 --> 00:42:18,309

제가 지금 여기서 하는 것처럼 숫자만 저장하는 경우에는

1848
00:42:18,309 --> 00:42:18,319
제가 지금 여기서 하는 것처럼 숫자만 저장하는 경우에는
 

1849
00:42:18,319 --> 00:42:20,150
제가 지금 여기서 하는 것처럼 숫자만 저장하는 경우에는
집합-AVL 트리가 아니지만,

1850
00:42:20,150 --> 00:42:20,160
집합-AVL 트리가 아니지만,
 

1851
00:42:20,160 --> 00:42:21,270
집합-AVL 트리가 아니지만,
숫자만 저장하는 경우에는

1852
00:42:21,270 --> 00:42:22,630
숫자만 저장하는 경우에는
 

1853
00:42:22,630 --> 00:42:22,640

 

1854
00:42:22,640 --> 00:42:24,309

저장하는 항목이 키가 된다는 것을 알려줘야 하죠.

1855
00:42:24,309 --> 00:42:24,319
저장하는 항목이 키가 된다는 것을 알려줘야 하죠.
 

1856
00:42:24,319 --> 00:42:26,870
저장하는 항목이 키가 된다는 것을 알려줘야 하죠.
그러면 나머지는 자연스럽게 따라오게 됩니다.

1857
00:42:26,870 --> 00:42:26,880
그러면 나머지는 자연스럽게 따라오게 됩니다.
 

1858
00:42:26,880 --> 00:42:28,150
그러면 나머지는 자연스럽게 따라오게 됩니다.
하지만

1859
00:42:28,150 --> 00:42:29,190
하지만
 

1860
00:42:29,190 --> 00:42:29,200

 

1861
00:42:29,200 --> 00:42:31,030

이 방에 있는 학생들처럼 정렬하려는 객체가 있다면 속성이 많겠죠. 예를 들어

1862
00:42:31,030 --> 00:42:32,230
이 방에 있는 학생들처럼 정렬하려는 객체가 있다면 속성이 많겠죠. 예를 들어
 

1863
00:42:32,230 --> 00:42:35,430

 

1864
00:42:35,430 --> 00:42:35,440

 

1865
00:42:35,440 --> 00:42:38,470

전화번호가 있는 학생들을 모두 찾고 싶을 수도 있고,

1866
00:42:38,470 --> 00:42:39,910
전화번호가 있는 학생들을 모두 찾고 싶을 수도 있고,
 

1867
00:42:39,910 --> 00:42:39,920

 

1868
00:42:39,920 --> 00:42:42,630

어떤 이유로든 전화번호를 기준으로 삼아

1869
00:42:42,630 --> 00:42:42,640
어떤 이유로든 전화번호를 기준으로 삼아
 

1870
00:42:42,640 --> 00:42:44,630
어떤 이유로든 전화번호를 기준으로 삼아
어디에 사는지 알아내고 싶을 수도 있겠죠. 뭐, 이 얘기는 좀 길어지니 그만하죠.

1871
00:42:44,630 --> 00:42:46,309
어디에 사는지 알아내고 싶을 수도 있겠죠. 뭐, 이 얘기는 좀 길어지니 그만하죠.
 

1872
00:42:46,309 --> 00:42:46,319

 

1873
00:42:46,319 --> 00:42:46,870


1874
00:42:46,870 --> 00:42:46,880

 

1875
00:42:46,880 --> 00:42:49,829

그러니까 집합-AVL

1876
00:42:49,829 --> 00:42:49,839
그러니까 집합-AVL
 

1877
00:42:49,839 --> 00:42:50,550
그러니까 집합-AVL
트리를 만들 때는 어떤 기준으로 키를 지정하는지

1878
00:42:50,550 --> 00:42:50,560
트리를 만들 때는 어떤 기준으로 키를 지정하는지
 

1879
00:42:50,560 --> 00:42:51,910
트리를 만들 때는 어떤 기준으로 키를 지정하는지
알려줘야 하지만, 순열

1880
00:42:51,910 --> 00:42:51,920
알려줘야 하지만, 순열
 

1881
00:42:51,920 --> 00:42:54,309
알려줘야 하지만, 순열
-AVL 트리를 만들 때는 어떤 기준으로 순회하는지

1882
00:42:54,309 --> 00:42:54,319
-AVL 트리를 만들 때는 어떤 기준으로 순회하는지
 

1883
00:42:54,319 --> 00:42:57,589
-AVL 트리를 만들 때는 어떤 기준으로 순회하는지
명확하잖아요.

1884
00:42:57,589 --> 00:42:57,599
명확하잖아요.
 

1885
00:42:57,599 --> 00:42:58,870
명확하잖아요.
순서는 제가 여러분에게 순서를 주기 때문입니다. 그게 바로

1886
00:42:58,870 --> 00:42:59,910
순서는 제가 여러분에게 순서를 주기 때문입니다. 그게 바로
 

1887
00:42:59,910 --> 00:42:59,920

 

1888
00:42:59,920 --> 00:43:02,470

입력 게이트였죠.

1889
00:43:02,470 --> 00:43:02,480
입력 게이트였죠.
 

1890
00:43:02,480 --> 00:43:03,510
입력 게이트였죠.

1891
00:43:03,510 --> 00:43:03,520

 

1892
00:43:03,520 --> 00:43:05,750

이해되시나요? 좋습니다.

1893
00:43:05,750 --> 00:43:06,870
이해되시나요? 좋습니다.
 

1894
00:43:06,870 --> 00:43:06,880

 

1895
00:43:06,880 --> 00:43:10,069

크기가 log n인 AVL 트리가 있는데, 이걸

1896
00:43:10,069 --> 00:43:10,079
크기가 log n인 AVL 트리가 있는데, 이걸
 

1897
00:43:10,079 --> 00:43:13,670
크기가 log n인 AVL 트리가 있는데, 이걸
어떤

1898
00:43:13,670 --> 00:43:13,680
어떤
 

1899
00:43:13,680 --> 00:43:15,829
어떤
값으로 설정해야 할까요? 선호도의 절댓값으로 설정해야 할까요,

1900
00:43:15,829 --> 00:43:15,839
값으로 설정해야 할까요? 선호도의 절댓값으로 설정해야 할까요,
 

1901
00:43:15,839 --> 00:43:17,349
값으로 설정해야 할까요? 선호도의 절댓값으로 설정해야 할까요,
아니면

1902
00:43:17,349 --> 00:43:17,359
아니면
 

1903
00:43:17,359 --> 00:43:18,870
아니면
의견의 절댓값으로 설정해야 할까요? 이름이 정확히 기억나지 않지만,

1904
00:43:18,870 --> 00:43:20,630
의견의 절댓값으로 설정해야 할까요? 이름이 정확히 기억나지 않지만,
 

1905
00:43:20,630 --> 00:43:20,640

 

1906
00:43:20,640 --> 00:43:28,150

여기에 log n개의 항목을 넣어야 할까요? 저는

1907
00:43:28,150 --> 00:43:31,270

 

1908
00:43:31,270 --> 00:43:31,280

 

1909
00:43:31,280 --> 00:43:32,069

이런 것들에 대해 아무것도 몰라요. 무엇이 어떤 것을

1910
00:43:32,069 --> 00:43:32,079
이런 것들에 대해 아무것도 몰라요. 무엇이 어떤 것을
 

1911
00:43:32,079 --> 00:43:35,109
이런 것들에 대해 아무것도 몰라요. 무엇이 어떤 것을
다른 것보다 더 좋게 만드는 걸까요? 일단

1912
00:43:35,109 --> 00:43:35,119
다른 것보다 더 좋게 만드는 걸까요? 일단
 

1913
00:43:35,119 --> 00:43:37,910
다른 것보다 더 좋게 만드는 걸까요? 일단
첫 번째 log 값을 의미 있는 것들에 넣어보죠. 자,

1914
00:43:37,910 --> 00:43:39,589
첫 번째 log 값을 의미 있는 것들에 넣어보죠. 자,
 

1915
00:43:39,589 --> 00:43:43,270

 

1916
00:43:43,270 --> 00:43:43,280

 

1917
00:43:43,280 --> 00:43:45,270

이제 이 항목을 넣었으니,

1918
00:43:45,270 --> 00:43:45,280
이제 이 항목을 넣었으니,
 

1919
00:43:45,280 --> 00:43:49,589
이제 이 항목을 넣었으니,
얼마나 걸렸는지 알 수 있겠죠?

1920
00:43:49,589 --> 00:43:49,599

 

1921
00:43:49,599 --> 00:43:53,990

log n 곱하기 log log n

1922
00:43:53,990 --> 00:43:54,000
log n 곱하기 log log n
 

1923
00:43:54,000 --> 00:43:56,950
log n 곱하기 log log n
시간입니다. 하지만 이건 우리가 원하는

1924
00:43:56,950 --> 00:43:56,960
시간입니다. 하지만 이건 우리가 원하는
 

1925
00:43:56,960 --> 00:43:58,390
시간입니다. 하지만 이건 우리가 원하는
실행 시간보다 훨씬 짧죠? 그러니까 실행 시간은 중요하지

1926
00:43:58,390 --> 00:43:58,400
실행 시간보다 훨씬 짧죠? 그러니까 실행 시간은 중요하지
 

1927
00:43:58,400 --> 00:44:00,230
실행 시간보다 훨씬 짧죠? 그러니까 실행 시간은 중요하지
않아요. 물론

1928
00:44:00,230 --> 00:44:01,510
않아요. 물론
 

1929
00:44:01,510 --> 00:44:01,520

 

1930
00:44:01,520 --> 00:44:03,910

얼마나 걸렸는지는 말해야겠지만,

1931
00:44:03,910 --> 00:44:03,920
얼마나 걸렸는지는 말해야겠지만,
 

1932
00:44:03,920 --> 00:44:04,630
얼마나 걸렸는지는 말해야겠지만,

1933
00:44:04,630 --> 00:44:04,640

 

1934
00:44:04,640 --> 00:44:06,390

제 목적에는

1935
00:44:06,390 --> 00:44:06,400
제 목적에는
 

1936
00:44:06,400 --> 00:44:07,750
제 목적에는
실행 시간보다 짧다는 것만 알면 됩니다. 이

1937
00:44:07,750 --> 00:44:07,760
실행 시간보다 짧다는 것만 알면 됩니다. 이
 

1938
00:44:07,760 --> 00:44:07,990
실행 시간보다 짧다는 것만 알면 됩니다. 이

1939
00:44:07,990 --> 00:44:08,000

 

1940
00:44:08,000 --> 00:44:10,309

연산은 한 번만 수행했으니 더 이상 신경 쓰지 않아도 됩니다. 네,

1941
00:44:10,309 --> 00:44:11,750
연산은 한 번만 수행했으니 더 이상 신경 쓰지 않아도 됩니다. 네,
 

1942
00:44:11,750 --> 00:44:11,760

 

1943
00:44:11,760 --> 00:44:15,109

log n은 어떻게 나온 거죠?

1944
00:44:15,109 --> 00:44:15,119
log n은 어떻게 나온 거죠?
 

1945
00:44:15,119 --> 00:44:16,870
log n은 어떻게 나온 거죠?
여기에 저장하는 항목의 개수가

1946
00:44:16,870 --> 00:44:16,880
여기에 저장하는 항목의 개수가
 

1947
00:44:16,880 --> 00:44:18,870
여기에 저장하는 항목의 개수가
log n

1948
00:44:18,870 --> 00:44:18,880
log n
 

1949
00:44:18,880 --> 00:44:21,990
log n
이기 때문입니다.  만약 제가

1950
00:44:21,990 --> 00:44:22,000
이기 때문입니다.  만약 제가
 

1951
00:44:22,000 --> 00:44:24,230
이기 때문입니다.  만약 제가
AVL 트리의 생성 시간을 패턴 매칭하고

1952
00:44:24,230 --> 00:44:24,240
AVL 트리의 생성 시간을 패턴 매칭하고
 

1953
00:44:24,240 --> 00:44:26,150
AVL 트리의 생성 시간을 패턴 매칭하고
거기에 log n을 넣으면,

1954
00:44:26,150 --> 00:44:26,160
거기에 log n을 넣으면,
 

1955
00:44:26,160 --> 00:44:29,270
거기에 log n을 넣으면,
log n 곱하기 log log n이 되겠죠. 알겠습니다. 그럼 그게 한 번의 반복에 대한 건가요?

1956
00:44:29,270 --> 00:44:33,349
log n 곱하기 log log n이 되겠죠. 알겠습니다. 그럼 그게 한 번의 반복에 대한 건가요?
 

1957
00:44:33,349 --> 00:44:33,359

 

1958
00:44:33,359 --> 00:44:34,790

지금 저는 방금 이걸 생성했잖아요. 아마

1959
00:44:34,790 --> 00:44:36,710
지금 저는 방금 이걸 생성했잖아요. 아마
 

1960
00:44:36,710 --> 00:44:36,720

 

1961
00:44:36,720 --> 00:44:39,829

한 번만 생성했으니

1962
00:44:39,829 --> 00:44:41,829
한 번만 생성했으니
 

1963
00:44:41,829 --> 00:44:41,839

 

1964
00:44:41,839 --> 00:44:43,430

다시 생성할 필요가 없을 거라고 단언하고 있는 거죠. 그럼

1965
00:44:43,430 --> 00:44:43,440
다시 생성할 필요가 없을 거라고 단언하고 있는 거죠. 그럼
 

1966
00:44:43,440 --> 00:44:46,309
다시 생성할 필요가 없을 거라고 단언하고 있는 거죠. 그럼
대신 뭘 할 수 있을까요?

1967
00:44:46,309 --> 00:44:46,319
대신 뭘 할 수 있을까요?
 

1968
00:44:46,319 --> 00:44:46,950
대신 뭘 할 수 있을까요?
지금

1969
00:44:46,950 --> 00:44:46,960
지금
 

1970
00:44:46,960 --> 00:44:50,790
지금
저는 데이터를 전혀 필터링하지 않았어요. 그냥

1971
00:44:50,790 --> 00:44:52,870
저는 데이터를 전혀 필터링하지 않았어요. 그냥
 

1972
00:44:52,870 --> 00:44:52,880

 

1973
00:44:52,880 --> 00:44:54,150

어떤 식으로든 정렬된 순서로 저장하고 있는 거죠.

1974
00:44:54,150 --> 00:44:57,910
어떤 식으로든 정렬된 순서로 저장하고 있는 거죠.
 

1975
00:44:57,910 --> 00:44:57,920

 

1976
00:44:57,920 --> 00:45:00,069

나머지 데이터를 처리하려면 어떻게 해야 할까요?

1977
00:45:00,069 --> 00:45:01,589
나머지 데이터를 처리하려면 어떻게 해야 할까요?
 

1978
00:45:01,589 --> 00:45:01,599

 

1979
00:45:01,599 --> 00:45:04,309

음, 목록을 스크롤하면서 '이건 너무

1980
00:45:04,309 --> 00:45:04,319
음, 목록을 스크롤하면서 '이건 너무
 

1981
00:45:04,319 --> 00:45:05,510
음, 목록을 스크롤하면서 '이건 너무

1982
00:45:05,510 --> 00:45:08,150

 

1983
00:45:08,150 --> 00:45:08,160

 

1984
00:45:08,160 --> 00:45:09,430

커'라는 걸 알려주고,

1985
00:45:09,430 --> 00:45:09,440
커'라는 걸 알려주고,
 

1986
00:45:09,440 --> 00:45:12,790
커'라는 걸 알려주고,
최대값을 유지하면서

1987
00:45:12,790 --> 00:45:15,190
최대값을 유지하면서
 

1988
00:45:15,190 --> 00:45:15,200

 

1989
00:45:15,200 --> 00:45:16,069

항목을 삽입하고,

1990
00:45:16,069 --> 00:45:19,510
항목을 삽입하고,
 

1991
00:45:19,510 --> 00:45:19,520

 

1992
00:45:19,520 --> 00:45:21,349

계속 정렬 상태를 유지하는 건 좀 그렇죠. 그렇게 계속 항목을 추가하면

1993
00:45:21,349 --> 00:45:21,359
계속 정렬 상태를 유지하는 건 좀 그렇죠. 그렇게 계속 항목을 추가하면
 

1994
00:45:21,359 --> 00:45:23,270
계속 정렬 상태를 유지하는 건 좀 그렇죠. 그렇게 계속 항목을 추가하면
결국 정렬된 목록이 남게 되고,

1995
00:45:23,270 --> 00:45:23,280
결국 정렬된 목록이 남게 되고,
 

1996
00:45:23,280 --> 00:45:26,230
결국 정렬된 목록이 남게 되고,
이제

1997
00:45:26,230 --> 00:45:26,240
이제
 

1998
00:45:26,240 --> 00:45:29,510
이제
가장 큰 k개의 항목만 읽어낼 수 있겠죠. 하지만

1999
00:45:29,510 --> 00:45:29,520
가장 큰 k개의 항목만 읽어낼 수 있겠죠. 하지만
 

2000
00:45:29,520 --> 00:45:33,270
가장 큰 k개의 항목만 읽어낼 수 있겠죠. 하지만
항목을 추가할수록 목록이 커지니까,

2001
00:45:33,270 --> 00:45:35,670
항목을 추가할수록 목록이 커지니까,
 

2002
00:45:35,670 --> 00:45:35,680

 

2003
00:45:35,680 --> 00:45:36,870

작은 항목을 삭제하면 되겠네요. 아, 작은 항목 삭제, 재밌겠다. 좋은

2004
00:45:36,870 --> 00:45:36,880
작은 항목을 삭제하면 되겠네요. 아, 작은 항목 삭제, 재밌겠다. 좋은
 

2005
00:45:36,880 --> 00:45:39,829
작은 항목을 삭제하면 되겠네요. 아, 작은 항목 삭제, 재밌겠다. 좋은
아이디어네요. 네, 기본적으로 그렇습니다.

2006
00:45:39,829 --> 00:45:39,839
아이디어네요. 네, 기본적으로 그렇습니다.
 

2007
00:45:39,839 --> 00:45:41,510
아이디어네요. 네, 기본적으로 그렇습니다.
기본적으로 교체하는 거죠.

2008
00:45:41,510 --> 00:45:41,520
기본적으로 교체하는 거죠.
 

2009
00:45:41,520 --> 00:45:44,630
기본적으로 교체하는 거죠.
제가 제안하는 방법은 이렇습니다.

2010
00:45:44,630 --> 00:45:44,640
제가 제안하는 방법은 이렇습니다.
 

2011
00:45:44,640 --> 00:45:47,430
제가 제안하는 방법은 이렇습니다.
다음 개체를 가져와서 넣습니다.

2012
00:45:47,430 --> 00:45:48,950
다음 개체를 가져와서 넣습니다.
 

2013
00:45:48,950 --> 00:45:48,960

 

2014
00:45:48,960 --> 00:45:53,829

멋지네요. 어떤 게 제가 신경 안 쓰는 거죠? 가장

2015
00:45:53,829 --> 00:45:53,839
멋지네요. 어떤 게 제가 신경 안 쓰는 거죠? 가장
 

2016
00:45:53,839 --> 00:45:55,990
멋지네요. 어떤 게 제가 신경 안 쓰는 거죠? 가장
작은 개체입니다. 그럼 가장 작은 개체를 빼내겠습니다. 방금 넣은 이 개체가

2017
00:45:55,990 --> 00:45:57,750
작은 개체입니다. 그럼 가장 작은 개체를 빼내겠습니다. 방금 넣은 이 개체가
 

2018
00:45:57,750 --> 00:46:00,230

 

2019
00:46:00,230 --> 00:46:00,240

 

2020
00:46:00,240 --> 00:46:00,950

가장 작을 수도 있겠네요. 이렇게 해서

2021
00:46:00,950 --> 00:46:02,550
가장 작을 수도 있겠네요. 이렇게 해서
 

2022
00:46:02,550 --> 00:46:02,560

 

2023
00:46:02,560 --> 00:46:04,150

이 장치를 통과시켰는데, 얼마나 걸렸을까요?

2024
00:46:04,150 --> 00:46:09,910
이 장치를 통과시켰는데, 얼마나 걸렸을까요?
 

2025
00:46:09,910 --> 00:46:09,920

 

2026
00:46:09,920 --> 00:46:11,270

이 나무 높이만큼 걸렸습니다.

2027
00:46:11,270 --> 00:46:11,280
이 나무 높이만큼 걸렸습니다.
 

2028
00:46:11,280 --> 00:46:13,589
이 나무 높이만큼 걸렸습니다.
나무 높이는 log log n

2029
00:46:13,589 --> 00:46:13,599
나무 높이는 log log n
 

2030
00:46:13,599 --> 00:46:17,589
나무 높이는 log log n
이죠. 하나를 넣고

2031
00:46:17,589 --> 00:46:17,599
이죠. 하나를 넣고
 

2032
00:46:17,599 --> 00:46:20,710
이죠. 하나를 넣고
하나를 빼내는데, 이게 가장 작은 개체입니다. 이렇게 계속 쭉 반복합니다.

2033
00:46:20,710 --> 00:46:22,150
하나를 빼내는데, 이게 가장 작은 개체입니다. 이렇게 계속 쭉 반복합니다.
 

2034
00:46:22,150 --> 00:46:22,160

 

2035
00:46:22,160 --> 00:46:28,550

얼마나 걸렸을까요? 네, n에서

2036
00:46:28,550 --> 00:46:28,560
얼마나 걸렸을까요? 네, n에서
 

2037
00:46:28,560 --> 00:46:31,589
얼마나 걸렸을까요? 네, n에서
log n을 뺀 만큼,

2038
00:46:31,589 --> 00:46:31,599
log n을 뺀 만큼,
 

2039
00:46:31,599 --> 00:46:34,790
log n을 뺀 만큼,
즉 n만큼 처리했습니다.

2040
00:46:34,790 --> 00:46:34,800
즉 n만큼 처리했습니다.
 

2041
00:46:34,800 --> 00:46:36,870
즉 n만큼 처리했습니다.
각 작업에

2042
00:46:36,870 --> 00:46:36,880
각 작업에
 

2043
00:46:36,880 --> 00:46:38,790
각 작업에
나무 높이만큼의 시간이 걸렸습니다.

2044
00:46:38,790 --> 00:46:38,800
나무 높이만큼의 시간이 걸렸습니다.
 

2045
00:46:38,800 --> 00:46:40,630
나무 높이만큼의 시간이 걸렸습니다.
그래서 우리가 찾던 실행 시간이 나오는 겁니다.

2046
00:46:40,630 --> 00:46:42,470
그래서 우리가 찾던 실행 시간이 나오는 겁니다.
 

2047
00:46:42,470 --> 00:46:42,480

 

2048
00:46:42,480 --> 00:46:45,829

log log n, 네,

2049
00:46:45,829 --> 00:46:47,589
log log n, 네,
 

2050
00:46:47,589 --> 00:46:47,599

 

2051
00:46:47,599 --> 00:46:49,829

슬라이드처럼요. 슬라이딩

2052
00:46:49,829 --> 00:46:49,839
슬라이드처럼요. 슬라이딩
 

2053
00:46:49,839 --> 00:46:51,750
슬라이드처럼요. 슬라이딩
윈도우 기법인데,

2054
00:46:51,750 --> 00:46:51,760
윈도우 기법인데,
 

2055
00:46:51,760 --> 00:46:56,470
윈도우 기법인데,
최근에 사용해 보셨을 수도 있습니다. 네,

2056
00:46:56,470 --> 00:46:56,480
최근에 사용해 보셨을 수도 있습니다. 네,
 

2057
00:46:56,480 --> 00:46:59,109
최근에 사용해 보셨을 수도 있습니다. 네,
모두 이해하셨죠? 네,

2058
00:46:59,109 --> 00:46:59,119
모두 이해하셨죠? 네,
 

2059
00:46:59,119 --> 00:46:59,510
모두 이해하셨죠? 네,

2060
00:46:59,510 --> 00:46:59,520

 

2061
00:46:59,520 --> 00:47:01,349

우리가 이야기하는 맥락을 다시 한번 정리해 보겠습니다.

2062
00:47:01,349 --> 00:47:01,359
우리가 이야기하는 맥락을 다시 한번 정리해 보겠습니다.
 

2063
00:47:01,359 --> 00:47:02,710
우리가 이야기하는 맥락을 다시 한번 정리해 보겠습니다.
log

2064
00:47:02,710 --> 00:47:02,720
log
 

2065
00:47:02,720 --> 00:47:05,510
log
log n, 즉 나무이고, 어디에 있는 거죠?

2066
00:47:05,510 --> 00:47:05,520
log n, 즉 나무이고, 어디에 있는 거죠?
 

2067
00:47:05,520 --> 00:47:05,990
log n, 즉 나무이고, 어디에 있는 거죠?
이

2068
00:47:05,990 --> 00:47:06,000
이
 

2069
00:47:06,000 --> 00:47:08,950
이
개체의 크기는 log log n입니다. 아,

2070
00:47:08,950 --> 00:47:08,960
개체의 크기는 log log n입니다. 아,
 

2071
00:47:08,960 --> 00:47:09,670
개체의 크기는 log log n입니다. 아,
죄송합니다.

2072
00:47:09,670 --> 00:47:09,680
죄송합니다.
 

2073
00:47:09,680 --> 00:47:11,750
죄송합니다.
log n이고 이 객체의 높이는

2074
00:47:11,750 --> 00:47:13,190
log n이고 이 객체의 높이는
 

2075
00:47:13,190 --> 00:47:13,200

 

2076
00:47:13,200 --> 00:47:16,309

크기의 로그 값입니다. 마치

2077
00:47:16,309 --> 00:47:16,319

 

2078
00:47:16,319 --> 00:47:18,069

작은

2079
00:47:18,069 --> 00:47:18,079
작은
 

2080
00:47:18,079 --> 00:47:19,670
작은
로그인 크기처럼요.

2081
00:47:19,670 --> 00:47:19,680
로그인 크기처럼요.
 

2082
00:47:19,680 --> 00:47:23,030
로그인 크기처럼요.
바로 저기에

2083
00:47:23,030 --> 00:47:23,040
바로 저기에
 

2084
00:47:23,040 --> 00:47:26,150
바로 저기에
작은 로그 항목들을 가득 채워 넣는 것처럼요. 아니,

2085
00:47:26,150 --> 00:47:26,160
작은 로그 항목들을 가득 채워 넣는 것처럼요. 아니,
 

2086
00:47:26,160 --> 00:47:27,030
작은 로그 항목들을 가득 채워 넣는 것처럼요. 아니,
죄송합니다.

2087
00:47:27,030 --> 00:47:27,040
죄송합니다.
 

2088
00:47:27,040 --> 00:47:29,990
죄송합니다.
제가 지금 이 내용을 다루고 있는데,

2089
00:47:29,990 --> 00:47:30,000
제가 지금 이 내용을 다루고 있는데,
 

2090
00:47:30,000 --> 00:47:31,910
제가 지금 이 내용을 다루고 있는데,
여기에는 중간 데이터 구조가 없습니다.

2091
00:47:31,910 --> 00:47:31,920
여기에는 중간 데이터 구조가 없습니다.
 

2092
00:47:31,920 --> 00:47:34,069
여기에는 중간 데이터 구조가 없습니다.
그냥 이 모든 것들을

2093
00:47:34,069 --> 00:47:34,079
그냥 이 모든 것들을
 

2094
00:47:34,079 --> 00:47:35,430
그냥 이 모든 것들을
via

2095
00:47:35,430 --> 00:47:35,440
via
 

2096
00:47:35,440 --> 00:47:38,950
via
bsta, 그러니까 set abl, 네,

2097
00:47:38,950 --> 00:47:38,960
bsta, 그러니까 set abl, 네,
 

2098
00:47:38,960 --> 00:47:43,109
bsta, 그러니까 set abl, 네,
하나의 set avl, 크기가 log n인 객체에 넣는 겁니다. 사람을 넣고

2099
00:47:43,109 --> 00:47:46,630
하나의 set avl, 크기가 log n인 객체에 넣는 겁니다. 사람을 넣고
 

2100
00:47:46,630 --> 00:47:46,640

 

2101
00:47:46,640 --> 00:47:49,030

가장 나쁜 사람을 빼내는 식으로요. 넣을

2102
00:47:49,030 --> 00:47:49,670
가장 나쁜 사람을 빼내는 식으로요. 넣을
 

2103
00:47:49,670 --> 00:47:49,680

 

2104
00:47:49,680 --> 00:47:51,589

때

2105
00:47:51,589 --> 00:47:52,790
때
 

2106
00:47:52,790 --> 00:47:52,800

 

2107
00:47:52,800 --> 00:47:55,109

어떤 복수자

2108
00:47:55,109 --> 00:47:55,119
어떤 복수자
 

2109
00:47:55,119 --> 00:47:56,950
어떤 복수자
인지 추적하고, 절댓값을 취하고, 그런 자잘한 것들을

2110
00:47:56,950 --> 00:47:56,960
인지 추적하고, 절댓값을 취하고, 그런 자잘한 것들을
 

2111
00:47:56,960 --> 00:47:58,230
인지 추적하고, 절댓값을 취하고, 그런 자잘한 것들을
다 확인하는 거죠.

2112
00:47:58,230 --> 00:47:58,240
다 확인하는 거죠.
 

2113
00:47:58,240 --> 00:48:00,470
다 확인하는 거죠.
하지만

2114
00:48:00,470 --> 00:48:00,480
하지만
 

2115
00:48:00,480 --> 00:48:02,150
하지만
기본적인 아이디어는 이렇습니다.

2116
00:48:02,150 --> 00:48:02,160
기본적인 아이디어는 이렇습니다.
 

2117
00:48:02,160 --> 00:48:04,230
기본적인 아이디어는 이렇습니다.
창을 밀어 넣고,

2118
00:48:04,230 --> 00:48:05,589
창을 밀어 넣고,
 

2119
00:48:05,589 --> 00:48:05,599

 

2120
00:48:05,599 --> 00:48:07,510

뭔가를 넣고, 뭔가를 빼내는 거죠. 그게

2121
00:48:07,510 --> 00:48:09,430
뭔가를 넣고, 뭔가를 빼내는 거죠. 그게
 

2122
00:48:09,430 --> 00:48:09,440

 

2123
00:48:09,440 --> 00:48:10,230


2124
00:48:10,230 --> 00:48:10,240

 

2125
00:48:10,240 --> 00:48:12,790

같은 건 아닐 수도 있고, 아마 아닐 수도 있겠죠. 이 절차의 마지막에

2126
00:48:12,790 --> 00:48:12,800
같은 건 아닐 수도 있고, 아마 아닐 수도 있겠죠. 이 절차의 마지막에
 

2127
00:48:12,800 --> 00:48:13,990
같은 건 아닐 수도 있고, 아마 아닐 수도 있겠죠. 이 절차의 마지막에

2128
00:48:13,990 --> 00:48:14,000

 

2129
00:48:14,000 --> 00:48:16,630

제가 유지하는 불변 조건은

2130
00:48:16,630 --> 00:48:16,640
제가 유지하는 불변 조건은
 

2131
00:48:16,640 --> 00:48:18,549
제가 유지하는 불변 조건은
제 객체가

2132
00:48:18,549 --> 00:48:22,790
제 객체가
 

2133
00:48:22,790 --> 00:48:22,800

 

2134
00:48:22,800 --> 00:48:24,710

지금까지 처리한 것들 중에서 가장 큰 k개의 의견을 항상 가지고 있다는 겁니다. 물론

2135
00:48:24,710 --> 00:48:25,990
지금까지 처리한 것들 중에서 가장 큰 k개의 의견을 항상 가지고 있다는 겁니다. 물론
 

2136
00:48:25,990 --> 00:48:26,000

 

2137
00:48:26,000 --> 00:48:27,750

처음에 만들 때는 당연히 그렇죠.  이걸 처리하고 나면

2138
00:48:27,750 --> 00:48:29,829
처음에 만들 때는 당연히 그렇죠.  이걸 처리하고 나면
 

2139
00:48:29,829 --> 00:48:29,839

 

2140
00:48:29,839 --> 00:48:30,870

모든 걸 다 처리한 셈이 되는데,

2141
00:48:30,870 --> 00:48:30,880
모든 걸 다 처리한 셈이 되는데,
 

2142
00:48:30,880 --> 00:48:34,230
모든 걸 다 처리한 셈이 되는데,
크기가 log n이에요. 그러니까

2143
00:48:34,230 --> 00:48:34,240
크기가 log n이에요. 그러니까
 

2144
00:48:34,240 --> 00:48:37,910
크기가 log n이에요. 그러니까
log n개의

2145
00:48:37,910 --> 00:48:37,920
log n개의
 

2146
00:48:37,920 --> 00:48:41,670
log n개의
가장 극단적인 의견들을 모아놓은 거죠.

2147
00:48:41,670 --> 00:48:41,680
가장 극단적인 의견들을 모아놓은 거죠.
 

2148
00:48:41,680 --> 00:48:43,349
가장 극단적인 의견들을 모아놓은 거죠.
그리고 이걸 중위

2149
00:48:43,349 --> 00:48:43,359
그리고 이걸 중위
 

2150
00:48:43,359 --> 00:48:44,950
그리고 이걸 중위
순회하면서 읽고

2151
00:48:44,950 --> 00:48:44,960
순회하면서 읽고
 

2152
00:48:44,960 --> 00:48:47,430
순회하면서 읽고
반환하면 돼요. 이해되시나요? 그리고 저는

2153
00:48:47,430 --> 00:48:48,790
반환하면 돼요. 이해되시나요? 그리고 저는
 

2154
00:48:48,790 --> 00:48:48,800

 

2155
00:48:48,800 --> 00:48:52,309

로그 공간만 사용했어요. 아, 네.

2156
00:48:52,309 --> 00:48:52,319

 

2157
00:48:52,319 --> 00:48:56,790

그런데 잘 이해가 안 가네요. 모든

2158
00:48:56,790 --> 00:48:56,800
그런데 잘 이해가 안 가네요. 모든
 

2159
00:48:56,800 --> 00:48:59,990
그런데 잘 이해가 안 가네요. 모든
의견이 그

2160
00:48:59,990 --> 00:49:00,000
의견이 그
 

2161
00:49:00,000 --> 00:49:02,309
의견이 그
avl 트리에 있는 건가요? 모든 의견이 abl

2162
00:49:02,309 --> 00:49:04,309
avl 트리에 있는 건가요? 모든 의견이 abl
 

2163
00:49:04,309 --> 00:49:04,319

 

2164
00:49:04,319 --> 00:49:05,430

트리에 있는 거죠?

2165
00:49:05,430 --> 00:49:05,440
트리에 있는 거죠?
 

2166
00:49:05,440 --> 00:49:08,470
트리에 있는 거죠?
그리고 언젠가

2167
00:49:08,470 --> 00:49:08,480
그리고 언젠가
 

2168
00:49:08,480 --> 00:49:11,510
그리고 언젠가
모든

2169
00:49:11,510 --> 00:49:11,520
모든
 

2170
00:49:11,520 --> 00:49:14,630
모든
의견을 이 abl 트리에 삽입할 건데, 그러면서 필요

2171
00:49:14,630 --> 00:49:14,640
의견을 이 abl 트리에 삽입할 건데, 그러면서 필요
 

2172
00:49:14,640 --> 00:49:17,190
의견을 이 abl 트리에 삽입할 건데, 그러면서 필요
없는 의견은 제거할 거예요. 이해되시나요?

2173
00:49:17,190 --> 00:49:18,150
없는 의견은 제거할 거예요. 이해되시나요?
 

2174
00:49:18,150 --> 00:49:19,510

 

2175
00:49:19,510 --> 00:49:21,750

 

2176
00:49:21,750 --> 00:49:24,630

 

2177
00:49:24,630 --> 00:49:24,640

 

2178
00:49:24,640 --> 00:49:25,910

삽입하기 전에는 항상

2179
00:49:25,910 --> 00:49:25,920
삽입하기 전에는 항상
 

2180
00:49:25,920 --> 00:49:28,790
삽입하기 전에는 항상
log n개의 항목이 있다는 불변 조건을 유지하고, 하나를 넣고 하나를 빼면서

2181
00:49:28,790 --> 00:49:28,800
log n개의 항목이 있다는 불변 조건을 유지하고, 하나를 넣고 하나를 빼면서
 

2182
00:49:28,800 --> 00:49:29,990
log n개의 항목이 있다는 불변 조건을 유지하고, 하나를 넣고 하나를 빼면서
그 불변 조건을 유지하는 거예요.

2183
00:49:29,990 --> 00:49:30,000
그 불변 조건을 유지하는 거예요.
 

2184
00:49:30,000 --> 00:49:32,790
그 불변 조건을 유지하는 거예요.
아,

2185
00:49:32,790 --> 00:49:32,800
아,
 

2186
00:49:32,800 --> 00:49:35,190
아,
그렇군요. 그럼

2187
00:49:35,190 --> 00:49:35,200
그렇군요. 그럼
 

2188
00:49:35,200 --> 00:49:36,950
그렇군요. 그럼
항상 최소값을 선택하는 거죠? 저는

2189
00:49:36,950 --> 00:49:36,960
항상 최소값을 선택하는 거죠? 저는
 

2190
00:49:36,960 --> 00:49:38,630
항상 최소값을 선택하는 거죠? 저는
가장 큰 의견들을 원하니까요. 그리고

2191
00:49:38,630 --> 00:49:38,640
가장 큰 의견들을 원하니까요. 그리고
 

2192
00:49:38,640 --> 00:49:41,990
가장 큰 의견들을 원하니까요. 그리고
절댓값 기준으로 중간값을 선택하는 거예요. 네,

2193
00:49:41,990 --> 00:49:42,000
절댓값 기준으로 중간값을 선택하는 거예요. 네,
 

2194
00:49:42,000 --> 00:49:43,990
절댓값 기준으로 중간값을 선택하는 거예요. 네,
그러니까 의견들의 절댓값을 기준으로 키를 정하는 거죠.

2195
00:49:43,990 --> 00:49:48,390
그러니까 의견들의 절댓값을 기준으로 키를 정하는 거죠.
 

2196
00:49:48,390 --> 00:49:48,400

 

2197
00:49:48,400 --> 00:49:51,349

여기서 총 실행 시간은

2198
00:49:51,349 --> 00:49:51,359
여기서 총 실행 시간은
 

2199
00:49:51,359 --> 00:49:52,470
여기서 총 실행 시간은
계산하는 거예요.

2200
00:49:52,470 --> 00:49:56,390
계산하는 거예요.
 

2201
00:49:56,390 --> 00:50:00,069

 

2202
00:50:00,069 --> 00:50:02,470

 

2203
00:50:02,470 --> 00:50:02,480

 

2204
00:50:02,480 --> 00:50:04,069

처음에 이 데이터 구조를 구축하는 데 log n 곱하기 log log n 시간이 걸렸습니다. 즉, n 곱하기

2205
00:50:04,069 --> 00:50:07,670
처음에 이 데이터 구조를 구축하는 데 log n 곱하기 log log n 시간이 걸렸습니다. 즉, n 곱하기
 

2206
00:50:07,670 --> 00:50:07,680

 

2207
00:50:07,680 --> 00:50:10,870

log log n에 더해서

2208
00:50:10,870 --> 00:50:10,880
log log n에 더해서
 

2209
00:50:10,880 --> 00:50:13,829
log log n에 더해서
기본적으로 n번의 연산이 필요하고,

2210
00:50:13,829 --> 00:50:14,870
기본적으로 n번의 연산이 필요하고,
 

2211
00:50:14,870 --> 00:50:14,880

 

2212
00:50:14,880 --> 00:50:16,390

이런 방식으로 연산을 하면 실제로는 n에서

2213
00:50:16,390 --> 00:50:16,400
이런 방식으로 연산을 하면 실제로는 n에서
 

2214
00:50:16,400 --> 00:50:17,990
이런 방식으로 연산을 하면 실제로는 n에서
log n을 뺀 연산이 됩니다.

2215
00:50:17,990 --> 00:50:18,000
log n을 뺀 연산이 됩니다.
 

2216
00:50:18,000 --> 00:50:20,390
log n을 뺀 연산이 됩니다.
그리고 각각의 연산, 즉

2217
00:50:20,390 --> 00:50:22,630
그리고 각각의 연산, 즉
 

2218
00:50:22,630 --> 00:50:22,640

 

2219
00:50:22,640 --> 00:50:25,190

삽입과 삭제를 할 때마다

2220
00:50:25,190 --> 00:50:26,069
삽입과 삭제를 할 때마다
 

2221
00:50:26,069 --> 00:50:26,079

 

2222
00:50:26,079 --> 00:50:29,510

트리의 높이만큼의 시간이 걸립니다. 그래서

2223
00:50:29,510 --> 00:50:29,520
트리의 높이만큼의 시간이 걸립니다. 그래서
 

2224
00:50:29,520 --> 00:50:32,710
트리의 높이만큼의 시간이 걸립니다. 그래서
이게 좋은 겁니다.

2225
00:50:32,710 --> 00:50:32,720
이게 좋은 겁니다.
 

2226
00:50:32,720 --> 00:50:35,430
이게 좋은 겁니다.
만약 그냥 삽입

2227
00:50:35,430 --> 00:50:35,440
만약 그냥 삽입
 

2228
00:50:35,440 --> 00:50:36,549
만약 그냥 삽입
하고

2229
00:50:36,549 --> 00:50:36,559
하고
 

2230
00:50:36,559 --> 00:50:39,430
하고
비교를 한다면,

2231
00:50:39,430 --> 00:50:42,309
비교를 한다면,
 

2232
00:50:42,309 --> 00:50:42,319

 

2233
00:50:42,319 --> 00:50:44,950

집합 AVL 트리에서 삽입과 삭제는 실제로

2234
00:50:44,950 --> 00:50:44,960
집합 AVL 트리에서 삽입과 삭제는 실제로
 

2235
00:50:44,960 --> 00:50:46,870
집합 AVL 트리에서 삽입과 삭제는 실제로
데이터 구조 내에서 비교를 하는 것입니다.

2236
00:50:46,870 --> 00:50:46,880
데이터 구조 내에서 비교를 하는 것입니다.
 

2237
00:50:46,880 --> 00:50:48,390
데이터 구조 내에서 비교를 하는 것입니다.
즉, n과 비교하는 것이죠.  확실히

2238
00:50:48,390 --> 00:50:48,400
즉, n과 비교하는 것이죠.  확실히
 

2239
00:50:48,400 --> 00:50:49,190
즉, n과 비교하는 것이죠.  확실히
그렇게 할 수 있겠죠? 그렇죠?

2240
00:50:49,190 --> 00:50:51,430
그렇게 할 수 있겠죠? 그렇죠?
 

2241
00:50:51,430 --> 00:50:51,440

 

2242
00:50:51,440 --> 00:50:52,309

반대로도 할 수 있어요.

2243
00:50:52,309 --> 00:50:56,630
반대로도 할 수 있어요.
 

2244
00:50:56,630 --> 00:50:57,670

 

2245
00:50:57,670 --> 00:50:57,680

 

2246
00:50:57,680 --> 00:51:00,150

먼저 여기서 가장 작은 요소를 제거하고, 이 요소와 비교해서 더

2247
00:51:00,150 --> 00:51:00,160
먼저 여기서 가장 작은 요소를 제거하고, 이 요소와 비교해서 더
 

2248
00:51:00,160 --> 00:51:00,790
먼저 여기서 가장 작은 요소를 제거하고, 이 요소와 비교해서 더

2249
00:51:00,790 --> 00:51:00,800

 

2250
00:51:00,800 --> 00:51:02,390

큰 요소를

2251
00:51:02,390 --> 00:51:02,400
큰 요소를
 

2252
00:51:02,400 --> 00:51:04,309
큰 요소를
다시 넣는 거죠.

2253
00:51:04,309 --> 00:51:04,319
다시 넣는 거죠.
 

2254
00:51:04,319 --> 00:51:07,030
다시 넣는 거죠.
같은 방식인데,

2255
00:51:07,030 --> 00:51:07,040
같은 방식인데,
 

2256
00:51:07,040 --> 00:51:08,309
같은 방식인데,
삭제를 먼저 하고

2257
00:51:08,309 --> 00:51:08,319
삭제를 먼저 하고
 

2258
00:51:08,319 --> 00:51:09,670
삭제를 먼저 하고
삽입을 할지, 아니면 삽입을

2259
00:51:09,670 --> 00:51:09,680
삽입을 할지, 아니면 삽입을
 

2260
00:51:09,680 --> 00:51:12,790
삽입을 할지, 아니면 삽입을
먼저 하고 삭제를 할지 차이가 ​​나는 거죠.

2261
00:51:12,790 --> 00:51:12,800
먼저 하고 삭제를 할지 차이가 ​​나는 거죠.
 

2262
00:51:12,800 --> 00:51:15,589
먼저 하고 삭제를 할지 차이가 ​​나는 거죠.
다른 질문 있나요? 질문이 많네요.

2263
00:51:15,589 --> 00:51:15,599
다른 질문 있나요? 질문이 많네요.
 

2264
00:51:15,599 --> 00:51:16,790
다른 질문 있나요? 질문이 많네요.
음, 아마 이

2265
00:51:16,790 --> 00:51:16,800
음, 아마 이
 

2266
00:51:16,800 --> 00:51:18,470
음, 아마 이
문제는 넘어가야 할 것 같아요. 다음으로

2267
00:51:18,470 --> 00:51:18,480
문제는 넘어가야 할 것 같아요. 다음으로
 

2268
00:51:18,480 --> 00:51:22,069
문제는 넘어가야 할 것 같아요. 다음으로
넘어가죠. C, S, C, L, R... 자,

2269
00:51:22,069 --> 00:51:25,270
넘어가죠. C, S, C, L, R... 자,
 

2270
00:51:25,270 --> 00:51:25,280

 

2271
00:51:25,280 --> 00:51:30,069

여기서 참조는 뭐죠? 네, C, L, R이요.

2272
00:51:30,069 --> 00:51:30,079

 

2273
00:51:30,079 --> 00:51:32,710

이 네 명의

2274
00:51:32,710 --> 00:51:32,720
이 네 명의
 

2275
00:51:32,720 --> 00:51:34,470
이 네 명의
학자들이 컴퓨터 과학 분야에서 유명한 교과서를 썼어요.

2276
00:51:34,470 --> 00:51:36,390
학자들이 컴퓨터 과학 분야에서 유명한 교과서를 썼어요.
 

2277
00:51:36,390 --> 00:51:36,400

 

2278
00:51:36,400 --> 00:51:38,710

이것도 비슷한 맥락이에요. 이 학자들이

2279
00:51:38,710 --> 00:51:39,750
이것도 비슷한 맥락이에요. 이 학자들이
 

2280
00:51:39,750 --> 00:51:39,760

 

2281
00:51:39,760 --> 00:51:41,510

초판본을 발견해서

2282
00:51:41,510 --> 00:51:41,520
초판본을 발견해서
 

2283
00:51:41,520 --> 00:51:44,069
초판본을 발견해서
경매에 부치려고 해요.

2284
00:51:44,069 --> 00:51:44,079
경매에 부치려고 해요.
 

2285
00:51:44,079 --> 00:51:46,390
경매에 부치려고 해요.
사람들은 웹사이트에 접속해서

2286
00:51:46,390 --> 00:51:46,400
사람들은 웹사이트에 접속해서
 

2287
00:51:46,400 --> 00:51:47,349
사람들은 웹사이트에 접속해서
고유 식별자인 입찰 ID를 가지고

2288
00:51:47,349 --> 00:51:50,069
고유 식별자인 입찰 ID를 가지고
 

2289
00:51:50,069 --> 00:51:51,349

 

2290
00:51:51,349 --> 00:51:51,359

 

2291
00:51:51,359 --> 00:51:54,390

책에 입찰할 수 있어요.

2292
00:51:54,390 --> 00:51:54,400
책에 입찰할 수 있어요.
 

2293
00:51:54,400 --> 00:51:56,790
책에 입찰할 수 있어요.
입찰 기간 동안 입찰가를 변경할 수도 있죠.

2294
00:51:56,790 --> 00:51:56,800
입찰 기간 동안 입찰가를 변경할 수도 있죠.
 

2295
00:51:56,800 --> 00:51:57,910
입찰 기간 동안 입찰가를 변경할 수도 있죠.
그런데

2296
00:51:57,910 --> 00:51:57,920
그런데
 

2297
00:51:57,920 --> 00:51:59,190
그런데
입찰 기간이 끝나면

2298
00:51:59,190 --> 00:52:01,430
입찰 기간이 끝나면
 

2299
00:52:01,430 --> 00:52:01,440

 

2300
00:52:01,440 --> 00:52:05,750

학자들은 누가 낙찰받았는지, 예상 수익이 얼마인지 알고 싶어 해요.

2301
00:52:05,750 --> 00:52:07,670
학자들은 누가 낙찰받았는지, 예상 수익이 얼마인지 알고 싶어 해요.
 

2302
00:52:07,670 --> 00:52:07,680

 

2303
00:52:07,680 --> 00:52:09,510

저는 최고 입찰자 k명에게 판매해서 수익을 낼 거예요. 이해되시나요? 네, 알겠습니다. 제가

2304
00:52:09,510 --> 00:52:13,349
저는 최고 입찰자 k명에게 판매해서 수익을 낼 거예요. 이해되시나요? 네, 알겠습니다. 제가
 

2305
00:52:13,349 --> 00:52:16,549

 

2306
00:52:16,549 --> 00:52:20,230

 

2307
00:52:20,230 --> 00:52:20,240

 

2308
00:52:20,240 --> 00:52:23,270

이 데이터 구조를 만들기 전에 k가 무엇인지 알고 있다는 점을 알아두세요. k는

2309
00:52:23,270 --> 00:52:23,280
이 데이터 구조를 만들기 전에 k가 무엇인지 알고 있다는 점을 알아두세요. k는
 

2310
00:52:23,280 --> 00:52:24,950
이 데이터 구조를 만들기 전에 k가 무엇인지 알고 있다는 점을 알아두세요. k는
고정된 값입니다.

2311
00:52:24,950 --> 00:52:24,960
고정된 값입니다.
 

2312
00:52:24,960 --> 00:52:28,470
고정된 값입니다.
왜냐하면

2313
00:52:28,470 --> 00:52:28,480
왜냐하면
 

2314
00:52:28,480 --> 00:52:29,670
왜냐하면
이 수익 계산 함수의 실행 시간이 이

2315
00:52:29,670 --> 00:52:29,680
이 수익 계산 함수의 실행 시간이 이
 

2316
00:52:29,680 --> 00:52:32,230
이 수익 계산 함수의 실행 시간이 이
k에 따라 달라지기 때문입니다. k는 이 연산의 입력값이 아닙니다.

2317
00:52:32,230 --> 00:52:33,270
k에 따라 달라지기 때문입니다. k는 이 연산의 입력값이 아닙니다.
 

2318
00:52:33,270 --> 00:52:33,280

 

2319
00:52:33,280 --> 00:52:36,309

그러니까 k는 사전에 정확히 알 수 없습니다.

2320
00:52:36,309 --> 00:52:36,710
그러니까 k는 사전에 정확히 알 수 없습니다.
 

2321
00:52:36,710 --> 00:52:36,720

 

2322
00:52:36,720 --> 00:52:39,750

n/2일 수도 있고,

2323
00:52:39,750 --> 00:52:39,760
n/2일 수도 있고,
 

2324
00:52:39,760 --> 00:52:41,430
n/2일 수도 있고,
log n일 수도 있고,

2325
00:52:41,430 --> 00:52:41,440
log n일 수도 있고,
 

2326
00:52:41,440 --> 00:52:44,829
log n일 수도 있고,
1일 수도 있습니다.

2327
00:52:44,829 --> 00:52:44,839
1일 수도 있습니다.
 

2328
00:52:44,839 --> 00:52:48,069
1일 수도 있습니다.
하지만 제가 만드는 데이터 구조는

2329
00:52:48,069 --> 00:52:49,910
하지만 제가 만드는 데이터 구조는
 

2330
00:52:49,910 --> 00:52:49,920

 

2331
00:52:49,920 --> 00:52:52,790

어떤 값을 선택하든 실행 시간 조건을 만족해야 합니다.

2332
00:52:52,790 --> 00:52:52,800
어떤 값을 선택하든 실행 시간 조건을 만족해야 합니다.
 

2333
00:52:52,800 --> 00:52:55,270
어떤 값을 선택하든 실행 시간 조건을 만족해야 합니다.
학자들이 그렇게 말했잖아요. 이해되시나요?

2334
00:52:55,270 --> 00:52:56,710
학자들이 그렇게 말했잖아요. 이해되시나요?
 

2335
00:52:56,710 --> 00:52:56,720

 

2336
00:52:56,720 --> 00:53:00,150

제가 해야 할 일은 시간이

2337
00:53:00,150 --> 00:53:00,160
제가 해야 할 일은 시간이
 

2338
00:53:00,160 --> 00:53:03,990
제가 해야 할 일은 시간이
지남에 따라 사람들이

2339
00:53:03,990 --> 00:53:04,000
지남에 따라 사람들이
 

2340
00:53:04,000 --> 00:53:06,870
지남에 따라 사람들이
새로운 입찰을 하고 입찰가를 업데이트하는 것입니다.

2341
00:53:06,870 --> 00:53:06,880
새로운 입찰을 하고 입찰가를 업데이트하는 것입니다.
 

2342
00:53:06,880 --> 00:53:07,910
새로운 입찰을 하고 입찰가를 업데이트하는 것입니다.

2343
00:53:07,910 --> 00:53:07,920

 

2344
00:53:07,920 --> 00:53:10,790

업데이트에는

2345
00:53:10,790 --> 00:53:10,800
업데이트에는
 

2346
00:53:10,800 --> 00:53:11,670
업데이트에는
시간이 더 걸릴 수 있지만,

2347
00:53:11,670 --> 00:53:11,680
시간이 더 걸릴 수 있지만,
 

2348
00:53:11,680 --> 00:53:14,710
시간이 더 걸릴 수 있지만,
창을 닫는 즉시

2349
00:53:14,710 --> 00:53:14,720
창을 닫는 즉시
 

2350
00:53:14,720 --> 00:53:17,589
창을 닫는 즉시
상수 시간 안에

2351
00:53:17,589 --> 00:53:17,599
상수 시간 안에
 

2352
00:53:17,599 --> 00:53:20,790
상수 시간 안에

2353
00:53:20,790 --> 00:53:20,800

 

2354
00:53:20,800 --> 00:53:24,549

최고 입찰자 k명을 알 수 있어야 합니다.

2355
00:53:24,549 --> 00:53:24,559
최고 입찰자 k명을 알 수 있어야 합니다.
 

2356
00:53:24,559 --> 00:53:26,950
최고 입찰자 k명을 알 수 있어야 합니다.
어떻게 하면 좋을까요? 어떤 연산을 해야 할까요?

2357
00:53:26,950 --> 00:53:29,190
어떻게 하면 좋을까요? 어떤 연산을 해야 할까요?
 

2358
00:53:29,190 --> 00:53:29,200

 

2359
00:53:29,200 --> 00:53:32,870

새로운 입찰을 할 수 있어야 합니다.

2360
00:53:32,870 --> 00:53:32,880
새로운 입찰을 할 수 있어야 합니다.
 

2361
00:53:32,880 --> 00:53:36,710
새로운 입찰을 할 수 있어야 합니다.
입찰자에게는 ID

2362
00:53:36,710 --> 00:53:36,720
입찰자에게는 ID
 

2363
00:53:36,720 --> 00:53:39,430
입찰자에게는 ID
와 입찰가(이 책

2364
00:53:39,430 --> 00:53:39,440
와 입찰가(이 책
 

2365
00:53:39,440 --> 00:53:40,790
와 입찰가(이 책
에 얼마를 지불할 것인지 나타내는 정수)가 연결됩니다.

2366
00:53:40,790 --> 00:53:42,630
에 얼마를 지불할 것인지 나타내는 정수)가 연결됩니다.
 

2367
00:53:42,630 --> 00:53:42,640

 

2368
00:53:42,640 --> 00:53:46,390

어, 입찰 정보를 업데이트해야 하는데, 어떤 의미에서는

2369
00:53:46,390 --> 00:53:47,109
어, 입찰 정보를 업데이트해야 하는데, 어떤 의미에서는
 

2370
00:53:47,109 --> 00:53:47,119

 

2371
00:53:47,119 --> 00:53:49,109

그 사람이 이전에 입찰을 했는지 확인해야 합니다.

2372
00:53:49,109 --> 00:53:50,630
그 사람이 이전에 입찰을 했는지 확인해야 합니다.
 

2373
00:53:50,630 --> 00:53:50,640

 

2374
00:53:50,640 --> 00:53:52,630

제 데이터 구조에서, 어느 시점에는

2375
00:53:52,630 --> 00:53:52,640
제 데이터 구조에서, 어느 시점에는
 

2376
00:53:52,640 --> 00:53:54,549
제 데이터 구조에서, 어느 시점에는
입찰자 ID를 찾아야 할 텐데,

2377
00:53:54,549 --> 00:53:54,559
입찰자 ID를 찾아야 할 텐데,
 

2378
00:53:54,559 --> 00:53:57,750
입찰자 ID를 찾아야 할 텐데,
이게 가능할까요? 입찰자 ID를 저장하는 일종의 딕셔너리를 만들고 싶습니다.

2379
00:53:57,750 --> 00:53:59,750
이게 가능할까요? 입찰자 ID를 저장하는 일종의 딕셔너리를 만들고 싶습니다.
 

2380
00:53:59,750 --> 00:54:02,630

 

2381
00:54:02,630 --> 00:54:03,030

 

2382
00:54:03,030 --> 00:54:05,990

 

2383
00:54:05,990 --> 00:54:08,710

 

2384
00:54:08,710 --> 00:54:10,069

 

2385
00:54:10,069 --> 00:54:10,079

 

2386
00:54:10,079 --> 00:54:11,910

딕셔너리를 만든다는 건, 아직 어떻게 구현할지는 구체적으로 말씀드리지 않겠습니다. 일반적으로

2387
00:54:11,910 --> 00:54:11,920
딕셔너리를 만든다는 건, 아직 어떻게 구현할지는 구체적으로 말씀드리지 않겠습니다. 일반적으로
 

2388
00:54:11,920 --> 00:54:13,270
딕셔너리를 만든다는 건, 아직 어떻게 구현할지는 구체적으로 말씀드리지 않겠습니다. 일반적으로

2389
00:54:13,270 --> 00:54:13,280

 

2390
00:54:13,280 --> 00:54:15,910

해시 테이블을 사용하지만, 최악의

2391
00:54:15,910 --> 00:54:15,920
해시 테이블을 사용하지만, 최악의
 

2392
00:54:15,920 --> 00:54:19,510
해시 테이블을 사용하지만, 최악의
경우 시간 복잡도를 고려해야 한다면

2393
00:54:19,510 --> 00:54:19,520

 

2394
00:54:19,520 --> 00:54:21,510

AVL 트리를 사용하는 게 좋을 겁니다. AVL 트리는

2395
00:54:21,510 --> 00:54:23,349
AVL 트리를 사용하는 게 좋을 겁니다. AVL 트리는
 

2396
00:54:23,349 --> 00:54:24,549

 

2397
00:54:24,549 --> 00:54:24,559

 

2398
00:54:24,559 --> 00:54:27,349

키로 검색하는 데 log n 시간이 걸리기 때문에 딕셔너리로는

2399
00:54:27,349 --> 00:54:27,359
키로 검색하는 데 log n 시간이 걸리기 때문에 딕셔너리로는
 

2400
00:54:27,359 --> 00:54:29,990
키로 검색하는 데 log n 시간이 걸리기 때문에 딕셔너리로는
최적의 선택입니다. 정렬된 배열을 사용하는 것 외에는 다른 방법이 없습니다.

2401
00:54:29,990 --> 00:54:31,109
최적의 선택입니다. 정렬된 배열을 사용하는 것 외에는 다른 방법이 없습니다.
 

2402
00:54:31,109 --> 00:54:33,349

 

2403
00:54:33,349 --> 00:54:33,359

 

2404
00:54:33,359 --> 00:54:35,109

하지만 정렬된 배열은

2405
00:54:35,109 --> 00:54:35,119
하지만 정렬된 배열은
 

2406
00:54:35,119 --> 00:54:37,270
하지만 정렬된 배열은
동적이지 않습니다.

2407
00:54:37,270 --> 00:54:37,280
동적이지 않습니다.
 

2408
00:54:37,280 --> 00:54:39,109
동적이지 않습니다.
제 데이터 구조에서는 누가 입찰을 했는지 계속 업데이트해야 합니다.

2409
00:54:39,109 --> 00:54:39,119
제 데이터 구조에서는 누가 입찰을 했는지 계속 업데이트해야 합니다.
 

2410
00:54:39,119 --> 00:54:39,589
제 데이터 구조에서는 누가 입찰을 했는지 계속 업데이트해야 합니다.

2411
00:54:39,589 --> 00:54:39,599

 

2412
00:54:39,599 --> 00:54:43,190

사람들이 계속 들어와서 입찰을 하므로, 제가 중요하게 생각하는 정보들이 계속 바뀝니다.

2413
00:54:43,190 --> 00:54:43,750
사람들이 계속 들어와서 입찰을 하므로, 제가 중요하게 생각하는 정보들이 계속 바뀝니다.
 

2414
00:54:43,750 --> 00:54:45,910

 

2415
00:54:45,910 --> 00:54:47,829

 

2416
00:54:47,829 --> 00:54:48,390

 

2417
00:54:48,390 --> 00:54:49,829

 

2418
00:54:49,829 --> 00:54:49,839

 

2419
00:54:49,839 --> 00:54:51,750

따라서 정렬된 배열은 적합하지 않을 것 같습니다.

2420
00:54:51,750 --> 00:54:51,760
따라서 정렬된 배열은 적합하지 않을 것 같습니다.
 

2421
00:54:51,760 --> 00:54:54,870
따라서 정렬된 배열은 적합하지 않을 것 같습니다.
동적 연산에는 익숙하지 않아서 입찰자

2422
00:54:54,870 --> 00:54:56,789
동적 연산에는 익숙하지 않아서 입찰자
 

2423
00:54:56,789 --> 00:54:58,069

 

2424
00:54:58,069 --> 00:54:58,079

 

2425
00:54:58,079 --> 00:55:01,430

ID에 대한 딕셔너리가 필요할 것 같아요. 그리고

2426
00:55:01,430 --> 00:55:04,549
ID에 대한 딕셔너리가 필요할 것 같아요. 그리고
 

2427
00:55:04,549 --> 00:55:04,559

 

2428
00:55:04,559 --> 00:55:07,109

최고 입찰자 k명의 합계도 유지해야 하고요. 이해되시나요?

2429
00:55:07,109 --> 00:55:08,230
최고 입찰자 k명의 합계도 유지해야 하고요. 이해되시나요?
 

2430
00:55:08,230 --> 00:55:08,240

 

2431
00:55:08,240 --> 00:55:10,309

그러니까 어떤 의미에서는

2432
00:55:10,309 --> 00:55:13,349
그러니까 어떤 의미에서는
 

2433
00:55:13,349 --> 00:55:16,789

 

2434
00:55:16,789 --> 00:55:16,799

 

2435
00:55:16,799 --> 00:55:19,030

입찰자들의 순서를 추적해야 한다는 거죠. 제 데이터 구조에 있는 입찰들을요.

2436
00:55:19,030 --> 00:55:21,589
입찰자들의 순서를 추적해야 한다는 거죠. 제 데이터 구조에 있는 입찰들을요.
 

2437
00:55:21,589 --> 00:55:21,599

 

2438
00:55:21,599 --> 00:55:23,349

순서가 중요하기 때문에

2439
00:55:23,349 --> 00:55:23,359
순서가 중요하기 때문에
 

2440
00:55:23,359 --> 00:55:25,430
순서가 중요하기 때문에
입찰자 ID를 조회해야 하고요. 대략 이 정도입니다. 네,

2441
00:55:25,430 --> 00:55:28,230
입찰자 ID를 조회해야 하고요. 대략 이 정도입니다. 네,
 

2442
00:55:28,230 --> 00:55:31,349

 

2443
00:55:31,349 --> 00:55:31,359

 

2444
00:55:31,359 --> 00:55:38,470

확인차 물어본 거예요. 네, 맞아요.

2445
00:55:38,470 --> 00:55:42,309

 

2446
00:55:42,309 --> 00:55:42,319

 

2447
00:55:42,319 --> 00:55:44,230

아주 좋은 지적입니다.

2448
00:55:44,230 --> 00:55:44,240
아주 좋은 지적입니다.
 

2449
00:55:44,240 --> 00:55:45,430
아주 좋은 지적입니다.
최악의 경우 실행 시간이

2450
00:55:45,430 --> 00:55:45,440
최악의 경우 실행 시간이
 

2451
00:55:45,440 --> 00:55:47,670
최악의 경우 실행 시간이
예상치 못한 시간으로 실행될 수도 있죠.

2452
00:55:47,670 --> 00:55:47,680
예상치 못한 시간으로 실행될 수도 있죠.
 

2453
00:55:47,680 --> 00:55:49,270
예상치 못한 시간으로 실행될 수도 있죠.
왜냐하면 여기에는 본질적으로 무작위

2454
00:55:49,270 --> 00:55:49,280
왜냐하면 여기에는 본질적으로 무작위
 

2455
00:55:49,280 --> 00:55:50,870
왜냐하면 여기에는 본질적으로 무작위
화가 없기 때문입니다. 제가 말하는

2456
00:55:50,870 --> 00:55:54,789
화가 없기 때문입니다. 제가 말하는
 

2457
00:55:54,789 --> 00:55:56,630

 

2458
00:55:56,630 --> 00:55:58,710

 

2459
00:55:58,710 --> 00:56:00,789

 

2460
00:56:00,789 --> 00:56:00,799

 

2461
00:56:00,799 --> 00:56:02,230

무작위화는 여기서는 사용되지 않습니다.

2462
00:56:02,230 --> 00:56:03,589
무작위화는 여기서는 사용되지 않습니다.
 

2463
00:56:03,589 --> 00:56:03,599

 

2464
00:56:03,599 --> 00:56:05,349

이 클래스에서는 해시 테이블을 사용하지 않습니다.

2465
00:56:05,349 --> 00:56:07,510
이 클래스에서는 해시 테이블을 사용하지 않습니다.
 

2466
00:56:07,510 --> 00:56:07,520

 

2467
00:56:07,520 --> 00:56:10,630

이것이 문제가 될 수 있는 유일한 상황입니다. 그렇죠? 하지만

2468
00:56:10,630 --> 00:56:10,640
이것이 문제가 될 수 있는 유일한 상황입니다. 그렇죠? 하지만
 

2469
00:56:10,640 --> 00:56:11,430
이것이 문제가 될 수 있는 유일한 상황입니다. 그렇죠? 하지만

2470
00:56:11,430 --> 00:56:11,440

 

2471
00:56:11,440 --> 00:56:14,710

만약 그렇다면, 이 문제는

2472
00:56:14,710 --> 00:56:14,720
만약 그렇다면, 이 문제는
 

2473
00:56:14,720 --> 00:56:15,349
만약 그렇다면, 이 문제는

2474
00:56:15,349 --> 00:56:15,359

 

2475
00:56:15,359 --> 00:56:16,710

각 상태에 대해 무엇을 말하는 건가요?

2476
00:56:16,710 --> 00:56:16,720
각 상태에 대해 무엇을 말하는 건가요?
 

2477
00:56:16,720 --> 00:56:18,470
각 상태에 대해 무엇을 말하는 건가요?
실행 시간은 최악의 경우 예상 시간

2478
00:56:18,470 --> 00:56:18,480
실행 시간은 최악의 경우 예상 시간
 

2479
00:56:18,480 --> 00:56:20,789
실행 시간은 최악의 경우 예상 시간
또는 상각 시간일 수 있습니다. 우리가 정말로

2480
00:56:20,789 --> 00:56:20,799
또는 상각 시간일 수 있습니다. 우리가 정말로
 

2481
00:56:20,799 --> 00:56:22,230
또는 상각 시간일 수 있습니다. 우리가 정말로
여러분에게 묻고 싶은 것은

2482
00:56:22,230 --> 00:56:26,150
여러분에게 묻고 싶은 것은
 

2483
00:56:26,150 --> 00:56:27,510

 

2484
00:56:27,510 --> 00:56:27,520

 

2485
00:56:27,520 --> 00:56:29,670

적절한 조건을 고려하여 알고리즘의 실행 시간을 평가하는 것입니다.

2486
00:56:29,670 --> 00:56:29,680
적절한 조건을 고려하여 알고리즘의 실행 시간을 평가하는 것입니다.
 

2487
00:56:29,680 --> 00:56:30,789
적절한 조건을 고려하여 알고리즘의 실행 시간을 평가하는 것입니다.

2488
00:56:30,789 --> 00:56:30,799

 

2489
00:56:30,799 --> 00:56:32,390

최악의 경우라면 최악의 경우라고 말하고,

2490
00:56:32,390 --> 00:56:34,950
최악의 경우라면 최악의 경우라고 말하고,
 

2491
00:56:34,950 --> 00:56:34,960

 

2492
00:56:34,960 --> 00:56:38,230

해시 테이블을 사용한다면 예상 시간이라고

2493
00:56:38,230 --> 00:56:38,240
해시 테이블을 사용한다면 예상 시간이라고
 

2494
00:56:38,240 --> 00:56:39,510
해시 테이블을 사용한다면 예상 시간이라고
말하고,

2495
00:56:39,510 --> 00:56:39,520
말하고,
 

2496
00:56:39,520 --> 00:56:42,309
말하고,
이러한 연산들이 때때로 매우

2497
00:56:42,309 --> 00:56:42,319
이러한 연산들이 때때로 매우
 

2498
00:56:42,319 --> 00:56:43,670
이러한 연산들이 때때로 매우
나쁘지만

2499
00:56:43,670 --> 00:56:43,680
나쁘지만
 

2500
00:56:43,680 --> 00:56:45,589
나쁘지만
평균적으로는 매우 좋고,

2501
00:56:45,589 --> 00:56:45,599
평균적으로는 매우 좋고,
 

2502
00:56:45,599 --> 00:56:46,870
평균적으로는 매우 좋고,
많이 수행된다면 상각된 시간이라고 말해야 합니다.

2503
00:56:46,870 --> 00:56:49,109
많이 수행된다면 상각된 시간이라고 말해야 합니다.
 

2504
00:56:49,109 --> 00:56:51,589

 

2505
00:56:51,589 --> 00:56:51,599

 

2506
00:56:51,599 --> 00:56:52,549


2507
00:56:52,549 --> 00:56:54,309

 

2508
00:56:54,309 --> 00:56:56,470

 

2509
00:56:56,470 --> 00:56:59,430

 

2510
00:56:59,430 --> 00:56:59,440

 

2511
00:56:59,440 --> 00:57:02,549

그렇죠? 동적 배열을 사용하거나 해시 테이블을 사용하더라도 동적 연산은 여전히 ​​상각된 시간입니다. 동적 연산의 장점은

2512
00:57:02,549 --> 00:57:02,559
그렇죠? 동적 배열을 사용하거나 해시 테이블을 사용하더라도 동적 연산은 여전히 ​​상각된 시간입니다. 동적 연산의 장점은
 

2513
00:57:02,559 --> 00:57:03,270
그렇죠? 동적 배열을 사용하거나 해시 테이블을 사용하더라도 동적 연산은 여전히 ​​상각된 시간입니다. 동적 연산의 장점은

2514
00:57:03,270 --> 00:57:03,280

 

2515
00:57:03,280 --> 00:57:05,349

연결 데이터 구조의 경우 동적

2516
00:57:05,349 --> 00:57:05,359
연결 데이터 구조의 경우 동적
 

2517
00:57:05,359 --> 00:57:07,190
연결 데이터 구조의 경우 동적
연산이 상각되지 않는다는 것입니다. 따라서

2518
00:57:07,190 --> 00:57:08,870
연산이 상각되지 않는다는 것입니다. 따라서
 

2519
00:57:08,870 --> 00:57:08,880

 

2520
00:57:08,880 --> 00:57:10,630

이 문제에서는

2521
00:57:10,630 --> 00:57:10,640
이 문제에서는
 

2522
00:57:10,640 --> 00:57:12,630
이 문제에서는
최악의 경우 경계를 구할 수 있으므로 그렇게 해보겠습니다.

2523
00:57:12,630 --> 00:57:13,589
최악의 경우 경계를 구할 수 있으므로 그렇게 해보겠습니다.
 

2524
00:57:13,589 --> 00:57:15,750

 

2525
00:57:15,750 --> 00:57:15,760

 

2526
00:57:15,760 --> 00:57:17,030

해시 테이블을 사용하는 경우 예상 시간으로도 구할 수 있습니다.

2527
00:57:17,030 --> 00:57:17,040
해시 테이블을 사용하는 경우 예상 시간으로도 구할 수 있습니다.
 

2528
00:57:17,040 --> 00:57:20,069
해시 테이블을 사용하는 경우 예상 시간으로도 구할 수 있습니다.
딕셔너리도 마찬가지입니다.

2529
00:57:20,069 --> 00:57:21,589
딕셔너리도 마찬가지입니다.
 

2530
00:57:21,589 --> 00:57:21,599

 

2531
00:57:21,599 --> 00:57:24,549

이 수업에서 데이터 구조 문제를 풀 때는

2532
00:57:24,549 --> 00:57:27,190
이 수업에서 데이터 구조 문제를 풀 때는
 

2533
00:57:27,190 --> 00:57:27,200

 

2534
00:57:27,200 --> 00:57:27,990


2535
00:57:27,990 --> 00:57:28,000

 

2536
00:57:28,000 --> 00:57:31,510

먼저 무엇을 저장하는지 말해야 합니다.

2537
00:57:31,510 --> 00:57:31,520
먼저 무엇을 저장하는지 말해야 합니다.
 

2538
00:57:31,520 --> 00:57:33,910
먼저 무엇을 저장하는지 말해야 합니다.
이런 것들에는 뭐가 들어가야 하는 거죠?

2539
00:57:33,910 --> 00:57:33,920
이런 것들에는 뭐가 들어가야 하는 거죠?
 

2540
00:57:33,920 --> 00:57:35,430
이런 것들에는 뭐가 들어가야 하는 거죠?
이 데이터 구조에 대한 불변 조건 같은 게 있어야

2541
00:57:35,430 --> 00:57:35,440
이 데이터 구조에 대한 불변 조건 같은 게 있어야
 

2542
00:57:35,440 --> 00:57:35,910
이 데이터 구조에 대한 불변 조건 같은 게 있어야

2543
00:57:35,910 --> 00:57:38,630

 

2544
00:57:38,630 --> 00:57:38,640

 

2545
00:57:38,640 --> 00:57:39,589

나중에 쿼리를 할 때

2546
00:57:39,589 --> 00:57:39,599
나중에 쿼리를 할 때
 

2547
00:57:39,599 --> 00:57:41,589
나중에 쿼리를 할 때
이런 조건들이

2548
00:57:41,589 --> 00:57:41,599
이런 조건들이
 

2549
00:57:41,599 --> 00:57:43,349
이런 조건들이
유지되도록 하는 거잖아요. 예를 들어

2550
00:57:43,349 --> 00:57:46,470
유지되도록 하는 거잖아요. 예를 들어
 

2551
00:57:46,470 --> 00:57:46,480

 

2552
00:57:46,480 --> 00:57:48,230

정렬된 배열을 유지하고

2553
00:57:48,230 --> 00:57:50,710
정렬된 배열을 유지하고
 

2554
00:57:50,710 --> 00:57:50,720

 

2555
00:57:50,720 --> 00:57:51,990

최댓값을 찾는 연산을 지원한다고 가정해 볼게요. 그러면

2556
00:57:51,990 --> 00:57:52,000
최댓값을 찾는 연산을 지원한다고 가정해 볼게요. 그러면
 

2557
00:57:52,000 --> 00:57:53,910
최댓값을 찾는 연산을 지원한다고 가정해 볼게요. 그러면
이 데이터 구조에 어떤 작업을 하든 배열이

2558
00:57:53,910 --> 00:57:55,910
이 데이터 구조에 어떤 작업을 하든 배열이
 

2559
00:57:55,910 --> 00:57:57,190

 

2560
00:57:57,190 --> 00:57:57,200

 

2561
00:57:57,200 --> 00:57:59,349

정렬된 상태이고 마지막에 최댓값이 있어야 한다는 불변 조건이 유지되어야 해요.

2562
00:57:59,349 --> 00:57:59,359
정렬된 상태이고 마지막에 최댓값이 있어야 한다는 불변 조건이 유지되어야 해요.
 

2563
00:57:59,359 --> 00:58:02,390
정렬된 상태이고 마지막에 최댓값이 있어야 한다는 불변 조건이 유지되어야 해요.
왜냐하면 최댓값을 찾는 함수는 마지막에 있는 값을

2564
00:58:02,390 --> 00:58:04,789
왜냐하면 최댓값을 찾는 함수는 마지막에 있는 값을
 

2565
00:58:04,789 --> 00:58:04,799

 

2566
00:58:04,799 --> 00:58:05,750

반환할 테니까요. 이해가 되시나요? 그러니까

2567
00:58:05,750 --> 00:58:07,829
반환할 테니까요. 이해가 되시나요? 그러니까
 

2568
00:58:07,829 --> 00:58:09,589

 

2569
00:58:09,589 --> 00:58:09,599

 

2570
00:58:09,599 --> 00:58:10,470


2571
00:58:10,470 --> 00:58:12,470

 

2572
00:58:12,470 --> 00:58:12,480

 

2573
00:58:12,480 --> 00:58:13,670

데이터 구조의 특정 시점에 무엇이 저장되고 유지되는지, 그리고

2574
00:58:13,670 --> 00:58:15,829
데이터 구조의 특정 시점에 무엇이 저장되고 유지되는지, 그리고
 

2575
00:58:15,829 --> 00:58:15,839

 

2576
00:58:15,839 --> 00:58:18,390

동적 연산이나 쿼리를 지원할 때, 즉 이 데이터 구조에서

2577
00:58:18,390 --> 00:58:18,400
동적 연산이나 쿼리를 지원할 때, 즉 이 데이터 구조에서
 

2578
00:58:18,400 --> 00:58:19,670
동적 연산이나 쿼리를 지원할 때, 즉 이 데이터 구조에서

2579
00:58:19,670 --> 00:58:22,470

 

2580
00:58:22,470 --> 00:58:22,480

 

2581
00:58:22,480 --> 00:58:24,069

요소를 삽입하거나 삭제할 때

2582
00:58:24,069 --> 00:58:24,079
요소를 삽입하거나 삭제할 때
 

2583
00:58:24,079 --> 00:58:24,870
요소를 삽입하거나 삭제할 때

2584
00:58:24,870 --> 00:58:26,549

 

2585
00:58:26,549 --> 00:58:26,559

 

2586
00:58:26,559 --> 00:58:28,390

이러한 불변 조건이 유지되는지 확인해야 한다는 거죠.

2587
00:58:28,390 --> 00:58:28,400
이러한 불변 조건이 유지되는지 확인해야 한다는 거죠.
 

2588
00:58:28,400 --> 00:58:29,910
이러한 불변 조건이 유지되는지 확인해야 한다는 거죠.
그리고 쿼리를 할 때도

2589
00:58:29,910 --> 00:58:29,920
그리고 쿼리를 할 때도
 

2590
00:58:29,920 --> 00:58:32,230
그리고 쿼리를 할 때도
이러한 불변 조건을 믿고 원하는 결과를 얻을 수 있어야 하고요. 이해가 되시나요? 네,

2591
00:58:32,230 --> 00:58:34,470
이러한 불변 조건을 믿고 원하는 결과를 얻을 수 있어야 하고요. 이해가 되시나요? 네,
 

2592
00:58:34,470 --> 00:58:34,480

 

2593
00:58:34,480 --> 00:58:35,670


2594
00:58:35,670 --> 00:58:35,680

 

2595
00:58:35,680 --> 00:58:40,870

이 문제에 대해서는 이 정도면 괜찮을 것 같아요.

2596
00:58:40,870 --> 00:58:45,270

 

2597
00:58:45,270 --> 00:58:45,280

 

2598
00:58:45,280 --> 00:58:48,950

제가 다뤄야 할 키가 두 종류 정도 있는 것 같은데, 어떤 아이디어가 있으신가요?

2599
00:58:48,950 --> 00:58:48,960
제가 다뤄야 할 키가 두 종류 정도 있는 것 같은데, 어떤 아이디어가 있으신가요?
 

2600
00:58:48,960 --> 00:58:50,870
제가 다뤄야 할 키가 두 종류 정도 있는 것 같은데, 어떤 아이디어가 있으신가요?
하나는 입찰 ID이고 다른 하나는

2601
00:58:50,870 --> 00:58:52,870
하나는 입찰 ID이고 다른 하나는
 

2602
00:58:52,870 --> 00:58:52,880

 

2603
00:58:52,880 --> 00:58:56,549

입찰 금액입니다.

2604
00:58:56,549 --> 00:58:56,559
입찰 금액입니다.
 

2605
00:58:56,559 --> 00:58:59,510
입찰 금액입니다.
두 개의 키가 있는데,

2606
00:58:59,510 --> 00:59:00,230
두 개의 키가 있는데,
 

2607
00:59:00,230 --> 00:59:00,240

 

2608
00:59:00,240 --> 00:59:01,829

하나는 정렬 기준으로,

2609
00:59:01,829 --> 00:59:01,839
하나는 정렬 기준으로,
 

2610
00:59:01,839 --> 00:59:03,430
하나는 정렬 기준으로,
다른 하나는 조회 기준으로 사용하려면 어떻게 해야 할까요?

2611
00:59:03,430 --> 00:59:03,440
다른 하나는 조회 기준으로 사용하려면 어떻게 해야 할까요?
 

2612
00:59:03,440 --> 00:59:04,789
다른 하나는 조회 기준으로 사용하려면 어떻게 해야 할까요?
데이터 구조를 몇 개나

2613
00:59:04,789 --> 00:59:04,799
데이터 구조를 몇 개나
 

2614
00:59:04,799 --> 00:59:06,710
데이터 구조를 몇 개나
사용하겠습니까? 아마

2615
00:59:06,710 --> 00:59:06,720
사용하겠습니까? 아마
 

2616
00:59:06,720 --> 00:59:09,990
사용하겠습니까? 아마
두 개일 겁니다. 네,

2617
00:59:09,990 --> 00:59:10,000
두 개일 겁니다. 네,
 

2618
00:59:10,000 --> 00:59:12,309
두 개일 겁니다. 네,
하나는 입찰 금액을 조회할 수 있어야 하죠.

2619
00:59:12,309 --> 00:59:14,230
하나는 입찰 금액을 조회할 수 있어야 하죠.
 

2620
00:59:14,230 --> 00:59:14,240

 

2621
00:59:14,240 --> 00:59:17,510

그러니까 입찰

2622
00:59:17,510 --> 00:59:17,520
그러니까 입찰
 

2623
00:59:17,520 --> 00:59:21,270
그러니까 입찰
금액들을 딕셔너리에 저장해서

2624
00:59:21,270 --> 00:59:24,150
금액들을 딕셔너리에 저장해서
 

2625
00:59:24,150 --> 00:59:25,910

 

2626
00:59:25,910 --> 00:59:25,920

 

2627
00:59:25,920 --> 00:59:27,109

빠르게 조회할 수 있도록 해야겠습니다. 이렇게 하면

2628
00:59:27,109 --> 00:59:27,119
빠르게 조회할 수 있도록 해야겠습니다. 이렇게 하면
 

2629
00:59:27,119 --> 00:59:29,109
빠르게 조회할 수 있도록 해야겠습니다. 이렇게 하면
두 개의 데이터 구조를 사용할 수 있습니다. 하나는 입찰

2630
00:59:29,109 --> 00:59:30,390
두 개의 데이터 구조를 사용할 수 있습니다. 하나는 입찰
 

2631
00:59:30,390 --> 00:59:33,589

 

2632
00:59:33,589 --> 00:59:36,710

 

2633
00:59:36,710 --> 00:59:40,870

 

2634
00:59:40,870 --> 00:59:40,880

 

2635
00:59:40,880 --> 00:59:44,789

ID를 키로 하는 딕셔너리입니다. 그럼 또 뭐가 필요할까요?

2636
00:59:44,789 --> 00:59:47,829

 

2637
00:59:47,829 --> 00:59:52,150

 

2638
00:59:52,150 --> 00:59:52,160

 

2639
00:59:52,160 --> 00:59:53,910

반대로 입찰 금액을 키로 하는 딕셔너리도 필요합니다.

2640
00:59:53,910 --> 00:59:56,230
반대로 입찰 금액을 키로 하는 딕셔너리도 필요합니다.
 

2641
00:59:56,230 --> 00:59:56,240

 

2642
00:59:56,240 --> 01:00:01,750

여기서 제가 원하는 건

2643
01:00:01,750 --> 01:00:01,760
여기서 제가 원하는 건
 

2644
01:00:01,760 --> 01:00:03,349
여기서 제가 원하는 건
순서를 유지하는 겁니다.

2645
01:00:03,349 --> 01:00:03,359
순서를 유지하는 겁니다.
 

2646
01:00:03,359 --> 01:00:05,430
순서를 유지하는 겁니다.
왜냐하면 지금까지 본 입찰 금액 중 가장 높은 금액의 K개를 유지하고 싶기 때문입니다.

2647
01:00:05,430 --> 01:00:07,670
왜냐하면 지금까지 본 입찰 금액 중 가장 높은 금액의 K개를 유지하고 싶기 때문입니다.
 

2648
01:00:07,670 --> 01:00:08,630

 

2649
01:00:08,630 --> 01:00:08,640

 

2650
01:00:08,640 --> 01:00:11,990

만약 어느 시점에

2651
01:00:11,990 --> 01:00:13,190
만약 어느 시점에
 

2652
01:00:13,190 --> 01:00:13,200

 

2653
01:00:13,200 --> 01:00:15,670

가장 높은 금액의 K개를 유지하고 있다면 어떻게 될까요? 예를 들어,

2654
01:00:15,670 --> 01:00:16,630
가장 높은 금액의 K개를 유지하고 있다면 어떻게 될까요? 예를 들어,
 

2655
01:00:16,630 --> 01:00:16,640

 

2656
01:00:16,640 --> 01:00:19,510

어떤 입찰자가

2657
01:00:19,510 --> 01:00:19,520
어떤 입찰자가
 

2658
01:00:19,520 --> 01:00:20,950
어떤 입찰자가
입찰 금액을 낮추면 더 이상

2659
01:00:20,950 --> 01:00:20,960
입찰 금액을 낮추면 더 이상
 

2660
01:00:20,960 --> 01:00:24,309
입찰 금액을 낮추면 더 이상
최고가 순위에 없을 수도 있습니다.

2661
01:00:24,309 --> 01:00:26,470
최고가 순위에 없을 수도 있습니다.
 

2662
01:00:26,470 --> 01:00:26,480

 

2663
01:00:26,480 --> 01:00:28,549

다른 사람들도 계속 추적해서 누가

2664
01:00:28,549 --> 01:00:28,559
다른 사람들도 계속 추적해서 누가
 

2665
01:00:28,559 --> 01:00:29,510
다른 사람들도 계속 추적해서 누가
그 집합에 다시 추가되어야 하는지 확인해야 해요.

2666
01:00:29,510 --> 01:00:29,520
그 집합에 다시 추가되어야 하는지 확인해야 해요.
 

2667
01:00:29,520 --> 01:00:33,750
그 집합에 다시 추가되어야 하는지 확인해야 해요.
예를 들어, 제 생각은 이렇습니다.

2668
01:00:33,750 --> 01:00:36,390
예를 들어, 제 생각은 이렇습니다.
 

2669
01:00:36,390 --> 01:00:37,430

 

2670
01:00:37,430 --> 01:00:37,440

 

2671
01:00:37,440 --> 01:00:39,109

데이터 구조를 하나만 유지하는 게 아니라 두 개 더 유지하는 거예요. 좀

2672
01:00:39,109 --> 01:00:39,119
데이터 구조를 하나만 유지하는 게 아니라 두 개 더 유지하는 거예요. 좀
 

2673
01:00:39,119 --> 01:00:40,630
데이터 구조를 하나만 유지하는 게 아니라 두 개 더 유지하는 거예요. 좀
비약적인 생각일 수도 있지만, 꼭

2674
01:00:40,630 --> 01:00:40,640
비약적인 생각일 수도 있지만, 꼭
 

2675
01:00:40,640 --> 01:00:42,309
비약적인 생각일 수도 있지만, 꼭
이렇게 할 필요는 없어요. 하나만 사용하는 방법도 있으니까요.

2676
01:00:42,309 --> 01:00:43,990
이렇게 할 필요는 없어요. 하나만 사용하는 방법도 있으니까요.
 

2677
01:00:43,990 --> 01:00:44,000

 

2678
01:00:44,000 --> 01:00:47,430

하지만 저는 두 개를 더 저장할 거예요. 하나는

2679
01:00:47,430 --> 01:00:51,430
하지만 저는 두 개를 더 저장할 거예요. 하나는
 

2680
01:00:51,430 --> 01:00:58,630

 

2681
01:00:58,630 --> 01:01:04,150

 

2682
01:01:04,150 --> 01:01:04,160

 

2683
01:01:04,160 --> 01:01:08,829

최고 입찰자 k명을 저장하는 데이터 구조

2684
01:01:08,829 --> 01:01:08,839
최고 입찰자 k명을 저장하는 데이터 구조
 

2685
01:01:08,839 --> 01:01:12,230
최고 입찰자 k명을 저장하는 데이터 구조

2686
01:01:12,230 --> 01:01:12,240

 

2687
01:01:12,240 --> 01:01:18,150

이고, 다른 하나는

2688
01:01:18,150 --> 01:01:18,160

 

2689
01:01:18,160 --> 01:01:22,309

최고 입찰자 n-k명을 저장하는 데이터 구조예요.

2690
01:01:22,309 --> 01:01:22,319
최고 입찰자 n-k명을 저장하는 데이터 구조예요.
 

2691
01:01:22,319 --> 01:01:25,349
최고 입찰자 n-k명을 저장하는 데이터 구조예요.
이해가 되시나요? 이렇게 하면

2692
01:01:25,349 --> 01:01:25,359
이해가 되시나요? 이렇게 하면
 

2693
01:01:25,359 --> 01:01:28,150
이해가 되시나요? 이렇게 하면
문제가 훨씬 잘 분리되죠.

2694
01:01:28,150 --> 01:01:30,309
문제가 훨씬 잘 분리되죠.
 

2695
01:01:30,309 --> 01:01:30,319

 

2696
01:01:30,319 --> 01:01:32,630

누군가

2697
01:01:32,630 --> 01:01:32,640
누군가
 

2698
01:01:32,640 --> 01:01:36,829
누군가
이 데이터 구조와 상호 작용할 때마다,

2699
01:01:36,829 --> 01:01:36,839

 

2700
01:01:36,839 --> 01:01:38,230


2701
01:01:38,230 --> 01:01:38,240

 

2702
01:01:38,240 --> 01:01:41,510

그 값이 여기 있는 가장 작은 값보다 큰지 확인할 수 있어요.

2703
01:01:41,510 --> 01:01:43,430
그 값이 여기 있는 가장 작은 값보다 큰지 확인할 수 있어요.
 

2704
01:01:43,430 --> 01:01:43,440

 

2705
01:01:43,440 --> 01:01:46,150

만약 크다면, 이전과 같은 방식으로 처리할 수 있죠. 그 값을

2706
01:01:46,150 --> 01:01:48,230
만약 크다면, 이전과 같은 방식으로 처리할 수 있죠. 그 값을
 

2707
01:01:48,230 --> 01:01:48,240

 

2708
01:01:48,240 --> 01:01:50,789

제거하고 새로운 값을 넣으면 돼요.

2709
01:01:50,789 --> 01:01:50,799
제거하고 새로운 값을 넣으면 돼요.
 

2710
01:01:50,799 --> 01:01:51,349
제거하고 새로운 값을 넣으면 돼요.

2711
01:01:51,349 --> 01:01:51,359

 

2712
01:01:51,359 --> 01:01:54,150

그런데 어디에 넣어야 할까요? 제거했으니

2713
01:01:54,150 --> 01:01:54,160
그런데 어디에 넣어야 할까요? 제거했으니
 

2714
01:01:54,160 --> 01:01:55,270
그런데 어디에 넣어야 할까요? 제거했으니
이

2715
01:01:55,270 --> 01:01:55,280
이
 

2716
01:01:55,280 --> 01:01:57,750
이
속성을 유지해야 하죠. 그래서 여기에 넣으면 돼요.

2717
01:01:57,750 --> 01:01:57,760
속성을 유지해야 하죠. 그래서 여기에 넣으면 돼요.
 

2718
01:01:57,760 --> 01:01:58,470
속성을 유지해야 하죠. 그래서 여기에 넣으면 돼요.

2719
01:01:58,470 --> 01:01:58,480

 

2720
01:01:58,480 --> 01:01:59,670

또 다른 경우가 있어요. 그 값이 더

2721
01:01:59,670 --> 01:01:59,680
또 다른 경우가 있어요. 그 값이 더
 

2722
01:01:59,680 --> 01:02:02,950
또 다른 경우가 있어요. 그 값이 더

2723
01:02:02,950 --> 01:02:02,960

 

2724
01:02:02,960 --> 01:02:06,470

작을 때죠. 이 경우에는

2725
01:02:06,470 --> 01:02:06,480
작을 때죠. 이 경우에는
 

2726
01:02:06,480 --> 01:02:07,829
작을 때죠. 이 경우에는
이 데이터 구조에 아무것도 하지 않고 그냥

2727
01:02:07,829 --> 01:02:07,839
이 데이터 구조에 아무것도 하지 않고 그냥
 

2728
01:02:07,839 --> 01:02:09,510
이 데이터 구조에 아무것도 하지 않고 그냥
여기에 넣으면 돼요.

2729
01:02:09,510 --> 01:02:09,520
여기에 넣으면 돼요.
 

2730
01:02:09,520 --> 01:02:12,630
여기에 넣으면 돼요.
이해되셨나요?  그렇다면

2731
01:02:12,630 --> 01:02:12,640
이해되셨나요?  그렇다면
 

2732
01:02:12,640 --> 01:02:14,789
이해되셨나요?  그렇다면
이 데이터 구조들이 유지해야 할 연산은 무엇일까요? 바로

2733
01:02:14,789 --> 01:02:17,510
이 데이터 구조들이 유지해야 할 연산은 무엇일까요? 바로
 

2734
01:02:17,510 --> 01:02:17,520

 

2735
01:02:17,520 --> 01:02:18,230


2736
01:02:18,230 --> 01:02:18,240

 

2737
01:02:18,240 --> 01:02:20,470

이 두 집합의 최소값이나 최대값을 찾는 연산이죠. 이해가 되시나요?

2738
01:02:20,470 --> 01:02:20,480
이 두 집합의 최소값이나 최대값을 찾는 연산이죠. 이해가 되시나요?
 

2739
01:02:20,480 --> 01:02:21,510
이 두 집합의 최소값이나 최대값을 찾는 연산이죠. 이해가 되시나요?
사실, 잘 이해가 안 되네요.

2740
01:02:21,510 --> 01:02:21,520
사실, 잘 이해가 안 되네요.
 

2741
01:02:21,520 --> 01:02:25,190
사실, 잘 이해가 안 되네요.
그런 연산들이 어디 있었더라? 지금은 기억이 안 나지만,

2742
01:02:25,190 --> 01:02:26,470
그런 연산들이 어디 있었더라? 지금은 기억이 안 나지만,
 

2743
01:02:26,470 --> 01:02:26,480

 

2744
01:02:26,480 --> 01:02:27,910

우선순위 큐 연산이었어요. 예를 들어,

2745
01:02:27,910 --> 01:02:29,910
우선순위 큐 연산이었어요. 예를 들어,
 

2746
01:02:29,910 --> 01:02:29,920

 

2747
01:02:29,920 --> 01:02:33,589

최대값 삭제나 위치 삽입 같은

2748
01:02:33,589 --> 01:02:33,599
최대값 삭제나 위치 삽입 같은
 

2749
01:02:33,599 --> 01:02:36,870
최대값 삭제나 위치 삽입 같은
것들이요. 우선순위

2750
01:02:36,870 --> 01:02:36,880
것들이요. 우선순위
 

2751
01:02:36,880 --> 01:02:39,750
것들이요. 우선순위
큐라면 뭐든,

2752
01:02:39,750 --> 01:02:39,760
큐라면 뭐든,
 

2753
01:02:39,760 --> 01:02:40,069
큐라면 뭐든,

2754
01:02:40,069 --> 01:02:40,079

 

2755
01:02:40,079 --> 01:02:44,150

최대값과 최소값을 처리할 수 있는 거면 다

2756
01:02:44,150 --> 01:02:44,160
최대값과 최소값을 처리할 수 있는 거면 다
 

2757
01:02:44,160 --> 01:02:46,630
최대값과 최소값을 처리할 수 있는 거면 다
좋죠. 그리고 최대값

2758
01:02:46,630 --> 01:02:47,990
좋죠. 그리고 최대값
 

2759
01:02:47,990 --> 01:02:48,000

 

2760
01:02:48,000 --> 01:02:50,710

과 최소값을 효율적으로 처리할 수 있는 데이터 구조는 뭐가 있을까요?

2761
01:02:50,710 --> 01:02:50,720
과 최소값을 효율적으로 처리할 수 있는 데이터 구조는 뭐가 있을까요?
 

2762
01:02:50,720 --> 01:02:53,910
과 최소값을 효율적으로 처리할 수 있는 데이터 구조는 뭐가 있을까요?
바로 `setavl`이죠.

2763
01:02:53,910 --> 01:02:53,920
바로 `setavl`이죠.
 

2764
01:02:53,920 --> 01:02:55,750
바로 `setavl`이죠.
여기서는 데이터 구조 대신 `

2765
01:02:55,750 --> 01:02:57,829
여기서는 데이터 구조 대신 `
 

2766
01:02:57,829 --> 01:02:57,839

 

2767
01:02:57,839 --> 01:03:03,430

setavl`이라고 할게요.

2768
01:03:03,430 --> 01:03:03,440
setavl`이라고 할게요.
 

2769
01:03:03,440 --> 01:03:07,109
setavl`이라고 할게요.
당연히

2770
01:03:07,109 --> 01:03:07,119
당연히
 

2771
01:03:07,119 --> 01:03:11,430
당연히
키는 `

2772
01:03:11,430 --> 01:03:11,440

 

2773
01:03:11,440 --> 01:03:13,510

bid`가 될 거예요. 왜냐하면

2774
01:03:13,510 --> 01:03:13,520
bid`가 될 거예요. 왜냐하면
 

2775
01:03:13,520 --> 01:03:15,109
bid`가 될 거예요. 왜냐하면
제가 최대값과 최소값을 찾고 싶은 대상이니까요. 자,

2776
01:03:15,109 --> 01:03:15,119
제가 최대값과 최소값을 찾고 싶은 대상이니까요. 자,
 

2777
01:03:15,119 --> 01:03:17,190
제가 최대값과 최소값을 찾고 싶은 대상이니까요. 자,

2778
01:03:17,190 --> 01:03:17,200

 

2779
01:03:17,200 --> 01:03:19,589

여러분,

2780
01:03:19,589 --> 01:03:20,630
여러분,
 

2781
01:03:20,630 --> 01:03:20,640

 

2782
01:03:20,640 --> 01:03:23,430

제가 왜 이런 것들을 유지하는지 논리를 이해하시겠죠?

2783
01:03:23,430 --> 01:03:24,950
제가 왜 이런 것들을 유지하는지 논리를 이해하시겠죠?
 

2784
01:03:24,950 --> 01:03:24,960

 

2785
01:03:24,960 --> 01:03:27,190

제가 유지하고 싶은 불변성의 수준이 바로 이거예요.

2786
01:03:27,190 --> 01:03:27,200
제가 유지하고 싶은 불변성의 수준이 바로 이거예요.
 

2787
01:03:27,200 --> 01:03:30,710
제가 유지하고 싶은 불변성의 수준이 바로 이거예요.
예를 들어, `revenue` 쿼리를 실행할 때, 그냥

2788
01:03:30,710 --> 01:03:34,470
예를 들어, `revenue` 쿼리를 실행할 때, 그냥
 

2789
01:03:34,470 --> 01:03:34,480

 

2790
01:03:34,480 --> 01:03:35,109


2791
01:03:35,109 --> 01:03:35,119

 

2792
01:03:35,119 --> 01:03:38,390

모든 값을 더하면 되잖아요. 아, 잠깐,

2793
01:03:38,390 --> 01:03:38,400
모든 값을 더하면 되잖아요. 아, 잠깐,
 

2794
01:03:38,400 --> 01:03:40,549
모든 값을 더하면 되잖아요. 아, 잠깐,
시간이 얼마나 있지?

2795
01:03:40,549 --> 01:03:40,559
시간이 얼마나 있지?
 

2796
01:03:40,559 --> 01:03:43,910
시간이 얼마나 있지?
k만큼 시간이 있나? 아니, k만큼 시간이 없네.

2797
01:03:43,910 --> 01:03:43,920
k만큼 시간이 있나? 아니, k만큼 시간이 없네.
 

2798
01:03:43,920 --> 01:03:44,549
k만큼 시간이 있나? 아니, k만큼 시간이 없네.
그래서...  제가

2799
01:03:44,549 --> 01:03:44,559
그래서...  제가
 

2800
01:03:44,559 --> 01:03:48,309
그래서...  제가
이 모든 걸 마지막에 다 합산할 여유가 없어요.

2801
01:03:48,309 --> 01:03:49,430
이 모든 걸 마지막에 다 합산할 여유가 없어요.
 

2802
01:03:49,430 --> 01:03:51,109

 

2803
01:03:51,109 --> 01:03:51,119

 

2804
01:03:51,119 --> 01:03:52,549

상수 시간 안에 결과를 반환해야 하거든요. 좋은

2805
01:03:52,549 --> 01:03:52,559
상수 시간 안에 결과를 반환해야 하거든요. 좋은
 

2806
01:03:52,559 --> 01:03:56,230
상수 시간 안에 결과를 반환해야 하거든요. 좋은
아이디어 있으세요? 네, 그냥

2807
01:03:56,230 --> 01:03:56,240
아이디어 있으세요? 네, 그냥
 

2808
01:03:56,240 --> 01:03:59,190
아이디어 있으세요? 네, 그냥
계산하면 돼요. 노래를 업데이트하는 것처럼요.

2809
01:03:59,190 --> 01:03:59,200
계산하면 돼요. 노래를 업데이트하는 것처럼요.
 

2810
01:03:59,200 --> 01:04:00,390
계산하면 돼요. 노래를 업데이트하는 것처럼요.
이

2811
01:04:00,390 --> 01:04:00,400
이
 

2812
01:04:00,400 --> 01:04:03,190
이
데이터 구조와 함께,

2813
01:04:03,190 --> 01:04:03,200
데이터 구조와 함께,
 

2814
01:04:03,200 --> 01:04:05,109
데이터 구조와 함께,
네 번째 요소로 각

2815
01:04:05,109 --> 01:04:11,270
네 번째 요소로 각
 

2816
01:04:11,270 --> 01:04:11,280

 

2817
01:04:11,280 --> 01:04:13,750

비트의 총합을 저장할 거예요. 이걸 't'라고 부를게요. 이건

2818
01:04:13,750 --> 01:04:14,870
비트의 총합을 저장할 거예요. 이걸 't'라고 부를게요. 이건
 

2819
01:04:14,870 --> 01:04:18,630

 

2820
01:04:18,630 --> 01:04:18,640

 

2821
01:04:18,640 --> 01:04:20,230

제가 유지 관리하는

2822
01:04:20,230 --> 01:04:20,240
제가 유지 관리하는
 

2823
01:04:20,240 --> 01:04:21,750
제가 유지 관리하는
데이터 구조의 일부예요.

2824
01:04:21,750 --> 01:04:23,589
데이터 구조의 일부예요.
 

2825
01:04:23,589 --> 01:04:23,599

 

2826
01:04:23,599 --> 01:04:25,750

숫자를 추가하는 거라고 생각하면 돼요. 숫자를

2827
01:04:25,750 --> 01:04:25,760
숫자를 추가하는 거라고 생각하면 돼요. 숫자를
 

2828
01:04:25,760 --> 01:04:28,549
숫자를 추가하는 거라고 생각하면 돼요. 숫자를
추가하는 이유는 이 모든

2829
01:04:28,549 --> 01:04:29,750
추가하는 이유는 이 모든
 

2830
01:04:29,750 --> 01:04:32,390

 

2831
01:04:32,390 --> 01:04:32,400

 

2832
01:04:32,400 --> 01:04:34,069

것의 총합이 궁금할 때

2833
01:04:34,069 --> 01:04:34,079
것의 총합이 궁금할 때
 

2834
01:04:34,079 --> 01:04:35,589
것의 총합이 궁금할 때
그 숫자만 보면 되니까요. 이해되시나요? 자, 이제 거의 다 된 것

2835
01:04:35,589 --> 01:04:38,950
그 숫자만 보면 되니까요. 이해되시나요? 자, 이제 거의 다 된 것
 

2836
01:04:38,950 --> 01:04:38,960

 

2837
01:04:38,960 --> 01:04:41,510

같아요. 거의 다 끝났죠? 그럼

2838
01:04:41,510 --> 01:04:42,789
같아요. 거의 다 끝났죠? 그럼
 

2839
01:04:42,789 --> 01:04:42,799

 

2840
01:04:42,799 --> 01:04:45,829

어떻게 해야 할까요?

2841
01:04:45,829 --> 01:04:50,230
어떻게 해야 할까요?
 

2842
01:04:50,230 --> 01:04:50,240

 

2843
01:04:50,240 --> 01:04:54,309

이 데이터 구조로 수익을 어떻게 계산하는지 설명해 주시겠어요? 제가

2844
01:04:54,309 --> 01:04:54,319
이 데이터 구조로 수익을 어떻게 계산하는지 설명해 주시겠어요? 제가
 

2845
01:04:54,319 --> 01:04:56,950
이 데이터 구조로 수익을 어떻게 계산하는지 설명해 주시겠어요? 제가
말씀드렸듯이,

2846
01:04:56,950 --> 01:04:56,960
말씀드렸듯이,
 

2847
01:04:56,960 --> 01:04:57,670
말씀드렸듯이,
이 숫자를 보고

2848
01:04:57,670 --> 01:04:57,680
이 숫자를 보고
 

2849
01:04:57,680 --> 01:04:59,670
이 숫자를 보고
반환하면 돼요. 왜냐하면 이게

2850
01:04:59,670 --> 01:05:01,910
반환하면 돼요. 왜냐하면 이게
 

2851
01:05:01,910 --> 01:05:01,920

 

2852
01:05:01,920 --> 01:05:03,910

제가 데이터 구조에 유지해 온 불변성이기 때문이에요. 저는 이 불변성에 의존하고 있는 거예요.

2853
01:05:03,910 --> 01:05:03,920
제가 데이터 구조에 유지해 온 불변성이기 때문이에요. 저는 이 불변성에 의존하고 있는 거예요.
 

2854
01:05:03,920 --> 01:05:05,029
제가 데이터 구조에 유지해 온 불변성이기 때문이에요. 저는 이 불변성에 의존하고 있는 거예요.
이제 확실히 확인해야겠네요.

2855
01:05:05,029 --> 01:05:06,950
이제 확실히 확인해야겠네요.
 

2856
01:05:06,950 --> 01:05:06,960

 

2857
01:05:06,960 --> 01:05:08,950

동적 연산을 할 때 잘 작동하는지

2858
01:05:08,950 --> 01:05:08,960
동적 연산을 할 때 잘 작동하는지
 

2859
01:05:08,960 --> 01:05:11,670
동적 연산을 할 때 잘 작동하는지
확인하고 유지 관리합니다. 하지만

2860
01:05:11,670 --> 01:05:11,680
확인하고 유지 관리합니다. 하지만
 

2861
01:05:11,680 --> 01:05:13,109
확인하고 유지 관리합니다. 하지만
귀납적으로

2862
01:05:13,109 --> 01:05:13,119
귀납적으로
 

2863
01:05:13,119 --> 01:05:15,109
귀납적으로
모든 것이 제대로 작동하고

2864
01:05:15,109 --> 01:05:15,119
모든 것이 제대로 작동하고
 

2865
01:05:15,119 --> 01:05:17,349
모든 것이 제대로 작동하고
동적 연산을 수행할 때

2866
01:05:17,349 --> 01:05:17,359
동적 연산을 수행할 때
 

2867
01:05:17,359 --> 01:05:19,670
동적 연산을 수행할 때
모든 것이 유지된다는 것을 확신할 수 있다면 모든 것이

2868
01:05:19,670 --> 01:05:19,680
모든 것이 유지된다는 것을 확신할 수 있다면 모든 것이
 

2869
01:05:19,680 --> 01:05:22,789
모든 것이 유지된다는 것을 확신할 수 있다면 모든 것이
괜찮습니다. 그렇죠?

2870
01:05:22,789 --> 01:05:22,799
괜찮습니다. 그렇죠?
 

2871
01:05:22,799 --> 01:05:26,309
괜찮습니다. 그렇죠?
이렇게 추가 작업을 모두 마친 후에 수익을 얻는 것은

2872
01:05:26,309 --> 01:05:26,319
이렇게 추가 작업을 모두 마친 후에 수익을 얻는 것은
 

2873
01:05:26,319 --> 01:05:28,470
이렇게 추가 작업을 모두 마친 후에 수익을 얻는 것은
매우 쉽습니다. 이

2874
01:05:28,470 --> 01:05:28,480
매우 쉽습니다. 이
 

2875
01:05:28,480 --> 01:05:30,150
매우 쉽습니다. 이
숫자를 보고 반환하면 됩니다. 좋습니다.

2876
01:05:30,150 --> 01:05:30,160
숫자를 보고 반환하면 됩니다. 좋습니다.
 

2877
01:05:30,160 --> 01:05:32,789
숫자를 보고 반환하면 됩니다. 좋습니다.
데이터

2878
01:05:32,789 --> 01:05:32,799
데이터
 

2879
01:05:32,799 --> 01:05:34,309
데이터
구조 문제를 채점할 때 일반적으로

2880
01:05:34,309 --> 01:05:35,670
구조 문제를 채점할 때 일반적으로
 

2881
01:05:35,670 --> 01:05:35,680

 

2882
01:05:35,680 --> 01:05:37,589

데이터 구조를 연산과 별도로 설정하는 데 점수를 주고,

2883
01:05:37,589 --> 01:05:39,190
데이터 구조를 연산과 별도로 설정하는 데 점수를 주고,
 

2884
01:05:39,190 --> 01:05:40,470

 

2885
01:05:40,470 --> 01:05:42,390

 

2886
01:05:42,390 --> 01:05:42,400

 

2887
01:05:42,400 --> 01:05:43,910

성공적으로 처리한 연산마다 점수를 주고,

2888
01:05:43,910 --> 01:05:43,920
성공적으로 처리한 연산마다 점수를 주고,
 

2889
01:05:43,920 --> 01:05:45,750
성공적으로 처리한 연산마다 점수를 주고,
정확성과

2890
01:05:45,750 --> 01:05:45,760
정확성과
 

2891
01:05:45,760 --> 01:05:46,950
정확성과
실행 시간에도 점수를 줍니다.

2892
01:05:46,950 --> 01:05:46,960
실행 시간에도 점수를 줍니다.
 

2893
01:05:46,960 --> 01:05:50,230
실행 시간에도 점수를 줍니다.
네, 질문이 있습니다. '

2894
01:05:50,230 --> 01:05:50,240
네, 질문이 있습니다. '
 

2895
01:05:50,240 --> 01:05:51,829
네, 질문이 있습니다. '
total'은

2896
01:05:51,829 --> 01:05:51,839
total'은
 

2897
01:05:51,839 --> 01:05:53,510
total'은
우리가 최고 비터

2898
01:05:53,510 --> 01:05:55,510
우리가 최고 비터
 

2899
01:05:55,510 --> 01:05:55,520

 

2900
01:05:55,520 --> 01:05:56,870

트리(highest bitter tree)와

2901
01:05:56,870 --> 01:05:56,880
트리(highest bitter tree)와
 

2902
01:05:56,880 --> 01:05:59,430
트리(highest bitter tree)와
마이너스 k(mined k) 최고 비터 트리(highest bigger tree)를 조작할 때마다 업데이트되는 것과 같은 것인가요?

2903
01:05:59,430 --> 01:05:59,440
마이너스 k(mined k) 최고 비터 트리(highest bigger tree)를 조작할 때마다 업데이트되는 것과 같은 것인가요?
 

2904
01:05:59,440 --> 01:06:00,230
마이너스 k(mined k) 최고 비터 트리(highest bigger tree)를 조작할 때마다 업데이트되는 것과 같은 것인가요?
다시 말씀해 주시겠어요? 'total'을 무언가를 할 때

2905
01:06:00,230 --> 01:06:02,630
다시 말씀해 주시겠어요? 'total'을 무언가를 할 때
 

2906
01:06:02,630 --> 01:06:04,150

 

2907
01:06:04,150 --> 01:06:04,160

 

2908
01:06:04,160 --> 01:06:05,589

마다 업데이트되는 증강 변수처럼 취급하는 건가요? 네, 그렇습니다. 그냥

2909
01:06:05,589 --> 01:06:05,599
마다 업데이트되는 증강 변수처럼 취급하는 건가요? 네, 그렇습니다. 그냥
 

2910
01:06:05,599 --> 01:06:06,069
마다 업데이트되는 증강 변수처럼 취급하는 건가요? 네, 그렇습니다. 그냥

2911
01:06:06,069 --> 01:06:06,079

 

2912
01:06:06,079 --> 01:06:08,230

하나의 숫자일 뿐이고,

2913
01:06:08,230 --> 01:06:08,240
하나의 숫자일 뿐이고,
 

2914
01:06:08,240 --> 01:06:09,670
하나의 숫자일 뿐이고,
데이터 구조가 아니라 데이터베이스에 저장하는 하나의 숫자입니다. 좋습니다. 그럼

2915
01:06:09,670 --> 01:06:09,680
데이터 구조가 아니라 데이터베이스에 저장하는 하나의 숫자입니다. 좋습니다. 그럼
 

2916
01:06:09,680 --> 01:06:10,309
데이터 구조가 아니라 데이터베이스에 저장하는 하나의 숫자입니다. 좋습니다. 그럼

2917
01:06:10,309 --> 01:06:12,710

 

2918
01:06:12,710 --> 01:06:12,720

 

2919
01:06:12,720 --> 01:06:14,470


2920
01:06:14,470 --> 01:06:18,390

 

2921
01:06:18,390 --> 01:06:18,400

 

2922
01:06:18,400 --> 01:06:23,029

새로운 입찰 연산을 어떻게 구현하나요? 네, 다음과 같이

2923
01:06:23,029 --> 01:06:23,039

 

2924
01:06:23,039 --> 01:06:25,990

가정해도 될까요?  입찰

2925
01:06:25,990 --> 01:06:26,000
가정해도 될까요?  입찰
 

2926
01:06:26,000 --> 01:06:27,190
가정해도 될까요?  입찰
도 고유할 거라고

2927
01:06:27,190 --> 01:06:27,200
도 고유할 거라고
 

2928
01:06:27,200 --> 01:06:28,870
도 고유할 거라고
가정할 수 있을까요?

2929
01:06:28,870 --> 01:06:28,880
가정할 수 있을까요?
 

2930
01:06:28,880 --> 01:06:30,950
가정할 수 있을까요?
아니죠.

2931
01:06:30,950 --> 01:06:30,960
아니죠.
 

2932
01:06:30,960 --> 01:06:35,109
아니죠.
사실 이건

2933
01:06:35,109 --> 01:06:35,119
사실 이건
 

2934
01:06:35,119 --> 01:06:38,950
사실 이건
정말 유용한 관찰입니다.

2935
01:06:38,950 --> 01:06:38,960
정말 유용한 관찰입니다.
 

2936
01:06:38,960 --> 01:06:40,870
정말 유용한 관찰입니다.
우리는 지금까지 집합 데이터

2937
01:06:40,870 --> 01:06:40,880
우리는 지금까지 집합 데이터
 

2938
01:06:40,880 --> 01:06:42,230
우리는 지금까지 집합 데이터
구조가

2939
01:06:42,230 --> 01:06:42,240
구조가
 

2940
01:06:42,240 --> 01:06:47,270
구조가
고유 키를 요구한다고 이야기해 왔잖아요. 그렇다면

2941
01:06:47,270 --> 01:06:47,280
고유 키를 요구한다고 이야기해 왔잖아요. 그렇다면
 

2942
01:06:47,280 --> 01:06:48,870
고유 키를 요구한다고 이야기해 왔잖아요. 그렇다면
고유하지 않은 키는 어떻게 처리할까요?

2943
01:06:48,870 --> 01:06:48,880
고유하지 않은 키는 어떻게 처리할까요?
 

2944
01:06:48,880 --> 01:06:50,710
고유하지 않은 키는 어떻게 처리할까요?
해시

2945
01:06:50,710 --> 01:06:50,720
해시
 

2946
01:06:50,720 --> 01:06:52,309
해시
테이블에서는 키가 고유해야 한다는 것이 정말 중요합니다.

2947
01:06:52,309 --> 01:06:52,319
테이블에서는 키가 고유해야 한다는 것이 정말 중요합니다.
 

2948
01:06:52,319 --> 01:06:52,630
테이블에서는 키가 고유해야 한다는 것이 정말 중요합니다.

2949
01:06:52,630 --> 01:06:52,640

 

2950
01:06:52,640 --> 01:06:55,829

왜냐하면 저는 그

2951
01:06:55,829 --> 01:06:55,839
왜냐하면 저는 그
 

2952
01:06:55,839 --> 01:06:57,430
왜냐하면 저는 그
안에 해당 키가 있는지 확인해야 하고, 찾으면

2953
01:06:57,430 --> 01:06:57,990
안에 해당 키가 있는지 확인해야 하고, 찾으면
 

2954
01:06:57,990 --> 01:07:00,470

 

2955
01:07:00,470 --> 01:07:00,480

 

2956
01:07:00,480 --> 01:07:02,150

반환해야 하기 때문입니다. 만약 같은 키를 가진 항목이 여러 개 있다면,

2957
01:07:02,150 --> 01:07:03,109
반환해야 하기 때문입니다. 만약 같은 키를 가진 항목이 여러 개 있다면,
 

2958
01:07:03,109 --> 01:07:03,119

 

2959
01:07:03,119 --> 01:07:04,390

제가 찾고 있는 항목을 반환하지 못할 수도 있죠. 말이 안 되잖아요.

2960
01:07:04,390 --> 01:07:05,990
제가 찾고 있는 항목을 반환하지 못할 수도 있죠. 말이 안 되잖아요.
 

2961
01:07:05,990 --> 01:07:06,000

 

2962
01:07:06,000 --> 01:07:06,549


2963
01:07:06,549 --> 01:07:06,559

 

2964
01:07:06,559 --> 01:07:10,789

하지만 집합의 구조를 일반화해서

2965
01:07:10,789 --> 01:07:14,069
하지만 집합의 구조를 일반화해서
 

2966
01:07:14,069 --> 01:07:17,190

 

2967
01:07:17,190 --> 01:07:17,200

 

2968
01:07:17,200 --> 01:07:19,750

여러 개의 집합을 처리할 수 있습니다. 어떻게 할까요?

2969
01:07:19,750 --> 01:07:21,190
여러 개의 집합을 처리할 수 있습니다. 어떻게 할까요?
 

2970
01:07:21,190 --> 01:07:21,200

 

2971
01:07:21,200 --> 01:07:24,710

각 키에 대해

2972
01:07:24,710 --> 01:07:24,720
각 키에 대해
 

2973
01:07:24,720 --> 01:07:27,029
각 키에 대해
고유 키를 저장하는 겁니다. 각

2974
01:07:27,029 --> 01:07:27,039
고유 키를 저장하는 겁니다. 각
 

2975
01:07:27,039 --> 01:07:29,190
고유 키를 저장하는 겁니다. 각
키를 시퀀스 데이터

2976
01:07:29,190 --> 01:07:29,200
키를 시퀀스 데이터
 

2977
01:07:29,200 --> 01:07:29,990
키를 시퀀스 데이터
구조

2978
01:07:29,990 --> 01:07:30,000
구조
 

2979
01:07:30,000 --> 01:07:32,710
구조
나 다른 데이터 구조에 연결할 수 있습니다.

2980
01:07:32,710 --> 01:07:32,720
나 다른 데이터 구조에 연결할 수 있습니다.
 

2981
01:07:32,720 --> 01:07:33,990
나 다른 데이터 구조에 연결할 수 있습니다.
제가 하는 일은

2982
01:07:33,990 --> 01:07:34,000
제가 하는 일은
 

2983
01:07:34,000 --> 01:07:35,990
제가 하는 일은
해당 키를 가진 모든 항목을

2984
01:07:35,990 --> 01:07:36,000
해당 키를 가진 모든 항목을
 

2985
01:07:36,000 --> 01:07:37,990
해당 키를 가진 모든 항목을
그 데이터 구조에 저장하는 것입니다. 따라서

2986
01:07:37,990 --> 01:07:38,000
그 데이터 구조에 저장하는 것입니다. 따라서
 

2987
01:07:38,000 --> 01:07:39,589
그 데이터 구조에 저장하는 것입니다. 따라서
하나의 항목만 저장하는 대신

2988
01:07:39,589 --> 01:07:41,109
하나의 항목만 저장하는 대신
 

2989
01:07:41,109 --> 01:07:41,119

 

2990
01:07:41,119 --> 01:07:41,990

여러 항목을 저장할 수 있게 됩니다.

2991
01:07:41,990 --> 01:07:42,000
여러 항목을 저장할 수 있게 됩니다.
 

2992
01:07:42,000 --> 01:07:44,069
여러 항목을 저장할 수 있게 됩니다.
이제 코드를 변경해야 합니다.  여기서 의미론을 생각해 봅시다.

2993
01:07:44,069 --> 01:07:44,079
이제 코드를 변경해야 합니다.  여기서 의미론을 생각해 봅시다.
 

2994
01:07:44,079 --> 01:07:47,109
이제 코드를 변경해야 합니다.  여기서 의미론을 생각해 봅시다.
만약 제가 이 키로 검색하라고 한다면,

2995
01:07:47,109 --> 01:07:49,670
만약 제가 이 키로 검색하라고 한다면,
 

2996
01:07:49,670 --> 01:07:49,680

 

2997
01:07:49,680 --> 01:07:51,589

그 키를 가진 모든 항목을 반환하거나,

2998
01:07:51,589 --> 01:07:53,750
그 키를 가진 모든 항목을 반환하거나,
 

2999
01:07:53,750 --> 01:07:53,760

 

3000
01:07:53,760 --> 01:07:54,630

그 키를 가진 특정 항목을 보여줄 수도 있겠죠. 요점은,

3001
01:07:54,630 --> 01:07:54,640
그 키를 가진 특정 항목을 보여줄 수도 있겠죠. 요점은,
 

3002
01:07:54,640 --> 01:07:56,390
그 키를 가진 특정 항목을 보여줄 수도 있겠죠. 요점은,
제가 해야 할 일은

3003
01:07:56,390 --> 01:07:58,789
제가 해야 할 일은
 

3004
01:07:58,789 --> 01:08:00,549

 

3005
01:08:00,549 --> 01:08:00,559

 

3006
01:08:00,559 --> 01:08:01,990

이러한 항목들을 관리하기 위해 다른 데이터 구조에 매핑하는 것입니다. 예를 들어,

3007
01:08:01,990 --> 01:08:02,000
이러한 항목들을 관리하기 위해 다른 데이터 구조에 매핑하는 것입니다. 예를 들어,
 

3008
01:08:02,000 --> 01:08:06,230
이러한 항목들을 관리하기 위해 다른 데이터 구조에 매핑하는 것입니다. 예를 들어,
특정 키를 가진 모든 항목을 원하거나,

3009
01:08:06,230 --> 01:08:06,240

 

3010
01:08:06,240 --> 01:08:07,750

다른 키를 가진 항목을 찾고 싶을 수도 있습니다.

3011
01:08:07,750 --> 01:08:09,270
다른 키를 가진 항목을 찾고 싶을 수도 있습니다.
 

3012
01:08:09,270 --> 01:08:09,280

 

3013
01:08:09,280 --> 01:08:11,270

그러면 다른 키를 검색할 수 있는 집합 데이터 구조에 연결할 수 있겠죠.

3014
01:08:11,270 --> 01:08:12,870
그러면 다른 키를 검색할 수 있는 집합 데이터 구조에 연결할 수 있겠죠.
 

3015
01:08:12,870 --> 01:08:12,880

 

3016
01:08:12,880 --> 01:08:15,430

여기서 중요한 것은 키의

3017
01:08:15,430 --> 01:08:15,440
여기서 중요한 것은 키의
 

3018
01:08:15,440 --> 01:08:17,430
여기서 중요한 것은 키의
고유성 속성을 유지하는 것입니다. 즉,

3019
01:08:17,430 --> 01:08:19,749
고유성 속성을 유지하는 것입니다. 즉,
 

3020
01:08:19,749 --> 01:08:21,349

 

3021
01:08:21,349 --> 01:08:21,359

 

3022
01:08:21,359 --> 01:08:23,269

해당 키 위치에 여러 항목을 저장할 수 있도록 의미론을 완화해야 합니다. 이해되셨나요? 네,

3023
01:08:23,269 --> 01:08:24,630
해당 키 위치에 여러 항목을 저장할 수 있도록 의미론을 완화해야 합니다. 이해되셨나요? 네,
 

3024
01:08:24,630 --> 01:08:24,640

 

3025
01:08:24,640 --> 01:08:26,309

왜 '

3026
01:08:26,309 --> 01:08:26,319
왜 '
 

3027
01:08:26,319 --> 01:08:28,070
왜 '
entre'라고 했는지 여부가 중요할까요? 네, 중요합니다. 왜냐하면

3028
01:08:28,070 --> 01:08:31,110
entre'라고 했는지 여부가 중요할까요? 네, 중요합니다. 왜냐하면
 

3029
01:08:31,110 --> 01:08:34,229

 

3030
01:08:34,229 --> 01:08:34,239

 

3031
01:08:34,239 --> 01:08:35,349

입찰이 있기 때문입니다.

3032
01:08:35,349 --> 01:08:35,359
입찰이 있기 때문입니다.
 

3033
01:08:35,359 --> 01:08:37,510
입찰이 있기 때문입니다.
입찰은 고유하지 않을 수 있습니다.

3034
01:08:37,510 --> 01:08:37,520
입찰은 고유하지 않을 수 있습니다.
 

3035
01:08:37,520 --> 01:08:38,789
입찰은 고유하지 않을 수 있습니다.

3036
01:08:38,789 --> 01:08:38,799

 

3037
01:08:38,799 --> 01:08:41,910

두 사람이 같은

3038
01:08:41,910 --> 01:08:41,920
두 사람이 같은
 

3039
01:08:41,920 --> 01:08:45,590
두 사람이 같은
입찰을 할 수도 있죠. 집합 데이터 구조의 정의에 따르면

3040
01:08:45,590 --> 01:08:47,590
입찰을 할 수도 있죠. 집합 데이터 구조의 정의에 따르면
 

3041
01:08:47,590 --> 01:08:47,600

 

3042
01:08:47,600 --> 01:08:49,590

키는 고유해야 합니다. 따라서

3043
01:08:49,590 --> 01:08:49,600
키는 고유해야 합니다. 따라서
 

3044
01:08:49,600 --> 01:08:53,349
키는 고유해야 합니다. 따라서
입찰자를 키로 사용하는 모든 항목을 저장하면 문제가 발생합니다. 하지만

3045
01:08:53,349 --> 01:08:53,359
입찰자를 키로 사용하는 모든 항목을 저장하면 문제가 발생합니다. 하지만
 

3046
01:08:53,359 --> 01:08:54,950
입찰자를 키로 사용하는 모든 항목을 저장하면 문제가 발생합니다. 하지만
실제로는 다른 방식으로

3047
01:08:54,950 --> 01:08:54,960
실제로는 다른 방식으로
 

3048
01:08:54,960 --> 01:08:57,030
실제로는 다른 방식으로
저장할 수 있습니다.

3049
01:08:57,030 --> 01:08:57,040
저장할 수 있습니다.
 

3050
01:08:57,040 --> 01:08:58,709
저장할 수 있습니다.
해당 키를 가진 모든 항목을 저장하는 연결 리스트를 사용하면

3051
01:08:58,709 --> 01:08:58,719
해당 키를 가진 모든 항목을 저장하는 연결 리스트를 사용하면
 

3052
01:08:58,719 --> 01:09:01,349
해당 키를 가진 모든 항목을 저장하는 연결 리스트를 사용하면
괜찮을 것 같습니다.

3053
01:09:01,349 --> 01:09:01,359
괜찮을 것 같습니다.
 

3054
01:09:01,359 --> 01:09:04,789
괜찮을 것 같습니다.
그리고 필요할 때마다 해당 키를

3055
01:09:04,789 --> 01:09:04,799
그리고 필요할 때마다 해당 키를
 

3056
01:09:04,799 --> 01:09:06,870
그리고 필요할 때마다 해당 키를
반환하면 되죠. 하지만

3057
01:09:06,870 --> 01:09:06,880
반환하면 되죠. 하지만
 

3058
01:09:06,880 --> 01:09:08,950
반환하면 되죠. 하지만
이진 트리는

3059
01:09:08,950 --> 01:09:11,510
이진 트리는
 

3060
01:09:11,510 --> 01:09:11,520

 

3061
01:09:11,520 --> 01:09:14,070

대부분의 구현에서

3062
01:09:14,070 --> 01:09:14,080
대부분의 구현에서
 

3063
01:09:14,080 --> 01:09:16,070
대부분의 구현에서
여러 항목을 저장할 수 있을 만큼 유연합니다. 하지만 이렇게 하면

3064
01:09:16,070 --> 01:09:16,080
여러 항목을 저장할 수 있을 만큼 유연합니다. 하지만 이렇게 하면
 

3065
01:09:16,080 --> 01:09:18,309
여러 항목을 저장할 수 있을 만큼 유연합니다. 하지만 이렇게 하면
실행 시간이 더

3066
01:09:18,309 --> 01:09:18,319
실행 시간이 더
 

3067
01:09:18,319 --> 01:09:21,669
실행 시간이 더
오래 걸립니다.

3068
01:09:21,669 --> 01:09:21,679
오래 걸립니다.
 

3069
01:09:21,679 --> 01:09:23,910
오래 걸립니다.
시퀀스에서 '다음'을 찾는다는 것은 무엇을 의미할까요?

3070
01:09:23,910 --> 01:09:27,669
시퀀스에서 '다음'을 찾는다는 것은 무엇을 의미할까요?
 

3071
01:09:27,669 --> 01:09:30,709

 

3072
01:09:30,709 --> 01:09:30,719

 

3073
01:09:30,719 --> 01:09:31,910

이 키보다 큰 다음 항목을 반환한다는 것은 의미가

3074
01:09:31,910 --> 01:09:31,920
이 키보다 큰 다음 항목을 반환한다는 것은 의미가
 

3075
01:09:31,920 --> 01:09:33,669
이 키보다 큰 다음 항목을 반환한다는 것은 의미가
없습니다.

3076
01:09:33,669 --> 01:09:33,679
없습니다.
 

3077
01:09:33,679 --> 01:09:35,189
없습니다.
여러 항목이 있을 수 있는데 어떤 항목을

3078
01:09:35,189 --> 01:09:35,199
여러 항목이 있을 수 있는데 어떤 항목을
 

3079
01:09:35,199 --> 01:09:36,070
여러 항목이 있을 수 있는데 어떤 항목을
반환해야 할까요?

3080
01:09:36,070 --> 01:09:36,080
반환해야 할까요?
 

3081
01:09:36,080 --> 01:09:38,390
반환해야 할까요?
그리고 이 데이터 구조에서 '다음'을 반복적으로 호출하면

3082
01:09:38,390 --> 01:09:39,990
그리고 이 데이터 구조에서 '다음'을 반복적으로 호출하면
 

3083
01:09:39,990 --> 01:09:40,000

 

3084
01:09:40,000 --> 01:09:43,189

모든 항목을 순회하지 못할 수도 있습니다. 따라서

3085
01:09:43,189 --> 01:09:43,199
모든 항목을 순회하지 못할 수도 있습니다. 따라서
 

3086
01:09:43,199 --> 01:09:43,910
모든 항목을 순회하지 못할 수도 있습니다. 따라서

3087
01:09:43,910 --> 01:09:47,189

 

3088
01:09:47,189 --> 01:09:47,199

 

3089
01:09:47,199 --> 01:09:50,229

인터페이스에서 문제가 발생합니다. 이런

3090
01:09:50,229 --> 01:09:53,269
인터페이스에서 문제가 발생합니다. 이런
 

3091
01:09:53,269 --> 01:09:53,279

 

3092
01:09:53,279 --> 01:09:54,870

상황에서는 고유 키를 사용하는 것이 좋습니다.

3093
01:09:54,870 --> 01:09:54,880
상황에서는 고유 키를 사용하는 것이 좋습니다.
 

3094
01:09:54,880 --> 01:09:57,990
상황에서는 고유 키를 사용하는 것이 좋습니다.
다음 주 화요일에 이진 힙에 대해

3095
01:09:57,990 --> 01:09:58,000
다음 주 화요일에 이진 힙에 대해
 

3096
01:09:58,000 --> 01:10:01,189
다음 주 화요일에 이진 힙에 대해
다루겠지만, 고유하지 않은

3097
01:10:01,189 --> 01:10:06,070
다루겠지만, 고유하지 않은
 

3098
01:10:06,070 --> 01:10:06,080

 

3099
01:10:06,080 --> 01:10:08,790

키를 사용하려면

3100
01:10:08,790 --> 01:10:08,800
키를 사용하려면
 

3101
01:10:08,800 --> 01:10:09,270
키를 사용하려면

3102
01:10:09,270 --> 01:10:11,750

 

3103
01:10:11,750 --> 01:10:11,760

 

3104
01:10:11,760 --> 01:10:13,030

의미론에 조금 주의해야 합니다.

3105
01:10:13,030 --> 01:10:23,350
의미론에 조금 주의해야 합니다.
 

3106
01:10:23,350 --> 01:10:27,189

 

3107
01:10:27,189 --> 01:10:27,199

 

3108
01:10:27,199 --> 01:10:29,110

실행 시간은 같더라도 '무언가를

3109
01:10:29,110 --> 01:10:29,120
실행 시간은 같더라도 '무언가를
 

3110
01:10:29,120 --> 01:10:30,790
실행 시간은 같더라도 '무언가를
찾는다'는 의미를 바꿔야 합니다.

3111
01:10:30,790 --> 01:10:30,800
찾는다'는 의미를 바꿔야 합니다.
 

3112
01:10:30,800 --> 01:10:31,270
찾는다'는 의미를 바꿔야 합니다.

3113
01:10:31,270 --> 01:10:31,280

 

3114
01:10:31,280 --> 01:10:33,990

저는 그냥 이 키를 가진 아무거나 반환하고 싶습니다.

3115
01:10:33,990 --> 01:10:34,000
저는 그냥 이 키를 가진 아무거나 반환하고 싶습니다.
 

3116
01:10:34,000 --> 01:10:35,430
저는 그냥 이 키를 가진 아무거나 반환하고 싶습니다.
키,

3117
01:10:35,430 --> 01:10:35,440
키,
 

3118
01:10:35,440 --> 01:10:37,110
키,
맞죠? 모든 게 같은

3119
01:10:37,110 --> 01:10:37,120
맞죠? 모든 게 같은
 

3120
01:10:37,120 --> 01:10:39,750
맞죠? 모든 게 같은
키를 가진 경우 상수 시간이 걸리겠죠. 방금

3121
01:10:39,750 --> 01:10:39,760
키를 가진 경우 상수 시간이 걸리겠죠. 방금
 

3122
01:10:39,760 --> 01:10:43,990
키를 가진 경우 상수 시간이 걸리겠죠. 방금
첫 번째 결과를 반환했는데,

3123
01:10:43,990 --> 01:10:44,000
첫 번째 결과를 반환했는데,
 

3124
01:10:44,000 --> 01:10:47,110
첫 번째 결과를 반환했는데,
이건 특별한 경우라서

3125
01:10:47,110 --> 01:10:47,120
이건 특별한 경우라서
 

3126
01:10:47,120 --> 01:10:50,630
이건 특별한 경우라서
생각해야 하는 거죠. 저는

3127
01:10:50,630 --> 01:10:50,640
생각해야 하는 거죠. 저는
 

3128
01:10:50,640 --> 01:10:52,390
생각해야 하는 거죠. 저는
이런 걸 생각하는 걸 좋아하지 않아서, 그냥

3129
01:10:52,390 --> 01:10:53,830
이런 걸 생각하는 걸 좋아하지 않아서, 그냥
 

3130
01:10:53,830 --> 01:10:53,840

 

3131
01:10:53,840 --> 01:10:56,470

고유 키를 사용하는 걸 선호합니다. 고유하지 않은 키가 필요한

3132
01:10:56,470 --> 01:10:56,480
고유 키를 사용하는 걸 선호합니다. 고유하지 않은 키가 필요한
 

3133
01:10:56,480 --> 01:10:59,430
고유 키를 사용하는 걸 선호합니다. 고유하지 않은 키가 필요한
상황이 생기면, 해당

3134
01:10:59,430 --> 01:11:01,750
상황이 생기면, 해당
 

3135
01:11:01,750 --> 01:11:01,760

 

3136
01:11:01,760 --> 01:11:02,790

키에서 충돌이 발생하면

3137
01:11:02,790 --> 01:11:02,800
키에서 충돌이 발생하면
 

3138
01:11:02,800 --> 01:11:04,870
키에서 충돌이 발생하면
새로운 데이터 구조에 저장할 겁니다. 이렇게 하면

3139
01:11:04,870 --> 01:11:06,630
새로운 데이터 구조에 저장할 겁니다. 이렇게 하면
 

3140
01:11:06,630 --> 01:11:06,640

 

3141
01:11:06,640 --> 01:11:06,950


3142
01:11:06,950 --> 01:11:06,960

 

3143
01:11:06,960 --> 01:11:08,950

무슨 일이 일어나고 있는지 머릿속에서 분리하기가 더 쉽거든요.

3144
01:11:08,950 --> 01:11:08,960
무슨 일이 일어나고 있는지 머릿속에서 분리하기가 더 쉽거든요.
 

3145
01:11:08,960 --> 01:11:11,350
무슨 일이 일어나고 있는지 머릿속에서 분리하기가 더 쉽거든요.
우리가 제안한 실행 시간은

3146
01:11:11,350 --> 01:11:13,189
우리가 제안한 실행 시간은
 

3147
01:11:13,189 --> 01:11:13,199

 

3148
01:11:13,199 --> 01:11:14,390

고유 키에 대한 매우 강력한 정의를 가지고 있습니다.

3149
01:11:14,390 --> 01:11:15,590
고유 키에 대한 매우 강력한 정의를 가지고 있습니다.
 

3150
01:11:15,590 --> 01:11:15,600

 

3151
01:11:15,600 --> 01:11:17,510

다중 집합을 다룰 때는 조금 더

3152
01:11:17,510 --> 01:11:17,520
다중 집합을 다룰 때는 조금 더
 

3153
01:11:17,520 --> 01:11:20,070
다중 집합을 다룰 때는 조금 더
복잡해지죠.

3154
01:11:20,070 --> 01:11:20,080
복잡해지죠.
 

3155
01:11:20,080 --> 01:11:22,630
복잡해지죠.
다른 질문 있으신가요? 이제 다음으로

3156
01:11:22,630 --> 01:11:22,640
다른 질문 있으신가요? 이제 다음으로
 

3157
01:11:22,640 --> 01:11:23,830
다른 질문 있으신가요? 이제 다음으로
넘어가야 할 것 같네요.

3158
01:11:23,830 --> 01:11:23,840
넘어가야 할 것 같네요.
 

3159
01:11:23,840 --> 01:11:27,510
넘어가야 할 것 같네요.
딕셔너리, 케톤, 비터,

3160
01:11:27,510 --> 01:11:27,520
딕셔너리, 케톤, 비터,
 

3161
01:11:27,520 --> 01:11:30,070
딕셔너리, 케톤, 비터,
아직 동적 연산을 구현하지 않았는데,

3162
01:11:30,070 --> 01:11:30,080
아직 동적 연산을 구현하지 않았는데,
 

3163
01:11:30,080 --> 01:11:31,590
아직 동적 연산을 구현하지 않았는데,

3164
01:11:31,590 --> 01:11:31,600

 

3165
01:11:31,600 --> 01:11:35,910

새로운 입찰을 어떻게 해야 할까요?

3166
01:11:35,910 --> 01:11:35,920
새로운 입찰을 어떻게 해야 할까요?
 

3167
01:11:35,920 --> 01:11:37,910
새로운 입찰을 어떻게 해야 할까요?
업데이트를 위해 무엇이 필요할까요?

3168
01:11:37,910 --> 01:11:39,030
업데이트를 위해 무엇이 필요할까요?
 

3169
01:11:39,030 --> 01:11:39,040

 

3170
01:11:39,040 --> 01:11:42,390

기본적으로 각

3171
01:11:42,390 --> 01:11:42,400
기본적으로 각
 

3172
01:11:42,400 --> 01:11:44,070
기본적으로 각
데이터 구조에서

3173
01:11:44,070 --> 01:11:44,080
데이터 구조에서
 

3174
01:11:44,080 --> 01:11:47,430
데이터 구조에서
해당 입찰자를 찾을 수 있어야 합니다.

3175
01:11:47,430 --> 01:11:49,830
해당 입찰자를 찾을 수 있어야 합니다.
 

3176
01:11:49,830 --> 01:11:49,840

 

3177
01:11:49,840 --> 01:11:51,110

입찰가를 키로 사용하는 경우,

3178
01:11:51,110 --> 01:11:51,120
입찰가를 키로 사용하는 경우,
 

3179
01:11:51,120 --> 01:11:53,110
입찰가를 키로 사용하는 경우,
인터페이스는 이전 입찰가를 알려주지 않고 현재 입찰가만

3180
01:11:53,110 --> 01:11:54,630
인터페이스는 이전 입찰가를 알려주지 않고 현재 입찰가만
 

3181
01:11:54,630 --> 01:11:54,640

 

3182
01:11:54,640 --> 01:11:56,390

알려줍니다.  입찰자 ID가

3183
01:11:56,390 --> 01:11:56,400
알려줍니다.  입찰자 ID가
 

3184
01:11:56,400 --> 01:11:59,510
알려줍니다.  입찰자 ID가
맞다면, 입찰자 ID

3185
01:11:59,510 --> 01:11:59,520
맞다면, 입찰자 ID
 

3186
01:11:59,520 --> 01:12:02,149
맞다면, 입찰자 ID
와 새 입찰가만 있을 때

3187
01:12:02,149 --> 01:12:02,950
와 새 입찰가만 있을 때
 

3188
01:12:02,950 --> 01:12:02,960

 

3189
01:12:02,960 --> 01:12:04,550

이

3190
01:12:04,550 --> 01:12:04,560
이
 

3191
01:12:04,560 --> 01:12:06,229
이
데이터 구조들 중 어디에 있는지 어떻게 알아낼 수 있을까요? 이럴 때 필요한 건 딕셔너리에 해당 데이터가 어디에 있는지 가리키는

3192
01:12:06,229 --> 01:12:09,669
데이터 구조들 중 어디에 있는지 어떻게 알아낼 수 있을까요? 이럴 때 필요한 건 딕셔너리에 해당 데이터가 어디에 있는지 가리키는
 

3193
01:12:09,669 --> 01:12:12,790

 

3194
01:12:12,790 --> 01:12:12,800

 

3195
01:12:12,800 --> 01:12:16,149

포인터를 저장하는 것입니다. 이 포인터는 나중에 필요할 때 찾아볼 수 있죠. 이해가 되시나요? 이걸

3196
01:12:16,149 --> 01:12:18,149
포인터를 저장하는 것입니다. 이 포인터는 나중에 필요할 때 찾아볼 수 있죠. 이해가 되시나요? 이걸
 

3197
01:12:18,149 --> 01:12:21,030

 

3198
01:12:21,030 --> 01:12:21,040

 

3199
01:12:21,040 --> 01:12:23,030

크로스 링크라고 하는데,

3200
01:12:23,030 --> 01:12:23,040
크로스 링크라고 하는데,
 

3201
01:12:23,040 --> 01:12:25,110
크로스 링크라고 하는데,
문제 세트

3202
01:12:25,110 --> 01:12:25,120
문제 세트
 

3203
01:12:25,120 --> 01:12:26,790
문제 세트
2 같은 데서 조금 다뤄보셨을 수도 있습니다.

3204
01:12:26,790 --> 01:12:26,800
2 같은 데서 조금 다뤄보셨을 수도 있습니다.
 

3205
01:12:26,800 --> 01:12:28,550
2 같은 데서 조금 다뤄보셨을 수도 있습니다.
네, 특정 데이터를 가리키는 포인터를 저장하는 거죠.

3206
01:12:28,550 --> 01:12:30,470
네, 특정 데이터를 가리키는 포인터를 저장하는 거죠.
 

3207
01:12:30,470 --> 01:12:30,480

 

3208
01:12:30,480 --> 01:12:33,189

네, 맞습니다.

3209
01:12:33,189 --> 01:12:34,790
네, 맞습니다.
 

3210
01:12:34,790 --> 01:12:34,800

 

3211
01:12:34,800 --> 01:12:36,550

지금까지 처리한 모든 입찰자는 이 데이터

3212
01:12:36,550 --> 01:12:36,560
지금까지 처리한 모든 입찰자는 이 데이터
 

3213
01:12:36,560 --> 01:12:37,350
지금까지 처리한 모든 입찰자는 이 데이터
구조들 중

3214
01:12:37,350 --> 01:12:37,360
구조들 중
 

3215
01:12:37,360 --> 01:12:40,390
구조들 중
하나에 존재한다는 불변 조건이 있습니다. 특히,

3216
01:12:40,390 --> 01:12:40,400
하나에 존재한다는 불변 조건이 있습니다. 특히,
 

3217
01:12:40,400 --> 01:12:42,950
하나에 존재한다는 불변 조건이 있습니다. 특히,
집합 AVL 트리를 사용했기 때문에 특정 입찰자는 이 데이터 구조 중

3218
01:12:42,950 --> 01:12:42,960
집합 AVL 트리를 사용했기 때문에 특정 입찰자는 이 데이터 구조 중
 

3219
01:12:42,960 --> 01:12:43,750
집합 AVL 트리를 사용했기 때문에 특정 입찰자는 이 데이터 구조 중

3220
01:12:43,750 --> 01:12:43,760

 

3221
01:12:43,760 --> 01:12:45,669

하나의 노드에 존재합니다. 이 데이터 구조에서

3222
01:12:45,669 --> 01:12:46,870
하나의 노드에 존재합니다. 이 데이터 구조에서
 

3223
01:12:46,870 --> 01:12:50,630

 

3224
01:12:50,630 --> 01:12:53,990

 

3225
01:12:53,990 --> 01:12:54,000

 

3226
01:12:54,000 --> 01:12:56,709

각 입찰자 ID를 해당 위치에 매핑하는 포인터를 유지할 수 있습니다. 이게

3227
01:12:56,709 --> 01:12:58,870
각 입찰자 ID를 해당 위치에 매핑하는 포인터를 유지할 수 있습니다. 이게
 

3228
01:12:58,870 --> 01:12:58,880

 

3229
01:12:58,880 --> 01:13:00,470

왜 유용할까요? 예를 들어,

3230
01:13:00,470 --> 01:13:00,480
왜 유용할까요? 예를 들어,
 

3231
01:13:00,480 --> 01:13:01,990
왜 유용할까요? 예를 들어,

3232
01:13:01,990 --> 01:13:02,000

 

3233
01:13:02,000 --> 01:13:05,750

이 딕셔너리에 매핑 정보를 저장했다고 가정해 봅시다.

3234
01:13:05,750 --> 01:13:05,760
이 딕셔너리에 매핑 정보를 저장했다고 가정해 봅시다.
 

3235
01:13:05,760 --> 01:13:06,229
이 딕셔너리에 매핑 정보를 저장했다고 가정해 봅시다.

3236
01:13:06,229 --> 01:13:06,239

 

3237
01:13:06,239 --> 01:13:07,750

이 딕셔너리를 이용해서 원하는

3238
01:13:07,750 --> 01:13:07,760
이 딕셔너리를 이용해서 원하는
 

3239
01:13:07,760 --> 01:13:10,470
이 딕셔너리를 이용해서 원하는
실행 시간을 얻으려면

3240
01:13:10,470 --> 01:13:10,480
실행 시간을 얻으려면
 

3241
01:13:10,480 --> 01:13:12,950
실행 시간을 얻으려면
해시 테이블이나 집합을 사용할 수 있습니다.  AVL 트리를 사용하면

3242
01:13:12,950 --> 01:13:14,390
해시 테이블이나 집합을 사용할 수 있습니다.  AVL 트리를 사용하면
 

3243
01:13:14,390 --> 01:13:14,400

 

3244
01:13:14,400 --> 01:13:16,390

최악의 경우 로그 시간 복잡도를 갖게 됩니다.

3245
01:13:16,390 --> 01:13:16,400
최악의 경우 로그 시간 복잡도를 갖게 됩니다.
 

3246
01:13:16,400 --> 01:13:17,669
최악의 경우 로그 시간 복잡도를 갖게 됩니다.

3247
01:13:17,669 --> 01:13:17,679

 

3248
01:13:17,679 --> 01:13:18,709

해시 테이블을 사용하면

3249
01:13:18,709 --> 01:13:18,719
해시 테이블을 사용하면
 

3250
01:13:18,719 --> 01:13:21,030
해시 테이블을 사용하면
상수 시간 복잡도를 갖게 되지만, 이는 예상되는 결과입니다.

3251
01:13:21,030 --> 01:13:21,040
상수 시간 복잡도를 갖게 되지만, 이는 예상되는 결과입니다.
 

3252
01:13:21,040 --> 01:13:22,550
상수 시간 복잡도를 갖게 되지만, 이는 예상되는 결과입니다.
최악의 경우에도 선형 시간 복잡도를 가질 수 있습니다.

3253
01:13:22,550 --> 01:13:22,560
최악의 경우에도 선형 시간 복잡도를 가질 수 있습니다.
 

3254
01:13:22,560 --> 01:13:23,510
최악의 경우에도 선형 시간 복잡도를 가질 수 있습니다.

3255
01:13:23,510 --> 01:13:23,520

 

3256
01:13:23,520 --> 01:13:25,750

따라서 현재 사용하고 있는 AVL 트리를 사용할 것입니다. 이렇게 하면

3257
01:13:25,750 --> 01:13:27,510
따라서 현재 사용하고 있는 AVL 트리를 사용할 것입니다. 이렇게 하면
 

3258
01:13:27,510 --> 01:13:31,030

 

3259
01:13:31,030 --> 01:13:31,040

 

3260
01:13:31,040 --> 01:13:32,229

최악의 경우에도 시간 복잡도를 줄일 수 있습니다. 이제

3261
01:13:32,229 --> 01:13:32,239
최악의 경우에도 시간 복잡도를 줄일 수 있습니다. 이제
 

3262
01:13:32,239 --> 01:13:34,310
최악의 경우에도 시간 복잡도를 줄일 수 있습니다. 이제
각

3263
01:13:34,310 --> 01:13:34,320
각
 

3264
01:13:34,320 --> 01:13:35,350
각
객체에 대한 포인터를 저장할 것입니다.

3265
01:13:35,350 --> 01:13:36,709
객체에 대한 포인터를 저장할 것입니다.
 

3266
01:13:36,709 --> 01:13:36,719

 

3267
01:13:36,719 --> 01:13:40,550

먼저,

3268
01:13:40,550 --> 01:13:41,030
먼저,
 

3269
01:13:41,030 --> 01:13:41,040

 

3270
01:13:41,040 --> 01:13:43,910

새로운 Bitter 객체를 추가하는 작업을 수행합니다.

3271
01:13:43,910 --> 01:13:45,669
새로운 Bitter 객체를 추가하는 작업을 수행합니다.
 

3272
01:13:45,669 --> 01:13:48,950

 

3273
01:13:48,950 --> 01:13:52,229

 

3274
01:13:52,229 --> 01:13:52,239

 

3275
01:13:52,239 --> 01:13:54,950

Bitter 객체의 D와 B 값을 가져와서,

3276
01:13:54,950 --> 01:13:56,630
Bitter 객체의 D와 B 값을 가져와서,
 

3277
01:13:56,630 --> 01:13:56,640

 

3278
01:13:56,640 --> 01:13:57,590

이

3279
01:13:57,590 --> 01:13:57,600
이
 

3280
01:13:57,600 --> 01:14:01,590
이
데이터 구조에서 가장 작은 객체의 Bid가 삽입하려는 객체의 Bid보다 큰지 확인합니다.

3281
01:14:01,590 --> 01:14:04,950
데이터 구조에서 가장 작은 객체의 Bid가 삽입하려는 객체의 Bid보다 큰지 확인합니다.
 

3282
01:14:04,950 --> 01:14:04,960

 

3283
01:14:04,960 --> 01:14:07,910

만약 크다면, 이 데이터 구조는 건드리지 않고 바로 삽입합니다. 이제

3284
01:14:07,910 --> 01:14:09,430
만약 크다면, 이 데이터 구조는 건드리지 않고 바로 삽입합니다. 이제
 

3285
01:14:09,430 --> 01:14:10,709

 

3286
01:14:10,709 --> 01:14:11,750

 

3287
01:14:11,750 --> 01:14:11,760

 

3288
01:14:11,760 --> 01:14:14,310

삽입 후에는

3289
01:14:14,310 --> 01:14:14,320
삽입 후에는
 

3290
01:14:14,320 --> 01:14:15,510
삽입 후에는
데이터 구조에서 해당 객체의 정확한 위치를 알 수 있습니다.  방금

3291
01:14:15,510 --> 01:14:15,520
데이터 구조에서 해당 객체의 정확한 위치를 알 수 있습니다.  방금
 

3292
01:14:15,520 --> 01:14:16,950
데이터 구조에서 해당 객체의 정확한 위치를 알 수 있습니다.  방금
삽입한 구조입니다.

3293
01:14:16,950 --> 01:14:16,960
삽입한 구조입니다.
 

3294
01:14:16,960 --> 01:14:20,550
삽입한 구조입니다.
이제 이

3295
01:14:20,550 --> 01:14:20,560
이제 이
 

3296
01:14:20,560 --> 01:14:24,229
이제 이
노드를 손에 쥐고

3297
01:14:24,229 --> 01:14:26,229
노드를 손에 쥐고
 

3298
01:14:26,229 --> 01:14:27,510

 

3299
01:14:27,510 --> 01:14:27,520

 

3300
01:14:27,520 --> 01:14:30,470

비트 ID를 이용해 여기에 해당 비트를 삽입할 수 있습니다.

3301
01:14:30,470 --> 01:14:30,480
비트 ID를 이용해 여기에 해당 비트를 삽입할 수 있습니다.
 

3302
01:14:30,480 --> 01:14:31,750
비트 ID를 이용해 여기에 해당 비트를 삽입할 수 있습니다.
로그 시간 복잡도가 걸리겠죠.

3303
01:14:31,750 --> 01:14:31,760
로그 시간 복잡도가 걸리겠죠.
 

3304
01:14:31,760 --> 01:14:34,950
로그 시간 복잡도가 걸리겠죠.
이제 이 노드에

3305
01:14:34,950 --> 01:14:34,960
이제 이 노드에
 

3306
01:14:34,960 --> 01:14:37,750
이제 이 노드에
이 데이터 구조를 가리키는 포인터를 저장할 수 있습니다.

3307
01:14:37,750 --> 01:14:37,760
이 데이터 구조를 가리키는 포인터를 저장할 수 있습니다.
 

3308
01:14:37,760 --> 01:14:38,550
이 데이터 구조를 가리키는 포인터를 저장할 수 있습니다.
이해되셨나요?

3309
01:14:38,550 --> 01:14:38,560
이해되셨나요?
 

3310
01:14:38,560 --> 01:14:40,709
이해되셨나요?
다른 경우에도 비슷한 방식으로 합니다.

3311
01:14:40,709 --> 01:14:41,669
다른 경우에도 비슷한 방식으로 합니다.
 

3312
01:14:41,669 --> 01:14:41,679

 

3313
01:14:41,679 --> 01:14:43,510

만약 가장 작은 것보다 크다면,

3314
01:14:43,510 --> 01:14:43,520
만약 가장 작은 것보다 크다면,
 

3315
01:14:43,520 --> 01:14:45,590
만약 가장 작은 것보다 크다면,
작은 것을 빼내서

3316
01:14:45,590 --> 01:14:45,600
작은 것을 빼내서
 

3317
01:14:45,600 --> 01:14:46,229
작은 것을 빼내서
여기에 넣고,

3318
01:14:46,229 --> 01:14:46,239
여기에 넣고,
 

3319
01:14:46,239 --> 01:14:48,550
여기에 넣고,
새 것을 여기에 넣으면서

3320
01:14:48,550 --> 01:14:48,560
새 것을 여기에 넣으면서
 

3321
01:14:48,560 --> 01:14:49,510
새 것을 여기에 넣으면서

3322
01:14:49,510 --> 01:14:49,520

 

3323
01:14:49,520 --> 01:14:52,550

각 포인터를 서로 연결합니다. 이해가 되셨으면 좋겠네요.

3324
01:14:52,550 --> 01:14:57,430
각 포인터를 서로 연결합니다. 이해가 되셨으면 좋겠네요.
 

3325
01:14:57,430 --> 01:14:57,440

 

3326
01:14:57,440 --> 01:15:00,790

네,

3327
01:15:00,790 --> 01:15:00,800
네,
 

3328
01:15:00,800 --> 01:15:03,510
네,
업데이트도 매우 유사합니다.

3329
01:15:03,510 --> 01:15:04,709
업데이트도 매우 유사합니다.
 

3330
01:15:04,709 --> 01:15:04,719

 

3331
01:15:04,719 --> 01:15:07,189

특정 입찰자를 업데이트하고 싶다면, 이 데이터 구조에서

3332
01:15:07,189 --> 01:15:07,199
특정 입찰자를 업데이트하고 싶다면, 이 데이터 구조에서
 

3333
01:15:07,199 --> 01:15:07,910
특정 입찰자를 업데이트하고 싶다면, 이 데이터 구조에서

3334
01:15:07,910 --> 01:15:07,920

 

3335
01:15:07,920 --> 01:15:11,430

입찰자를 찾고,

3336
01:15:11,430 --> 01:15:11,440
입찰자를 찾고,
 

3337
01:15:11,440 --> 01:15:13,590
입찰자를 찾고,
해당 포인터를 따라

3338
01:15:13,590 --> 01:15:13,600
해당 포인터를 따라
 

3339
01:15:13,600 --> 01:15:15,510
해당 포인터를 따라
AVL 트리 중 하나에서 입찰자가 있는 위치로 이동합니다.

3340
01:15:15,510 --> 01:15:15,520
AVL 트리 중 하나에서 입찰자가 있는 위치로 이동합니다.
 

3341
01:15:15,520 --> 01:15:18,550
AVL 트리 중 하나에서 입찰자가 있는 위치로 이동합니다.
이 트리에 있으면

3342
01:15:18,550 --> 01:15:18,560
이 트리에 있으면
 

3343
01:15:18,560 --> 01:15:19,430
이 트리에 있으면

3344
01:15:19,430 --> 01:15:19,440

 

3345
01:15:19,440 --> 01:15:22,390

트리에서 제거하고, 아니면

3346
01:15:22,390 --> 01:15:23,750
트리에서 제거하고, 아니면
 

3347
01:15:23,750 --> 01:15:23,760

 

3348
01:15:23,760 --> 01:15:24,950


3349
01:15:24,950 --> 01:15:24,960

 

3350
01:15:24,960 --> 01:15:28,950

새 비트를 넣어서 다시 삽입합니다. 또

3351
01:15:28,950 --> 01:15:28,960
새 비트를 넣어서 다시 삽입합니다. 또
 

3352
01:15:28,960 --> 01:15:32,229
새 비트를 넣어서 다시 삽입합니다. 또
이 트리에 있으면 마찬가지로

3353
01:15:32,229 --> 01:15:32,239
이 트리에 있으면 마찬가지로
 

3354
01:15:32,239 --> 01:15:33,990
이 트리에 있으면 마찬가지로
트리에서 제거하고 다시 삽입합니다.

3355
01:15:33,990 --> 01:15:36,149
트리에서 제거하고 다시 삽입합니다.
 

3356
01:15:36,149 --> 01:15:36,159

 

3357
01:15:36,159 --> 01:15:38,310

그리고 필요에 따라 스왑 작업을 해야 할 수도 있습니다.

3358
01:15:38,310 --> 01:15:39,910
그리고 필요에 따라 스왑 작업을 해야 할 수도 있습니다.
 

3359
01:15:39,910 --> 01:15:39,920

 

3360
01:15:39,920 --> 01:15:41,590

이것이

3361
01:15:41,590 --> 01:15:41,600
이것이
 

3362
01:15:41,600 --> 01:15:44,149
이것이
가장 높은 권리를 갖고 있다는 것을 유지하기 위해 여기서 끊임없이 많은 것들이 오고 가고 있으며,  저는

3363
01:15:44,149 --> 01:15:44,159
가장 높은 권리를 갖고 있다는 것을 유지하기 위해 여기서 끊임없이 많은 것들이 오고 가고 있으며,  저는
 

3364
01:15:44,159 --> 01:15:47,510
가장 높은 권리를 갖고 있다는 것을 유지하기 위해 여기서 끊임없이 많은 것들이 오고 가고 있으며,  저는
동적인 연산을 수행하는데,

3365
01:15:47,510 --> 01:15:50,229

 

3366
01:15:50,229 --> 01:15:50,239

 

3367
01:15:50,239 --> 01:15:52,630

각 트리에서 일정한 수의 노드를 제거하고

3368
01:15:52,630 --> 01:15:52,640
각 트리에서 일정한 수의 노드를 제거하고
 

3369
01:15:52,640 --> 01:15:54,149
각 트리에서 일정한 수의 노드를 제거하고
일정한 수의 요소를 다시 추가합니다.

3370
01:15:54,149 --> 01:15:54,159
일정한 수의 요소를 다시 추가합니다.
 

3371
01:15:54,159 --> 01:15:56,390
일정한 수의 요소를 다시 추가합니다.
그리고 이 작업을 하는 동안

3372
01:15:56,390 --> 01:15:56,400
그리고 이 작업을 하는 동안
 

3373
01:15:56,400 --> 01:15:58,390
그리고 이 작업을 하는 동안
총계를 계속 업데이트합니다.

3374
01:15:58,390 --> 01:16:01,990
총계를 계속 업데이트합니다.
 

3375
01:16:01,990 --> 01:16:02,000

 

3376
01:16:02,000 --> 01:16:02,630


3377
01:16:02,630 --> 01:16:02,640

 

3378
01:16:02,640 --> 01:16:06,470

여기서 총계는 모든 입찰가의 합계입니다. 새로운 입찰가를 추가하면

3379
01:16:06,470 --> 01:16:07,189
여기서 총계는 모든 입찰가의 합계입니다. 새로운 입찰가를 추가하면
 

3380
01:16:07,189 --> 01:16:07,199

 

3381
01:16:07,199 --> 01:16:09,669

총계에 더해야 하고,

3382
01:16:09,669 --> 01:16:09,679
총계에 더해야 하고,
 

3383
01:16:09,679 --> 01:16:11,510
총계에 더해야 하고,
하나를 제거하면 총계에서 빼야 합니다.

3384
01:16:11,510 --> 01:16:11,520
하나를 제거하면 총계에서 빼야 합니다.
 

3385
01:16:11,520 --> 01:16:12,070
하나를 제거하면 총계에서 빼야 합니다.
하지만

3386
01:16:12,070 --> 01:16:12,080
하지만
 

3387
01:16:12,080 --> 01:16:13,510
하지만
다시 말하지만,

3388
01:16:13,510 --> 01:16:13,520
다시 말하지만,
 

3389
01:16:13,520 --> 01:16:15,030
다시 말하지만,
데이터 구조에서 이동하고 제거하는 요소의 수는 일정하므로 상수

3390
01:16:15,030 --> 01:16:15,040
데이터 구조에서 이동하고 제거하는 요소의 수는 일정하므로 상수
 

3391
01:16:15,040 --> 01:16:15,750
데이터 구조에서 이동하고 제거하는 요소의 수는 일정하므로 상수

3392
01:16:15,750 --> 01:16:17,270

 

3393
01:16:17,270 --> 01:16:17,280

 

3394
01:16:17,280 --> 01:16:19,669

시간 안에 업데이트할 수 있습니다. 이해가 되시나요?

3395
01:16:19,669 --> 01:16:19,679
시간 안에 업데이트할 수 있습니다. 이해가 되시나요?
 

3396
01:16:19,679 --> 01:16:23,110
시간 안에 업데이트할 수 있습니다. 이해가 되시나요?
여기서 조회, 삽입

3397
01:16:23,110 --> 01:16:23,120
여기서 조회, 삽입
 

3398
01:16:23,120 --> 01:16:24,390
여기서 조회, 삽입
및 삭제는

3399
01:16:24,390 --> 01:16:27,669
및 삭제는
 

3400
01:16:27,669 --> 01:16:27,679

 

3401
01:16:27,679 --> 01:16:30,229

최악의 경우 로그 시간 복잡도를 가지지만, 일정한 횟수만큼 수행하므로

3402
01:16:30,229 --> 01:16:31,110
최악의 경우 로그 시간 복잡도를 가지지만, 일정한 횟수만큼 수행하므로
 

3403
01:16:31,110 --> 01:16:31,120

 

3404
01:16:31,120 --> 01:16:33,189

시간 복잡도보다 오래 걸리지 않습니다. 이해가 되시나요? 이것이

3405
01:16:33,189 --> 01:16:34,310
시간 복잡도보다 오래 걸리지 않습니다. 이해가 되시나요? 이것이
 

3406
01:16:34,310 --> 01:16:34,320

 

3407
01:16:34,320 --> 01:16:37,189

이 문제의 핵심입니다. 조금

3408
01:16:37,189 --> 01:16:37,199
이 문제의 핵심입니다. 조금
 

3409
01:16:37,199 --> 01:16:37,590
이 문제의 핵심입니다. 조금

3410
01:16:37,590 --> 01:16:37,600

 

3411
01:16:37,600 --> 01:16:39,669

어렵죠?

3412
01:16:39,669 --> 01:16:39,679
어렵죠?
 

3413
01:16:39,679 --> 01:16:40,790
어렵죠?
여기에는 많은 요소가 있습니다.

3414
01:16:40,790 --> 01:16:40,800
여기에는 많은 요소가 있습니다.
 

3415
01:16:40,800 --> 01:16:43,110
여기에는 많은 요소가 있습니다.
하지만 문제를 "

3416
01:16:43,110 --> 01:16:44,470
하지만 문제를 "
 

3417
01:16:44,470 --> 01:16:46,550

 

3418
01:16:46,550 --> 01:16:48,070

 

3419
01:16:48,070 --> 01:16:48,080

 

3420
01:16:48,080 --> 01:16:50,630

데이터 구조에 대해 설명해 주세요"라는 부분으로 나누어 설명하면

3421
01:16:50,630 --> 01:16:50,640
데이터 구조에 대해 설명해 주세요"라는 부분으로 나누어 설명하면
 

3422
01:16:50,640 --> 01:16:52,229
데이터 구조에 대해 설명해 주세요"라는 부분으로 나누어 설명하면
알고리즘에 대한 설명은 실제로

3423
01:16:52,229 --> 01:16:52,709
알고리즘에 대한 설명은 실제로
 

3424
01:16:52,709 --> 01:16:52,719

 

3425
01:16:52,719 --> 01:16:56,310

상당히 간결해질 수 있습니다. 예를 들어, 이 문제에서는

3426
01:16:56,310 --> 01:16:59,030
상당히 간결해질 수 있습니다. 예를 들어, 이 문제에서는
 

3427
01:16:59,030 --> 01:16:59,040

 

3428
01:16:59,040 --> 01:17:00,550

세 가지 데이터를 설명해 주셔야 합니다.  구조에 대해 설명해 주시겠어요? 이

3429
01:17:00,550 --> 01:17:00,560
세 가지 데이터를 설명해 주셔야 합니다.  구조에 대해 설명해 주시겠어요? 이
 

3430
01:17:00,560 --> 01:17:03,830
세 가지 데이터를 설명해 주셔야 합니다.  구조에 대해 설명해 주시겠어요? 이
사람이 어떤 위치에 매핑되는지, 그리고 제가

3431
01:17:03,830 --> 01:17:03,840
사람이 어떤 위치에 매핑되는지, 그리고 제가
 

3432
01:17:03,840 --> 01:17:04,709
사람이 어떤 위치에 매핑되는지, 그리고 제가

3433
01:17:04,709 --> 01:17:04,719

 

3434
01:17:04,719 --> 01:17:08,229

이 사람을 어떻게 관리하는지 알려주세요. 그런 다음

3435
01:17:08,229 --> 01:17:10,310
이 사람을 어떻게 관리하는지 알려주세요. 그런 다음
 

3436
01:17:10,310 --> 01:17:10,320

 

3437
01:17:10,320 --> 01:17:12,149

동적 연산을 사용하여 이러한 것들을 관리하고, 의미 있는 쿼리 연산에 사용하면 됩니다.

3438
01:17:12,149 --> 01:17:15,189
동적 연산을 사용하여 이러한 것들을 관리하고, 의미 있는 쿼리 연산에 사용하면 됩니다.
 

3439
01:17:15,189 --> 01:17:16,470

 

3440
01:17:16,470 --> 01:17:16,480

 

3441
01:17:16,480 --> 01:17:19,510

좋아요,

3442
01:17:19,510 --> 01:17:19,520

 

3443
01:17:19,520 --> 01:17:25,750

10분 남았네요.

3444
01:17:25,750 --> 01:17:25,760

 

3445
01:17:25,760 --> 01:17:28,830

간단하게 네 가지 정도 설명해 드릴게요.

3446
01:17:28,830 --> 01:17:28,840
간단하게 네 가지 정도 설명해 드릴게요.
 

3447
01:17:28,840 --> 01:17:29,990
간단하게 네 가지 정도 설명해 드릴게요.

3448
01:17:29,990 --> 01:17:30,000

 

3449
01:17:30,000 --> 01:17:34,070

리시버 로스터요.

3450
01:17:34,070 --> 01:17:34,080
리시버 로스터요.
 

3451
01:17:34,080 --> 01:17:36,790
리시버 로스터요.
코치가 있고,

3452
01:17:36,790 --> 01:17:36,800

 

3453
01:17:36,800 --> 01:17:38,870

여러 명의 미식축구 선수(

3454
01:17:38,870 --> 01:17:38,880
여러 명의 미식축구 선수(
 

3455
01:17:38,880 --> 01:17:41,590
여러 명의 미식축구 선수(
리시버)들이

3456
01:17:41,590 --> 01:17:41,600

 

3457
01:17:41,600 --> 01:17:44,870

우리 팀에서 뛰고 싶어 합니다. 그중에서

3458
01:17:44,870 --> 01:17:47,910
우리 팀에서 뛰고 싶어 합니다. 그중에서
 

3459
01:17:47,910 --> 01:17:47,920

 

3460
01:17:47,920 --> 01:17:48,790

최고의 성적을 낸 선수들이 몇 명 있습니다. 여기서

3461
01:17:48,790 --> 01:17:50,550
최고의 성적을 낸 선수들이 몇 명 있습니다. 여기서
 

3462
01:17:50,550 --> 01:17:50,560

 

3463
01:17:50,560 --> 01:17:51,830

성적이란 선수들이 시스템에

3464
01:17:51,830 --> 01:17:53,510
성적이란 선수들이 시스템에
 

3465
01:17:53,510 --> 01:17:53,520

 

3466
01:17:53,520 --> 01:17:55,350

기록한 경기에서 얻은 평균 점수를 의미합니다.

3467
01:17:55,350 --> 01:17:56,070
기록한 경기에서 얻은 평균 점수를 의미합니다.
 

3468
01:17:56,070 --> 01:17:56,080

 

3469
01:17:56,080 --> 01:17:58,310

하지만 실제로는 데이터가

3470
01:17:58,310 --> 01:17:58,320
하지만 실제로는 데이터가
 

3471
01:17:58,320 --> 01:17:59,830
하지만 실제로는 데이터가
불완전합니다.

3472
01:17:59,830 --> 01:17:59,840
불완전합니다.
 

3473
01:17:59,840 --> 01:18:01,590
불완전합니다.
어떤 경기에서 몇 점을 득점했는지 알 수 없고

3474
01:18:01,590 --> 01:18:03,189
어떤 경기에서 몇 점을 득점했는지 알 수 없고
 

3475
01:18:03,189 --> 01:18:03,199

 

3476
01:18:03,199 --> 01:18:04,709

오류가 있을 수도 있습니다.

3477
01:18:04,709 --> 01:18:04,719
오류가 있을 수도 있습니다.
 

3478
01:18:04,719 --> 01:18:07,430
오류가 있을 수도 있습니다.
그래서 인턴들이

3479
01:18:07,430 --> 01:18:07,440
그래서 인턴들이
 

3480
01:18:07,440 --> 01:18:08,790
그래서 인턴들이
계속해서

3481
01:18:08,790 --> 01:18:08,800
계속해서
 

3482
01:18:08,800 --> 01:18:11,030
계속해서
쿼리를 통해 데이터베이스를 업데이트합니다. 예를 들어, "아,

3483
01:18:11,030 --> 01:18:14,070
쿼리를 통해 데이터베이스를 업데이트합니다. 예를 들어, "아,
 

3484
01:18:14,070 --> 01:18:14,080

 

3485
01:18:14,080 --> 01:18:15,990

이 선수는

3486
01:18:15,990 --> 01:18:16,000
이 선수는
 

3487
01:18:16,000 --> 01:18:17,910
이 선수는
이 경기에 출전하지 않았네요."

3488
01:18:17,910 --> 01:18:17,920
이 경기에 출전하지 않았네요."
 

3489
01:18:17,920 --> 01:18:20,470
이 경기에 출전하지 않았네요."
또는 "실제로 출전했고

3490
01:18:20,470 --> 01:18:20,480
또는 "실제로 출전했고
 

3491
01:18:20,480 --> 01:18:21,430
또는 "실제로 출전했고
몇 점을 득점했네요."와 같이 말이죠. 이렇게 정보를

3492
01:18:21,430 --> 01:18:21,440
몇 점을 득점했네요."와 같이 말이죠. 이렇게 정보를
 

3493
01:18:21,440 --> 01:18:24,870
몇 점을 득점했네요."와 같이 말이죠. 이렇게 정보를
정리하고 기록합니다. 그리고

3494
01:18:24,870 --> 01:18:24,880
정리하고 기록합니다. 그리고
 

3495
01:18:24,880 --> 01:18:27,669
정리하고 기록합니다. 그리고
어느 시점, 예를 들어

3496
01:18:27,669 --> 01:18:29,030
어느 시점, 예를 들어
 

3497
01:18:29,030 --> 01:18:29,040

 

3498
01:18:29,040 --> 01:18:31,669

경기를 시작할 때, 저는...

3499
01:18:31,669 --> 01:18:33,990
경기를 시작할 때, 저는...
 

3500
01:18:33,990 --> 01:18:34,000

 

3501
01:18:34,000 --> 01:18:36,630

k번째로 높은

3502
01:18:36,630 --> 01:18:36,640
k번째로 높은
 

3503
01:18:36,640 --> 01:18:39,030
k번째로 높은
경기력과 로그인 시간을 가진 선수를 반환할 수 있어야 합니다. 네,

3504
01:18:39,030 --> 01:18:39,040
경기력과 로그인 시간을 가진 선수를 반환할 수 있어야 합니다. 네,
 

3505
01:18:39,040 --> 01:18:42,790
경기력과 로그인 시간을 가진 선수를 반환할 수 있어야 합니다. 네,
이건 일종의

3506
01:18:42,790 --> 01:18:42,800
이건 일종의
 

3507
01:18:42,800 --> 01:18:45,750
이건 일종의
순위 쿼리죠. k번째로 높은 선수요.

3508
01:18:45,750 --> 01:18:45,760
순위 쿼리죠. k번째로 높은 선수요.
 

3509
01:18:45,760 --> 01:18:47,110
순위 쿼리죠. k번째로 높은 선수요.

3510
01:18:47,110 --> 01:18:47,120

 

3511
01:18:47,120 --> 01:18:49,910

사실 저는

3512
01:18:49,910 --> 01:18:49,920
사실 저는
 

3513
01:18:49,920 --> 01:18:50,470
사실 저는

3514
01:18:50,470 --> 01:18:50,480

 

3515
01:18:50,480 --> 01:18:54,070

가장 높은 경기력을 보인 선수 k명을 모두 반환하고 싶을 수도 있습니다. 그게

3516
01:18:54,070 --> 01:18:54,080
가장 높은 경기력을 보인 선수 k명을 모두 반환하고 싶을 수도 있습니다. 그게
 

3517
01:18:54,080 --> 01:18:54,550
가장 높은 경기력을 보인 선수 k명을 모두 반환하고 싶을 수도 있습니다. 그게
제

3518
01:18:54,550 --> 01:18:54,560
제
 

3519
01:18:54,560 --> 01:18:57,350
제
로스터가 될 수도 있으니까요. 하지만 이건 좀

3520
01:18:57,350 --> 01:18:57,360
로스터가 될 수도 있으니까요. 하지만 이건 좀
 

3521
01:18:57,360 --> 01:18:59,910
로스터가 될 수도 있으니까요. 하지만 이건 좀
더 일반적인 쿼리입니다.

3522
01:18:59,910 --> 01:18:59,920
더 일반적인 쿼리입니다.
 

3523
01:18:59,920 --> 01:19:02,950
더 일반적인 쿼리입니다.
더 구체적이죠.

3524
01:19:02,950 --> 01:19:02,960
더 구체적이죠.
 

3525
01:19:02,960 --> 01:19:04,950
더 구체적이죠.
완전히 비교할 수는 없지만,

3526
01:19:04,950 --> 01:19:04,960
완전히 비교할 수는 없지만,
 

3527
01:19:04,960 --> 01:19:06,790
완전히 비교할 수는 없지만,
왜 코치에게 유용할 수 있는지에 대한 아이디어를 얻을 수 있을 겁니다. 아닐 수도 있겠지만요. 자,

3528
01:19:06,790 --> 01:19:06,800
왜 코치에게 유용할 수 있는지에 대한 아이디어를 얻을 수 있을 겁니다. 아닐 수도 있겠지만요. 자,
 

3529
01:19:06,800 --> 01:19:07,510
왜 코치에게 유용할 수 있는지에 대한 아이디어를 얻을 수 있을 겁니다. 아닐 수도 있겠지만요. 자,

3530
01:19:07,510 --> 01:19:10,310

 

3531
01:19:10,310 --> 01:19:10,320

 

3532
01:19:10,320 --> 01:19:11,910

여기서 핵심은 무엇일까요?

3533
01:19:11,910 --> 01:19:11,920
여기서 핵심은 무엇일까요?
 

3534
01:19:11,920 --> 01:19:13,110
여기서 핵심은 무엇일까요?
여러 가지 요소가 있습니다.

3535
01:19:13,110 --> 01:19:13,120
여러 가지 요소가 있습니다.
 

3536
01:19:13,120 --> 01:19:15,110
여러 가지 요소가 있습니다.
경기는

3537
01:19:15,110 --> 01:19:15,120
경기는
 

3538
01:19:15,120 --> 01:19:17,189
경기는
고유 ID를 가지고 있고,

3539
01:19:17,189 --> 01:19:17,199
고유 ID를 가지고 있고,
 

3540
01:19:17,199 --> 01:19:19,510
고유 ID를 가지고 있고,
리시버도 고유 ID를 가지고 있습니다.

3541
01:19:19,510 --> 01:19:19,520
리시버도 고유 ID를 가지고 있습니다.
 

3542
01:19:19,520 --> 01:19:21,750
리시버도 고유 ID를 가지고 있습니다.
각 리시버는 여러 경기에 출전할 수 있죠.

3543
01:19:21,750 --> 01:19:21,760
각 리시버는 여러 경기에 출전할 수 있죠.
 

3544
01:19:21,760 --> 01:19:23,430
각 리시버는 여러 경기에 출전할 수 있죠.

3545
01:19:23,430 --> 01:19:23,440

 

3546
01:19:23,440 --> 01:19:26,550

아, 좀 걱정스럽네요.

3547
01:19:26,550 --> 01:19:26,560
아, 좀 걱정스럽네요.
 

3548
01:19:26,560 --> 01:19:29,030
아, 좀 걱정스럽네요.
여러 리시버가 같은 경기에 출전할 수도 있고요.

3549
01:19:29,030 --> 01:19:30,790
여러 리시버가 같은 경기에 출전할 수도 있고요.
 

3550
01:19:30,790 --> 01:19:30,800

 

3551
01:19:30,800 --> 01:19:32,950

이런 다대일 매핑은

3552
01:19:32,950 --> 01:19:32,960
이런 다대일 매핑은
 

3553
01:19:32,960 --> 01:19:34,310
이런 다대일 매핑은
좀 ​​복잡합니다.

3554
01:19:34,310 --> 01:19:34,320
좀 ​​복잡합니다.
 

3555
01:19:34,320 --> 01:19:38,950
좀 ​​복잡합니다.
그리고 각 선수/

3556
01:19:38,950 --> 01:19:38,960

 

3557
01:19:38,960 --> 01:19:40,790

리시버는 경기당 특정 점수를 가지고 있습니다.

3558
01:19:40,790 --> 01:19:42,070
리시버는 경기당 특정 점수를 가지고 있습니다.
 

3559
01:19:42,070 --> 01:19:42,080

 

3560
01:19:42,080 --> 01:19:44,950

우리는

3561
01:19:44,950 --> 01:19:44,960
우리는
 

3562
01:19:44,960 --> 01:19:46,550
우리는
그들의 경기력(합리적인

3563
01:19:46,550 --> 01:19:46,560
그들의 경기력(합리적인
 

3564
01:19:46,560 --> 01:19:48,830
그들의 경기력(합리적인
값)을 기준으로 정렬하려고 합니다. 경기력은

3565
01:19:48,830 --> 01:19:51,590
값)을 기준으로 정렬하려고 합니다. 경기력은
 

3566
01:19:51,590 --> 01:19:51,600

 

3567
01:19:51,600 --> 01:19:52,790

출전 경기 수

3568
01:19:52,790 --> 01:19:52,800
출전 경기 수
 

3569
01:19:52,800 --> 01:19:55,830
출전 경기 수
와 총 점수와 관련이 있죠. 이제 이해했습니다.

3570
01:19:55,830 --> 01:19:55,840
와 총 점수와 관련이 있죠. 이제 이해했습니다.
 

3571
01:19:55,840 --> 01:19:58,149
와 총 점수와 관련이 있죠. 이제 이해했습니다.
유리수는 계산할 수 없죠.

3572
01:19:58,149 --> 01:19:59,030
유리수는 계산할 수 없죠.
 

3573
01:19:59,030 --> 01:20:00,709

 

3574
01:20:00,709 --> 01:20:00,719

 

3575
01:20:00,719 --> 01:20:02,790

지난번 문제 풀이 시간에 얘기했던 거잖아요.

3576
01:20:02,790 --> 01:20:02,800
지난번 문제 풀이 시간에 얘기했던 거잖아요.
 

3577
01:20:02,800 --> 01:20:04,470
지난번 문제 풀이 시간에 얘기했던 거잖아요.
하지만 제가 할 수 있는 건 선수들이

3578
01:20:04,470 --> 01:20:04,480
하지만 제가 할 수 있는 건 선수들이
 

3579
01:20:04,480 --> 01:20:05,669
하지만 제가 할 수 있는 건 선수들이
플레이한 총 게임 수와

3580
01:20:05,669 --> 01:20:05,679
플레이한 총 게임 수와
 

3581
01:20:05,679 --> 01:20:07,110
플레이한 총 게임 수와
획득한 총 점수를 저장하는 거예요. 그리고 이런 식으로 데이터를

3582
01:20:07,110 --> 01:20:08,950
획득한 총 점수를 저장하는 거예요. 그리고 이런 식으로 데이터를
 

3583
01:20:08,950 --> 01:20:08,960

 

3584
01:20:08,960 --> 01:20:10,550

확장하면,

3585
01:20:10,550 --> 01:20:10,560
확장하면,
 

3586
01:20:10,560 --> 01:20:13,830
확장하면,
게임이 추가될 때마다

3587
01:20:13,830 --> 01:20:13,840
게임이 추가될 때마다
 

3588
01:20:13,840 --> 01:20:16,229
게임이 추가될 때마다
이런 작은 연산들을 통해

3589
01:20:16,229 --> 01:20:16,239
이런 작은 연산들을 통해
 

3590
01:20:16,239 --> 01:20:16,950
이런 작은 연산들을 통해

3591
01:20:16,950 --> 01:20:16,960

 

3592
01:20:16,960 --> 01:20:19,750

각 선수의 정보를 업데이트할 수 있죠. 만약

3593
01:20:19,750 --> 01:20:19,760
각 선수의 정보를 업데이트할 수 있죠. 만약
 

3594
01:20:19,760 --> 01:20:21,270
각 선수의 정보를 업데이트할 수 있죠. 만약

3595
01:20:21,270 --> 01:20:21,280

 

3596
01:20:21,280 --> 01:20:23,990

이런

3597
01:20:23,990 --> 01:20:24,000
이런
 

3598
01:20:24,000 --> 01:20:25,910
이런
동적 연산이 한 선수에게만 영향을 미친다면,

3599
01:20:25,910 --> 01:20:25,920
동적 연산이 한 선수에게만 영향을 미친다면,
 

3600
01:20:25,920 --> 01:20:27,110
동적 연산이 한 선수에게만 영향을 미친다면,

3601
01:20:27,110 --> 01:20:30,550

 

3602
01:20:30,550 --> 01:20:30,560

 

3603
01:20:30,560 --> 01:20:32,550

상수 시간 안에 정보를 업데이트할 수 있을 거예요.

3604
01:20:32,550 --> 01:20:32,560
상수 시간 안에 정보를 업데이트할 수 있을 거예요.
 

3605
01:20:32,560 --> 01:20:34,629
상수 시간 안에 정보를 업데이트할 수 있을 거예요.
선수 정보를 데이터베이스에 저장된

3606
01:20:34,629 --> 01:20:34,639
선수 정보를 데이터베이스에 저장된
 

3607
01:20:34,639 --> 01:20:37,030
선수 정보를 데이터베이스에 저장된
총 게임 수

3608
01:20:37,030 --> 01:20:38,629
총 게임 수
 

3609
01:20:38,629 --> 01:20:38,639

 

3610
01:20:38,639 --> 01:20:41,270

와 획득한 점수를 저장해 놓으면,

3611
01:20:41,270 --> 01:20:42,709
와 획득한 점수를 저장해 놓으면,
 

3612
01:20:42,709 --> 01:20:45,750

 

3613
01:20:45,750 --> 01:20:45,760

 

3614
01:20:45,760 --> 01:20:47,750

선수들을 성적 순으로 정렬해야 하는 데이터 구조가 있다고 가정해 볼게요. 예를 들어,

3615
01:20:47,750 --> 01:20:49,830
선수들을 성적 순으로 정렬해야 하는 데이터 구조가 있다고 가정해 볼게요. 예를 들어,
 

3616
01:20:49,830 --> 01:20:49,840

 

3617
01:20:49,840 --> 01:20:54,229

k번째로 성적이 높은 선수를 찾아야 할 때,

3618
01:20:54,229 --> 01:20:54,239
k번째로 성적이 높은 선수를 찾아야 할 때,
 

3619
01:20:54,239 --> 01:20:56,550
k번째로 성적이 높은 선수를 찾아야 할 때,
저는 성적을 직접 계산할 수는 없지만,

3620
01:20:56,550 --> 01:20:59,030
저는 성적을 직접 계산할 수는 없지만,
 

3621
01:20:59,030 --> 01:21:01,750

 

3622
01:21:01,750 --> 01:21:01,760

 

3623
01:21:01,760 --> 01:21:04,070

교차 곱셈을 이용해서 두 선수의 성적을 비교할 수 있어요.

3624
01:21:04,070 --> 01:21:07,030
교차 곱셈을 이용해서 두 선수의 성적을 비교할 수 있어요.
 

3625
01:21:07,030 --> 01:21:07,040

 

3626
01:21:07,040 --> 01:21:08,229

각 유리수의 분자와 분모를 알고 있으니까, 교차 곱셈을 통해 어느 쪽이

3627
01:21:08,229 --> 01:21:10,310
각 유리수의 분자와 분모를 알고 있으니까, 교차 곱셈을 통해 어느 쪽이
 

3628
01:21:10,310 --> 01:21:10,320

 

3629
01:21:10,320 --> 01:21:12,149

더 큰지 작은지 알아낼 수 있죠.

3630
01:21:12,149 --> 01:21:13,910
더 큰지 작은지 알아낼 수 있죠.
 

3631
01:21:13,910 --> 01:21:13,920

 

3632
01:21:13,920 --> 01:21:14,950

비교 변수만 있으면,

3633
01:21:14,950 --> 01:21:14,960
비교 변수만 있으면,
 

3634
01:21:14,960 --> 01:21:17,990
비교 변수만 있으면,
JBL을 설정할 수도 있고요.  자, 이제

3635
01:21:17,990 --> 01:21:18,000
JBL을 설정할 수도 있고요.  자, 이제
 

3636
01:21:18,000 --> 01:21:18,950
JBL을 설정할 수도 있고요.  자, 이제

3637
01:21:18,950 --> 01:21:21,189

 

3638
01:21:21,189 --> 01:21:22,950

 

3639
01:21:22,950 --> 01:21:22,960

 

3640
01:21:22,960 --> 01:21:26,830

이 데이터 구조의 구성 요소를 간략하게 설명해 드릴게요.

3641
01:21:26,830 --> 01:21:26,840
이 데이터 구조의 구성 요소를 간략하게 설명해 드릴게요.
 

3642
01:21:26,840 --> 01:21:30,709
이 데이터 구조의 구성 요소를 간략하게 설명해 드릴게요.
우선,

3643
01:21:30,709 --> 01:21:30,719
우선,
 

3644
01:21:30,719 --> 01:21:33,270
우선,
수신기를 기록해야 하는데, 수신기는

3645
01:21:33,270 --> 01:21:33,280
수신기를 기록해야 하는데, 수신기는
 

3646
01:21:33,280 --> 01:21:34,470
수신기를 기록해야 하는데, 수신기는
여러 게임을 가질 수 있죠.

3647
01:21:34,470 --> 01:21:34,480
여러 게임을 가질 수 있죠.
 

3648
01:21:34,480 --> 01:21:36,149
여러 게임을 가질 수 있죠.
중요한 건, 이건

3649
01:21:36,149 --> 01:21:36,159
중요한 건, 이건
 

3650
01:21:36,159 --> 01:21:38,070
중요한 건, 이건
수신기 중심적인 문제라는 거예요. 이해되시죠?

3651
01:21:38,070 --> 01:21:39,430
수신기 중심적인 문제라는 거예요. 이해되시죠?
 

3652
01:21:39,430 --> 01:21:41,990

 

3653
01:21:41,990 --> 01:21:42,000

 

3654
01:21:42,000 --> 01:21:43,830

모든 수신기가 게임을 플레이하는 걸 필터링하려는 게 아니에요. 시스템

3655
01:21:43,830 --> 01:21:48,390
모든 수신기가 게임을 플레이하는 걸 필터링하려는 게 아니에요. 시스템
 

3656
01:21:48,390 --> 01:21:48,400

 

3657
01:21:48,400 --> 01:21:49,910

에서 게임을 삭제하는 것도 아니고, 특정 수신기가

3658
01:21:49,910 --> 01:21:51,910
에서 게임을 삭제하는 것도 아니고, 특정 수신기가
 

3659
01:21:51,910 --> 01:21:51,920

 

3660
01:21:51,920 --> 01:21:53,990

특정

3661
01:21:53,990 --> 01:21:54,000
특정
 

3662
01:21:54,000 --> 01:21:55,510
특정
게임을 플레이하지 못하도록 막는 거예요. 이해가 되시나요?

3663
01:21:55,510 --> 01:21:55,520
게임을 플레이하지 못하도록 막는 거예요. 이해가 되시나요?
 

3664
01:21:55,520 --> 01:21:58,790
게임을 플레이하지 못하도록 막는 거예요. 이해가 되시나요?
수신기를 저장하고 각

3665
01:21:58,790 --> 01:21:58,800
수신기를 저장하고 각
 

3666
01:21:58,800 --> 01:21:59,830
수신기를 저장하고 각
수신기에

3667
01:21:59,830 --> 01:21:59,840
수신기에
 

3668
01:21:59,840 --> 01:22:02,149
수신기에
연결된 게임을 저장하려면

3669
01:22:02,149 --> 01:22:04,310
연결된 게임을 저장하려면
 

3670
01:22:04,310 --> 01:22:04,320

 

3671
01:22:04,320 --> 01:22:07,510

중첩된 데이터 구조가 필요할 수 있어요. 수신기

3672
01:22:07,510 --> 01:22:07,520
중첩된 데이터 구조가 필요할 수 있어요. 수신기
 

3673
01:22:07,520 --> 01:22:10,149
중첩된 데이터 구조가 필요할 수 있어요. 수신기
에 대한 딕셔너리를 만들고,

3674
01:22:10,149 --> 01:22:10,159
에 대한 딕셔너리를 만들고,
 

3675
01:22:10,159 --> 01:22:11,430
에 대한 딕셔너리를 만들고,

3676
01:22:11,430 --> 01:22:11,440

 

3677
01:22:11,440 --> 01:22:14,229

각 수신기에 대해 플레이한 모든 게임을 다른

3678
01:22:14,229 --> 01:22:15,350
각 수신기에 대해 플레이한 모든 게임을 다른
 

3679
01:22:15,350 --> 01:22:15,360

 

3680
01:22:15,360 --> 01:22:17,430

데이터 구조에 저장하는 거죠.

3681
01:22:17,430 --> 01:22:17,440
데이터 구조에 저장하는 거죠.
 

3682
01:22:17,440 --> 01:22:18,470
데이터 구조에 저장하는 거죠.
각 수신기마다 플레이한

3683
01:22:18,470 --> 01:22:20,709
각 수신기마다 플레이한
 

3684
01:22:20,709 --> 01:22:20,719

 

3685
01:22:20,719 --> 01:22:22,070

모든 게임을 담은 또 다른 데이터 구조를 만드는 거예요.

3686
01:22:22,070 --> 01:22:22,080
모든 게임을 담은 또 다른 데이터 구조를 만드는 거예요.
 

3687
01:22:22,080 --> 01:22:23,430
모든 게임을 담은 또 다른 데이터 구조를 만드는 거예요.
이해되시죠?

3688
01:22:23,430 --> 01:22:23,440
이해되시죠?
 

3689
01:22:23,440 --> 01:22:26,629
이해되시죠?
그래서 아이디어는 이렇습니다.

3690
01:22:26,629 --> 01:22:27,430
그래서 아이디어는 이렇습니다.
 

3691
01:22:27,430 --> 01:22:27,440

 

3692
01:22:27,440 --> 01:22:30,470

수신기를 조회할 수 있어야 해요.

3693
01:22:30,470 --> 01:22:30,480
수신기를 조회할 수 있어야 해요.
 

3694
01:22:30,480 --> 01:22:33,270
수신기를 조회할 수 있어야 해요.
왜냐하면 수신기를

3695
01:22:33,270 --> 01:22:33,280
왜냐하면 수신기를
 

3696
01:22:33,280 --> 01:22:34,390
왜냐하면 수신기를
초기화하거나 삭제할 수 있어야 하니까요.  지금

3697
01:22:34,390 --> 01:22:34,400
초기화하거나 삭제할 수 있어야 하니까요.  지금
 

3698
01:22:34,400 --> 01:22:37,189
초기화하거나 삭제할 수 있어야 하니까요.  지금
녹음 중이니까, 일종의

3699
01:22:37,189 --> 01:22:38,390
녹음 중이니까, 일종의
 

3700
01:22:38,390 --> 01:22:38,400

 

3701
01:22:38,400 --> 01:22:40,709

사전 같은 걸 만들 거예요.

3702
01:22:40,709 --> 01:22:40,719
사전 같은 걸 만들 거예요.
 

3703
01:22:40,719 --> 01:22:42,709
사전 같은 걸 만들 거예요.
최악의 경우 로그인 시간을 찾고 있으니까요.

3704
01:22:42,709 --> 01:22:42,719
최악의 경우 로그인 시간을 찾고 있으니까요.
 

3705
01:22:42,719 --> 01:22:44,550
최악의 경우 로그인 시간을 찾고 있으니까요.
그래서

3706
01:22:44,550 --> 01:22:44,560
그래서
 

3707
01:22:44,560 --> 01:22:46,229
그래서
사전 추상화는 건너뛰고 바로 `available`

3708
01:22:46,229 --> 01:22:46,239
사전 추상화는 건너뛰고 바로 `available`
 

3709
01:22:46,239 --> 01:22:49,110
사전 추상화는 건너뛰고 바로 `available`
세트를 사용할 거예요.

3710
01:22:49,110 --> 01:22:52,870
세트를 사용할 거예요.
 

3711
01:22:52,870 --> 01:22:56,229

 

3712
01:22:56,229 --> 01:22:56,239

 

3713
01:22:56,239 --> 01:23:00,070

수신자를 기준으로 `c`

3714
01:23:00,070 --> 01:23:00,080
수신자를 기준으로 `c`
 

3715
01:23:00,080 --> 01:23:05,110
수신자를 기준으로 `c`
이전은 `e`로, `c` 이후는 `i`로 설정하는 규칙이 있는데,

3716
01:23:05,110 --> 01:23:08,550

 

3717
01:23:08,550 --> 01:23:08,560

 

3718
01:23:08,560 --> 01:23:11,750

이 규칙은 절대 안 되죠. 그래서

3719
01:23:11,750 --> 01:23:11,760
이 규칙은 절대 안 되죠. 그래서
 

3720
01:23:11,760 --> 01:23:15,189
이 규칙은 절대 안 되죠. 그래서
수신자 트리에 `available`을 설정하고,

3721
01:23:15,189 --> 01:23:18,149
수신자 트리에 `available`을 설정하고,
 

3722
01:23:18,149 --> 01:23:18,159

 

3723
01:23:18,159 --> 01:23:21,189

각 수신자의 노드마다 `available`을

3724
01:23:21,189 --> 01:23:21,199
각 수신자의 노드마다 `available`을
 

3725
01:23:21,199 --> 01:23:24,500
각 수신자의 노드마다 `available`을
저장할 거예요. 각 수신자에 대해 `available`을

3726
01:23:24,500 --> 01:23:24,510
저장할 거예요. 각 수신자에 대해 `available`을
 

3727
01:23:24,510 --> 01:23:25,910
저장할 거예요. 각 수신자에 대해 `available`을

3728
01:23:25,910 --> 01:23:25,920

 

3729
01:23:25,920 --> 01:23:29,590

저장하는 거죠.

3730
01:23:29,590 --> 01:23:35,430
저장하는 거죠.
 

3731
01:23:35,430 --> 01:23:35,440

 

3732
01:23:35,440 --> 01:23:38,310

왜 게임

3733
01:23:38,310 --> 01:23:38,320
왜 게임
 

3734
01:23:38,320 --> 01:23:39,910
왜 게임
목록을 저장하지 않고 게임 트리에 저장하냐고요?

3735
01:23:39,910 --> 01:23:39,920
목록을 저장하지 않고 게임 트리에 저장하냐고요?
 

3736
01:23:39,920 --> 01:23:42,310
목록을 저장하지 않고 게임 트리에 저장하냐고요?

3737
01:23:42,310 --> 01:23:42,320

 

3738
01:23:42,320 --> 01:23:44,229

만약 특정 수신자에서 게임을 제거하려면

3739
01:23:44,229 --> 01:23:46,310
만약 특정 수신자에서 게임을 제거하려면
 

3740
01:23:46,310 --> 01:23:46,320

 

3741
01:23:46,320 --> 01:23:47,669

로그인 시간 내에 제거해야 하기 때문이에요.

3742
01:23:47,669 --> 01:23:47,679
로그인 시간 내에 제거해야 하기 때문이에요.
 

3743
01:23:47,679 --> 01:23:49,910
로그인 시간 내에 제거해야 하기 때문이에요.
여기서 n은

3744
01:23:49,910 --> 01:23:49,920
여기서 n은
 

3745
01:23:49,920 --> 01:23:51,270
여기서 n은
게임의 개수인데,

3746
01:23:51,270 --> 01:23:53,590
게임의 개수인데,
 

3747
01:23:53,590 --> 01:23:53,600

 

3748
01:23:53,600 --> 01:23:55,030

팀의 수신자 수는 항상 게임 수보다 적어요.

3749
01:23:55,030 --> 01:23:55,040
팀의 수신자 수는 항상 게임 수보다 적어요.
 

3750
01:23:55,040 --> 01:23:56,149
팀의 수신자 수는 항상 게임 수보다 적어요.
그러니까

3751
01:23:56,149 --> 01:23:56,159
그러니까
 

3752
01:23:56,159 --> 01:23:59,270
그러니까
이 `available` 트리

3753
01:23:59,270 --> 01:23:59,280
이 `available` 트리
 

3754
01:23:59,280 --> 01:24:02,390
이 `available` 트리
와 해당 수신자의 `available` 트리에서 검색하면,

3755
01:24:02,390 --> 01:24:02,400
와 해당 수신자의 `available` 트리에서 검색하면,
 

3756
01:24:02,400 --> 01:24:04,149
와 해당 수신자의 `available` 트리에서 검색하면,
두 검색 모두 로그인 시간 내에만 이루어졌다는 걸 확신할 수 있죠.

3757
01:24:04,149 --> 01:24:06,070
두 검색 모두 로그인 시간 내에만 이루어졌다는 걸 확신할 수 있죠.
 

3758
01:24:06,070 --> 01:24:08,229

 

3759
01:24:08,229 --> 01:24:08,239

 

3760
01:24:08,239 --> 01:24:09,189

게임을 제거해야 할 수도 있으니까요.  자,

3761
01:24:09,189 --> 01:24:09,199
게임을 제거해야 할 수도 있으니까요.  자,
 

3762
01:24:09,199 --> 01:24:12,310
게임을 제거해야 할 수도 있으니까요.  자,
그럼

3763
01:24:12,310 --> 01:24:12,320
그럼
 

3764
01:24:12,320 --> 01:24:14,629
그럼
제가 뭘 하고 있는지 아시겠죠? 저는 k번째로

3765
01:24:14,629 --> 01:24:14,639
제가 뭘 하고 있는지 아시겠죠? 저는 k번째로
 

3766
01:24:14,639 --> 01:24:16,709
제가 뭘 하고 있는지 아시겠죠? 저는 k번째로
높은 성적을 반환하고 있습니다. 각 플레이어마다 필요한 건,

3767
01:24:16,709 --> 01:24:18,229
높은 성적을 반환하고 있습니다. 각 플레이어마다 필요한 건,
 

3768
01:24:18,229 --> 01:24:22,870

 

3769
01:24:22,870 --> 01:24:22,880

 

3770
01:24:22,880 --> 01:24:25,110

이 게임에서 얻은 점수의 합계와 게임 수를 저장하는 겁니다.

3771
01:24:25,110 --> 01:24:28,070
이 게임에서 얻은 점수의 합계와 게임 수를 저장하는 겁니다.
 

3772
01:24:28,070 --> 01:24:32,310

 

3773
01:24:32,310 --> 01:24:36,790

 

3774
01:24:36,790 --> 01:24:39,910

 

3775
01:24:39,910 --> 01:24:39,920

 

3776
01:24:39,920 --> 01:24:41,590

이 두 가지를

3777
01:24:41,590 --> 01:24:41,600
이 두 가지를
 

3778
01:24:41,600 --> 01:24:43,510
이 두 가지를
상수 시간 안에 저장하면 성적을 계산할 수 있으니까요. 그러면 성적을

3779
01:24:43,510 --> 01:24:43,520
상수 시간 안에 저장하면 성적을 계산할 수 있으니까요. 그러면 성적을
 

3780
01:24:43,520 --> 01:24:43,990
상수 시간 안에 저장하면 성적을 계산할 수 있으니까요. 그러면 성적을

3781
01:24:43,990 --> 01:24:46,629

 

3782
01:24:46,629 --> 01:24:47,430

 

3783
01:24:47,430 --> 01:24:47,440

 

3784
01:24:47,440 --> 01:24:49,830

비교하는 데 필요한 데이터를 얻을 수 있습니다. 변수는 필요

3785
01:24:49,830 --> 01:24:49,840
비교하는 데 필요한 데이터를 얻을 수 있습니다. 변수는 필요
 

3786
01:24:49,840 --> 01:24:51,430
비교하는 데 필요한 데이터를 얻을 수 있습니다. 변수는 필요
없고, 그냥

3787
01:24:51,430 --> 01:24:53,590
없고, 그냥
 

3788
01:24:53,590 --> 01:24:53,600

 

3789
01:24:53,600 --> 01:24:54,550

숫자만 있으면 됩니다.

3790
01:24:54,550 --> 01:24:54,560
숫자만 있으면 됩니다.
 

3791
01:24:54,560 --> 01:24:55,990
숫자만 있으면 됩니다.
이건 데이터 구조가 아니라

3792
01:24:55,990 --> 01:24:56,000
이건 데이터 구조가 아니라
 

3793
01:24:56,000 --> 01:24:58,709
이건 데이터 구조가 아니라
숫자입니다. 각 수신기에 이 데이터를

3794
01:24:58,709 --> 01:24:58,719
숫자입니다. 각 수신기에 이 데이터를
 

3795
01:24:58,719 --> 01:25:02,790
숫자입니다. 각 수신기에 이 데이터를
저장하고 있지만, 이것으로는

3796
01:25:02,790 --> 01:25:06,070
저장하고 있지만, 이것으로는
 

3797
01:25:06,070 --> 01:25:06,080

 

3798
01:25:06,080 --> 01:25:07,430

k번째로

3799
01:25:07,430 --> 01:25:07,440
k번째로
 

3800
01:25:07,440 --> 01:25:09,189
k번째로
높은 성적을 가진 플레이어를 찾을 수 없습니다. 이 모든 데이터는

3801
01:25:09,189 --> 01:25:09,199
높은 성적을 가진 플레이어를 찾을 수 없습니다. 이 모든 데이터는
 

3802
01:25:09,199 --> 01:25:13,350
높은 성적을 가진 플레이어를 찾을 수 없습니다. 이 모든 데이터는
성적 순으로 정렬되어 있지 않기 때문입니다.

3803
01:25:13,350 --> 01:25:13,360
성적 순으로 정렬되어 있지 않기 때문입니다.
 

3804
01:25:13,360 --> 01:25:24,830
성적 순으로 정렬되어 있지 않기 때문입니다.
그래서 마지막으로 필요한 데이터 구조, 즉

3805
01:25:24,830 --> 01:25:24,840

 

3806
01:25:24,840 --> 01:25:28,310


3807
01:25:28,310 --> 01:25:30,470

 

3808
01:25:30,470 --> 01:25:31,430

 

3809
01:25:31,430 --> 01:25:31,440

 

3810
01:25:31,440 --> 01:25:35,669

성적 순으로 동적으로 정렬된 데이터를 저장해야 합니다. 네,

3811
01:25:35,669 --> 01:25:35,679
성적 순으로 동적으로 정렬된 데이터를 저장해야 합니다. 네,
 

3812
01:25:35,679 --> 01:25:40,629
성적 순으로 동적으로 정렬된 데이터를 저장해야 합니다. 네,
AVL을 설정하고 수신기를 성적을 기준으로 저장하는 겁니다. 여기서 '성적을

3813
01:25:40,629 --> 01:25:40,639
AVL을 설정하고 수신기를 성적을 기준으로 저장하는 겁니다. 여기서 '성적을
 

3814
01:25:40,639 --> 01:25:45,990
AVL을 설정하고 수신기를 성적을 기준으로 저장하는 겁니다. 여기서 '성적을

3815
01:25:45,990 --> 01:25:49,590

 

3816
01:25:49,590 --> 01:25:49,600

 

3817
01:25:49,600 --> 01:25:53,270

기준으로'라고 했을 때,

3818
01:25:53,270 --> 01:25:53,280
기준으로'라고 했을 때,
 

3819
01:25:53,280 --> 01:25:55,510
기준으로'라고 했을 때,

3820
01:25:55,510 --> 01:25:57,189

 

3821
01:25:57,189 --> 01:25:57,199

 

3822
01:25:57,199 --> 01:25:58,550

교차 곱셈에 대해서도 언급해야겠죠?

3823
01:25:58,550 --> 01:25:58,560
교차 곱셈에 대해서도 언급해야겠죠?
 

3824
01:25:58,560 --> 01:26:00,070
교차 곱셈에 대해서도 언급해야겠죠?
각 수신기에 이 점수를 저장하고,

3825
01:26:00,070 --> 01:26:02,470
각 수신기에 이 점수를 저장하고,
 

3826
01:26:02,470 --> 01:26:02,480

 

3827
01:26:02,480 --> 01:26:04,070

두 가지를 비교할 때는

3828
01:26:04,070 --> 01:26:04,080
두 가지를 비교할 때는
 

3829
01:26:04,080 --> 01:26:05,750
두 가지를 비교할 때는
교차 곱셈을 사용합니다.

3830
01:26:05,750 --> 01:26:05,760
교차 곱셈을 사용합니다.
 

3831
01:26:05,760 --> 01:26:07,990
교차 곱셈을 사용합니다.
하지만 그 외에는 추상화할 수 있죠.

3832
01:26:07,990 --> 01:26:09,030
하지만 그 외에는 추상화할 수 있죠.
 

3833
01:26:09,030 --> 01:26:09,040

 

3834
01:26:09,040 --> 01:26:12,070

함수 호출을 추상화했고,

3835
01:26:12,070 --> 01:26:12,080
함수 호출을 추상화했고,
 

3836
01:26:12,080 --> 01:26:14,550
함수 호출을 추상화했고,
두 키를 비교하는 것도 가능하다고 생각해요.

3837
01:26:14,550 --> 01:26:14,560
두 키를 비교하는 것도 가능하다고 생각해요.
 

3838
01:26:14,560 --> 01:26:16,070
두 키를 비교하는 것도 가능하다고 생각해요.
이건 이론적인 거고, 구현하라는 건 아니지만, 제가

3839
01:26:16,070 --> 01:26:17,590
이건 이론적인 거고, 구현하라는 건 아니지만, 제가
 

3840
01:26:17,590 --> 01:26:20,629

 

3841
01:26:20,629 --> 01:26:20,639

 

3842
01:26:20,639 --> 01:26:22,149

당신의 해결책을 읽는 입장에서 '

3843
01:26:22,149 --> 01:26:22,159
당신의 해결책을 읽는 입장에서 '
 

3844
01:26:22,159 --> 01:26:23,910
당신의 해결책을 읽는 입장에서 '
네, 무슨 말인지 알겠네요'라고 말할 수 있을 정도면 충분해요.

3845
01:26:23,910 --> 01:26:25,270
네, 무슨 말인지 알겠네요'라고 말할 수 있을 정도면 충분해요.
 

3846
01:26:25,270 --> 01:26:25,280

 

3847
01:26:25,280 --> 01:26:28,870

좋아요, 그럼 이 모든 걸 어떻게 연결할까요?

3848
01:26:28,870 --> 01:26:28,880
좋아요, 그럼 이 모든 걸 어떻게 연결할까요?
 

3849
01:26:28,880 --> 01:26:29,590
좋아요, 그럼 이 모든 걸 어떻게 연결할까요?

3850
01:26:29,590 --> 01:26:29,600

 

3851
01:26:29,600 --> 01:26:31,110

문제는

3852
01:26:31,110 --> 01:26:34,070
문제는
 

3853
01:26:34,070 --> 01:26:37,430

 

3854
01:26:37,430 --> 01:26:37,440

 

3855
01:26:37,440 --> 01:26:41,270

게임을 추가하거나 삭제할 때 이 모든 걸 업데이트해야 한다는 거죠.

3856
01:26:41,270 --> 01:26:43,990

 

3857
01:26:43,990 --> 01:26:44,000

 

3858
01:26:44,000 --> 01:26:44,470


3859
01:26:44,470 --> 01:26:48,550

 

3860
01:26:48,550 --> 01:26:48,560

 

3861
01:26:48,560 --> 01:26:50,470

이 데이터 구조에서 수신기가 어디에 있는지 어떻게 알 수 있을까요? 이 데이터 구조에 포인터를 저장하면 돼요.

3862
01:26:50,470 --> 01:26:50,480
이 데이터 구조에서 수신기가 어디에 있는지 어떻게 알 수 있을까요? 이 데이터 구조에 포인터를 저장하면 돼요.
 

3863
01:26:50,480 --> 01:26:56,550
이 데이터 구조에서 수신기가 어디에 있는지 어떻게 알 수 있을까요? 이 데이터 구조에 포인터를 저장하면 돼요.
여기 위에

3864
01:26:56,550 --> 01:26:56,560

 

3865
01:26:56,560 --> 01:26:58,229

데이터

3866
01:26:58,229 --> 01:26:58,239
데이터
 

3867
01:26:58,239 --> 01:27:00,310
데이터
구조 내 위치를 가리키는 포인터를 저장하는 거죠. 다시 말하지만, 모든 수신기를 저장하는 거예요.

3868
01:27:00,310 --> 01:27:01,189
구조 내 위치를 가리키는 포인터를 저장하는 거죠. 다시 말하지만, 모든 수신기를 저장하는 거예요.
 

3869
01:27:01,189 --> 01:27:01,199

 

3870
01:27:01,199 --> 01:27:03,669

이건

3871
01:27:03,669 --> 01:27:03,679
이건
 

3872
01:27:03,679 --> 01:27:04,790
이건
위에 있는 첫 번째 데이터 구조와 크기가 같고,

3873
01:27:04,790 --> 01:27:04,800
위에 있는 첫 번째 데이터 구조와 크기가 같고,
 

3874
01:27:04,800 --> 01:27:09,430
위에 있는 첫 번째 데이터 구조와 크기가 같고,
수신기 개수도 같아요.

3875
01:27:09,430 --> 01:27:09,440

 

3876
01:27:09,440 --> 01:27:12,870

하지만 아직 끝이 아니에요.

3877
01:27:12,870 --> 01:27:14,390
하지만 아직 끝이 아니에요.
 

3878
01:27:14,390 --> 01:27:14,400

 

3879
01:27:14,400 --> 01:27:18,790

누가 가장 좋은

3880
01:27:18,790 --> 01:27:18,800
누가 가장 좋은
 

3881
01:27:18,800 --> 01:27:22,149
누가 가장 좋은
성능을 내는지 알고 싶은 게 아니라, 누가 가장 좋은 성능을 내는지 알고 싶거든요.

3882
01:27:22,149 --> 01:27:22,159
성능을 내는지 알고 싶은 게 아니라, 누가 가장 좋은 성능을 내는지 알고 싶거든요.
 

3883
01:27:22,159 --> 01:27:22,629
성능을 내는지 알고 싶은 게 아니라, 누가 가장 좋은 성능을 내는지 알고 싶거든요.

3884
01:27:22,629 --> 01:27:27,270

 

3885
01:27:27,270 --> 01:27:27,280

 

3886
01:27:27,280 --> 01:27:29,510

어떻게 하면 이 트리에서 가장 좋은 성능을 내는 것을 찾을 수 있을까요? 트리 구조가 있어요.

3887
01:27:29,510 --> 01:27:31,830
어떻게 하면 이 트리에서 가장 좋은 성능을 내는 것을 찾을 수 있을까요? 트리 구조가 있어요.
 

3888
01:27:31,830 --> 01:27:35,270

 

3889
01:27:35,270 --> 01:27:35,280

 

3890
01:27:35,280 --> 01:27:37,350

성능에 따라 매핑되는 거죠. 마지막 항목이 어디 있는지는 알지만,

3891
01:27:37,350 --> 01:27:38,790
성능에 따라 매핑되는 거죠. 마지막 항목이 어디 있는지는 알지만,
 

3892
01:27:38,790 --> 01:27:40,790

 

3893
01:27:40,790 --> 01:27:40,800

 

3894
01:27:40,800 --> 01:27:44,070

끝에서 k번째 항목을 찾으려면 어떻게 해야 할까요?

3895
01:27:44,070 --> 01:27:44,080

 

3896
01:27:44,080 --> 01:27:47,189

AVL 트리, 즉 집합 AVL 트리인데,

3897
01:27:47,189 --> 01:27:47,199
AVL 트리, 즉 집합 AVL 트리인데,
 

3898
01:27:47,199 --> 01:27:50,550
AVL 트리, 즉 집합 AVL 트리인데,
높이만 저장하고 있습니다. 크기를 저장하는

3899
01:27:50,550 --> 01:27:50,560
높이만 저장하고 있습니다. 크기를 저장하는
 

3900
01:27:50,560 --> 01:27:52,550
높이만 저장하고 있습니다. 크기를 저장하는
연산에

3901
01:27:52,550 --> 01:27:52,560
연산에
 

3902
01:27:52,560 --> 01:27:56,390
연산에
대해 생각해 보신 적이 있나요? 크기를 저장하지 않고 있잖아요.

3903
01:27:56,390 --> 01:27:57,270
대해 생각해 보신 적이 있나요? 크기를 저장하지 않고 있잖아요.
 

3904
01:27:57,270 --> 01:27:57,280

 

3905
01:27:57,280 --> 01:28:01,030

집합 AVL 트리는 기본적으로

3906
01:28:01,030 --> 01:28:01,040
집합 AVL 트리는 기본적으로
 

3907
01:28:01,040 --> 01:28:02,950
집합 AVL 트리는 기본적으로
크기를 저장하지 않죠. 시퀀스 트리는 크기를 저장

3908
01:28:02,950 --> 01:28:02,960
크기를 저장하지 않죠. 시퀀스 트리는 크기를 저장
 

3909
01:28:02,960 --> 01:28:04,070
크기를 저장하지 않죠. 시퀀스 트리는 크기를 저장

3910
01:28:04,070 --> 01:28:04,080

 

3911
01:28:04,080 --> 01:28:05,590

하지만,

3912
01:28:05,590 --> 01:28:05,600
하지만,
 

3913
01:28:05,600 --> 01:28:07,350
하지만,
이 상황에서는 크기를 저장하는 것이 도움이 될 것 같지 않나요?

3914
01:28:07,350 --> 01:28:07,360
이 상황에서는 크기를 저장하는 것이 도움이 될 것 같지 않나요?
 

3915
01:28:07,360 --> 01:28:11,110
이 상황에서는 크기를 저장하는 것이 도움이 될 것 같지 않나요?
네, 그래서

3916
01:28:11,110 --> 01:28:11,120
네, 그래서
 

3917
01:28:11,120 --> 01:28:12,790
네, 그래서
크기를 추가하면 시퀀스에서와

3918
01:28:12,790 --> 01:28:12,800
크기를 추가하면 시퀀스에서와
 

3919
01:28:12,800 --> 01:28:14,470
크기를 추가하면 시퀀스에서와
똑같은 방식으로

3920
01:28:14,470 --> 01:28:14,480
똑같은 방식으로
 

3921
01:28:14,480 --> 01:28:17,750
똑같은 방식으로
찾을 수 있고, 시퀀스

3922
01:28:17,750 --> 01:28:18,950
찾을 수 있고, 시퀀스
 

3923
01:28:18,950 --> 01:28:22,629

 

3924
01:28:22,629 --> 01:28:25,830

 

3925
01:28:25,830 --> 01:28:28,870

 

3926
01:28:28,870 --> 01:28:28,880

 

3927
01:28:28,880 --> 01:28:31,910

AVL 트리에서 사용했던 것과 같은 서브트리 함수를 사용해서 n-k번째 항목을 찾을 수 있습니다.

3928
01:28:31,910 --> 01:28:31,920
AVL 트리에서 사용했던 것과 같은 서브트리 함수를 사용해서 n-k번째 항목을 찾을 수 있습니다.
 

3929
01:28:31,920 --> 01:28:33,990
AVL 트리에서 사용했던 것과 같은 서브트리 함수를 사용해서 n-k번째 항목을 찾을 수 있습니다.
CLRS에서는

3930
01:28:33,990 --> 01:28:34,000
CLRS에서는
 

3931
01:28:34,000 --> 01:28:35,590
CLRS에서는
시퀀스 AVL 트리를 아예 고려하지 않고 바로

3932
01:28:35,590 --> 01:28:37,750
시퀀스 AVL 트리를 아예 고려하지 않고 바로
 

3933
01:28:37,750 --> 01:28:39,590

 

3934
01:28:39,590 --> 01:28:39,600

 

3935
01:28:39,600 --> 01:28:43,669

정렬된 순서의 순위 찾기 기능을 사용합니다. 만약 정렬된 순서의 항목에 대한 순위 찾기 기능이 필요하다면

3936
01:28:43,669 --> 01:28:43,679
정렬된 순서의 순위 찾기 기능을 사용합니다. 만약 정렬된 순서의 항목에 대한 순위 찾기 기능이 필요하다면
 

3937
01:28:43,679 --> 01:28:46,550
정렬된 순서의 순위 찾기 기능을 사용합니다. 만약 정렬된 순서의 항목에 대한 순위 찾기 기능이 필요하다면
서브트리 크기를 추가하면 되죠.

3938
01:28:46,550 --> 01:28:46,560
서브트리 크기를 추가하면 되죠.
 

3939
01:28:46,560 --> 01:28:47,189
서브트리 크기를 추가하면 되죠.

3940
01:28:47,189 --> 01:28:47,199

 

3941
01:28:47,199 --> 01:28:49,590

하지만 크기를 추가하는 것이 훨씬 더 유용한

3942
01:28:49,590 --> 01:28:49,600
하지만 크기를 추가하는 것이 훨씬 더 유용한
 

3943
01:28:49,600 --> 01:28:51,189
하지만 크기를 추가하는 것이 훨씬 더 유용한
일반적인 속성이기

3944
01:28:51,189 --> 01:28:52,790
일반적인 속성이기
 

3945
01:28:52,790 --> 01:28:54,790

 

3946
01:28:54,790 --> 01:28:54,800

 

3947
01:28:54,800 --> 01:28:55,830

때문에 시퀀스 AVL 트리의 맥락에서 설명해 드리기로 했습니다.  그럼 여기까지 오면

3948
01:28:55,830 --> 01:28:55,840
때문에 시퀀스 AVL 트리의 맥락에서 설명해 드리기로 했습니다.  그럼 여기까지 오면
 

3949
01:28:55,840 --> 01:28:57,510
때문에 시퀀스 AVL 트리의 맥락에서 설명해 드리기로 했습니다.  그럼 여기까지 오면
기본적으로 간단하게 줄일 수 있겠네요. 자, 이게

3950
01:28:57,510 --> 01:28:58,950
기본적으로 간단하게 줄일 수 있겠네요. 자, 이게
 

3951
01:28:58,950 --> 01:29:00,709

 

3952
01:29:00,709 --> 01:29:00,719

 

3953
01:29:00,719 --> 01:29:02,310

이 문제를

3954
01:29:02,310 --> 01:29:04,229
이 문제를
 

3955
01:29:04,229 --> 01:29:04,239

 

3956
01:29:04,239 --> 01:29:06,149

해결하는 데 필요한 데이터 구조의 개요입니다. 이 모든 연산을 직접 구현해 보거나, 제공된

3957
01:29:06,149 --> 01:29:07,430
해결하는 데 필요한 데이터 구조의 개요입니다. 이 모든 연산을 직접 구현해 보거나, 제공된
 

3958
01:29:07,430 --> 01:29:07,440

 

3959
01:29:07,440 --> 01:29:11,750

해답을 참고하는 건 여러분의 몫입니다. 마지막 문제의

3960
01:29:11,750 --> 01:29:11,760
해답을 참고하는 건 여러분의 몫입니다. 마지막 문제의
 

3961
01:29:11,760 --> 01:29:14,470
해답을 참고하는 건 여러분의 몫입니다. 마지막 문제의
해답은 온라인에 올라올 예정입니다.

3962
01:29:14,470 --> 01:29:14,480
해답은 온라인에 올라올 예정입니다.
 

3963
01:29:14,480 --> 01:29:15,030
해답은 온라인에 올라올 예정입니다.

3964
01:29:15,030 --> 01:29:15,040

 

3965
01:29:15,040 --> 01:29:16,550

꽤 복잡한데,

3966
01:29:16,550 --> 01:29:16,560
꽤 복잡한데,
 

3967
01:29:16,560 --> 01:29:18,470
꽤 복잡한데,
크기

3968
01:29:18,470 --> 01:29:18,480
크기
 

3969
01:29:18,480 --> 01:29:21,350
크기
증강이라고 하는 랭크 찾기를 단측

3970
01:29:21,350 --> 01:29:21,360
증강이라고 하는 랭크 찾기를 단측
 

3971
01:29:21,360 --> 01:29:22,229
증강이라고 하는 랭크 찾기를 단측
범위 쿼리라고 생각하면 됩니다.

3972
01:29:22,229 --> 01:29:22,239
범위 쿼리라고 생각하면 됩니다.
 

3973
01:29:22,239 --> 01:29:24,229
범위 쿼리라고 생각하면 됩니다.
기본적으로

3974
01:29:24,229 --> 01:29:24,239
기본적으로
 

3975
01:29:24,239 --> 01:29:26,070
기본적으로
이 값의 오른쪽에 몇 개의 요소가 있는지 찾는 거죠.

3976
01:29:26,070 --> 01:29:26,080
이 값의 오른쪽에 몇 개의 요소가 있는지 찾는 거죠.
 

3977
01:29:26,080 --> 01:29:29,270
이 값의 오른쪽에 몇 개의 요소가 있는지 찾는 거죠.
마지막 문제는 양방향

3978
01:29:29,270 --> 01:29:29,280
마지막 문제는 양방향
 

3979
01:29:29,280 --> 01:29:31,030
마지막 문제는 양방향
범위 쿼리를 다루는데,

3980
01:29:31,030 --> 01:29:31,040
범위 쿼리를 다루는데,
 

3981
01:29:31,040 --> 01:29:31,510
범위 쿼리를 다루는데,

3982
01:29:31,510 --> 01:29:33,189

 

3983
01:29:33,189 --> 01:29:33,199

 

3984
01:29:33,199 --> 01:29:35,590

이 두 값 사이에 몇 개의 노드가 있는지 알아보는 겁니다. 자, 여기까지가 단계별 설명입니다.

3985
01:29:35,590 --> 01:29:39,110
이 두 값 사이에 몇 개의 노드가 있는지 알아보는 겁니다. 자, 여기까지가 단계별 설명입니다.
 

3986
01:29:39,110 --> 01:29:39,120

 

3987
01:29:39,120 --> 01:29:48,480

감사합니다.

