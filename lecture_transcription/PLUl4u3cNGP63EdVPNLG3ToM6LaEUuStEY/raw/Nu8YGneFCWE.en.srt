1
00:00:12,880 --> 00:00:14,470

welcome to the fourth lecture

2
00:00:14,470 --> 00:00:14,480
welcome to the fourth lecture
 

3
00:00:14,480 --> 00:00:18,310
welcome to the fourth lecture
of 6006. um today

4
00:00:18,310 --> 00:00:18,320
of 6006. um today
 

5
00:00:18,320 --> 00:00:20,390
of 6006. um today
we are going to be talking about hashing

6
00:00:20,390 --> 00:00:20,400
we are going to be talking about hashing
 

7
00:00:20,400 --> 00:00:21,510
we are going to be talking about hashing
last lecture

8
00:00:21,510 --> 00:00:21,520
last lecture
 

9
00:00:21,520 --> 00:00:24,870
last lecture
on tuesday um professor solomon was

10
00:00:24,870 --> 00:00:24,880
on tuesday um professor solomon was
 

11
00:00:24,880 --> 00:00:26,470
on tuesday um professor solomon was
talking about

12
00:00:26,470 --> 00:00:26,480
talking about
 

13
00:00:26,480 --> 00:00:29,750
talking about
uh set data structures right storing

14
00:00:29,750 --> 00:00:29,760
uh set data structures right storing
 

15
00:00:29,760 --> 00:00:30,470
uh set data structures right storing
things

16
00:00:30,470 --> 00:00:30,480
things
 

17
00:00:30,480 --> 00:00:33,670
things
so that you can query items by

18
00:00:33,670 --> 00:00:33,680
so that you can query items by
 

19
00:00:33,680 --> 00:00:35,510
so that you can query items by
their key right by what they

20
00:00:35,510 --> 00:00:35,520
their key right by what they
 

21
00:00:35,520 --> 00:00:37,350
their key right by what they
intrinsically are

22
00:00:37,350 --> 00:00:37,360
intrinsically are
 

23
00:00:37,360 --> 00:00:39,430
intrinsically are
versus what professor domain was talking

24
00:00:39,430 --> 00:00:39,440
versus what professor domain was talking
 

25
00:00:39,440 --> 00:00:41,350
versus what professor domain was talking
about last week which was sequence data

26
00:00:41,350 --> 00:00:41,360
about last week which was sequence data
 

27
00:00:41,360 --> 00:00:42,150
about last week which was sequence data
structures where

28
00:00:42,150 --> 00:00:42,160
structures where
 

29
00:00:42,160 --> 00:00:45,110
structures where
we impose an external order on these

30
00:00:45,110 --> 00:00:45,120
we impose an external order on these
 

31
00:00:45,120 --> 00:00:45,910
we impose an external order on these
items

32
00:00:45,910 --> 00:00:45,920
items
 

33
00:00:45,920 --> 00:00:48,069
items
and we want you to maintain those but

34
00:00:48,069 --> 00:00:48,079
and we want you to maintain those but
 

35
00:00:48,079 --> 00:00:49,510
and we want you to maintain those but
i'm not i don't really

36
00:00:49,510 --> 00:00:49,520
i'm not i don't really
 

37
00:00:49,520 --> 00:00:51,590
i'm not i don't really
i'm not supporting operations where i'm

38
00:00:51,590 --> 00:00:51,600
i'm not supporting operations where i'm
 

39
00:00:51,600 --> 00:00:53,910
i'm not supporting operations where i'm
looking stuff up based on what they are

40
00:00:53,910 --> 00:00:53,920
looking stuff up based on what they are
 

41
00:00:53,920 --> 00:00:56,069
looking stuff up based on what they are
right that's what the set interface is

42
00:00:56,069 --> 00:00:56,079
right that's what the set interface is
 

43
00:00:56,079 --> 00:00:58,069
right that's what the set interface is
for right so we're going to be talking a

44
00:00:58,069 --> 00:00:58,079
for right so we're going to be talking a
 

45
00:00:58,079 --> 00:00:59,349
for right so we're going to be talking a
little bit more about the set

46
00:00:59,349 --> 00:00:59,359
little bit more about the set
 

47
00:00:59,359 --> 00:01:02,470
little bit more about the set
interface today so last on tuesday

48
00:01:02,470 --> 00:01:02,480
interface today so last on tuesday
 

49
00:01:02,480 --> 00:01:05,590
interface today so last on tuesday
you saw two ways of implementing the set

50
00:01:05,590 --> 00:01:05,600
you saw two ways of implementing the set
 

51
00:01:05,600 --> 00:01:06,789
you saw two ways of implementing the set
interface

52
00:01:06,789 --> 00:01:06,799
interface
 

53
00:01:06,799 --> 00:01:09,350
interface
right one using just a unsorted array

54
00:01:09,350 --> 00:01:09,360
right one using just a unsorted array
 

55
00:01:09,360 --> 00:01:09,910
right one using just a unsorted array
just

56
00:01:09,910 --> 00:01:09,920
just
 

57
00:01:09,920 --> 00:01:12,230
just
i threw these things in an array and i

58
00:01:12,230 --> 00:01:12,240
i threw these things in an array and i
 

59
00:01:12,240 --> 00:01:14,469
i threw these things in an array and i
could do a linear scan of my items

60
00:01:14,469 --> 00:01:14,479
could do a linear scan of my items
 

61
00:01:14,479 --> 00:01:16,230
could do a linear scan of my items
to support basically any of these

62
00:01:16,230 --> 00:01:16,240
to support basically any of these
 

63
00:01:16,240 --> 00:01:18,149
to support basically any of these
operations it's a little exercise you

64
00:01:18,149 --> 00:01:18,159
operations it's a little exercise you
 

65
00:01:18,159 --> 00:01:19,030
operations it's a little exercise you
can go through

66
00:01:19,030 --> 00:01:19,040
can go through
 

67
00:01:19,040 --> 00:01:20,630
can go through
i think they show it to you in the

68
00:01:20,630 --> 00:01:20,640
i think they show it to you in the
 

69
00:01:20,640 --> 00:01:22,469
i think they show it to you in the
recitation notes but if you'd like to

70
00:01:22,469 --> 00:01:22,479
recitation notes but if you'd like to
 

71
00:01:22,479 --> 00:01:23,590
recitation notes but if you'd like to
implement it

72
00:01:23,590 --> 00:01:23,600
implement it
 

73
00:01:23,600 --> 00:01:27,109
implement it
for yourself that's fine uh in and then

74
00:01:27,109 --> 00:01:27,119
for yourself that's fine uh in and then
 

75
00:01:27,119 --> 00:01:29,670
for yourself that's fine uh in and then
we saw a slightly better data structure

76
00:01:29,670 --> 00:01:29,680
we saw a slightly better data structure
 

77
00:01:29,680 --> 00:01:31,670
we saw a slightly better data structure
at least for the find operations

78
00:01:31,670 --> 00:01:31,680
at least for the find operations
 

79
00:01:31,680 --> 00:01:34,630
at least for the find operations
can i look something up whether this key

80
00:01:34,630 --> 00:01:34,640
can i look something up whether this key
 

81
00:01:34,640 --> 00:01:35,830
can i look something up whether this key
is in my

82
00:01:35,830 --> 00:01:35,840
is in my
 

83
00:01:35,840 --> 00:01:39,510
is in my
uh set interface we can do that faster

84
00:01:39,510 --> 00:01:39,520
uh set interface we can do that faster
 

85
00:01:39,520 --> 00:01:41,510
uh set interface we can do that faster
we can do that in log n time

86
00:01:41,510 --> 00:01:41,520
we can do that in log n time
 

87
00:01:41,520 --> 00:01:45,190
we can do that in log n time
with a build overhead that's about n log

88
00:01:45,190 --> 00:01:45,200
with a build overhead that's about n log
 

89
00:01:45,200 --> 00:01:48,069
with a build overhead that's about n log
n right because we showed you three ways

90
00:01:48,069 --> 00:01:48,079
n right because we showed you three ways
 

91
00:01:48,079 --> 00:01:49,030
n right because we showed you three ways
to sort

92
00:01:49,030 --> 00:01:49,040
to sort
 

93
00:01:49,040 --> 00:01:51,510
to sort
two of them were n squared one of them

94
00:01:51,510 --> 00:01:51,520
two of them were n squared one of them
 

95
00:01:51,520 --> 00:01:52,950
two of them were n squared one of them
was n log n

96
00:01:52,950 --> 00:01:52,960
was n log n
 

97
00:01:52,960 --> 00:01:55,590
was n log n
which is as good as we showed you how to

98
00:01:55,590 --> 00:01:55,600
which is as good as we showed you how to
 

99
00:01:55,600 --> 00:01:57,350
which is as good as we showed you how to
do yesterday

100
00:01:57,350 --> 00:01:57,360
do yesterday
 

101
00:01:57,360 --> 00:01:59,510
do yesterday
so the question then becomes can i build

102
00:01:59,510 --> 00:01:59,520
so the question then becomes can i build
 

103
00:01:59,520 --> 00:02:01,350
so the question then becomes can i build
that data structure faster that'll be a

104
00:02:01,350 --> 00:02:01,360
that data structure faster that'll be a
 

105
00:02:01,360 --> 00:02:02,870
that data structure faster that'll be a
subject of next week's

106
00:02:02,870 --> 00:02:02,880
subject of next week's
 

107
00:02:02,880 --> 00:02:05,270
subject of next week's
thursday lecture but this week we're

108
00:02:05,270 --> 00:02:05,280
thursday lecture but this week we're
 

109
00:02:05,280 --> 00:02:06,870
thursday lecture but this week we're
going to concentrate on

110
00:02:06,870 --> 00:02:06,880
going to concentrate on
 

111
00:02:06,880 --> 00:02:10,070
going to concentrate on
this static find right right we got log

112
00:02:10,070 --> 00:02:10,080
this static find right right we got log
 

113
00:02:10,080 --> 00:02:11,830
this static find right right we got log
n which is an exponential improvement

114
00:02:11,830 --> 00:02:11,840
n which is an exponential improvement
 

115
00:02:11,840 --> 00:02:12,309
n which is an exponential improvement
over

116
00:02:12,309 --> 00:02:12,319
over
 

117
00:02:12,319 --> 00:02:15,830
over
linear right

118
00:02:15,830 --> 00:02:15,840

 

119
00:02:15,840 --> 00:02:18,309

but the question here now becomes can i

120
00:02:18,309 --> 00:02:18,319
but the question here now becomes can i
 

121
00:02:18,319 --> 00:02:22,070
but the question here now becomes can i
do faster than log n time

122
00:02:22,070 --> 00:02:22,080
do faster than log n time
 

123
00:02:22,080 --> 00:02:23,430
do faster than log n time
and what we're going to do at the first

124
00:02:23,430 --> 00:02:23,440
and what we're going to do at the first
 

125
00:02:23,440 --> 00:02:26,150
and what we're going to do at the first
part of this lecture is show you that no

126
00:02:26,150 --> 00:02:26,160
part of this lecture is show you that no
 

127
00:02:26,160 --> 00:02:29,270
part of this lecture is show you that no
you what's up what no

128
00:02:29,270 --> 00:02:29,280
you what's up what no
 

129
00:02:29,280 --> 00:02:34,070
you what's up what no
okay that you can't do faster than log n

130
00:02:34,070 --> 00:02:34,080
okay that you can't do faster than log n
 

131
00:02:34,080 --> 00:02:37,030
okay that you can't do faster than log n
time in the caveat that we are in a

132
00:02:37,030 --> 00:02:37,040
time in the caveat that we are in a
 

133
00:02:37,040 --> 00:02:38,869
time in the caveat that we are in a
slightly more restricted model of

134
00:02:38,869 --> 00:02:38,879
slightly more restricted model of
 

135
00:02:38,879 --> 00:02:40,710
slightly more restricted model of
computation

136
00:02:40,710 --> 00:02:40,720
computation
 

137
00:02:40,720 --> 00:02:43,030
computation
that we were then what we introduced to

138
00:02:43,030 --> 00:02:43,040
that we were then what we introduced to
 

139
00:02:43,040 --> 00:02:46,390
that we were then what we introduced to
you a couple weeks ago

140
00:02:46,390 --> 00:02:46,400

 

141
00:02:46,400 --> 00:02:48,949

and then so if we're not in that that

142
00:02:48,949 --> 00:02:48,959
and then so if we're not in that that
 

143
00:02:48,959 --> 00:02:50,949
and then so if we're not in that that
more constrained model of computation we

144
00:02:50,949 --> 00:02:50,959
more constrained model of computation we
 

145
00:02:50,959 --> 00:02:52,710
more constrained model of computation we
can actually do faster

146
00:02:52,710 --> 00:02:52,720
can actually do faster
 

147
00:02:52,720 --> 00:02:55,670
can actually do faster
right and doing faster is i mean log n

148
00:02:55,670 --> 00:02:55,680
right and doing faster is i mean log n
 

149
00:02:55,680 --> 00:02:56,949
right and doing faster is i mean log n
is already pretty good

150
00:02:56,949 --> 00:02:56,959
is already pretty good
 

151
00:02:56,959 --> 00:02:59,589
is already pretty good
right log n is not going to be larger

152
00:02:59,589 --> 00:02:59,599
right log n is not going to be larger
 

153
00:02:59,599 --> 00:03:01,350
right log n is not going to be larger
than like

154
00:03:01,350 --> 00:03:01,360
than like
 

155
00:03:01,360 --> 00:03:04,550
than like
30 for any problem that you're going to

156
00:03:04,550 --> 00:03:04,560
30 for any problem that you're going to
 

157
00:03:04,560 --> 00:03:07,750
30 for any problem that you're going to
be talk talking about uh in the real

158
00:03:07,750 --> 00:03:07,760
be talk talking about uh in the real
 

159
00:03:07,760 --> 00:03:09,670
be talk talking about uh in the real
world on real computers

160
00:03:09,670 --> 00:03:09,680
world on real computers
 

161
00:03:09,680 --> 00:03:13,270
world on real computers
but uh a factor of 30 is still bad

162
00:03:13,270 --> 00:03:13,280
but uh a factor of 30 is still bad
 

163
00:03:13,280 --> 00:03:16,229
but uh a factor of 30 is still bad
right i would prefer to do faster with

164
00:03:16,229 --> 00:03:16,239
right i would prefer to do faster with
 

165
00:03:16,239 --> 00:03:18,229
right i would prefer to do faster with
those constant factors when i can

166
00:03:18,229 --> 00:03:18,239
those constant factors when i can
 

167
00:03:18,239 --> 00:03:19,350
those constant factors when i can
it's not a constant factor it's a

168
00:03:19,350 --> 00:03:19,360
it's not a constant factor it's a
 

169
00:03:19,360 --> 00:03:20,790
it's not a constant factor it's a
logarithmic factor but you get what i'm

170
00:03:20,790 --> 00:03:20,800
logarithmic factor but you get what i'm
 

171
00:03:20,800 --> 00:03:21,910
logarithmic factor but you get what i'm
saying

172
00:03:21,910 --> 00:03:21,920
saying
 

173
00:03:21,920 --> 00:03:24,550
saying
okay so what we're going to do is first

174
00:03:24,550 --> 00:03:24,560
okay so what we're going to do is first
 

175
00:03:24,560 --> 00:03:25,670
okay so what we're going to do is first
prove that

176
00:03:25,670 --> 00:03:25,680
prove that
 

177
00:03:25,680 --> 00:03:27,830
prove that
you can't do faster for for fine does

178
00:03:27,830 --> 00:03:27,840
you can't do faster for for fine does
 

179
00:03:27,840 --> 00:03:29,270
you can't do faster for for fine does
everyone understand

180
00:03:29,270 --> 00:03:29,280
everyone understand
 

181
00:03:29,280 --> 00:03:32,470
everyone understand
remember what find key meant right i

182
00:03:32,470 --> 00:03:32,480
remember what find key meant right i
 

183
00:03:32,480 --> 00:03:33,030
remember what find key meant right i
have

184
00:03:33,030 --> 00:03:33,040
have
 

185
00:03:33,040 --> 00:03:35,190
have
a key i have a bunch of items that have

186
00:03:35,190 --> 00:03:35,200
a key i have a bunch of items that have
 

187
00:03:35,200 --> 00:03:36,550
a key i have a bunch of items that have
keys associated with them

188
00:03:36,550 --> 00:03:36,560
keys associated with them
 

189
00:03:36,560 --> 00:03:38,949
keys associated with them
and i want to see if one of the items

190
00:03:38,949 --> 00:03:38,959
and i want to see if one of the items
 

191
00:03:38,959 --> 00:03:40,070
and i want to see if one of the items
that i'm storing

192
00:03:40,070 --> 00:03:40,080
that i'm storing
 

193
00:03:40,080 --> 00:03:42,149
that i'm storing
contains a key that is the same as the

194
00:03:42,149 --> 00:03:42,159
contains a key that is the same as the
 

195
00:03:42,159 --> 00:03:43,750
contains a key that is the same as the
one that i searched for right

196
00:03:43,750 --> 00:03:43,760
one that i searched for right
 

197
00:03:43,760 --> 00:03:46,710
one that i searched for right
the item might contain other things but

198
00:03:46,710 --> 00:03:46,720
the item might contain other things but
 

199
00:03:46,720 --> 00:03:48,309
the item might contain other things but
it in particular has a

200
00:03:48,309 --> 00:03:48,319
it in particular has a
 

201
00:03:48,319 --> 00:03:50,149
it in particular has a
search key that i'm maintaining the set

202
00:03:50,149 --> 00:03:50,159
search key that i'm maintaining the set
 

203
00:03:50,159 --> 00:03:52,710
search key that i'm maintaining the set
on so that it supports

204
00:03:52,710 --> 00:03:52,720
on so that it supports
 

205
00:03:52,720 --> 00:03:54,789
on so that it supports
find operation search operations based

206
00:03:54,789 --> 00:03:54,799
find operation search operations based
 

207
00:03:54,799 --> 00:03:55,910
find operation search operations based
on that key

208
00:03:55,910 --> 00:03:55,920
on that key
 

209
00:03:55,920 --> 00:03:59,110
on that key
quickly does that make sense so

210
00:03:59,110 --> 00:03:59,120
quickly does that make sense so
 

211
00:03:59,120 --> 00:04:00,470
quickly does that make sense so
there's the find one that we want to

212
00:04:00,470 --> 00:04:00,480
there's the find one that we want to
 

213
00:04:00,480 --> 00:04:02,229
there's the find one that we want to
improve and we also want to improve this

214
00:04:02,229 --> 00:04:02,239
improve and we also want to improve this
 

215
00:04:02,239 --> 00:04:04,550
improve and we also want to improve this
insert delete we want to be make this

216
00:04:04,550 --> 00:04:04,560
insert delete we want to be make this
 

217
00:04:04,560 --> 00:04:06,630
insert delete we want to be make this
this data structure dynamic right

218
00:04:06,630 --> 00:04:06,640
this data structure dynamic right
 

219
00:04:06,640 --> 00:04:09,750
this data structure dynamic right
because we we might uh

220
00:04:09,750 --> 00:04:09,760
because we we might uh
 

221
00:04:09,760 --> 00:04:11,990
because we we might uh
do those operations quite a bit and so

222
00:04:11,990 --> 00:04:12,000
do those operations quite a bit and so
 

223
00:04:12,000 --> 00:04:13,190
do those operations quite a bit and so
this lecture is about

224
00:04:13,190 --> 00:04:13,200
this lecture is about
 

225
00:04:13,200 --> 00:04:16,550
this lecture is about
optimizing those three things okay so

226
00:04:16,550 --> 00:04:16,560
optimizing those three things okay so
 

227
00:04:16,560 --> 00:04:17,990
optimizing those three things okay so
first i'm going to show you that we

228
00:04:17,990 --> 00:04:18,000
first i'm going to show you that we
 

229
00:04:18,000 --> 00:04:20,469
first i'm going to show you that we
can't do faster than log n

230
00:04:20,469 --> 00:04:20,479
can't do faster than log n
 

231
00:04:20,479 --> 00:04:23,590
can't do faster than log n
for find which is a little weird

232
00:04:23,590 --> 00:04:23,600
for find which is a little weird
 

233
00:04:23,600 --> 00:04:26,150
for find which is a little weird
okay the model of computation i'm going

234
00:04:26,150 --> 00:04:26,160
okay the model of computation i'm going
 

235
00:04:26,160 --> 00:04:26,710
okay the model of computation i'm going
to be

236
00:04:26,710 --> 00:04:26,720
to be
 

237
00:04:26,720 --> 00:04:29,350
to be
proving this lower bound on right i'm

238
00:04:29,350 --> 00:04:29,360
proving this lower bound on right i'm
 

239
00:04:29,360 --> 00:04:31,189
proving this lower bound on right i'm
saying that

240
00:04:31,189 --> 00:04:31,199
saying that
 

241
00:04:31,199 --> 00:04:32,469
saying that
how i'm going to approach this is i'm

242
00:04:32,469 --> 00:04:32,479
how i'm going to approach this is i'm
 

243
00:04:32,479 --> 00:04:34,390
how i'm going to approach this is i'm
going to say that any

244
00:04:34,390 --> 00:04:34,400
going to say that any
 

245
00:04:34,400 --> 00:04:38,070
going to say that any
way that i store these the items that

246
00:04:38,070 --> 00:04:38,080
way that i store these the items that
 

247
00:04:38,080 --> 00:04:42,310
way that i store these the items that
i'm storing in this data structure

248
00:04:42,310 --> 00:04:42,320
i'm storing in this data structure
 

249
00:04:42,320 --> 00:04:44,550
i'm storing in this data structure
for any way i store these things any

250
00:04:44,550 --> 00:04:44,560
for any way i store these things any
 

251
00:04:44,560 --> 00:04:46,950
for any way i store these things any
algorithm of this certain type

252
00:04:46,950 --> 00:04:46,960
algorithm of this certain type
 

253
00:04:46,960 --> 00:04:49,430
algorithm of this certain type
is going to require at least logarithmic

254
00:04:49,430 --> 00:04:49,440
is going to require at least logarithmic
 

255
00:04:49,440 --> 00:04:49,990
is going to require at least logarithmic
time

256
00:04:49,990 --> 00:04:50,000
time
 

257
00:04:50,000 --> 00:04:52,070
time
that's that's what we're going to try to

258
00:04:52,070 --> 00:04:52,080
that's that's what we're going to try to
 

259
00:04:52,080 --> 00:04:54,390
that's that's what we're going to try to
prove and the model of computation

260
00:04:54,390 --> 00:04:54,400
prove and the model of computation
 

261
00:04:54,400 --> 00:04:56,150
prove and the model of computation
that's that's weaker than what we've

262
00:04:56,150 --> 00:04:56,160
that's that's weaker than what we've
 

263
00:04:56,160 --> 00:04:58,310
that's that's weaker than what we've
been talking about previously

264
00:04:58,310 --> 00:04:58,320
been talking about previously
 

265
00:04:58,320 --> 00:04:59,990
been talking about previously
is what i'm going to call the comparison

266
00:04:59,990 --> 00:05:00,000
is what i'm going to call the comparison
 

267
00:05:00,000 --> 00:05:04,150
is what i'm going to call the comparison
model

268
00:05:04,150 --> 00:05:04,160

 

269
00:05:04,160 --> 00:05:07,110

and a comparison model means is that the

270
00:05:07,110 --> 00:05:07,120
and a comparison model means is that the
 

271
00:05:07,120 --> 00:05:10,310
and a comparison model means is that the
items the objects i'm storing i can kind

272
00:05:10,310 --> 00:05:10,320
items the objects i'm storing i can kind
 

273
00:05:10,320 --> 00:05:11,909
items the objects i'm storing i can kind
of think of them as black boxes

274
00:05:11,909 --> 00:05:11,919
of think of them as black boxes
 

275
00:05:11,919 --> 00:05:14,710
of think of them as black boxes
i don't get to touch these things except

276
00:05:14,710 --> 00:05:14,720
i don't get to touch these things except
 

277
00:05:14,720 --> 00:05:16,310
i don't get to touch these things except
the only way that i can distinguish

278
00:05:16,310 --> 00:05:16,320
the only way that i can distinguish
 

279
00:05:16,320 --> 00:05:18,150
the only way that i can distinguish
between them

280
00:05:18,150 --> 00:05:18,160
between them
 

281
00:05:18,160 --> 00:05:21,189
between them
is to say given a

282
00:05:21,189 --> 00:05:21,199
is to say given a
 

283
00:05:21,199 --> 00:05:25,830
is to say given a
key and an item or two items

284
00:05:25,830 --> 00:05:25,840
key and an item or two items
 

285
00:05:25,840 --> 00:05:28,550
key and an item or two items
i'm i can do a comparison on those keys

286
00:05:28,550 --> 00:05:28,560
i'm i can do a comparison on those keys
 

287
00:05:28,560 --> 00:05:28,870
i'm i can do a comparison on those keys
right

288
00:05:28,870 --> 00:05:28,880
right
 

289
00:05:28,880 --> 00:05:32,310
right
are these keys the same uh is this key

290
00:05:32,310 --> 00:05:32,320
are these keys the same uh is this key
 

291
00:05:32,320 --> 00:05:32,950
are these keys the same uh is this key
bigger

292
00:05:32,950 --> 00:05:32,960
bigger
 

293
00:05:32,960 --> 00:05:35,029
bigger
than this one is it smaller than this

294
00:05:35,029 --> 00:05:35,039
than this one is it smaller than this
 

295
00:05:35,039 --> 00:05:36,790
than this one is it smaller than this
one those are kind of the only

296
00:05:36,790 --> 00:05:36,800
one those are kind of the only
 

297
00:05:36,800 --> 00:05:38,390
one those are kind of the only
operations i get to do with them

298
00:05:38,390 --> 00:05:38,400
operations i get to do with them
 

299
00:05:38,400 --> 00:05:41,029
operations i get to do with them
i don't get to look at what the say if

300
00:05:41,029 --> 00:05:41,039
i don't get to look at what the say if
 

301
00:05:41,039 --> 00:05:42,629
i don't get to look at what the say if
the keys are numbers i don't get to look

302
00:05:42,629 --> 00:05:42,639
the keys are numbers i don't get to look
 

303
00:05:42,639 --> 00:05:44,310
the keys are numbers i don't get to look
at what number that is

304
00:05:44,310 --> 00:05:44,320
at what number that is
 

305
00:05:44,320 --> 00:05:46,150
at what number that is
right i just get to take two keys and

306
00:05:46,150 --> 00:05:46,160
right i just get to take two keys and
 

307
00:05:46,160 --> 00:05:47,350
right i just get to take two keys and
compare them and actually

308
00:05:47,350 --> 00:05:47,360
compare them and actually
 

309
00:05:47,360 --> 00:05:50,629
compare them and actually
all of the search algorithms that we saw

310
00:05:50,629 --> 00:05:50,639
all of the search algorithms that we saw
 

311
00:05:50,639 --> 00:05:52,870
all of the search algorithms that we saw
on tuesday were comparison sort

312
00:05:52,870 --> 00:05:52,880
on tuesday were comparison sort
 

313
00:05:52,880 --> 00:05:53,670
on tuesday were comparison sort
algorithms right

314
00:05:53,670 --> 00:05:53,680
algorithms right
 

315
00:05:53,680 --> 00:05:55,830
algorithms right
what you did was you stepped through the

316
00:05:55,830 --> 00:05:55,840
what you did was you stepped through the
 

317
00:05:55,840 --> 00:05:56,790
what you did was you stepped through the
program

318
00:05:56,790 --> 00:05:56,800
program
 

319
00:05:56,800 --> 00:05:59,270
program
at some point you came to a branch and

320
00:05:59,270 --> 00:05:59,280
at some point you came to a branch and
 

321
00:05:59,280 --> 00:06:00,550
at some point you came to a branch and
you looked at

322
00:06:00,550 --> 00:06:00,560
you looked at
 

323
00:06:00,560 --> 00:06:03,270
you looked at
two keys and you branched based on

324
00:06:03,270 --> 00:06:03,280
two keys and you branched based on
 

325
00:06:03,280 --> 00:06:05,590
two keys and you branched based on
whether one key was bigger than another

326
00:06:05,590 --> 00:06:05,600
whether one key was bigger than another
 

327
00:06:05,600 --> 00:06:07,990
whether one key was bigger than another
right that was a comparison and then you

328
00:06:07,990 --> 00:06:08,000
right that was a comparison and then you
 

329
00:06:08,000 --> 00:06:09,830
right that was a comparison and then you
moved some stuff around but that was the

330
00:06:09,830 --> 00:06:09,840
moved some stuff around but that was the
 

331
00:06:09,840 --> 00:06:10,469
moved some stuff around but that was the
general

332
00:06:10,469 --> 00:06:10,479
general
 

333
00:06:10,479 --> 00:06:13,510
general
paradigm those those three sorting

334
00:06:13,510 --> 00:06:13,520
paradigm those those three sorting
 

335
00:06:13,520 --> 00:06:16,710
paradigm those those three sorting
operations uh lived in this comparison

336
00:06:16,710 --> 00:06:16,720
operations uh lived in this comparison
 

337
00:06:16,720 --> 00:06:18,070
operations uh lived in this comparison
model right you've got

338
00:06:18,070 --> 00:06:18,080
model right you've got
 

339
00:06:18,080 --> 00:06:21,270
model right you've got
uh you know comparison operations like

340
00:06:21,270 --> 00:06:21,280
uh you know comparison operations like
 

341
00:06:21,280 --> 00:06:25,029
uh you know comparison operations like
are they equal less than greater than

342
00:06:25,029 --> 00:06:25,039
are they equal less than greater than
 

343
00:06:25,039 --> 00:06:27,110
are they equal less than greater than
maybe greater than or equal less than or

344
00:06:27,110 --> 00:06:27,120
maybe greater than or equal less than or
 

345
00:06:27,120 --> 00:06:28,790
maybe greater than or equal less than or
equal right

346
00:06:28,790 --> 00:06:28,800
equal right
 

347
00:06:28,800 --> 00:06:30,469
equal right
generally you have all these operations

348
00:06:30,469 --> 00:06:30,479
generally you have all these operations
 

349
00:06:30,479 --> 00:06:32,830
generally you have all these operations
that you could do maybe not equal

350
00:06:32,830 --> 00:06:32,840
that you could do maybe not equal
 

351
00:06:32,840 --> 00:06:36,070
that you could do maybe not equal
right but the key thing here

352
00:06:36,070 --> 00:06:36,080
right but the key thing here
 

353
00:06:36,080 --> 00:06:38,950
right but the key thing here
is that there are only two possible

354
00:06:38,950 --> 00:06:38,960
is that there are only two possible
 

355
00:06:38,960 --> 00:06:40,790
is that there are only two possible
outputs to each of these comparators

356
00:06:40,790 --> 00:06:40,800
outputs to each of these comparators
 

357
00:06:40,800 --> 00:06:42,230
outputs to each of these comparators
right

358
00:06:42,230 --> 00:06:42,240
right
 

359
00:06:42,240 --> 00:06:44,070
right
there's only two things there's there's

360
00:06:44,070 --> 00:06:44,080
there's only two things there's there's
 

361
00:06:44,080 --> 00:06:45,430
there's only two things there's there's
only one one

362
00:06:45,430 --> 00:06:45,440
only one one
 

363
00:06:45,440 --> 00:06:46,950
only one one
thing that i can branch on it's going to

364
00:06:46,950 --> 00:06:46,960
thing that i can branch on it's going to
 

365
00:06:46,960 --> 00:06:49,670
thing that i can branch on it's going to
branch into two different lines right

366
00:06:49,670 --> 00:06:49,680
branch into two different lines right
 

367
00:06:49,680 --> 00:06:50,710
branch into two different lines right
it's either true

368
00:06:50,710 --> 00:06:50,720
it's either true
 

369
00:06:50,720 --> 00:06:53,029
it's either true
and i do some other computation or it's

370
00:06:53,029 --> 00:06:53,039
and i do some other computation or it's
 

371
00:06:53,039 --> 00:06:54,550
and i do some other computation or it's
false and i'll do

372
00:06:54,550 --> 00:06:54,560
false and i'll do
 

373
00:06:54,560 --> 00:06:56,469
false and i'll do
a different set of computation right

374
00:06:56,469 --> 00:06:56,479
a different set of computation right
 

375
00:06:56,479 --> 00:06:58,550
a different set of computation right
that makes sense

376
00:06:58,550 --> 00:06:58,560
that makes sense
 

377
00:06:58,560 --> 00:06:59,830
that makes sense
so what i'm going to do is i'm going to

378
00:06:59,830 --> 00:06:59,840
so what i'm going to do is i'm going to
 

379
00:06:59,840 --> 00:07:03,110
so what i'm going to do is i'm going to
view a comparison

380
00:07:03,110 --> 00:07:03,120
view a comparison
 

381
00:07:03,120 --> 00:07:05,430
view a comparison
an algorithm in the comparison model as

382
00:07:05,430 --> 00:07:05,440
an algorithm in the comparison model as
 

383
00:07:05,440 --> 00:07:07,430
an algorithm in the comparison model as
what i like to call a decision tree

384
00:07:07,430 --> 00:07:07,440
what i like to call a decision tree
 

385
00:07:07,440 --> 00:07:09,749
what i like to call a decision tree
right so if i specify an algorithm to

386
00:07:09,749 --> 00:07:09,759
right so if i specify an algorithm to
 

387
00:07:09,759 --> 00:07:11,830
right so if i specify an algorithm to
you the first thing it's going to do

388
00:07:11,830 --> 00:07:11,840
you the first thing it's going to do
 

389
00:07:11,840 --> 00:07:14,710
you the first thing it's going to do
if i don't compare items at all i'm kind

390
00:07:14,710 --> 00:07:14,720
if i don't compare items at all i'm kind
 

391
00:07:14,720 --> 00:07:16,150
if i don't compare items at all i'm kind
of screwed because i'll never be able to

392
00:07:16,150 --> 00:07:16,160
of screwed because i'll never be able to
 

393
00:07:16,160 --> 00:07:16,629
of screwed because i'll never be able to
tell

394
00:07:16,629 --> 00:07:16,639
tell
 

395
00:07:16,639 --> 00:07:18,230
tell
if my keys and they're not so i have to

396
00:07:18,230 --> 00:07:18,240
if my keys and they're not so i have to
 

397
00:07:18,240 --> 00:07:20,950
if my keys and they're not so i have to
do some comparisons

398
00:07:20,950 --> 00:07:20,960
do some comparisons
 

399
00:07:20,960 --> 00:07:23,270
do some comparisons
so you know i'll do some computation you

400
00:07:23,270 --> 00:07:23,280
so you know i'll do some computation you
 

401
00:07:23,280 --> 00:07:24,870
so you know i'll do some computation you
know maybe i find out the length of the

402
00:07:24,870 --> 00:07:24,880
know maybe i find out the length of the
 

403
00:07:24,880 --> 00:07:27,189
know maybe i find out the length of the
array and i do some constant time stuff

404
00:07:27,189 --> 00:07:27,199
array and i do some constant time stuff
 

405
00:07:27,199 --> 00:07:29,749
array and i do some constant time stuff
but at some point i'll do a comparison

406
00:07:29,749 --> 00:07:29,759
but at some point i'll do a comparison
 

407
00:07:29,759 --> 00:07:30,230
but at some point i'll do a comparison
and i'll

408
00:07:30,230 --> 00:07:30,240
and i'll
 

409
00:07:30,240 --> 00:07:32,870
and i'll
i'll branch right i'll come to this node

410
00:07:32,870 --> 00:07:32,880
i'll branch right i'll come to this node
 

411
00:07:32,880 --> 00:07:34,070
i'll branch right i'll come to this node
and

412
00:07:34,070 --> 00:07:34,080
and
 

413
00:07:34,080 --> 00:07:36,550
and
if the comparison like maybe a less than

414
00:07:36,550 --> 00:07:36,560
if the comparison like maybe a less than
 

415
00:07:36,560 --> 00:07:37,430
if the comparison like maybe a less than
right

416
00:07:37,430 --> 00:07:37,440
right
 

417
00:07:37,440 --> 00:07:40,230
right
if it's true i'm going to go this way in

418
00:07:40,230 --> 00:07:40,240
if it's true i'm going to go this way in
 

419
00:07:40,240 --> 00:07:41,830
if it's true i'm going to go this way in
my computation and if it's false i'm

420
00:07:41,830 --> 00:07:41,840
my computation and if it's false i'm
 

421
00:07:41,840 --> 00:07:44,070
my computation and if it's false i'm
going to go this way in my computation

422
00:07:44,070 --> 00:07:44,080
going to go this way in my computation
 

423
00:07:44,080 --> 00:07:47,589
going to go this way in my computation
right and i'm going to keep doing that

424
00:07:47,589 --> 00:07:47,599
right and i'm going to keep doing that
 

425
00:07:47,599 --> 00:07:56,830
right and i'm going to keep doing that
with various comparisons um

426
00:07:56,830 --> 00:07:56,840

 

427
00:07:56,840 --> 00:07:58,150

sure

428
00:07:58,150 --> 00:07:58,160
sure
 

429
00:07:58,160 --> 00:08:00,390
sure
until i get down here to some

430
00:08:00,390 --> 00:08:00,400
until i get down here to some
 

431
00:08:00,400 --> 00:08:01,510
until i get down here to some
[Music]

432
00:08:01,510 --> 00:08:01,520
[Music]
 

433
00:08:01,520 --> 00:08:03,749
[Music]
leaf in which i'm i'm not branching

434
00:08:03,749 --> 00:08:03,759
leaf in which i'm i'm not branching
 

435
00:08:03,759 --> 00:08:05,270
leaf in which i'm i'm not branching
right the internal nodes here are

436
00:08:05,270 --> 00:08:05,280
right the internal nodes here are
 

437
00:08:05,280 --> 00:08:06,150
right the internal nodes here are
representing

438
00:08:06,150 --> 00:08:06,160
representing
 

439
00:08:06,160 --> 00:08:08,710
representing
comparisons but the leaves are

440
00:08:08,710 --> 00:08:08,720
comparisons but the leaves are
 

441
00:08:08,720 --> 00:08:11,270
comparisons but the leaves are
representing i stopped my computation

442
00:08:11,270 --> 00:08:11,280
representing i stopped my computation
 

443
00:08:11,280 --> 00:08:13,990
representing i stopped my computation
i'm outputting something does that make

444
00:08:13,990 --> 00:08:14,000
i'm outputting something does that make
 

445
00:08:14,000 --> 00:08:14,629
i'm outputting something does that make
sense

446
00:08:14,629 --> 00:08:14,639
sense
 

447
00:08:14,639 --> 00:08:16,790
sense
what i'm kind of trying to do i'm kind

448
00:08:16,790 --> 00:08:16,800
what i'm kind of trying to do i'm kind
 

449
00:08:16,800 --> 00:08:18,790
what i'm kind of trying to do i'm kind
of

450
00:08:18,790 --> 00:08:18,800
of
 

451
00:08:18,800 --> 00:08:20,869
of
changing my algorithm to be put in this

452
00:08:20,869 --> 00:08:20,879
changing my algorithm to be put in this
 

453
00:08:20,879 --> 00:08:22,469
changing my algorithm to be put in this
kind of graphical way

454
00:08:22,469 --> 00:08:22,479
kind of graphical way
 

455
00:08:22,479 --> 00:08:24,710
kind of graphical way
where i'm branching what my program

456
00:08:24,710 --> 00:08:24,720
where i'm branching what my program
 

457
00:08:24,720 --> 00:08:27,110
where i'm branching what my program
could possibly do

458
00:08:27,110 --> 00:08:27,120
could possibly do
 

459
00:08:27,120 --> 00:08:29,430
could possibly do
based on the comparisons that i do right

460
00:08:29,430 --> 00:08:29,440
based on the comparisons that i do right
 

461
00:08:29,440 --> 00:08:30,390
based on the comparisons that i do right
i'm not i'm not

462
00:08:30,390 --> 00:08:30,400
i'm not i'm not
 

463
00:08:30,400 --> 00:08:32,870
i'm not i'm not
actually counting the rest of the work

464
00:08:32,870 --> 00:08:32,880
actually counting the rest of the work
 

465
00:08:32,880 --> 00:08:34,469
actually counting the rest of the work
that the program does

466
00:08:34,469 --> 00:08:34,479
that the program does
 

467
00:08:34,479 --> 00:08:36,389
that the program does
right i'm really only looking at the

468
00:08:36,389 --> 00:08:36,399
right i'm really only looking at the
 

469
00:08:36,399 --> 00:08:37,509
right i'm really only looking at the
comparisons

470
00:08:37,509 --> 00:08:37,519
comparisons
 

471
00:08:37,519 --> 00:08:40,149
comparisons
right because i know that i i'll need to

472
00:08:40,149 --> 00:08:40,159
right because i know that i i'll need to
 

473
00:08:40,159 --> 00:08:41,190
right because i know that i i'll need to
compare some things

474
00:08:41,190 --> 00:08:41,200
compare some things
 

475
00:08:41,200 --> 00:08:44,550
compare some things
eventually to figure out what my items

476
00:08:44,550 --> 00:08:44,560
eventually to figure out what my items
 

477
00:08:44,560 --> 00:08:45,829
eventually to figure out what my items
are and if that's the only way i can

478
00:08:45,829 --> 00:08:45,839
are and if that's the only way i can
 

479
00:08:45,839 --> 00:08:47,190
are and if that's the only way i can
distinguish items

480
00:08:47,190 --> 00:08:47,200
distinguish items
 

481
00:08:47,200 --> 00:08:49,110
distinguish items
then i have to do those comparisons to

482
00:08:49,110 --> 00:08:49,120
then i have to do those comparisons to
 

483
00:08:49,120 --> 00:08:51,430
then i have to do those comparisons to
to find out right does that make sense

484
00:08:51,430 --> 00:08:51,440
to find out right does that make sense
 

485
00:08:51,440 --> 00:08:54,870
to find out right does that make sense
all right so what i have is a binary

486
00:08:54,870 --> 00:08:54,880
all right so what i have is a binary
 

487
00:08:54,880 --> 00:08:56,070
all right so what i have is a binary
tree

488
00:08:56,070 --> 00:08:56,080
tree
 

489
00:08:56,080 --> 00:08:58,389
tree
that's representing the comparisons done

490
00:08:58,389 --> 00:08:58,399
that's representing the comparisons done
 

491
00:08:58,399 --> 00:08:59,350
that's representing the comparisons done
by my algorithm

492
00:08:59,350 --> 00:08:59,360
by my algorithm
 

493
00:08:59,360 --> 00:09:03,030
by my algorithm
okay so it starts at one comparison and

494
00:09:03,030 --> 00:09:03,040
okay so it starts at one comparison and
 

495
00:09:03,040 --> 00:09:04,550
okay so it starts at one comparison and
then it branches

496
00:09:04,550 --> 00:09:04,560
then it branches
 

497
00:09:04,560 --> 00:09:10,389
then it branches
how many leaves must i have in my tree

498
00:09:10,389 --> 00:09:10,399

 

499
00:09:10,399 --> 00:09:12,630

what does that question mean right like

500
00:09:12,630 --> 00:09:12,640
what does that question mean right like
 

501
00:09:12,640 --> 00:09:16,550
what does that question mean right like
in in terms of the program

502
00:09:16,550 --> 00:09:16,560

 

503
00:09:16,560 --> 00:09:18,550

what's up the number comparison the

504
00:09:18,550 --> 00:09:18,560
what's up the number comparison the
 

505
00:09:18,560 --> 00:09:20,310
what's up the number comparison the
number of comparisons no that's the

506
00:09:20,310 --> 00:09:20,320
number of comparisons no that's the
 

507
00:09:20,320 --> 00:09:22,310
number of comparisons no that's the
number of internal nodes that i have

508
00:09:22,310 --> 00:09:22,320
number of internal nodes that i have
 

509
00:09:22,320 --> 00:09:23,990
number of internal nodes that i have
in the algorithm and actually the number

510
00:09:23,990 --> 00:09:24,000
in the algorithm and actually the number
 

511
00:09:24,000 --> 00:09:26,710
in the algorithm and actually the number
of comparisons that i do in an execution

512
00:09:26,710 --> 00:09:26,720
of comparisons that i do in an execution
 

513
00:09:26,720 --> 00:09:28,150
of comparisons that i do in an execution
of the algorithm is just

514
00:09:28,150 --> 00:09:28,160
of the algorithm is just
 

515
00:09:28,160 --> 00:09:31,750
of the algorithm is just
along a path from here to the to a leaf

516
00:09:31,750 --> 00:09:31,760
along a path from here to the to a leaf
 

517
00:09:31,760 --> 00:09:34,070
along a path from here to the to a leaf
right so what do the leaves actually

518
00:09:34,070 --> 00:09:34,080
right so what do the leaves actually
 

519
00:09:34,080 --> 00:09:35,269
right so what do the leaves actually
represent those are represent

520
00:09:35,269 --> 00:09:35,279
represent those are represent
 

521
00:09:35,279 --> 00:09:36,790
represent those are represent
outputs right i'm going to output

522
00:09:36,790 --> 00:09:36,800
outputs right i'm going to output
 

523
00:09:36,800 --> 00:09:38,630
outputs right i'm going to output
something here

524
00:09:38,630 --> 00:09:38,640
something here
 

525
00:09:38,640 --> 00:09:41,990
something here
and yeah the number of i

526
00:09:41,990 --> 00:09:42,000
and yeah the number of i
 

527
00:09:42,000 --> 00:09:45,350
and yeah the number of i
okay so i need at least

528
00:09:45,350 --> 00:09:45,360
okay so i need at least
 

529
00:09:45,360 --> 00:09:46,949
okay so i need at least
so what is the output to my search

530
00:09:46,949 --> 00:09:46,959
so what is the output to my search
 

531
00:09:46,959 --> 00:09:48,389
so what is the output to my search
algorithm maybe it's the

532
00:09:48,389 --> 00:09:48,399
algorithm maybe it's the
 

533
00:09:48,399 --> 00:09:52,230
algorithm maybe it's the
an index of an item that contains this

534
00:09:52,230 --> 00:09:52,240
an index of an item that contains this
 

535
00:09:52,240 --> 00:09:53,110
an index of an item that contains this
key or maybe

536
00:09:53,110 --> 00:09:53,120
key or maybe
 

537
00:09:53,120 --> 00:09:56,870
key or maybe
i return the item uh

538
00:09:56,870 --> 00:09:56,880
i return the item uh
 

539
00:09:56,880 --> 00:09:58,949
i return the item uh
is the output right the item so the of

540
00:09:58,949 --> 00:09:58,959
is the output right the item so the of
 

541
00:09:58,959 --> 00:10:00,470
is the output right the item so the of
the thing i'm storing and i'm storing n

542
00:10:00,470 --> 00:10:00,480
the thing i'm storing and i'm storing n
 

543
00:10:00,480 --> 00:10:02,069
the thing i'm storing and i'm storing n
things so i need at least

544
00:10:02,069 --> 00:10:02,079
things so i need at least
 

545
00:10:02,079 --> 00:10:05,670
things so i need at least
n outputs right because i need to be

546
00:10:05,670 --> 00:10:05,680
n outputs right because i need to be
 

547
00:10:05,680 --> 00:10:06,710
n outputs right because i need to be
able to return

548
00:10:06,710 --> 00:10:06,720
able to return
 

549
00:10:06,720 --> 00:10:09,030
able to return
any of the items that i'm storing based

550
00:10:09,030 --> 00:10:09,040
any of the items that i'm storing based
 

551
00:10:09,040 --> 00:10:09,910
any of the items that i'm storing based
on a different

552
00:10:09,910 --> 00:10:09,920
on a different
 

553
00:10:09,920 --> 00:10:11,590
on a different
search key parameter if it's going to be

554
00:10:11,590 --> 00:10:11,600
search key parameter if it's going to be
 

555
00:10:11,600 --> 00:10:13,670
search key parameter if it's going to be
correct i actually need one more output

556
00:10:13,670 --> 00:10:13,680
correct i actually need one more output
 

557
00:10:13,680 --> 00:10:17,590
correct i actually need one more output
why do i need one more output

558
00:10:17,590 --> 00:10:17,600

 

559
00:10:17,600 --> 00:10:21,509

if it's not in there right right so

560
00:10:21,509 --> 00:10:21,519
if it's not in there right right so
 

561
00:10:21,519 --> 00:10:24,790
if it's not in there right right so
any correct comparison

562
00:10:24,790 --> 00:10:24,800
any correct comparison
 

563
00:10:24,800 --> 00:10:27,590
any correct comparison
searching algorithm i've i'm doing some

564
00:10:27,590 --> 00:10:27,600
searching algorithm i've i'm doing some
 

565
00:10:27,600 --> 00:10:29,910
searching algorithm i've i'm doing some
comparisons to find this thing

566
00:10:29,910 --> 00:10:29,920
comparisons to find this thing
 

567
00:10:29,920 --> 00:10:33,269
comparisons to find this thing
needs to have at least

568
00:10:33,269 --> 00:10:33,279
needs to have at least
 

569
00:10:33,279 --> 00:10:36,790
needs to have at least
n plus one leaves

570
00:10:36,790 --> 00:10:36,800

 

571
00:10:36,800 --> 00:10:39,590

right otherwise it can't be correct

572
00:10:39,590 --> 00:10:39,600
right otherwise it can't be correct
 

573
00:10:39,600 --> 00:10:40,310
right otherwise it can't be correct
because

574
00:10:40,310 --> 00:10:40,320
because
 

575
00:10:40,320 --> 00:10:42,949
because
i could look up the one that i i'm not

576
00:10:42,949 --> 00:10:42,959
i could look up the one that i i'm not
 

577
00:10:42,959 --> 00:10:44,790
i could look up the one that i i'm not
returning in that set

578
00:10:44,790 --> 00:10:44,800
returning in that set
 

579
00:10:44,800 --> 00:10:46,790
returning in that set
and it would never be able to return

580
00:10:46,790 --> 00:10:46,800
and it would never be able to return
 

581
00:10:46,800 --> 00:10:49,910
and it would never be able to return
that value does that make sense

582
00:10:49,910 --> 00:10:49,920
that value does that make sense
 

583
00:10:49,920 --> 00:10:53,670
that value does that make sense
yeah what's n n is always the num in for

584
00:10:53,670 --> 00:10:53,680
yeah what's n n is always the num in for
 

585
00:10:53,680 --> 00:10:55,590
yeah what's n n is always the num in for
a data structure n is the number of

586
00:10:55,590 --> 00:10:55,600
a data structure n is the number of
 

587
00:10:55,600 --> 00:10:57,590
a data structure n is the number of
things stored in that data structure at

588
00:10:57,590 --> 00:10:57,600
things stored in that data structure at
 

589
00:10:57,600 --> 00:10:59,670
things stored in that data structure at
that time right so the number of items

590
00:10:59,670 --> 00:10:59,680
that time right so the number of items
 

591
00:10:59,680 --> 00:11:00,949
that time right so the number of items
in the data structure that's what it

592
00:11:00,949 --> 00:11:00,959
in the data structure that's what it
 

593
00:11:00,959 --> 00:11:02,949
in the data structure that's what it
means in all of these tables

594
00:11:02,949 --> 00:11:02,959
means in all of these tables
 

595
00:11:02,959 --> 00:11:06,310
means in all of these tables
any other questions okay so now we get

596
00:11:06,310 --> 00:11:06,320
any other questions okay so now we get
 

597
00:11:06,320 --> 00:11:09,509
any other questions okay so now we get
to the fun part

598
00:11:09,509 --> 00:11:09,519

 

599
00:11:09,519 --> 00:11:12,710

how many comparisons does this algorithm

600
00:11:12,710 --> 00:11:12,720
how many comparisons does this algorithm
 

601
00:11:12,720 --> 00:11:16,550
how many comparisons does this algorithm
have to do

602
00:11:16,550 --> 00:11:16,560

 

603
00:11:16,560 --> 00:11:22,150

yeah up there what's up

604
00:11:22,150 --> 00:11:22,160

 

605
00:11:22,160 --> 00:11:24,470

all right your colleague is jumping

606
00:11:24,470 --> 00:11:24,480
all right your colleague is jumping
 

607
00:11:24,480 --> 00:11:26,230
all right your colleague is jumping
ahead for a second but really

608
00:11:26,230 --> 00:11:26,240
ahead for a second but really
 

609
00:11:26,240 --> 00:11:29,030
ahead for a second but really
i have to do as many comparisons in the

610
00:11:29,030 --> 00:11:29,040
i have to do as many comparisons in the
 

611
00:11:29,040 --> 00:11:30,069
i have to do as many comparisons in the
worst case

612
00:11:30,069 --> 00:11:30,079
worst case
 

613
00:11:30,079 --> 00:11:34,069
worst case
as the longest route to leaf path

614
00:11:34,069 --> 00:11:34,079
as the longest route to leaf path
 

615
00:11:34,079 --> 00:11:36,150
as the longest route to leaf path
in this tree right because as i'm

616
00:11:36,150 --> 00:11:36,160
in this tree right because as i'm
 

617
00:11:36,160 --> 00:11:38,150
in this tree right because as i'm
executing this algorithm i'll go

618
00:11:38,150 --> 00:11:38,160
executing this algorithm i'll go
 

619
00:11:38,160 --> 00:11:39,990
executing this algorithm i'll go
you know down this thing always

620
00:11:39,990 --> 00:11:40,000
you know down this thing always
 

621
00:11:40,000 --> 00:11:42,710
you know down this thing always
branching down

622
00:11:42,710 --> 00:11:42,720
branching down
 

623
00:11:42,720 --> 00:11:44,870
branching down
and at some point i'll get to a leaf and

624
00:11:44,870 --> 00:11:44,880
and at some point i'll get to a leaf and
 

625
00:11:44,880 --> 00:11:45,910
and at some point i'll get to a leaf and
in the worst case

626
00:11:45,910 --> 00:11:45,920
in the worst case
 

627
00:11:45,920 --> 00:11:48,150
in the worst case
if i happen to need to return this

628
00:11:48,150 --> 00:11:48,160
if i happen to need to return this
 

629
00:11:48,160 --> 00:11:50,069
if i happen to need to return this
particular output

630
00:11:50,069 --> 00:11:50,079
particular output
 

631
00:11:50,079 --> 00:11:52,470
particular output
right then i'll have to walk down the

632
00:11:52,470 --> 00:11:52,480
right then i'll have to walk down the
 

633
00:11:52,480 --> 00:11:53,750
right then i'll have to walk down the
longest thing

634
00:11:53,750 --> 00:11:53,760
longest thing
 

635
00:11:53,760 --> 00:11:57,030
longest thing
right it's the longest path

636
00:11:57,030 --> 00:11:57,040
right it's the longest path
 

637
00:11:57,040 --> 00:11:59,590
right it's the longest path
so and the longest path is the same as

638
00:11:59,590 --> 00:11:59,600
so and the longest path is the same as
 

639
00:11:59,600 --> 00:12:00,870
so and the longest path is the same as
the height of the tree

640
00:12:00,870 --> 00:12:00,880
the height of the tree
 

641
00:12:00,880 --> 00:12:03,910
the height of the tree
okay so the question then becomes what

642
00:12:03,910 --> 00:12:03,920
okay so the question then becomes what
 

643
00:12:03,920 --> 00:12:07,509
okay so the question then becomes what
is the minimum height

644
00:12:07,509 --> 00:12:07,519

 

645
00:12:07,519 --> 00:12:10,710

of any binary tree that has at least n

646
00:12:10,710 --> 00:12:10,720
of any binary tree that has at least n
 

647
00:12:10,720 --> 00:12:14,150
of any binary tree that has at least n
plus one leaves

648
00:12:14,150 --> 00:12:14,160

 

649
00:12:14,160 --> 00:12:16,629

ever understand why we're asking that

650
00:12:16,629 --> 00:12:16,639
ever understand why we're asking that
 

651
00:12:16,639 --> 00:12:17,829
ever understand why we're asking that
question

652
00:12:17,829 --> 00:12:17,839
question
 

653
00:12:17,839 --> 00:12:22,550
question
okay so unrest yeah

654
00:12:22,550 --> 00:12:22,560

 

655
00:12:22,560 --> 00:12:24,310

why it needs n plus one leads if it's a

656
00:12:24,310 --> 00:12:24,320
why it needs n plus one leads if it's a
 

657
00:12:24,320 --> 00:12:27,509
why it needs n plus one leads if it's a
correct algorithm it needs to return

658
00:12:27,509 --> 00:12:27,519
correct algorithm it needs to return
 

659
00:12:27,519 --> 00:12:29,509
correct algorithm it needs to return
it needs to be able to return any of the

660
00:12:29,509 --> 00:12:29,519
it needs to be able to return any of the
 

661
00:12:29,519 --> 00:12:31,269
it needs to be able to return any of the
n items that i'm storing

662
00:12:31,269 --> 00:12:31,279
n items that i'm storing
 

663
00:12:31,279 --> 00:12:33,509
n items that i'm storing
or say that the key that i'm looking for

664
00:12:33,509 --> 00:12:33,519
or say that the key that i'm looking for
 

665
00:12:33,519 --> 00:12:35,670
or say that the key that i'm looking for
is not there

666
00:12:35,670 --> 00:12:35,680
is not there
 

667
00:12:35,680 --> 00:12:38,790
is not there
great question okay so

668
00:12:38,790 --> 00:12:38,800
great question okay so
 

669
00:12:38,800 --> 00:12:41,509
great question okay so
what is the minimum height of any binary

670
00:12:41,509 --> 00:12:41,519
what is the minimum height of any binary
 

671
00:12:41,519 --> 00:12:42,470
what is the minimum height of any binary
tree

672
00:12:42,470 --> 00:12:42,480
tree
 

673
00:12:42,480 --> 00:12:45,509
tree
that has n plus one at least n plus one

674
00:12:45,509 --> 00:12:45,519
that has n plus one at least n plus one
 

675
00:12:45,519 --> 00:12:46,629
that has n plus one at least n plus one
leaves

676
00:12:46,629 --> 00:12:46,639
leaves
 

677
00:12:46,639 --> 00:12:48,790
leaves
you'll you can solve that uh you can

678
00:12:48,790 --> 00:12:48,800
you'll you can solve that uh you can
 

679
00:12:48,800 --> 00:12:50,069
you'll you can solve that uh you can
actually state a recurrence for that and

680
00:12:50,069 --> 00:12:50,079
actually state a recurrence for that and
 

681
00:12:50,079 --> 00:12:51,269
actually state a recurrence for that and
solve that you're going to do that in

682
00:12:51,269 --> 00:12:51,279
solve that you're going to do that in
 

683
00:12:51,279 --> 00:12:52,230
solve that you're going to do that in
your recitation

684
00:12:52,230 --> 00:12:52,240
your recitation
 

685
00:12:52,240 --> 00:12:54,389
your recitation
but it's log n right like the best you

686
00:12:54,389 --> 00:12:54,399
but it's log n right like the best you
 

687
00:12:54,399 --> 00:12:56,629
but it's log n right like the best you
can do is if this is a balanced

688
00:12:56,629 --> 00:12:56,639
can do is if this is a balanced
 

689
00:12:56,639 --> 00:13:00,389
can do is if this is a balanced
binary tree right so the min

690
00:13:00,389 --> 00:13:00,399
binary tree right so the min
 

691
00:13:00,399 --> 00:13:03,430
binary tree right so the min
height

692
00:13:03,430 --> 00:13:03,440

 

693
00:13:03,440 --> 00:13:08,470

is going to be at least

694
00:13:08,470 --> 00:13:08,480

 

695
00:13:08,480 --> 00:13:14,310

log n height right

696
00:13:14,310 --> 00:13:14,320

 

697
00:13:14,320 --> 00:13:16,150

right where the min height is

698
00:13:16,150 --> 00:13:16,160
right where the min height is
 

699
00:13:16,160 --> 00:13:18,470
right where the min height is
logarithmic right so it's actually theta

700
00:13:18,470 --> 00:13:18,480
logarithmic right so it's actually theta
 

701
00:13:18,480 --> 00:13:20,949
logarithmic right so it's actually theta
right here but but if i just said height

702
00:13:20,949 --> 00:13:20,959
right here but but if i just said height
 

703
00:13:20,959 --> 00:13:21,509
right here but but if i just said height
here

704
00:13:21,509 --> 00:13:21,519
here
 

705
00:13:21,519 --> 00:13:23,670
here
i would be lower bounding the height

706
00:13:23,670 --> 00:13:23,680
i would be lower bounding the height
 

707
00:13:23,680 --> 00:13:25,670
i would be lower bounding the height
right if i could have a linear

708
00:13:25,670 --> 00:13:25,680
right if i could have a linear
 

709
00:13:25,680 --> 00:13:27,910
right if i could have a linear
height right if i just chained

710
00:13:27,910 --> 00:13:27,920
height right if i just chained
 

711
00:13:27,920 --> 00:13:29,269
height right if i just chained
comparisons down

712
00:13:29,269 --> 00:13:29,279
comparisons down
 

713
00:13:29,279 --> 00:13:31,509
comparisons down
one by one if i was doing a linear

714
00:13:31,509 --> 00:13:31,519
one by one if i was doing a linear
 

715
00:13:31,519 --> 00:13:32,870
one by one if i was doing a linear
search for example

716
00:13:32,870 --> 00:13:32,880
search for example
 

717
00:13:32,880 --> 00:13:35,509
search for example
right all right so this is saying that

718
00:13:35,509 --> 00:13:35,519
right all right so this is saying that
 

719
00:13:35,519 --> 00:13:38,310
right all right so this is saying that
if i'm just restricting to comparisons

720
00:13:38,310 --> 00:13:38,320
if i'm just restricting to comparisons
 

721
00:13:38,320 --> 00:13:40,230
if i'm just restricting to comparisons
i have to spend at least logarithmic

722
00:13:40,230 --> 00:13:40,240
i have to spend at least logarithmic
 

723
00:13:40,240 --> 00:13:41,829
i have to spend at least logarithmic
time to be able to find

724
00:13:41,829 --> 00:13:41,839
time to be able to find
 

725
00:13:41,839 --> 00:13:46,550
time to be able to find
whether this key is in my set right

726
00:13:46,550 --> 00:13:46,560

 

727
00:13:46,560 --> 00:13:48,150

but i don't want logarithmic time i want

728
00:13:48,150 --> 00:13:48,160
but i don't want logarithmic time i want
 

729
00:13:48,160 --> 00:13:49,670
but i don't want logarithmic time i want
faster

730
00:13:49,670 --> 00:13:49,680
faster
 

731
00:13:49,680 --> 00:13:52,550
faster
so how can i do that i have one

732
00:13:52,550 --> 00:13:52,560
so how can i do that i have one
 

733
00:13:52,560 --> 00:13:53,189
so how can i do that i have one
operation

734
00:13:53,189 --> 00:13:53,199
operation
 

735
00:13:53,199 --> 00:13:55,110
operation
in my model of computation i presented a

736
00:13:55,110 --> 00:13:55,120
in my model of computation i presented a
 

737
00:13:55,120 --> 00:13:56,870
in my model of computation i presented a
couple weeks ago

738
00:13:56,870 --> 00:13:56,880
couple weeks ago
 

739
00:13:56,880 --> 00:13:59,509
couple weeks ago
that allows me to do faster which allows

740
00:13:59,509 --> 00:13:59,519
that allows me to do faster which allows
 

741
00:13:59,519 --> 00:14:02,069
that allows me to do faster which allows
me to do something stronger than

742
00:14:02,069 --> 00:14:02,079
me to do something stronger than
 

743
00:14:02,079 --> 00:14:03,189
me to do something stronger than
comparisons

744
00:14:03,189 --> 00:14:03,199
comparisons
 

745
00:14:03,199 --> 00:14:05,829
comparisons
comparisons have a constant branching

746
00:14:05,829 --> 00:14:05,839
comparisons have a constant branching
 

747
00:14:05,839 --> 00:14:06,629
comparisons have a constant branching
factor

748
00:14:06,629 --> 00:14:06,639
factor
 

749
00:14:06,639 --> 00:14:09,670
factor
in particular i can i if i do this

750
00:14:09,670 --> 00:14:09,680
in particular i can i if i do this
 

751
00:14:09,680 --> 00:14:11,590
in particular i can i if i do this
operation this constant time operation

752
00:14:11,590 --> 00:14:11,600
operation this constant time operation
 

753
00:14:11,600 --> 00:14:14,790
operation this constant time operation
i can branch

754
00:14:14,790 --> 00:14:14,800

 

755
00:14:14,800 --> 00:14:17,350

to two different locations right it's

756
00:14:17,350 --> 00:14:17,360
to two different locations right it's
 

757
00:14:17,360 --> 00:14:18,470
to two different locations right it's
like an if

758
00:14:18,470 --> 00:14:18,480
like an if
 

759
00:14:18,480 --> 00:14:21,509
like an if
kind of situation if or else right

760
00:14:21,509 --> 00:14:21,519
kind of situation if or else right
 

761
00:14:21,519 --> 00:14:24,069
kind of situation if or else right
and in fact if i had constant branching

762
00:14:24,069 --> 00:14:24,079
and in fact if i had constant branching
 

763
00:14:24,079 --> 00:14:24,710
and in fact if i had constant branching
factor for

764
00:14:24,710 --> 00:14:24,720
factor for
 

765
00:14:24,720 --> 00:14:27,910
factor for
any constant here

766
00:14:27,910 --> 00:14:27,920
any constant here
 

767
00:14:27,920 --> 00:14:29,829
any constant here
right if i had three or four if it was

768
00:14:29,829 --> 00:14:29,839
right if i had three or four if it was
 

769
00:14:29,839 --> 00:14:31,110
right if i had three or four if it was
bounded by a constant

770
00:14:31,110 --> 00:14:31,120
bounded by a constant
 

771
00:14:31,120 --> 00:14:32,790
bounded by a constant
the height of this tree would still be

772
00:14:32,790 --> 00:14:32,800
the height of this tree would still be
 

773
00:14:32,800 --> 00:14:35,030
the height of this tree would still be
bounded by a log base

774
00:14:35,030 --> 00:14:35,040
bounded by a log base
 

775
00:14:35,040 --> 00:14:38,710
bounded by a log base
the constant of that number of leaves

776
00:14:38,710 --> 00:14:38,720
the constant of that number of leaves
 

777
00:14:38,720 --> 00:14:41,189
the constant of that number of leaves
okay so i need in some sense to be able

778
00:14:41,189 --> 00:14:41,199
okay so i need in some sense to be able
 

779
00:14:41,199 --> 00:14:42,150
okay so i need in some sense to be able
to branch

780
00:14:42,150 --> 00:14:42,160
to branch
 

781
00:14:42,160 --> 00:14:45,670
to branch
a non-constant amount right

782
00:14:45,670 --> 00:14:45,680
a non-constant amount right
 

783
00:14:45,680 --> 00:14:47,189
a non-constant amount right
so how can i branch a non-constant

784
00:14:47,189 --> 00:14:47,199
so how can i branch a non-constant
 

785
00:14:47,199 --> 00:14:49,269
so how can i branch a non-constant
amount

786
00:14:49,269 --> 00:14:49,279
amount
 

787
00:14:49,279 --> 00:14:52,150
amount
this is a little tricky right we had

788
00:14:52,150 --> 00:14:52,160
this is a little tricky right we had
 

789
00:14:52,160 --> 00:14:53,829
this is a little tricky right we had
this really neat

790
00:14:53,829 --> 00:14:53,839
this really neat
 

791
00:14:53,839 --> 00:14:57,269
this really neat
operation in the random access

792
00:14:57,269 --> 00:14:57,279
operation in the random access
 

793
00:14:57,279 --> 00:15:00,550
operation in the random access
machine that we could randomly

794
00:15:00,550 --> 00:15:00,560
machine that we could randomly
 

795
00:15:00,560 --> 00:15:03,110
machine that we could randomly
uh go to any place in memory in constant

796
00:15:03,110 --> 00:15:03,120
uh go to any place in memory in constant
 

797
00:15:03,120 --> 00:15:04,949
uh go to any place in memory in constant
time based on a number

798
00:15:04,949 --> 00:15:04,959
time based on a number
 

799
00:15:04,959 --> 00:15:08,069
time based on a number
right

800
00:15:08,069 --> 00:15:08,079

 

801
00:15:08,079 --> 00:15:09,910

it was a super powerful thing because

802
00:15:09,910 --> 00:15:09,920
it was a super powerful thing because
 

803
00:15:09,920 --> 00:15:12,389
it was a super powerful thing because
within a single constant time operation

804
00:15:12,389 --> 00:15:12,399
within a single constant time operation
 

805
00:15:12,399 --> 00:15:15,269
within a single constant time operation
i could go to any space in memory right

806
00:15:15,269 --> 00:15:15,279
i could go to any space in memory right
 

807
00:15:15,279 --> 00:15:15,750
i could go to any space in memory right
that's

808
00:15:15,750 --> 00:15:15,760
that's
 

809
00:15:15,760 --> 00:15:17,829
that's
that's potentially much larger than

810
00:15:17,829 --> 00:15:17,839
that's potentially much larger than
 

811
00:15:17,839 --> 00:15:19,350
that's potentially much larger than
linear branching factor depending on the

812
00:15:19,350 --> 00:15:19,360
linear branching factor depending on the
 

813
00:15:19,360 --> 00:15:20,310
linear branching factor depending on the
size of my model

814
00:15:20,310 --> 00:15:20,320
size of my model
 

815
00:15:20,320 --> 00:15:22,550
size of my model
and the size of my machine right so

816
00:15:22,550 --> 00:15:22,560
and the size of my machine right so
 

817
00:15:22,560 --> 00:15:24,470
and the size of my machine right so
that's a very powerful operation can we

818
00:15:24,470 --> 00:15:24,480
that's a very powerful operation can we
 

819
00:15:24,480 --> 00:15:25,750
that's a very powerful operation can we
use that

820
00:15:25,750 --> 00:15:25,760
use that
 

821
00:15:25,760 --> 00:15:31,350
use that
to find quicker anyone have any ideas

822
00:15:31,350 --> 00:15:31,360

 

823
00:15:31,360 --> 00:15:34,710

sure uh we're going to get to hashing in

824
00:15:34,710 --> 00:15:34,720
sure uh we're going to get to hashing in
 

825
00:15:34,720 --> 00:15:36,710
sure uh we're going to get to hashing in
a second but this is a

826
00:15:36,710 --> 00:15:36,720
a second but this is a
 

827
00:15:36,720 --> 00:15:39,350
a second but this is a
simpler concept a concept in hashing

828
00:15:39,350 --> 00:15:39,360
simpler concept a concept in hashing
 

829
00:15:39,360 --> 00:15:40,550
simpler concept a concept in hashing
hashing

830
00:15:40,550 --> 00:15:40,560
hashing
 

831
00:15:40,560 --> 00:15:42,069
hashing
something you probably are familiar with

832
00:15:42,069 --> 00:15:42,079
something you probably are familiar with
 

833
00:15:42,079 --> 00:15:44,150
something you probably are familiar with
already

834
00:15:44,150 --> 00:15:44,160
already
 

835
00:15:44,160 --> 00:15:46,230
already
we've kind of been using it implicitly

836
00:15:46,230 --> 00:15:46,240
we've kind of been using it implicitly
 

837
00:15:46,240 --> 00:15:47,749
we've kind of been using it implicitly
in some of our sequence data structure

838
00:15:47,749 --> 00:15:47,759
in some of our sequence data structure
 

839
00:15:47,759 --> 00:15:50,069
in some of our sequence data structure
things

840
00:15:50,069 --> 00:15:50,079

 

841
00:15:50,079 --> 00:15:54,150

what we're going to do is if i have a

842
00:15:54,150 --> 00:15:54,160
what we're going to do is if i have a
 

843
00:15:54,160 --> 00:15:57,749
what we're going to do is if i have a
an item that has key 10 okay

844
00:15:57,749 --> 00:15:57,759
an item that has key 10 okay
 

845
00:15:57,759 --> 00:16:00,310
an item that has key 10 okay
i'm going to keep an array and store

846
00:16:00,310 --> 00:16:00,320
i'm going to keep an array and store
 

847
00:16:00,320 --> 00:16:02,949
i'm going to keep an array and store
that item

848
00:16:02,949 --> 00:16:02,959

 

849
00:16:02,959 --> 00:16:04,710

10 spaces away from the front of the

850
00:16:04,710 --> 00:16:04,720
10 spaces away from the front of the
 

851
00:16:04,720 --> 00:16:06,150
10 spaces away from the front of the
array right at

852
00:16:06,150 --> 00:16:06,160
array right at
 

853
00:16:06,160 --> 00:16:09,910
array right at
index nine or the tenth index does that

854
00:16:09,910 --> 00:16:09,920
index nine or the tenth index does that
 

855
00:16:09,920 --> 00:16:11,269
index nine or the tenth index does that
make sense

856
00:16:11,269 --> 00:16:11,279
make sense
 

857
00:16:11,279 --> 00:16:14,310
make sense
if i store that item at that location in

858
00:16:14,310 --> 00:16:14,320
if i store that item at that location in
 

859
00:16:14,320 --> 00:16:16,470
if i store that item at that location in
memory i can use this

860
00:16:16,470 --> 00:16:16,480
memory i can use this
 

861
00:16:16,480 --> 00:16:19,670
memory i can use this
random access to that location

862
00:16:19,670 --> 00:16:19,680
random access to that location
 

863
00:16:19,680 --> 00:16:21,030
random access to that location
and see if there's something there if

864
00:16:21,030 --> 00:16:21,040
and see if there's something there if
 

865
00:16:21,040 --> 00:16:22,310
and see if there's something there if
there's something there i return that

866
00:16:22,310 --> 00:16:22,320
there's something there i return that
 

867
00:16:22,320 --> 00:16:24,710
there's something there i return that
item does that make sense

868
00:16:24,710 --> 00:16:24,720
item does that make sense
 

869
00:16:24,720 --> 00:16:26,470
item does that make sense
this is what i call a direct access

870
00:16:26,470 --> 00:16:26,480
this is what i call a direct access
 

871
00:16:26,480 --> 00:16:29,590
this is what i call a direct access
array

872
00:16:29,590 --> 00:16:29,600

 

873
00:16:29,600 --> 00:16:31,990

it's really no different than the arrays

874
00:16:31,990 --> 00:16:32,000
it's really no different than the arrays
 

875
00:16:32,000 --> 00:16:33,749
it's really no different than the arrays
that we've been

876
00:16:33,749 --> 00:16:33,759
that we've been
 

877
00:16:33,759 --> 00:16:37,990
that we've been
talking about earlier in the class

878
00:16:37,990 --> 00:16:38,000

 

879
00:16:38,000 --> 00:16:42,310

we got an array and if i have

880
00:16:42,310 --> 00:16:42,320
we got an array and if i have
 

881
00:16:42,320 --> 00:16:46,790
we got an array and if i have
an item here with key equals 10

882
00:16:46,790 --> 00:16:46,800
an item here with key equals 10
 

883
00:16:46,800 --> 00:16:49,990
an item here with key equals 10
i'll stick it here in the 10th place

884
00:16:49,990 --> 00:16:50,000
i'll stick it here in the 10th place
 

885
00:16:50,000 --> 00:16:54,230
i'll stick it here in the 10th place
now i can only now store one item

886
00:16:54,230 --> 00:16:54,240
now i can only now store one item
 

887
00:16:54,240 --> 00:16:57,509
now i can only now store one item
with the key 10 in my thing and that's

888
00:16:57,509 --> 00:16:57,519
with the key 10 in my thing and that's
 

889
00:16:57,519 --> 00:16:59,189
with the key 10 in my thing and that's
one of the stipulations we had on our

890
00:16:59,189 --> 00:16:59,199
one of the stipulations we had on our
 

891
00:16:59,199 --> 00:17:01,030
one of the stipulations we had on our
set data structures right if we tried to

892
00:17:01,030 --> 00:17:01,040
set data structures right if we tried to
 

893
00:17:01,040 --> 00:17:02,230
set data structures right if we tried to
insert something

894
00:17:02,230 --> 00:17:02,240
insert something
 

895
00:17:02,240 --> 00:17:03,910
insert something
with the same key as something already

896
00:17:03,910 --> 00:17:03,920
with the same key as something already
 

897
00:17:03,920 --> 00:17:05,189
with the same key as something already
stored there we're going to replace the

898
00:17:05,189 --> 00:17:05,199
stored there we're going to replace the
 

899
00:17:05,199 --> 00:17:05,990
stored there we're going to replace the
item

900
00:17:05,990 --> 00:17:06,000
item
 

901
00:17:06,000 --> 00:17:07,829
item
right that's what the semantics of our

902
00:17:07,829 --> 00:17:07,839
right that's what the semantics of our
 

903
00:17:07,839 --> 00:17:09,350
right that's what the semantics of our
set interface was

904
00:17:09,350 --> 00:17:09,360
set interface was
 

905
00:17:09,360 --> 00:17:10,949
set interface was
but that's okay that's that's that's

906
00:17:10,949 --> 00:17:10,959
but that's okay that's that's that's
 

907
00:17:10,959 --> 00:17:13,110
but that's okay that's that's that's
satisfying uh the conditions of our send

908
00:17:13,110 --> 00:17:13,120
satisfying uh the conditions of our send
 

909
00:17:13,120 --> 00:17:14,630
satisfying uh the conditions of our send
interface

910
00:17:14,630 --> 00:17:14,640
interface
 

911
00:17:14,640 --> 00:17:17,510
interface
so if we store it there that's fantastic

912
00:17:17,510 --> 00:17:17,520
so if we store it there that's fantastic
 

913
00:17:17,520 --> 00:17:17,990
so if we store it there that's fantastic
how how

914
00:17:17,990 --> 00:17:18,000
how how
 

915
00:17:18,000 --> 00:17:19,669
how how
long does it take to find if we have an

916
00:17:19,669 --> 00:17:19,679
long does it take to find if we have an
 

917
00:17:19,679 --> 00:17:23,110
long does it take to find if we have an
item with the the key 10

918
00:17:23,110 --> 00:17:23,120
item with the the key 10
 

919
00:17:23,120 --> 00:17:27,029
item with the the key 10
it takes constant time worst case great

920
00:17:27,029 --> 00:17:27,039
it takes constant time worst case great
 

921
00:17:27,039 --> 00:17:28,390
it takes constant time worst case great
how about inserting or deleting

922
00:17:28,390 --> 00:17:28,400
how about inserting or deleting
 

923
00:17:28,400 --> 00:17:30,630
how about inserting or deleting
something

924
00:17:30,630 --> 00:17:30,640
something
 

925
00:17:30,640 --> 00:17:34,150
something
what's what's that again constant time

926
00:17:34,150 --> 00:17:34,160
what's what's that again constant time
 

927
00:17:34,160 --> 00:17:36,549
what's what's that again constant time
we've solved all of our problems this is

928
00:17:36,549 --> 00:17:36,559
we've solved all of our problems this is
 

929
00:17:36,559 --> 00:17:39,510
we've solved all of our problems this is
amazing

930
00:17:39,510 --> 00:17:39,520

 

931
00:17:39,520 --> 00:17:42,150

okay what's not amazing about this why

932
00:17:42,150 --> 00:17:42,160
okay what's not amazing about this why
 

933
00:17:42,160 --> 00:17:52,950
okay what's not amazing about this why
don't we just do this all the time

934
00:17:52,950 --> 00:17:52,960

 

935
00:17:52,960 --> 00:17:56,070

ah i don't know how high the numbers go

936
00:17:56,070 --> 00:17:56,080
ah i don't know how high the numbers go
 

937
00:17:56,080 --> 00:17:58,870
ah i don't know how high the numbers go
right so let's say i'm storing i don't

938
00:17:58,870 --> 00:17:58,880
right so let's say i'm storing i don't
 

939
00:17:58,880 --> 00:17:59,350
right so let's say i'm storing i don't
know

940
00:17:59,350 --> 00:17:59,360
know
 

941
00:17:59,360 --> 00:18:02,390
know
a number associated with the the

942
00:18:02,390 --> 00:18:02,400
a number associated with the the
 

943
00:18:02,400 --> 00:18:03,909
a number associated with the the
three or four hundred of you that are in

944
00:18:03,909 --> 00:18:03,919
three or four hundred of you that are in
 

945
00:18:03,919 --> 00:18:05,590
three or four hundred of you that are in
this classroom

946
00:18:05,590 --> 00:18:05,600
this classroom
 

947
00:18:05,600 --> 00:18:10,150
this classroom
right but i'm storing your mit ids

948
00:18:10,150 --> 00:18:10,160
right but i'm storing your mit ids
 

949
00:18:10,160 --> 00:18:12,630
right but i'm storing your mit ids
how big are those numbers those are like

950
00:18:12,630 --> 00:18:12,640
how big are those numbers those are like
 

951
00:18:12,640 --> 00:18:14,549
how big are those numbers those are like
nine digit numbers

952
00:18:14,549 --> 00:18:14,559
nine digit numbers
 

953
00:18:14,559 --> 00:18:17,750
nine digit numbers
right pretty long numbers so what i

954
00:18:17,750 --> 00:18:17,760
right pretty long numbers so what i
 

955
00:18:17,760 --> 00:18:18,630
right pretty long numbers so what i
would need to do

956
00:18:18,630 --> 00:18:18,640
would need to do
 

957
00:18:18,640 --> 00:18:21,669
would need to do
in in if i was storing your keys as

958
00:18:21,669 --> 00:18:21,679
in in if i was storing your keys as
 

959
00:18:21,679 --> 00:18:24,870
in in if i was storing your keys as
uh mit ids i would need an

960
00:18:24,870 --> 00:18:24,880
uh mit ids i would need an
 

961
00:18:24,880 --> 00:18:27,830
uh mit ids i would need an
array that has indices that span the

962
00:18:27,830 --> 00:18:27,840
array that has indices that span the
 

963
00:18:27,840 --> 00:18:30,549
array that has indices that span the
entire space

964
00:18:30,549 --> 00:18:30,559
entire space
 

965
00:18:30,559 --> 00:18:33,830
entire space
of nine digit numbers right that's like

966
00:18:33,830 --> 00:18:33,840
of nine digit numbers right that's like
 

967
00:18:33,840 --> 00:18:37,029
of nine digit numbers right that's like
10 to the nine or nine uh

968
00:18:37,029 --> 00:18:37,039
10 to the nine or nine uh
 

969
00:18:37,039 --> 00:18:40,150
10 to the nine or nine uh
10 to the nine thank you ten to the nine

970
00:18:40,150 --> 00:18:40,160
10 to the nine thank you ten to the nine
 

971
00:18:40,160 --> 00:18:43,029
10 to the nine thank you ten to the nine
is the the size of a direct access array

972
00:18:43,029 --> 00:18:43,039
is the the size of a direct access array
 

973
00:18:43,039 --> 00:18:45,430
is the the size of a direct access array
i would have to build to be able to

974
00:18:45,430 --> 00:18:45,440
i would have to build to be able to
 

975
00:18:45,440 --> 00:18:47,720
i would have to build to be able to
use this um

976
00:18:47,720 --> 00:18:47,730
use this um
 

977
00:18:47,730 --> 00:18:49,029
use this um
[Music]

978
00:18:49,029 --> 00:18:49,039
[Music]
 

979
00:18:49,039 --> 00:18:52,230
[Music]
this technique to to create a direct

980
00:18:52,230 --> 00:18:52,240
this technique to to create a direct
 

981
00:18:52,240 --> 00:18:54,310
this technique to to create a direct
access array to search on your mit ids

982
00:18:54,310 --> 00:18:54,320
access array to search on your mit ids
 

983
00:18:54,320 --> 00:18:56,070
access array to search on your mit ids
when there's only really 300 of you in

984
00:18:56,070 --> 00:18:56,080
when there's only really 300 of you in
 

985
00:18:56,080 --> 00:18:56,950
when there's only really 300 of you in
here

986
00:18:56,950 --> 00:18:56,960
here
 

987
00:18:56,960 --> 00:19:00,230
here
right so 300 or 400 is an n

988
00:19:00,230 --> 00:19:00,240
right so 300 or 400 is an n
 

989
00:19:00,240 --> 00:19:02,470
right so 300 or 400 is an n
that's much smaller than the size of the

990
00:19:02,470 --> 00:19:02,480
that's much smaller than the size of the
 

991
00:19:02,480 --> 00:19:04,230
that's much smaller than the size of the
numbers that i'm trying to store

992
00:19:04,230 --> 00:19:04,240
numbers that i'm trying to store
 

993
00:19:04,240 --> 00:19:06,230
numbers that i'm trying to store
what i'm going to use as a variable to

994
00:19:06,230 --> 00:19:06,240
what i'm going to use as a variable to
 

995
00:19:06,240 --> 00:19:08,070
what i'm going to use as a variable to
to talk about the size of the numbers

996
00:19:08,070 --> 00:19:08,080
to talk about the size of the numbers
 

997
00:19:08,080 --> 00:19:08,870
to talk about the size of the numbers
i'm storing

998
00:19:08,870 --> 00:19:08,880
i'm storing
 

999
00:19:08,880 --> 00:19:11,270
i'm storing
i'm going to say u is the maximum size

1000
00:19:11,270 --> 00:19:11,280
i'm going to say u is the maximum size
 

1001
00:19:11,280 --> 00:19:13,190
i'm going to say u is the maximum size
of any number that i'm storing

1002
00:19:13,190 --> 00:19:13,200
of any number that i'm storing
 

1003
00:19:13,200 --> 00:19:15,590
of any number that i'm storing
okay it's the size of the universe of

1004
00:19:15,590 --> 00:19:15,600
okay it's the size of the universe of
 

1005
00:19:15,600 --> 00:19:17,029
okay it's the size of the universe of
space of keys

1006
00:19:17,029 --> 00:19:17,039
space of keys
 

1007
00:19:17,039 --> 00:19:19,190
space of keys
that i'm storing does that make sense

1008
00:19:19,190 --> 00:19:19,200
that i'm storing does that make sense
 

1009
00:19:19,200 --> 00:19:20,549
that i'm storing does that make sense
okay so to

1010
00:19:20,549 --> 00:19:20,559
okay so to
 

1011
00:19:20,559 --> 00:19:23,430
okay so to
instantiate a direct access array of

1012
00:19:23,430 --> 00:19:23,440
instantiate a direct access array of
 

1013
00:19:23,440 --> 00:19:25,430
instantiate a direct access array of
that size i have to allocate that amount

1014
00:19:25,430 --> 00:19:25,440
that size i have to allocate that amount
 

1015
00:19:25,440 --> 00:19:26,789
that size i have to allocate that amount
of space

1016
00:19:26,789 --> 00:19:26,799
of space
 

1017
00:19:26,799 --> 00:19:31,029
of space
and so if that is much bigger than n

1018
00:19:31,029 --> 00:19:31,039
and so if that is much bigger than n
 

1019
00:19:31,039 --> 00:19:33,590
and so if that is much bigger than n
then i'm kind of screwed right because

1020
00:19:33,590 --> 00:19:33,600
then i'm kind of screwed right because
 

1021
00:19:33,600 --> 00:19:35,909
then i'm kind of screwed right because
i'm using much more space

1022
00:19:35,909 --> 00:19:35,919
i'm using much more space
 

1023
00:19:35,919 --> 00:19:38,470
i'm using much more space
and these order operations are bad also

1024
00:19:38,470 --> 00:19:38,480
and these order operations are bad also
 

1025
00:19:38,480 --> 00:19:40,470
and these order operations are bad also
right because essentially

1026
00:19:40,470 --> 00:19:40,480
right because essentially
 

1027
00:19:40,480 --> 00:19:43,669
right because essentially
if i am storing these things

1028
00:19:43,669 --> 00:19:43,679
if i am storing these things
 

1029
00:19:43,679 --> 00:19:46,710
if i am storing these things
uh non-continuously i kind of just have

1030
00:19:46,710 --> 00:19:46,720
uh non-continuously i kind of just have
 

1031
00:19:46,720 --> 00:19:47,750
uh non-continuously i kind of just have
to scan down

1032
00:19:47,750 --> 00:19:47,760
to scan down
 

1033
00:19:47,760 --> 00:19:50,070
to scan down
the thing to find the next element for

1034
00:19:50,070 --> 00:19:50,080
the thing to find the next element for
 

1035
00:19:50,080 --> 00:19:50,830
the thing to find the next element for
example

1036
00:19:50,830 --> 00:19:50,840
example
 

1037
00:19:50,840 --> 00:19:56,789
example
right okay what's your question

1038
00:19:56,789 --> 00:19:56,799

 

1039
00:19:56,799 --> 00:19:59,110

a direct access array is a set data

1040
00:19:59,110 --> 00:19:59,120
a direct access array is a set data
 

1041
00:19:59,120 --> 00:20:00,310
a direct access array is a set data
structure that's why it's a set

1042
00:20:00,310 --> 00:20:00,320
structure that's why it's a set
 

1043
00:20:00,320 --> 00:20:04,470
structure that's why it's a set
interface up there so uh

1044
00:20:04,470 --> 00:20:04,480
interface up there so uh
 

1045
00:20:04,480 --> 00:20:06,710
interface up there so uh
this is uh your colleague is asking

1046
00:20:06,710 --> 00:20:06,720
this is uh your colleague is asking
 

1047
00:20:06,720 --> 00:20:07,510
this is uh your colleague is asking
whether

1048
00:20:07,510 --> 00:20:07,520
whether
 

1049
00:20:07,520 --> 00:20:09,430
whether
you can use a direct access array to

1050
00:20:09,430 --> 00:20:09,440
you can use a direct access array to
 

1051
00:20:09,440 --> 00:20:11,510
you can use a direct access array to
implement a set i mean a sequence

1052
00:20:11,510 --> 00:20:11,520
implement a set i mean a sequence
 

1053
00:20:11,520 --> 00:20:13,750
implement a set i mean a sequence
and actually i think you'll see in your

1054
00:20:13,750 --> 00:20:13,760
and actually i think you'll see in your
 

1055
00:20:13,760 --> 00:20:16,710
and actually i think you'll see in your
recitation notes you have code that

1056
00:20:16,710 --> 00:20:16,720
recitation notes you have code that
 

1057
00:20:16,720 --> 00:20:19,270
recitation notes you have code that
can take a set data structure and

1058
00:20:19,270 --> 00:20:19,280
can take a set data structure and
 

1059
00:20:19,280 --> 00:20:20,950
can take a set data structure and
implement a sequence data structure and

1060
00:20:20,950 --> 00:20:20,960
implement a sequence data structure and
 

1061
00:20:20,960 --> 00:20:22,390
implement a sequence data structure and
take a sequence data structure and

1062
00:20:22,390 --> 00:20:22,400
take a sequence data structure and
 

1063
00:20:22,400 --> 00:20:24,549
take a sequence data structure and
implement a set data structure

1064
00:20:24,549 --> 00:20:24,559
implement a set data structure
 

1065
00:20:24,559 --> 00:20:25,990
implement a set data structure
they just won't necessarily have very

1066
00:20:25,990 --> 00:20:26,000
they just won't necessarily have very
 

1067
00:20:26,000 --> 00:20:28,149
they just won't necessarily have very
good run time so this direct access

1068
00:20:28,149 --> 00:20:28,159
good run time so this direct access
 

1069
00:20:28,159 --> 00:20:29,350
good run time so this direct access
array semantics

1070
00:20:29,350 --> 00:20:29,360
array semantics
 

1071
00:20:29,360 --> 00:20:32,710
array semantics
is really just good good for these

1072
00:20:32,710 --> 00:20:32,720
is really just good good for these
 

1073
00:20:32,720 --> 00:20:34,230
is really just good good for these
specific set operations

1074
00:20:34,230 --> 00:20:34,240
specific set operations
 

1075
00:20:34,240 --> 00:20:37,830
specific set operations
that make sense yeah what you u is this

1076
00:20:37,830 --> 00:20:37,840
that make sense yeah what you u is this
 

1077
00:20:37,840 --> 00:20:39,590
that make sense yeah what you u is this
the size of the largest key that i'm

1078
00:20:39,590 --> 00:20:39,600
the size of the largest key that i'm
 

1079
00:20:39,600 --> 00:20:41,830
the size of the largest key that i'm
allowed to store that makes sense

1080
00:20:41,830 --> 00:20:41,840
allowed to store that makes sense
 

1081
00:20:41,840 --> 00:20:44,230
allowed to store that makes sense
right and the the direct access array is

1082
00:20:44,230 --> 00:20:44,240
right and the the direct access array is
 

1083
00:20:44,240 --> 00:20:45,350
right and the the direct access array is
supporting

1084
00:20:45,350 --> 00:20:45,360
supporting
 

1085
00:20:45,360 --> 00:20:47,830
supporting
you up to you size keys does that make

1086
00:20:47,830 --> 00:20:47,840
you up to you size keys does that make
 

1087
00:20:47,840 --> 00:20:48,789
you up to you size keys does that make
sense

1088
00:20:48,789 --> 00:20:48,799
sense
 

1089
00:20:48,799 --> 00:20:50,789
sense
okay we're going to move on for a second

1090
00:20:50,789 --> 00:20:50,799
okay we're going to move on for a second
 

1091
00:20:50,799 --> 00:20:52,710
okay we're going to move on for a second
so what's that that's the problem right

1092
00:20:52,710 --> 00:20:52,720
so what's that that's the problem right
 

1093
00:20:52,720 --> 00:20:53,029
so what's that that's the problem right
we

1094
00:20:53,029 --> 00:20:53,039
we
 

1095
00:20:53,039 --> 00:20:59,110
we
when you largest

1096
00:20:59,110 --> 00:20:59,120

 

1097
00:20:59,120 --> 00:21:03,190

key we are we're assuming integers here

1098
00:21:03,190 --> 00:21:03,200
key we are we're assuming integers here
 

1099
00:21:03,200 --> 00:21:04,630
key we are we're assuming integers here
right

1100
00:21:04,630 --> 00:21:04,640
right
 

1101
00:21:04,640 --> 00:21:08,549
right
integer keys right so

1102
00:21:08,549 --> 00:21:08,559
integer keys right so
 

1103
00:21:08,559 --> 00:21:11,029
integer keys right so
in the comparison model we could store

1104
00:21:11,029 --> 00:21:11,039
in the comparison model we could store
 

1105
00:21:11,039 --> 00:21:11,990
in the comparison model we could store
any arbitrary

1106
00:21:11,990 --> 00:21:12,000
any arbitrary
 

1107
00:21:12,000 --> 00:21:14,390
any arbitrary
objects that that supported a comparison

1108
00:21:14,390 --> 00:21:14,400
objects that that supported a comparison
 

1109
00:21:14,400 --> 00:21:15,669
objects that that supported a comparison
here

1110
00:21:15,669 --> 00:21:15,679
here
 

1111
00:21:15,679 --> 00:21:17,830
here
we really need to have integer keys or

1112
00:21:17,830 --> 00:21:17,840
we really need to have integer keys or
 

1113
00:21:17,840 --> 00:21:18,789
we really need to have integer keys or
else we're not going to

1114
00:21:18,789 --> 00:21:18,799
else we're not going to
 

1115
00:21:18,799 --> 00:21:21,669
else we're not going to
be able to use those as addresses right

1116
00:21:21,669 --> 00:21:21,679
be able to use those as addresses right
 

1117
00:21:21,679 --> 00:21:22,470
be able to use those as addresses right
so

1118
00:21:22,470 --> 00:21:22,480
so
 

1119
00:21:22,480 --> 00:21:25,190
so
we're making a an assumption on the

1120
00:21:25,190 --> 00:21:25,200
we're making a an assumption on the
 

1121
00:21:25,200 --> 00:21:26,789
we're making a an assumption on the
inputs that i can only store

1122
00:21:26,789 --> 00:21:26,799
inputs that i can only store
 

1123
00:21:26,799 --> 00:21:28,789
inputs that i can only store
integers now i can't store arbitrary

1124
00:21:28,789 --> 00:21:28,799
integers now i can't store arbitrary
 

1125
00:21:28,799 --> 00:21:29,830
integers now i can't store arbitrary
objects

1126
00:21:29,830 --> 00:21:29,840
objects
 

1127
00:21:29,840 --> 00:21:32,950
objects
items with keys and in particular i also

1128
00:21:32,950 --> 00:21:32,960
items with keys and in particular i also
 

1129
00:21:32,960 --> 00:21:33,590
items with keys and in particular i also
need to

1130
00:21:33,590 --> 00:21:33,600
need to
 

1131
00:21:33,600 --> 00:21:35,270
need to
this is a subtlety that's in the word

1132
00:21:35,270 --> 00:21:35,280
this is a subtlety that's in the word
 

1133
00:21:35,280 --> 00:21:36,710
this is a subtlety that's in the word
ram model

1134
00:21:36,710 --> 00:21:36,720
ram model
 

1135
00:21:36,720 --> 00:21:39,750
ram model
how can i be assured that these keys can

1136
00:21:39,750 --> 00:21:39,760
how can i be assured that these keys can
 

1137
00:21:39,760 --> 00:21:43,190
how can i be assured that these keys can
be looked up in constant time

1138
00:21:43,190 --> 00:21:43,200
be looked up in constant time
 

1139
00:21:43,200 --> 00:21:45,750
be looked up in constant time
how does my seat my this little cpu

1140
00:21:45,750 --> 00:21:45,760
how does my seat my this little cpu
 

1141
00:21:45,760 --> 00:21:46,870
how does my seat my this little cpu
right it's got some

1142
00:21:46,870 --> 00:21:46,880
right it's got some
 

1143
00:21:46,880 --> 00:21:49,350
right it's got some
number of registers it can act upon how

1144
00:21:49,350 --> 00:21:49,360
number of registers it can act upon how
 

1145
00:21:49,360 --> 00:21:53,350
number of registers it can act upon how
big is those registers

1146
00:21:53,350 --> 00:21:53,360

 

1147
00:21:53,360 --> 00:21:56,549

what well so they're they're right now

1148
00:21:56,549 --> 00:21:56,559
what well so they're they're right now
 

1149
00:21:56,559 --> 00:21:58,870
what well so they're they're right now
they're 64 bits but in general they're

1150
00:21:58,870 --> 00:21:58,880
they're 64 bits but in general they're
 

1151
00:21:58,880 --> 00:22:02,070
they're 64 bits but in general they're
w they're the size of your word

1152
00:22:02,070 --> 00:22:02,080
w they're the size of your word
 

1153
00:22:02,080 --> 00:22:04,950
w they're the size of your word
on your machine that's how many uh two

1154
00:22:04,950 --> 00:22:04,960
on your machine that's how many uh two
 

1155
00:22:04,960 --> 00:22:06,630
on your machine that's how many uh two
to the w is the number of addresses i

1156
00:22:06,630 --> 00:22:06,640
to the w is the number of addresses i
 

1157
00:22:06,640 --> 00:22:07,430
to the w is the number of addresses i
can access

1158
00:22:07,430 --> 00:22:07,440
can access
 

1159
00:22:07,440 --> 00:22:09,669
can access
so implicitly i'm kind of if i'm going

1160
00:22:09,669 --> 00:22:09,679
so implicitly i'm kind of if i'm going
 

1161
00:22:09,679 --> 00:22:11,270
so implicitly i'm kind of if i'm going
to be able to use this direct access

1162
00:22:11,270 --> 00:22:11,280
to be able to use this direct access
 

1163
00:22:11,280 --> 00:22:11,830
to be able to use this direct access
array

1164
00:22:11,830 --> 00:22:11,840
array
 

1165
00:22:11,840 --> 00:22:14,870
array
i need to make sure that the u is

1166
00:22:14,870 --> 00:22:14,880
i need to make sure that the u is
 

1167
00:22:14,880 --> 00:22:17,990
i need to make sure that the u is
you know less than 2 to the w

1168
00:22:17,990 --> 00:22:18,000
you know less than 2 to the w
 

1169
00:22:18,000 --> 00:22:20,710
you know less than 2 to the w
right if i want these operations to run

1170
00:22:20,710 --> 00:22:20,720
right if i want these operations to run
 

1171
00:22:20,720 --> 00:22:22,070
right if i want these operations to run
in constant time

1172
00:22:22,070 --> 00:22:22,080
in constant time
 

1173
00:22:22,080 --> 00:22:24,310
in constant time
right if i have keys that are much

1174
00:22:24,310 --> 00:22:24,320
right if i have keys that are much
 

1175
00:22:24,320 --> 00:22:25,510
right if i have keys that are much
larger than this

1176
00:22:25,510 --> 00:22:25,520
larger than this
 

1177
00:22:25,520 --> 00:22:27,830
larger than this
i'm going to need to do something else

1178
00:22:27,830 --> 00:22:27,840
i'm going to need to do something else
 

1179
00:22:27,840 --> 00:22:28,630
i'm going to need to do something else
okay

1180
00:22:28,630 --> 00:22:28,640
okay
 

1181
00:22:28,640 --> 00:22:29,909
okay
but this is this is kind of the

1182
00:22:29,909 --> 00:22:29,919
but this is this is kind of the
 

1183
00:22:29,919 --> 00:22:31,669
but this is this is kind of the
assumption in in this class

1184
00:22:31,669 --> 00:22:31,679
assumption in in this class
 

1185
00:22:31,679 --> 00:22:33,350
assumption in in this class
when we give you like an array of

1186
00:22:33,350 --> 00:22:33,360
when we give you like an array of
 

1187
00:22:33,360 --> 00:22:35,110
when we give you like an array of
integers or an array of strings or

1188
00:22:35,110 --> 00:22:35,120
integers or an array of strings or
 

1189
00:22:35,120 --> 00:22:36,549
integers or an array of strings or
something like that on your problem set

1190
00:22:36,549 --> 00:22:36,559
something like that on your problem set
 

1191
00:22:36,559 --> 00:22:37,830
something like that on your problem set
or on an exam

1192
00:22:37,830 --> 00:22:37,840
or on an exam
 

1193
00:22:37,840 --> 00:22:40,070
or on an exam
right the assumption is unless we give

1194
00:22:40,070 --> 00:22:40,080
right the assumption is unless we give
 

1195
00:22:40,080 --> 00:22:41,350
right the assumption is unless we give
you a

1196
00:22:41,350 --> 00:22:41,360
you a
 

1197
00:22:41,360 --> 00:22:45,430
you a
bounds on the size of those things right

1198
00:22:45,430 --> 00:22:45,440
bounds on the size of those things right
 

1199
00:22:45,440 --> 00:22:47,110
bounds on the size of those things right
like the number of characters in your

1200
00:22:47,110 --> 00:22:47,120
like the number of characters in your
 

1201
00:22:47,120 --> 00:22:49,270
like the number of characters in your
string or the size of the number and

1202
00:22:49,270 --> 00:22:49,280
string or the size of the number and
 

1203
00:22:49,280 --> 00:22:50,950
string or the size of the number and
you can assume that those things will

1204
00:22:50,950 --> 00:22:50,960
you can assume that those things will
 

1205
00:22:50,960 --> 00:22:52,549
you can assume that those things will
fit in in

1206
00:22:52,549 --> 00:22:52,559
fit in in
 

1207
00:22:52,559 --> 00:22:58,230
fit in in
one word of memory okay

1208
00:22:58,230 --> 00:22:58,240

 

1209
00:22:58,240 --> 00:23:01,350

w is the word size of your machine right

1210
00:23:01,350 --> 00:23:01,360
w is the word size of your machine right
 

1211
00:23:01,360 --> 00:23:04,950
w is the word size of your machine right
the number of bits that your machine can

1212
00:23:04,950 --> 00:23:04,960
the number of bits that your machine can
 

1213
00:23:04,960 --> 00:23:05,270
the number of bits that your machine can
do

1214
00:23:05,270 --> 00:23:05,280
do
 

1215
00:23:05,280 --> 00:23:08,870
do
operations on in constant time

1216
00:23:08,870 --> 00:23:08,880
operations on in constant time
 

1217
00:23:08,880 --> 00:23:11,430
operations on in constant time
any other questions okay so we have this

1218
00:23:11,430 --> 00:23:11,440
any other questions okay so we have this
 

1219
00:23:11,440 --> 00:23:12,149
any other questions okay so we have this
problem

1220
00:23:12,149 --> 00:23:12,159
problem
 

1221
00:23:12,159 --> 00:23:15,270
problem
we're using way too much space right

1222
00:23:15,270 --> 00:23:15,280
we're using way too much space right
 

1223
00:23:15,280 --> 00:23:20,870
we're using way too much space right
when we have a large universe of keys so

1224
00:23:20,870 --> 00:23:20,880

 

1225
00:23:20,880 --> 00:23:23,510

how do we get around that problem any

1226
00:23:23,510 --> 00:23:23,520
how do we get around that problem any
 

1227
00:23:23,520 --> 00:23:34,830
how do we get around that problem any
ideas

1228
00:23:34,830 --> 00:23:34,840

 

1229
00:23:34,840 --> 00:23:36,070

sure

1230
00:23:36,070 --> 00:23:36,080
sure
 

1231
00:23:36,080 --> 00:23:39,110
sure
okay so what your colleague is saying

1232
00:23:39,110 --> 00:23:39,120
okay so what your colleague is saying
 

1233
00:23:39,120 --> 00:23:41,909
okay so what your colleague is saying
instead of just storing one value at

1234
00:23:41,909 --> 00:23:41,919
instead of just storing one value at
 

1235
00:23:41,919 --> 00:23:43,029
instead of just storing one value at
each place

1236
00:23:43,029 --> 00:23:43,039
each place
 

1237
00:23:43,039 --> 00:23:47,029
each place
maybe store more than one value

1238
00:23:47,029 --> 00:23:47,039

 

1239
00:23:47,039 --> 00:23:50,230

if we're using this uh idea right where

1240
00:23:50,230 --> 00:23:50,240
if we're using this uh idea right where
 

1241
00:23:50,240 --> 00:23:53,190
if we're using this uh idea right where
i am storing my key at the index of the

1242
00:23:53,190 --> 00:23:53,200
i am storing my key at the index of the
 

1243
00:23:53,200 --> 00:23:53,750
i am storing my key at the index of the
key

1244
00:23:53,750 --> 00:23:53,760
key
 

1245
00:23:53,760 --> 00:23:55,750
key
that's getting around the us having to

1246
00:23:55,750 --> 00:23:55,760
that's getting around the us having to
 

1247
00:23:55,760 --> 00:23:57,110
that's getting around the us having to
have unique keys

1248
00:23:57,110 --> 00:23:57,120
have unique keys
 

1249
00:23:57,120 --> 00:23:59,190
have unique keys
in our data structure it's not getting

1250
00:23:59,190 --> 00:23:59,200
in our data structure it's not getting
 

1251
00:23:59,200 --> 00:24:00,390
in our data structure it's not getting
around this

1252
00:24:00,390 --> 00:24:00,400
around this
 

1253
00:24:00,400 --> 00:24:04,789
around this
space usage problem does that make sense

1254
00:24:04,789 --> 00:24:04,799
space usage problem does that make sense
 

1255
00:24:04,799 --> 00:24:07,350
space usage problem does that make sense
we will end up storing multiple things

1256
00:24:07,350 --> 00:24:07,360
we will end up storing multiple things
 

1257
00:24:07,360 --> 00:24:08,950
we will end up storing multiple things
at indices

1258
00:24:08,950 --> 00:24:08,960
at indices
 

1259
00:24:08,960 --> 00:24:11,269
at indices
but there's an another trick that i'm

1260
00:24:11,269 --> 00:24:11,279
but there's an another trick that i'm
 

1261
00:24:11,279 --> 00:24:12,789
but there's an another trick that i'm
looking for right now

1262
00:24:12,789 --> 00:24:12,799
looking for right now
 

1263
00:24:12,799 --> 00:24:15,830
looking for right now
right we have a lot of space that we

1264
00:24:15,830 --> 00:24:15,840
right we have a lot of space that we
 

1265
00:24:15,840 --> 00:24:18,310
right we have a lot of space that we
would need to allocate for this data

1266
00:24:18,310 --> 00:24:18,320
would need to allocate for this data
 

1267
00:24:18,320 --> 00:24:19,510
would need to allocate for this data
structure

1268
00:24:19,510 --> 00:24:19,520
structure
 

1269
00:24:19,520 --> 00:24:22,710
structure
what's an alternative

1270
00:24:22,710 --> 00:24:22,720

 

1271
00:24:22,720 --> 00:24:24,710

instead of allocating a lot of space we

1272
00:24:24,710 --> 00:24:24,720
instead of allocating a lot of space we
 

1273
00:24:24,720 --> 00:24:28,390
instead of allocating a lot of space we
allocate

1274
00:24:28,390 --> 00:24:28,400

 

1275
00:24:28,400 --> 00:24:31,350

less space right let's allocate less

1276
00:24:31,350 --> 00:24:31,360
less space right let's allocate less
 

1277
00:24:31,360 --> 00:24:32,630
less space right let's allocate less
space all right so

1278
00:24:32,630 --> 00:24:32,640
space all right so
 

1279
00:24:32,640 --> 00:24:36,070
space all right so
we have a really like

1280
00:24:36,070 --> 00:24:36,080
we have a really like
 

1281
00:24:36,080 --> 00:24:38,789
we have a really like
this is our space of keys right you

1282
00:24:38,789 --> 00:24:38,799
this is our space of keys right you
 

1283
00:24:38,799 --> 00:24:40,789
this is our space of keys right you
right

1284
00:24:40,789 --> 00:24:40,799
right
 

1285
00:24:40,799 --> 00:24:45,669
right
but instead i want to store those things

1286
00:24:45,669 --> 00:24:45,679
but instead i want to store those things
 

1287
00:24:45,679 --> 00:24:49,110
but instead i want to store those things
in a direct access array of maybe size

1288
00:24:49,110 --> 00:24:49,120
in a direct access array of maybe size
 

1289
00:24:49,120 --> 00:24:52,870
in a direct access array of maybe size
n right something like

1290
00:24:52,870 --> 00:24:52,880
n right something like
 

1291
00:24:52,880 --> 00:24:54,310
n right something like
the order of the things that i'm going

1292
00:24:54,310 --> 00:24:54,320
the order of the things that i'm going
 

1293
00:24:54,320 --> 00:24:56,149
the order of the things that i'm going
to be storing i'm going to relax that

1294
00:24:56,149 --> 00:24:56,159
to be storing i'm going to relax that
 

1295
00:24:56,159 --> 00:24:57,110
to be storing i'm going to relax that
and say

1296
00:24:57,110 --> 00:24:57,120
and say
 

1297
00:24:57,120 --> 00:24:59,510
and say
we're going to make this a length m

1298
00:24:59,510 --> 00:24:59,520
we're going to make this a length m
 

1299
00:24:59,520 --> 00:25:00,710
we're going to make this a length m
that's

1300
00:25:00,710 --> 00:25:00,720
that's
 

1301
00:25:00,720 --> 00:25:04,390
that's
you know around the size of the things

1302
00:25:04,390 --> 00:25:04,400
you know around the size of the things
 

1303
00:25:04,400 --> 00:25:05,110
you know around the size of the things
i'm storing

1304
00:25:05,110 --> 00:25:05,120
i'm storing
 

1305
00:25:05,120 --> 00:25:09,029
i'm storing
okay and what i'm going to do is i'm

1306
00:25:09,029 --> 00:25:09,039
okay and what i'm going to do is i'm
 

1307
00:25:09,039 --> 00:25:11,990
okay and what i'm going to do is i'm
going to try to map this space of keys

1308
00:25:11,990 --> 00:25:12,000
going to try to map this space of keys
 

1309
00:25:12,000 --> 00:25:15,029
going to try to map this space of keys
this large space of keys from like zero

1310
00:25:15,029 --> 00:25:15,039
this large space of keys from like zero
 

1311
00:25:15,039 --> 00:25:17,029
this large space of keys from like zero
to u minus one or something like that

1312
00:25:17,029 --> 00:25:17,039
to u minus one or something like that
 

1313
00:25:17,039 --> 00:25:20,310
to u minus one or something like that
right down to a range that's

1314
00:25:20,310 --> 00:25:20,320
right down to a range that's
 

1315
00:25:20,320 --> 00:25:24,149
right down to a range that's
zero to m minus one okay

1316
00:25:24,149 --> 00:25:24,159
zero to m minus one okay
 

1317
00:25:24,159 --> 00:25:26,950
zero to m minus one okay
right i'm gonna want a function this is

1318
00:25:26,950 --> 00:25:26,960
right i'm gonna want a function this is
 

1319
00:25:26,960 --> 00:25:28,950
right i'm gonna want a function this is
what i'm going to call h

1320
00:25:28,950 --> 00:25:28,960
what i'm going to call h
 

1321
00:25:28,960 --> 00:25:33,190
what i'm going to call h
which maps

1322
00:25:33,190 --> 00:25:33,200

 

1323
00:25:33,200 --> 00:25:40,470

this range down to a smaller range

1324
00:25:40,470 --> 00:25:40,480

 

1325
00:25:40,480 --> 00:25:42,390

does that make sense i'm gonna have some

1326
00:25:42,390 --> 00:25:42,400
does that make sense i'm gonna have some
 

1327
00:25:42,400 --> 00:25:44,310
does that make sense i'm gonna have some
function that takes that large space of

1328
00:25:44,310 --> 00:25:44,320
function that takes that large space of
 

1329
00:25:44,320 --> 00:25:44,870
function that takes that large space of
keys

1330
00:25:44,870 --> 00:25:44,880
keys
 

1331
00:25:44,880 --> 00:25:48,630
keys
sticks them down here okay

1332
00:25:48,630 --> 00:25:48,640
sticks them down here okay
 

1333
00:25:48,640 --> 00:25:53,350
sticks them down here okay
and instead of storing at an index

1334
00:25:53,350 --> 00:25:53,360
and instead of storing at an index
 

1335
00:25:53,360 --> 00:25:56,149
and instead of storing at an index
of the key i'm going to put the key

1336
00:25:56,149 --> 00:25:56,159
of the key i'm going to put the key
 

1337
00:25:56,159 --> 00:25:57,669
of the key i'm going to put the key
through this function

1338
00:25:57,669 --> 00:25:57,679
through this function
 

1339
00:25:57,679 --> 00:26:01,830
through this function
the key space into a compressed space

1340
00:26:01,830 --> 00:26:01,840
the key space into a compressed space
 

1341
00:26:01,840 --> 00:26:05,029
the key space into a compressed space
and store it at that index location

1342
00:26:05,029 --> 00:26:05,039
and store it at that index location
 

1343
00:26:05,039 --> 00:26:09,750
and store it at that index location
does that make sense sure

1344
00:26:09,750 --> 00:26:09,760

 

1345
00:26:09,760 --> 00:26:12,710

oh your colleague is comes comes up with

1346
00:26:12,710 --> 00:26:12,720
oh your colleague is comes comes up with
 

1347
00:26:12,720 --> 00:26:13,110
oh your colleague is comes comes up with
the

1348
00:26:13,110 --> 00:26:13,120
the
 

1349
00:26:13,120 --> 00:26:15,029
the
the question i was going to ask right

1350
00:26:15,029 --> 00:26:15,039
the question i was going to ask right
 

1351
00:26:15,039 --> 00:26:16,390
the question i was going to ask right
away which was

1352
00:26:16,390 --> 00:26:16,400
away which was
 

1353
00:26:16,400 --> 00:26:18,470
away which was
what's the problem here the problem is

1354
00:26:18,470 --> 00:26:18,480
what's the problem here the problem is
 

1355
00:26:18,480 --> 00:26:19,750
what's the problem here the problem is
it's the potential

1356
00:26:19,750 --> 00:26:19,760
it's the potential
 

1357
00:26:19,760 --> 00:26:21,990
it's the potential
that we might be story have to store

1358
00:26:21,990 --> 00:26:22,000
that we might be story have to store
 

1359
00:26:22,000 --> 00:26:24,710
that we might be story have to store
more than one thing

1360
00:26:24,710 --> 00:26:24,720
more than one thing
 

1361
00:26:24,720 --> 00:26:27,830
more than one thing
at the same index location right

1362
00:26:27,830 --> 00:26:27,840
at the same index location right
 

1363
00:26:27,840 --> 00:26:29,750
at the same index location right
if i have a function that matches this

1364
00:26:29,750 --> 00:26:29,760
if i have a function that matches this
 

1365
00:26:29,760 --> 00:26:31,110
if i have a function that matches this
big space

1366
00:26:31,110 --> 00:26:31,120
big space
 

1367
00:26:31,120 --> 00:26:35,510
big space
down to this small space

1368
00:26:35,510 --> 00:26:35,520

 

1369
00:26:35,520 --> 00:26:37,750

i gotta have multiple of these things

1370
00:26:37,750 --> 00:26:37,760
i gotta have multiple of these things
 

1371
00:26:37,760 --> 00:26:39,830
i gotta have multiple of these things
going to the same places here right it's

1372
00:26:39,830 --> 00:26:39,840
going to the same places here right it's
 

1373
00:26:39,840 --> 00:26:40,390
going to the same places here right it's
got a

1374
00:26:40,390 --> 00:26:40,400
got a
 

1375
00:26:40,400 --> 00:26:44,070
got a
it can't be injective right

1376
00:26:44,070 --> 00:26:44,080
it can't be injective right
 

1377
00:26:44,080 --> 00:26:45,830
it can't be injective right
but just based on pigeonhole principle i

1378
00:26:45,830 --> 00:26:45,840
but just based on pigeonhole principle i
 

1379
00:26:45,840 --> 00:26:47,430
but just based on pigeonhole principle i
have more of these things

1380
00:26:47,430 --> 00:26:47,440
have more of these things
 

1381
00:26:47,440 --> 00:26:49,110
have more of these things
at least two of them have to go to

1382
00:26:49,110 --> 00:26:49,120
at least two of them have to go to
 

1383
00:26:49,120 --> 00:26:50,549
at least two of them have to go to
something over here in fact

1384
00:26:50,549 --> 00:26:50,559
something over here in fact
 

1385
00:26:50,559 --> 00:26:54,789
something over here in fact
if i have say u is bigger than n squared

1386
00:26:54,789 --> 00:26:54,799
if i have say u is bigger than n squared
 

1387
00:26:54,799 --> 00:26:55,750
if i have say u is bigger than n squared
for example

1388
00:26:55,750 --> 00:26:55,760
for example
 

1389
00:26:55,760 --> 00:26:59,750
for example
right there for any function i give you

1390
00:26:59,750 --> 00:26:59,760
right there for any function i give you
 

1391
00:26:59,760 --> 00:27:01,510
right there for any function i give you
that maps this large space down to the

1392
00:27:01,510 --> 00:27:01,520
that maps this large space down to the
 

1393
00:27:01,520 --> 00:27:03,110
that maps this large space down to the
small space

1394
00:27:03,110 --> 00:27:03,120
small space
 

1395
00:27:03,120 --> 00:27:06,070
small space
n of these things will map to the same

1396
00:27:06,070 --> 00:27:06,080
n of these things will map to the same
 

1397
00:27:06,080 --> 00:27:07,430
n of these things will map to the same
place

1398
00:27:07,430 --> 00:27:07,440
place
 

1399
00:27:07,440 --> 00:27:11,669
place
right so if i choose a bad function here

1400
00:27:11,669 --> 00:27:11,679
right so if i choose a bad function here
 

1401
00:27:11,679 --> 00:27:14,710
right so if i choose a bad function here
then i'll have to store n things at the

1402
00:27:14,710 --> 00:27:14,720
then i'll have to store n things at the
 

1403
00:27:14,720 --> 00:27:17,190
then i'll have to store n things at the
same index location and if i go there

1404
00:27:17,190 --> 00:27:17,200
same index location and if i go there
 

1405
00:27:17,200 --> 00:27:20,310
same index location and if i go there
i have to kind of check to see whether

1406
00:27:20,310 --> 00:27:20,320
i have to kind of check to see whether
 

1407
00:27:20,320 --> 00:27:21,510
i have to kind of check to see whether
any of those are the things that i'm

1408
00:27:21,510 --> 00:27:21,520
any of those are the things that i'm
 

1409
00:27:21,520 --> 00:27:22,870
any of those are the things that i'm
looking for i haven't gained anything

1410
00:27:22,870 --> 00:27:22,880
looking for i haven't gained anything
 

1411
00:27:22,880 --> 00:27:25,190
looking for i haven't gained anything
right i really want a hash function that

1412
00:27:25,190 --> 00:27:25,200
right i really want a hash function that
 

1413
00:27:25,200 --> 00:27:27,110
right i really want a hash function that
will evenly distribute

1414
00:27:27,110 --> 00:27:27,120
will evenly distribute
 

1415
00:27:27,120 --> 00:27:30,549
will evenly distribute
keys over this space

1416
00:27:30,549 --> 00:27:30,559
keys over this space
 

1417
00:27:30,559 --> 00:27:34,149
keys over this space
right does that make sense

1418
00:27:34,149 --> 00:27:34,159
right does that make sense
 

1419
00:27:34,159 --> 00:27:36,549
right does that make sense
but we have a problem here if we need to

1420
00:27:36,549 --> 00:27:36,559
but we have a problem here if we need to
 

1421
00:27:36,559 --> 00:27:37,909
but we have a problem here if we need to
store multiple things

1422
00:27:37,909 --> 00:27:37,919
store multiple things
 

1423
00:27:37,919 --> 00:27:41,510
store multiple things
at a given location in memory

1424
00:27:41,510 --> 00:27:41,520
at a given location in memory
 

1425
00:27:41,520 --> 00:27:43,510
at a given location in memory
can't do that i have one thing i can put

1426
00:27:43,510 --> 00:27:43,520
can't do that i have one thing i can put
 

1427
00:27:43,520 --> 00:27:44,870
can't do that i have one thing i can put
there so i have two

1428
00:27:44,870 --> 00:27:44,880
there so i have two
 

1429
00:27:44,880 --> 00:27:47,190
there so i have two
options on how to deal what what i call

1430
00:27:47,190 --> 00:27:47,200
options on how to deal what what i call
 

1431
00:27:47,200 --> 00:27:48,549
options on how to deal what what i call
collisions

1432
00:27:48,549 --> 00:27:48,559
collisions
 

1433
00:27:48,559 --> 00:27:51,830
collisions
right if i have two items here like

1434
00:27:51,830 --> 00:27:51,840
right if i have two items here like
 

1435
00:27:51,840 --> 00:27:55,029
right if i have two items here like
a and b these are different keys right

1436
00:27:55,029 --> 00:27:55,039
a and b these are different keys right
 

1437
00:27:55,039 --> 00:27:55,990
a and b these are different keys right
in my

1438
00:27:55,990 --> 00:27:56,000
in my
 

1439
00:27:56,000 --> 00:28:00,549
in my
universe of space but it's possible

1440
00:28:00,549 --> 00:28:00,559
universe of space but it's possible
 

1441
00:28:00,559 --> 00:28:03,990
universe of space but it's possible
that they both map down to some

1442
00:28:03,990 --> 00:28:04,000
that they both map down to some
 

1443
00:28:04,000 --> 00:28:08,070
that they both map down to some
hash that has the same value

1444
00:28:08,070 --> 00:28:08,080
hash that has the same value
 

1445
00:28:08,080 --> 00:28:11,990
hash that has the same value
right so where do i if i if i first hash

1446
00:28:11,990 --> 00:28:12,000
right so where do i if i if i first hash
 

1447
00:28:12,000 --> 00:28:16,310
right so where do i if i if i first hash
a and a is i put put a there

1448
00:28:16,310 --> 00:28:16,320
a and a is i put put a there
 

1449
00:28:16,320 --> 00:28:21,990
a and a is i put put a there
where do i put b

1450
00:28:21,990 --> 00:28:22,000

 

1451
00:28:22,000 --> 00:28:25,510

there are kind of two options um

1452
00:28:25,510 --> 00:28:25,520
there are kind of two options um
 

1453
00:28:25,520 --> 00:28:28,470
there are kind of two options um
is the second data structure a linked

1454
00:28:28,470 --> 00:28:28,480
is the second data structure a linked
 

1455
00:28:28,480 --> 00:28:29,590
is the second data structure a linked
list so that

1456
00:28:29,590 --> 00:28:29,600
list so that
 

1457
00:28:29,600 --> 00:28:32,470
list so that
um it can store me okay so what your

1458
00:28:32,470 --> 00:28:32,480
um it can store me okay so what your
 

1459
00:28:32,480 --> 00:28:34,230
um it can store me okay so what your
colleague was saying

1460
00:28:34,230 --> 00:28:34,240
colleague was saying
 

1461
00:28:34,240 --> 00:28:36,070
colleague was saying
can i store this one as a linked list

1462
00:28:36,070 --> 00:28:36,080
can i store this one as a linked list
 

1463
00:28:36,080 --> 00:28:37,350
can i store this one as a linked list
and then i can just insert

1464
00:28:37,350 --> 00:28:37,360
and then i can just insert
 

1465
00:28:37,360 --> 00:28:40,710
and then i can just insert
a guy right next to where it was

1466
00:28:40,710 --> 00:28:40,720
a guy right next to where it was
 

1467
00:28:40,720 --> 00:28:43,510
a guy right next to where it was
what's the problem there is linked lists

1468
00:28:43,510 --> 00:28:43,520
what's the problem there is linked lists
 

1469
00:28:43,520 --> 00:28:44,950
what's the problem there is linked lists
are linked lists good with

1470
00:28:44,950 --> 00:28:44,960
are linked lists good with
 

1471
00:28:44,960 --> 00:28:48,389
are linked lists good with
direct accessing by an index

1472
00:28:48,389 --> 00:28:48,399
direct accessing by an index
 

1473
00:28:48,399 --> 00:28:50,470
direct accessing by an index
no they're terrible with get at and set

1474
00:28:50,470 --> 00:28:50,480
no they're terrible with get at and set
 

1475
00:28:50,480 --> 00:28:52,470
no they're terrible with get at and set
at right they take linear time there

1476
00:28:52,470 --> 00:28:52,480
at right they take linear time there
 

1477
00:28:52,480 --> 00:28:54,470
at right they take linear time there
right so really the whole point of

1478
00:28:54,470 --> 00:28:54,480
right so really the whole point of
 

1479
00:28:54,480 --> 00:28:56,230
right so really the whole point of
direct access array is that there is an

1480
00:28:56,230 --> 00:28:56,240
direct access array is that there is an
 

1481
00:28:56,240 --> 00:28:57,269
direct access array is that there is an
array underneath

1482
00:28:57,269 --> 00:28:57,279
array underneath
 

1483
00:28:57,279 --> 00:28:59,750
array underneath
and i can do this index from arithmetic

1484
00:28:59,750 --> 00:28:59,760
and i can do this index from arithmetic
 

1485
00:28:59,760 --> 00:29:01,510
and i can do this index from arithmetic
and go down to the next thing

1486
00:29:01,510 --> 00:29:01,520
and go down to the next thing
 

1487
00:29:01,520 --> 00:29:02,950
and go down to the next thing
so i really don't want to replace a

1488
00:29:02,950 --> 00:29:02,960
so i really don't want to replace a
 

1489
00:29:02,960 --> 00:29:07,510
so i really don't want to replace a
linked list as this data structure

1490
00:29:07,510 --> 00:29:07,520
linked list as this data structure
 

1491
00:29:07,520 --> 00:29:13,830
linked list as this data structure
yeah what's up

1492
00:29:13,830 --> 00:29:13,840
yeah what's up
 

1493
00:29:13,840 --> 00:29:17,269
yeah what's up
we can make it really unlikely sure

1494
00:29:17,269 --> 00:29:17,279
we can make it really unlikely sure
 

1495
00:29:17,279 --> 00:29:18,950
we can make it really unlikely sure
i don't know what likely means because

1496
00:29:18,950 --> 00:29:18,960
i don't know what likely means because
 

1497
00:29:18,960 --> 00:29:21,510
i don't know what likely means because
i'm giving you a hash function one hash

1498
00:29:21,510 --> 00:29:21,520
i'm giving you a hash function one hash
 

1499
00:29:21,520 --> 00:29:22,549
i'm giving you a hash function one hash
function

1500
00:29:22,549 --> 00:29:22,559
function
 

1501
00:29:22,559 --> 00:29:24,830
function
and i don't know what the inputs are

1502
00:29:24,830 --> 00:29:24,840
and i don't know what the inputs are
 

1503
00:29:24,840 --> 00:29:31,590
and i don't know what the inputs are
yeah

1504
00:29:31,590 --> 00:29:31,600

 

1505
00:29:31,600 --> 00:29:34,789

okay right so there are actually two

1506
00:29:34,789 --> 00:29:34,799
okay right so there are actually two
 

1507
00:29:34,799 --> 00:29:38,630
okay right so there are actually two
solutions here one is

1508
00:29:38,630 --> 00:29:38,640
solutions here one is
 

1509
00:29:38,640 --> 00:29:41,029
solutions here one is
i i maybe if i choose m to be larger

1510
00:29:41,029 --> 00:29:41,039
i i maybe if i choose m to be larger
 

1511
00:29:41,039 --> 00:29:41,909
i i maybe if i choose m to be larger
than n

1512
00:29:41,909 --> 00:29:41,919
than n
 

1513
00:29:41,919 --> 00:29:43,669
than n
right there's going to be extra space in

1514
00:29:43,669 --> 00:29:43,679
right there's going to be extra space in
 

1515
00:29:43,679 --> 00:29:45,029
right there's going to be extra space in
here

1516
00:29:45,029 --> 00:29:45,039
here
 

1517
00:29:45,039 --> 00:29:46,710
here
i'll just stick it somewhere else in the

1518
00:29:46,710 --> 00:29:46,720
i'll just stick it somewhere else in the
 

1519
00:29:46,720 --> 00:29:48,630
i'll just stick it somewhere else in the
existing array

1520
00:29:48,630 --> 00:29:48,640
existing array
 

1521
00:29:48,640 --> 00:29:51,110
existing array
right how i find an open space is a

1522
00:29:51,110 --> 00:29:51,120
right how i find an open space is a
 

1523
00:29:51,120 --> 00:29:52,470
right how i find an open space is a
little complicated

1524
00:29:52,470 --> 00:29:52,480
little complicated
 

1525
00:29:52,480 --> 00:29:55,669
little complicated
but this is a technique

1526
00:29:55,669 --> 00:29:55,679
but this is a technique
 

1527
00:29:55,679 --> 00:29:58,710
but this is a technique
called open addressing which is much

1528
00:29:58,710 --> 00:29:58,720
called open addressing which is much
 

1529
00:29:58,720 --> 00:30:00,310
called open addressing which is much
more common than the technique we're

1530
00:30:00,310 --> 00:30:00,320
more common than the technique we're
 

1531
00:30:00,320 --> 00:30:02,310
more common than the technique we're
going to be talking about today

1532
00:30:02,310 --> 00:30:02,320
going to be talking about today
 

1533
00:30:02,320 --> 00:30:05,430
going to be talking about today
in implementations python uses an open

1534
00:30:05,430 --> 00:30:05,440
in implementations python uses an open
 

1535
00:30:05,440 --> 00:30:06,549
in implementations python uses an open
addressing scheme

1536
00:30:06,549 --> 00:30:06,559
addressing scheme
 

1537
00:30:06,559 --> 00:30:08,470
addressing scheme
which is essentially find another place

1538
00:30:08,470 --> 00:30:08,480
which is essentially find another place
 

1539
00:30:08,480 --> 00:30:10,389
which is essentially find another place
in the array to to put this

1540
00:30:10,389 --> 00:30:10,399
in the array to to put this
 

1541
00:30:10,399 --> 00:30:13,510
in the array to to put this
collision but it's open addressing is

1542
00:30:13,510 --> 00:30:13,520
collision but it's open addressing is
 

1543
00:30:13,520 --> 00:30:15,269
collision but it's open addressing is
notoriously difficult to analyze so

1544
00:30:15,269 --> 00:30:15,279
notoriously difficult to analyze so
 

1545
00:30:15,279 --> 00:30:16,470
notoriously difficult to analyze so
we're not going to do that in this class

1546
00:30:16,470 --> 00:30:16,480
we're not going to do that in this class
 

1547
00:30:16,480 --> 00:30:18,470
we're not going to do that in this class
there's a much easier technique

1548
00:30:18,470 --> 00:30:18,480
there's a much easier technique
 

1549
00:30:18,480 --> 00:30:20,389
there's a much easier technique
that we have an implementation for you

1550
00:30:20,389 --> 00:30:20,399
that we have an implementation for you
 

1551
00:30:20,399 --> 00:30:23,190
that we have an implementation for you
in the recitation handouts

1552
00:30:23,190 --> 00:30:23,200
in the recitation handouts
 

1553
00:30:23,200 --> 00:30:26,470
in the recitation handouts
it's what your colleague up here i can't

1554
00:30:26,470 --> 00:30:26,480
it's what your colleague up here i can't
 

1555
00:30:26,480 --> 00:30:29,510
it's what your colleague up here i can't
find him over there was saying

1556
00:30:29,510 --> 00:30:29,520
find him over there was saying
 

1557
00:30:29,520 --> 00:30:31,190
find him over there was saying
was instead of storing it somewhere else

1558
00:30:31,190 --> 00:30:31,200
was instead of storing it somewhere else
 

1559
00:30:31,200 --> 00:30:33,830
was instead of storing it somewhere else
in the existing

1560
00:30:33,830 --> 00:30:33,840
in the existing
 

1561
00:30:33,840 --> 00:30:35,909
in the existing
direct access array down here which we

1562
00:30:35,909 --> 00:30:35,919
direct access array down here which we
 

1563
00:30:35,919 --> 00:30:38,230
direct access array down here which we
usually call the hash table

1564
00:30:38,230 --> 00:30:38,240
usually call the hash table
 

1565
00:30:38,240 --> 00:30:42,230
usually call the hash table
right instead of storing it

1566
00:30:42,230 --> 00:30:42,240
right instead of storing it
 

1567
00:30:42,240 --> 00:30:44,630
right instead of storing it
somewhere else in that hash table we'll

1568
00:30:44,630 --> 00:30:44,640
somewhere else in that hash table we'll
 

1569
00:30:44,640 --> 00:30:46,070
somewhere else in that hash table we'll
instead add that key

1570
00:30:46,070 --> 00:30:46,080
instead add that key
 

1571
00:30:46,080 --> 00:30:47,909
instead add that key
store a pointer to another data

1572
00:30:47,909 --> 00:30:47,919
store a pointer to another data
 

1573
00:30:47,919 --> 00:30:49,269
store a pointer to another data
structure

1574
00:30:49,269 --> 00:30:49,279
structure
 

1575
00:30:49,279 --> 00:30:51,750
structure
right some other data structure that can

1576
00:30:51,750 --> 00:30:51,760
right some other data structure that can
 

1577
00:30:51,760 --> 00:30:53,110
right some other data structure that can
store a bunch of things just

1578
00:30:53,110 --> 00:30:53,120
store a bunch of things just
 

1579
00:30:53,120 --> 00:30:54,789
store a bunch of things just
like any sequence data structure like a

1580
00:30:54,789 --> 00:30:54,799
like any sequence data structure like a
 

1581
00:30:54,799 --> 00:30:56,389
like any sequence data structure like a
dynamic array or a linked list or

1582
00:30:56,389 --> 00:30:56,399
dynamic array or a linked list or
 

1583
00:30:56,399 --> 00:30:57,509
dynamic array or a linked list or
anything right

1584
00:30:57,509 --> 00:30:57,519
anything right
 

1585
00:30:57,519 --> 00:30:59,269
anything right
all i need to do is be able to stick a

1586
00:30:59,269 --> 00:30:59,279
all i need to do is be able to stick a
 

1587
00:30:59,279 --> 00:31:01,590
all i need to do is be able to stick a
bunch of things on there

1588
00:31:01,590 --> 00:31:01,600
bunch of things on there
 

1589
00:31:01,600 --> 00:31:03,909
bunch of things on there
uh when there are collisions and then

1590
00:31:03,909 --> 00:31:03,919
uh when there are collisions and then
 

1591
00:31:03,919 --> 00:31:05,750
uh when there are collisions and then
when i go up to look for that thing

1592
00:31:05,750 --> 00:31:05,760
when i go up to look for that thing
 

1593
00:31:05,760 --> 00:31:08,070
when i go up to look for that thing
i'll just look through all of the things

1594
00:31:08,070 --> 00:31:08,080
i'll just look through all of the things
 

1595
00:31:08,080 --> 00:31:08,950
i'll just look through all of the things
in that

1596
00:31:08,950 --> 00:31:08,960
in that
 

1597
00:31:08,960 --> 00:31:11,590
in that
data structure and see if my key exists

1598
00:31:11,590 --> 00:31:11,600
data structure and see if my key exists
 

1599
00:31:11,600 --> 00:31:12,950
data structure and see if my key exists
does that make sense

1600
00:31:12,950 --> 00:31:12,960
does that make sense
 

1601
00:31:12,960 --> 00:31:15,269
does that make sense
now we want to make sure that those

1602
00:31:15,269 --> 00:31:15,279
now we want to make sure that those
 

1603
00:31:15,279 --> 00:31:16,870
now we want to make sure that those
additional data structure

1604
00:31:16,870 --> 00:31:16,880
additional data structure
 

1605
00:31:16,880 --> 00:31:19,669
additional data structure
structures which i'll call chains right

1606
00:31:19,669 --> 00:31:19,679
structures which i'll call chains right
 

1607
00:31:19,679 --> 00:31:22,389
structures which i'll call chains right
we want to make sure that those chains

1608
00:31:22,389 --> 00:31:22,399
we want to make sure that those chains
 

1609
00:31:22,399 --> 00:31:25,110
we want to make sure that those chains
are short right they don't i don't want

1610
00:31:25,110 --> 00:31:25,120
are short right they don't i don't want
 

1611
00:31:25,120 --> 00:31:26,630
are short right they don't i don't want
them to be long

1612
00:31:26,630 --> 00:31:26,640
them to be long
 

1613
00:31:26,640 --> 00:31:28,070
them to be long
right so what i'm going to do is when i

1614
00:31:28,070 --> 00:31:28,080
right so what i'm going to do is when i
 

1615
00:31:28,080 --> 00:31:30,070
right so what i'm going to do is when i
have this collision here instead i'll

1616
00:31:30,070 --> 00:31:30,080
have this collision here instead i'll
 

1617
00:31:30,080 --> 00:31:31,509
have this collision here instead i'll
have a pointer to some

1618
00:31:31,509 --> 00:31:31,519
have a pointer to some
 

1619
00:31:31,519 --> 00:31:33,110
have a pointer to some
i don't know maybe make it a dynamic

1620
00:31:33,110 --> 00:31:33,120
i don't know maybe make it a dynamic
 

1621
00:31:33,120 --> 00:31:34,789
i don't know maybe make it a dynamic
array or a linked list or something like

1622
00:31:34,789 --> 00:31:34,799
array or a linked list or something like
 

1623
00:31:34,799 --> 00:31:35,509
array or a linked list or something like
that

1624
00:31:35,509 --> 00:31:35,519
that
 

1625
00:31:35,519 --> 00:31:38,470
that
and i'll put a here and i'll put b here

1626
00:31:38,470 --> 00:31:38,480
and i'll put a here and i'll put b here
 

1627
00:31:38,480 --> 00:31:39,669
and i'll put a here and i'll put b here
and then later

1628
00:31:39,669 --> 00:31:39,679
and then later
 

1629
00:31:39,679 --> 00:31:44,149
and then later
when i look up key k right

1630
00:31:44,149 --> 00:31:44,159
when i look up key k right
 

1631
00:31:44,159 --> 00:31:47,190
when i look up key k right
or look up key a or b let's look up key

1632
00:31:47,190 --> 00:31:47,200
or look up key a or b let's look up key
 

1633
00:31:47,200 --> 00:31:47,990
or look up key a or b let's look up key
b

1634
00:31:47,990 --> 00:31:48,000
b
 

1635
00:31:48,000 --> 00:31:51,269
b
i'll go to this hashed value here

1636
00:31:51,269 --> 00:31:51,279
i'll go to this hashed value here
 

1637
00:31:51,279 --> 00:31:52,470
i'll go to this hashed value here
i'll put it through the hash function

1638
00:31:52,470 --> 00:31:52,480
i'll put it through the hash function
 

1639
00:31:52,480 --> 00:31:54,630
i'll put it through the hash function
i'll go to this index i'll go to the

1640
00:31:54,630 --> 00:31:54,640
i'll go to this index i'll go to the
 

1641
00:31:54,640 --> 00:31:56,789
i'll go to this index i'll go to the
data structure the chain associated with

1642
00:31:56,789 --> 00:31:56,799
data structure the chain associated with
 

1643
00:31:56,799 --> 00:31:57,830
data structure the chain associated with
that index

1644
00:31:57,830 --> 00:31:57,840
that index
 

1645
00:31:57,840 --> 00:31:59,590
that index
and i'll look at all of these items i'm

1646
00:31:59,590 --> 00:31:59,600
and i'll look at all of these items i'm
 

1647
00:31:59,600 --> 00:32:01,269
and i'll look at all of these items i'm
just going to do a linear find i'm going

1648
00:32:01,269 --> 00:32:01,279
just going to do a linear find i'm going
 

1649
00:32:01,279 --> 00:32:04,389
just going to do a linear find i'm going
to look

1650
00:32:04,389 --> 00:32:04,399

 

1651
00:32:04,399 --> 00:32:05,990

i could put any data structure here but

1652
00:32:05,990 --> 00:32:06,000
i could put any data structure here but
 

1653
00:32:06,000 --> 00:32:07,509
i could put any data structure here but
i'm going to look at this one

1654
00:32:07,509 --> 00:32:07,519
i'm going to look at this one
 

1655
00:32:07,519 --> 00:32:10,310
i'm going to look at this one
see if it's b it's not b look at this

1656
00:32:10,310 --> 00:32:10,320
see if it's b it's not b look at this
 

1657
00:32:10,320 --> 00:32:10,630
see if it's b it's not b look at this
one

1658
00:32:10,630 --> 00:32:10,640
one
 

1659
00:32:10,640 --> 00:32:12,870
one
it is b i return yes does that make

1660
00:32:12,870 --> 00:32:12,880
it is b i return yes does that make
 

1661
00:32:12,880 --> 00:32:15,029
it is b i return yes does that make
sense this is an idea called chaining

1662
00:32:15,029 --> 00:32:15,039
sense this is an idea called chaining
 

1663
00:32:15,039 --> 00:32:17,669
sense this is an idea called chaining
i can put anything i want there commonly

1664
00:32:17,669 --> 00:32:17,679
i can put anything i want there commonly
 

1665
00:32:17,679 --> 00:32:18,789
i can put anything i want there commonly
we talk about

1666
00:32:18,789 --> 00:32:18,799
we talk about
 

1667
00:32:18,799 --> 00:32:20,710
we talk about
putting a linked list there but you can

1668
00:32:20,710 --> 00:32:20,720
putting a linked list there but you can
 

1669
00:32:20,720 --> 00:32:22,230
putting a linked list there but you can
put

1670
00:32:22,230 --> 00:32:22,240
put
 

1671
00:32:22,240 --> 00:32:24,470
put
you know a dynamic array there you can

1672
00:32:24,470 --> 00:32:24,480
you know a dynamic array there you can
 

1673
00:32:24,480 --> 00:32:25,750
you know a dynamic array there you can
put a

1674
00:32:25,750 --> 00:32:25,760
put a
 

1675
00:32:25,760 --> 00:32:27,750
put a
sorted array there to make it easier to

1676
00:32:27,750 --> 00:32:27,760
sorted array there to make it easier to
 

1677
00:32:27,760 --> 00:32:29,029
sorted array there to make it easier to
check whether the key is there

1678
00:32:29,029 --> 00:32:29,039
check whether the key is there
 

1679
00:32:29,039 --> 00:32:30,789
check whether the key is there
you can put anything you want there the

1680
00:32:30,789 --> 00:32:30,799
you can put anything you want there the
 

1681
00:32:30,799 --> 00:32:32,149
you can put anything you want there the
point of this lecture

1682
00:32:32,149 --> 00:32:32,159
point of this lecture
 

1683
00:32:32,159 --> 00:32:34,549
point of this lecture
is going to try to show that there's a

1684
00:32:34,549 --> 00:32:34,559
is going to try to show that there's a
 

1685
00:32:34,559 --> 00:32:36,870
is going to try to show that there's a
choice of hash function i can make

1686
00:32:36,870 --> 00:32:36,880
choice of hash function i can make
 

1687
00:32:36,880 --> 00:32:40,830
choice of hash function i can make
that make sure that these chains are

1688
00:32:40,830 --> 00:32:40,840
that make sure that these chains are
 

1689
00:32:40,840 --> 00:32:41,990
that make sure that these chains are
small

1690
00:32:41,990 --> 00:32:42,000
small
 

1691
00:32:42,000 --> 00:32:43,430
small
that it really doesn't matter how i

1692
00:32:43,430 --> 00:32:43,440
that it really doesn't matter how i
 

1693
00:32:43,440 --> 00:32:45,029
that it really doesn't matter how i
store them there right

1694
00:32:45,029 --> 00:32:45,039
store them there right
 

1695
00:32:45,039 --> 00:32:47,029
store them there right
because i can just i have i have time if

1696
00:32:47,029 --> 00:32:47,039
because i can just i have i have time if
 

1697
00:32:47,039 --> 00:32:48,149
because i can just i have i have time if
there's a constant number of things

1698
00:32:48,149 --> 00:32:48,159
there's a constant number of things
 

1699
00:32:48,159 --> 00:32:48,870
there's a constant number of things
stored there

1700
00:32:48,870 --> 00:32:48,880
stored there
 

1701
00:32:48,880 --> 00:32:50,310
stored there
i can just look at all of them and do

1702
00:32:50,310 --> 00:32:50,320
i can just look at all of them and do
 

1703
00:32:50,320 --> 00:32:52,070
i can just look at all of them and do
whatever i want

1704
00:32:52,070 --> 00:32:52,080
whatever i want
 

1705
00:32:52,080 --> 00:33:01,430
whatever i want
and still get constant time yeah so

1706
00:33:01,430 --> 00:33:01,440

 

1707
00:33:01,440 --> 00:33:04,070

and like let's just say like for some

1708
00:33:04,070 --> 00:33:04,080
and like let's just say like for some
 

1709
00:33:04,080 --> 00:33:06,389
and like let's just say like for some
reason the number of things

1710
00:33:06,389 --> 00:33:06,399
reason the number of things
 

1711
00:33:06,399 --> 00:33:13,509
reason the number of things
is that most of them get like multiple

1712
00:33:13,509 --> 00:33:13,519

 

1713
00:33:13,519 --> 00:33:15,190

yeah so what your your colleague is

1714
00:33:15,190 --> 00:33:15,200
yeah so what your your colleague is
 

1715
00:33:15,200 --> 00:33:17,750
yeah so what your your colleague is
saying is kind of at initialization what

1716
00:33:17,750 --> 00:33:17,760
saying is kind of at initialization what
 

1717
00:33:17,760 --> 00:33:19,110
saying is kind of at initialization what
is stored here

1718
00:33:19,110 --> 00:33:19,120
is stored here
 

1719
00:33:19,120 --> 00:33:21,190
is stored here
right initially it points to an empty

1720
00:33:21,190 --> 00:33:21,200
right initially it points to an empty
 

1721
00:33:21,200 --> 00:33:22,470
right initially it points to an empty
data structure right

1722
00:33:22,470 --> 00:33:22,480
data structure right
 

1723
00:33:22,480 --> 00:33:23,990
data structure right
i'm just going to initialize all of

1724
00:33:23,990 --> 00:33:24,000
i'm just going to initialize all of
 

1725
00:33:24,000 --> 00:33:26,310
i'm just going to initialize all of
these things to have now you get some

1726
00:33:26,310 --> 00:33:26,320
these things to have now you get some
 

1727
00:33:26,320 --> 00:33:27,669
these things to have now you get some
overhead here right we're paying

1728
00:33:27,669 --> 00:33:27,679
overhead here right we're paying
 

1729
00:33:27,679 --> 00:33:29,509
overhead here right we're paying
something for this some extra space in

1730
00:33:29,509 --> 00:33:29,519
something for this some extra space in
 

1731
00:33:29,519 --> 00:33:31,269
something for this some extra space in
having pointer and another data

1732
00:33:31,269 --> 00:33:31,279
having pointer and another data
 

1733
00:33:31,279 --> 00:33:32,630
having pointer and another data
structure at all of these things

1734
00:33:32,630 --> 00:33:32,640
structure at all of these things
 

1735
00:33:32,640 --> 00:33:34,630
structure at all of these things
or you could have the semantics where if

1736
00:33:34,630 --> 00:33:34,640
or you could have the semantics where if
 

1737
00:33:34,640 --> 00:33:36,149
or you could have the semantics where if
i only have one thing here

1738
00:33:36,149 --> 00:33:36,159
i only have one thing here
 

1739
00:33:36,159 --> 00:33:37,990
i only have one thing here
i'm going to store that thing at this

1740
00:33:37,990 --> 00:33:38,000
i'm going to store that thing at this
 

1741
00:33:38,000 --> 00:33:39,830
i'm going to store that thing at this
location but if i have multiple it

1742
00:33:39,830 --> 00:33:39,840
location but if i have multiple it
 

1743
00:33:39,840 --> 00:33:41,110
location but if i have multiple it
points to a data structure

1744
00:33:41,110 --> 00:33:41,120
points to a data structure
 

1745
00:33:41,120 --> 00:33:42,950
points to a data structure
these are kind of complicated you know

1746
00:33:42,950 --> 00:33:42,960
these are kind of complicated you know
 

1747
00:33:42,960 --> 00:33:44,470
these are kind of complicated you know
implementation details but you get the

1748
00:33:44,470 --> 00:33:44,480
implementation details but you get the
 

1749
00:33:44,480 --> 00:33:45,909
implementation details but you get the
basic idea

1750
00:33:45,909 --> 00:33:45,919
basic idea
 

1751
00:33:45,919 --> 00:33:48,789
basic idea
right if i just have a zero size data

1752
00:33:48,789 --> 00:33:48,799
right if i just have a zero size data
 

1753
00:33:48,799 --> 00:33:50,230
right if i just have a zero size data
structure at all of these things

1754
00:33:50,230 --> 00:33:50,240
structure at all of these things
 

1755
00:33:50,240 --> 00:33:52,230
structure at all of these things
i'm still going to have a constant

1756
00:33:52,230 --> 00:33:52,240
i'm still going to have a constant
 

1757
00:33:52,240 --> 00:33:54,070
i'm still going to have a constant
factor overhead

1758
00:33:54,070 --> 00:33:54,080
factor overhead
 

1759
00:33:54,080 --> 00:33:55,830
factor overhead
right it's still going to be a linear

1760
00:33:55,830 --> 00:33:55,840
right it's still going to be a linear
 

1761
00:33:55,840 --> 00:33:57,750
right it's still going to be a linear
size data structure as long as

1762
00:33:57,750 --> 00:33:57,760
size data structure as long as
 

1763
00:33:57,760 --> 00:34:01,590
size data structure as long as
m is linear in n does that make sense

1764
00:34:01,590 --> 00:34:01,600
m is linear in n does that make sense
 

1765
00:34:01,600 --> 00:34:03,669
m is linear in n does that make sense
okay so how do we pick a good hash

1766
00:34:03,669 --> 00:34:03,679
okay so how do we pick a good hash
 

1767
00:34:03,679 --> 00:34:04,950
okay so how do we pick a good hash
function

1768
00:34:04,950 --> 00:34:04,960
function
 

1769
00:34:04,960 --> 00:34:08,550
function
i already told you that any fixed hash

1770
00:34:08,550 --> 00:34:08,560
i already told you that any fixed hash
 

1771
00:34:08,560 --> 00:34:10,230
i already told you that any fixed hash
function i give you

1772
00:34:10,230 --> 00:34:10,240
function i give you
 

1773
00:34:10,240 --> 00:34:12,790
function i give you
is going to experience collisions and if

1774
00:34:12,790 --> 00:34:12,800
is going to experience collisions and if
 

1775
00:34:12,800 --> 00:34:13,510
is going to experience collisions and if
u

1776
00:34:13,510 --> 00:34:13,520
u
 

1777
00:34:13,520 --> 00:34:17,270
u
is large right

1778
00:34:17,270 --> 00:34:17,280
is large right
 

1779
00:34:17,280 --> 00:34:20,550
is large right
then there is the possibility that i for

1780
00:34:20,550 --> 00:34:20,560
then there is the possibility that i for
 

1781
00:34:20,560 --> 00:34:23,589
then there is the possibility that i for
some input all of the things in my set

1782
00:34:23,589 --> 00:34:23,599
some input all of the things in my set
 

1783
00:34:23,599 --> 00:34:24,069
some input all of the things in my set
go

1784
00:34:24,069 --> 00:34:24,079
go
 

1785
00:34:24,079 --> 00:34:27,589
go
directly to the same hashed index value

1786
00:34:27,589 --> 00:34:27,599
directly to the same hashed index value
 

1787
00:34:27,599 --> 00:34:29,589
directly to the same hashed index value
so that ain't great let's ignore that

1788
00:34:29,589 --> 00:34:29,599
so that ain't great let's ignore that
 

1789
00:34:29,599 --> 00:34:32,230
so that ain't great let's ignore that
for a second what's the easiest way

1790
00:34:32,230 --> 00:34:32,240
for a second what's the easiest way
 

1791
00:34:32,240 --> 00:34:34,869
for a second what's the easiest way
to get down from this large space of

1792
00:34:34,869 --> 00:34:34,879
to get down from this large space of
 

1793
00:34:34,879 --> 00:34:36,710
to get down from this large space of
keys down to a small one

1794
00:34:36,710 --> 00:34:36,720
keys down to a small one
 

1795
00:34:36,720 --> 00:34:38,149
keys down to a small one
what's the easiest thing you could do

1796
00:34:38,149 --> 00:34:38,159
what's the easiest thing you could do
 

1797
00:34:38,159 --> 00:34:39,909
what's the easiest thing you could do
yeah modulus

1798
00:34:39,909 --> 00:34:39,919
yeah modulus
 

1799
00:34:39,919 --> 00:34:46,829
yeah modulus
great this is called the division method

1800
00:34:46,829 --> 00:34:46,839

 

1801
00:34:46,839 --> 00:34:51,190

okay

1802
00:34:51,190 --> 00:34:51,200

 

1803
00:34:51,200 --> 00:34:53,349

and what it's the function is is

1804
00:34:53,349 --> 00:34:53,359
and what it's the function is is
 

1805
00:34:53,359 --> 00:34:55,829
and what it's the function is is
essentially it's going to take a key

1806
00:34:55,829 --> 00:34:55,839
essentially it's going to take a key
 

1807
00:34:55,839 --> 00:35:00,829
essentially it's going to take a key
and it's going to set it equal to b k

1808
00:35:00,829 --> 00:35:00,839

 

1809
00:35:00,839 --> 00:35:02,630

mod

1810
00:35:02,630 --> 00:35:02,640
mod
 

1811
00:35:02,640 --> 00:35:05,349
mod
m okay i'm going to take something of a

1812
00:35:05,349 --> 00:35:05,359
m okay i'm going to take something of a
 

1813
00:35:05,359 --> 00:35:06,710
m okay i'm going to take something of a
large space

1814
00:35:06,710 --> 00:35:06,720
large space
 

1815
00:35:06,720 --> 00:35:08,470
large space
i'm going to mod it so that it kind of

1816
00:35:08,470 --> 00:35:08,480
i'm going to mod it so that it kind of
 

1817
00:35:08,480 --> 00:35:10,390
i'm going to mod it so that it kind of
just wraps around

1818
00:35:10,390 --> 00:35:10,400
just wraps around
 

1819
00:35:10,400 --> 00:35:13,430
just wraps around
right

1820
00:35:13,430 --> 00:35:13,440

 

1821
00:35:13,440 --> 00:35:15,750

perfectly valid thing to do it satisfies

1822
00:35:15,750 --> 00:35:15,760
perfectly valid thing to do it satisfies
 

1823
00:35:15,760 --> 00:35:16,710
perfectly valid thing to do it satisfies
what we're

1824
00:35:16,710 --> 00:35:16,720
what we're
 

1825
00:35:16,720 --> 00:35:20,630
what we're
doing in a hash table and if my keys are

1826
00:35:20,630 --> 00:35:20,640
doing in a hash table and if my keys are
 

1827
00:35:20,640 --> 00:35:23,829
doing in a hash table and if my keys are
completely uniformly distributed

1828
00:35:23,829 --> 00:35:23,839
completely uniformly distributed
 

1829
00:35:23,839 --> 00:35:26,150
completely uniformly distributed
ran like if if when i use my hash

1830
00:35:26,150 --> 00:35:26,160
ran like if if when i use my hash
 

1831
00:35:26,160 --> 00:35:27,829
ran like if if when i use my hash
function

1832
00:35:27,829 --> 00:35:27,839
function
 

1833
00:35:27,839 --> 00:35:30,790
function
all of the keys here are uniformly

1834
00:35:30,790 --> 00:35:30,800
all of the keys here are uniformly
 

1835
00:35:30,800 --> 00:35:32,870
all of the keys here are uniformly
distributed over this

1836
00:35:32,870 --> 00:35:32,880
distributed over this
 

1837
00:35:32,880 --> 00:35:35,510
distributed over this
this larger space then actually this

1838
00:35:35,510 --> 00:35:35,520
this larger space then actually this
 

1839
00:35:35,520 --> 00:35:35,990
this larger space then actually this
isn't a

1840
00:35:35,990 --> 00:35:36,000
isn't a
 

1841
00:35:36,000 --> 00:35:38,550
isn't a
such a bad thing right but that's

1842
00:35:38,550 --> 00:35:38,560
such a bad thing right but that's
 

1843
00:35:38,560 --> 00:35:39,270
such a bad thing right but that's
imposing

1844
00:35:39,270 --> 00:35:39,280
imposing
 

1845
00:35:39,280 --> 00:35:42,310
imposing
some kind of distribution requirements

1846
00:35:42,310 --> 00:35:42,320
some kind of distribution requirements
 

1847
00:35:42,320 --> 00:35:43,990
some kind of distribution requirements
on the type of inputs i'm allowed to use

1848
00:35:43,990 --> 00:35:44,000
on the type of inputs i'm allowed to use
 

1849
00:35:44,000 --> 00:35:45,750
on the type of inputs i'm allowed to use
with this hash function for it to be of

1850
00:35:45,750 --> 00:35:45,760
with this hash function for it to be of
 

1851
00:35:45,760 --> 00:35:47,190
with this hash function for it to be of
have good performance

1852
00:35:47,190 --> 00:35:47,200
have good performance
 

1853
00:35:47,200 --> 00:35:51,270
have good performance
right but this plus a little bit of

1854
00:35:51,270 --> 00:35:51,280
right but this plus a little bit of
 

1855
00:35:51,280 --> 00:35:53,190
right but this plus a little bit of
extra you know mixing and bit

1856
00:35:53,190 --> 00:35:53,200
extra you know mixing and bit
 

1857
00:35:53,200 --> 00:35:54,470
extra you know mixing and bit
manipulation

1858
00:35:54,470 --> 00:35:54,480
manipulation
 

1859
00:35:54,480 --> 00:35:57,829
manipulation
is essentially what python does

1860
00:35:57,829 --> 00:35:57,839
is essentially what python does
 

1861
00:35:57,839 --> 00:35:59,990
is essentially what python does
it essentially all it does is kind of

1862
00:35:59,990 --> 00:36:00,000
it essentially all it does is kind of
 

1863
00:36:00,000 --> 00:36:01,910
it essentially all it does is kind of
jumbles up that key

1864
00:36:01,910 --> 00:36:01,920
jumbles up that key
 

1865
00:36:01,920 --> 00:36:05,670
jumbles up that key
for some fixed amount of jumbling

1866
00:36:05,670 --> 00:36:05,680
for some fixed amount of jumbling
 

1867
00:36:05,680 --> 00:36:09,190
for some fixed amount of jumbling
and then mods it m and sticks it there

1868
00:36:09,190 --> 00:36:09,200
and then mods it m and sticks it there
 

1869
00:36:09,200 --> 00:36:12,470
and then mods it m and sticks it there
but there are some it's it's hard-coded

1870
00:36:12,470 --> 00:36:12,480
but there are some it's it's hard-coded
 

1871
00:36:12,480 --> 00:36:13,990
but there are some it's it's hard-coded
in the the python

1872
00:36:13,990 --> 00:36:14,000
in the the python
 

1873
00:36:14,000 --> 00:36:16,390
in the the python
library what this hash function is and

1874
00:36:16,390 --> 00:36:16,400
library what this hash function is and
 

1875
00:36:16,400 --> 00:36:17,990
library what this hash function is and
so there exists

1876
00:36:17,990 --> 00:36:18,000
so there exists
 

1877
00:36:18,000 --> 00:36:21,430
so there exists
some sequences of inserts

1878
00:36:21,430 --> 00:36:21,440
some sequences of inserts
 

1879
00:36:21,440 --> 00:36:24,470
some sequences of inserts
into a hash table in python which

1880
00:36:24,470 --> 00:36:24,480
into a hash table in python which
 

1881
00:36:24,480 --> 00:36:26,150
into a hash table in python which
will be really bad in terms of

1882
00:36:26,150 --> 00:36:26,160
will be really bad in terms of
 

1883
00:36:26,160 --> 00:36:27,510
will be really bad in terms of
performance because these

1884
00:36:27,510 --> 00:36:27,520
performance because these
 

1885
00:36:27,520 --> 00:36:29,190
performance because these
these chain lengths or the amount number

1886
00:36:29,190 --> 00:36:29,200
these chain lengths or the amount number
 

1887
00:36:29,200 --> 00:36:31,030
these chain lengths or the amount number
of collisions that i'll get at a single

1888
00:36:31,030 --> 00:36:31,040
of collisions that i'll get at a single
 

1889
00:36:31,040 --> 00:36:32,630
of collisions that i'll get at a single
hash

1890
00:36:32,630 --> 00:36:32,640
hash
 

1891
00:36:32,640 --> 00:36:35,510
hash
is going to be large right but they do

1892
00:36:35,510 --> 00:36:35,520
is going to be large right but they do
 

1893
00:36:35,520 --> 00:36:37,109
is going to be large right but they do
that for other reasons they want a

1894
00:36:37,109 --> 00:36:37,119
that for other reasons they want a
 

1895
00:36:37,119 --> 00:36:39,030
that for other reasons they want a
deterministic hash function they want

1896
00:36:39,030 --> 00:36:39,040
deterministic hash function they want
 

1897
00:36:39,040 --> 00:36:41,190
deterministic hash function they want
something that i do the program

1898
00:36:41,190 --> 00:36:41,200
something that i do the program
 

1899
00:36:41,200 --> 00:36:42,870
something that i do the program
again it's going to do the same thing

1900
00:36:42,870 --> 00:36:42,880
again it's going to do the same thing
 

1901
00:36:42,880 --> 00:36:44,950
again it's going to do the same thing
underneath right

1902
00:36:44,950 --> 00:36:44,960
underneath right
 

1903
00:36:44,960 --> 00:36:47,510
underneath right
but sometimes python gets it wrong but

1904
00:36:47,510 --> 00:36:47,520
but sometimes python gets it wrong but
 

1905
00:36:47,520 --> 00:36:48,870
but sometimes python gets it wrong but
if your data

1906
00:36:48,870 --> 00:36:48,880
if your data
 

1907
00:36:48,880 --> 00:36:50,990
if your data
that you're storing is sufficiently

1908
00:36:50,990 --> 00:36:51,000
that you're storing is sufficiently
 

1909
00:36:51,000 --> 00:36:53,190
that you're storing is sufficiently
uncorrelated to the hash function that

1910
00:36:53,190 --> 00:36:53,200
uncorrelated to the hash function that
 

1911
00:36:53,200 --> 00:36:54,230
uncorrelated to the hash function that
they've chosen

1912
00:36:54,230 --> 00:36:54,240
they've chosen
 

1913
00:36:54,240 --> 00:36:56,470
they've chosen
which usually it is this is a pretty

1914
00:36:56,470 --> 00:36:56,480
which usually it is this is a pretty
 

1915
00:36:56,480 --> 00:36:57,589
which usually it is this is a pretty
good performance

1916
00:36:57,589 --> 00:36:57,599
good performance
 

1917
00:36:57,599 --> 00:37:01,829
good performance
okay but this is not a uh

1918
00:37:01,829 --> 00:37:01,839
okay but this is not a uh
 

1919
00:37:01,839 --> 00:37:03,910
okay but this is not a uh
practical class well it is a practical

1920
00:37:03,910 --> 00:37:03,920
practical class well it is a practical
 

1921
00:37:03,920 --> 00:37:05,030
practical class well it is a practical
class but

1922
00:37:05,030 --> 00:37:05,040
class but
 

1923
00:37:05,040 --> 00:37:07,670
class but
one of the things that we are uh that's

1924
00:37:07,670 --> 00:37:07,680
one of the things that we are uh that's
 

1925
00:37:07,680 --> 00:37:09,190
one of the things that we are uh that's
the emphasis of this class

1926
00:37:09,190 --> 00:37:09,200
the emphasis of this class
 

1927
00:37:09,200 --> 00:37:10,950
the emphasis of this class
is making sure we can prove that this is

1928
00:37:10,950 --> 00:37:10,960
is making sure we can prove that this is
 

1929
00:37:10,960 --> 00:37:13,030
is making sure we can prove that this is
good in theory as well

1930
00:37:13,030 --> 00:37:13,040
good in theory as well
 

1931
00:37:13,040 --> 00:37:15,190
good in theory as well
right i don't want to know that

1932
00:37:15,190 --> 00:37:15,200
right i don't want to know that
 

1933
00:37:15,200 --> 00:37:17,430
right i don't want to know that
sometimes this will be good

1934
00:37:17,430 --> 00:37:17,440
sometimes this will be good
 

1935
00:37:17,440 --> 00:37:21,270
sometimes this will be good
i really want to know that if i choose

1936
00:37:21,270 --> 00:37:21,280
i really want to know that if i choose
 

1937
00:37:21,280 --> 00:37:24,870
i really want to know that if i choose
if i if i make this data structure and i

1938
00:37:24,870 --> 00:37:24,880
if i if i make this data structure and i
 

1939
00:37:24,880 --> 00:37:28,390
if i if i make this data structure and i
put some inputs on it i want a running

1940
00:37:28,390 --> 00:37:28,400
put some inputs on it i want a running
 

1941
00:37:28,400 --> 00:37:28,870
put some inputs on it i want a running
time

1942
00:37:28,870 --> 00:37:28,880
time
 

1943
00:37:28,880 --> 00:37:31,349
time
that is independent on what inputs i

1944
00:37:31,349 --> 00:37:31,359
that is independent on what inputs i
 

1945
00:37:31,359 --> 00:37:32,630
that is independent on what inputs i
decided to use

1946
00:37:32,630 --> 00:37:32,640
decided to use
 

1947
00:37:32,640 --> 00:37:34,829
decided to use
independent of what keys i decided to

1948
00:37:34,829 --> 00:37:34,839
independent of what keys i decided to
 

1949
00:37:34,839 --> 00:37:37,750
independent of what keys i decided to
store does that make sense

1950
00:37:37,750 --> 00:37:37,760
store does that make sense
 

1951
00:37:37,760 --> 00:37:41,109
store does that make sense
right in some sense i want but it's

1952
00:37:41,109 --> 00:37:41,119
right in some sense i want but it's
 

1953
00:37:41,119 --> 00:37:43,109
right in some sense i want but it's
impossible for me to pick a fixed hash

1954
00:37:43,109 --> 00:37:43,119
impossible for me to pick a fixed hash
 

1955
00:37:43,119 --> 00:37:43,910
impossible for me to pick a fixed hash
function

1956
00:37:43,910 --> 00:37:43,920
function
 

1957
00:37:43,920 --> 00:37:45,430
function
that will achieve this right because i

1958
00:37:45,430 --> 00:37:45,440
that will achieve this right because i
 

1959
00:37:45,440 --> 00:37:47,990
that will achieve this right because i
just told you that if u is large

1960
00:37:47,990 --> 00:37:48,000
just told you that if u is large
 

1961
00:37:48,000 --> 00:37:51,349
just told you that if u is large
right this is if u is large

1962
00:37:51,349 --> 00:37:51,359
right this is if u is large
 

1963
00:37:51,359 --> 00:37:54,069
right this is if u is large
then there exists inputs that map

1964
00:37:54,069 --> 00:37:54,079
then there exists inputs that map
 

1965
00:37:54,079 --> 00:37:56,470
then there exists inputs that map
everything to one place

1966
00:37:56,470 --> 00:37:56,480
everything to one place
 

1967
00:37:56,480 --> 00:37:59,109
everything to one place
so i feel i'm screwed right i can't

1968
00:37:59,109 --> 00:37:59,119
so i feel i'm screwed right i can't
 

1969
00:37:59,119 --> 00:38:02,950
so i feel i'm screwed right i can't
there's no way to solve this problem

1970
00:38:02,950 --> 00:38:02,960

 

1971
00:38:02,960 --> 00:38:04,790

that's true if i want a deterministic

1972
00:38:04,790 --> 00:38:04,800
that's true if i want a deterministic
 

1973
00:38:04,800 --> 00:38:06,069
that's true if i want a deterministic
hash function right

1974
00:38:06,069 --> 00:38:06,079
hash function right
 

1975
00:38:06,079 --> 00:38:07,829
hash function right
i want the thing to be repeatable to do

1976
00:38:07,829 --> 00:38:07,839
i want the thing to be repeatable to do
 

1977
00:38:07,839 --> 00:38:09,670
i want the thing to be repeatable to do
the same thing over and over again

1978
00:38:09,670 --> 00:38:09,680
the same thing over and over again
 

1979
00:38:09,680 --> 00:38:13,030
the same thing over and over again
for any set of inputs what can i do

1980
00:38:13,030 --> 00:38:13,040
for any set of inputs what can i do
 

1981
00:38:13,040 --> 00:38:14,630
for any set of inputs what can i do
instead

1982
00:38:14,630 --> 00:38:14,640
instead
 

1983
00:38:14,640 --> 00:38:16,630
instead
weaken my notion of what constant time

1984
00:38:16,630 --> 00:38:16,640
weaken my notion of what constant time
 

1985
00:38:16,640 --> 00:38:22,230
weaken my notion of what constant time
is to do better

1986
00:38:22,230 --> 00:38:22,240

 

1987
00:38:22,240 --> 00:38:24,230

okay use a non-deterministic what does

1988
00:38:24,230 --> 00:38:24,240
okay use a non-deterministic what does
 

1989
00:38:24,240 --> 00:38:26,069
okay use a non-deterministic what does
not what does non-deterministic mean

1990
00:38:26,069 --> 00:38:26,079
not what does non-deterministic mean
 

1991
00:38:26,079 --> 00:38:26,470
not what does non-deterministic mean
right

1992
00:38:26,470 --> 00:38:26,480
right
 

1993
00:38:26,480 --> 00:38:30,069
right
it means don't choose a hash function

1994
00:38:30,069 --> 00:38:30,079
it means don't choose a hash function
 

1995
00:38:30,079 --> 00:38:33,430
it means don't choose a hash function
up front choose one randomly later

1996
00:38:33,430 --> 00:38:33,440
up front choose one randomly later
 

1997
00:38:33,440 --> 00:38:36,630
up front choose one randomly later
right so have the user they pick

1998
00:38:36,630 --> 00:38:36,640
right so have the user they pick
 

1999
00:38:36,640 --> 00:38:38,310
right so have the user they pick
whatever inputs they're gonna do and

2000
00:38:38,310 --> 00:38:38,320
whatever inputs they're gonna do and
 

2001
00:38:38,320 --> 00:38:40,470
whatever inputs they're gonna do and
then i'm gonna pick a hash function

2002
00:38:40,470 --> 00:38:40,480
then i'm gonna pick a hash function
 

2003
00:38:40,480 --> 00:38:41,829
then i'm gonna pick a hash function
randomly they don't know which hash

2004
00:38:41,829 --> 00:38:41,839
randomly they don't know which hash
 

2005
00:38:41,839 --> 00:38:43,349
randomly they don't know which hash
function i'm gonna pick so it's hard for

2006
00:38:43,349 --> 00:38:43,359
function i'm gonna pick so it's hard for
 

2007
00:38:43,359 --> 00:38:44,230
function i'm gonna pick so it's hard for
them

2008
00:38:44,230 --> 00:38:44,240
them
 

2009
00:38:44,240 --> 00:38:47,349
them
to give me an input that's bad right

2010
00:38:47,349 --> 00:38:47,359
to give me an input that's bad right
 

2011
00:38:47,359 --> 00:38:49,829
to give me an input that's bad right
okay so how do i'm going to choose a

2012
00:38:49,829 --> 00:38:49,839
okay so how do i'm going to choose a
 

2013
00:38:49,839 --> 00:38:51,270
okay so how do i'm going to choose a
random hash function

2014
00:38:51,270 --> 00:38:51,280
random hash function
 

2015
00:38:51,280 --> 00:38:53,430
random hash function
how do i choose a random can i choose a

2016
00:38:53,430 --> 00:38:53,440
how do i choose a random can i choose a
 

2017
00:38:53,440 --> 00:38:54,950
how do i choose a random can i choose a
a hash function from the

2018
00:38:54,950 --> 00:38:54,960
a hash function from the
 

2019
00:38:54,960 --> 00:38:58,390
a hash function from the
space of all hash functions what is the

2020
00:38:58,390 --> 00:38:58,400
space of all hash functions what is the
 

2021
00:38:58,400 --> 00:39:02,630
space of all hash functions what is the
space of all hash functions of this form

2022
00:39:02,630 --> 00:39:02,640

 

2023
00:39:02,640 --> 00:39:05,510

right for every one of these values i

2024
00:39:05,510 --> 00:39:05,520
right for every one of these values i
 

2025
00:39:05,520 --> 00:39:06,790
right for every one of these values i
give a value in here

2026
00:39:06,790 --> 00:39:06,800
give a value in here
 

2027
00:39:06,800 --> 00:39:09,990
give a value in here
right that would be a completely like i

2028
00:39:09,990 --> 00:39:10,000
right that would be a completely like i
 

2029
00:39:10,000 --> 00:39:10,470
right that would be a completely like i
choose

2030
00:39:10,470 --> 00:39:10,480
choose
 

2031
00:39:10,480 --> 00:39:12,069
choose
for each one of these independently

2032
00:39:12,069 --> 00:39:12,079
for each one of these independently
 

2033
00:39:12,079 --> 00:39:14,150
for each one of these independently
random number between this range

2034
00:39:14,150 --> 00:39:14,160
random number between this range
 

2035
00:39:14,160 --> 00:39:19,109
random number between this range
how many such hash functions are there

2036
00:39:19,109 --> 00:39:19,119

 

2037
00:39:19,119 --> 00:39:22,390

m m to the this number

2038
00:39:22,390 --> 00:39:22,400
m m to the this number
 

2039
00:39:22,400 --> 00:39:25,270
m m to the this number
that's a lot of things right so i can't

2040
00:39:25,270 --> 00:39:25,280
that's a lot of things right so i can't
 

2041
00:39:25,280 --> 00:39:26,470
that's a lot of things right so i can't
do that

2042
00:39:26,470 --> 00:39:26,480
do that
 

2043
00:39:26,480 --> 00:39:28,550
do that
what i can do is fix a family of hash

2044
00:39:28,550 --> 00:39:28,560
what i can do is fix a family of hash
 

2045
00:39:28,560 --> 00:39:30,790
what i can do is fix a family of hash
functions where if i choose

2046
00:39:30,790 --> 00:39:30,800
functions where if i choose
 

2047
00:39:30,800 --> 00:39:33,510
functions where if i choose
one from randomly i get good performance

2048
00:39:33,510 --> 00:39:33,520
one from randomly i get good performance
 

2049
00:39:33,520 --> 00:39:35,030
one from randomly i get good performance
and so the hash function i'm going to

2050
00:39:35,030 --> 00:39:35,040
and so the hash function i'm going to
 

2051
00:39:35,040 --> 00:39:36,390
and so the hash function i'm going to
use

2052
00:39:36,390 --> 00:39:36,400
use
 

2053
00:39:36,400 --> 00:39:38,470
use
and we're going to spend the rest of the

2054
00:39:38,470 --> 00:39:38,480
and we're going to spend the rest of the
 

2055
00:39:38,480 --> 00:39:39,510
and we're going to spend the rest of the
time on

2056
00:39:39,510 --> 00:39:39,520
time on
 

2057
00:39:39,520 --> 00:39:42,710
time on
is what i call a universal hash function

2058
00:39:42,710 --> 00:39:42,720
is what i call a universal hash function
 

2059
00:39:42,720 --> 00:39:45,430
is what i call a universal hash function
it has it satisfies what we call a

2060
00:39:45,430 --> 00:39:45,440
it has it satisfies what we call a
 

2061
00:39:45,440 --> 00:39:46,310
it has it satisfies what we call a
universal

2062
00:39:46,310 --> 00:39:46,320
universal
 

2063
00:39:46,320 --> 00:39:51,270
universal
hash property so universal

2064
00:39:51,270 --> 00:39:51,280
hash property so universal
 

2065
00:39:51,280 --> 00:39:54,550
hash property so universal
hash function and

2066
00:39:54,550 --> 00:39:54,560
hash function and
 

2067
00:39:54,560 --> 00:39:56,069
hash function and
this is a little bit of a weird

2068
00:39:56,069 --> 00:39:56,079
this is a little bit of a weird
 

2069
00:39:56,079 --> 00:39:57,750
this is a little bit of a weird
nomenclature because

2070
00:39:57,750 --> 00:39:57,760
nomenclature because
 

2071
00:39:57,760 --> 00:39:59,829
nomenclature because
i'm defining this to you as the

2072
00:39:59,829 --> 00:39:59,839
i'm defining this to you as the
 

2073
00:39:59,839 --> 00:40:01,190
i'm defining this to you as the
universal hash function

2074
00:40:01,190 --> 00:40:01,200
universal hash function
 

2075
00:40:01,200 --> 00:40:04,069
universal hash function
but actually universal is a uh you know

2076
00:40:04,069 --> 00:40:04,079
but actually universal is a uh you know
 

2077
00:40:04,079 --> 00:40:05,349
but actually universal is a uh you know
a descriptor

2078
00:40:05,349 --> 00:40:05,359
a descriptor
 

2079
00:40:05,359 --> 00:40:08,470
a descriptor
right there exists many universal hash

2080
00:40:08,470 --> 00:40:08,480
right there exists many universal hash
 

2081
00:40:08,480 --> 00:40:09,510
right there exists many universal hash
functions

2082
00:40:09,510 --> 00:40:09,520
functions
 

2083
00:40:09,520 --> 00:40:11,190
functions
this just happens to be an example of

2084
00:40:11,190 --> 00:40:11,200
this just happens to be an example of
 

2085
00:40:11,200 --> 00:40:12,870
this just happens to be an example of
one of them okay

2086
00:40:12,870 --> 00:40:12,880
one of them okay
 

2087
00:40:12,880 --> 00:40:16,069
one of them okay
so the hash function uh or

2088
00:40:16,069 --> 00:40:16,079
so the hash function uh or
 

2089
00:40:16,079 --> 00:40:19,750
so the hash function uh or
really

2090
00:40:19,750 --> 00:40:19,760

 

2091
00:40:19,760 --> 00:40:23,349

right so we're gonna

2092
00:40:23,349 --> 00:40:23,359

 

2093
00:40:23,359 --> 00:40:27,670

so here's the hash function

2094
00:40:27,670 --> 00:40:27,680

 

2095
00:40:27,680 --> 00:40:29,670

it doesn't look actually all that

2096
00:40:29,670 --> 00:40:29,680
it doesn't look actually all that
 

2097
00:40:29,680 --> 00:40:32,470
it doesn't look actually all that
different

2098
00:40:32,470 --> 00:40:32,480

 

2099
00:40:32,480 --> 00:40:34,069

goodness gracious how many parentheses

2100
00:40:34,069 --> 00:40:34,079
goodness gracious how many parentheses
 

2101
00:40:34,079 --> 00:40:36,870
goodness gracious how many parentheses
are there

2102
00:40:36,870 --> 00:40:36,880

 

2103
00:40:36,880 --> 00:40:40,470

mod p mod

2104
00:40:40,470 --> 00:40:40,480
mod p mod
 

2105
00:40:40,480 --> 00:40:43,030
mod p mod
m okay so it's kind of doing the same

2106
00:40:43,030 --> 00:40:43,040
m okay so it's kind of doing the same
 

2107
00:40:43,040 --> 00:40:43,750
m okay so it's kind of doing the same
thing

2108
00:40:43,750 --> 00:40:43,760
thing
 

2109
00:40:43,760 --> 00:40:47,109
thing
as what's happening up here right

2110
00:40:47,109 --> 00:40:47,119
as what's happening up here right
 

2111
00:40:47,119 --> 00:40:50,710
as what's happening up here right
but before modding by m i'm

2112
00:40:50,710 --> 00:40:50,720
but before modding by m i'm
 

2113
00:40:50,720 --> 00:40:53,349
but before modding by m i'm
multiplying it by a number i'm adding a

2114
00:40:53,349 --> 00:40:53,359
multiplying it by a number i'm adding a
 

2115
00:40:53,359 --> 00:40:53,910
multiplying it by a number i'm adding a
number

2116
00:40:53,910 --> 00:40:53,920
number
 

2117
00:40:53,920 --> 00:40:55,750
number
i'm taking it mod another number and

2118
00:40:55,750 --> 00:40:55,760
i'm taking it mod another number and
 

2119
00:40:55,760 --> 00:40:57,190
i'm taking it mod another number and
then i'm modding by m

2120
00:40:57,190 --> 00:40:57,200
then i'm modding by m
 

2121
00:40:57,200 --> 00:40:59,190
then i'm modding by m
okay this is a little weird and not only

2122
00:40:59,190 --> 00:40:59,200
okay this is a little weird and not only
 

2123
00:40:59,200 --> 00:41:01,910
okay this is a little weird and not only
that this is still a fixed hash function

2124
00:41:01,910 --> 00:41:01,920
that this is still a fixed hash function
 

2125
00:41:01,920 --> 00:41:04,309
that this is still a fixed hash function
i don't want that i want to generalize

2126
00:41:04,309 --> 00:41:04,319
i don't want that i want to generalize
 

2127
00:41:04,319 --> 00:41:10,390
i don't want that i want to generalize
this to be a family of hash functions

2128
00:41:10,390 --> 00:41:10,400

 

2129
00:41:10,400 --> 00:41:14,150

which are this h a

2130
00:41:14,150 --> 00:41:14,160
which are this h a
 

2131
00:41:14,160 --> 00:41:17,270
which are this h a
b k

2132
00:41:17,270 --> 00:41:17,280

 

2133
00:41:17,280 --> 00:41:20,309

for some random choice

2134
00:41:20,309 --> 00:41:20,319
for some random choice
 

2135
00:41:20,319 --> 00:41:25,270
for some random choice
of a b

2136
00:41:25,270 --> 00:41:25,280

 

2137
00:41:25,280 --> 00:41:29,670

in this larger range

2138
00:41:29,670 --> 00:41:29,680

 

2139
00:41:29,680 --> 00:41:32,790

all right this is a lot of

2140
00:41:32,790 --> 00:41:32,800

 

2141
00:41:32,800 --> 00:41:35,270

notation here essentially what this is

2142
00:41:35,270 --> 00:41:35,280
notation here essentially what this is
 

2143
00:41:35,280 --> 00:41:37,270
notation here essentially what this is
saying is

2144
00:41:37,270 --> 00:41:37,280
saying is
 

2145
00:41:37,280 --> 00:41:40,470
saying is
i have a hash family okay it's

2146
00:41:40,470 --> 00:41:40,480
i have a hash family okay it's
 

2147
00:41:40,480 --> 00:41:42,550
i have a hash family okay it's
parameterized by the length of my hash

2148
00:41:42,550 --> 00:41:42,560
parameterized by the length of my hash
 

2149
00:41:42,560 --> 00:41:43,430
parameterized by the length of my hash
function

2150
00:41:43,430 --> 00:41:43,440
function
 

2151
00:41:43,440 --> 00:41:46,710
function
and some fixed large random prime that's

2152
00:41:46,710 --> 00:41:46,720
and some fixed large random prime that's
 

2153
00:41:46,720 --> 00:41:48,390
and some fixed large random prime that's
bigger than u

2154
00:41:48,390 --> 00:41:48,400
bigger than u
 

2155
00:41:48,400 --> 00:41:50,230
bigger than u
just i'm going to pick some large prime

2156
00:41:50,230 --> 00:41:50,240
just i'm going to pick some large prime
 

2157
00:41:50,240 --> 00:41:51,829
just i'm going to pick some large prime
number

2158
00:41:51,829 --> 00:41:51,839
number
 

2159
00:41:51,839 --> 00:41:54,069
number
okay and that's going to be fixed when i

2160
00:41:54,069 --> 00:41:54,079
okay and that's going to be fixed when i
 

2161
00:41:54,079 --> 00:41:55,030
okay and that's going to be fixed when i
make the hash

2162
00:41:55,030 --> 00:41:55,040
make the hash
 

2163
00:41:55,040 --> 00:41:58,870
make the hash
table okay

2164
00:41:58,870 --> 00:41:58,880

 

2165
00:41:58,880 --> 00:42:01,990

and then when i instantiate the hash

2166
00:42:01,990 --> 00:42:02,000
and then when i instantiate the hash
 

2167
00:42:02,000 --> 00:42:04,309
and then when i instantiate the hash
table i'm going to choose randomly one

2168
00:42:04,309 --> 00:42:04,319
table i'm going to choose randomly one
 

2169
00:42:04,319 --> 00:42:06,230
table i'm going to choose randomly one
of these things

2170
00:42:06,230 --> 00:42:06,240
of these things
 

2171
00:42:06,240 --> 00:42:08,710
of these things
by choosing a random a and a random b

2172
00:42:08,710 --> 00:42:08,720
by choosing a random a and a random b
 

2173
00:42:08,720 --> 00:42:10,230
by choosing a random a and a random b
from this range

2174
00:42:10,230 --> 00:42:10,240
from this range
 

2175
00:42:10,240 --> 00:42:16,390
from this range
does that make sense

2176
00:42:16,390 --> 00:42:16,400
does that make sense
 

2177
00:42:16,400 --> 00:42:19,589
does that make sense
this is a not equal to zero right if i

2178
00:42:19,589 --> 00:42:19,599
this is a not equal to zero right if i
 

2179
00:42:19,599 --> 00:42:20,870
this is a not equal to zero right if i
had zero here

2180
00:42:20,870 --> 00:42:20,880
had zero here
 

2181
00:42:20,880 --> 00:42:22,630
had zero here
i kind of lose the key information and

2182
00:42:22,630 --> 00:42:22,640
i kind of lose the key information and
 

2183
00:42:22,640 --> 00:42:26,710
i kind of lose the key information and
that's no good

2184
00:42:26,710 --> 00:42:26,720

 

2185
00:42:26,720 --> 00:42:28,230

does this make sense so what this is do

2186
00:42:28,230 --> 00:42:28,240
does this make sense so what this is do
 

2187
00:42:28,240 --> 00:42:30,950
does this make sense so what this is do
is multiplying this key by some random

2188
00:42:30,950 --> 00:42:30,960
is multiplying this key by some random
 

2189
00:42:30,960 --> 00:42:31,750
is multiplying this key by some random
number

2190
00:42:31,750 --> 00:42:31,760
number
 

2191
00:42:31,760 --> 00:42:34,710
number
adding some random number modding by

2192
00:42:34,710 --> 00:42:34,720
adding some random number modding by
 

2193
00:42:34,720 --> 00:42:36,950
adding some random number modding by
this prime

2194
00:42:36,950 --> 00:42:36,960
this prime
 

2195
00:42:36,960 --> 00:42:38,950
this prime
and then modding by the size of my thing

2196
00:42:38,950 --> 00:42:38,960
and then modding by the size of my thing
 

2197
00:42:38,960 --> 00:42:41,670
and then modding by the size of my thing
okay so it's doing a bunch of jumbling

2198
00:42:41,670 --> 00:42:41,680
okay so it's doing a bunch of jumbling
 

2199
00:42:41,680 --> 00:42:43,109
okay so it's doing a bunch of jumbling
and there's some randomness involved

2200
00:42:43,109 --> 00:42:43,119
and there's some randomness involved
 

2201
00:42:43,119 --> 00:42:45,109
and there's some randomness involved
here i'm choosing the hash function by

2202
00:42:45,109 --> 00:42:45,119
here i'm choosing the hash function by
 

2203
00:42:45,119 --> 00:42:45,670
here i'm choosing the hash function by
choosing

2204
00:42:45,670 --> 00:42:45,680
choosing
 

2205
00:42:45,680 --> 00:42:48,309
choosing
an a b randomly from this thing so when

2206
00:42:48,309 --> 00:42:48,319
an a b randomly from this thing so when
 

2207
00:42:48,319 --> 00:42:51,750
an a b randomly from this thing so when
i start up my program

2208
00:42:51,750 --> 00:42:51,760
i start up my program
 

2209
00:42:51,760 --> 00:42:54,069
i start up my program
right i'm going to instantiate this

2210
00:42:54,069 --> 00:42:54,079
right i'm going to instantiate this
 

2211
00:42:54,079 --> 00:42:55,349
right i'm going to instantiate this
thing with some random a

2212
00:42:55,349 --> 00:42:55,359
thing with some random a
 

2213
00:42:55,359 --> 00:42:58,390
thing with some random a
and b not deterministically right the

2214
00:42:58,390 --> 00:42:58,400
and b not deterministically right the
 

2215
00:42:58,400 --> 00:43:00,230
and b not deterministically right the
user

2216
00:43:00,230 --> 00:43:00,240
user
 

2217
00:43:00,240 --> 00:43:02,150
user
when they're using this thing doesn't

2218
00:43:02,150 --> 00:43:02,160
when they're using this thing doesn't
 

2219
00:43:02,160 --> 00:43:03,829
when they're using this thing doesn't
know which a and b i picked

2220
00:43:03,829 --> 00:43:03,839
know which a and b i picked
 

2221
00:43:03,839 --> 00:43:05,510
know which a and b i picked
right so it's really hard for them to

2222
00:43:05,510 --> 00:43:05,520
right so it's really hard for them to
 

2223
00:43:05,520 --> 00:43:07,030
right so it's really hard for them to
give me a bad example

2224
00:43:07,030 --> 00:43:07,040
give me a bad example
 

2225
00:43:07,040 --> 00:43:10,870
give me a bad example
right and this universal hash function

2226
00:43:10,870 --> 00:43:10,880
right and this universal hash function
 

2227
00:43:10,880 --> 00:43:13,430
right and this universal hash function
this universal hash family shall we say

2228
00:43:13,430 --> 00:43:13,440
this universal hash family shall we say
 

2229
00:43:13,440 --> 00:43:15,190
this universal hash family shall we say
really this is a family of functions and

2230
00:43:15,190 --> 00:43:15,200
really this is a family of functions and
 

2231
00:43:15,200 --> 00:43:16,390
really this is a family of functions and
i'm choosing one

2232
00:43:16,390 --> 00:43:16,400
i'm choosing one
 

2233
00:43:16,400 --> 00:43:19,990
i'm choosing one
randomly within that family

2234
00:43:19,990 --> 00:43:20,000

 

2235
00:43:20,000 --> 00:43:24,950

is universal and universality

2236
00:43:24,950 --> 00:43:24,960

 

2237
00:43:24,960 --> 00:43:27,430

says that what is it what is the

2238
00:43:27,430 --> 00:43:27,440
says that what is it what is the
 

2239
00:43:27,440 --> 00:43:30,230
says that what is it what is the
property of universality

2240
00:43:30,230 --> 00:43:30,240
property of universality
 

2241
00:43:30,240 --> 00:43:32,870
property of universality
it means that the probability by

2242
00:43:32,870 --> 00:43:32,880
it means that the probability by
 

2243
00:43:32,880 --> 00:43:33,829
it means that the probability by
choosing

2244
00:43:33,829 --> 00:43:33,839
choosing
 

2245
00:43:33,839 --> 00:43:38,829
choosing
a hash function from this hash family

2246
00:43:38,829 --> 00:43:38,839

 

2247
00:43:38,839 --> 00:43:40,230

that

2248
00:43:40,230 --> 00:43:40,240
that
 

2249
00:43:40,240 --> 00:43:43,349
that
a certain key collides

2250
00:43:43,349 --> 00:43:43,359
a certain key collides
 

2251
00:43:43,359 --> 00:43:46,790
a certain key collides
with another key

2252
00:43:46,790 --> 00:43:46,800

 

2253
00:43:46,800 --> 00:43:50,069

is less than or equal to one over m

2254
00:43:50,069 --> 00:43:50,079
is less than or equal to one over m
 

2255
00:43:50,079 --> 00:43:53,270
is less than or equal to one over m
for all any

2256
00:43:53,270 --> 00:43:53,280
for all any
 

2257
00:43:53,280 --> 00:43:56,790
for all any
uh different two keys

2258
00:43:56,790 --> 00:43:56,800
uh different two keys
 

2259
00:43:56,800 --> 00:44:01,990
uh different two keys
in my universe

2260
00:44:01,990 --> 00:44:02,000

 

2261
00:44:02,000 --> 00:44:05,670

does that make sense so if i

2262
00:44:05,670 --> 00:44:05,680
does that make sense so if i
 

2263
00:44:05,680 --> 00:44:07,349
does that make sense so if i
basically this thing has the property

2264
00:44:07,349 --> 00:44:07,359
basically this thing has the property
 

2265
00:44:07,359 --> 00:44:10,069
basically this thing has the property
that if i randomly pick or if i

2266
00:44:10,069 --> 00:44:10,079
that if i randomly pick or if i
 

2267
00:44:10,079 --> 00:44:14,069
that if i randomly pick or if i
for any two keys right that i pick

2268
00:44:14,069 --> 00:44:14,079
for any two keys right that i pick
 

2269
00:44:14,079 --> 00:44:17,670
for any two keys right that i pick
in my universe space if i randomly

2270
00:44:17,670 --> 00:44:17,680
in my universe space if i randomly
 

2271
00:44:17,680 --> 00:44:19,030
in my universe space if i randomly
choose a hash function

2272
00:44:19,030 --> 00:44:19,040
choose a hash function
 

2273
00:44:19,040 --> 00:44:21,109
choose a hash function
the probability that these things

2274
00:44:21,109 --> 00:44:21,119
the probability that these things
 

2275
00:44:21,119 --> 00:44:22,790
the probability that these things
collide is less than

2276
00:44:22,790 --> 00:44:22,800
collide is less than
 

2277
00:44:22,800 --> 00:44:25,430
collide is less than
one over m why is that good this is in

2278
00:44:25,430 --> 00:44:25,440
one over m why is that good this is in
 

2279
00:44:25,440 --> 00:44:26,710
one over m why is that good this is in
some sense a measure

2280
00:44:26,710 --> 00:44:26,720
some sense a measure
 

2281
00:44:26,720 --> 00:44:30,150
some sense a measure
of how well distributed these things are

2282
00:44:30,150 --> 00:44:30,160
of how well distributed these things are
 

2283
00:44:30,160 --> 00:44:33,109
of how well distributed these things are
i want these things to collide with one

2284
00:44:33,109 --> 00:44:33,119
i want these things to collide with one
 

2285
00:44:33,119 --> 00:44:33,510
i want these things to collide with one
over

2286
00:44:33,510 --> 00:44:33,520
over
 

2287
00:44:33,520 --> 00:44:37,190
over
m probability so that these things

2288
00:44:37,190 --> 00:44:37,200
m probability so that these things
 

2289
00:44:37,200 --> 00:44:39,910
m probability so that these things
don't collide very likely it's not very

2290
00:44:39,910 --> 00:44:39,920
don't collide very likely it's not very
 

2291
00:44:39,920 --> 00:44:41,430
don't collide very likely it's not very
likely for these things to collide does

2292
00:44:41,430 --> 00:44:41,440
likely for these things to collide does
 

2293
00:44:41,440 --> 00:44:42,950
likely for these things to collide does
that make sense

2294
00:44:42,950 --> 00:44:42,960
that make sense
 

2295
00:44:42,960 --> 00:44:46,150
that make sense
so we won't prove that this hash family

2296
00:44:46,150 --> 00:44:46,160
so we won't prove that this hash family
 

2297
00:44:46,160 --> 00:44:48,150
so we won't prove that this hash family
satisfies this universality property

2298
00:44:48,150 --> 00:44:48,160
satisfies this universality property
 

2299
00:44:48,160 --> 00:44:50,470
satisfies this universality property
you'll do that no four six but we can

2300
00:44:50,470 --> 00:44:50,480
you'll do that no four six but we can
 

2301
00:44:50,480 --> 00:44:51,589
you'll do that no four six but we can
use

2302
00:44:51,589 --> 00:44:51,599
use
 

2303
00:44:51,599 --> 00:44:55,030
use
this result to show that if we use a

2304
00:44:55,030 --> 00:44:55,040
this result to show that if we use a
 

2305
00:44:55,040 --> 00:44:55,910
this result to show that if we use a
universal ha

2306
00:44:55,910 --> 00:44:55,920
universal ha
 

2307
00:44:55,920 --> 00:44:59,190
universal ha
this universal hash family that

2308
00:44:59,190 --> 00:44:59,200
this universal hash family that
 

2309
00:44:59,200 --> 00:45:02,710
this universal hash family that
the length of our change chains

2310
00:45:02,710 --> 00:45:02,720
the length of our change chains
 

2311
00:45:02,720 --> 00:45:05,829
the length of our change chains
is expected to be constant length

2312
00:45:05,829 --> 00:45:05,839
is expected to be constant length
 

2313
00:45:05,839 --> 00:45:07,670
is expected to be constant length
okay so we're going to use this property

2314
00:45:07,670 --> 00:45:07,680
okay so we're going to use this property
 

2315
00:45:07,680 --> 00:45:09,910
okay so we're going to use this property
to prove that okay

2316
00:45:09,910 --> 00:45:09,920
to prove that okay
 

2317
00:45:09,920 --> 00:45:11,750
to prove that okay
how do we prove that we're going to do a

2318
00:45:11,750 --> 00:45:11,760
how do we prove that we're going to do a
 

2319
00:45:11,760 --> 00:45:13,510
how do we prove that we're going to do a
little probability

2320
00:45:13,510 --> 00:45:13,520
little probability
 

2321
00:45:13,520 --> 00:45:16,630
little probability
okay so how are we going to prove that

2322
00:45:16,630 --> 00:45:16,640
okay so how are we going to prove that
 

2323
00:45:16,640 --> 00:45:19,430
okay so how are we going to prove that
i'm going to define a random variable an

2324
00:45:19,430 --> 00:45:19,440
i'm going to define a random variable an
 

2325
00:45:19,440 --> 00:45:21,109
i'm going to define a random variable an
indicator random variable does anyone

2326
00:45:21,109 --> 00:45:21,119
indicator random variable does anyone
 

2327
00:45:21,119 --> 00:45:22,309
indicator random variable does anyone
remember what an indicator random

2328
00:45:22,309 --> 00:45:22,319
remember what an indicator random
 

2329
00:45:22,319 --> 00:45:23,670
remember what an indicator random
variable is

2330
00:45:23,670 --> 00:45:23,680
variable is
 

2331
00:45:23,680 --> 00:45:26,790
variable is
yeah it's a it's a variable that with

2332
00:45:26,790 --> 00:45:26,800
yeah it's a it's a variable that with
 

2333
00:45:26,800 --> 00:45:27,190
yeah it's a it's a variable that with
some

2334
00:45:27,190 --> 00:45:27,200
some
 

2335
00:45:27,200 --> 00:45:29,430
some
amount of probability is one and one

2336
00:45:29,430 --> 00:45:29,440
amount of probability is one and one
 

2337
00:45:29,440 --> 00:45:31,829
amount of probability is one and one
minus that probability is zero

2338
00:45:31,829 --> 00:45:31,839
minus that probability is zero
 

2339
00:45:31,839 --> 00:45:34,230
minus that probability is zero
right so i'm going to define this

2340
00:45:34,230 --> 00:45:34,240
right so i'm going to define this
 

2341
00:45:34,240 --> 00:45:35,030
right so i'm going to define this
indicator

2342
00:45:35,030 --> 00:45:35,040
indicator
 

2343
00:45:35,040 --> 00:45:39,589
indicator
random variable i x i j

2344
00:45:39,589 --> 00:45:39,599
random variable i x i j
 

2345
00:45:39,599 --> 00:45:44,309
random variable i x i j
is a random variable over my choice

2346
00:45:44,309 --> 00:45:44,319
is a random variable over my choice
 

2347
00:45:44,319 --> 00:45:48,710
is a random variable over my choice
over choice of a hash function

2348
00:45:48,710 --> 00:45:48,720
over choice of a hash function
 

2349
00:45:48,720 --> 00:45:51,190
over choice of a hash function
in my hash family and what does this

2350
00:45:51,190 --> 00:45:51,200
in my hash family and what does this
 

2351
00:45:51,200 --> 00:45:51,910
in my hash family and what does this
mean

2352
00:45:51,910 --> 00:45:51,920
mean
 

2353
00:45:51,920 --> 00:45:55,510
mean
it means x i j equals one

2354
00:45:55,510 --> 00:45:55,520
it means x i j equals one
 

2355
00:45:55,520 --> 00:45:59,030
it means x i j equals one
if hash

2356
00:45:59,030 --> 00:45:59,040
if hash
 

2357
00:45:59,040 --> 00:46:02,150
if hash
ki

2358
00:46:02,150 --> 00:46:02,160

 

2359
00:46:02,160 --> 00:46:06,470

equals hkj these things collide

2360
00:46:06,470 --> 00:46:06,480
equals hkj these things collide
 

2361
00:46:06,480 --> 00:46:12,710
equals hkj these things collide
right and zero otherwise

2362
00:46:12,710 --> 00:46:12,720

 

2363
00:46:12,720 --> 00:46:16,230

okay so i'm choosing randomly over this

2364
00:46:16,230 --> 00:46:16,240
okay so i'm choosing randomly over this
 

2365
00:46:16,240 --> 00:46:18,309
okay so i'm choosing randomly over this
hash family

2366
00:46:18,309 --> 00:46:18,319
hash family
 

2367
00:46:18,319 --> 00:46:21,510
hash family
if for two keys

2368
00:46:21,510 --> 00:46:21,520
if for two keys
 

2369
00:46:21,520 --> 00:46:24,870
if for two keys
i and j key i and key j if these things

2370
00:46:24,870 --> 00:46:24,880
i and j key i and key j if these things
 

2371
00:46:24,880 --> 00:46:26,309
i and j key i and key j if these things
collide

2372
00:46:26,309 --> 00:46:26,319
collide
 

2373
00:46:26,319 --> 00:46:28,630
collide
that's going to be one if they don't

2374
00:46:28,630 --> 00:46:28,640
that's going to be one if they don't
 

2375
00:46:28,640 --> 00:46:29,510
that's going to be one if they don't
then it's zero

2376
00:46:29,510 --> 00:46:29,520
then it's zero
 

2377
00:46:29,520 --> 00:46:33,109
then it's zero
okay then how can we write a formula

2378
00:46:33,109 --> 00:46:33,119
okay then how can we write a formula
 

2379
00:46:33,119 --> 00:46:36,150
okay then how can we write a formula
for the length of a a chain in this

2380
00:46:36,150 --> 00:46:36,160
for the length of a a chain in this
 

2381
00:46:36,160 --> 00:46:40,829
for the length of a a chain in this
model right so the size of a chain

2382
00:46:40,829 --> 00:46:40,839
model right so the size of a chain
 

2383
00:46:40,839 --> 00:46:43,349
model right so the size of a chain
right

2384
00:46:43,349 --> 00:46:43,359
right
 

2385
00:46:43,359 --> 00:46:46,390
right
or let's put it here

2386
00:46:46,390 --> 00:46:46,400
or let's put it here
 

2387
00:46:46,400 --> 00:46:51,589
or let's put it here
the size of the chain

2388
00:46:51,589 --> 00:46:51,599

 

2389
00:46:51,599 --> 00:46:54,950

at i

2390
00:46:54,950 --> 00:46:54,960
at i
 

2391
00:46:54,960 --> 00:46:58,309
at i
right at i in my hash table

2392
00:46:58,309 --> 00:46:58,319
right at i in my hash table
 

2393
00:46:58,319 --> 00:47:01,349
right at i in my hash table
is going to equal i'm going to call that

2394
00:47:01,349 --> 00:47:01,359
is going to equal i'm going to call that
 

2395
00:47:01,359 --> 00:47:02,470
is going to equal i'm going to call that
the random variable x

2396
00:47:02,470 --> 00:47:02,480
the random variable x
 

2397
00:47:02,480 --> 00:47:05,510
the random variable x
i that's going to equal the sum over

2398
00:47:05,510 --> 00:47:05,520
i that's going to equal the sum over
 

2399
00:47:05,520 --> 00:47:09,990
i that's going to equal the sum over
j equals 0 to

2400
00:47:09,990 --> 00:47:10,000
j equals 0 to
 

2401
00:47:10,000 --> 00:47:14,069
j equals 0 to
is it over i think u minus 1

2402
00:47:14,069 --> 00:47:14,079
is it over i think u minus 1
 

2403
00:47:14,079 --> 00:47:17,270
is it over i think u minus 1
of summation or

2404
00:47:17,270 --> 00:47:17,280
of summation or
 

2405
00:47:17,280 --> 00:47:20,549
of summation or
sorry of x i j

2406
00:47:20,549 --> 00:47:20,559
sorry of x i j
 

2407
00:47:20,559 --> 00:47:23,589
sorry of x i j
right so basically if i fix

2408
00:47:23,589 --> 00:47:23,599
right so basically if i fix
 

2409
00:47:23,599 --> 00:47:27,190
right so basically if i fix
this uh this location i

2410
00:47:27,190 --> 00:47:27,200
this uh this location i
 

2411
00:47:27,200 --> 00:47:31,430
this uh this location i
right

2412
00:47:31,430 --> 00:47:31,440

 

2413
00:47:31,440 --> 00:47:34,230

if i fix this location i this is where

2414
00:47:34,230 --> 00:47:34,240
if i fix this location i this is where
 

2415
00:47:34,240 --> 00:47:35,910
if i fix this location i this is where
this key goes

2416
00:47:35,910 --> 00:47:35,920
this key goes
 

2417
00:47:35,920 --> 00:47:39,109
this key goes
right so i'm looking at sorry this is

2418
00:47:39,109 --> 00:47:39,119
right so i'm looking at sorry this is
 

2419
00:47:39,119 --> 00:47:39,910
right so i'm looking at sorry this is
the size of

2420
00:47:39,910 --> 00:47:39,920
the size of
 

2421
00:47:39,920 --> 00:47:43,349
the size of
chain at h of

2422
00:47:43,349 --> 00:47:43,359
chain at h of
 

2423
00:47:43,359 --> 00:47:46,630
chain at h of
k i sorry so i look at wherever

2424
00:47:46,630 --> 00:47:46,640
k i sorry so i look at wherever
 

2425
00:47:46,640 --> 00:47:49,829
k i sorry so i look at wherever
k i goes is hashed right and i see how

2426
00:47:49,829 --> 00:47:49,839
k i goes is hashed right and i see how
 

2427
00:47:49,839 --> 00:47:51,589
k i goes is hashed right and i see how
many things collide with it

2428
00:47:51,589 --> 00:47:51,599
many things collide with it
 

2429
00:47:51,599 --> 00:47:53,190
many things collide with it
right i'm just summing over all of these

2430
00:47:53,190 --> 00:47:53,200
right i'm just summing over all of these
 

2431
00:47:53,200 --> 00:47:54,950
right i'm just summing over all of these
things right

2432
00:47:54,950 --> 00:47:54,960
things right
 

2433
00:47:54,960 --> 00:47:56,630
things right
because this is one if there's a

2434
00:47:56,630 --> 00:47:56,640
because this is one if there's a
 

2435
00:47:56,640 --> 00:47:58,549
because this is one if there's a
collision and zero if there's not

2436
00:47:58,549 --> 00:47:58,559
collision and zero if there's not
 

2437
00:47:58,559 --> 00:48:01,270
collision and zero if there's not
does that make sense so this is the size

2438
00:48:01,270 --> 00:48:01,280
does that make sense so this is the size
 

2439
00:48:01,280 --> 00:48:02,069
does that make sense so this is the size
of the chain

2440
00:48:02,069 --> 00:48:02,079
of the chain
 

2441
00:48:02,079 --> 00:48:05,829
of the chain
at the index location mapped to by

2442
00:48:05,829 --> 00:48:05,839
at the index location mapped to by
 

2443
00:48:05,839 --> 00:48:09,750
at the index location mapped to by
ki okay

2444
00:48:09,750 --> 00:48:09,760
ki okay
 

2445
00:48:09,760 --> 00:48:11,510
ki okay
so here's where your probability comes

2446
00:48:11,510 --> 00:48:11,520
so here's where your probability comes
 

2447
00:48:11,520 --> 00:48:12,870
so here's where your probability comes
in

2448
00:48:12,870 --> 00:48:12,880
in
 

2449
00:48:12,880 --> 00:48:15,030
in
what's the expected value of this chain

2450
00:48:15,030 --> 00:48:15,040
what's the expected value of this chain
 

2451
00:48:15,040 --> 00:48:17,510
what's the expected value of this chain
length over my random choice

2452
00:48:17,510 --> 00:48:17,520
length over my random choice
 

2453
00:48:17,520 --> 00:48:20,950
length over my random choice
okay expected value over choosing

2454
00:48:20,950 --> 00:48:20,960
okay expected value over choosing
 

2455
00:48:20,960 --> 00:48:23,349
okay expected value over choosing
a hash function from this universal hash

2456
00:48:23,349 --> 00:48:23,359
a hash function from this universal hash
 

2457
00:48:23,359 --> 00:48:24,470
a hash function from this universal hash
family

2458
00:48:24,470 --> 00:48:24,480
family
 

2459
00:48:24,480 --> 00:48:28,309
family
of this chain length

2460
00:48:28,309 --> 00:48:28,319

 

2461
00:48:28,319 --> 00:48:30,069

well that's just i can put in my

2462
00:48:30,069 --> 00:48:30,079
well that's just i can put in my
 

2463
00:48:30,079 --> 00:48:31,750
well that's just i can put in my
definition here that's the expected

2464
00:48:31,750 --> 00:48:31,760
definition here that's the expected
 

2465
00:48:31,760 --> 00:48:33,270
definition here that's the expected
value

2466
00:48:33,270 --> 00:48:33,280
value
 

2467
00:48:33,280 --> 00:48:36,390
value
of the summation over

2468
00:48:36,390 --> 00:48:36,400
of the summation over
 

2469
00:48:36,400 --> 00:48:45,510
of the summation over
j of x i j

2470
00:48:45,510 --> 00:48:45,520

 

2471
00:48:45,520 --> 00:48:48,870

what do i know about expectations and

2472
00:48:48,870 --> 00:48:48,880
what do i know about expectations and
 

2473
00:48:48,880 --> 00:48:53,109
what do i know about expectations and
summations

2474
00:48:53,109 --> 00:48:53,119

 

2475
00:48:53,119 --> 00:48:55,270

if these variables are independent from

2476
00:48:55,270 --> 00:48:55,280
if these variables are independent from
 

2477
00:48:55,280 --> 00:48:58,710
if these variables are independent from
each other

2478
00:48:58,710 --> 00:48:58,720

 

2479
00:48:58,720 --> 00:49:02,870

say say what

2480
00:49:02,870 --> 00:49:02,880
say say what
 

2481
00:49:02,880 --> 00:49:05,910
say say what
linearity of expectation right basically

2482
00:49:05,910 --> 00:49:05,920
linearity of expectation right basically
 

2483
00:49:05,920 --> 00:49:06,390
linearity of expectation right basically
the

2484
00:49:06,390 --> 00:49:06,400
the
 

2485
00:49:06,400 --> 00:49:07,829
the
expectation of the sum of these

2486
00:49:07,829 --> 00:49:07,839
expectation of the sum of these
 

2487
00:49:07,839 --> 00:49:09,430
expectation of the sum of these
independent random variables is the same

2488
00:49:09,430 --> 00:49:09,440
independent random variables is the same
 

2489
00:49:09,440 --> 00:49:11,910
independent random variables is the same
as the summation of their expectations

2490
00:49:11,910 --> 00:49:11,920
as the summation of their expectations
 

2491
00:49:11,920 --> 00:49:14,630
as the summation of their expectations
right so this is equal to the summation

2492
00:49:14,630 --> 00:49:14,640
right so this is equal to the summation
 

2493
00:49:14,640 --> 00:49:15,030
right so this is equal to the summation
over

2494
00:49:15,030 --> 00:49:15,040
over
 

2495
00:49:15,040 --> 00:49:17,670
over
j of the expectations of these

2496
00:49:17,670 --> 00:49:17,680
j of the expectations of these
 

2497
00:49:17,680 --> 00:49:20,150
j of the expectations of these
individual ones

2498
00:49:20,150 --> 00:49:20,160
individual ones
 

2499
00:49:20,160 --> 00:49:26,790
individual ones
okay

2500
00:49:26,790 --> 00:49:26,800

 

2501
00:49:26,800 --> 00:49:31,190

one of these j's is the same as i

2502
00:49:31,190 --> 00:49:31,200
one of these j's is the same as i
 

2503
00:49:31,200 --> 00:49:34,549
one of these j's is the same as i
right j j loops over all of the things

2504
00:49:34,549 --> 00:49:34,559
right j j loops over all of the things
 

2505
00:49:34,559 --> 00:49:35,270
right j j loops over all of the things
from zero

2506
00:49:35,270 --> 00:49:35,280
from zero
 

2507
00:49:35,280 --> 00:49:38,470
from zero
to u minus one right one of them is i

2508
00:49:38,470 --> 00:49:38,480
to u minus one right one of them is i
 

2509
00:49:38,480 --> 00:49:42,069
to u minus one right one of them is i
right so when x h i

2510
00:49:42,069 --> 00:49:42,079
right so when x h i
 

2511
00:49:42,079 --> 00:49:46,230
right so when x h i
is h j what is

2512
00:49:46,230 --> 00:49:46,240
is h j what is
 

2513
00:49:46,240 --> 00:49:47,589
is h j what is
what is the expected value that they

2514
00:49:47,589 --> 00:49:47,599
what is the expected value that they
 

2515
00:49:47,599 --> 00:49:49,349
what is the expected value that they
collide

2516
00:49:49,349 --> 00:49:49,359
collide
 

2517
00:49:49,359 --> 00:49:52,630
collide
one right so i'm going to refactor this

2518
00:49:52,630 --> 00:49:52,640
one right so i'm going to refactor this
 

2519
00:49:52,640 --> 00:49:53,750
one right so i'm going to refactor this
as being

2520
00:49:53,750 --> 00:49:53,760
as being
 

2521
00:49:53,760 --> 00:49:57,349
as being
this where j does not equal i

2522
00:49:57,349 --> 00:49:57,359
this where j does not equal i
 

2523
00:49:57,359 --> 00:50:00,710
this where j does not equal i
plus one are people okay with that

2524
00:50:00,710 --> 00:50:00,720
plus one are people okay with that
 

2525
00:50:00,720 --> 00:50:04,069
plus one are people okay with that
because if i equals

2526
00:50:04,069 --> 00:50:04,079
because if i equals
 

2527
00:50:04,079 --> 00:50:06,790
because if i equals
if if if j and i are equal they

2528
00:50:06,790 --> 00:50:06,800
if if if j and i are equal they
 

2529
00:50:06,800 --> 00:50:08,150
if if if j and i are equal they
definitely collide right they're the

2530
00:50:08,150 --> 00:50:08,160
definitely collide right they're the
 

2531
00:50:08,160 --> 00:50:09,430
definitely collide right they're the
same key

2532
00:50:09,430 --> 00:50:09,440
same key
 

2533
00:50:09,440 --> 00:50:11,910
same key
right so i'm expected to have one guy

2534
00:50:11,910 --> 00:50:11,920
right so i'm expected to have one guy
 

2535
00:50:11,920 --> 00:50:13,270
right so i'm expected to have one guy
there

2536
00:50:13,270 --> 00:50:13,280
there
 

2537
00:50:13,280 --> 00:50:16,549
there
which was the original key x i right

2538
00:50:16,549 --> 00:50:16,559
which was the original key x i right
 

2539
00:50:16,559 --> 00:50:19,990
which was the original key x i right
but otherwise we can use this universal

2540
00:50:19,990 --> 00:50:20,000
but otherwise we can use this universal
 

2541
00:50:20,000 --> 00:50:21,030
but otherwise we can use this universal
property

2542
00:50:21,030 --> 00:50:21,040
property
 

2543
00:50:21,040 --> 00:50:24,829
property
right that says if they're not

2544
00:50:24,829 --> 00:50:24,839
right that says if they're not
 

2545
00:50:24,839 --> 00:50:27,990
right that says if they're not
equal and they collide which is exactly

2546
00:50:27,990 --> 00:50:28,000
equal and they collide which is exactly
 

2547
00:50:28,000 --> 00:50:29,349
equal and they collide which is exactly
this case

2548
00:50:29,349 --> 00:50:29,359
this case
 

2549
00:50:29,359 --> 00:50:32,710
this case
right the probability that that happens

2550
00:50:32,710 --> 00:50:32,720
right the probability that that happens
 

2551
00:50:32,720 --> 00:50:36,790
right the probability that that happens
is 1 over m right and since it's

2552
00:50:36,790 --> 00:50:36,800
is 1 over m right and since it's
 

2553
00:50:36,800 --> 00:50:38,390
is 1 over m right and since it's
an indicator random variable the

2554
00:50:38,390 --> 00:50:38,400
an indicator random variable the
 

2555
00:50:38,400 --> 00:50:40,390
an indicator random variable the
expectation is

2556
00:50:40,390 --> 00:50:40,400
expectation is
 

2557
00:50:40,400 --> 00:50:42,309
expectation is
their outcomes times their probabilities

2558
00:50:42,309 --> 00:50:42,319
their outcomes times their probabilities
 

2559
00:50:42,319 --> 00:50:45,190
their outcomes times their probabilities
right so 1 times that probability

2560
00:50:45,190 --> 00:50:45,200
right so 1 times that probability
 

2561
00:50:45,200 --> 00:50:48,150
right so 1 times that probability
plus 0 times 1 minus that probability

2562
00:50:48,150 --> 00:50:48,160
plus 0 times 1 minus that probability
 

2563
00:50:48,160 --> 00:50:49,190
plus 0 times 1 minus that probability
right which is just

2564
00:50:49,190 --> 00:50:49,200
right which is just
 

2565
00:50:49,200 --> 00:50:54,309
right which is just
1 over m right so now we get

2566
00:50:54,309 --> 00:50:54,319
1 over m right so now we get
 

2567
00:50:54,319 --> 00:50:57,670
1 over m right so now we get
the summation of one over m

2568
00:50:57,670 --> 00:50:57,680
the summation of one over m
 

2569
00:50:57,680 --> 00:51:01,510
the summation of one over m
for j not equal to i

2570
00:51:01,510 --> 00:51:01,520
for j not equal to i
 

2571
00:51:01,520 --> 00:51:08,069
for j not equal to i
plus one

2572
00:51:08,069 --> 00:51:08,079
plus one
 

2573
00:51:08,079 --> 00:51:11,829
plus one
oh and this sorry i did this wrong

2574
00:51:11,829 --> 00:51:11,839
oh and this sorry i did this wrong
 

2575
00:51:11,839 --> 00:51:14,870
oh and this sorry i did this wrong
this isn't u this is n we're storing n

2576
00:51:14,870 --> 00:51:14,880
this isn't u this is n we're storing n
 

2577
00:51:14,880 --> 00:51:18,150
this isn't u this is n we're storing n
keys right okay

2578
00:51:18,150 --> 00:51:18,160
keys right okay
 

2579
00:51:18,160 --> 00:51:21,109
keys right okay
so now i'm looping over j this over all

2580
00:51:21,109 --> 00:51:21,119
so now i'm looping over j this over all
 

2581
00:51:21,119 --> 00:51:21,990
so now i'm looping over j this over all
of those things

2582
00:51:21,990 --> 00:51:22,000
of those things
 

2583
00:51:22,000 --> 00:51:24,150
of those things
how many things are there and minus one

2584
00:51:24,150 --> 00:51:24,160
how many things are there and minus one
 

2585
00:51:24,160 --> 00:51:26,069
how many things are there and minus one
things right

2586
00:51:26,069 --> 00:51:26,079
things right
 

2587
00:51:26,079 --> 00:51:29,510
things right
so this should equal one plus n

2588
00:51:29,510 --> 00:51:29,520
so this should equal one plus n
 

2589
00:51:29,520 --> 00:51:33,670
so this should equal one plus n
minus one over m okay so that's what

2590
00:51:33,670 --> 00:51:33,680
minus one over m okay so that's what
 

2591
00:51:33,680 --> 00:51:36,950
minus one over m okay so that's what
universality gives us so as long as we

2592
00:51:36,950 --> 00:51:36,960
universality gives us so as long as we
 

2593
00:51:36,960 --> 00:51:37,510
universality gives us so as long as we
choose

2594
00:51:37,510 --> 00:51:37,520
choose
 

2595
00:51:37,520 --> 00:51:41,829
choose
m to be like larger than n

2596
00:51:41,829 --> 00:51:41,839
m to be like larger than n
 

2597
00:51:41,839 --> 00:51:44,870
m to be like larger than n
or at least linear in n then we're

2598
00:51:44,870 --> 00:51:44,880
or at least linear in n then we're
 

2599
00:51:44,880 --> 00:51:45,990
or at least linear in n then we're
expected

2600
00:51:45,990 --> 00:51:46,000
expected
 

2601
00:51:46,000 --> 00:51:49,030
expected
to have our chain lengths be constant

2602
00:51:49,030 --> 00:51:49,040
to have our chain lengths be constant
 

2603
00:51:49,040 --> 00:51:52,069
to have our chain lengths be constant
right because this thing becomes a

2604
00:51:52,069 --> 00:51:52,079
right because this thing becomes a
 

2605
00:51:52,079 --> 00:51:52,790
right because this thing becomes a
constant

2606
00:51:52,790 --> 00:51:52,800
constant
 

2607
00:51:52,800 --> 00:51:55,670
constant
if m is at least order n does that make

2608
00:51:55,670 --> 00:51:55,680
if m is at least order n does that make
 

2609
00:51:55,680 --> 00:51:57,670
if m is at least order n does that make
sense

2610
00:51:57,670 --> 00:51:57,680
sense
 

2611
00:51:57,680 --> 00:51:59,829
sense
okay the last thing i'm going to leave

2612
00:51:59,829 --> 00:51:59,839
okay the last thing i'm going to leave
 

2613
00:51:59,839 --> 00:52:01,349
okay the last thing i'm going to leave
you with is how do we make this thing

2614
00:52:01,349 --> 00:52:01,359
you with is how do we make this thing
 

2615
00:52:01,359 --> 00:52:02,390
you with is how do we make this thing
dynamic

2616
00:52:02,390 --> 00:52:02,400
dynamic
 

2617
00:52:02,400 --> 00:52:05,190
dynamic
if we're growing the number of things

2618
00:52:05,190 --> 00:52:05,200
if we're growing the number of things
 

2619
00:52:05,200 --> 00:52:07,190
if we're growing the number of things
we're storing in this thing

2620
00:52:07,190 --> 00:52:07,200
we're storing in this thing
 

2621
00:52:07,200 --> 00:52:09,430
we're storing in this thing
it's possible that as we grow n for a

2622
00:52:09,430 --> 00:52:09,440
it's possible that as we grow n for a
 

2623
00:52:09,440 --> 00:52:10,790
it's possible that as we grow n for a
fixed m

2624
00:52:10,790 --> 00:52:10,800
fixed m
 

2625
00:52:10,800 --> 00:52:13,750
fixed m
this thing will stop being m will stop

2626
00:52:13,750 --> 00:52:13,760
this thing will stop being m will stop
 

2627
00:52:13,760 --> 00:52:14,710
this thing will stop being m will stop
being linear in n

2628
00:52:14,710 --> 00:52:14,720
being linear in n
 

2629
00:52:14,720 --> 00:52:17,670
being linear in n
right well then all we have to do is if

2630
00:52:17,670 --> 00:52:17,680
right well then all we have to do is if
 

2631
00:52:17,680 --> 00:52:18,230
right well then all we have to do is if
we get

2632
00:52:18,230 --> 00:52:18,240
we get
 

2633
00:52:18,240 --> 00:52:22,470
we get
too far we rebuild the entire thing

2634
00:52:22,470 --> 00:52:22,480
too far we rebuild the entire thing
 

2635
00:52:22,480 --> 00:52:24,390
too far we rebuild the entire thing
the entire hash table with the new m

2636
00:52:24,390 --> 00:52:24,400
the entire hash table with the new m
 

2637
00:52:24,400 --> 00:52:25,910
the entire hash table with the new m
right just like we did with a

2638
00:52:25,910 --> 00:52:25,920
right just like we did with a
 

2639
00:52:25,920 --> 00:52:28,790
right just like we did with a
dynamic array and you can prove we're

2640
00:52:28,790 --> 00:52:28,800
dynamic array and you can prove we're
 

2641
00:52:28,800 --> 00:52:30,790
dynamic array and you can prove we're
not going to do that here

2642
00:52:30,790 --> 00:52:30,800
not going to do that here
 

2643
00:52:30,800 --> 00:52:33,270
not going to do that here
but you can prove that you won't do that

2644
00:52:33,270 --> 00:52:33,280
but you can prove that you won't do that
 

2645
00:52:33,280 --> 00:52:34,309
but you can prove that you won't do that
operation too

2646
00:52:34,309 --> 00:52:34,319
operation too
 

2647
00:52:34,319 --> 00:52:36,870
operation too
often if you're resizing in the right

2648
00:52:36,870 --> 00:52:36,880
often if you're resizing in the right
 

2649
00:52:36,880 --> 00:52:37,430
often if you're resizing in the right
way

2650
00:52:37,430 --> 00:52:37,440
way
 

2651
00:52:37,440 --> 00:52:40,790
way
and so you just rebuild completely after

2652
00:52:40,790 --> 00:52:40,800
and so you just rebuild completely after
 

2653
00:52:40,800 --> 00:52:42,790
and so you just rebuild completely after
a certain number of operations okay so

2654
00:52:42,790 --> 00:52:42,800
a certain number of operations okay so
 

2655
00:52:42,800 --> 00:52:43,990
a certain number of operations okay so
that's hashing

2656
00:52:43,990 --> 00:52:44,000
that's hashing
 

2657
00:52:44,000 --> 00:52:45,349
that's hashing
next week we're going to be talking

2658
00:52:45,349 --> 00:52:45,359
next week we're going to be talking
 

2659
00:52:45,359 --> 00:52:56,079
next week we're going to be talking
about doing a faster sort

