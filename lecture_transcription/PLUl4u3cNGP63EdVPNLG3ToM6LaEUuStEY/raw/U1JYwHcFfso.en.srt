1
00:00:12,519 --> 00:00:14,629

all right welcome back to data

2
00:00:14,629 --> 00:00:14,639
all right welcome back to data
 

3
00:00:14,639 --> 00:00:18,429
all right welcome back to data
structures land today we continue and

4
00:00:18,429 --> 00:00:18,439
structures land today we continue and
 

5
00:00:18,439 --> 00:00:21,390
structures land today we continue and
complete our segment on binary trees so

6
00:00:21,390 --> 00:00:21,400
complete our segment on binary trees so
 

7
00:00:21,400 --> 00:00:23,870
complete our segment on binary trees so
this is part two if you missed part one

8
00:00:23,870 --> 00:00:23,880
this is part two if you missed part one
 

9
00:00:23,880 --> 00:00:26,790
this is part two if you missed part one
go back and watch part one um last time

10
00:00:26,790 --> 00:00:26,800
go back and watch part one um last time
 

11
00:00:26,800 --> 00:00:30,349
go back and watch part one um last time
we talked about binary trees in general

12
00:00:30,349 --> 00:00:30,359
we talked about binary trees in general
 

13
00:00:30,359 --> 00:00:35,069
we talked about binary trees in general
uh we had uh each node stored an item uh

14
00:00:35,069 --> 00:00:35,079
uh we had uh each node stored an item uh
 

15
00:00:35,079 --> 00:00:37,190
uh we had uh each node stored an item uh
which and also a left pointer and a

16
00:00:37,190 --> 00:00:37,200
which and also a left pointer and a
 

17
00:00:37,200 --> 00:00:38,790
which and also a left pointer and a
right pointer to other nodes and a

18
00:00:38,790 --> 00:00:38,800
right pointer to other nodes and a
 

19
00:00:38,800 --> 00:00:41,549
right pointer to other nodes and a
parent pointer to another node uh this

20
00:00:41,549 --> 00:00:41,559
parent pointer to another node uh this
 

21
00:00:41,559 --> 00:00:45,270
parent pointer to another node uh this
was an example of a tree B and C or A's

22
00:00:45,270 --> 00:00:45,280
was an example of a tree B and C or A's
 

23
00:00:45,280 --> 00:00:48,310
was an example of a tree B and C or A's
children a is the parent of B and C and

24
00:00:48,310 --> 00:00:48,320
children a is the parent of B and C and
 

25
00:00:48,320 --> 00:00:50,430
children a is the parent of B and C and
also the root of the entire tree we

26
00:00:50,430 --> 00:00:50,440
also the root of the entire tree we
 

27
00:00:50,440 --> 00:00:52,110
also the root of the entire tree we
defined the height of a node we didn't

28
00:00:52,110 --> 00:00:52,120
defined the height of a node we didn't
 

29
00:00:52,120 --> 00:00:53,549
defined the height of a node we didn't
use this too much yet but we're going to

30
00:00:53,549 --> 00:00:53,559
use this too much yet but we're going to
 

31
00:00:53,559 --> 00:00:55,349
use this too much yet but we're going to
use it a lot today so remember the

32
00:00:55,349 --> 00:00:55,359
use it a lot today so remember the
 

33
00:00:55,359 --> 00:00:58,590
use it a lot today so remember the
height is as drawn in red here um height

34
00:00:58,590 --> 00:00:58,600
height is as drawn in red here um height
 

35
00:00:58,600 --> 00:01:01,430
height is as drawn in red here um height
of the node is the length of the longest

36
00:01:01,430 --> 00:01:01,440
of the node is the length of the longest
 

37
00:01:01,440 --> 00:01:03,869
of the node is the length of the longest
downward path counting edges so B for

38
00:01:03,869 --> 00:01:03,879
downward path counting edges so B for
 

39
00:01:03,879 --> 00:01:05,710
downward path counting edges so B for
example has a length two path so we

40
00:01:05,710 --> 00:01:05,720
example has a length two path so we
 

41
00:01:05,720 --> 00:01:07,830
example has a length two path so we
write a two here you can also think of

42
00:01:07,830 --> 00:01:07,840
write a two here you can also think of
 

43
00:01:07,840 --> 00:01:11,270
write a two here you can also think of
it is if you just live within the sub

44
00:01:11,270 --> 00:01:11,280
it is if you just live within the sub
 

45
00:01:11,280 --> 00:01:15,789
it is if you just live within the sub
tree rooted at b b's subtree uh then uh

46
00:01:15,789 --> 00:01:15,799
tree rooted at b b's subtree uh then uh
 

47
00:01:15,799 --> 00:01:17,789
tree rooted at b b's subtree uh then uh
what is the maximum depth of those nodes

48
00:01:17,789 --> 00:01:17,799
what is the maximum depth of those nodes
 

49
00:01:17,799 --> 00:01:19,190
what is the maximum depth of those nodes
if you prefer to think about it that way

50
00:01:19,190 --> 00:01:19,200
if you prefer to think about it that way
 

51
00:01:19,200 --> 00:01:21,510
if you prefer to think about it that way
either way is fine um and in particular

52
00:01:21,510 --> 00:01:21,520
either way is fine um and in particular
 

53
00:01:21,520 --> 00:01:24,109
either way is fine um and in particular
we distinguished H the height of the

54
00:01:24,109 --> 00:01:24,119
we distinguished H the height of the
 

55
00:01:24,119 --> 00:01:26,310
we distinguished H the height of the
root node as the height of the entire

56
00:01:26,310 --> 00:01:26,320
root node as the height of the entire
 

57
00:01:26,320 --> 00:01:28,830
root node as the height of the entire
tree and what we achieved last time was

58
00:01:28,830 --> 00:01:28,840
tree and what we achieved last time was
 

59
00:01:28,840 --> 00:01:31,069
tree and what we achieved last time was
basically all of our operations ran in

60
00:01:31,069 --> 00:01:31,079
basically all of our operations ran in
 

61
00:01:31,079 --> 00:01:35,630
basically all of our operations ran in
order H time so um we had subtree insert

62
00:01:35,630 --> 00:01:35,640
order H time so um we had subtree insert
 

63
00:01:35,640 --> 00:01:38,270
order H time so um we had subtree insert
subtree delete subtree first and last we

64
00:01:38,270 --> 00:01:38,280
subtree delete subtree first and last we
 

65
00:01:38,280 --> 00:01:39,590
subtree delete subtree first and last we
could compute the predecessor and

66
00:01:39,590 --> 00:01:39,600
could compute the predecessor and
 

67
00:01:39,600 --> 00:01:42,630
could compute the predecessor and
successor of a node all in order H time

68
00:01:42,630 --> 00:01:42,640
successor of a node all in order H time
 

69
00:01:42,640 --> 00:01:46,990
successor of a node all in order H time
so as long as H was small uh we were

70
00:01:46,990 --> 00:01:47,000
so as long as H was small uh we were
 

71
00:01:47,000 --> 00:01:49,030
so as long as H was small uh we were
happy um and remember what does

72
00:01:49,030 --> 00:01:49,040
happy um and remember what does
 

73
00:01:49,040 --> 00:01:50,910
happy um and remember what does
predecessor and successor mean it's

74
00:01:50,910 --> 00:01:50,920
predecessor and successor mean it's
 

75
00:01:50,920 --> 00:01:53,230
predecessor and successor mean it's
talking about an implicit order in the

76
00:01:53,230 --> 00:01:53,240
talking about an implicit order in the
 

77
00:01:53,240 --> 00:01:55,550
talking about an implicit order in the
tree which is what we call traversal

78
00:01:55,550 --> 00:01:55,560
tree which is what we call traversal
 

79
00:01:55,560 --> 00:01:58,550
tree which is what we call traversal
order which is defined recursively as

80
00:01:58,550 --> 00:01:58,560
order which is defined recursively as
 

81
00:01:58,560 --> 00:02:01,350
order which is defined recursively as
recursively Traverse left sub tree then

82
00:02:01,350 --> 00:02:01,360
recursively Traverse left sub tree then
 

83
00:02:01,360 --> 00:02:03,190
recursively Traverse left sub tree then
output the root then recursively

84
00:02:03,190 --> 00:02:03,200
output the root then recursively
 

85
00:02:03,200 --> 00:02:05,950
output the root then recursively
Traverse the right sub tree so in this

86
00:02:05,950 --> 00:02:05,960
Traverse the right sub tree so in this
 

87
00:02:05,960 --> 00:02:10,510
Traverse the right sub tree so in this
example the traversal order is f is the

88
00:02:10,510 --> 00:02:10,520
example the traversal order is f is the
 

89
00:02:10,520 --> 00:02:12,630
example the traversal order is f is the
if you go all the way left that was the

90
00:02:12,630 --> 00:02:12,640
if you go all the way left that was the
 

91
00:02:12,640 --> 00:02:15,910
if you go all the way left that was the
first in the traversal order uh then we

92
00:02:15,910 --> 00:02:15,920
first in the traversal order uh then we
 

93
00:02:15,920 --> 00:02:19,589
first in the traversal order uh then we
have right make some space here uh then

94
00:02:19,589 --> 00:02:19,599
have right make some space here uh then
 

95
00:02:19,599 --> 00:02:22,910
have right make some space here uh then
we have D then we have

96
00:02:22,910 --> 00:02:22,920
we have D then we have
 

97
00:02:22,920 --> 00:02:25,750
we have D then we have
B then we do the right sub tree of B

98
00:02:25,750 --> 00:02:25,760
B then we do the right sub tree of B
 

99
00:02:25,760 --> 00:02:26,670
B then we do the right sub tree of B
which is

100
00:02:26,670 --> 00:02:26,680
which is
 

101
00:02:26,680 --> 00:02:30,229
which is
e then we have the root because we

102
00:02:30,229 --> 00:02:30,239
e then we have the root because we
 

103
00:02:30,239 --> 00:02:32,229
e then we have the root because we
finished the left sub tree of the root

104
00:02:32,229 --> 00:02:32,239
finished the left sub tree of the root
 

105
00:02:32,239 --> 00:02:36,030
finished the left sub tree of the root
so that's a and then we have

106
00:02:36,030 --> 00:02:36,040
so that's a and then we have
 

107
00:02:36,040 --> 00:02:38,589
so that's a and then we have
C okay so there's an implicit linear

108
00:02:38,589 --> 00:02:38,599
C okay so there's an implicit linear
 

109
00:02:38,599 --> 00:02:41,509
C okay so there's an implicit linear
order encoded by this tree and the whole

110
00:02:41,509 --> 00:02:41,519
order encoded by this tree and the whole
 

111
00:02:41,519 --> 00:02:43,430
order encoded by this tree and the whole
point of binary trees is that we can

112
00:02:43,430 --> 00:02:43,440
point of binary trees is that we can
 

113
00:02:43,440 --> 00:02:45,869
point of binary trees is that we can
efficiently update the tree uh much

114
00:02:45,869 --> 00:02:45,879
efficiently update the tree uh much
 

115
00:02:45,879 --> 00:02:47,869
efficiently update the tree uh much
faster than we could explicitly write

116
00:02:47,869 --> 00:02:47,879
faster than we could explicitly write
 

117
00:02:47,879 --> 00:02:49,550
faster than we could explicitly write
down an order in an array or something

118
00:02:49,550 --> 00:02:49,560
down an order in an array or something
 

119
00:02:49,560 --> 00:02:53,470
down an order in an array or something
like that so binary trees let us quickly

120
00:02:53,470 --> 00:02:53,480
like that so binary trees let us quickly
 

121
00:02:53,480 --> 00:02:55,550
like that so binary trees let us quickly
Now quickly is not so quick right now

122
00:02:55,550 --> 00:02:55,560
Now quickly is not so quick right now
 

123
00:02:55,560 --> 00:02:57,350
Now quickly is not so quick right now
because everything is order H and in the

124
00:02:57,350 --> 00:02:57,360
because everything is order H and in the
 

125
00:02:57,360 --> 00:02:59,190
because everything is order H and in the
worst case h is linear because we could

126
00:02:59,190 --> 00:02:59,200
worst case h is linear because we could
 

127
00:02:59,200 --> 00:03:02,270
worst case h is linear because we could
have a tree like

128
00:03:02,270 --> 00:03:02,280

 

129
00:03:02,280 --> 00:03:04,910

this but today we're going to make we're

130
00:03:04,910 --> 00:03:04,920
this but today we're going to make we're
 

131
00:03:04,920 --> 00:03:07,630
this but today we're going to make we're
going to guarantee that H is log n and

132
00:03:07,630 --> 00:03:07,640
going to guarantee that H is log n and
 

133
00:03:07,640 --> 00:03:09,430
going to guarantee that H is log n and
so the goal of today is to take all of

134
00:03:09,430 --> 00:03:09,440
so the goal of today is to take all of
 

135
00:03:09,440 --> 00:03:11,509
so the goal of today is to take all of
these operations that run in order H

136
00:03:11,509 --> 00:03:11,519
these operations that run in order H
 

137
00:03:11,519 --> 00:03:13,910
these operations that run in order H
time and get them to run in order log n

138
00:03:13,910 --> 00:03:13,920
time and get them to run in order log n
 

139
00:03:13,920 --> 00:03:15,309
time and get them to run in order log n
time just by modifying the data

140
00:03:15,309 --> 00:03:15,319
time just by modifying the data
 

141
00:03:15,319 --> 00:03:16,630
time just by modifying the data
structure we've already seen so we've

142
00:03:16,630 --> 00:03:16,640
structure we've already seen so we've
 

143
00:03:16,640 --> 00:03:18,229
structure we've already seen so we've
done a lot of the hard work just a

144
00:03:18,229 --> 00:03:18,239
done a lot of the hard work just a
 

145
00:03:18,239 --> 00:03:20,270
done a lot of the hard work just a
little bit more work we need to do today

146
00:03:20,270 --> 00:03:20,280
little bit more work we need to do today
 

147
00:03:20,280 --> 00:03:24,190
little bit more work we need to do today
in something called AVL trees or height

148
00:03:24,190 --> 00:03:24,200
in something called AVL trees or height
 

149
00:03:24,200 --> 00:03:26,910
in something called AVL trees or height
balance okay but before we get there I

150
00:03:26,910 --> 00:03:26,920
balance okay but before we get there I
 

151
00:03:26,920 --> 00:03:28,869
balance okay but before we get there I
want to talk a little bit more at the

152
00:03:28,869 --> 00:03:28,879
want to talk a little bit more at the
 

153
00:03:28,879 --> 00:03:30,990
want to talk a little bit more at the
very end of last leure we talked about

154
00:03:30,990 --> 00:03:31,000
very end of last leure we talked about
 

155
00:03:31,000 --> 00:03:32,830
very end of last leure we talked about
once you have these subtree operations

156
00:03:32,830 --> 00:03:32,840
once you have these subtree operations
 

157
00:03:32,840 --> 00:03:35,470
once you have these subtree operations
so I can insert and delete into subtree

158
00:03:35,470 --> 00:03:35,480
so I can insert and delete into subtree
 

159
00:03:35,480 --> 00:03:37,550
so I can insert and delete into subtree
um how do I actually use that to solve

160
00:03:37,550 --> 00:03:37,560
um how do I actually use that to solve
 

161
00:03:37,560 --> 00:03:39,149
um how do I actually use that to solve
the problems that we care about in this

162
00:03:39,149 --> 00:03:39,159
the problems that we care about in this
 

163
00:03:39,159 --> 00:03:41,070
the problems that we care about in this
class which are sequence data structure

164
00:03:41,070 --> 00:03:41,080
class which are sequence data structure
 

165
00:03:41,080 --> 00:03:45,470
class which are sequence data structure
and set data structure so um we talked

166
00:03:45,470 --> 00:03:45,480
and set data structure so um we talked
 

167
00:03:45,480 --> 00:03:47,350
and set data structure so um we talked
mostly about the set data structure last

168
00:03:47,350 --> 00:03:47,360
mostly about the set data structure last
 

169
00:03:47,360 --> 00:03:49,350
mostly about the set data structure last
time so in general we're going to Define

170
00:03:49,350 --> 00:03:49,360
time so in general we're going to Define
 

171
00:03:49,360 --> 00:03:52,509
time so in general we're going to Define
what traversal order we maintain by a

172
00:03:52,509 --> 00:03:52,519
what traversal order we maintain by a
 

173
00:03:52,519 --> 00:03:57,190
what traversal order we maintain by a
binary tree and so for a set um because

174
00:03:57,190 --> 00:03:57,200
binary tree and so for a set um because
 

175
00:03:57,200 --> 00:03:58,830
binary tree and so for a set um because
we're for the set interface we're

176
00:03:58,830 --> 00:03:58,840
we're for the set interface we're
 

177
00:03:58,840 --> 00:04:00,229
we're for the set interface we're
interested in doing

178
00:04:00,229 --> 00:04:00,239
interested in doing
 

179
00:04:00,239 --> 00:04:02,030
interested in doing
uh queries like find next and find

180
00:04:02,030 --> 00:04:02,040
uh queries like find next and find
 

181
00:04:02,040 --> 00:04:04,630
uh queries like find next and find
previous given a key if it's not there

182
00:04:04,630 --> 00:04:04,640
previous given a key if it's not there
 

183
00:04:04,640 --> 00:04:06,309
previous given a key if it's not there
tell me the previous one or the next one

184
00:04:06,309 --> 00:04:06,319
tell me the previous one or the next one
 

185
00:04:06,319 --> 00:04:07,350
tell me the previous one or the next one
this is something we could do with

186
00:04:07,350 --> 00:04:07,360
this is something we could do with
 

187
00:04:07,360 --> 00:04:10,589
this is something we could do with
binary search and so the the big cool

188
00:04:10,589 --> 00:04:10,599
binary search and so the the big cool
 

189
00:04:10,599 --> 00:04:12,910
binary search and so the the big cool
thing that binary trees let us do if we

190
00:04:12,910 --> 00:04:12,920
thing that binary trees let us do if we
 

191
00:04:12,920 --> 00:04:15,589
thing that binary trees let us do if we
let the traversal order always be uh all

192
00:04:15,589 --> 00:04:15,599
let the traversal order always be uh all
 

193
00:04:15,599 --> 00:04:17,430
let the traversal order always be uh all
of the items stored in increasing key

194
00:04:17,430 --> 00:04:17,440
of the items stored in increasing key
 

195
00:04:17,440 --> 00:04:19,469
of the items stored in increasing key
order then we are effectively

196
00:04:19,469 --> 00:04:19,479
order then we are effectively
 

197
00:04:19,479 --> 00:04:22,110
order then we are effectively
maintaining the items in

198
00:04:22,110 --> 00:04:22,120
maintaining the items in
 

199
00:04:22,120 --> 00:04:24,670
maintaining the items in
order in in the traversal order sense

200
00:04:24,670 --> 00:04:24,680
order in in the traversal order sense
 

201
00:04:24,680 --> 00:04:26,189
order in in the traversal order sense
again we're not explicitly maintaining

202
00:04:26,189 --> 00:04:26,199
again we're not explicitly maintaining
 

203
00:04:26,199 --> 00:04:28,590
again we're not explicitly maintaining
them in order but up here we're

204
00:04:28,590 --> 00:04:28,600
them in order but up here we're
 

205
00:04:28,600 --> 00:04:30,390
them in order but up here we're
maintaining a tree that that represents

206
00:04:30,390 --> 00:04:30,400
maintaining a tree that that represents
 

207
00:04:30,400 --> 00:04:33,870
maintaining a tree that that represents
items in key order and so this lets us

208
00:04:33,870 --> 00:04:33,880
items in key order and so this lets us
 

209
00:04:33,880 --> 00:04:37,870
items in key order and so this lets us
do uh a sub tree find operation which

210
00:04:37,870 --> 00:04:37,880
do uh a sub tree find operation which
 

211
00:04:37,880 --> 00:04:40,110
do uh a sub tree find operation which
you could easily use to implement find

212
00:04:40,110 --> 00:04:40,120
you could easily use to implement find
 

213
00:04:40,120 --> 00:04:42,830
you could easily use to implement find
and find previous and so on um as

214
00:04:42,830 --> 00:04:42,840
and find previous and so on um as
 

215
00:04:42,840 --> 00:04:45,990
and find previous and so on um as
follows we start at the root of the tree

216
00:04:45,990 --> 00:04:46,000
follows we start at the root of the tree
 

217
00:04:46,000 --> 00:04:47,830
follows we start at the root of the tree
so we could say node equals root

218
00:04:47,830 --> 00:04:47,840
so we could say node equals root
 

219
00:04:47,840 --> 00:04:50,029
so we could say node equals root
initially and then we can recursively

220
00:04:50,029 --> 00:04:50,039
initially and then we can recursively
 

221
00:04:50,039 --> 00:04:53,350
initially and then we can recursively
search for a key K as follows we check

222
00:04:53,350 --> 00:04:53,360
search for a key K as follows we check
 

223
00:04:53,360 --> 00:04:57,510
search for a key K as follows we check
well if the item at the root has a key

224
00:04:57,510 --> 00:04:57,520
well if the item at the root has a key
 

225
00:04:57,520 --> 00:05:00,189
well if the item at the root has a key
that's bigger than K let me draw a

226
00:05:00,189 --> 00:05:00,199
that's bigger than K let me draw a
 

227
00:05:00,199 --> 00:05:01,110
that's bigger than K let me draw a
little

228
00:05:01,110 --> 00:05:01,120
little
 

229
00:05:01,120 --> 00:05:03,110
little
picture

230
00:05:03,110 --> 00:05:03,120
picture
 

231
00:05:03,120 --> 00:05:07,469
picture
uh so we're at some node

232
00:05:07,469 --> 00:05:07,479
uh so we're at some node
 

233
00:05:07,479 --> 00:05:09,390
uh so we're at some node
here this is a

234
00:05:09,390 --> 00:05:09,400
here this is a
 

235
00:05:09,400 --> 00:05:12,710
here this is a
node and it has a left sub tree and a

236
00:05:12,710 --> 00:05:12,720
node and it has a left sub tree and a
 

237
00:05:12,720 --> 00:05:14,830
node and it has a left sub tree and a
right sub tree and there's some

238
00:05:14,830 --> 00:05:14,840
right sub tree and there's some
 

239
00:05:14,840 --> 00:05:17,950
right sub tree and there's some
item with some key so if the key we're

240
00:05:17,950 --> 00:05:17,960
item with some key so if the key we're
 

241
00:05:17,960 --> 00:05:20,350
item with some key so if the key we're
looking for is less than the nodes item

242
00:05:20,350 --> 00:05:20,360
looking for is less than the nodes item
 

243
00:05:20,360 --> 00:05:22,469
looking for is less than the nodes item
that means it's down here in the left

244
00:05:22,469 --> 00:05:22,479
that means it's down here in the left
 

245
00:05:22,479 --> 00:05:25,550
that means it's down here in the left
sub tree and so we recurse on node. left

246
00:05:25,550 --> 00:05:25,560
sub tree and so we recurse on node. left
 

247
00:05:25,560 --> 00:05:27,590
sub tree and so we recurse on node. left
if they're equal that means that this

248
00:05:27,590 --> 00:05:27,600
if they're equal that means that this
 

249
00:05:27,600 --> 00:05:29,189
if they're equal that means that this
item is the item we're looking for so we

250
00:05:29,189 --> 00:05:29,199
item is the item we're looking for so we
 

251
00:05:29,199 --> 00:05:31,150
item is the item we're looking for so we
can just turn it or the node depending

252
00:05:31,150 --> 00:05:31,160
can just turn it or the node depending
 

253
00:05:31,160 --> 00:05:33,230
can just turn it or the node depending
on what you're looking for and if the

254
00:05:33,230 --> 00:05:33,240
on what you're looking for and if the
 

255
00:05:33,240 --> 00:05:34,629
on what you're looking for and if the
key in here is greater than the key

256
00:05:34,629 --> 00:05:34,639
key in here is greater than the key
 

257
00:05:34,639 --> 00:05:36,110
key in here is greater than the key
we're looking for then we'll recurse to

258
00:05:36,110 --> 00:05:36,120
we're looking for then we'll recurse to
 

259
00:05:36,120 --> 00:05:37,270
we're looking for then we'll recurse to
the

260
00:05:37,270 --> 00:05:37,280
the
 

261
00:05:37,280 --> 00:05:40,029
the
right this if you think about it a

262
00:05:40,029 --> 00:05:40,039
right this if you think about it a
 

263
00:05:40,039 --> 00:05:42,469
right this if you think about it a
little bit this is exactly binary search

264
00:05:42,469 --> 00:05:42,479
little bit this is exactly binary search
 

265
00:05:42,479 --> 00:05:44,830
little bit this is exactly binary search
on an array it just happens to be on a

266
00:05:44,830 --> 00:05:44,840
on an array it just happens to be on a
 

267
00:05:44,840 --> 00:05:52,110
on an array it just happens to be on a
tree instead if you think of an

268
00:05:52,110 --> 00:05:52,120

 

269
00:05:52,120 --> 00:05:55,870

array um like this B where does binary

270
00:05:55,870 --> 00:05:55,880
array um like this B where does binary
 

271
00:05:55,880 --> 00:05:57,710
array um like this B where does binary
stretch do it first looks at the key in

272
00:05:57,710 --> 00:05:57,720
stretch do it first looks at the key in
 

273
00:05:57,720 --> 00:05:59,189
stretch do it first looks at the key in
the middle I'm going to draw that as the

274
00:05:59,189 --> 00:05:59,199
the middle I'm going to draw that as the
 

275
00:05:59,199 --> 00:06:02,629
the middle I'm going to draw that as the
root uh and then uh it recurses either

276
00:06:02,629 --> 00:06:02,639
root uh and then uh it recurses either
 

277
00:06:02,639 --> 00:06:04,870
root uh and then uh it recurses either
on the left chunk which I will draw

278
00:06:04,870 --> 00:06:04,880
on the left chunk which I will draw
 

279
00:06:04,880 --> 00:06:07,189
on the left chunk which I will draw
recursively or on the right

280
00:06:07,189 --> 00:06:07,199
recursively or on the right
 

281
00:06:07,199 --> 00:06:09,510
recursively or on the right
chunk and so if you happen to have a

282
00:06:09,510 --> 00:06:09,520
chunk and so if you happen to have a
 

283
00:06:09,520 --> 00:06:11,589
chunk and so if you happen to have a
perfect binary tree like this one it is

284
00:06:11,589 --> 00:06:11,599
perfect binary tree like this one it is
 

285
00:06:11,599 --> 00:06:14,629
perfect binary tree like this one it is
simulating exactly uh binary search in

286
00:06:14,629 --> 00:06:14,639
simulating exactly uh binary search in
 

287
00:06:14,639 --> 00:06:16,230
simulating exactly uh binary search in
this array but this we're going to be

288
00:06:16,230 --> 00:06:16,240
this array but this we're going to be
 

289
00:06:16,240 --> 00:06:17,950
this array but this we're going to be
able to maintain dynamically not perfect

290
00:06:17,950 --> 00:06:17,960
able to maintain dynamically not perfect
 

291
00:06:17,960 --> 00:06:20,270
able to maintain dynamically not perfect
anymore but close uh whereas this we

292
00:06:20,270 --> 00:06:20,280
anymore but close uh whereas this we
 

293
00:06:20,280 --> 00:06:23,230
anymore but close uh whereas this we
could not maintain in sorted order okay

294
00:06:23,230 --> 00:06:23,240
could not maintain in sorted order okay
 

295
00:06:23,240 --> 00:06:26,510
could not maintain in sorted order okay
so uh this is like a generalization of

296
00:06:26,510 --> 00:06:26,520
so uh this is like a generalization of
 

297
00:06:26,520 --> 00:06:28,629
so uh this is like a generalization of
binary search to work on trees instead

298
00:06:28,629 --> 00:06:28,639
binary search to work on trees instead
 

299
00:06:28,639 --> 00:06:32,469
binary search to work on trees instead
of on arrays and for this reason set

300
00:06:32,469 --> 00:06:32,479
of on arrays and for this reason set
 

301
00:06:32,479 --> 00:06:34,430
of on arrays and for this reason set
binary trees are called binary search

302
00:06:34,430 --> 00:06:34,440
binary trees are called binary search
 

303
00:06:34,440 --> 00:06:35,990
binary trees are called binary search
trees because they are the tree version

304
00:06:35,990 --> 00:06:36,000
trees because they are the tree version
 

305
00:06:36,000 --> 00:06:37,270
trees because they are the tree version
of binary search so there's many

306
00:06:37,270 --> 00:06:37,280
of binary search so there's many
 

307
00:06:37,280 --> 00:06:39,309
of binary search so there's many
equivalent names so binary search tree

308
00:06:39,309 --> 00:06:39,319
equivalent names so binary search tree
 

309
00:06:39,319 --> 00:06:41,350
equivalent names so binary search tree
is another name for set binary tree and

310
00:06:41,350 --> 00:06:41,360
is another name for set binary tree and
 

311
00:06:41,360 --> 00:06:43,150
is another name for set binary tree and
the key thing that makes this algorithm

312
00:06:43,150 --> 00:06:43,160
the key thing that makes this algorithm
 

313
00:06:43,160 --> 00:06:45,230
the key thing that makes this algorithm
work is so-called binary search tree

314
00:06:45,230 --> 00:06:45,240
work is so-called binary search tree
 

315
00:06:45,240 --> 00:06:48,790
work is so-called binary search tree
property which is um all the keys in the

316
00:06:48,790 --> 00:06:48,800
property which is um all the keys in the
 

317
00:06:48,800 --> 00:06:51,309
property which is um all the keys in the
left sub tree of a node are less than uh

318
00:06:51,309 --> 00:06:51,319
left sub tree of a node are less than uh
 

319
00:06:51,319 --> 00:06:54,589
left sub tree of a node are less than uh
the root and all or of that node and

320
00:06:54,589 --> 00:06:54,599
the root and all or of that node and
 

321
00:06:54,599 --> 00:06:56,710
the root and all or of that node and
that key that key is less than all the

322
00:06:56,710 --> 00:06:56,720
that key that key is less than all the
 

323
00:06:56,720 --> 00:06:58,230
that key that key is less than all the
keys in the right sub tree and this is

324
00:06:58,230 --> 00:06:58,240
keys in the right sub tree and this is
 

325
00:06:58,240 --> 00:07:00,350
keys in the right sub tree and this is
true recursively all the way down

326
00:07:00,350 --> 00:07:00,360
true recursively all the way down
 

327
00:07:00,360 --> 00:07:02,230
true recursively all the way down
and so that's that's how you prove that

328
00:07:02,230 --> 00:07:02,240
and so that's that's how you prove that
 

329
00:07:02,240 --> 00:07:04,110
and so that's that's how you prove that
this algorithm is correct by this

330
00:07:04,110 --> 00:07:04,120
this algorithm is correct by this
 

331
00:07:04,120 --> 00:07:07,710
this algorithm is correct by this
property why is this true because uh if

332
00:07:07,710 --> 00:07:07,720
property why is this true because uh if
 

333
00:07:07,720 --> 00:07:09,430
property why is this true because uh if
we can maintain traversal order to be

334
00:07:09,430 --> 00:07:09,440
we can maintain traversal order to be
 

335
00:07:09,440 --> 00:07:13,189
we can maintain traversal order to be
increasing key then that's exactly what

336
00:07:13,189 --> 00:07:13,199
increasing key then that's exactly what
 

337
00:07:13,199 --> 00:07:14,830
increasing key then that's exactly what
traversal order means it tells you all

338
00:07:14,830 --> 00:07:14,840
traversal order means it tells you all
 

339
00:07:14,840 --> 00:07:16,150
traversal order means it tells you all
the things in the left sub tree come

340
00:07:16,150 --> 00:07:16,160
the things in the left sub tree come
 

341
00:07:16,160 --> 00:07:17,629
the things in the left sub tree come
before the root which come before all

342
00:07:17,629 --> 00:07:17,639
before the root which come before all
 

343
00:07:17,639 --> 00:07:19,990
before the root which come before all
the things in the right sub tree so uh

344
00:07:19,990 --> 00:07:20,000
the things in the right sub tree so uh
 

345
00:07:20,000 --> 00:07:22,749
the things in the right sub tree so uh
this property implies this

346
00:07:22,749 --> 00:07:22,759
this property implies this
 

347
00:07:22,759 --> 00:07:25,070
this property implies this
one and how do you maintain things in

348
00:07:25,070 --> 00:07:25,080
one and how do you maintain things in
 

349
00:07:25,080 --> 00:07:27,790
one and how do you maintain things in
increasing key order it's pretty easy uh

350
00:07:27,790 --> 00:07:27,800
increasing key order it's pretty easy uh
 

351
00:07:27,800 --> 00:07:30,189
increasing key order it's pretty easy uh
if you want to insert an item where does

352
00:07:30,189 --> 00:07:30,199
if you want to insert an item where does
 

353
00:07:30,199 --> 00:07:32,710
if you want to insert an item where does
it belong well you do this search to

354
00:07:32,710 --> 00:07:32,720
it belong well you do this search to
 

355
00:07:32,720 --> 00:07:34,670
it belong well you do this search to
find where it would belong if it was

356
00:07:34,670 --> 00:07:34,680
find where it would belong if it was
 

357
00:07:34,680 --> 00:07:36,670
find where it would belong if it was
there if it's there you can overwrite

358
00:07:36,670 --> 00:07:36,680
there if it's there you can overwrite
 

359
00:07:36,680 --> 00:07:38,670
there if it's there you can overwrite
the values stored with that key if it's

360
00:07:38,670 --> 00:07:38,680
the values stored with that key if it's
 

361
00:07:38,680 --> 00:07:40,070
the values stored with that key if it's
not

362
00:07:40,070 --> 00:07:40,080
not
 

363
00:07:40,080 --> 00:07:42,950
not
um this search will fall off the tree at

364
00:07:42,950 --> 00:07:42,960
um this search will fall off the tree at
 

365
00:07:42,960 --> 00:07:45,230
um this search will fall off the tree at
some point and that's where you insert

366
00:07:45,230 --> 00:07:45,240
some point and that's where you insert
 

367
00:07:45,240 --> 00:07:48,790
some point and that's where you insert
your uh a new node in your tree okay

368
00:07:48,790 --> 00:07:48,800
your uh a new node in your tree okay
 

369
00:07:48,800 --> 00:07:50,189
your uh a new node in your tree okay
that was discovered in recitation so I

370
00:07:50,189 --> 00:07:50,199
that was discovered in recitation so I
 

371
00:07:50,199 --> 00:07:52,029
that was discovered in recitation so I
don't want to dwell on it what I want to

372
00:07:52,029 --> 00:07:52,039
don't want to dwell on it what I want to
 

373
00:07:52,039 --> 00:07:54,869
don't want to dwell on it what I want to
focus on today is the other application

374
00:07:54,869 --> 00:07:54,879
focus on today is the other application
 

375
00:07:54,879 --> 00:07:56,950
focus on today is the other application
how do we this is for representing a set

376
00:07:56,950 --> 00:07:56,960
how do we this is for representing a set
 

377
00:07:56,960 --> 00:08:00,629
how do we this is for representing a set
which is relatively easy uh a CH

378
00:08:00,629 --> 00:08:00,639
which is relatively easy uh a CH
 

379
00:08:00,639 --> 00:08:02,110
which is relatively easy uh a CH
we sort of set ourselves up for but we

380
00:08:02,110 --> 00:08:02,120
we sort of set ourselves up for but we
 

381
00:08:02,120 --> 00:08:04,670
we sort of set ourselves up for but we
need a little more work is to make

382
00:08:04,670 --> 00:08:04,680
need a little more work is to make
 

383
00:08:04,680 --> 00:08:06,550
need a little more work is to make
sequence binary

384
00:08:06,550 --> 00:08:06,560
sequence binary
 

385
00:08:06,560 --> 00:08:09,390
sequence binary
trees so suppose I have a binary tree

386
00:08:09,390 --> 00:08:09,400
trees so suppose I have a binary tree
 

387
00:08:09,400 --> 00:08:11,510
trees so suppose I have a binary tree
and what I would like mentioned at the

388
00:08:11,510 --> 00:08:11,520
and what I would like mentioned at the
 

389
00:08:11,520 --> 00:08:13,390
and what I would like mentioned at the
end of last time is that I want the

390
00:08:13,390 --> 00:08:13,400
end of last time is that I want the
 

391
00:08:13,400 --> 00:08:17,110
end of last time is that I want the
traversal order of my tree to be the

392
00:08:17,110 --> 00:08:17,120
traversal order of my tree to be the
 

393
00:08:17,120 --> 00:08:18,749
traversal order of my tree to be the
sequence

394
00:08:18,749 --> 00:08:18,759
sequence
 

395
00:08:18,759 --> 00:08:20,749
sequence
order the order that I'm trying to

396
00:08:20,749 --> 00:08:20,759
order the order that I'm trying to
 

397
00:08:20,759 --> 00:08:22,909
order the order that I'm trying to
represent that's changed by operations

398
00:08:22,909 --> 00:08:22,919
represent that's changed by operations
 

399
00:08:22,919 --> 00:08:25,070
represent that's changed by operations
like insert

400
00:08:25,070 --> 00:08:25,080
like insert
 

401
00:08:25,080 --> 00:08:27,909
like insert
at and so I just like to do the same

402
00:08:27,909 --> 00:08:27,919
at and so I just like to do the same
 

403
00:08:27,919 --> 00:08:29,830
at and so I just like to do the same
thing but now I have to think about how

404
00:08:29,830 --> 00:08:29,840
thing but now I have to think about how
 

405
00:08:29,840 --> 00:08:31,629
thing but now I have to think about how
do I do a search how do I do insert at

406
00:08:31,629 --> 00:08:31,639
do I do a search how do I do insert at
 

407
00:08:31,639 --> 00:08:34,310
do I do a search how do I do insert at
that sort of thing and here is an

408
00:08:34,310 --> 00:08:34,320
that sort of thing and here is an
 

409
00:08:34,320 --> 00:08:36,750
that sort of thing and here is an
algorithm for what I would like to work

410
00:08:36,750 --> 00:08:36,760
algorithm for what I would like to work
 

411
00:08:36,760 --> 00:08:40,350
algorithm for what I would like to work
but it's not going to quite work yet so

412
00:08:40,350 --> 00:08:40,360
but it's not going to quite work yet so
 

413
00:08:40,360 --> 00:08:43,990
but it's not going to quite work yet so
suppose I give you a sub tree so

414
00:08:43,990 --> 00:08:44,000
suppose I give you a sub tree so
 

415
00:08:44,000 --> 00:08:47,070
suppose I give you a sub tree so
specified by a node so there's all the

416
00:08:47,070 --> 00:08:47,080
specified by a node so there's all the
 

417
00:08:47,080 --> 00:08:49,710
specified by a node so there's all the
descendants of that node and I'd like to

418
00:08:49,710 --> 00:08:49,720
descendants of that node and I'd like to
 

419
00:08:49,720 --> 00:08:52,550
descendants of that node and I'd like to
know what is in the traversal order of

420
00:08:52,550 --> 00:08:52,560
know what is in the traversal order of
 

421
00:08:52,560 --> 00:08:55,310
know what is in the traversal order of
that subtree which starts here and ends

422
00:08:55,310 --> 00:08:55,320
that subtree which starts here and ends
 

423
00:08:55,320 --> 00:08:56,590
that subtree which starts here and ends
here and the root will be somewhere in

424
00:08:56,590 --> 00:08:56,600
here and the root will be somewhere in
 

425
00:08:56,600 --> 00:08:57,269
here and the root will be somewhere in
the

426
00:08:57,269 --> 00:08:57,279
the
 

427
00:08:57,279 --> 00:08:59,949
the
middle give me the

428
00:08:59,949 --> 00:08:59,959
middle give me the
 

429
00:08:59,959 --> 00:09:02,990
middle give me the
node so this if I ask I equals z i want

430
00:09:02,990 --> 00:09:03,000
node so this if I ask I equals z i want
 

431
00:09:03,000 --> 00:09:05,630
node so this if I ask I equals z i want
to get this leftmost descendant if I ask

432
00:09:05,630 --> 00:09:05,640
to get this leftmost descendant if I ask
 

433
00:09:05,640 --> 00:09:08,430
to get this leftmost descendant if I ask
for I equals the size of the tree minus

434
00:09:08,430 --> 00:09:08,440
for I equals the size of the tree minus
 

435
00:09:08,440 --> 00:09:10,430
for I equals the size of the tree minus
one I want to get The rightmost

436
00:09:10,430 --> 00:09:10,440
one I want to get The rightmost
 

437
00:09:10,440 --> 00:09:12,630
one I want to get The rightmost
Descendant that was the first and last

438
00:09:12,630 --> 00:09:12,640
Descendant that was the first and last
 

439
00:09:12,640 --> 00:09:14,829
Descendant that was the first and last
in the sub tree that we talked about but

440
00:09:14,829 --> 00:09:14,839
in the sub tree that we talked about but
 

441
00:09:14,839 --> 00:09:16,350
in the sub tree that we talked about but
we don't we know how to find the first

442
00:09:16,350 --> 00:09:16,360
we don't we know how to find the first
 

443
00:09:16,360 --> 00:09:18,230
we don't we know how to find the first
and last just walk left or walk right

444
00:09:18,230 --> 00:09:18,240
and last just walk left or walk right
 

445
00:09:18,240 --> 00:09:21,269
and last just walk left or walk right
but we don't know how to find the I

446
00:09:21,269 --> 00:09:21,279
but we don't know how to find the I
 

447
00:09:21,279 --> 00:09:24,190
but we don't know how to find the I
node in order H time is the goal right

448
00:09:24,190 --> 00:09:24,200
node in order H time is the goal right
 

449
00:09:24,200 --> 00:09:28,470
node in order H time is the goal right
now not log in and the idea is well it

450
00:09:28,470 --> 00:09:28,480
now not log in and the idea is well it
 

451
00:09:28,480 --> 00:09:30,389
now not log in and the idea is well it
seems like size

452
00:09:30,389 --> 00:09:30,399
seems like size
 

453
00:09:30,399 --> 00:09:33,990
seems like size
matters sorry if you heard otherwise um

454
00:09:33,990 --> 00:09:34,000
matters sorry if you heard otherwise um
 

455
00:09:34,000 --> 00:09:36,949
matters sorry if you heard otherwise um
so in particular I I mentioned size when

456
00:09:36,949 --> 00:09:36,959
so in particular I I mentioned size when
 

457
00:09:36,959 --> 00:09:39,350
so in particular I I mentioned size when
I was talking about the the last node in

458
00:09:39,350 --> 00:09:39,360
I was talking about the the last node in
 

459
00:09:39,360 --> 00:09:41,870
I was talking about the the last node in
the sequence that the index of that node

460
00:09:41,870 --> 00:09:41,880
the sequence that the index of that node
 

461
00:09:41,880 --> 00:09:45,030
the sequence that the index of that node
is size of this subtree minus one so

462
00:09:45,030 --> 00:09:45,040
is size of this subtree minus one so
 

463
00:09:45,040 --> 00:09:50,269
is size of this subtree minus one so
let's define the size of a

464
00:09:50,269 --> 00:09:50,279

 

465
00:09:50,279 --> 00:09:55,710

node to be uh the number of nodes in its

466
00:09:55,710 --> 00:09:55,720
node to be uh the number of nodes in its
 

467
00:09:55,720 --> 00:09:58,750
node to be uh the number of nodes in its
sub tree we're calling that subtree

468
00:09:58,750 --> 00:09:58,760
sub tree we're calling that subtree
 

469
00:09:58,760 --> 00:10:04,630
sub tree we're calling that subtree
paren

470
00:10:04,630 --> 00:10:04,640

 

471
00:10:04,640 --> 00:10:08,030

node okay including the node

472
00:10:08,030 --> 00:10:08,040
node okay including the node
 

473
00:10:08,040 --> 00:10:11,150
node okay including the node
itself so if I somehow knew the size

474
00:10:11,150 --> 00:10:11,160
itself so if I somehow knew the size
 

475
00:10:11,160 --> 00:10:12,990
itself so if I somehow knew the size
this seems important for understanding

476
00:10:12,990 --> 00:10:13,000
this seems important for understanding
 

477
00:10:13,000 --> 00:10:14,990
this seems important for understanding
indexes let's just assume that I knew

478
00:10:14,990 --> 00:10:15,000
indexes let's just assume that I knew
 

479
00:10:15,000 --> 00:10:17,750
indexes let's just assume that I knew
that magically in constant

480
00:10:17,750 --> 00:10:17,760
that magically in constant
 

481
00:10:17,760 --> 00:10:22,030
that magically in constant
time okay uh then I claim that the size

482
00:10:22,030 --> 00:10:22,040
time okay uh then I claim that the size
 

483
00:10:22,040 --> 00:10:23,790
time okay uh then I claim that the size
of the left sub tree so why don't I

484
00:10:23,790 --> 00:10:23,800
of the left sub tree so why don't I
 

485
00:10:23,800 --> 00:10:27,949
of the left sub tree so why don't I
expand this diagram a little

486
00:10:27,949 --> 00:10:27,959

 

487
00:10:27,959 --> 00:10:31,030

bit so we we have node as

488
00:10:31,030 --> 00:10:31,040
bit so we we have node as
 

489
00:10:31,040 --> 00:10:34,630
bit so we we have node as
before but we have a left sub tree and a

490
00:10:34,630 --> 00:10:34,640
before but we have a left sub tree and a
 

491
00:10:34,640 --> 00:10:36,910
before but we have a left sub tree and a
right sub tree so this node here is

492
00:10:36,910 --> 00:10:36,920
right sub tree so this node here is
 

493
00:10:36,920 --> 00:10:39,069
right sub tree so this node here is
node. left this node here is node. right

494
00:10:39,069 --> 00:10:39,079
node. left this node here is node. right
 

495
00:10:39,079 --> 00:10:41,470
node. left this node here is node. right
they might not exist but let's ignore

496
00:10:41,470 --> 00:10:41,480
they might not exist but let's ignore
 

497
00:10:41,480 --> 00:10:43,990
they might not exist but let's ignore
those exceptional cases for now let's

498
00:10:43,990 --> 00:10:44,000
those exceptional cases for now let's
 

499
00:10:44,000 --> 00:10:46,509
those exceptional cases for now let's
suppose we knew not only the size of

500
00:10:46,509 --> 00:10:46,519
suppose we knew not only the size of
 

501
00:10:46,519 --> 00:10:49,269
suppose we knew not only the size of
node but we knew the size of node. left

502
00:10:49,269 --> 00:10:49,279
node but we knew the size of node. left
 

503
00:10:49,279 --> 00:10:52,670
node but we knew the size of node. left
so that is the size of this tree on the

504
00:10:52,670 --> 00:10:52,680
so that is the size of this tree on the
 

505
00:10:52,680 --> 00:10:55,430
so that is the size of this tree on the
left I'm going to call that NL so let's

506
00:10:55,430 --> 00:10:55,440
left I'm going to call that NL so let's
 

507
00:10:55,440 --> 00:10:57,910
left I'm going to call that NL so let's
suppose that there are NL nodes down

508
00:10:57,910 --> 00:10:57,920
suppose that there are NL nodes down
 

509
00:10:57,920 --> 00:11:00,910
suppose that there are NL nodes down
here why I claim that lets me do the

510
00:11:00,910 --> 00:11:00,920
here why I claim that lets me do the
 

511
00:11:00,920 --> 00:11:02,790
here why I claim that lets me do the
equivalent of a binary

512
00:11:02,790 --> 00:11:02,800
equivalent of a binary
 

513
00:11:02,800 --> 00:11:06,509
equivalent of a binary
search cuz I'm looking for some index I

514
00:11:06,509 --> 00:11:06,519
search cuz I'm looking for some index I
 

515
00:11:06,519 --> 00:11:09,670
search cuz I'm looking for some index I
and if I is less than NL then I know

516
00:11:09,670 --> 00:11:09,680
and if I is less than NL then I know
 

517
00:11:09,680 --> 00:11:11,150
and if I is less than NL then I know
that it must be down here for example if

518
00:11:11,150 --> 00:11:11,160
that it must be down here for example if
 

519
00:11:11,160 --> 00:11:12,910
that it must be down here for example if
I equals z it's going to be in the left

520
00:11:12,910 --> 00:11:12,920
I equals z it's going to be in the left
 

521
00:11:12,920 --> 00:11:15,790
I equals z it's going to be in the left
sub tree as long as NL is greater than

522
00:11:15,790 --> 00:11:15,800
sub tree as long as NL is greater than
 

523
00:11:15,800 --> 00:11:18,910
sub tree as long as NL is greater than
zero right so uh that's exactly this

524
00:11:18,910 --> 00:11:18,920
zero right so uh that's exactly this
 

525
00:11:18,920 --> 00:11:20,509
zero right so uh that's exactly this
check if I is less than NL I'm going to

526
00:11:20,509 --> 00:11:20,519
check if I is less than NL I'm going to
 

527
00:11:20,519 --> 00:11:23,710
check if I is less than NL I'm going to
recurse to the left call subt tree at of

528
00:11:23,710 --> 00:11:23,720
recurse to the left call subt tree at of
 

529
00:11:23,720 --> 00:11:25,230
recurse to the left call subt tree at of
no do left comma

530
00:11:25,230 --> 00:11:25,240
no do left comma
 

531
00:11:25,240 --> 00:11:28,310
no do left comma
I that's what's written here um if I

532
00:11:28,310 --> 00:11:28,320
I that's what's written here um if I
 

533
00:11:28,320 --> 00:11:29,870
I that's what's written here um if I
equals NL

534
00:11:29,870 --> 00:11:29,880
equals NL
 

535
00:11:29,880 --> 00:11:31,389
equals NL
if you think about it for a second so NL

536
00:11:31,389 --> 00:11:31,399
if you think about it for a second so NL
 

537
00:11:31,399 --> 00:11:33,550
if you think about it for a second so NL
is the number of nodes here and so that

538
00:11:33,550 --> 00:11:33,560
is the number of nodes here and so that
 

539
00:11:33,560 --> 00:11:37,750
is the number of nodes here and so that
means this node has index NL the index

540
00:11:37,750 --> 00:11:37,760
means this node has index NL the index
 

541
00:11:37,760 --> 00:11:41,150
means this node has index NL the index
of this node is NL and so if I equals

542
00:11:41,150 --> 00:11:41,160
of this node is NL and so if I equals
 

543
00:11:41,160 --> 00:11:42,790
of this node is NL and so if I equals
the if the one index we're looking for

544
00:11:42,790 --> 00:11:42,800
the if the one index we're looking for
 

545
00:11:42,800 --> 00:11:44,470
the if the one index we're looking for
is that one then we just return this

546
00:11:44,470 --> 00:11:44,480
is that one then we just return this
 

547
00:11:44,480 --> 00:11:45,629
is that one then we just return this
node we're

548
00:11:45,629 --> 00:11:45,639
node we're
 

549
00:11:45,639 --> 00:11:48,949
node we're
done and otherwise I is greater than NL

550
00:11:48,949 --> 00:11:48,959
done and otherwise I is greater than NL
 

551
00:11:48,959 --> 00:11:50,310
done and otherwise I is greater than NL
and that means that the node we're

552
00:11:50,310 --> 00:11:50,320
and that means that the node we're
 

553
00:11:50,320 --> 00:11:52,790
and that means that the node we're
looking for is in the right sub tree

554
00:11:52,790 --> 00:11:52,800
looking for is in the right sub tree
 

555
00:11:52,800 --> 00:11:55,430
looking for is in the right sub tree
because it comes after the root again

556
00:11:55,430 --> 00:11:55,440
because it comes after the root again
 

557
00:11:55,440 --> 00:11:56,670
because it comes after the root again
that's what it means that's what

558
00:11:56,670 --> 00:11:56,680
that's what it means that's what
 

559
00:11:56,680 --> 00:11:58,350
that's what it means that's what
traversal order means so if we Define it

560
00:11:58,350 --> 00:11:58,360
traversal order means so if we Define it
 

561
00:11:58,360 --> 00:12:00,629
traversal order means so if we Define it
to be sequence order

562
00:12:00,629 --> 00:12:00,639
to be sequence order
 

563
00:12:00,639 --> 00:12:02,750
to be sequence order
uh then we know all the things that come

564
00:12:02,750 --> 00:12:02,760
uh then we know all the things that come
 

565
00:12:02,760 --> 00:12:05,150
uh then we know all the things that come
after this node which is index NL must

566
00:12:05,150 --> 00:12:05,160
after this node which is index NL must
 

567
00:12:05,160 --> 00:12:07,110
after this node which is index NL must
be over here now when we recurse down

568
00:12:07,110 --> 00:12:07,120
be over here now when we recurse down
 

569
00:12:07,120 --> 00:12:08,990
be over here now when we recurse down
here our numbering system changes

570
00:12:08,990 --> 00:12:09,000
here our numbering system changes
 

571
00:12:09,000 --> 00:12:12,470
here our numbering system changes
because out in for node zero is here and

572
00:12:12,470 --> 00:12:12,480
because out in for node zero is here and
 

573
00:12:12,480 --> 00:12:15,350
because out in for node zero is here and
then for node. right Zer is here so we

574
00:12:15,350 --> 00:12:15,360
then for node. right Zer is here so we
 

575
00:12:15,360 --> 00:12:17,150
then for node. right Zer is here so we
need to do a little bit of subtraction

576
00:12:17,150 --> 00:12:17,160
need to do a little bit of subtraction
 

577
00:12:17,160 --> 00:12:18,629
need to do a little bit of subtraction
here which is when we recurse to the

578
00:12:18,629 --> 00:12:18,639
here which is when we recurse to the
 

579
00:12:18,639 --> 00:12:21,949
here which is when we recurse to the
right we take IUS NL minus one minus NL

580
00:12:21,949 --> 00:12:21,959
right we take IUS NL minus one minus NL
 

581
00:12:21,959 --> 00:12:25,150
right we take IUS NL minus one minus NL
for these guys minus one for the root

582
00:12:25,150 --> 00:12:25,160
for these guys minus one for the root
 

583
00:12:25,160 --> 00:12:27,389
for these guys minus one for the root
node um and that will give us the index

584
00:12:27,389 --> 00:12:27,399
node um and that will give us the index
 

585
00:12:27,399 --> 00:12:30,790
node um and that will give us the index
we're looking for within this sub

586
00:12:30,790 --> 00:12:30,800
we're looking for within this sub
 

587
00:12:30,800 --> 00:12:33,269
we're looking for within this sub
okay so it's my point is this algorithm

588
00:12:33,269 --> 00:12:33,279
okay so it's my point is this algorithm
 

589
00:12:33,279 --> 00:12:35,629
okay so it's my point is this algorithm
is basically the same as this algorithm

590
00:12:35,629 --> 00:12:35,639
is basically the same as this algorithm
 

591
00:12:35,639 --> 00:12:38,269
is basically the same as this algorithm
but this one uses keys because we're

592
00:12:38,269 --> 00:12:38,279
but this one uses keys because we're
 

593
00:12:38,279 --> 00:12:40,389
but this one uses keys because we're
dealing with a set and in sets we assume

594
00:12:40,389 --> 00:12:40,399
dealing with a set and in sets we assume
 

595
00:12:40,399 --> 00:12:42,710
dealing with a set and in sets we assume
items have keys over here we items don't

596
00:12:42,710 --> 00:12:42,720
items have keys over here we items don't
 

597
00:12:42,720 --> 00:12:43,990
items have keys over here we items don't
have to have keys in fact we're not

598
00:12:43,990 --> 00:12:44,000
have to have keys in fact we're not
 

599
00:12:44,000 --> 00:12:45,990
have to have keys in fact we're not
touching the items at all we're just

600
00:12:45,990 --> 00:12:46,000
touching the items at all we're just
 

601
00:12:46,000 --> 00:12:49,829
touching the items at all we're just
asking what is the I item in my sequence

602
00:12:49,829 --> 00:12:49,839
asking what is the I item in my sequence
 

603
00:12:49,839 --> 00:12:51,310
asking what is the I item in my sequence
which is the same thing as what is the I

604
00:12:51,310 --> 00:12:51,320
which is the same thing as what is the I
 

605
00:12:51,320 --> 00:12:52,750
which is the same thing as what is the I
item in my traversal order which is the

606
00:12:52,750 --> 00:12:52,760
item in my traversal order which is the
 

607
00:12:52,760 --> 00:12:55,350
item in my traversal order which is the
same thing as asking what is the I node

608
00:12:55,350 --> 00:12:55,360
same thing as asking what is the I node
 

609
00:12:55,360 --> 00:12:56,990
same thing as asking what is the I node
in the traversal order and this

610
00:12:56,990 --> 00:12:57,000
in the traversal order and this
 

611
00:12:57,000 --> 00:12:58,790
in the traversal order and this
algorithm gives it to you exactly the

612
00:12:58,790 --> 00:12:58,800
algorithm gives it to you exactly the
 

613
00:12:58,800 --> 00:12:59,670
algorithm gives it to you exactly the
same way

614
00:12:59,670 --> 00:12:59,680
same way
 

615
00:12:59,680 --> 00:13:02,670
same way
in order H

616
00:13:02,670 --> 00:13:02,680
in order H
 

617
00:13:02,680 --> 00:13:04,670
in order H
time okay now I'm not going to show you

618
00:13:04,670 --> 00:13:04,680
time okay now I'm not going to show you
 

619
00:13:04,680 --> 00:13:07,030
time okay now I'm not going to show you
all the operations but you can use subt

620
00:13:07,030 --> 00:13:07,040
all the operations but you can use subt
 

621
00:13:07,040 --> 00:13:08,790
all the operations but you can use subt
tree at to

622
00:13:08,790 --> 00:13:08,800
tree at to
 

623
00:13:08,800 --> 00:13:12,430
tree at to
implement uh get at and set at you just

624
00:13:12,430 --> 00:13:12,440
implement uh get at and set at you just
 

625
00:13:12,440 --> 00:13:14,629
implement uh get at and set at you just
find the appropriate node and return the

626
00:13:14,629 --> 00:13:14,639
find the appropriate node and return the
 

627
00:13:14,639 --> 00:13:17,710
find the appropriate node and return the
item or modify the item uh or you can

628
00:13:17,710 --> 00:13:17,720
item or modify the item uh or you can
 

629
00:13:17,720 --> 00:13:20,150
item or modify the item uh or you can
use it to most crucially you can use it

630
00:13:20,150 --> 00:13:20,160
use it to most crucially you can use it
 

631
00:13:20,160 --> 00:13:22,310
use it to most crucially you can use it
to do insert at and delete at this is a

632
00:13:22,310 --> 00:13:22,320
to do insert at and delete at this is a
 

633
00:13:22,320 --> 00:13:23,910
to do insert at and delete at this is a
new thing we've never been able to do

634
00:13:23,910 --> 00:13:23,920
new thing we've never been able to do
 

635
00:13:23,920 --> 00:13:26,790
new thing we've never been able to do
before uh what do you do just like over

636
00:13:26,790 --> 00:13:26,800
before uh what do you do just like over
 

637
00:13:26,800 --> 00:13:29,870
before uh what do you do just like over
here if I'm trying to insert an item I

638
00:13:29,870 --> 00:13:29,880
here if I'm trying to insert an item I
 

639
00:13:29,880 --> 00:13:33,430
here if I'm trying to insert an item I
search for that item over here uh so if

640
00:13:33,430 --> 00:13:33,440
search for that item over here uh so if
 

641
00:13:33,440 --> 00:13:35,550
search for that item over here uh so if
I'm trying to insert at I for example I

642
00:13:35,550 --> 00:13:35,560
I'm trying to insert at I for example I
 

643
00:13:35,560 --> 00:13:39,430
I'm trying to insert at I for example I
look for I and then

644
00:13:39,430 --> 00:13:39,440
look for I and then
 

645
00:13:39,440 --> 00:13:42,870
look for I and then
uh for insert at I I want to add a new

646
00:13:42,870 --> 00:13:42,880
uh for insert at I I want to add a new
 

647
00:13:42,880 --> 00:13:45,310
uh for insert at I I want to add a new
item just before that one and

648
00:13:45,310 --> 00:13:45,320
item just before that one and
 

649
00:13:45,320 --> 00:13:48,230
item just before that one and
conveniently we already have I didn't

650
00:13:48,230 --> 00:13:48,240
conveniently we already have I didn't
 

651
00:13:48,240 --> 00:13:51,069
conveniently we already have I didn't
mention but we have a subtree insert we

652
00:13:51,069 --> 00:13:51,079
mention but we have a subtree insert we
 

653
00:13:51,079 --> 00:13:54,829
mention but we have a subtree insert we
had two versions before and

654
00:13:54,829 --> 00:13:54,839

 

655
00:13:54,839 --> 00:13:57,350

after I think we cover it

656
00:13:57,350 --> 00:13:57,360
after I think we cover it
 

657
00:13:57,360 --> 00:14:00,030
after I think we cover it
after which is success before use

658
00:14:00,030 --> 00:14:00,040
after which is success before use
 

659
00:14:00,040 --> 00:14:03,350
after which is success before use
predecessor uh but we can just call

660
00:14:03,350 --> 00:14:03,360
predecessor uh but we can just call
 

661
00:14:03,360 --> 00:14:06,710
predecessor uh but we can just call
subtree insert before at that node and

662
00:14:06,710 --> 00:14:06,720
subtree insert before at that node and
 

663
00:14:06,720 --> 00:14:10,310
subtree insert before at that node and
boom we will have added a new item just

664
00:14:10,310 --> 00:14:10,320
boom we will have added a new item just
 

665
00:14:10,320 --> 00:14:14,389
boom we will have added a new item just
before it um and great so magically

666
00:14:14,389 --> 00:14:14,399
before it um and great so magically
 

667
00:14:14,399 --> 00:14:16,389
before it um and great so magically
somehow uh we have inserted in the

668
00:14:16,389 --> 00:14:16,399
somehow uh we have inserted in the
 

669
00:14:16,399 --> 00:14:18,949
somehow uh we have inserted in the
middle of the sequence and all of the

670
00:14:18,949 --> 00:14:18,959
middle of the sequence and all of the
 

671
00:14:18,959 --> 00:14:22,230
middle of the sequence and all of the
indices update because I'm not storing

672
00:14:22,230 --> 00:14:22,240
indices update because I'm not storing
 

673
00:14:22,240 --> 00:14:24,749
indices update because I'm not storing
indices instead I'm to search for an

674
00:14:24,749 --> 00:14:24,759
indices instead I'm to search for an
 

675
00:14:24,759 --> 00:14:27,870
indices instead I'm to search for an
item at index I I'm using the search

676
00:14:27,870 --> 00:14:27,880
item at index I I'm using the search
 

677
00:14:27,880 --> 00:14:29,710
item at index I I'm using the search
algorithm but

678
00:14:29,710 --> 00:14:29,720
algorithm but
 

679
00:14:29,720 --> 00:14:35,470
algorithm but
there's a problem what's the

680
00:14:35,470 --> 00:14:35,480

 

681
00:14:35,480 --> 00:14:37,749

problem this seems a little too good to

682
00:14:37,749 --> 00:14:37,759
problem this seems a little too good to
 

683
00:14:37,759 --> 00:14:38,470
problem this seems a little too good to
be

684
00:14:38,470 --> 00:14:38,480
be
 

685
00:14:38,480 --> 00:14:41,550
be
true I insert in the middle of this tree

686
00:14:41,550 --> 00:14:41,560
true I insert in the middle of this tree
 

687
00:14:41,560 --> 00:14:43,829
true I insert in the middle of this tree
and then somehow I can magically search

688
00:14:43,829 --> 00:14:43,839
and then somehow I can magically search
 

689
00:14:43,839 --> 00:14:46,069
and then somehow I can magically search
and still find the I item even though

690
00:14:46,069 --> 00:14:46,079
and still find the I item even though
 

691
00:14:46,079 --> 00:14:47,550
and still find the I item even though
all the indices to the right of that

692
00:14:47,550 --> 00:14:47,560
all the indices to the right of that
 

693
00:14:47,560 --> 00:14:51,550
all the indices to the right of that
item incremented by

694
00:14:51,550 --> 00:14:51,560

 

695
00:14:51,560 --> 00:14:57,110

one it's almost true question

696
00:14:57,110 --> 00:14:57,120

 

697
00:14:57,120 --> 00:14:59,710

answer yeah

698
00:14:59,710 --> 00:14:59,720
answer yeah
 

699
00:14:59,720 --> 00:15:01,590
answer yeah
because we have to update the SI because

700
00:15:01,590 --> 00:15:01,600
because we have to update the SI because
 

701
00:15:01,600 --> 00:15:03,230
because we have to update the SI because
we have to update the sizes right I

702
00:15:03,230 --> 00:15:03,240
we have to update the sizes right I
 

703
00:15:03,240 --> 00:15:05,350
we have to update the sizes right I
didn't say how do I compute the size of

704
00:15:05,350 --> 00:15:05,360
didn't say how do I compute the size of
 

705
00:15:05,360 --> 00:15:10,910
didn't say how do I compute the size of
the left sub tree so that is the next

706
00:15:10,910 --> 00:15:10,920

 

707
00:15:10,920 --> 00:15:13,590

topic we're almost done this this will

708
00:15:13,590 --> 00:15:13,600
topic we're almost done this this will
 

709
00:15:13,600 --> 00:15:16,870
topic we're almost done this this will
actually work it's really quite awesome

710
00:15:16,870 --> 00:15:16,880
actually work it's really quite awesome
 

711
00:15:16,880 --> 00:15:18,829
actually work it's really quite awesome
but uh for it to work we need something

712
00:15:18,829 --> 00:15:18,839
but uh for it to work we need something
 

713
00:15:18,839 --> 00:15:21,590
but uh for it to work we need something
called sub tree

714
00:15:21,590 --> 00:15:21,600
called sub tree
 

715
00:15:21,600 --> 00:15:23,430
called sub tree
augmentation which I'll talk about

716
00:15:23,430 --> 00:15:23,440
augmentation which I'll talk about
 

717
00:15:23,440 --> 00:15:25,189
augmentation which I'll talk about
generally and then we'll apply it to

718
00:15:25,189 --> 00:15:25,199
generally and then we'll apply it to
 

719
00:15:25,199 --> 00:15:30,309
generally and then we'll apply it to
size

720
00:15:30,309 --> 00:15:30,319

 

721
00:15:30,319 --> 00:15:33,030

so the idea with subtree augmentation is

722
00:15:33,030 --> 00:15:33,040
so the idea with subtree augmentation is
 

723
00:15:33,040 --> 00:15:37,870
so the idea with subtree augmentation is
that uh each node in our binary tree uh

724
00:15:37,870 --> 00:15:37,880
that uh each node in our binary tree uh
 

725
00:15:37,880 --> 00:15:39,269
that uh each node in our binary tree uh
can

726
00:15:39,269 --> 00:15:39,279
can
 

727
00:15:39,279 --> 00:15:44,150
can
store uh constant number of extra

728
00:15:44,150 --> 00:15:44,160
store uh constant number of extra
 

729
00:15:44,160 --> 00:15:45,949
store uh constant number of extra
Fields why

730
00:15:45,949 --> 00:15:45,959
Fields why
 

731
00:15:45,959 --> 00:15:49,670
Fields why
not and in particular if these fields

732
00:15:49,670 --> 00:15:49,680
not and in particular if these fields
 

733
00:15:49,680 --> 00:15:51,910
not and in particular if these fields
are of a particular type or maybe I'll

734
00:15:51,910 --> 00:15:51,920
are of a particular type or maybe I'll
 

735
00:15:51,920 --> 00:15:56,749
are of a particular type or maybe I'll
call them

736
00:15:56,749 --> 00:15:56,759

 

737
00:15:56,759 --> 00:15:59,189

properties I'm going to define a a

738
00:15:59,189 --> 00:15:59,199
properties I'm going to define a a
 

739
00:15:59,199 --> 00:16:07,990
properties I'm going to define a a
subtree

740
00:16:07,990 --> 00:16:08,000

 

741
00:16:08,000 --> 00:16:20,389

property uh to be something that can be

742
00:16:20,389 --> 00:16:20,399

 

743
00:16:20,399 --> 00:16:23,069

computed from the

744
00:16:23,069 --> 00:16:23,079
computed from the
 

745
00:16:23,079 --> 00:16:27,670
computed from the
properties of the nodes

746
00:16:27,670 --> 00:16:27,680

 

747
00:16:27,680 --> 00:16:36,230

children so I should say this is of a

748
00:16:36,230 --> 00:16:36,240

 

749
00:16:36,240 --> 00:16:40,910

node so children are node. left and no.

750
00:16:40,910 --> 00:16:40,920
node so children are node. left and no.
 

751
00:16:40,920 --> 00:16:43,870
node so children are node. left and no.
right uh you can also access constant

752
00:16:43,870 --> 00:16:43,880
right uh you can also access constant
 

753
00:16:43,880 --> 00:16:45,430
right uh you can also access constant
amount of other stuff for example the

754
00:16:45,430 --> 00:16:45,440
amount of other stuff for example the
 

755
00:16:45,440 --> 00:16:46,389
amount of other stuff for example the
node

756
00:16:46,389 --> 00:16:46,399
node
 

757
00:16:46,399 --> 00:16:48,749
node
itself uh but the point of a subtree

758
00:16:48,749 --> 00:16:48,759
itself uh but the point of a subtree
 

759
00:16:48,759 --> 00:16:50,790
itself uh but the point of a subtree
property is it's downward looking if I

760
00:16:50,790 --> 00:16:50,800
property is it's downward looking if I
 

761
00:16:50,800 --> 00:16:52,189
property is it's downward looking if I
have a

762
00:16:52,189 --> 00:16:52,199
have a
 

763
00:16:52,199 --> 00:16:54,110
have a
node

764
00:16:54,110 --> 00:16:54,120
node
 

765
00:16:54,120 --> 00:16:55,949
node
here

766
00:16:55,949 --> 00:16:55,959
here
 

767
00:16:55,959 --> 00:16:59,389
here
and I want to compute some property

768
00:16:59,389 --> 00:16:59,399
and I want to compute some property
 

769
00:16:59,399 --> 00:17:04,110
and I want to compute some property
about it call it uh we want to store P

770
00:17:04,110 --> 00:17:04,120
about it call it uh we want to store P
 

771
00:17:04,120 --> 00:17:08,350
about it call it uh we want to store P
of the node and suppose we already know

772
00:17:08,350 --> 00:17:08,360
of the node and suppose we already know
 

773
00:17:08,360 --> 00:17:10,909
of the node and suppose we already know
p over here the property computed for

774
00:17:10,909 --> 00:17:10,919
p over here the property computed for
 

775
00:17:10,919 --> 00:17:13,069
p over here the property computed for
the left subtree or for the left node

776
00:17:13,069 --> 00:17:13,079
the left subtree or for the left node
 

777
00:17:13,079 --> 00:17:14,990
the left subtree or for the left node
and we already know the property for the

778
00:17:14,990 --> 00:17:15,000
and we already know the property for the
 

779
00:17:15,000 --> 00:17:18,350
and we already know the property for the
right node then uh what I'd like is for

780
00:17:18,350 --> 00:17:18,360
right node then uh what I'd like is for
 

781
00:17:18,360 --> 00:17:25,189
right node then uh what I'd like is for
this to be computable in constant

782
00:17:25,189 --> 00:17:25,199

 

783
00:17:25,199 --> 00:17:28,350

time so I can compute P of this node

784
00:17:28,350 --> 00:17:28,360
time so I can compute P of this node
 

785
00:17:28,360 --> 00:17:30,270
time so I can compute P of this node
given P of the left node and P of the

786
00:17:30,270 --> 00:17:30,280
given P of the left node and P of the
 

787
00:17:30,280 --> 00:17:32,350
given P of the left node and P of the
right node that's a sub tree property

788
00:17:32,350 --> 00:17:32,360
right node that's a sub tree property
 

789
00:17:32,360 --> 00:17:33,230
right node that's a sub tree property
now in

790
00:17:33,230 --> 00:17:33,240
now in
 

791
00:17:33,240 --> 00:17:37,549
now in
particular size is a sub tree

792
00:17:37,549 --> 00:17:37,559
particular size is a sub tree
 

793
00:17:37,559 --> 00:17:40,190
particular size is a sub tree
property why

794
00:17:40,190 --> 00:17:40,200
property why
 

795
00:17:40,200 --> 00:17:42,669
property why
because I can write this kind of

796
00:17:42,669 --> 00:17:42,679
because I can write this kind of
 

797
00:17:42,679 --> 00:17:45,510
because I can write this kind of
recurrence uh node.

798
00:17:45,510 --> 00:17:45,520
recurrence uh node.
 

799
00:17:45,520 --> 00:17:48,630
recurrence uh node.
size equals no do left do

800
00:17:48,630 --> 00:17:48,640
size equals no do left do
 

801
00:17:48,640 --> 00:17:51,590
size equals no do left do
size is very tedious to

802
00:17:51,590 --> 00:17:51,600
size is very tedious to
 

803
00:17:51,600 --> 00:18:02,830
size is very tedious to
write plus no do right. size

804
00:18:02,830 --> 00:18:02,840

 

805
00:18:02,840 --> 00:18:05,430

plus one thank

806
00:18:05,430 --> 00:18:05,440
plus one thank
 

807
00:18:05,440 --> 00:18:08,510
plus one thank
you size of the sub of the entire sub

808
00:18:08,510 --> 00:18:08,520
you size of the sub of the entire sub
 

809
00:18:08,520 --> 00:18:12,029
you size of the sub of the entire sub
tree here called node um is the size of

810
00:18:12,029 --> 00:18:12,039
tree here called node um is the size of
 

811
00:18:12,039 --> 00:18:13,310
tree here called node um is the size of
the left sub tree plus the size of the

812
00:18:13,310 --> 00:18:13,320
the left sub tree plus the size of the
 

813
00:18:13,320 --> 00:18:16,110
the left sub tree plus the size of the
right sub tree plus one for that node

814
00:18:16,110 --> 00:18:16,120
right sub tree plus one for that node
 

815
00:18:16,120 --> 00:18:19,110
right sub tree plus one for that node
itself okay so this is an update rule

816
00:18:19,110 --> 00:18:19,120
itself okay so this is an update rule
 

817
00:18:19,120 --> 00:18:21,950
itself okay so this is an update rule
takes constant time to evaluate it's two

818
00:18:21,950 --> 00:18:21,960
takes constant time to evaluate it's two
 

819
00:18:21,960 --> 00:18:24,270
takes constant time to evaluate it's two
additions sorry my T's look kind of like

820
00:18:24,270 --> 00:18:24,280
additions sorry my T's look kind of like
 

821
00:18:24,280 --> 00:18:26,909
additions sorry my T's look kind of like
plus

822
00:18:26,909 --> 00:18:26,919

 

823
00:18:26,919 --> 00:18:34,510

signs make the pluses a little

824
00:18:34,510 --> 00:18:34,520

 

825
00:18:34,520 --> 00:18:37,029

bigger okay so we're summing those three

826
00:18:37,029 --> 00:18:37,039
bigger okay so we're summing those three
 

827
00:18:37,039 --> 00:18:41,149
bigger okay so we're summing those three
things boom we can get node do size so I

828
00:18:41,149 --> 00:18:41,159
things boom we can get node do size so I
 

829
00:18:41,159 --> 00:18:45,430
things boom we can get node do size so I
claim that uh if as long as my property

830
00:18:45,430 --> 00:18:45,440
claim that uh if as long as my property
 

831
00:18:45,440 --> 00:18:48,230
claim that uh if as long as my property
has this feature I can maintain it

832
00:18:48,230 --> 00:18:48,240
has this feature I can maintain it
 

833
00:18:48,240 --> 00:18:50,430
has this feature I can maintain it
dynamically as I'm changing the

834
00:18:50,430 --> 00:18:50,440
dynamically as I'm changing the
 

835
00:18:50,440 --> 00:18:53,390
dynamically as I'm changing the
tree okay now this is a little bit of a

836
00:18:53,390 --> 00:18:53,400
tree okay now this is a little bit of a
 

837
00:18:53,400 --> 00:18:54,549
tree okay now this is a little bit of a
forward reference because we haven't

838
00:18:54,549 --> 00:18:54,559
forward reference because we haven't
 

839
00:18:54,559 --> 00:18:55,750
forward reference because we haven't
said exactly how we're going to change

840
00:18:55,750 --> 00:18:55,760
said exactly how we're going to change
 

841
00:18:55,760 --> 00:18:59,669
said exactly how we're going to change
the tree yet but uh question if um no SI

842
00:18:59,669 --> 00:18:59,679
the tree yet but uh question if um no SI
 

843
00:18:59,679 --> 00:19:04,590
the tree yet but uh question if um no SI
is recursive yeah how is it happen would

844
00:19:04,590 --> 00:19:04,600
is recursive yeah how is it happen would
 

845
00:19:04,600 --> 00:19:07,630
is recursive yeah how is it happen would
okay why is this okay good question so

846
00:19:07,630 --> 00:19:07,640
okay why is this okay good question so
 

847
00:19:07,640 --> 00:19:09,470
okay why is this okay good question so
one natural way you can think of this as

848
00:19:09,470 --> 00:19:09,480
one natural way you can think of this as
 

849
00:19:09,480 --> 00:19:11,549
one natural way you can think of this as
a recursion which gives you a recursive

850
00:19:11,549 --> 00:19:11,559
a recursion which gives you a recursive
 

851
00:19:11,559 --> 00:19:14,230
a recursion which gives you a recursive
algorithm uh so I wrote but I didn't

852
00:19:14,230 --> 00:19:14,240
algorithm uh so I wrote but I didn't
 

853
00:19:14,240 --> 00:19:15,990
algorithm uh so I wrote but I didn't
write it but I could have written size

854
00:19:15,990 --> 00:19:16,000
write it but I could have written size
 

855
00:19:16,000 --> 00:19:19,310
write it but I could have written size
of node equals this size of node. left

856
00:19:19,310 --> 00:19:19,320
of node equals this size of node. left
 

857
00:19:19,320 --> 00:19:20,710
of node equals this size of node. left
plus and that would give you a linear

858
00:19:20,710 --> 00:19:20,720
plus and that would give you a linear
 

859
00:19:20,720 --> 00:19:23,270
plus and that would give you a linear
time algorithm to count the size and if

860
00:19:23,270 --> 00:19:23,280
time algorithm to count the size and if
 

861
00:19:23,280 --> 00:19:25,669
time algorithm to count the size and if
you don't have any information that

862
00:19:25,669 --> 00:19:25,679
you don't have any information that
 

863
00:19:25,679 --> 00:19:27,710
you don't have any information that
is what you would do and that would be

864
00:19:27,710 --> 00:19:27,720
is what you would do and that would be
 

865
00:19:27,720 --> 00:19:28,990
is what you would do and that would be
very painful so that would would make

866
00:19:28,990 --> 00:19:29,000
very painful so that would would make
 

867
00:19:29,000 --> 00:19:30,549
very painful so that would would make
this algorithm really slow if I'm

868
00:19:30,549 --> 00:19:30,559
this algorithm really slow if I'm
 

869
00:19:30,559 --> 00:19:32,710
this algorithm really slow if I'm
calling sizes a recursive function it's

870
00:19:32,710 --> 00:19:32,720
calling sizes a recursive function it's
 

871
00:19:32,720 --> 00:19:35,669
calling sizes a recursive function it's
bad uh what I'm instead doing is storing

872
00:19:35,669 --> 00:19:35,679
bad uh what I'm instead doing is storing
 

873
00:19:35,679 --> 00:19:37,870
bad uh what I'm instead doing is storing
the sizes on every single

874
00:19:37,870 --> 00:19:37,880
the sizes on every single
 

875
00:19:37,880 --> 00:19:41,830
the sizes on every single
node okay and precomputing this so in

876
00:19:41,830 --> 00:19:41,840
node okay and precomputing this so in
 

877
00:19:41,840 --> 00:19:45,710
node okay and precomputing this so in
fact I'm going to Define uh size of node

878
00:19:45,710 --> 00:19:45,720
fact I'm going to Define uh size of node
 

879
00:19:45,720 --> 00:19:47,549
fact I'm going to Define uh size of node
in so this is the definition

880
00:19:47,549 --> 00:19:47,559
in so this is the definition
 

881
00:19:47,559 --> 00:19:49,390
in so this is the definition
mathematically but the algorithm for

882
00:19:49,390 --> 00:19:49,400
mathematically but the algorithm for
 

883
00:19:49,400 --> 00:19:51,470
mathematically but the algorithm for
this function is just going to be return

884
00:19:51,470 --> 00:19:51,480
this function is just going to be return
 

885
00:19:51,480 --> 00:19:55,630
this function is just going to be return
node. size okay so that's constant time

886
00:19:55,630 --> 00:19:55,640
node. size okay so that's constant time
 

887
00:19:55,640 --> 00:19:57,430
node. size okay so that's constant time
so I the challenge now is I have to keep

888
00:19:57,430 --> 00:19:57,440
so I the challenge now is I have to keep
 

889
00:19:57,440 --> 00:19:59,149
so I the challenge now is I have to keep
these sizes up to dat no matter what I

890
00:19:59,149 --> 00:19:59,159
these sizes up to dat no matter what I
 

891
00:19:59,159 --> 00:20:01,630
these sizes up to dat no matter what I
do to the tree and you could look back

892
00:20:01,630 --> 00:20:01,640
do to the tree and you could look back
 

893
00:20:01,640 --> 00:20:03,390
do to the tree and you could look back
at last lecture and see okay what were

894
00:20:03,390 --> 00:20:03,400
at last lecture and see okay what were
 

895
00:20:03,400 --> 00:20:06,510
at last lecture and see okay what were
all the changes that I did in a tree uh

896
00:20:06,510 --> 00:20:06,520
all the changes that I did in a tree uh
 

897
00:20:06,520 --> 00:20:08,750
all the changes that I did in a tree uh
we only did changes during insert and

898
00:20:08,750 --> 00:20:08,760
we only did changes during insert and
 

899
00:20:08,760 --> 00:20:12,549
we only did changes during insert and
delete and I will just claim to you when

900
00:20:12,549 --> 00:20:12,559
delete and I will just claim to you when
 

901
00:20:12,559 --> 00:20:15,990
delete and I will just claim to you when
we did uh insert and

902
00:20:15,990 --> 00:20:16,000
we did uh insert and
 

903
00:20:16,000 --> 00:20:18,710
we did uh insert and
delete what they ended up

904
00:20:18,710 --> 00:20:18,720
delete what they ended up
 

905
00:20:18,720 --> 00:20:21,789
delete what they ended up
doing uh in the

906
00:20:21,789 --> 00:20:21,799
doing uh in the
 

907
00:20:21,799 --> 00:20:26,590
doing uh in the
end they add or

908
00:20:26,590 --> 00:20:26,600
end they add or
 

909
00:20:26,600 --> 00:20:33,830
end they add or
remove a leaf of the

910
00:20:33,830 --> 00:20:33,840

 

911
00:20:33,840 --> 00:20:36,070

tree okay remember Leaf was a node with

912
00:20:36,070 --> 00:20:36,080
tree okay remember Leaf was a node with
 

913
00:20:36,080 --> 00:20:40,190
tree okay remember Leaf was a node with
no children um so let's just think about

914
00:20:40,190 --> 00:20:40,200
no children um so let's just think about
 

915
00:20:40,200 --> 00:20:42,990
no children um so let's just think about
if I add a new Leaf in a tree here's a

916
00:20:42,990 --> 00:20:43,000
if I add a new Leaf in a tree here's a
 

917
00:20:43,000 --> 00:20:45,909
if I add a new Leaf in a tree here's a
tree suppose I add a leaf here which sub

918
00:20:45,909 --> 00:20:45,919
tree suppose I add a leaf here which sub
 

919
00:20:45,919 --> 00:20:47,230
tree suppose I add a leaf here which sub
trees

920
00:20:47,230 --> 00:20:47,240
trees
 

921
00:20:47,240 --> 00:20:51,350
trees
change well which sub trees contain that

922
00:20:51,350 --> 00:20:51,360
change well which sub trees contain that
 

923
00:20:51,360 --> 00:20:54,230
change well which sub trees contain that
node it it is its own new sub tree then

924
00:20:54,230 --> 00:20:54,240
node it it is its own new sub tree then
 

925
00:20:54,240 --> 00:20:56,390
node it it is its own new sub tree then
its parents it's in it's in its parents

926
00:20:56,390 --> 00:20:56,400
its parents it's in it's in its parents
 

927
00:20:56,400 --> 00:20:58,430
its parents it's in it's in its parents
sub tree and its grandparents sub tree

928
00:20:58,430 --> 00:20:58,440
sub tree and its grandparents sub tree
 

929
00:20:58,440 --> 00:21:00,990
sub tree and its grandparents sub tree
and and the overall sub tree okay in

930
00:21:00,990 --> 00:21:01,000
and and the overall sub tree okay in
 

931
00:21:01,000 --> 00:21:03,270
and and the overall sub tree okay in
general these nodes are called the

932
00:21:03,270 --> 00:21:03,280
general these nodes are called the
 

933
00:21:03,280 --> 00:21:06,549
general these nodes are called the
ancestors of this node that we added and

934
00:21:06,549 --> 00:21:06,559
ancestors of this node that we added and
 

935
00:21:06,559 --> 00:21:08,310
ancestors of this node that we added and
those are the ones that update this sub

936
00:21:08,310 --> 00:21:08,320
those are the ones that update this sub
 

937
00:21:08,320 --> 00:21:10,710
those are the ones that update this sub
tree over here didn't change it didn't

938
00:21:10,710 --> 00:21:10,720
tree over here didn't change it didn't
 

939
00:21:10,720 --> 00:21:13,390
tree over here didn't change it didn't
change size and because it's a sub tree

940
00:21:13,390 --> 00:21:13,400
change size and because it's a sub tree
 

941
00:21:13,400 --> 00:21:15,110
change size and because it's a sub tree
property no subtree property will change

942
00:21:15,110 --> 00:21:15,120
property no subtree property will change
 

943
00:21:15,120 --> 00:21:17,149
property no subtree property will change
over here because the sub tree was

944
00:21:17,149 --> 00:21:17,159
over here because the sub tree was
 

945
00:21:17,159 --> 00:21:20,110
over here because the sub tree was
untouched okay so

946
00:21:20,110 --> 00:21:20,120
untouched okay so
 

947
00:21:20,120 --> 00:21:22,710
untouched okay so
um when I touch this guy I just have to

948
00:21:22,710 --> 00:21:22,720
um when I touch this guy I just have to
 

949
00:21:22,720 --> 00:21:24,870
um when I touch this guy I just have to
update the sub tree property here update

950
00:21:24,870 --> 00:21:24,880
update the sub tree property here update
 

951
00:21:24,880 --> 00:21:26,230
update the sub tree property here update
the subtree property here update the

952
00:21:26,230 --> 00:21:26,240
the subtree property here update the
 

953
00:21:26,240 --> 00:21:27,710
the subtree property here update the
subtree property here how many of these

954
00:21:27,710 --> 00:21:27,720
subtree property here how many of these
 

955
00:21:27,720 --> 00:21:32,789
subtree property here how many of these
are there

956
00:21:32,789 --> 00:21:32,799

 

957
00:21:32,799 --> 00:21:36,669

yeah H I'll say order H to be safe but I

958
00:21:36,669 --> 00:21:36,679
yeah H I'll say order H to be safe but I
 

959
00:21:36,679 --> 00:21:40,870
yeah H I'll say order H to be safe but I
think it's exactly H um so also when I

960
00:21:40,870 --> 00:21:40,880
think it's exactly H um so also when I
 

961
00:21:40,880 --> 00:21:43,149
think it's exactly H um so also when I
remove a leaf the same thing if I remove

962
00:21:43,149 --> 00:21:43,159
remove a leaf the same thing if I remove
 

963
00:21:43,159 --> 00:21:44,830
remove a leaf the same thing if I remove
this Leaf then the the sub trees that

964
00:21:44,830 --> 00:21:44,840
this Leaf then the the sub trees that
 

965
00:21:44,840 --> 00:21:48,630
this Leaf then the the sub trees that
change are exactly its former

966
00:21:48,630 --> 00:21:48,640

 

967
00:21:48,640 --> 00:21:50,510

ancestors

968
00:21:50,510 --> 00:21:50,520
ancestors
 

969
00:21:50,520 --> 00:21:54,750
ancestors
uh cool so

970
00:21:54,750 --> 00:21:54,760
uh cool so
 

971
00:21:54,760 --> 00:21:59,350
uh cool so
um we're going to update those order

972
00:21:59,350 --> 00:21:59,360
um we're going to update those order
 

973
00:21:59,360 --> 00:22:05,110
um we're going to update those order
H uh

974
00:22:05,110 --> 00:22:05,120

 

975
00:22:05,120 --> 00:22:09,669

ancestors um in

976
00:22:09,669 --> 00:22:09,679
ancestors um in
 

977
00:22:09,679 --> 00:22:12,630
ancestors um in
order up the

978
00:22:12,630 --> 00:22:12,640
order up the
 

979
00:22:12,640 --> 00:22:16,909
order up the
tree so what do I mean by update I mean

980
00:22:16,909 --> 00:22:16,919
tree so what do I mean by update I mean
 

981
00:22:16,919 --> 00:22:20,950
tree so what do I mean by update I mean
apply this rule for sub for size it's

982
00:22:20,950 --> 00:22:20,960
apply this rule for sub for size it's
 

983
00:22:20,960 --> 00:22:23,149
apply this rule for sub for size it's
this rule but for in general the subtree

984
00:22:23,149 --> 00:22:23,159
this rule but for in general the subtree
 

985
00:22:23,159 --> 00:22:24,669
this rule but for in general the subtree
property gives me an update rule that

986
00:22:24,669 --> 00:22:24,679
property gives me an update rule that
 

987
00:22:24,679 --> 00:22:27,070
property gives me an update rule that
takes constant time and so I'm going to

988
00:22:27,070 --> 00:22:27,080
takes constant time and so I'm going to
 

989
00:22:27,080 --> 00:22:30,110
takes constant time and so I'm going to
apply that update rule to this node

990
00:22:30,110 --> 00:22:30,120
apply that update rule to this node
 

991
00:22:30,120 --> 00:22:32,190
apply that update rule to this node
which will fix whatever property is

992
00:22:32,190 --> 00:22:32,200
which will fix whatever property is
 

993
00:22:32,200 --> 00:22:34,230
which will fix whatever property is
stored in there maybe there's more than

994
00:22:34,230 --> 00:22:34,240
stored in there maybe there's more than
 

995
00:22:34,240 --> 00:22:35,990
stored in there maybe there's more than
one property and then I'll apply it to

996
00:22:35,990 --> 00:22:36,000
one property and then I'll apply it to
 

997
00:22:36,000 --> 00:22:38,029
one property and then I'll apply it to
this node and because this is already

998
00:22:38,029 --> 00:22:38,039
this node and because this is already
 

999
00:22:38,039 --> 00:22:40,870
this node and because this is already
correct by induction and this is already

1000
00:22:40,870 --> 00:22:40,880
correct by induction and this is already
 

1001
00:22:40,880 --> 00:22:42,390
correct by induction and this is already
correct because I didn't touch this

1002
00:22:42,390 --> 00:22:42,400
correct because I didn't touch this
 

1003
00:22:42,400 --> 00:22:45,390
correct because I didn't touch this
subre it's unchanged then I can update

1004
00:22:45,390 --> 00:22:45,400
subre it's unchanged then I can update
 

1005
00:22:45,400 --> 00:22:47,470
subre it's unchanged then I can update
the value at this node the property at

1006
00:22:47,470 --> 00:22:47,480
the value at this node the property at
 

1007
00:22:47,480 --> 00:22:49,909
the value at this node the property at
this node in constant time then I update

1008
00:22:49,909 --> 00:22:49,919
this node in constant time then I update
 

1009
00:22:49,919 --> 00:22:52,470
this node in constant time then I update
this one and because this one is already

1010
00:22:52,470 --> 00:22:52,480
this one and because this one is already
 

1011
00:22:52,480 --> 00:22:54,390
this one and because this one is already
correct by induction and this one is

1012
00:22:54,390 --> 00:22:54,400
correct by induction and this one is
 

1013
00:22:54,400 --> 00:22:55,710
correct by induction and this one is
already correct because this sub tree is

1014
00:22:55,710 --> 00:22:55,720
already correct because this sub tree is
 

1015
00:22:55,720 --> 00:22:58,029
already correct because this sub tree is
unchanged I can update the property

1016
00:22:58,029 --> 00:22:58,039
unchanged I can update the property
 

1017
00:22:58,039 --> 00:23:00,590
unchanged I can update the property
correctly here in constant time okay so

1018
00:23:00,590 --> 00:23:00,600
correctly here in constant time okay so
 

1019
00:23:00,600 --> 00:23:03,149
correctly here in constant time okay so
when I make a change in order H time

1020
00:23:03,149 --> 00:23:03,159
when I make a change in order H time
 

1021
00:23:03,159 --> 00:23:04,990
when I make a change in order H time
because I'm making H calls to this

1022
00:23:04,990 --> 00:23:05,000
because I'm making H calls to this
 

1023
00:23:05,000 --> 00:23:07,269
because I'm making H calls to this
constant time algorithm I can update a

1024
00:23:07,269 --> 00:23:07,279
constant time algorithm I can update a
 

1025
00:23:07,279 --> 00:23:10,590
constant time algorithm I can update a
constant number of sub tree

1026
00:23:10,590 --> 00:23:10,600
constant number of sub tree
 

1027
00:23:10,600 --> 00:23:12,750
constant number of sub tree
properties this is very powerful data

1028
00:23:12,750 --> 00:23:12,760
properties this is very powerful data
 

1029
00:23:12,760 --> 00:23:14,549
properties this is very powerful data
structure argumentation is super useful

1030
00:23:14,549 --> 00:23:14,559
structure argumentation is super useful
 

1031
00:23:14,559 --> 00:23:16,190
structure argumentation is super useful
you will use it on your problem set we

1032
00:23:16,190 --> 00:23:16,200
you will use it on your problem set we
 

1033
00:23:16,200 --> 00:23:17,990
you will use it on your problem set we
will use it again

1034
00:23:17,990 --> 00:23:18,000
will use it again
 

1035
00:23:18,000 --> 00:23:21,310
will use it again
today let me give you some examples of

1036
00:23:21,310 --> 00:23:21,320
today let me give you some examples of
 

1037
00:23:21,320 --> 00:23:27,070
today let me give you some examples of
sub tree

1038
00:23:27,070 --> 00:23:27,080

 

1039
00:23:27,080 --> 00:23:30,190

properties they could would be uh common

1040
00:23:30,190 --> 00:23:30,200
properties they could would be uh common
 

1041
00:23:30,200 --> 00:23:35,310
properties they could would be uh common
ones are like the sum or the product or

1042
00:23:35,310 --> 00:23:35,320
ones are like the sum or the product or
 

1043
00:23:35,320 --> 00:23:39,789
ones are like the sum or the product or
the Min or the

1044
00:23:39,789 --> 00:23:39,799

 

1045
00:23:39,799 --> 00:23:42,990

max or sum of squares or all sorts of

1046
00:23:42,990 --> 00:23:43,000
max or sum of squares or all sorts of
 

1047
00:23:43,000 --> 00:23:45,470
max or sum of squares or all sorts of
things of

1048
00:23:45,470 --> 00:23:45,480
things of
 

1049
00:23:45,480 --> 00:23:49,190
things of
some

1050
00:23:49,190 --> 00:23:49,200

 

1051
00:23:49,200 --> 00:23:56,669

feature of every node in

1052
00:23:56,669 --> 00:23:56,679

 

1053
00:23:56,679 --> 00:23:59,230

subtree okay in fact

1054
00:23:59,230 --> 00:23:59,240
subtree okay in fact
 

1055
00:23:59,240 --> 00:24:01,110
subtree okay in fact
uh sub tree size is an example of such a

1056
00:24:01,110 --> 00:24:01,120
uh sub tree size is an example of such a
 

1057
00:24:01,120 --> 00:24:03,230
uh sub tree size is an example of such a
thing it is the sum over all nodes in

1058
00:24:03,230 --> 00:24:03,240
thing it is the sum over all nodes in
 

1059
00:24:03,240 --> 00:24:05,909
thing it is the sum over all nodes in
the sub tree of the value one okay

1060
00:24:05,909 --> 00:24:05,919
the sub tree of the value one okay
 

1061
00:24:05,919 --> 00:24:07,149
the sub tree of the value one okay
that's another way to say count the

1062
00:24:07,149 --> 00:24:07,159
that's another way to say count the
 

1063
00:24:07,159 --> 00:24:09,149
that's another way to say count the
number of nodes okay but you could also

1064
00:24:09,149 --> 00:24:09,159
number of nodes okay but you could also
 

1065
00:24:09,159 --> 00:24:11,350
number of nodes okay but you could also
say what's the sum of the keys in these

1066
00:24:11,350 --> 00:24:11,360
say what's the sum of the keys in these
 

1067
00:24:11,360 --> 00:24:12,789
say what's the sum of the keys in these
nodes or you could say what's the

1068
00:24:12,789 --> 00:24:12,799
nodes or you could say what's the
 

1069
00:24:12,799 --> 00:24:14,630
nodes or you could say what's the
maximum key in these nodes or you could

1070
00:24:14,630 --> 00:24:14,640
maximum key in these nodes or you could
 

1071
00:24:14,640 --> 00:24:16,789
maximum key in these nodes or you could
say

1072
00:24:16,789 --> 00:24:16,799
say
 

1073
00:24:16,799 --> 00:24:19,750
say
uh um what is the

1074
00:24:19,750 --> 00:24:19,760
uh um what is the
 

1075
00:24:19,760 --> 00:24:21,950
uh um what is the
maximum value in these notes you can

1076
00:24:21,950 --> 00:24:21,960
maximum value in these notes you can
 

1077
00:24:21,960 --> 00:24:23,470
maximum value in these notes you can
take any property it doesn't have to be

1078
00:24:23,470 --> 00:24:23,480
take any property it doesn't have to be
 

1079
00:24:23,480 --> 00:24:25,029
take any property it doesn't have to be
key it doesn't have to be anything in

1080
00:24:25,029 --> 00:24:25,039
key it doesn't have to be anything in
 

1081
00:24:25,039 --> 00:24:26,830
key it doesn't have to be anything in
particular it's very powerful you can

1082
00:24:26,830 --> 00:24:26,840
particular it's very powerful you can
 

1083
00:24:26,840 --> 00:24:28,669
particular it's very powerful you can
take all sums products and Main maintain

1084
00:24:28,669 --> 00:24:28,679
take all sums products and Main maintain
 

1085
00:24:28,679 --> 00:24:30,269
take all sums products and Main maintain
them as long as they're downward looking

1086
00:24:30,269 --> 00:24:30,279
them as long as they're downward looking
 

1087
00:24:30,279 --> 00:24:31,430
them as long as they're downward looking
as long as you're only thinking about

1088
00:24:31,430 --> 00:24:31,440
as long as you're only thinking about
 

1089
00:24:31,440 --> 00:24:32,389
as long as you're only thinking about
the sub

1090
00:24:32,389 --> 00:24:32,399
the sub
 

1091
00:24:32,399 --> 00:24:35,590
the sub
tree okay uh some examples of things you

1092
00:24:35,590 --> 00:24:35,600
tree okay uh some examples of things you
 

1093
00:24:35,600 --> 00:24:37,389
tree okay uh some examples of things you
cannot

1094
00:24:37,389 --> 00:24:37,399
cannot
 

1095
00:24:37,399 --> 00:24:40,950
cannot
maintain

1096
00:24:40,950 --> 00:24:40,960

 

1097
00:24:40,960 --> 00:24:43,510

are

1098
00:24:43,510 --> 00:24:43,520
are
 

1099
00:24:43,520 --> 00:24:47,430
are
not a nodes

1100
00:24:47,430 --> 00:24:47,440

 

1101
00:24:47,440 --> 00:24:50,310

index so if you get a little bit too

1102
00:24:50,310 --> 00:24:50,320
index so if you get a little bit too
 

1103
00:24:50,320 --> 00:24:51,909
index so if you get a little bit too
excited about augmentation you might

1104
00:24:51,909 --> 00:24:51,919
excited about augmentation you might
 

1105
00:24:51,919 --> 00:24:54,149
excited about augmentation you might
think oh it could do everything right I

1106
00:24:54,149 --> 00:24:54,159
think oh it could do everything right I
 

1107
00:24:54,159 --> 00:24:56,789
think oh it could do everything right I
needed to support subtree at or let's

1108
00:24:56,789 --> 00:24:56,799
needed to support subtree at or let's
 

1109
00:24:56,799 --> 00:24:59,389
needed to support subtree at or let's
just say uh get at globally I wanted to

1110
00:24:59,389 --> 00:24:59,399
just say uh get at globally I wanted to
 

1111
00:24:59,399 --> 00:25:01,990
just say uh get at globally I wanted to
know what is the I node in my tree well

1112
00:25:01,990 --> 00:25:02,000
know what is the I node in my tree well
 

1113
00:25:02,000 --> 00:25:03,070
know what is the I node in my tree well
I'll just use data structure

1114
00:25:03,070 --> 00:25:03,080
I'll just use data structure
 

1115
00:25:03,080 --> 00:25:04,909
I'll just use data structure
augumentation and store in every node

1116
00:25:04,909 --> 00:25:04,919
augumentation and store in every node
 

1117
00:25:04,919 --> 00:25:08,310
augumentation and store in every node
what is its index zero through n minus

1118
00:25:08,310 --> 00:25:08,320
what is its index zero through n minus
 

1119
00:25:08,320 --> 00:25:11,470
what is its index zero through n minus
one I can't maintain that efficiently

1120
00:25:11,470 --> 00:25:11,480
one I can't maintain that efficiently
 

1121
00:25:11,480 --> 00:25:14,149
one I can't maintain that efficiently
because if I insert at the beginning of

1122
00:25:14,149 --> 00:25:14,159
because if I insert at the beginning of
 

1123
00:25:14,159 --> 00:25:17,070
because if I insert at the beginning of
my traversal order then all the indices

1124
00:25:17,070 --> 00:25:17,080
my traversal order then all the indices
 

1125
00:25:17,080 --> 00:25:19,269
my traversal order then all the indices
change right so that that's an example

1126
00:25:19,269 --> 00:25:19,279
change right so that that's an example
 

1127
00:25:19,279 --> 00:25:22,430
change right so that that's an example
of a of a edit so if I insert a new Noe

1128
00:25:22,430 --> 00:25:22,440
of a of a edit so if I insert a new Noe
 

1129
00:25:22,440 --> 00:25:25,029
of a of a edit so if I insert a new Noe
over here so this guy's index was Zero

1130
00:25:25,029 --> 00:25:25,039
over here so this guy's index was Zero
 

1131
00:25:25,039 --> 00:25:26,909
over here so this guy's index was Zero
now it's one this guy's index was one

1132
00:25:26,909 --> 00:25:26,919
now it's one this guy's index was one
 

1133
00:25:26,919 --> 00:25:28,789
now it's one this guy's index was one
now it's two this was two two now it's

1134
00:25:28,789 --> 00:25:28,799
now it's two this was two two now it's
 

1135
00:25:28,799 --> 00:25:30,510
now it's two this was two two now it's
three and so on every node changes its

1136
00:25:30,510 --> 00:25:30,520
three and so on every node changes its
 

1137
00:25:30,520 --> 00:25:33,389
three and so on every node changes its
index index is not a subtree property

1138
00:25:33,389 --> 00:25:33,399
index index is not a subtree property
 

1139
00:25:33,399 --> 00:25:35,350
index index is not a subtree property
and that's why we can't maintain it

1140
00:25:35,350 --> 00:25:35,360
and that's why we can't maintain it
 

1141
00:25:35,360 --> 00:25:37,070
and that's why we can't maintain it
because it depends on all of the nodes

1142
00:25:37,070 --> 00:25:37,080
because it depends on all of the nodes
 

1143
00:25:37,080 --> 00:25:38,389
because it depends on all of the nodes
in the tree or it depends on all the

1144
00:25:38,389 --> 00:25:38,399
in the tree or it depends on all the
 

1145
00:25:38,399 --> 00:25:40,750
in the tree or it depends on all the
nodes to its left all the predecessors

1146
00:25:40,750 --> 00:25:40,760
nodes to its left all the predecessors
 

1147
00:25:40,760 --> 00:25:43,430
nodes to its left all the predecessors
so for example this guy's index depends

1148
00:25:43,430 --> 00:25:43,440
so for example this guy's index depends
 

1149
00:25:43,440 --> 00:25:45,070
so for example this guy's index depends
on how many nodes are over here on the

1150
00:25:45,070 --> 00:25:45,080
on how many nodes are over here on the
 

1151
00:25:45,080 --> 00:25:46,870
on how many nodes are over here on the
left which is not in the sub tree of

1152
00:25:46,870 --> 00:25:46,880
left which is not in the sub tree of
 

1153
00:25:46,880 --> 00:25:49,350
left which is not in the sub tree of
that Noe so that's where you have to be

1154
00:25:49,350 --> 00:25:49,360
that Noe so that's where you have to be
 

1155
00:25:49,360 --> 00:25:51,710
that Noe so that's where you have to be
careful don't use Global properties of

1156
00:25:51,710 --> 00:25:51,720
careful don't use Global properties of
 

1157
00:25:51,720 --> 00:25:54,149
careful don't use Global properties of
the tree you can only use

1158
00:25:54,149 --> 00:25:54,159
the tree you can only use
 

1159
00:25:54,159 --> 00:25:56,430
the tree you can only use
subtree sub tree

1160
00:25:56,430 --> 00:25:56,440
subtree sub tree
 

1161
00:25:56,440 --> 00:26:00,870
subtree sub tree
properties okay another example is uh

1162
00:26:00,870 --> 00:26:00,880
properties okay another example is uh
 

1163
00:26:00,880 --> 00:26:04,990
properties okay another example is uh
depth depth is annoying to

1164
00:26:04,990 --> 00:26:05,000
depth depth is annoying to
 

1165
00:26:05,000 --> 00:26:08,190
depth depth is annoying to
maintain uh but it's not obvious why yet

1166
00:26:08,190 --> 00:26:08,200
maintain uh but it's not obvious why yet
 

1167
00:26:08,200 --> 00:26:12,350
maintain uh but it's not obvious why yet
we will see that in a

1168
00:26:12,350 --> 00:26:12,360

 

1169
00:26:12,360 --> 00:26:16,389

moment okay the rest of today is about

1170
00:26:16,389 --> 00:26:16,399
moment okay the rest of today is about
 

1171
00:26:16,399 --> 00:26:21,710
moment okay the rest of today is about
going from order H to order log n which

1172
00:26:21,710 --> 00:26:21,720
going from order H to order log n which
 

1173
00:26:21,720 --> 00:26:24,510
going from order H to order log n which
is what this slide is showing us so at

1174
00:26:24,510 --> 00:26:24,520
is what this slide is showing us so at
 

1175
00:26:24,520 --> 00:26:25,630
is what this slide is showing us so at
this point you should believe that we

1176
00:26:25,630 --> 00:26:25,640
this point you should believe that we
 

1177
00:26:25,640 --> 00:26:27,870
this point you should believe that we
can do all of the sequence data

1178
00:26:27,870 --> 00:26:27,880
can do all of the sequence data
 

1179
00:26:27,880 --> 00:26:30,149
can do all of the sequence data
structure operations in order H time

1180
00:26:30,149 --> 00:26:30,159
structure operations in order H time
 

1181
00:26:30,159 --> 00:26:31,549
structure operations in order H time
except for build and iterate which take

1182
00:26:31,549 --> 00:26:31,559
except for build and iterate which take
 

1183
00:26:31,559 --> 00:26:34,310
except for build and iterate which take
linear time uh and that we can do all of

1184
00:26:34,310 --> 00:26:34,320
linear time uh and that we can do all of
 

1185
00:26:34,320 --> 00:26:36,750
linear time uh and that we can do all of
the set operations in order H time

1186
00:26:36,750 --> 00:26:36,760
the set operations in order H time
 

1187
00:26:36,760 --> 00:26:38,630
the set operations in order H time
except build and iterate which Take N

1188
00:26:38,630 --> 00:26:38,640
except build and iterate which Take N
 

1189
00:26:38,640 --> 00:26:41,870
except build and iterate which Take N
log n and n respectively and our goal is

1190
00:26:41,870 --> 00:26:41,880
log n and n respectively and our goal is
 

1191
00:26:41,880 --> 00:26:44,830
log n and n respectively and our goal is
to now

1192
00:26:44,830 --> 00:26:44,840
to now
 

1193
00:26:44,840 --> 00:26:47,909
to now
bound

1194
00:26:47,909 --> 00:26:47,919

 

1195
00:26:47,919 --> 00:26:53,070

uh H by log n we know it's possible at

1196
00:26:53,070 --> 00:26:53,080
uh H by log n we know it's possible at
 

1197
00:26:53,080 --> 00:26:54,990
uh H by log n we know it's possible at
some level because there are

1198
00:26:54,990 --> 00:26:55,000
some level because there are
 

1199
00:26:55,000 --> 00:26:57,549
some level because there are
trees that have logarithmic height

1200
00:26:57,549 --> 00:26:57,559
trees that have logarithmic height
 

1201
00:26:57,559 --> 00:26:59,590
trees that have logarithmic height
that's like this Perfect Tree

1202
00:26:59,590 --> 00:26:59,600
that's like this Perfect Tree
 

1203
00:26:59,600 --> 00:27:01,830
that's like this Perfect Tree
here but we also know we have to be

1204
00:27:01,830 --> 00:27:01,840
here but we also know we have to be
 

1205
00:27:01,840 --> 00:27:03,549
here but we also know we have to be
careful because there are some bad trees

1206
00:27:03,549 --> 00:27:03,559
careful because there are some bad trees
 

1207
00:27:03,559 --> 00:27:06,149
careful because there are some bad trees
like this

1208
00:27:06,149 --> 00:27:06,159

 

1209
00:27:06,159 --> 00:27:08,950

chain so

1210
00:27:08,950 --> 00:27:08,960
chain so
 

1211
00:27:08,960 --> 00:27:13,430
chain so
um if H equals log n we call this a

1212
00:27:13,430 --> 00:27:13,440
um if H equals log n we call this a
 

1213
00:27:13,440 --> 00:27:18,430
um if H equals log n we call this a
balanced binary

1214
00:27:18,430 --> 00:27:18,440

 

1215
00:27:18,440 --> 00:27:20,789

tree there are many balanced binary

1216
00:27:20,789 --> 00:27:20,799
tree there are many balanced binary
 

1217
00:27:20,799 --> 00:27:23,549
tree there are many balanced binary
trees in the world maybe a dozen or

1218
00:27:23,549 --> 00:27:23,559
trees in the world maybe a dozen or
 

1219
00:27:23,559 --> 00:27:25,830
trees in the world maybe a dozen or
two a lot of different data structures

1220
00:27:25,830 --> 00:27:25,840
two a lot of different data structures
 

1221
00:27:25,840 --> 00:27:29,350
two a lot of different data structures
question hi you um you said like not to

1222
00:27:29,350 --> 00:27:29,360
question hi you um you said like not to
 

1223
00:27:29,360 --> 00:27:31,269
question hi you um you said like not to
think about things on a global level

1224
00:27:31,269 --> 00:27:31,279
think about things on a global level
 

1225
00:27:31,279 --> 00:27:32,750
think about things on a global level
think of them at a sub level can you

1226
00:27:32,750 --> 00:27:32,760
think of them at a sub level can you
 

1227
00:27:32,760 --> 00:27:33,950
think of them at a sub level can you
explain what

1228
00:27:33,950 --> 00:27:33,960
explain what
 

1229
00:27:33,960 --> 00:27:36,510
explain what
that okay what does it mean for property

1230
00:27:36,510 --> 00:27:36,520
that okay what does it mean for property
 

1231
00:27:36,520 --> 00:27:39,549
that okay what does it mean for property
to be uh local to a sub tree versus

1232
00:27:39,549 --> 00:27:39,559
to be uh local to a sub tree versus
 

1233
00:27:39,559 --> 00:27:42,269
to be uh local to a sub tree versus
global the best answer is this

1234
00:27:42,269 --> 00:27:42,279
global the best answer is this
 

1235
00:27:42,279 --> 00:27:44,310
global the best answer is this
definition but that's maybe not the most

1236
00:27:44,310 --> 00:27:44,320
definition but that's maybe not the most
 

1237
00:27:44,320 --> 00:27:45,950
definition but that's maybe not the most
intuitive definition this is what I mean

1238
00:27:45,950 --> 00:27:45,960
intuitive definition this is what I mean
 

1239
00:27:45,960 --> 00:27:47,870
intuitive definition this is what I mean
something that can be computed just

1240
00:27:47,870 --> 00:27:47,880
something that can be computed just
 

1241
00:27:47,880 --> 00:27:49,350
something that can be computed just
knowing information about your left and

1242
00:27:49,350 --> 00:27:49,360
knowing information about your left and
 

1243
00:27:49,360 --> 00:27:51,310
knowing information about your left and
right children that is the meaning of

1244
00:27:51,310 --> 00:27:51,320
right children that is the meaning of
 

1245
00:27:51,320 --> 00:27:52,830
right children that is the meaning of
subre property and those are the only

1246
00:27:52,830 --> 00:27:52,840
subre property and those are the only
 

1247
00:27:52,840 --> 00:27:54,350
subre property and those are the only
things you're allowed to maintain

1248
00:27:54,350 --> 00:27:54,360
things you're allowed to maintain
 

1249
00:27:54,360 --> 00:27:55,870
things you're allowed to maintain
because those are the only

1250
00:27:55,870 --> 00:27:55,880
because those are the only
 

1251
00:27:55,880 --> 00:27:58,789
because those are the only
things uh that are easy to update by

1252
00:27:58,789 --> 00:27:58,799
things uh that are easy to update by
 

1253
00:27:58,799 --> 00:28:01,870
things uh that are easy to update by
walking up this path and the contrast is

1254
00:28:01,870 --> 00:28:01,880
walking up this path and the contrast is
 

1255
00:28:01,880 --> 00:28:04,630
walking up this path and the contrast is
that a global property like

1256
00:28:04,630 --> 00:28:04,640
that a global property like
 

1257
00:28:04,640 --> 00:28:07,509
that a global property like
index I it's Global in particular

1258
00:28:07,509 --> 00:28:07,519
index I it's Global in particular
 

1259
00:28:07,519 --> 00:28:10,470
index I it's Global in particular
because I can do one change add one no

1260
00:28:10,470 --> 00:28:10,480
because I can do one change add one no
 

1261
00:28:10,480 --> 00:28:12,509
because I can do one change add one no
node and all of the nodes properties

1262
00:28:12,509 --> 00:28:12,519
node and all of the nodes properties
 

1263
00:28:12,519 --> 00:28:14,430
node and all of the nodes properties
change so that's an extreme example of

1264
00:28:14,430 --> 00:28:14,440
change so that's an extreme example of
 

1265
00:28:14,440 --> 00:28:16,830
change so that's an extreme example of
global we want this very particular

1266
00:28:16,830 --> 00:28:16,840
global we want this very particular
 

1267
00:28:16,840 --> 00:28:18,310
global we want this very particular
notion of

1268
00:28:18,310 --> 00:28:18,320
notion of
 

1269
00:28:18,320 --> 00:28:21,190
notion of
local uh because that's what we can

1270
00:28:21,190 --> 00:28:21,200
local uh because that's what we can
 

1271
00:28:21,200 --> 00:28:23,830
local uh because that's what we can
actually afford to recompute hopefully

1272
00:28:23,830 --> 00:28:23,840
actually afford to recompute hopefully
 

1273
00:28:23,840 --> 00:28:26,110
actually afford to recompute hopefully
that clarifies

1274
00:28:26,110 --> 00:28:26,120
that clarifies
 

1275
00:28:26,120 --> 00:28:31,710
that clarifies
yeah doesn't size

1276
00:28:31,710 --> 00:28:31,720

 

1277
00:28:31,720 --> 00:28:34,070

you're right that if we added oh no

1278
00:28:34,070 --> 00:28:34,080
you're right that if we added oh no
 

1279
00:28:34,080 --> 00:28:35,669
you're right that if we added oh no
let's okay let's think about that if we

1280
00:28:35,669 --> 00:28:35,679
let's okay let's think about that if we
 

1281
00:28:35,679 --> 00:28:37,430
let's okay let's think about that if we
added a new parent to the tree this is

1282
00:28:37,430 --> 00:28:37,440
added a new parent to the tree this is
 

1283
00:28:37,440 --> 00:28:40,630
added a new parent to the tree this is
not something that we've ever done um

1284
00:28:40,630 --> 00:28:40,640
not something that we've ever done um
 

1285
00:28:40,640 --> 00:28:43,509
not something that we've ever done um
but even if we did that which sub trees

1286
00:28:43,509 --> 00:28:43,519
but even if we did that which sub trees
 

1287
00:28:43,519 --> 00:28:46,509
but even if we did that which sub trees
change only this

1288
00:28:46,509 --> 00:28:46,519
change only this
 

1289
00:28:46,519 --> 00:28:49,149
change only this
one right this node it's it's a new

1290
00:28:49,149 --> 00:28:49,159
one right this node it's it's a new
 

1291
00:28:49,159 --> 00:28:51,070
one right this node it's it's a new
totally new sub tree but the sub tree of

1292
00:28:51,070 --> 00:28:51,080
totally new sub tree but the sub tree of
 

1293
00:28:51,080 --> 00:28:52,909
totally new sub tree but the sub tree of
this node is completely unchanged

1294
00:28:52,909 --> 00:28:52,919
this node is completely unchanged
 

1295
00:28:52,919 --> 00:28:54,070
this node is completely unchanged
because sub trees are always downward

1296
00:28:54,070 --> 00:28:54,080
because sub trees are always downward
 

1297
00:28:54,080 --> 00:28:57,149
because sub trees are always downward
looking if I added a new root um I

1298
00:28:57,149 --> 00:28:57,159
looking if I added a new root um I
 

1299
00:28:57,159 --> 00:29:00,110
looking if I added a new root um I
didn't change any sub except for one so

1300
00:29:00,110 --> 00:29:00,120
didn't change any sub except for one so
 

1301
00:29:00,120 --> 00:29:03,630
didn't change any sub except for one so
size is a sube property now there are I

1302
00:29:03,630 --> 00:29:03,640
size is a sube property now there are I
 

1303
00:29:03,640 --> 00:29:05,549
size is a sube property now there are I
mean I can completely redraw the tree

1304
00:29:05,549 --> 00:29:05,559
mean I can completely redraw the tree
 

1305
00:29:05,559 --> 00:29:07,149
mean I can completely redraw the tree
and that's an operation that requires

1306
00:29:07,149 --> 00:29:07,159
and that's an operation that requires
 

1307
00:29:07,159 --> 00:29:09,149
and that's an operation that requires
everything to be recomputed okay so it

1308
00:29:09,149 --> 00:29:09,159
everything to be recomputed okay so it
 

1309
00:29:09,159 --> 00:29:10,750
everything to be recomputed okay so it
is limited exactly what I'm allowed to

1310
00:29:10,750 --> 00:29:10,760
is limited exactly what I'm allowed to
 

1311
00:29:10,760 --> 00:29:12,630
is limited exactly what I'm allowed to
do in the tree but I claim everything

1312
00:29:12,630 --> 00:29:12,640
do in the tree but I claim everything
 

1313
00:29:12,640 --> 00:29:16,149
do in the tree but I claim everything
will do last class and today uh we can

1314
00:29:16,149 --> 00:29:16,159
will do last class and today uh we can
 

1315
00:29:16,159 --> 00:29:17,310
will do last class and today uh we can
afford this

1316
00:29:17,310 --> 00:29:17,320
afford this
 

1317
00:29:17,320 --> 00:29:19,990
afford this
augmentation so it's a feature not of

1318
00:29:19,990 --> 00:29:20,000
augmentation so it's a feature not of
 

1319
00:29:20,000 --> 00:29:21,669
augmentation so it's a feature not of
all binary trees necessarily but the

1320
00:29:21,669 --> 00:29:21,679
all binary trees necessarily but the
 

1321
00:29:21,679 --> 00:29:23,350
all binary trees necessarily but the
ones that we would cover

1322
00:29:23,350 --> 00:29:23,360
ones that we would cover
 

1323
00:29:23,360 --> 00:29:25,990
ones that we would cover
yeah what is a

1324
00:29:25,990 --> 00:29:26,000
yeah what is a
 

1325
00:29:26,000 --> 00:29:30,590
yeah what is a
Min binary binary tree

1326
00:29:30,590 --> 00:29:30,600

 

1327
00:29:30,600 --> 00:29:33,149

yeah okay let's uh this will make a

1328
00:29:33,149 --> 00:29:33,159
yeah okay let's uh this will make a
 

1329
00:29:33,159 --> 00:29:36,190
yeah okay let's uh this will make a
little more sense in a moment when I say

1330
00:29:36,190 --> 00:29:36,200
little more sense in a moment when I say
 

1331
00:29:36,200 --> 00:29:45,430
little more sense in a moment when I say
what we're actually going to do with

1332
00:29:45,430 --> 00:29:45,440

 

1333
00:29:45,440 --> 00:29:48,029

trees we

1334
00:29:48,029 --> 00:29:48,039
trees we
 

1335
00:29:48,039 --> 00:29:52,909
trees we
uh we need a new tool for manipulating a

1336
00:29:52,909 --> 00:29:52,919
uh we need a new tool for manipulating a
 

1337
00:29:52,919 --> 00:29:55,149
uh we need a new tool for manipulating a
tree what we've done so far we've done

1338
00:29:55,149 --> 00:29:55,159
tree what we've done so far we've done
 

1339
00:29:55,159 --> 00:29:58,110
tree what we've done so far we've done
some swapping of items and we did adding

1340
00:29:58,110 --> 00:29:58,120
some swapping of items and we did adding
 

1341
00:29:58,120 --> 00:30:00,110
some swapping of items and we did adding
removing a leaf that's not enough we're

1342
00:30:00,110 --> 00:30:00,120
removing a leaf that's not enough we're
 

1343
00:30:00,120 --> 00:30:01,990
removing a leaf that's not enough we're
going to need something else to let us

1344
00:30:01,990 --> 00:30:02,000
going to need something else to let us
 

1345
00:30:02,000 --> 00:30:04,430
going to need something else to let us
guarantee logarithmic

1346
00:30:04,430 --> 00:30:04,440
guarantee logarithmic
 

1347
00:30:04,440 --> 00:30:06,710
guarantee logarithmic
height and that's something else is

1348
00:30:06,710 --> 00:30:06,720
height and that's something else is
 

1349
00:30:06,720 --> 00:30:11,110
height and that's something else is
called a

1350
00:30:11,110 --> 00:30:11,120

 

1351
00:30:11,120 --> 00:30:13,110

rotation what does this something else

1352
00:30:13,110 --> 00:30:13,120
rotation what does this something else
 

1353
00:30:13,120 --> 00:30:16,750
rotation what does this something else
need to do this is just a tool for

1354
00:30:16,750 --> 00:30:16,760
need to do this is just a tool for
 

1355
00:30:16,760 --> 00:30:19,669
need to do this is just a tool for
rebalancing the tree so it should not

1356
00:30:19,669 --> 00:30:19,679
rebalancing the tree so it should not
 

1357
00:30:19,679 --> 00:30:21,630
rebalancing the tree so it should not
change the data that's represented by

1358
00:30:21,630 --> 00:30:21,640
change the data that's represented by
 

1359
00:30:21,640 --> 00:30:23,549
change the data that's represented by
the tree what is the data represented by

1360
00:30:23,549 --> 00:30:23,559
the tree what is the data represented by
 

1361
00:30:23,559 --> 00:30:26,750
the tree what is the data represented by
the tree traversal order traversal order

1362
00:30:26,750 --> 00:30:26,760
the tree traversal order traversal order
 

1363
00:30:26,760 --> 00:30:28,909
the tree traversal order traversal order
is sacran where not allowed to touch it

1364
00:30:28,909 --> 00:30:28,919
is sacran where not allowed to touch it
 

1365
00:30:28,919 --> 00:30:31,190
is sacran where not allowed to touch it
it's already defined two different ways

1366
00:30:31,190 --> 00:30:31,200
it's already defined two different ways
 

1367
00:30:31,200 --> 00:30:32,669
it's already defined two different ways
depending on whether you're using a set

1368
00:30:32,669 --> 00:30:32,679
depending on whether you're using a set
 

1369
00:30:32,679 --> 00:30:35,950
depending on whether you're using a set
or sequence so we want to modify the

1370
00:30:35,950 --> 00:30:35,960
or sequence so we want to modify the
 

1371
00:30:35,960 --> 00:30:38,029
or sequence so we want to modify the
tree in a way that doesn't modify the

1372
00:30:38,029 --> 00:30:38,039
tree in a way that doesn't modify the
 

1373
00:30:38,039 --> 00:30:40,830
tree in a way that doesn't modify the
traversal order so this we're exploiting

1374
00:30:40,830 --> 00:30:40,840
traversal order so this we're exploiting
 

1375
00:30:40,840 --> 00:30:42,310
traversal order so this we're exploiting
redundancy if you wrote down the

1376
00:30:42,310 --> 00:30:42,320
redundancy if you wrote down the
 

1377
00:30:42,320 --> 00:30:44,110
redundancy if you wrote down the
traversal order in an array there's

1378
00:30:44,110 --> 00:30:44,120
traversal order in an array there's
 

1379
00:30:44,120 --> 00:30:45,950
traversal order in an array there's
exactly one representation of a given

1380
00:30:45,950 --> 00:30:45,960
exactly one representation of a given
 

1381
00:30:45,960 --> 00:30:48,350
exactly one representation of a given
order but in a tree there's many

1382
00:30:48,350 --> 00:30:48,360
order but in a tree there's many
 

1383
00:30:48,360 --> 00:30:50,870
order but in a tree there's many
representations it could be a long line

1384
00:30:50,870 --> 00:30:50,880
representations it could be a long line
 

1385
00:30:50,880 --> 00:30:52,870
representations it could be a long line
it could be a balanced thing they could

1386
00:30:52,870 --> 00:30:52,880
it could be a balanced thing they could
 

1387
00:30:52,880 --> 00:30:54,430
it could be a balanced thing they could
represent the exact same order on the

1388
00:30:54,430 --> 00:30:54,440
represent the exact same order on the
 

1389
00:30:54,440 --> 00:30:56,669
represent the exact same order on the
nodes if you label them right okay in

1390
00:30:56,669 --> 00:30:56,679
nodes if you label them right okay in
 

1391
00:30:56,679 --> 00:30:58,389
nodes if you label them right okay in
fact they're exponentially many

1392
00:30:58,389 --> 00:30:58,399
fact they're exponentially many
 

1393
00:30:58,399 --> 00:30:59,789
fact they're exponentially many
different representations of the same

1394
00:30:59,789 --> 00:30:59,799
different representations of the same
 

1395
00:30:59,799 --> 00:31:01,629
different representations of the same
thing and we're going to exploit that

1396
00:31:01,629 --> 00:31:01,639
thing and we're going to exploit that
 

1397
00:31:01,639 --> 00:31:02,950
thing and we're going to exploit that
the same

1398
00:31:02,950 --> 00:31:02,960
the same
 

1399
00:31:02,960 --> 00:31:05,669
the same
order and Define this is just a thing

1400
00:31:05,669 --> 00:31:05,679
order and Define this is just a thing
 

1401
00:31:05,679 --> 00:31:20,110
order and Define this is just a thing
you need to

1402
00:31:20,110 --> 00:31:20,120

 

1403
00:31:20,120 --> 00:31:26,149

know me label a x b y

1404
00:31:26,149 --> 00:31:26,159
know me label a x b y
 

1405
00:31:26,159 --> 00:31:28,990
know me label a x b y
c you can tell I've drawn this diagram

1406
00:31:28,990 --> 00:31:29,000
c you can tell I've drawn this diagram
 

1407
00:31:29,000 --> 00:31:32,389
c you can tell I've drawn this diagram
before many many times this is a very

1408
00:31:32,389 --> 00:31:32,399
before many many times this is a very
 

1409
00:31:32,399 --> 00:31:34,389
before many many times this is a very
powerful tool in all tree data

1410
00:31:34,389 --> 00:31:34,399
powerful tool in all tree data
 

1411
00:31:34,399 --> 00:31:35,950
powerful tool in all tree data
structures which are most of data

1412
00:31:35,950 --> 00:31:35,960
structures which are most of data
 

1413
00:31:35,960 --> 00:31:42,470
structures which are most of data
structures uh and they are called right

1414
00:31:42,470 --> 00:31:42,480

 

1415
00:31:42,480 --> 00:31:52,669

rotate of Y and left rotate of

1416
00:31:52,669 --> 00:31:52,679

 

1417
00:31:52,679 --> 00:31:56,070

x uh so if I have this tree which I'm

1418
00:31:56,070 --> 00:31:56,080
x uh so if I have this tree which I'm
 

1419
00:31:56,080 --> 00:31:58,350
x uh so if I have this tree which I'm
just blackboxing some of the sub into

1420
00:31:58,350 --> 00:31:58,360
just blackboxing some of the sub into
 

1421
00:31:58,360 --> 00:32:01,230
just blackboxing some of the sub into
little triangles if I have a node and it

1422
00:32:01,230 --> 00:32:01,240
little triangles if I have a node and it
 

1423
00:32:01,240 --> 00:32:03,990
little triangles if I have a node and it
it has a left child then I'm allowed to

1424
00:32:03,990 --> 00:32:04,000
it has a left child then I'm allowed to
 

1425
00:32:04,000 --> 00:32:05,590
it has a left child then I'm allowed to
right rotate this Edge which means take

1426
00:32:05,590 --> 00:32:05,600
right rotate this Edge which means take
 

1427
00:32:05,600 --> 00:32:08,430
right rotate this Edge which means take
this Edge and go like this 90 Dees kind

1428
00:32:08,430 --> 00:32:08,440
this Edge and go like this 90 Dees kind
 

1429
00:32:08,440 --> 00:32:10,310
this Edge and go like this 90 Dees kind
of uh or you could just think of it as

1430
00:32:10,310 --> 00:32:10,320
of uh or you could just think of it as
 

1431
00:32:10,320 --> 00:32:12,230
of uh or you could just think of it as
rewriting it this way now you might also

1432
00:32:12,230 --> 00:32:12,240
rewriting it this way now you might also
 

1433
00:32:12,240 --> 00:32:14,269
rewriting it this way now you might also
keep in track of the parent pointer

1434
00:32:14,269 --> 00:32:14,279
keep in track of the parent pointer
 

1435
00:32:14,279 --> 00:32:17,149
keep in track of the parent pointer
parent pointer uh moves around before

1436
00:32:17,149 --> 00:32:17,159
parent pointer uh moves around before
 

1437
00:32:17,159 --> 00:32:19,070
parent pointer uh moves around before
this was the parent of Y now it's the

1438
00:32:19,070 --> 00:32:19,080
this was the parent of Y now it's the
 

1439
00:32:19,080 --> 00:32:20,110
this was the parent of Y now it's the
parent of

1440
00:32:20,110 --> 00:32:20,120
parent of
 

1441
00:32:20,120 --> 00:32:23,389
parent of
X okay so we X and Y are switching

1442
00:32:23,389 --> 00:32:23,399
X okay so we X and Y are switching
 

1443
00:32:23,399 --> 00:32:26,590
X okay so we X and Y are switching
places but if we we couldn't just swap

1444
00:32:26,590 --> 00:32:26,600
places but if we we couldn't just swap
 

1445
00:32:26,600 --> 00:32:28,710
places but if we we couldn't just swap
these items around that would change

1446
00:32:28,710 --> 00:32:28,720
these items around that would change
 

1447
00:32:28,720 --> 00:32:31,629
these items around that would change
traversal order in this picture X comes

1448
00:32:31,629 --> 00:32:31,639
traversal order in this picture X comes
 

1449
00:32:31,639 --> 00:32:34,389
traversal order in this picture X comes
before y because X is in the left sub

1450
00:32:34,389 --> 00:32:34,399
before y because X is in the left sub
 

1451
00:32:34,399 --> 00:32:37,350
before y because X is in the left sub
tree of Y in traversal order and over

1452
00:32:37,350 --> 00:32:37,360
tree of Y in traversal order and over
 

1453
00:32:37,360 --> 00:32:39,950
tree of Y in traversal order and over
here now Y is in the right sub tree of X

1454
00:32:39,950 --> 00:32:39,960
here now Y is in the right sub tree of X
 

1455
00:32:39,960 --> 00:32:42,590
here now Y is in the right sub tree of X
so it comes after X so in both cases X

1456
00:32:42,590 --> 00:32:42,600
so it comes after X so in both cases X
 

1457
00:32:42,600 --> 00:32:45,149
so it comes after X so in both cases X
comes before Y and indeed in all of

1458
00:32:45,149 --> 00:32:45,159
comes before Y and indeed in all of
 

1459
00:32:45,159 --> 00:32:46,029
comes before Y and indeed in all of
these

1460
00:32:46,029 --> 00:32:46,039
these
 

1461
00:32:46,039 --> 00:32:48,830
these
pictures uh the traversal order I mean

1462
00:32:48,830 --> 00:32:48,840
pictures uh the traversal order I mean
 

1463
00:32:48,840 --> 00:32:50,629
pictures uh the traversal order I mean
not just for X and Y but also for a b

1464
00:32:50,629 --> 00:32:50,639
not just for X and Y but also for a b
 

1465
00:32:50,639 --> 00:32:53,269
not just for X and Y but also for a b
and c the traversal order is consistent

1466
00:32:53,269 --> 00:32:53,279
and c the traversal order is consistent
 

1467
00:32:53,279 --> 00:32:54,310
and c the traversal order is consistent
it is

1468
00:32:54,310 --> 00:32:54,320
it is
 

1469
00:32:54,320 --> 00:32:59,029
it is
a uh x b

1470
00:32:59,029 --> 00:32:59,039
a uh x b
 

1471
00:32:59,039 --> 00:33:02,310
a uh x b
y c where when I write a triangle I mean

1472
00:33:02,310 --> 00:33:02,320
y c where when I write a triangle I mean
 

1473
00:33:02,320 --> 00:33:03,830
y c where when I write a triangle I mean
recursively the traversal order of all

1474
00:33:03,830 --> 00:33:03,840
recursively the traversal order of all
 

1475
00:33:03,840 --> 00:33:05,950
recursively the traversal order of all
the things in the Triangle so if you

1476
00:33:05,950 --> 00:33:05,960
the things in the Triangle so if you
 

1477
00:33:05,960 --> 00:33:07,710
the things in the Triangle so if you
just apply the traversal order algorithm

1478
00:33:07,710 --> 00:33:07,720
just apply the traversal order algorithm
 

1479
00:33:07,720 --> 00:33:09,830
just apply the traversal order algorithm
here versus here you get the same output

1480
00:33:09,830 --> 00:33:09,840
here versus here you get the same output
 

1481
00:33:09,840 --> 00:33:11,830
here versus here you get the same output
which means these these operations

1482
00:33:11,830 --> 00:33:11,840
which means these these operations
 

1483
00:33:11,840 --> 00:33:17,950
which means these these operations
preserve traversal

1484
00:33:17,950 --> 00:33:17,960

 

1485
00:33:17,960 --> 00:33:21,310

order great so this is a thing that we

1486
00:33:21,310 --> 00:33:21,320
order great so this is a thing that we
 

1487
00:33:21,320 --> 00:33:24,269
order great so this is a thing that we
can do in a tree that won't affect any

1488
00:33:24,269 --> 00:33:24,279
can do in a tree that won't affect any
 

1489
00:33:24,279 --> 00:33:26,669
can do in a tree that won't affect any
of the stuff we've done so far it's a

1490
00:33:26,669 --> 00:33:26,679
of the stuff we've done so far it's a
 

1491
00:33:26,679 --> 00:33:28,870
of the stuff we've done so far it's a
tool that we can used to rebalance

1492
00:33:28,870 --> 00:33:28,880
tool that we can used to rebalance
 

1493
00:33:28,880 --> 00:33:30,389
tool that we can used to rebalance
notice

1494
00:33:30,389 --> 00:33:30,399
notice
 

1495
00:33:30,399 --> 00:33:32,950
notice
um you know how deep things are in the

1496
00:33:32,950 --> 00:33:32,960
um you know how deep things are in the
 

1497
00:33:32,960 --> 00:33:36,110
um you know how deep things are in the
tree changes our problem with this

1498
00:33:36,110 --> 00:33:36,120
tree changes our problem with this
 

1499
00:33:36,120 --> 00:33:38,269
tree changes our problem with this
linear tree is that there are some nodes

1500
00:33:38,269 --> 00:33:38,279
linear tree is that there are some nodes
 

1501
00:33:38,279 --> 00:33:40,029
linear tree is that there are some nodes
of linear depth we want to get rid of

1502
00:33:40,029 --> 00:33:40,039
of linear depth we want to get rid of
 

1503
00:33:40,039 --> 00:33:42,269
of linear depth we want to get rid of
those how we could take these edges and

1504
00:33:42,269 --> 00:33:42,279
those how we could take these edges and
 

1505
00:33:42,279 --> 00:33:44,590
those how we could take these edges and
start rotating them up if you look at

1506
00:33:44,590 --> 00:33:44,600
start rotating them up if you look at
 

1507
00:33:44,600 --> 00:33:48,070
start rotating them up if you look at
depths um you know in this picture A and

1508
00:33:48,070 --> 00:33:48,080
depths um you know in this picture A and
 

1509
00:33:48,080 --> 00:33:51,430
depths um you know in this picture A and
B are deeper than C and in this picture

1510
00:33:51,430 --> 00:33:51,440
B are deeper than C and in this picture
 

1511
00:33:51,440 --> 00:33:53,830
B are deeper than C and in this picture
uh B and C are deeper than a so you know

1512
00:33:53,830 --> 00:33:53,840
uh B and C are deeper than a so you know
 

1513
00:33:53,840 --> 00:33:57,509
uh B and C are deeper than a so you know
there a trade-off this one moved up this

1514
00:33:57,509 --> 00:33:57,519
there a trade-off this one moved up this
 

1515
00:33:57,519 --> 00:33:59,230
there a trade-off this one moved up this
one moved down this one stayed at the

1516
00:33:59,230 --> 00:33:59,240
one moved down this one stayed at the
 

1517
00:33:59,240 --> 00:34:00,110
one moved down this one stayed at the
same

1518
00:34:00,110 --> 00:34:00,120
same
 

1519
00:34:00,120 --> 00:34:04,149
same
depth so hopefully if if a is too deep

1520
00:34:04,149 --> 00:34:04,159
depth so hopefully if if a is too deep
 

1521
00:34:04,159 --> 00:34:07,830
depth so hopefully if if a is too deep
and C is too shallow uh they can trade

1522
00:34:07,830 --> 00:34:07,840
and C is too shallow uh they can trade
 

1523
00:34:07,840 --> 00:34:10,190
and C is too shallow uh they can trade
off like this okay it may sound

1524
00:34:10,190 --> 00:34:10,200
off like this okay it may sound
 

1525
00:34:10,200 --> 00:34:11,430
off like this okay it may sound
difficult but in fact there's a pretty

1526
00:34:11,430 --> 00:34:11,440
difficult but in fact there's a pretty
 

1527
00:34:11,440 --> 00:34:17,389
difficult but in fact there's a pretty
simple way uh which are called AVL

1528
00:34:17,389 --> 00:34:17,399

 

1529
00:34:17,399 --> 00:34:20,149

trees uh that maintain balance in a

1530
00:34:20,149 --> 00:34:20,159
trees uh that maintain balance in a
 

1531
00:34:20,159 --> 00:34:22,510
trees uh that maintain balance in a
particular

1532
00:34:22,510 --> 00:34:22,520
particular
 

1533
00:34:22,520 --> 00:34:34,829
particular
way called height balance

1534
00:34:34,829 --> 00:34:34,839

 

1535
00:34:34,839 --> 00:34:40,389

this is uh if we take the

1536
00:34:40,389 --> 00:34:40,399
this is uh if we take the
 

1537
00:34:40,399 --> 00:34:44,990
this is uh if we take the
height of no dot

1538
00:34:44,990 --> 00:34:45,000

 

1539
00:34:45,000 --> 00:34:48,950

left uh actually I'd prefer

1540
00:34:48,950 --> 00:34:48,960
left uh actually I'd prefer
 

1541
00:34:48,960 --> 00:34:52,750
left uh actually I'd prefer
to no do

1542
00:34:52,750 --> 00:34:52,760

 

1543
00:34:52,760 --> 00:34:54,349

right

1544
00:34:54,349 --> 00:34:54,359
right
 

1545
00:34:54,359 --> 00:35:03,150
right
minus height of node do left

1546
00:35:03,150 --> 00:35:03,160

 

1547
00:35:03,160 --> 00:35:07,190

so this thing is called um

1548
00:35:07,190 --> 00:35:07,200
so this thing is called um
 

1549
00:35:07,200 --> 00:35:10,109
so this thing is called um
skew of the

1550
00:35:10,109 --> 00:35:10,119
skew of the
 

1551
00:35:10,119 --> 00:35:14,230
skew of the
node I want this to always be minus1 0

1552
00:35:14,230 --> 00:35:14,240
node I want this to always be minus1 0
 

1553
00:35:14,240 --> 00:35:16,710
node I want this to always be minus1 0
or plus

1554
00:35:16,710 --> 00:35:16,720
or plus
 

1555
00:35:16,720 --> 00:35:19,950
or plus
one okay so this is saying that if I

1556
00:35:19,950 --> 00:35:19,960
one okay so this is saying that if I
 

1557
00:35:19,960 --> 00:35:23,109
one okay so this is saying that if I
have any node and I look if it's left

1558
00:35:23,109 --> 00:35:23,119
have any node and I look if it's left
 

1559
00:35:23,119 --> 00:35:26,030
have any node and I look if it's left
sube and it's right sub tree I measure

1560
00:35:26,030 --> 00:35:26,040
sube and it's right sub tree I measure
 

1561
00:35:26,040 --> 00:35:27,710
sube and it's right sub tree I measure
their heights remember that's downward

1562
00:35:27,710 --> 00:35:27,720
their heights remember that's downward
 

1563
00:35:27,720 --> 00:35:30,790
their heights remember that's downward
dist to maximum distance to a leaf I

1564
00:35:30,790 --> 00:35:30,800
dist to maximum distance to a leaf I
 

1565
00:35:30,800 --> 00:35:32,870
dist to maximum distance to a leaf I
measure the height of this tree maximum

1566
00:35:32,870 --> 00:35:32,880
measure the height of this tree maximum
 

1567
00:35:32,880 --> 00:35:34,390
measure the height of this tree maximum
height I measure the maximum height of

1568
00:35:34,390 --> 00:35:34,400
height I measure the maximum height of
 

1569
00:35:34,400 --> 00:35:36,910
height I measure the maximum height of
this sube I want these to be within one

1570
00:35:36,910 --> 00:35:36,920
this sube I want these to be within one
 

1571
00:35:36,920 --> 00:35:39,550
this sube I want these to be within one
of each other maybe ideally they're

1572
00:35:39,550 --> 00:35:39,560
of each other maybe ideally they're
 

1573
00:35:39,560 --> 00:35:42,430
of each other maybe ideally they're
equal that would be the perfect case but

1574
00:35:42,430 --> 00:35:42,440
equal that would be the perfect case but
 

1575
00:35:42,440 --> 00:35:44,790
equal that would be the perfect case but
let's let them differ by one so maybe

1576
00:35:44,790 --> 00:35:44,800
let's let them differ by one so maybe
 

1577
00:35:44,800 --> 00:35:48,630
let's let them differ by one so maybe
this is K and this is k + one or maybe

1578
00:35:48,630 --> 00:35:48,640
this is K and this is k + one or maybe
 

1579
00:35:48,640 --> 00:35:51,309
this is K and this is k + one or maybe
this is K and this is K minus one what's

1580
00:35:51,309 --> 00:35:51,319
this is K and this is K minus one what's
 

1581
00:35:51,319 --> 00:35:52,790
this is K and this is K minus one what's
the in this picture what is the height

1582
00:35:52,790 --> 00:35:52,800
the in this picture what is the height
 

1583
00:35:52,800 --> 00:35:56,030
the in this picture what is the height
of this node it's good

1584
00:35:56,030 --> 00:35:56,040
of this node it's good
 

1585
00:35:56,040 --> 00:35:58,630
of this node it's good
practice k+ 2

1586
00:35:58,630 --> 00:35:58,640
practice k+ 2
 

1587
00:35:58,640 --> 00:36:00,829
practice k+ 2
good what's the longest path from this

1588
00:36:00,829 --> 00:36:00,839
good what's the longest path from this
 

1589
00:36:00,839 --> 00:36:02,589
good what's the longest path from this
node to a leaf well it could go through

1590
00:36:02,589 --> 00:36:02,599
node to a leaf well it could go through
 

1591
00:36:02,599 --> 00:36:04,630
node to a leaf well it could go through
this sub tree and that would be length

1592
00:36:04,630 --> 00:36:04,640
this sub tree and that would be length
 

1593
00:36:04,640 --> 00:36:06,750
this sub tree and that would be length
k+ 1 cuz it's K in here plus one for

1594
00:36:06,750 --> 00:36:06,760
k+ 1 cuz it's K in here plus one for
 

1595
00:36:06,760 --> 00:36:08,630
k+ 1 cuz it's K in here plus one for
this Edge or it could be through here

1596
00:36:08,630 --> 00:36:08,640
this Edge or it could be through here
 

1597
00:36:08,640 --> 00:36:11,150
this Edge or it could be through here
and that's k+ 1 plus one so the biggest

1598
00:36:11,150 --> 00:36:11,160
and that's k+ 1 plus one so the biggest
 

1599
00:36:11,160 --> 00:36:13,589
and that's k+ 1 plus one so the biggest
is to go to the right so the height if I

1600
00:36:13,589 --> 00:36:13,599
is to go to the right so the height if I
 

1601
00:36:13,599 --> 00:36:14,829
is to go to the right so the height if I
told you the height of these sub trees

1602
00:36:14,829 --> 00:36:14,839
told you the height of these sub trees
 

1603
00:36:14,839 --> 00:36:16,190
told you the height of these sub trees
we can derive the height of this note

1604
00:36:16,190 --> 00:36:16,200
we can derive the height of this note
 

1605
00:36:16,200 --> 00:36:18,430
we can derive the height of this note
we're going to use that a lot in a

1606
00:36:18,430 --> 00:36:18,440
we're going to use that a lot in a
 

1607
00:36:18,440 --> 00:36:21,430
we're going to use that a lot in a
moment so first claim is that if I could

1608
00:36:21,430 --> 00:36:21,440
moment so first claim is that if I could
 

1609
00:36:21,440 --> 00:36:25,150
moment so first claim is that if I could
maintain height balance then I

1610
00:36:25,150 --> 00:36:25,160
maintain height balance then I
 

1611
00:36:25,160 --> 00:36:28,190
maintain height balance then I
can uh I will guarantee that H equals

1612
00:36:28,190 --> 00:36:28,200
can uh I will guarantee that H equals
 

1613
00:36:28,200 --> 00:36:29,790
can uh I will guarantee that H equals
log n so in other words height balance

1614
00:36:29,790 --> 00:36:29,800
log n so in other words height balance
 

1615
00:36:29,800 --> 00:36:31,309
log n so in other words height balance
implies

1616
00:36:31,309 --> 00:36:31,319
implies
 

1617
00:36:31,319 --> 00:36:33,950
implies
balance so let's prove that

1618
00:36:33,950 --> 00:36:33,960
balance so let's prove that
 

1619
00:36:33,960 --> 00:36:38,390
balance so let's prove that
first quickly and then the interesting

1620
00:36:38,390 --> 00:36:38,400
first quickly and then the interesting
 

1621
00:36:38,400 --> 00:36:43,870
first quickly and then the interesting
part is how do we actually

1622
00:36:43,870 --> 00:36:43,880

 

1623
00:36:43,880 --> 00:36:46,349

prove or how do we actually maintain the

1624
00:36:46,349 --> 00:36:46,359
prove or how do we actually maintain the
 

1625
00:36:46,359 --> 00:36:48,349
prove or how do we actually maintain the
balance property we're going to do that

1626
00:36:48,349 --> 00:36:48,359
balance property we're going to do that
 

1627
00:36:48,359 --> 00:36:51,109
balance property we're going to do that
using rotations but how is a big

1628
00:36:51,109 --> 00:36:51,119
using rotations but how is a big
 

1629
00:36:51,119 --> 00:37:01,470
using rotations but how is a big
question

1630
00:37:01,470 --> 00:37:01,480

 

1631
00:37:01,480 --> 00:37:05,589

okay so why does height

1632
00:37:05,589 --> 00:37:05,599

 

1633
00:37:05,599 --> 00:37:15,630

balance imply

1634
00:37:15,630 --> 00:37:15,640

 

1635
00:37:15,640 --> 00:37:19,750

balance so uh what this is saying is

1636
00:37:19,750 --> 00:37:19,760
balance so uh what this is saying is
 

1637
00:37:19,760 --> 00:37:22,150
balance so uh what this is saying is
that all height balanc trees have

1638
00:37:22,150 --> 00:37:22,160
that all height balanc trees have
 

1639
00:37:22,160 --> 00:37:23,710
that all height balanc trees have
logarithmic

1640
00:37:23,710 --> 00:37:23,720
logarithmic
 

1641
00:37:23,720 --> 00:37:26,150
logarithmic
height so what I'd like to think about

1642
00:37:26,150 --> 00:37:26,160
height so what I'd like to think about
 

1643
00:37:26,160 --> 00:37:29,190
height so what I'd like to think about
is sort of the Le least balanced height

1644
00:37:29,190 --> 00:37:29,200
is sort of the Le least balanced height
 

1645
00:37:29,200 --> 00:37:31,990
is sort of the Le least balanced height
balanced tree uh the least balanced one

1646
00:37:31,990 --> 00:37:32,000
balanced tree uh the least balanced one
 

1647
00:37:32,000 --> 00:37:34,349
balanced tree uh the least balanced one
is going to have at every node a

1648
00:37:34,349 --> 00:37:34,359
is going to have at every node a
 

1649
00:37:34,359 --> 00:37:36,630
is going to have at every node a
mismatch the the left let's say the left

1650
00:37:36,630 --> 00:37:36,640
mismatch the the left let's say the left
 

1651
00:37:36,640 --> 00:37:40,470
mismatch the the left let's say the left
sube is shallower than the right subtree

1652
00:37:40,470 --> 00:37:40,480
sube is shallower than the right subtree
 

1653
00:37:40,480 --> 00:37:42,710
sube is shallower than the right subtree
by one and recursively all the way down

1654
00:37:42,710 --> 00:37:42,720
by one and recursively all the way down
 

1655
00:37:42,720 --> 00:37:46,150
by one and recursively all the way down
so every node has a a Gap

1656
00:37:46,150 --> 00:37:46,160
so every node has a a Gap
 

1657
00:37:46,160 --> 00:37:48,589
so every node has a a Gap
a

1658
00:37:48,589 --> 00:37:48,599
a
 

1659
00:37:48,599 --> 00:37:53,990
a
uh what do we call it uh a skew of

1660
00:37:53,990 --> 00:37:54,000
uh what do we call it uh a skew of
 

1661
00:37:54,000 --> 00:37:56,630
uh what do we call it uh a skew of
one okay which I'm going to write I'm

1662
00:37:56,630 --> 00:37:56,640
one okay which I'm going to write I'm
 

1663
00:37:56,640 --> 00:37:58,150
one okay which I'm going to write I'm
going to introduce some notation I'll

1664
00:37:58,150 --> 00:37:58,160
going to introduce some notation I'll
 

1665
00:37:58,160 --> 00:37:59,990
going to introduce some notation I'll
write a descending rightward Arrow if

1666
00:37:59,990 --> 00:38:00,000
write a descending rightward Arrow if
 

1667
00:38:00,000 --> 00:38:04,950
write a descending rightward Arrow if
this one is is higher than the left sub

1668
00:38:04,950 --> 00:38:04,960
this one is is higher than the left sub
 

1669
00:38:04,960 --> 00:38:07,910
this one is is higher than the left sub
tree uh so the easy way to think about

1670
00:38:07,910 --> 00:38:07,920
tree uh so the easy way to think about
 

1671
00:38:07,920 --> 00:38:09,829
tree uh so the easy way to think about
this is this is sort of the our worst

1672
00:38:09,829 --> 00:38:09,839
this is this is sort of the our worst
 

1673
00:38:09,839 --> 00:38:12,030
this is this is sort of the our worst
case this is going to be the the fewest

1674
00:38:12,030 --> 00:38:12,040
case this is going to be the the fewest
 

1675
00:38:12,040 --> 00:38:14,950
case this is going to be the the fewest
nodes for the maximum depth let's just

1676
00:38:14,950 --> 00:38:14,960
nodes for the maximum depth let's just
 

1677
00:38:14,960 --> 00:38:17,390
nodes for the maximum depth let's just
count how many nodes are in this

1678
00:38:17,390 --> 00:38:17,400
count how many nodes are in this
 

1679
00:38:17,400 --> 00:38:19,790
count how many nodes are in this
tree I'm going to write that as a

1680
00:38:19,790 --> 00:38:19,800
tree I'm going to write that as a
 

1681
00:38:19,800 --> 00:38:22,069
tree I'm going to write that as a
recurrence um which is the number of

1682
00:38:22,069 --> 00:38:22,079
recurrence um which is the number of
 

1683
00:38:22,079 --> 00:38:24,630
recurrence um which is the number of
nodes in a tree of height

1684
00:38:24,630 --> 00:38:24,640
nodes in a tree of height
 

1685
00:38:24,640 --> 00:38:29,630
nodes in a tree of height
H so if this whole tree has height h

1686
00:38:29,630 --> 00:38:29,640

 

1687
00:38:29,640 --> 00:38:32,990

H uh as we said in this picture if I

1688
00:38:32,990 --> 00:38:33,000
H uh as we said in this picture if I
 

1689
00:38:33,000 --> 00:38:35,670
H uh as we said in this picture if I
just subtract two from all these numbers

1690
00:38:35,670 --> 00:38:35,680
just subtract two from all these numbers
 

1691
00:38:35,680 --> 00:38:40,309
just subtract two from all these numbers
then this one has height uh H minus 2

1692
00:38:40,309 --> 00:38:40,319
then this one has height uh H minus 2
 

1693
00:38:40,319 --> 00:38:42,870
then this one has height uh H minus 2
and this one has height H minus

1694
00:38:42,870 --> 00:38:42,880
and this one has height H minus
 

1695
00:38:42,880 --> 00:38:45,990
and this one has height H minus
one okay so how many nodes are in here

1696
00:38:45,990 --> 00:38:46,000
one okay so how many nodes are in here
 

1697
00:38:46,000 --> 00:38:47,550
one okay so how many nodes are in here
well this is a recurrence I'm going to

1698
00:38:47,550 --> 00:38:47,560
well this is a recurrence I'm going to
 

1699
00:38:47,560 --> 00:38:52,150
well this is a recurrence I'm going to
write so this will be N Sub h-2 this

1700
00:38:52,150 --> 00:38:52,160
write so this will be N Sub h-2 this
 

1701
00:38:52,160 --> 00:38:54,349
write so this will be N Sub h-2 this
will be N Sub

1702
00:38:54,349 --> 00:38:54,359
will be N Sub
 

1703
00:38:54,359 --> 00:38:56,430
will be N Sub
hus1 and then I just count how many

1704
00:38:56,430 --> 00:38:56,440
hus1 and then I just count how many
 

1705
00:38:56,440 --> 00:38:57,990
hus1 and then I just count how many
nodes are in this picture

1706
00:38:57,990 --> 00:38:58,000
nodes are in this picture
 

1707
00:38:58,000 --> 00:39:04,750
nodes are in this picture
it is n subh -1 plus n subh - 2 + 1 or

1708
00:39:04,750 --> 00:39:04,760
it is n subh -1 plus n subh - 2 + 1 or
 

1709
00:39:04,760 --> 00:39:07,589
it is n subh -1 plus n subh - 2 + 1 or
this note now you might ask what is NH

1710
00:39:07,589 --> 00:39:07,599
this note now you might ask what is NH
 

1711
00:39:07,599 --> 00:39:10,230
this note now you might ask what is NH
or recurrence for uh but it is the

1712
00:39:10,230 --> 00:39:10,240
or recurrence for uh but it is the
 

1713
00:39:10,240 --> 00:39:13,630
or recurrence for uh but it is the
number of nodes in this sort of worst

1714
00:39:13,630 --> 00:39:13,640
number of nodes in this sort of worst
 

1715
00:39:13,640 --> 00:39:17,190
number of nodes in this sort of worst
case uh for if the worst case has total

1716
00:39:17,190 --> 00:39:17,200
case uh for if the worst case has total
 

1717
00:39:17,200 --> 00:39:20,150
case uh for if the worst case has total
height H so you can also think of it as

1718
00:39:20,150 --> 00:39:20,160
height H so you can also think of it as
 

1719
00:39:20,160 --> 00:39:21,910
height H so you can also think of it as
what is the minimum number of nodes I

1720
00:39:21,910 --> 00:39:21,920
what is the minimum number of nodes I
 

1721
00:39:21,920 --> 00:39:23,750
what is the minimum number of nodes I
could have in an AVL tree which is a

1722
00:39:23,750 --> 00:39:23,760
could have in an AVL tree which is a
 

1723
00:39:23,760 --> 00:39:33,470
could have in an AVL tree which is a
height balance tree uh that has height h

1724
00:39:33,470 --> 00:39:33,480

 

1725
00:39:33,480 --> 00:39:37,630

in a height balanced

1726
00:39:37,630 --> 00:39:37,640
in a height balanced
 

1727
00:39:37,640 --> 00:39:39,750
in a height balanced
tree okay so now I just need to solve

1728
00:39:39,750 --> 00:39:39,760
tree okay so now I just need to solve
 

1729
00:39:39,760 --> 00:39:45,430
tree okay so now I just need to solve
this recurrence this recurrence look

1730
00:39:45,430 --> 00:39:45,440

 

1731
00:39:45,440 --> 00:39:47,109

familiar

1732
00:39:47,109 --> 00:39:47,119
familiar
 

1733
00:39:47,119 --> 00:39:49,670
familiar
is it's like Fibonacci numbers if I

1734
00:39:49,670 --> 00:39:49,680
is it's like Fibonacci numbers if I
 

1735
00:39:49,680 --> 00:39:52,270
is it's like Fibonacci numbers if I
remove the plus one it's Fibonacci and

1736
00:39:52,270 --> 00:39:52,280
remove the plus one it's Fibonacci and
 

1737
00:39:52,280 --> 00:39:53,550
remove the plus one it's Fibonacci and
if you happen to know the Fibonacci

1738
00:39:53,550 --> 00:39:53,560
if you happen to know the Fibonacci
 

1739
00:39:53,560 --> 00:39:55,910
if you happen to know the Fibonacci
numbers grow as like a golden ratio to

1740
00:39:55,910 --> 00:39:55,920
numbers grow as like a golden ratio to
 

1741
00:39:55,920 --> 00:39:57,870
numbers grow as like a golden ratio to
the N then we know that this is

1742
00:39:57,870 --> 00:39:57,880
the N then we know that this is
 

1743
00:39:57,880 --> 00:39:59,670
the N then we know that this is
exponential which is what we want

1744
00:39:59,670 --> 00:39:59,680
exponential which is what we want
 

1745
00:39:59,680 --> 00:40:02,790
exponential which is what we want
because if NH is exponential in h that

1746
00:40:02,790 --> 00:40:02,800
because if NH is exponential in h that
 

1747
00:40:02,800 --> 00:40:05,069
because if NH is exponential in h that
means H is logarithmic in N because log

1748
00:40:05,069 --> 00:40:05,079
means H is logarithmic in N because log
 

1749
00:40:05,079 --> 00:40:07,150
means H is logarithmic in N because log
is inverse of exponential okay but maybe

1750
00:40:07,150 --> 00:40:07,160
is inverse of exponential okay but maybe
 

1751
00:40:07,160 --> 00:40:08,670
is inverse of exponential okay but maybe
you don't know about Fibonacci numbers

1752
00:40:08,670 --> 00:40:08,680
you don't know about Fibonacci numbers
 

1753
00:40:08,680 --> 00:40:12,910
you don't know about Fibonacci numbers
and uh so we can still uh easily show

1754
00:40:12,910 --> 00:40:12,920
and uh so we can still uh easily show
 

1755
00:40:12,920 --> 00:40:16,109
and uh so we can still uh easily show
that this is exponential as follows I

1756
00:40:16,109 --> 00:40:16,119
that this is exponential as follows I
 

1757
00:40:16,119 --> 00:40:17,630
that this is exponential as follows I
want to prove that it's at least an

1758
00:40:17,630 --> 00:40:17,640
want to prove that it's at least an
 

1759
00:40:17,640 --> 00:40:19,510
want to prove that it's at least an
exponential because that gives me that H

1760
00:40:19,510 --> 00:40:19,520
exponential because that gives me that H
 

1761
00:40:19,520 --> 00:40:21,230
exponential because that gives me that H
is at most

1762
00:40:21,230 --> 00:40:21,240
is at most
 

1763
00:40:21,240 --> 00:40:24,390
is at most
logarithmic um so we need a lower bound

1764
00:40:24,390 --> 00:40:24,400
logarithmic um so we need a lower bound
 

1765
00:40:24,400 --> 00:40:25,829
logarithmic um so we need a lower bound
and so we have these two terms which are

1766
00:40:25,829 --> 00:40:25,839
and so we have these two terms which are
 

1767
00:40:25,839 --> 00:40:28,150
and so we have these two terms which are
hard to compare n subh minus 1 and N Sub

1768
00:40:28,150 --> 00:40:28,160
hard to compare n subh minus 1 and N Sub
 

1769
00:40:28,160 --> 00:40:30,589
hard to compare n subh minus 1 and N Sub
hus 2 it's kind of ugly uh but if we're

1770
00:40:30,589 --> 00:40:30,599
hus 2 it's kind of ugly uh but if we're
 

1771
00:40:30,599 --> 00:40:32,109
hus 2 it's kind of ugly uh but if we're
allowed to be sloppy and we'll see if

1772
00:40:32,109 --> 00:40:32,119
allowed to be sloppy and we'll see if
 

1773
00:40:32,119 --> 00:40:33,910
allowed to be sloppy and we'll see if
we're not too sloppy and still get an

1774
00:40:33,910 --> 00:40:33,920
we're not too sloppy and still get an
 

1775
00:40:33,920 --> 00:40:36,390
we're not too sloppy and still get an
exponential answer um let's just make

1776
00:40:36,390 --> 00:40:36,400
exponential answer um let's just make
 

1777
00:40:36,400 --> 00:40:38,349
exponential answer um let's just make
them

1778
00:40:38,349 --> 00:40:38,359
them
 

1779
00:40:38,359 --> 00:40:40,550
them
equal uh like

1780
00:40:40,550 --> 00:40:40,560
equal uh like
 

1781
00:40:40,560 --> 00:40:43,150
equal uh like
so

1782
00:40:43,150 --> 00:40:43,160
so
 

1783
00:40:43,160 --> 00:40:46,390
so
um so this is a true statement in fact

1784
00:40:46,390 --> 00:40:46,400
um so this is a true statement in fact
 

1785
00:40:46,400 --> 00:40:49,390
um so this is a true statement in fact
strictly greater than uh why because so

1786
00:40:49,390 --> 00:40:49,400
strictly greater than uh why because so
 

1787
00:40:49,400 --> 00:40:50,910
strictly greater than uh why because so
I removed the plus one that should only

1788
00:40:50,910 --> 00:40:50,920
I removed the plus one that should only
 

1789
00:40:50,920 --> 00:40:54,349
I removed the plus one that should only
make something smaller and um I replaced

1790
00:40:54,349 --> 00:40:54,359
make something smaller and um I replaced
 

1791
00:40:54,359 --> 00:40:56,750
make something smaller and um I replaced
n subh minus1 with n subh minus 2 here

1792
00:40:56,750 --> 00:40:56,760
n subh minus1 with n subh minus 2 here
 

1793
00:40:56,760 --> 00:40:59,230
n subh minus1 with n subh minus 2 here
I'm implic using a fact which is obvious

1794
00:40:59,230 --> 00:40:59,240
I'm implic using a fact which is obvious
 

1795
00:40:59,240 --> 00:41:03,190
I'm implic using a fact which is obvious
by induction that uh this tree on height

1796
00:41:03,190 --> 00:41:03,200
by induction that uh this tree on height
 

1797
00:41:03,200 --> 00:41:05,309
by induction that uh this tree on height
if I take this tree versus this tree

1798
00:41:05,309 --> 00:41:05,319
if I take this tree versus this tree
 

1799
00:41:05,319 --> 00:41:07,630
if I take this tree versus this tree
this one has more nodes than this one

1800
00:41:07,630 --> 00:41:07,640
this one has more nodes than this one
 

1801
00:41:07,640 --> 00:41:09,550
this one has more nodes than this one
right if I have larger height this

1802
00:41:09,550 --> 00:41:09,560
right if I have larger height this
 

1803
00:41:09,560 --> 00:41:11,230
right if I have larger height this
construction is going to build a bigger

1804
00:41:11,230 --> 00:41:11,240
construction is going to build a bigger
 

1805
00:41:11,240 --> 00:41:14,109
construction is going to build a bigger
tree at least as big doesn't need even

1806
00:41:14,109 --> 00:41:14,119
tree at least as big doesn't need even
 

1807
00:41:14,119 --> 00:41:16,309
tree at least as big doesn't need even
need to be strictly bigger so certainly

1808
00:41:16,309 --> 00:41:16,319
need to be strictly bigger so certainly
 

1809
00:41:16,319 --> 00:41:17,910
need to be strictly bigger so certainly
n subh minus one is greater than or

1810
00:41:17,910 --> 00:41:17,920
n subh minus one is greater than or
 

1811
00:41:17,920 --> 00:41:22,390
n subh minus one is greater than or
equal to n subh minus 2 now this is 2 *

1812
00:41:22,390 --> 00:41:22,400
equal to n subh minus 2 now this is 2 *
 

1813
00:41:22,400 --> 00:41:25,630
equal to n subh minus 2 now this is 2 *
n subus 2 and this is an easy recurrence

1814
00:41:25,630 --> 00:41:25,640
n subus 2 and this is an easy recurrence
 

1815
00:41:25,640 --> 00:41:28,190
n subus 2 and this is an easy recurrence
this is just powers of two right I keep

1816
00:41:28,190 --> 00:41:28,200
this is just powers of two right I keep
 

1817
00:41:28,200 --> 00:41:30,430
this is just powers of two right I keep
multiplying by two and subtracting two

1818
00:41:30,430 --> 00:41:30,440
multiplying by two and subtracting two
 

1819
00:41:30,440 --> 00:41:35,190
multiplying by two and subtracting two
from H so this solves to 2 to the h 2

1820
00:41:35,190 --> 00:41:35,200
from H so this solves to 2 to the h 2
 

1821
00:41:35,200 --> 00:41:38,790
from H so this solves to 2 to the h 2
maybe with a floor or something okay but

1822
00:41:38,790 --> 00:41:38,800
maybe with a floor or something okay but
 

1823
00:41:38,800 --> 00:41:41,710
maybe with a floor or something okay but
uh it is I'm using a base case here

1824
00:41:41,710 --> 00:41:41,720
uh it is I'm using a base case here
 

1825
00:41:41,720 --> 00:41:44,030
uh it is I'm using a base case here
which is N Sub 0al

1826
00:41:44,030 --> 00:41:44,040
which is N Sub 0al
 

1827
00:41:44,040 --> 00:41:47,589
which is N Sub 0al
1 uh maybe it's a ceiling then but the

1828
00:41:47,589 --> 00:41:47,599
1 uh maybe it's a ceiling then but the
 

1829
00:41:47,599 --> 00:41:49,670
1 uh maybe it's a ceiling then but the
point is this is exponential so this

1830
00:41:49,670 --> 00:41:49,680
point is this is exponential so this
 

1831
00:41:49,680 --> 00:41:52,390
point is this is exponential so this
implies that the height is always at

1832
00:41:52,390 --> 00:41:52,400
implies that the height is always at
 

1833
00:41:52,400 --> 00:41:54,589
implies that the height is always at
most 2 * log

1834
00:41:54,589 --> 00:41:54,599
most 2 * log
 

1835
00:41:54,599 --> 00:41:57,750
most 2 * log
n uh this two corresponds to this to if

1836
00:41:57,750 --> 00:41:57,760
n uh this two corresponds to this to if
 

1837
00:41:57,760 --> 00:41:59,790
n uh this two corresponds to this to if
you just invert this formula this was

1838
00:41:59,790 --> 00:41:59,800
you just invert this formula this was
 

1839
00:41:59,800 --> 00:42:03,030
you just invert this formula this was
number of nodes is going to be at

1840
00:42:03,030 --> 00:42:03,040
number of nodes is going to be at
 

1841
00:42:03,040 --> 00:42:06,910
number of nodes is going to be at
least uh 2 the H2 and so H is at most to

1842
00:42:06,910 --> 00:42:06,920
least uh 2 the H2 and so H is at most to
 

1843
00:42:06,920 --> 00:42:09,349
least uh 2 the H2 and so H is at most to
log n so it's not log n that would be

1844
00:42:09,349 --> 00:42:09,359
log n so it's not log n that would be
 

1845
00:42:09,359 --> 00:42:11,390
log n so it's not log n that would be
perfect but it's within a factor of two

1846
00:42:11,390 --> 00:42:11,400
perfect but it's within a factor of two
 

1847
00:42:11,400 --> 00:42:14,550
perfect but it's within a factor of two
of log n so AVL trees are always quite

1848
00:42:14,550 --> 00:42:14,560
of log n so AVL trees are always quite
 

1849
00:42:14,560 --> 00:42:16,710
of log n so AVL trees are always quite
balanced number of levels is at most

1850
00:42:16,710 --> 00:42:16,720
balanced number of levels is at most
 

1851
00:42:16,720 --> 00:42:22,910
balanced number of levels is at most
double what you need to store end nodes

1852
00:42:22,910 --> 00:42:22,920

 

1853
00:42:22,920 --> 00:42:27,670

great we're left with the main Magic

1854
00:42:27,670 --> 00:42:27,680
great we're left with the main Magic
 

1855
00:42:27,680 --> 00:42:31,750
great we're left with the main Magic
not domain magic that's different uh and

1856
00:42:31,750 --> 00:42:31,760
not domain magic that's different uh and
 

1857
00:42:31,760 --> 00:42:36,510
not domain magic that's different uh and
let's see we're going to use subt tree

1858
00:42:36,510 --> 00:42:36,520

 

1859
00:42:36,520 --> 00:42:44,510

augmentation keep

1860
00:42:44,510 --> 00:42:44,520

 

1861
00:42:44,520 --> 00:42:48,109

that big remaining challenge is how do

1862
00:42:48,109 --> 00:42:48,119
that big remaining challenge is how do
 

1863
00:42:48,119 --> 00:42:50,109
that big remaining challenge is how do
we maintain this height balance property

1864
00:42:50,109 --> 00:42:50,119
we maintain this height balance property
 

1865
00:42:50,119 --> 00:42:51,829
we maintain this height balance property
using rotations we have all the

1866
00:42:51,829 --> 00:42:51,839
using rotations we have all the
 

1867
00:42:51,839 --> 00:42:54,670
using rotations we have all the
ingredients lined up for us we have sub

1868
00:42:54,670 --> 00:42:54,680
ingredients lined up for us we have sub
 

1869
00:42:54,680 --> 00:42:55,630
ingredients lined up for us we have sub
Tre

1870
00:42:55,630 --> 00:42:55,640
Tre
 

1871
00:42:55,640 --> 00:42:59,710
Tre
augmentation what does that let me

1872
00:42:59,710 --> 00:42:59,720

 

1873
00:42:59,720 --> 00:43:03,190

do that's relevant to AVL trees well it

1874
00:43:03,190 --> 00:43:03,200
do that's relevant to AVL trees well it
 

1875
00:43:03,200 --> 00:43:05,390
do that's relevant to AVL trees well it
lets me store

1876
00:43:05,390 --> 00:43:05,400
lets me store
 

1877
00:43:05,400 --> 00:43:07,910
lets me store
height right I need to be able to

1878
00:43:07,910 --> 00:43:07,920
height right I need to be able to
 

1879
00:43:07,920 --> 00:43:10,309
height right I need to be able to
compute the height of a

1880
00:43:10,309 --> 00:43:10,319
compute the height of a
 

1881
00:43:10,319 --> 00:43:13,030
compute the height of a
node that in general takes linear time

1882
00:43:13,030 --> 00:43:13,040
node that in general takes linear time
 

1883
00:43:13,040 --> 00:43:14,030
node that in general takes linear time
because I have to look at all the

1884
00:43:14,030 --> 00:43:14,040
because I have to look at all the
 

1885
00:43:14,040 --> 00:43:15,510
because I have to look at all the
downward paths all the leaves within

1886
00:43:15,510 --> 00:43:15,520
downward paths all the leaves within
 

1887
00:43:15,520 --> 00:43:19,630
downward paths all the leaves within
that sub tree but height is a sub tree

1888
00:43:19,630 --> 00:43:19,640
that sub tree but height is a sub tree
 

1889
00:43:19,640 --> 00:43:23,829
that sub tree but height is a sub tree
property so uh

1890
00:43:23,829 --> 00:43:23,839
property so uh
 

1891
00:43:23,839 --> 00:43:28,069
property so uh
yes height

1892
00:43:28,069 --> 00:43:28,079

 

1893
00:43:28,079 --> 00:43:29,829

why

1894
00:43:29,829 --> 00:43:29,839
why
 

1895
00:43:29,839 --> 00:43:33,630
why
because uh let me just write it here

1896
00:43:33,630 --> 00:43:33,640
because uh let me just write it here
 

1897
00:43:33,640 --> 00:43:37,030
because uh let me just write it here
node.

1898
00:43:37,030 --> 00:43:37,040

 

1899
00:43:37,040 --> 00:43:48,150

height equals 1 + Max of node. left.

1900
00:43:48,150 --> 00:43:48,160

 

1901
00:43:48,160 --> 00:43:54,829

height and no do right.

1902
00:43:54,829 --> 00:43:54,839

 

1903
00:43:54,839 --> 00:43:59,510

height and of Max let me put this in a

1904
00:43:59,510 --> 00:43:59,520
height and of Max let me put this in a
 

1905
00:43:59,520 --> 00:44:01,270
height and of Max let me put this in a
box

1906
00:44:01,270 --> 00:44:01,280
box
 

1907
00:44:01,280 --> 00:44:03,829
box
this equation or I guess it's an

1908
00:44:03,829 --> 00:44:03,839
this equation or I guess it's an
 

1909
00:44:03,839 --> 00:44:07,549
this equation or I guess it's an
assignment operation this is a

1910
00:44:07,549 --> 00:44:07,559
assignment operation this is a
 

1911
00:44:07,559 --> 00:44:09,670
assignment operation this is a
one is the thing we've been doing over

1912
00:44:09,670 --> 00:44:09,680
one is the thing we've been doing over
 

1913
00:44:09,680 --> 00:44:11,030
one is the thing we've been doing over
and over when I said what is the height

1914
00:44:11,030 --> 00:44:11,040
and over when I said what is the height
 

1915
00:44:11,040 --> 00:44:12,670
and over when I said what is the height
of this node you just figured that out

1916
00:44:12,670 --> 00:44:12,680
of this node you just figured that out
 

1917
00:44:12,680 --> 00:44:13,750
of this node you just figured that out
right you took the height of the left

1918
00:44:13,750 --> 00:44:13,760
right you took the height of the left
 

1919
00:44:13,760 --> 00:44:15,109
right you took the height of the left
sub tree maxed with the height of the

1920
00:44:15,109 --> 00:44:15,119
sub tree maxed with the height of the
 

1921
00:44:15,119 --> 00:44:17,349
sub tree maxed with the height of the
right sub tree and added one for to

1922
00:44:17,349 --> 00:44:17,359
right sub tree and added one for to
 

1923
00:44:17,359 --> 00:44:19,750
right sub tree and added one for to
count for these edges okay so this is a

1924
00:44:19,750 --> 00:44:19,760
count for these edges okay so this is a
 

1925
00:44:19,760 --> 00:44:21,790
count for these edges okay so this is a
general update rule it matches this

1926
00:44:21,790 --> 00:44:21,800
general update rule it matches this
 

1927
00:44:21,800 --> 00:44:24,069
general update rule it matches this
subtree property pattern if I have the

1928
00:44:24,069 --> 00:44:24,079
subtree property pattern if I have the
 

1929
00:44:24,079 --> 00:44:25,910
subtree property pattern if I have the
property of left and right I can compute

1930
00:44:25,910 --> 00:44:25,920
property of left and right I can compute
 

1931
00:44:25,920 --> 00:44:27,910
property of left and right I can compute
it for node

1932
00:44:27,910 --> 00:44:27,920
it for node
 

1933
00:44:27,920 --> 00:44:29,670
it for node
and this takes constant time to do and

1934
00:44:29,670 --> 00:44:29,680
and this takes constant time to do and
 

1935
00:44:29,680 --> 00:44:31,150
and this takes constant time to do and
so it's a sub tree property and so I can

1936
00:44:31,150 --> 00:44:31,160
so it's a sub tree property and so I can
 

1937
00:44:31,160 --> 00:44:32,950
so it's a sub tree property and so I can
maintain through all the things I'm

1938
00:44:32,950 --> 00:44:32,960
maintain through all the things I'm
 

1939
00:44:32,960 --> 00:44:34,950
maintain through all the things I'm
doing the height of every node oh by the

1940
00:44:34,950 --> 00:44:34,960
doing the height of every node oh by the
 

1941
00:44:34,960 --> 00:44:38,270
doing the height of every node oh by the
way whenever I do a rotation I'm also

1942
00:44:38,270 --> 00:44:38,280
way whenever I do a rotation I'm also
 

1943
00:44:38,280 --> 00:44:40,230
way whenever I do a rotation I'm also
going to have to update my sube

1944
00:44:40,230 --> 00:44:40,240
going to have to update my sube
 

1945
00:44:40,240 --> 00:44:43,950
going to have to update my sube
properties when I rotate this Edge a

1946
00:44:43,950 --> 00:44:43,960
properties when I rotate this Edge a
 

1947
00:44:43,960 --> 00:44:46,069
properties when I rotate this Edge a
does not change B does not change C does

1948
00:44:46,069 --> 00:44:46,079
does not change B does not change C does
 

1949
00:44:46,079 --> 00:44:49,150
does not change B does not change C does
not change so that's good but X's sub

1950
00:44:49,150 --> 00:44:49,160
not change so that's good but X's sub
 

1951
00:44:49,160 --> 00:44:51,230
not change so that's good but X's sub
tree changes it now has why it didn't

1952
00:44:51,230 --> 00:44:51,240
tree changes it now has why it didn't
 

1953
00:44:51,240 --> 00:44:54,430
tree changes it now has why it didn't
before so we're going to have to also uh

1954
00:44:54,430 --> 00:44:54,440
before so we're going to have to also uh
 

1955
00:44:54,440 --> 00:44:58,109
before so we're going to have to also uh
update the augmentation here

1956
00:44:58,109 --> 00:44:58,119
update the augmentation here
 

1957
00:44:58,119 --> 00:45:00,309
update the augmentation here
Y and we're going to have to update the

1958
00:45:00,309 --> 00:45:00,319
Y and we're going to have to update the
 

1959
00:45:00,319 --> 00:45:02,790
Y and we're going to have to update the
augmentation in

1960
00:45:02,790 --> 00:45:02,800
augmentation in
 

1961
00:45:02,800 --> 00:45:05,030
augmentation in
X and we're going to have to update the

1962
00:45:05,030 --> 00:45:05,040
X and we're going to have to update the
 

1963
00:45:05,040 --> 00:45:07,190
X and we're going to have to update the
augmentation of all of the ancestors of

1964
00:45:07,190 --> 00:45:07,200
augmentation of all of the ancestors of
 

1965
00:45:07,200 --> 00:45:12,270
augmentation of all of the ancestors of
X eventually um so rotation is locally

1966
00:45:12,270 --> 00:45:12,280
X eventually um so rotation is locally
 

1967
00:45:12,280 --> 00:45:13,549
X eventually um so rotation is locally
just changing a constant number of

1968
00:45:13,549 --> 00:45:13,559
just changing a constant number of
 

1969
00:45:13,559 --> 00:45:15,150
just changing a constant number of
pointers so I usually think of rotations

1970
00:45:15,150 --> 00:45:15,160
pointers so I usually think of rotations
 

1971
00:45:15,160 --> 00:45:16,950
pointers so I usually think of rotations
as taking constant

1972
00:45:16,950 --> 00:45:16,960
as taking constant
 

1973
00:45:16,960 --> 00:45:19,790
as taking constant
time uh but eventually we will have to

1974
00:45:19,790 --> 00:45:19,800
time uh but eventually we will have to
 

1975
00:45:19,800 --> 00:45:22,670
time uh but eventually we will have to
do this is constant time

1976
00:45:22,670 --> 00:45:22,680
do this is constant time
 

1977
00:45:22,680 --> 00:45:24,390
do this is constant time
locally

1978
00:45:24,390 --> 00:45:24,400
locally
 

1979
00:45:24,400 --> 00:45:32,470
locally
uh but we will need to up

1980
00:45:32,470 --> 00:45:32,480

 

1981
00:45:32,480 --> 00:45:34,270

uh H

1982
00:45:34,270 --> 00:45:34,280
uh H
 

1983
00:45:34,280 --> 00:45:36,910
uh H
ancestors in order to store all of keep

1984
00:45:36,910 --> 00:45:36,920
ancestors in order to store all of keep
 

1985
00:45:36,920 --> 00:45:39,349
ancestors in order to store all of keep
all of our augmentations up to date okay

1986
00:45:39,349 --> 00:45:39,359
all of our augmentations up to date okay
 

1987
00:45:39,359 --> 00:45:42,390
all of our augmentations up to date okay
we'll worry about that

1988
00:45:42,390 --> 00:45:42,400

 

1989
00:45:42,400 --> 00:45:44,750

later all right so great now we have the

1990
00:45:44,750 --> 00:45:44,760
later all right so great now we have the
 

1991
00:45:44,760 --> 00:45:46,270
later all right so great now we have the
height of all the nodes we can compute

1992
00:45:46,270 --> 00:45:46,280
height of all the nodes we can compute
 

1993
00:45:46,280 --> 00:45:50,829
height of all the nodes we can compute
the SK skew of all the nodes cool uh we

1994
00:45:50,829 --> 00:45:50,839
the SK skew of all the nodes cool uh we
 

1995
00:45:50,839 --> 00:45:52,870
the SK skew of all the nodes cool uh we
have this rotation operation and we want

1996
00:45:52,870 --> 00:45:52,880
have this rotation operation and we want
 

1997
00:45:52,880 --> 00:45:53,829
have this rotation operation and we want
to

1998
00:45:53,829 --> 00:45:53,839
to
 

1999
00:45:53,839 --> 00:45:55,670
to
maintain

2000
00:45:55,670 --> 00:45:55,680
maintain
 

2001
00:45:55,680 --> 00:45:58,470
maintain
uh this height balance property height

2002
00:45:58,470 --> 00:45:58,480
uh this height balance property height
 

2003
00:45:58,480 --> 00:46:00,670
uh this height balance property height
of left node left and right of every

2004
00:46:00,670 --> 00:46:00,680
of left node left and right of every
 

2005
00:46:00,680 --> 00:46:03,670
of left node left and right of every
node is within is plus or minus one or

2006
00:46:03,670 --> 00:46:03,680
node is within is plus or minus one or
 

2007
00:46:03,680 --> 00:46:05,309
node is within is plus or minus one or
zero

2008
00:46:05,309 --> 00:46:05,319
zero
 

2009
00:46:05,319 --> 00:46:08,150
zero
um

2010
00:46:08,150 --> 00:46:08,160
um
 

2011
00:46:08,160 --> 00:46:11,790
um
cool so uh I said over here

2012
00:46:11,790 --> 00:46:11,800
cool so uh I said over here
 

2013
00:46:11,800 --> 00:46:14,630
cool so uh I said over here
somewhere whenever we so the only things

2014
00:46:14,630 --> 00:46:14,640
somewhere whenever we so the only things
 

2015
00:46:14,640 --> 00:46:15,950
somewhere whenever we so the only things
that change the tree are when we insert

2016
00:46:15,950 --> 00:46:15,960
that change the tree are when we insert
 

2017
00:46:15,960 --> 00:46:18,470
that change the tree are when we insert
or delete a new node and it and the way

2018
00:46:18,470 --> 00:46:18,480
or delete a new node and it and the way
 

2019
00:46:18,480 --> 00:46:20,510
or delete a new node and it and the way
that we implemented those so far is to

2020
00:46:20,510 --> 00:46:20,520
that we implemented those so far is to
 

2021
00:46:20,520 --> 00:46:22,710
that we implemented those so far is to
add or remove a leaf so we should still

2022
00:46:22,710 --> 00:46:22,720
add or remove a leaf so we should still
 

2023
00:46:22,720 --> 00:46:24,829
add or remove a leaf so we should still
be thinking about adding or removing a

2024
00:46:24,829 --> 00:46:24,839
be thinking about adding or removing a
 

2025
00:46:24,839 --> 00:46:26,470
be thinking about adding or removing a
leaf the problem is when I add a new

2026
00:46:26,470 --> 00:46:26,480
leaf the problem is when I add a new
 

2027
00:46:26,480 --> 00:46:27,510
leaf the problem is when I add a new
Leaf

2028
00:46:27,510 --> 00:46:27,520
Leaf
 

2029
00:46:27,520 --> 00:46:30,109
Leaf
now maybe this tree is higher than it

2030
00:46:30,109 --> 00:46:30,119
now maybe this tree is higher than it
 

2031
00:46:30,119 --> 00:46:33,630
now maybe this tree is higher than it
used to be so um some node here may no

2032
00:46:33,630 --> 00:46:33,640
used to be so um some node here may no
 

2033
00:46:33,640 --> 00:46:35,910
used to be so um some node here may no
longer be height balanced but because

2034
00:46:35,910 --> 00:46:35,920
longer be height balanced but because
 

2035
00:46:35,920 --> 00:46:37,870
longer be height balanced but because
height is a subtree property the only

2036
00:46:37,870 --> 00:46:37,880
height is a subtree property the only
 

2037
00:46:37,880 --> 00:46:40,309
height is a subtree property the only
nodes we need to check are the ones up

2038
00:46:40,309 --> 00:46:40,319
nodes we need to check are the ones up
 

2039
00:46:40,319 --> 00:46:42,710
nodes we need to check are the ones up
this ancestor path so and there's only

2040
00:46:42,710 --> 00:46:42,720
this ancestor path so and there's only
 

2041
00:46:42,720 --> 00:46:44,430
this ancestor path so and there's only
log n of them because now height is log

2042
00:46:44,430 --> 00:46:44,440
log n of them because now height is log
 

2043
00:46:44,440 --> 00:46:46,790
log n of them because now height is log
n that's what we just proved as long as

2044
00:46:46,790 --> 00:46:46,800
n that's what we just proved as long as
 

2045
00:46:46,800 --> 00:46:48,430
n that's what we just proved as long as
we have this property now we right now

2046
00:46:48,430 --> 00:46:48,440
we have this property now we right now
 

2047
00:46:48,440 --> 00:46:51,150
we have this property now we right now
don't have it for like maybe these few

2048
00:46:51,150 --> 00:46:51,160
don't have it for like maybe these few
 

2049
00:46:51,160 --> 00:46:53,470
don't have it for like maybe these few
notes but it will be it was log n before

2050
00:46:53,470 --> 00:46:53,480
notes but it will be it was log n before
 

2051
00:46:53,480 --> 00:46:55,630
notes but it will be it was log n before
it's at most log n 2 log n plus one

2052
00:46:55,630 --> 00:46:55,640
it's at most log n 2 log n plus one
 

2053
00:46:55,640 --> 00:46:58,309
it's at most log n 2 log n plus one
right now cuz we just added a Noe

2054
00:46:58,309 --> 00:46:58,319
right now cuz we just added a Noe
 

2055
00:46:58,319 --> 00:47:00,069
right now cuz we just added a Noe
so what I want to do is check all of

2056
00:47:00,069 --> 00:47:00,079
so what I want to do is check all of
 

2057
00:47:00,079 --> 00:47:02,630
so what I want to do is check all of
these ancestor nodes in sequence from

2058
00:47:02,630 --> 00:47:02,640
these ancestor nodes in sequence from
 

2059
00:47:02,640 --> 00:47:05,430
these ancestor nodes in sequence from
bottom up and find one that's out of

2060
00:47:05,430 --> 00:47:05,440
bottom up and find one that's out of
 

2061
00:47:05,440 --> 00:47:10,870
bottom up and find one that's out of
balance so let's take the

2062
00:47:10,870 --> 00:47:10,880

 

2063
00:47:10,880 --> 00:47:13,349

um

2064
00:47:13,349 --> 00:47:13,359
um
 

2065
00:47:13,359 --> 00:47:20,990
um
lowest uh outof balance

2066
00:47:20,990 --> 00:47:21,000

 

2067
00:47:21,000 --> 00:47:25,109

node I'm going to call that X now

2068
00:47:25,109 --> 00:47:25,119
node I'm going to call that X now
 

2069
00:47:25,119 --> 00:47:26,990
node I'm going to call that X now
because we just inserted or deleted a

2070
00:47:26,990 --> 00:47:27,000
because we just inserted or deleted a
 

2071
00:47:27,000 --> 00:47:30,390
because we just inserted or deleted a
single leaf it's only out of balance by

2072
00:47:30,390 --> 00:47:30,400
single leaf it's only out of balance by
 

2073
00:47:30,400 --> 00:47:33,670
single leaf it's only out of balance by
one right because we only changed height

2074
00:47:33,670 --> 00:47:33,680
one right because we only changed height
 

2075
00:47:33,680 --> 00:47:35,470
one right because we only changed height
one height went up by one or one height

2076
00:47:35,470 --> 00:47:35,480
one height went up by one or one height
 

2077
00:47:35,480 --> 00:47:38,309
one height went up by one or one height
went down by one and before all of our

2078
00:47:38,309 --> 00:47:38,319
went down by one and before all of our
 

2079
00:47:38,319 --> 00:47:40,990
went down by one and before all of our
SKS were plus or minus one or zero so

2080
00:47:40,990 --> 00:47:41,000
SKS were plus or minus one or zero so
 

2081
00:47:41,000 --> 00:47:42,990
SKS were plus or minus one or zero so
now it's going the bad case is when it's

2082
00:47:42,990 --> 00:47:43,000
now it's going the bad case is when it's
 

2083
00:47:43,000 --> 00:47:45,470
now it's going the bad case is when it's
plus or minus two if it happens to still

2084
00:47:45,470 --> 00:47:45,480
plus or minus two if it happens to still
 

2085
00:47:45,480 --> 00:47:46,790
plus or minus two if it happens to still
be in this range for all the nodes we're

2086
00:47:46,790 --> 00:47:46,800
be in this range for all the nodes we're
 

2087
00:47:46,800 --> 00:47:48,710
be in this range for all the nodes we're
happy but if it's outside this range

2088
00:47:48,710 --> 00:47:48,720
happy but if it's outside this range
 

2089
00:47:48,720 --> 00:47:51,349
happy but if it's outside this range
it's only going to be out by one uh so

2090
00:47:51,349 --> 00:47:51,359
it's only going to be out by one uh so
 

2091
00:47:51,359 --> 00:47:52,750
it's only going to be out by one uh so
this means the

2092
00:47:52,750 --> 00:47:52,760
this means the
 

2093
00:47:52,760 --> 00:47:57,710
this means the
skew is in plus 2 orus

2094
00:47:57,710 --> 00:47:57,720
skew is in plus 2 orus
 

2095
00:47:57,720 --> 00:48:01,150
skew is in plus 2 orus
2 and let's say that it's two by

2096
00:48:01,150 --> 00:48:01,160
2 and let's say that it's two by
 

2097
00:48:01,160 --> 00:48:04,950
2 and let's say that it's two by
symmetry so um my picture

2098
00:48:04,950 --> 00:48:04,960
symmetry so um my picture
 

2099
00:48:04,960 --> 00:48:08,990
symmetry so um my picture
is I'm going to draw double right

2100
00:48:08,990 --> 00:48:09,000
is I'm going to draw double right
 

2101
00:48:09,000 --> 00:48:13,470
is I'm going to draw double right
arrow to say

2102
00:48:13,470 --> 00:48:13,480

 

2103
00:48:13,480 --> 00:48:17,150

that this sub tree is two higher than

2104
00:48:17,150 --> 00:48:17,160
that this sub tree is two higher than
 

2105
00:48:17,160 --> 00:48:19,910
that this sub tree is two higher than
this sub tree okay so that's bad and we

2106
00:48:19,910 --> 00:48:19,920
this sub tree okay so that's bad and we
 

2107
00:48:19,920 --> 00:48:23,510
this sub tree okay so that's bad and we
want to fix it the obvious thing to do

2108
00:48:23,510 --> 00:48:23,520
want to fix it the obvious thing to do
 

2109
00:48:23,520 --> 00:48:25,790
want to fix it the obvious thing to do
is to rotate this Edge because that'll

2110
00:48:25,790 --> 00:48:25,800
is to rotate this Edge because that'll
 

2111
00:48:25,800 --> 00:48:27,990
is to rotate this Edge because that'll
make this this is

2112
00:48:27,990 --> 00:48:28,000
make this this is
 

2113
00:48:28,000 --> 00:48:31,470
make this this is
too this is too high and this is too low

2114
00:48:31,470 --> 00:48:31,480
too this is too high and this is too low
 

2115
00:48:31,480 --> 00:48:33,150
too this is too high and this is too low
so if we rotate this should go down by

2116
00:48:33,150 --> 00:48:33,160
so if we rotate this should go down by
 

2117
00:48:33,160 --> 00:48:34,670
so if we rotate this should go down by
one and this should go up by one and

2118
00:48:34,670 --> 00:48:34,680
one and this should go up by one and
 

2119
00:48:34,680 --> 00:48:37,069
one and this should go up by one and
that works most of the

2120
00:48:37,069 --> 00:48:37,079
that works most of the
 

2121
00:48:37,079 --> 00:48:40,109
that works most of the
time so case

2122
00:48:40,109 --> 00:48:40,119
time so case
 

2123
00:48:40,119 --> 00:48:42,829
time so case
one is that

2124
00:48:42,829 --> 00:48:42,839
one is that
 

2125
00:48:42,839 --> 00:48:47,190
one is that
skew of Y what is y I want y to be the

2126
00:48:47,190 --> 00:48:47,200
skew of Y what is y I want y to be the
 

2127
00:48:47,200 --> 00:48:51,030
skew of Y what is y I want y to be the
right child of X because we have

2128
00:48:51,030 --> 00:48:51,040
right child of X because we have
 

2129
00:48:51,040 --> 00:48:53,349
right child of X because we have
positive skew we know there is a right

2130
00:48:53,349 --> 00:48:53,359
positive skew we know there is a right
 

2131
00:48:53,359 --> 00:48:56,349
positive skew we know there is a right
child now uh because this was the lowest

2132
00:48:56,349 --> 00:48:56,359
child now uh because this was the lowest
 

2133
00:48:56,359 --> 00:48:58,990
child now uh because this was the lowest
bad we know that Y is actually good it's

2134
00:48:58,990 --> 00:48:59,000
bad we know that Y is actually good it's
 

2135
00:48:59,000 --> 00:49:01,990
bad we know that Y is actually good it's
either right heavy or even the two sub

2136
00:49:01,990 --> 00:49:02,000
either right heavy or even the two sub
 

2137
00:49:02,000 --> 00:49:04,829
either right heavy or even the two sub
trees have the same height or left heavy

2138
00:49:04,829 --> 00:49:04,839
trees have the same height or left heavy
 

2139
00:49:04,839 --> 00:49:05,990
trees have the same height or left heavy
the easy

2140
00:49:05,990 --> 00:49:06,000
the easy
 

2141
00:49:06,000 --> 00:49:11,309
the easy
cases uh

2142
00:49:11,309 --> 00:49:11,319

 

2143
00:49:11,319 --> 00:49:20,710

are when skew of Y is either one or

2144
00:49:20,710 --> 00:49:20,720

 

2145
00:49:20,720 --> 00:49:29,270

zero which I will draw

2146
00:49:29,270 --> 00:49:29,280

 

2147
00:49:29,280 --> 00:49:32,390

all right so double right arrow let's

2148
00:49:32,390 --> 00:49:32,400
all right so double right arrow let's
 

2149
00:49:32,400 --> 00:49:39,430
all right so double right arrow let's
say single right

2150
00:49:39,430 --> 00:49:39,440

 

2151
00:49:39,440 --> 00:49:42,309

arrow so this uh I'm just going to add

2152
00:49:42,309 --> 00:49:42,319
arrow so this uh I'm just going to add
 

2153
00:49:42,319 --> 00:49:47,549
arrow so this uh I'm just going to add
some labels here to make this picture

2154
00:49:47,549 --> 00:49:47,559

 

2155
00:49:47,559 --> 00:49:51,309

consistent uh k + one K plus two I'm

2156
00:49:51,309 --> 00:49:51,319
consistent uh k + one K plus two I'm
 

2157
00:49:51,319 --> 00:49:53,430
consistent uh k + one K plus two I'm
writing the heights so this is an

2158
00:49:53,430 --> 00:49:53,440
writing the heights so this is an
 

2159
00:49:53,440 --> 00:49:57,190
writing the heights so this is an
example where C is is taller than b

2160
00:49:57,190 --> 00:49:57,200
example where C is is taller than b
 

2161
00:49:57,200 --> 00:49:59,230
example where C is is taller than b
uh B A and B are the same height and

2162
00:49:59,230 --> 00:49:59,240
uh B A and B are the same height and
 

2163
00:49:59,240 --> 00:50:00,829
uh B A and B are the same height and
then if you compute the heights up here

2164
00:50:00,829 --> 00:50:00,839
then if you compute the heights up here
 

2165
00:50:00,839 --> 00:50:03,589
then if you compute the heights up here
indeed uh this one is right leaning this

2166
00:50:03,589 --> 00:50:03,599
indeed uh this one is right leaning this
 

2167
00:50:03,599 --> 00:50:05,829
indeed uh this one is right leaning this
one is doubly right leaning this one has

2168
00:50:05,829 --> 00:50:05,839
one is doubly right leaning this one has
 

2169
00:50:05,839 --> 00:50:07,470
one is doubly right leaning this one has
height K plus one this one has height K

2170
00:50:07,470 --> 00:50:07,480
height K plus one this one has height K
 

2171
00:50:07,480 --> 00:50:09,510
height K plus one this one has height K
minus one that's bad but if we do this

2172
00:50:09,510 --> 00:50:09,520
minus one that's bad but if we do this
 

2173
00:50:09,520 --> 00:50:13,589
minus one that's bad but if we do this
right rotation on X we get exactly what

2174
00:50:13,589 --> 00:50:13,599
right rotation on X we get exactly what
 

2175
00:50:13,599 --> 00:50:16,829
right rotation on X we get exactly what
we

2176
00:50:16,829 --> 00:50:16,839

 

2177
00:50:16,839 --> 00:50:19,630

want so I'm just going to copy the

2178
00:50:19,630 --> 00:50:19,640
want so I'm just going to copy the
 

2179
00:50:19,640 --> 00:50:22,670
want so I'm just going to copy the
labels on ABC we have k minus1 k minus

2180
00:50:22,670 --> 00:50:22,680
labels on ABC we have k minus1 k minus
 

2181
00:50:22,680 --> 00:50:24,950
labels on ABC we have k minus1 k minus
one and K and then recompute that means

2182
00:50:24,950 --> 00:50:24,960
one and K and then recompute that means
 

2183
00:50:24,960 --> 00:50:27,109
one and K and then recompute that means
this guy has height K this one has

2184
00:50:27,109 --> 00:50:27,119
this guy has height K this one has
 

2185
00:50:27,119 --> 00:50:30,510
this guy has height K this one has
height k + 1 and now all the nodes in

2186
00:50:30,510 --> 00:50:30,520
height k + 1 and now all the nodes in
 

2187
00:50:30,520 --> 00:50:32,030
height k + 1 and now all the nodes in
this picture that I've highlighted A and

2188
00:50:32,030 --> 00:50:32,040
this picture that I've highlighted A and
 

2189
00:50:32,040 --> 00:50:33,230
this picture that I've highlighted A and
C haven't changed they were height

2190
00:50:33,230 --> 00:50:33,240
C haven't changed they were height
 

2191
00:50:33,240 --> 00:50:35,630
C haven't changed they were height
balanced before they still are um but

2192
00:50:35,630 --> 00:50:35,640
balanced before they still are um but
 

2193
00:50:35,640 --> 00:50:37,789
balanced before they still are um but
now X and Y X wasn't height balanced

2194
00:50:37,789 --> 00:50:37,799
now X and Y X wasn't height balanced
 

2195
00:50:37,799 --> 00:50:41,069
now X and Y X wasn't height balanced
before y was now both X and Y are height

2196
00:50:41,069 --> 00:50:41,079
before y was now both X and Y are height
 

2197
00:50:41,079 --> 00:50:44,910
before y was now both X and Y are height
balanced okay that's case one in case

2198
00:50:44,910 --> 00:50:44,920
balanced okay that's case one in case
 

2199
00:50:44,920 --> 00:50:50,670
balanced okay that's case one in case
two the SK of Y is flat which means that

2200
00:50:50,670 --> 00:50:50,680
two the SK of Y is flat which means that
 

2201
00:50:50,680 --> 00:50:55,349
two the SK of Y is flat which means that
this is a k and this is a k and this is

2202
00:50:55,349 --> 00:50:55,359
this is a k and this is a k and this is
 

2203
00:50:55,359 --> 00:50:58,390
this is a k and this is a k and this is
a k + one and this this is a K plus 2

2204
00:50:58,390 --> 00:50:58,400
a k + one and this this is a K plus 2
 

2205
00:50:58,400 --> 00:50:59,789
a k + one and this this is a K plus 2
okay but still all the nodes are

2206
00:50:59,789 --> 00:50:59,799
okay but still all the nodes are
 

2207
00:50:59,799 --> 00:51:01,710
okay but still all the nodes are
balanced height balanced they're still

2208
00:51:01,710 --> 00:51:01,720
balanced height balanced they're still
 

2209
00:51:01,720 --> 00:51:03,950
balanced height balanced they're still
plus or minus one so those are the easy

2210
00:51:03,950 --> 00:51:03,960
plus or minus one so those are the easy
 

2211
00:51:03,960 --> 00:51:06,430
plus or minus one so those are the easy
cases unfortunately there is a hard

2212
00:51:06,430 --> 00:51:06,440
cases unfortunately there is a hard
 

2213
00:51:06,440 --> 00:51:10,150
cases unfortunately there is a hard
case case three but there's only one and

2214
00:51:10,150 --> 00:51:10,160
case case three but there's only one and
 

2215
00:51:10,160 --> 00:51:15,430
case case three but there's only one and
it's not that much

2216
00:51:15,430 --> 00:51:15,440

 

2217
00:51:15,440 --> 00:51:20,870

harder so it's when skew of Y is minus

2218
00:51:20,870 --> 00:51:20,880
harder so it's when skew of Y is minus
 

2219
00:51:20,880 --> 00:51:23,470
harder so it's when skew of Y is minus
one in this case we need to look at the

2220
00:51:23,470 --> 00:51:23,480
one in this case we need to look at the
 

2221
00:51:23,480 --> 00:51:27,309
one in this case we need to look at the
left child of Y

2222
00:51:27,309 --> 00:51:27,319
left child of Y
 

2223
00:51:27,319 --> 00:51:30,589
left child of Y
uh okay and to be alphabetical I'm going

2224
00:51:30,589 --> 00:51:30,599
uh okay and to be alphabetical I'm going
 

2225
00:51:30,599 --> 00:51:32,270
uh okay and to be alphabetical I'm going
to rename this to

2226
00:51:32,270 --> 00:51:32,280
to rename this to
 

2227
00:51:32,280 --> 00:51:35,710
to rename this to
Z sorry so this one again is double

2228
00:51:35,710 --> 00:51:35,720
Z sorry so this one again is double
 

2229
00:51:35,720 --> 00:51:38,670
Z sorry so this one again is double
right arrow this one is now left

2230
00:51:38,670 --> 00:51:38,680
right arrow this one is now left
 

2231
00:51:38,680 --> 00:51:42,549
right arrow this one is now left
arrow and this is letter Y and so we

2232
00:51:42,549 --> 00:51:42,559
arrow and this is letter Y and so we
 

2233
00:51:42,559 --> 00:51:44,870
arrow and this is letter Y and so we
have a

2234
00:51:44,870 --> 00:51:44,880
have a
 

2235
00:51:44,880 --> 00:51:49,710
have a
b c and d potential sub trees hanging

2236
00:51:49,710 --> 00:51:49,720
b c and d potential sub trees hanging
 

2237
00:51:49,720 --> 00:51:52,150
b c and d potential sub trees hanging
off of them and I'm going to label the

2238
00:51:52,150 --> 00:51:52,160
off of them and I'm going to label the
 

2239
00:51:52,160 --> 00:51:55,030
off of them and I'm going to label the
heights of these things these are each K

2240
00:51:55,030 --> 00:51:55,040
heights of these things these are each K
 

2241
00:51:55,040 --> 00:51:59,710
heights of these things these are each K
minus one or K minus 2 this one's K

2242
00:51:59,710 --> 00:51:59,720
minus one or K minus 2 this one's K
 

2243
00:51:59,720 --> 00:52:02,470
minus one or K minus 2 this one's K
minus one and now compute the inside so

2244
00:52:02,470 --> 00:52:02,480
minus one and now compute the inside so
 

2245
00:52:02,480 --> 00:52:04,589
minus one and now compute the inside so
this is going to be height k for this to

2246
00:52:04,589 --> 00:52:04,599
this is going to be height k for this to
 

2247
00:52:04,599 --> 00:52:08,950
this is going to be height k for this to
be uh left leaning so this is k + 1 and

2248
00:52:08,950 --> 00:52:08,960
be uh left leaning so this is k + 1 and
 

2249
00:52:08,960 --> 00:52:12,230
be uh left leaning so this is k + 1 and
this is k + 2 okay but the problem is

2250
00:52:12,230 --> 00:52:12,240
this is k + 2 okay but the problem is
 

2251
00:52:12,240 --> 00:52:13,910
this is k + 2 okay but the problem is
this is two higher than this the height

2252
00:52:13,910 --> 00:52:13,920
this is two higher than this the height
 

2253
00:52:13,920 --> 00:52:17,150
this is two higher than this the height
of Z is two higher than the height of a

2254
00:52:17,150 --> 00:52:17,160
of Z is two higher than the height of a
 

2255
00:52:17,160 --> 00:52:18,950
of Z is two higher than the height of a
in this case if I do this rotation

2256
00:52:18,950 --> 00:52:18,960
in this case if I do this rotation
 

2257
00:52:18,960 --> 00:52:21,670
in this case if I do this rotation
things get worse actually I'll just tell

2258
00:52:21,670 --> 00:52:21,680
things get worse actually I'll just tell
 

2259
00:52:21,680 --> 00:52:23,789
things get worse actually I'll just tell
you the right thing to

2260
00:52:23,789 --> 00:52:23,799
you the right thing to
 

2261
00:52:23,799 --> 00:52:25,510
you the right thing to
do

2262
00:52:25,510 --> 00:52:25,520
do
 

2263
00:52:25,520 --> 00:52:40,950
do
is this is the one thing you need to

2264
00:52:40,950 --> 00:52:40,960

 

2265
00:52:40,960 --> 00:52:43,870

memorize and let me draw the result you

2266
00:52:43,870 --> 00:52:43,880
memorize and let me draw the result you
 

2267
00:52:43,880 --> 00:52:45,309
memorize and let me draw the result you
can also just think of it as redrawing

2268
00:52:45,309 --> 00:52:45,319
can also just think of it as redrawing
 

2269
00:52:45,319 --> 00:52:48,549
can also just think of it as redrawing
the tree like this uh but it's easier

2270
00:52:48,549 --> 00:52:48,559
the tree like this uh but it's easier
 

2271
00:52:48,559 --> 00:52:50,150
the tree like this uh but it's easier
from an analysis perspective to think

2272
00:52:50,150 --> 00:52:50,160
from an analysis perspective to think
 

2273
00:52:50,160 --> 00:52:52,109
from an analysis perspective to think
about it is two rotations so then we can

2274
00:52:52,109 --> 00:52:52,119
about it is two rotations so then we can
 

2275
00:52:52,119 --> 00:52:53,950
about it is two rotations so then we can
just reduce as long as we know rotations

2276
00:52:53,950 --> 00:52:53,960
just reduce as long as we know rotations
 

2277
00:52:53,960 --> 00:52:56,510
just reduce as long as we know rotations
work then we know that this thing works

2278
00:52:56,510 --> 00:52:56,520
work then we know that this thing works
 

2279
00:52:56,520 --> 00:52:58,510
work then we know that this thing works
Works meaning it preserves traversal

2280
00:52:58,510 --> 00:52:58,520
Works meaning it preserves traversal
 

2281
00:52:58,520 --> 00:53:00,150
Works meaning it preserves traversal
order and we can maintain all the

2282
00:53:00,150 --> 00:53:00,160
order and we can maintain all the
 

2283
00:53:00,160 --> 00:53:02,630
order and we can maintain all the
augmentations so now if I copy over

2284
00:53:02,630 --> 00:53:02,640
augmentations so now if I copy over
 

2285
00:53:02,640 --> 00:53:04,710
augmentations so now if I copy over
these labels the height labels I have K

2286
00:53:04,710 --> 00:53:04,720
these labels the height labels I have K
 

2287
00:53:04,720 --> 00:53:06,670
these labels the height labels I have K
minus one I have for these two guys K

2288
00:53:06,670 --> 00:53:06,680
minus one I have for these two guys K
 

2289
00:53:06,680 --> 00:53:09,870
minus one I have for these two guys K
minus one or k minus 2 biggest one is

2290
00:53:09,870 --> 00:53:09,880
minus one or k minus 2 biggest one is
 

2291
00:53:09,880 --> 00:53:13,670
minus one or k minus 2 biggest one is
Kus one this is K minus one and so this

2292
00:53:13,670 --> 00:53:13,680
Kus one this is K minus one and so this
 

2293
00:53:13,680 --> 00:53:18,069
Kus one this is K minus one and so this
will be K this will be K this will be k

2294
00:53:18,069 --> 00:53:18,079
will be K this will be K this will be k
 

2295
00:53:18,079 --> 00:53:20,990
will be K this will be K this will be k
+ one and lo and behold we have a nice

2296
00:53:20,990 --> 00:53:21,000
+ one and lo and behold we have a nice
 

2297
00:53:21,000 --> 00:53:24,470
+ one and lo and behold we have a nice
height balanc Tree in all three cases

2298
00:53:24,470 --> 00:53:24,480
height balanc Tree in all three cases
 

2299
00:53:24,480 --> 00:53:26,750
height balanc Tree in all three cases
for this one node now this was the low

2300
00:53:26,750 --> 00:53:26,760
for this one node now this was the low
 

2301
00:53:26,760 --> 00:53:29,150
for this one node now this was the low
node once we update this one it could be

2302
00:53:29,150 --> 00:53:29,160
node once we update this one it could be
 

2303
00:53:29,160 --> 00:53:31,789
node once we update this one it could be
that um we changed the height of the

2304
00:53:31,789 --> 00:53:31,799
that um we changed the height of the
 

2305
00:53:31,799 --> 00:53:35,710
that um we changed the height of the
root before it was k + 2 now it's k+ one

2306
00:53:35,710 --> 00:53:35,720
root before it was k + 2 now it's k+ one
 

2307
00:53:35,720 --> 00:53:37,549
root before it was k + 2 now it's k+ one
or sometimes we keep it the same like

2308
00:53:37,549 --> 00:53:37,559
or sometimes we keep it the same like
 

2309
00:53:37,559 --> 00:53:40,349
or sometimes we keep it the same like
over in this case uh and so now we have

2310
00:53:40,349 --> 00:53:40,359
over in this case uh and so now we have
 

2311
00:53:40,359 --> 00:53:41,910
over in this case uh and so now we have
to check the parent maybe the parent is

2312
00:53:41,910 --> 00:53:41,920
to check the parent maybe the parent is
 

2313
00:53:41,920 --> 00:53:44,230
to check the parent maybe the parent is
out of balance we just keep walking up

2314
00:53:44,230 --> 00:53:44,240
out of balance we just keep walking up
 

2315
00:53:44,240 --> 00:53:46,069
out of balance we just keep walking up
the node and also maintain all the

2316
00:53:46,069 --> 00:53:46,079
the node and also maintain all the
 

2317
00:53:46,079 --> 00:53:48,150
the node and also maintain all the
augmentations as we go then we'll keep

2318
00:53:48,150 --> 00:53:48,160
augmentations as we go then we'll keep
 

2319
00:53:48,160 --> 00:53:49,990
augmentations as we go then we'll keep
track of height and subtree size if we

2320
00:53:49,990 --> 00:53:50,000
track of height and subtree size if we
 

2321
00:53:50,000 --> 00:53:52,309
track of height and subtree size if we
want them or any other augmentations and

2322
00:53:52,309 --> 00:53:52,319
want them or any other augmentations and
 

2323
00:53:52,319 --> 00:53:54,630
want them or any other augmentations and
after order H operations we will have

2324
00:53:54,630 --> 00:53:54,640
after order H operations we will have
 

2325
00:53:54,640 --> 00:53:56,069
after order H operations we will have
restored the height balance property

2326
00:53:56,069 --> 00:53:56,079
restored the height balance property
 

2327
00:53:56,079 --> 00:53:58,470
restored the height balance property
which means all the way through H equals

2328
00:53:58,470 --> 00:53:58,480
which means all the way through H equals
 

2329
00:53:58,480 --> 00:54:00,349
which means all the way through H equals
order log n and so all of our operations

2330
00:54:00,349 --> 00:54:00,359
order log n and so all of our operations
 

2331
00:54:00,359 --> 00:54:04,680
order log n and so all of our operations
now are magically order log n

