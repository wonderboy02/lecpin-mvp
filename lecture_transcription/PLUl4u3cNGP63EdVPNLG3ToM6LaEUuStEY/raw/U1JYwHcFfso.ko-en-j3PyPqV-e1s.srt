1
00:00:00,000 --> 00:00:04,473
[삐걱거리는 소리]
[바스락거리는 소리] [딸깍거리는 소리]

2
00:00:12,740 --> 00:00:15,920
에릭 데메인: 자,
다시 자료구조의 세계로 오신 것을 환영합니다.

3
00:00:15,920 --> 00:00:21,140
오늘은
이진 트리에 대한 내용을 계속해서 마무리하겠습니다.  자,

4
00:00:21,140 --> 00:00:23,030
이게 2부입니다.

5
00:00:23,030 --> 00:00:26,180
파트 1을 못 보셨다면,
돌아가서 파트 1을 시청하세요.

6
00:00:26,180 --> 00:00:30,650
지난 시간에는
이진 트리에 대해 전반적으로 이야기했습니다.

7
00:00:30,650 --> 00:00:36,980
각 노드에는
항목 하나와 다른 노드를 가리키는 왼쪽 포인터

8
00:00:36,980 --> 00:00:38,570
와 오른쪽 포인터
,

9
00:00:38,570 --> 00:00:41,420
그리고
다른 노드를 가리키는 부모 포인터가 저장되어 있었습니다.

10
00:00:41,420 --> 00:00:43,910
이것은 나무의 한 예였습니다.

11
00:00:43,910 --> 00:00:45,965
B와 C는 A의 자녀입니다.

12
00:00:45,965 --> 00:00:49,010
A는 B
와 C의 부모이며,

13
00:00:49,010 --> 00:00:50,330
전체 트리의 뿌리이기도 합니다.

14
00:00:50,330 --> 00:00:51,847
우리는 노드의 높이를 정의했습니다.

15
00:00:51,847 --> 00:00:53,180
아직 이걸 많이 사용하지는 않았어요.

16
00:00:53,180 --> 00:00:54,763
하지만
오늘 우리는 이걸 많이 사용할 거예요.

17
00:00:54,763 --> 00:00:58,460
그러니 높이는
여기 빨간색으로 표시된 것과 같다는 것을 기억하세요.

18
00:00:58,460 --> 00:01:02,390
노드의 높이는 간선을 포함하여
가장 긴 하향 경로의 길이입니다

19
00:01:02,390 --> 00:01:03,230
.

20
00:01:03,230 --> 00:01:05,510
예를 들어 B는 길이가
2인 경로를 가지고 있습니다.

21
00:01:05,510 --> 00:01:07,070
그래서 여기에 2를 씁니다.

22
00:01:07,070 --> 00:01:09,560
또한,

23
00:01:09,560 --> 00:01:14,600

B를 루트로 하는 서브트리, 즉 B 서브트리 내에서만 생활한다고 생각할 수도 있습니다.

24
00:01:14,600 --> 00:01:17,612
그렇다면
해당 노드들의 최대 깊이는 얼마일까요? (이런 방식으로

25
00:01:17,612 --> 00:01:19,320
생각하는 것을 선호하신다면 말입니다
.)

26
00:01:19,320 --> 00:01:20,750
어느 쪽이든 괜찮습니다.

27
00:01:20,750 --> 00:01:22,730
특히,
우리는 루트 노드

28
00:01:22,730 --> 00:01:25,460
의 높이인 h를

29
00:01:25,460 --> 00:01:27,360
전체 트리의 높이로 구분했습니다.  지난번에

30
00:01:27,360 --> 00:01:29,450
우리가 이룬 것은
기본적으로

31
00:01:29,450 --> 00:01:32,850
모든 작업이
시간 순서대로 진행되었다는 것입니다.

32
00:01:32,850 --> 00:01:37,730
그래서 우리는 서브트리 삽입,
서브트리 삭제, 서브트리 시작

33
00:01:37,730 --> 00:01:38,270
및 종료 기능을 가지고 있었습니다.

34
00:01:38,270 --> 00:01:40,187
우리는 노드의
이전 노드와 다음 노드를

35
00:01:40,187 --> 00:01:42,780
모두 순서대로 h시간 안에 계산할 수 있습니다.

36
00:01:42,780 --> 00:01:48,170
그래서 h가
작을 때는 우리는 행복했습니다.

37
00:01:48,170 --> 00:01:50,510
그리고
전임자와 후임자가 무엇을 의미하는지 기억하세요.

38
00:01:50,510 --> 00:01:54,320
이는
트리의 암묵적인 순서, 즉

39
00:01:54,320 --> 00:01:57,590
순회 순서에 관한 것으로,

40
00:01:57,590 --> 00:02:02,330
왼쪽
서브트리를 재귀적으로 순회한 다음 루트를 출력하고,

41
00:02:02,330 --> 00:02:05,040
다시
오른쪽 서브트리를 재귀적으로 순회하는 방식으로 정의됩니다.

42
00:02:05,040 --> 00:02:10,520
이 예시에서
순회 순서는 F가 맨

43
00:02:10,520 --> 00:02:13,130

왼쪽에 있고, F가

44
00:02:13,130 --> 00:02:14,930
순회 순서상 첫 번째입니다.

45
00:02:14,930 --> 00:02:19,430
그럼 이제... 네, 제가
여기 공간을 좀 만들게요.

46
00:02:19,430 --> 00:02:24,140
그다음 D가 있고,
그다음 B가 있습니다. 그다음

47
00:02:24,140 --> 00:02:26,000

B의 오른쪽 서브트리

48
00:02:26,000 --> 00:02:30,590
인 E를 처리합니다. 마지막으로
루트가 있는데,

49
00:02:30,590 --> 00:02:32,310
루트의 왼쪽 서브트리를 이미 처리했기 때문입니다.  자,

50
00:02:32,310 --> 00:02:37,220
이게 A입니다. 그리고 C가 있죠.

51
00:02:37,220 --> 00:02:40,910
그러니까
이 트리에는 암묵적인 선형 순서가 인코딩되어 있는 겁니다.

52
00:02:40,910 --> 00:02:42,770

이진 트리의 핵심은 배열 등에 순서를

53
00:02:42,770 --> 00:02:46,220


54
00:02:46,220 --> 00:02:49,160
명시적으로 적어두는 것보다 훨씬 빠르게 트리를 효율적으로 업데이트할 수 있다는 점입니다

55
00:02:49,160 --> 00:02:50,130
.

56
00:02:50,130 --> 00:02:53,480
그래서 이진 트리는 우리가 빠르게 할 수 있게 해줬는데

57
00:02:53,480 --> 00:02:55,520
, 지금은 그 '빠른'이라는 말이
그렇게 빠르지는 않네요.

58
00:02:55,520 --> 00:02:56,990
모든 것이 h 순서이기 때문입니다.

59
00:02:56,990 --> 00:02:58,790
최악의
경우, h는 선형적입니다.

60
00:02:58,790 --> 00:03:00,350
우리는 이런
나무를 가질 수 있으니까요.

61
00:03:03,200 --> 00:03:05,120
하지만 오늘 우리는

62
00:03:05,120 --> 00:03:07,490
h가 log n임을 보장할 것입니다.

63
00:03:07,490 --> 00:03:09,050
그래서
오늘 우리의 목표는 이미 살펴본 데이터 구조를 수정하는 것만으로

64
00:03:09,050 --> 00:03:12,080

시간 복잡도가 h인 모든 연산을 시간

65
00:03:12,080 --> 00:03:14,405

복잡도가 log n이 되도록 만드는 것입니다

66
00:03:14,405 --> 00:03:16,530

.

67
00:03:16,530 --> 00:03:18,822
그래서 우리는
어려운 작업의 대부분을 마쳤고,

68
00:03:18,822 --> 00:03:21,590

오늘

69
00:03:21,590 --> 00:03:25,370
AVL 트리 또는 높이 균형 조정이라고 하는 작업에 대해 조금 더 신경 써야 합니다.

70
00:03:25,370 --> 00:03:28,650
하지만 그 전에,

71
00:03:28,650 --> 00:03:30,150

지난 강의 마지막 부분에서

72
00:03:30,150 --> 00:03:32,970

서브트리 연산, 즉

73
00:03:32,970 --> 00:03:36,110

서브트리에 삽입과 삭제를 할 수 있게 된 것에 대해 이야기했었는데, 이 연산을

74
00:03:36,110 --> 00:03:38,780
어떻게 활용해서

75
00:03:38,780 --> 00:03:41,630
이번 수업에서 다루는
시퀀스 자료구조와 집합

76
00:03:41,630 --> 00:03:42,870
자료구조 문제를 해결할 수 있는지 좀 더 자세히 살펴보겠습니다.

77
00:03:42,870 --> 00:03:47,910

지난번에는 주로 집합 데이터 구조에 대해 이야기했습니다.

78
00:03:47,910 --> 00:03:50,810
일반적으로

79
00:03:50,810 --> 00:03:53,780
이진 트리에서 유지하는 순회 순서를 정의하겠습니다.

80
00:03:53,780 --> 00:03:58,730
그래서 집합의 경우,
집합 인터페이스에서는 `

81
00:03:58,730 --> 00:04:01,700

find_next`

82
00:04:01,700 --> 00:04:04,642
나 `find_previous`와 같은 쿼리를 수행하는 데 관심이 있습니다. 즉, 주어진
키가 있을 때 해당 키가 없으면

83
00:04:04,642 --> 00:04:06,350
이전
값을, 다음 값을 알려주는 쿼리인데,

84
00:04:06,350 --> 00:04:08,720
이는
이진 탐색을 통해 수행할 수 있습니다.

85
00:04:08,720 --> 00:04:12,170

이진 트리의 가장 큰 장점은, 저장된

86
00:04:12,170 --> 00:04:16,279

모든 항목을 키의 오름차순

87
00:04:16,279 --> 00:04:18,680
으로 정렬하여 순회하면

88
00:04:18,680 --> 00:04:23,450

항목들을

89
00:04:23,450 --> 00:04:24,680
순회 순서대로 유지할 수 있다는 것입니다.

90
00:04:24,680 --> 00:04:27,210
다시 말씀드리지만, 저희는 그것들을 명시적으로
순서대로 유지하고 있지는 않습니다.

91
00:04:27,210 --> 00:04:29,840
하지만 여기서는 주요

92
00:04:29,840 --> 00:04:32,300
항목들을 순서대로 나타내는 트리 구조를 유지하고 있습니다.  따라서

93
00:04:32,300 --> 00:04:37,640
이를 통해 다음과 같이
하위 트리 찾기 작업을 수행할 수 있습니다. 이 작업을 사용하여

94
00:04:37,640 --> 00:04:40,220

찾기, 이전 찾기 등을 쉽게 구현할 수 있습니다

95
00:04:42,500 --> 00:04:43,800
.

96
00:04:43,800 --> 00:04:45,890
우리는
나무의 뿌리부터 시작합니다.

97
00:04:45,890 --> 00:04:48,770
그러므로
초기에는 노드가 루트와 같다고 할 수 있습니다.

98
00:04:48,770 --> 00:04:52,770
그런 다음 다음과 같이 키 k를 재귀적으로
검색할 수 있습니다.

99
00:04:52,770 --> 00:04:56,900
음, 우리는
루트에 있는 항목의

100
00:04:56,900 --> 00:04:59,490
키가 k보다 큰지 확인합니다

101
00:04:59,490 --> 00:05:00,890
. 그림을 좀 그려볼게요.

102
00:05:04,200 --> 00:05:08,348
그러니까 우리는 지금 어떤 노드에 있는 거죠.

103
00:05:08,348 --> 00:05:10,220
이것은 노드입니다.

104
00:05:10,220 --> 00:05:13,550
그리고 왼쪽 서브트리
와 오른쪽 서브트리가 있습니다.

105
00:05:13,550 --> 00:05:16,780
그리고 어떤
열쇠가 달린 물건이 있어요.

106
00:05:16,780 --> 00:05:20,260
만약 우리가 찾고 있는 키가
노드의 항목보다 작다면,

107
00:05:20,260 --> 00:05:23,080
그것은
왼쪽 하위 트리에 있다는 것을 의미합니다.

108
00:05:23,080 --> 00:05:25,510
그래서 우리는 노드의 왼쪽 부분을 재귀적으로 호출합니다.  두 값이 같으면

109
00:05:25,510 --> 00:05:27,900
,
이 물건이

110
00:05:27,900 --> 00:05:29,150
우리가 찾던 물건이라는 뜻입니다.

111
00:05:29,150 --> 00:05:30,848
따라서 원하시는 바에 따라 해당 객체 또는 노드를 반환할 수 있습니다

112
00:05:30,848 --> 00:05:32,390

.

113
00:05:32,390 --> 00:05:34,690
그리고 여기에 있는 키가 우리가 찾고 있는
키보다 크면

114
00:05:34,690 --> 00:05:38,650

오른쪽으로 재귀 호출을 합니다.

115
00:05:38,650 --> 00:05:40,570

조금만 생각해 보면,

116
00:05:40,570 --> 00:05:43,600
이것은
배열에 대한 이진 탐색과 정확히 같습니다.

117
00:05:43,600 --> 00:05:46,120

단지 우연히 나무 위에 있을 뿐이죠.

118
00:05:46,120 --> 00:05:55,330

배열을 이런 식으로 생각하면

119
00:05:55,330 --> 00:05:56,500
이진 탐색은 무엇을 하는 것일까요?

120
00:05:56,500 --> 00:05:58,340
먼저
가운데 있는 열쇠를 살펴봅니다.  저것을

121
00:05:58,340 --> 00:06:00,160

뿌리로 그리겠습니다.

122
00:06:00,160 --> 00:06:04,060
그런 다음,
왼쪽 영역(

123
00:06:04,060 --> 00:06:08,110
제가 재귀적으로 그릴 영역)
또는 오른쪽 영역에 대해 재귀적으로 호출됩니다.

124
00:06:08,110 --> 00:06:10,240
따라서 이와 같은
완벽한 이진

125
00:06:10,240 --> 00:06:13,690
트리가 있다면, 이는

126
00:06:13,690 --> 00:06:15,048
해당 배열에서 이진 검색을 정확하게 시뮬레이션하는 것입니다.

127
00:06:15,048 --> 00:06:17,590
하지만 우리는 이것을
동적으로 유지할 수 있을 것입니다. 더 이상

128
00:06:17,590 --> 00:06:19,690
완벽하지는 않겠지만, 거의 완벽에 가까워질 것입니다.

129
00:06:19,690 --> 00:06:23,180
반면에 우리는 이것을
정렬된 순서대로 유지할 수 없었습니다.

130
00:06:23,180 --> 00:06:27,160
그러니까 이건
이진 탐색을 일반화해서 배열 대신

131
00:06:27,160 --> 00:06:30,670
트리에서 작동하도록 만든 거라고 할 수 있죠
.

132
00:06:30,670 --> 00:06:34,445
이러한 이유로 집합 이진
트리는 이진 탐색 트리라고 불립니다.

133
00:06:34,445 --> 00:06:36,820
왜냐하면
이진 탐색의 트리 버전이기 때문입니다.

134
00:06:36,820 --> 00:06:38,450
그래서
비슷한 의미를 가진 이름들이 많습니다.

135
00:06:38,450 --> 00:06:41,140
따라서 이진 검색 트리는
집합 이진 트리의 다른 이름입니다.

136
00:06:41,140 --> 00:06:43,720

이 알고리즘이 작동하는 핵심은

137
00:06:43,720 --> 00:06:45,970
소위 이진
검색 트리 속성인데, 이는

138
00:06:45,970 --> 00:06:50,050

노드의 왼쪽 서브트리에 있는 모든 키가

139
00:06:50,050 --> 00:06:54,100

루트 또는 해당 노드의 키보다 작고,

140
00:06:54,100 --> 00:06:57,880
해당 키는 오른쪽
서브트리에 있는 모든 키보다 작다는 것입니다.

141
00:06:57,880 --> 00:07:00,380
그리고 이는
모든 단계에서 재귀적으로 성립합니다.

142
00:07:00,380 --> 00:07:02,950
그래서 이

143
00:07:02,950 --> 00:07:04,850
속성을 통해 이 알고리즘이 올바르다는 것을 증명할 수 있습니다.

144
00:07:04,850 --> 00:07:06,170
왜 그럴까요?

145
00:07:06,170 --> 00:07:09,160
만약 우리가 키의
순회 순서를 오름차순으로 유지할 수 있다면

146
00:07:09,160 --> 00:07:12,010

, 그것이

147
00:07:12,010 --> 00:07:13,983
바로
순회 순서의 의미이기 때문입니다.  이는

148
00:07:13,983 --> 00:07:16,150

왼쪽 서브트리의 모든 요소가

149
00:07:16,150 --> 00:07:18,070
루트보다 먼저 오고, 루트는

150
00:07:18,070 --> 00:07:18,945
오른쪽 서브트리의 모든 요소보다 먼저 온다는 것을 의미합니다.

151
00:07:18,945 --> 00:07:23,680
그러므로 이 속성은
이 속성을 암시합니다.

152
00:07:23,680 --> 00:07:26,110
그렇다면
키 순서를 오름차순으로 유지하는 방법은 무엇인가요?

153
00:07:26,110 --> 00:07:27,790
꽤 쉬워요.

154
00:07:27,790 --> 00:07:31,240
만약 어떤 항목을 삽입하고 싶다면
, 어디에 삽입해야 할까요?

155
00:07:31,240 --> 00:07:33,760
음, 이 검색을 하는 이유는 그것이

156
00:07:33,760 --> 00:07:35,380
거기에 있다면 어디에 속해야 하는지를 찾기 위해서입니다.  해당 값이 있다면

157
00:07:35,380 --> 00:07:38,260
,
그 값으로 저장된 값을 덮어쓸 수 있습니다.

158
00:07:38,260 --> 00:07:42,393
그렇지 않으면 이
검색은

159
00:07:42,393 --> 00:07:43,810
어느 시점에서 트리에서 제외될 것이고
, 그 지점에

160
00:07:43,810 --> 00:07:48,850

트리에 새 노드를 삽입해야 합니다.

161
00:07:48,850 --> 00:07:51,610
그 내용은 수업 시간에 다뤘으니 자세히
언급하고 싶지 않네요.

162
00:07:51,610 --> 00:07:54,920
오늘 제가 집중하고 싶은 것은
다른 응용 프로그램입니다.

163
00:07:54,920 --> 00:07:57,160
우리는 어떻게 할까요? 이것은
집합을 표현하는 방법인데,

164
00:07:57,160 --> 00:07:59,080
비교적 간단합니다.  우리가 앞으로 해결해야 할

165
00:07:59,080 --> 00:08:01,960
과제 중 하나는

166
00:08:01,960 --> 00:08:03,970


167
00:08:03,970 --> 00:08:07,540
순차 이진 트리를 만드는 것인데, 이는 약간의 추가 작업이 필요합니다.  예를 들어

168
00:08:07,540 --> 00:08:10,787
이진 트리가 있다고 가정해 보겠습니다.

169
00:08:10,787 --> 00:08:12,370

지난 시간에 언급했듯이,

170
00:08:12,370 --> 00:08:15,640

트리의 순회 순서가 삽입(insert_at)과 같은 연산에 의해 변경되는 순서

171
00:08:15,640 --> 00:08:20,470

, 즉 제가

172
00:08:20,470 --> 00:08:22,960
표현하고자 하는 순서와 같도록 하고 싶습니다

173
00:08:22,960 --> 00:08:26,380
.  저도

174
00:08:26,380 --> 00:08:28,473

똑같이 하고 싶어요.

175
00:08:28,473 --> 00:08:30,640
하지만 이제는
검색은 어떻게 해야 하는지,

176
00:08:30,640 --> 00:08:32,650
삽입은 어떻게 해야 하는지 등을 생각해야 합니다
.

177
00:08:32,650 --> 00:08:36,789

제가 작업하고 싶은 알고리즘은 다음과 같습니다.

178
00:08:36,789 --> 00:08:40,059
하지만
아직은 제대로 작동하지 않을 것 같습니다.  자, 제가

179
00:08:40,059 --> 00:08:45,700

노드로 지정된 서브트리를 하나 드린다고 가정해 봅시다.

180
00:08:45,700 --> 00:08:49,060
그러니까
그 노드의 모든 후손들이 거기에 있는 겁니다.

181
00:08:49,060 --> 00:08:52,360
그리고 저는 여기서 시작해서 여기서 끝나는

182
00:08:52,360 --> 00:08:55,570
해당 서브트리의 순회 순서가 어떻게 되는지 알고 싶습니다.

183
00:08:55,570 --> 00:08:58,250
루트는
중간 어딘가에 있을 겁니다.  i번째

184
00:08:58,250 --> 00:09:01,100
노드를 알려주세요.

185
00:09:01,100 --> 00:09:03,430
그러니까 만약 제가 i가
0이라고 요청한다면, 가장

186
00:09:03,430 --> 00:09:05,230
왼쪽에 있는 자손을 얻고 싶습니다.

187
00:09:05,230 --> 00:09:08,800
만약 제가 i가
트리의 크기에서 1을 뺀 값과 같다고 요청한다면,

188
00:09:08,800 --> 00:09:11,380
저는 가장
오른쪽에 있는 자손을 얻고 싶습니다.

189
00:09:11,380 --> 00:09:13,835
그것이 우리가 이야기했던 하위 트리의 처음이자 마지막 항목이었습니다

190
00:09:13,835 --> 00:09:14,710
.

191
00:09:14,710 --> 00:09:16,840
하지만 우리는
처음과 마지막을 찾는 방법을 알고 있습니다.

192
00:09:16,840 --> 00:09:18,220
왼쪽으로 가거나 오른쪽으로 가세요.

193
00:09:18,220 --> 00:09:22,180
하지만 우리는
i번째 노드를 찾는 방법을 모릅니다.

194
00:09:22,180 --> 00:09:26,110

지금 목표는 log n이 아니라 h 시간 안에 찾는 것입니다.

195
00:09:26,110 --> 00:09:30,400
요점은, 음,
크기가 중요한 것 같다는 겁니다.

196
00:09:30,400 --> 00:09:34,070
[웃음] 혹시
다른 이야기를 들으셨다면 죄송합니다.

197
00:09:34,070 --> 00:09:36,940
특히, 제가

198
00:09:36,940 --> 00:09:40,300

시퀀스의 마지막 노드에 대해 이야기할 때 크기에 대해 언급했습니다.

199
00:09:40,300 --> 00:09:44,860
해당 노드의 인덱스는
서브트리의 크기에서 1을 뺀 값입니다.

200
00:09:44,860 --> 00:09:51,250
따라서
노드의 크기를

201
00:09:51,250 --> 00:09:57,310


202
00:09:57,310 --> 00:09:59,050

해당 노드를 포함하는 서브트리(서브트리(노드))에 있는 노드의 개수로 정의하겠습니다

203
00:10:06,510 --> 00:10:09,100
.

204
00:10:09,100 --> 00:10:11,340
그러므로 만약 제가
그 크기를 알 수 있다면, 이는

205
00:10:11,340 --> 00:10:13,590

인덱스를 이해하는 데 중요해 보입니다.

206
00:10:13,590 --> 00:10:16,530

내가 마치 마법처럼

207
00:10:16,530 --> 00:10:17,280
일정한 시간 속에서 그 사실을 알게 되었다고 가정해 보자.

208
00:10:19,980 --> 00:10:23,200
그렇다면
왼쪽 하위 트리의 크기가...

209
00:10:23,200 --> 00:10:25,350

이 다이어그램을 조금 확대해 보겠습니다.

210
00:10:29,060 --> 00:10:31,910
그래서 우리는 이전과 같은 노드를 가지고 있습니다.

211
00:10:31,910 --> 00:10:36,120
하지만 우리에게는 왼쪽 서브트리
와 오른쪽 서브트리가 있습니다.

212
00:10:36,120 --> 00:10:37,700
여기 있는 이 노드는 node.left입니다.

213
00:10:37,700 --> 00:10:39,080
여기 있는 이 노드는 node.right입니다.  그런 경우는

214
00:10:39,080 --> 00:10:42,500
존재하지 않을 수도 있지만, 일단은
예외적인 사례는 무시하도록 하죠

215
00:10:42,500 --> 00:10:43,760
.

216
00:10:43,760 --> 00:10:47,190

노드의 크기뿐만

217
00:10:47,190 --> 00:10:49,280
아니라
노드의 왼쪽 크기,

218
00:10:49,280 --> 00:10:53,780
즉
왼쪽 트리의 크기까지 알고 있다고 가정해 봅시다.

219
00:10:53,780 --> 00:10:55,070
저는 그걸 nL이라고 부를 거예요.

220
00:10:55,070 --> 00:10:59,000
그럼
여기에 nL개의 노드가 있다고 가정해 봅시다.  저는 그것이

221
00:10:59,000 --> 00:11:03,770

이진 탐색과 동일한 작업을 수행할 수 있게 해준다고 주장합니다.

222
00:11:03,770 --> 00:11:06,440

인덱스 i를 찾고 있기 때문입니다.

223
00:11:06,440 --> 00:11:10,737
그리고 만약 i가 nL보다 작다면, 저는
그것이 분명히 여기 아래에 있다는 것을 알 수 있습니다.

224
00:11:10,737 --> 00:11:12,320
예를 들어, i가
0이면 nL이 0보다 큰 한

225
00:11:12,320 --> 00:11:16,490
왼쪽 서브트리에 위치하게 되는 거죠

226
00:11:16,490 --> 00:11:16,990
?

227
00:11:16,990 --> 00:11:19,190
그러니까 이 수표가 바로 그겁니다.

228
00:11:19,190 --> 00:11:21,080
i가 nL보다 작으면

229
00:11:21,080 --> 00:11:25,860
왼쪽으로 재귀적으로 이동하여
노드.left의 하위 트리를 호출하고 i를 호출합니다.

230
00:11:25,860 --> 00:11:27,830
여기에 그렇게 쓰여 있어요.

231
00:11:27,830 --> 00:11:31,430
만약 i가 nL과 같다면, 잠시 생각해 보세요.

232
00:11:31,430 --> 00:11:33,150
여기서 nL은 노드의 개수입니다.

233
00:11:33,150 --> 00:11:37,340
따라서 이
노드의 인덱스는 nL입니다.

234
00:11:37,340 --> 00:11:39,500
이 노드의 인덱스는 nL입니다.

235
00:11:39,500 --> 00:11:42,770
그래서 만약 i가
우리가 찾고 있는 인덱스와 같다면

236
00:11:42,770 --> 00:11:44,780
, 우리는
이 노드를 반환합니다.

237
00:11:44,780 --> 00:11:46,460
끝났어요.

238
00:11:46,460 --> 00:11:48,920
그렇지 않은 경우에는 i가
nL보다 큽니다.  즉,

239
00:11:48,920 --> 00:11:50,930

우리가 찾고 있는 노드는

240
00:11:50,930 --> 00:11:54,590

루트 다음에 오기 때문에 올바른 서브트리에 있다는 뜻입니다.

241
00:11:54,590 --> 00:11:56,263
다시 말하지만, 그게 바로 그 의미입니다.

242
00:11:56,263 --> 00:11:57,680
그것이 바로 순회
순서의 의미입니다.

243
00:11:57,680 --> 00:12:00,830
따라서 이를
순차적인 순서로 정의한다면, 인덱스 nL인 이

244
00:12:00,830 --> 00:12:03,920

노드 다음에 오는 모든 것은 반드시

245
00:12:03,920 --> 00:12:06,120
여기에 있어야 한다는 것을 알 수 있습니다.

246
00:12:06,120 --> 00:12:08,870
이제 여기서 재귀 호출을 하면
번호 체계가 바뀝니다.

247
00:12:08,870 --> 00:12:12,320
노드의 경우 0이 여기에 있기 때문입니다.

248
00:12:12,320 --> 00:12:15,060
그리고 노드의 경우 여기에 있습니다.

249
00:12:15,060 --> 00:12:17,630
그래서
여기서 약간의 뺄셈을 해야 하는데, 오른쪽으로

250
00:12:17,630 --> 00:12:19,310
재귀 호출을 할 때

251
00:12:19,310 --> 00:12:22,580
i - nL - 1을 계산합니다. 여기서
nL은 이들에 대한 값이고,

252
00:12:22,580 --> 00:12:25,925
1은 루트 노드에 대한 값입니다.

253
00:12:25,925 --> 00:12:27,800
그러면

254
00:12:27,800 --> 00:12:30,980
이 하위 트리 내에서 우리가 찾고 있는 인덱스를 얻을 수 있습니다.

255
00:12:30,980 --> 00:12:34,400
그러니까 제 요점은, 이
알고리즘은 기본적으로

256
00:12:34,400 --> 00:12:35,600
이 알고리즘과 동일하다는 것입니다.

257
00:12:35,600 --> 00:12:39,080
하지만 이 경우에는 키를 사용합니다. 왜냐하면
우리는 집합을 다루고 있고,

258
00:12:39,080 --> 00:12:41,450
집합에서는 각
항목이 키를 가지고 있다고 가정하기 때문입니다.

259
00:12:41,450 --> 00:12:43,520
여기서는 물건에
열쇠가 필요하지 않습니다.

260
00:12:43,520 --> 00:12:45,810
사실, 우리는
물건들을 전혀 만지지 않고 있어요.

261
00:12:45,810 --> 00:12:49,823
우리는 단순히 "
내 시퀀스에서 i번째 항목은 무엇인가?"라고 묻는 것인데, 이는 "

262
00:12:49,823 --> 00:12:52,490

내 순회 순서에서 i번째 항목은 무엇인가?" 또는 "

263
00:12:52,490 --> 00:12:54,560


264
00:12:54,560 --> 00:12:56,600
순회 순서에서 i번째 노드는 무엇인가?"라고 묻는 것과 같은 의미입니다.

265
00:12:56,600 --> 00:12:58,310
그리고 이 알고리즘은

266
00:12:58,310 --> 00:13:01,090

h시간 안에 정확히 같은 방식으로 결과를 제공합니다.

267
00:13:03,547 --> 00:13:05,630
자, 제가
모든 작동 과정을 보여드리지는 않겠습니다.

268
00:13:05,630 --> 00:13:11,930
하지만 subtree_at을 사용하여
get_at set_at을 구현할 수 있습니다.

269
00:13:11,930 --> 00:13:15,050
적절한
노드를 찾아서 항목을 반환

270
00:13:15,050 --> 00:13:17,180
하거나 항목을 수정하면 됩니다.

271
00:13:17,180 --> 00:13:19,070
또는 이를 사용하여

272
00:13:19,070 --> 00:13:21,950
가장 중요한 것은
insert_at delete_at 작업을 수행할 수 있다는 것입니다.

273
00:13:21,950 --> 00:13:25,090
이건 우리가
전에는 결코 할 수 없었던 새로운 일입니다.

274
00:13:25,090 --> 00:13:25,970
무슨 일을 하세요?

275
00:13:25,970 --> 00:13:28,670
여기에서처럼, 만약 제가
어떤 항목을 삽입하려고 한다면,

276
00:13:28,670 --> 00:13:33,300

여기서 그 항목을 검색하면 됩니다.  예를 들어

277
00:13:33,300 --> 00:13:36,710

, i 위치에 삽입하려고 한다면 i를 찾습니다.

278
00:13:36,710 --> 00:13:43,490
그리고 insert_at i 구문에서,
바로 그 항목 앞에 새 항목을 추가하고 싶습니다

279
00:13:43,490 --> 00:13:44,990
.

280
00:13:44,990 --> 00:13:47,870
그리고 다행히도, 저는 이미

281
00:13:47,870 --> 00:13:50,810

서브트리 삽입 기능을 가지고 있습니다. (언급은 안 했지만요.)

282
00:13:50,810 --> 00:13:55,470
우리는 이전 버전과 이후 버전, 이렇게 두 가지 버전을 가지고 있었습니다
.  우리가

283
00:13:55,470 --> 00:13:59,270
나중에 다뤘듯이,
저는

284
00:13:59,270 --> 00:14:01,130
선행사보다 후임사를 먼저 사용합니다.

285
00:14:01,130 --> 00:14:04,280
하지만 해당 노드에서
서브트리 삽입을 호출하기만 하면

286
00:14:04,280 --> 00:14:09,470


287
00:14:09,470 --> 00:14:12,230
바로 그 앞에 새 항목이 추가됩니다.

288
00:14:12,230 --> 00:14:15,710
그리고 놀랍게도, 어떻게 된 일인지,
우리는

289
00:14:15,710 --> 00:14:18,080

이 순서의 중간에 무언가를 삽입했습니다.  인덱스를 저장하지 않기 때문에

290
00:14:18,080 --> 00:14:21,980
모든 인덱스가 업데이트됩니다

291
00:14:21,980 --> 00:14:23,210
.

292
00:14:23,210 --> 00:14:25,730
대신,
인덱스 i에 있는 항목을 검색하기 위해

293
00:14:25,730 --> 00:14:28,820
검색 알고리즘을 사용합니다.

294
00:14:28,820 --> 00:14:31,460
하지만 문제가 있습니다.

295
00:14:31,460 --> 00:14:32,300
무슨 문제예요?

296
00:14:36,520 --> 00:14:39,190
이건 너무
좋은 조건이라 믿기 어려워요.

297
00:14:39,190 --> 00:14:41,500

이 트리의 중간에

298
00:14:41,500 --> 00:14:44,350
무언가를 삽입했는데, 신기하게도 그 후에도

299
00:14:44,350 --> 00:14:47,350
i번째 항목을 검색할 수 있습니다. 심지어 해당 항목
오른쪽에 있는 모든 인덱스가

300
00:14:47,350 --> 00:14:48,760
1씩 증가했는데도 말이죠.

301
00:14:52,580 --> 00:14:54,720
거의 완벽한 현상입니다.

302
00:14:54,720 --> 00:14:55,220
답변?

303
00:14:58,020 --> 00:14:59,280
응?

304
00:14:59,280 --> 00:15:00,755
청중: [잘 안 들림]

305
00:15:00,755 --> 00:15:03,130
에릭 드메인:
사이즈를 업데이트해야 하니까요.

306
00:15:03,130 --> 00:15:06,350

왼쪽 서브트리의 크기를 어떻게 계산하냐고는 말하지 않았습니다.  자,

307
00:15:06,350 --> 00:15:07,660
그럼 다음 주제는 이것입니다.

308
00:15:11,950 --> 00:15:12,850
거의 다 끝났어요.

309
00:15:12,850 --> 00:15:14,510
이건 실제로 효과가 있을 겁니다.

310
00:15:14,510 --> 00:15:16,780
정말 멋지네요.

311
00:15:16,780 --> 00:15:18,790
하지만 이를 위해서는

312
00:15:18,790 --> 00:15:22,837
서브트리
증강이라는 것이 필요한데, 이에

313
00:15:22,837 --> 00:15:23,920
대해 전반적으로 설명드리겠습니다.

314
00:15:23,920 --> 00:15:25,390
그다음에는
크기에 적용해 보겠습니다.  서브트리 증강

315
00:15:30,370 --> 00:15:32,590
의 핵심 아이디어는

316
00:15:32,590 --> 00:15:37,900

이진 트리의 각 노드가

317
00:15:37,900 --> 00:15:45,100
일정한
개수의 추가 필드를 저장할 수 있다는 것입니다.

318
00:15:45,100 --> 00:15:46,780
왜 안 돼?

319
00:15:46,780 --> 00:15:49,750
특히,
이러한 필드들이

320
00:15:49,750 --> 00:15:51,610
특정 유형이라면,

321
00:15:51,610 --> 00:15:53,260
저는 그것들을 속성이라고 부르겠습니다.

322
00:15:57,700 --> 00:16:10,030
저는
하위 트리 속성을 노드 자식

323
00:16:10,030 --> 00:16:21,330


324
00:16:21,330 --> 00:16:25,520
의 속성으로부터 계산할 수 있는 것으로 정의하겠습니다
.

325
00:16:28,740 --> 00:16:30,780
그러니까 제가 말해야 할 것은
이것이 노드의 일부라는 것입니다.

326
00:16:37,230 --> 00:16:42,030
따라서 자식 노드는
node.left와 node.right입니다.

327
00:16:42,030 --> 00:16:44,655
또한 노드 자체와 같은 다른 여러 요소에도 일정한 양으로 접근할 수 있습니다

328
00:16:44,655 --> 00:16:47,620
.

329
00:16:47,620 --> 00:16:49,140
하지만
서브트리 속성의 핵심은

330
00:16:49,140 --> 00:16:50,490
아래쪽을 향한다는 점입니다.

331
00:16:50,490 --> 00:16:57,360
만약 여기에 노드가 있고
, 그 노드의

332
00:16:57,360 --> 00:17:00,750

속성(예: P)을 계산해서 저장하고

333
00:17:00,750 --> 00:17:06,000
싶다고 가정해 봅시다.

334
00:17:06,000 --> 00:17:09,270
그리고 이미

335
00:17:09,270 --> 00:17:11,910

왼쪽 서브트리

336
00:17:11,910 --> 00:17:13,710
또는 왼쪽
노드에 대해 계산된 속성 P를 알고 있고, 오른쪽 노드에

337
00:17:13,710 --> 00:17:17,970
대한 속성도 알고 있다고 가정할 때
,

338
00:17:17,970 --> 00:17:20,369
이 계산이
상수 시간 안에 이루어지기를 바랍니다.

339
00:17:26,160 --> 00:17:29,750
따라서
왼쪽 노드의 P

340
00:17:29,750 --> 00:17:30,870
와 오른쪽 노드의 P가 주어지면 이 노드의 P를 계산할 수 있습니다.

341
00:17:30,870 --> 00:17:32,340
그건 서브트리 속성이에요.

342
00:17:32,340 --> 00:17:38,340
특히 크기는
기판의 속성입니다.

343
00:17:38,340 --> 00:17:39,510
왜?

344
00:17:39,510 --> 00:17:43,830

이런 식으로 재귀 관계를 쓸 수 있기 때문에,

345
00:17:43,830 --> 00:17:49,282
노드 크기는
노드 왼쪽 크기와 같고(이렇게

346
00:17:49,282 --> 00:17:52,470
쓰는 건 너무 번거롭지만), 거기에

347
00:17:52,470 --> 00:17:59,580
노드 오른쪽 크기를 더하고, 또 다른 요소를 더하는 식으로요?

348
00:18:03,790 --> 00:18:05,955
1. 감사합니다.

349
00:18:05,955 --> 00:18:11,185

여기서 노드라고 불리는 전체 서브트리의 크기는

350
00:18:11,185 --> 00:18:13,810
왼쪽 서브트리의 크기와
오른쪽 서브트리의 크기를 더한 후,

351
00:18:13,810 --> 00:18:17,290
해당 노드 자체의 크기인 1을 더한 값입니다.

352
00:18:17,290 --> 00:18:18,865
이것은 업데이트 규칙입니다.

353
00:18:18,865 --> 00:18:20,530

평가하는 데는 지속적인 시간이 필요합니다.

354
00:18:20,530 --> 00:18:22,990
두 가지 버전이 있습니다.

355
00:18:22,990 --> 00:18:27,250
죄송합니다, 제가 쓴 't'자가 마치
더하기 기호처럼 보이네요.  플러스(+) 기호를

356
00:18:27,250 --> 00:18:29,390

조금 더 크게 만들겠습니다.

357
00:18:35,750 --> 00:18:38,030
그러니까 우리는
그 세 가지를 합산하는 겁니다.

358
00:18:38,030 --> 00:18:40,020
짜잔, 노드 크기를 얻을 수 있습니다.

359
00:18:40,020 --> 00:18:46,980
따라서
제 속성에 이 기능이 있는 한, 트리 구조를 변경하면서

360
00:18:46,980 --> 00:18:51,680
이를 동적으로 유지할 수 있다고 주장합니다
.

361
00:18:51,680 --> 00:18:53,722
자, 이건
앞으로 일어날 일을 미리 언급하는 셈인데,

362
00:18:53,722 --> 00:18:55,430
왜냐하면 우리가

363
00:18:55,430 --> 00:18:56,638
아직 트리 구조를 정확히 어떻게 바꿀지 말하지 않았기 때문입니다.

364
00:18:56,638 --> 00:18:57,710
그런데 질문이 있어요?

365
00:18:57,710 --> 00:19:01,100
청중: 노드의 크기를
재귀적으로 호출한다면,

366
00:19:01,100 --> 00:19:03,290
어떻게
상수 시간 안에 이루어질 수 있을까요?  그런 일이 일어나지

367
00:19:03,290 --> 00:19:05,150
않을까요?
[잘 안 들림]

368
00:19:05,150 --> 00:19:06,275
에릭 드메인: 왜 그럴까요?

369
00:19:06,275 --> 00:19:07,290
좋은 질문입니다.

370
00:19:07,290 --> 00:19:09,080
따라서 한 가지 자연스러운
방법은

371
00:19:09,080 --> 00:19:10,850
이것을 재귀로 생각하는 것이며, 그러면

372
00:19:10,850 --> 00:19:12,750
재귀 알고리즘이 됩니다.

373
00:19:12,750 --> 00:19:14,780
그래서 나는 글을 썼지만, 사실은 쓰지 않았다
.

374
00:19:14,780 --> 00:19:18,140
하지만 저는
노드의 크기가 이것과 같다고 쓸 수도 있었습니다. 즉,

375
00:19:18,140 --> 00:19:19,910
노드의 왼쪽 크기에 -를 더한 값입니다.
그러면

376
00:19:19,910 --> 00:19:23,030

크기를 계산하는 데 선형 시간 알고리즘이 주어집니다.

377
00:19:23,030 --> 00:19:24,710
만약
아무런 정보가 없다면,

378
00:19:24,710 --> 00:19:27,218
당신도 그렇게 할 겁니다.  그건 정말 고통

379
00:19:27,218 --> 00:19:28,510
스러울 거예요.

380
00:19:28,510 --> 00:19:30,427
그러면 이
알고리즘은 매우 느려질 것입니다.

381
00:19:30,427 --> 00:19:33,860
size를
재귀 함수로 호출하는 것은 좋지 않습니다.

382
00:19:33,860 --> 00:19:36,410
대신 저는

383
00:19:36,410 --> 00:19:41,510
모든 노드에 크기를 저장하고
이를 미리 계산하는 방식을 사용하고 있습니다.

384
00:19:41,510 --> 00:19:46,220
그래서 사실, 저는
노드의 크기를

385
00:19:46,220 --> 00:19:48,440

수학적으로 정의하려고 합니다.

386
00:19:48,440 --> 00:19:50,000
하지만
이 함수의 알고리즘은

387
00:19:50,000 --> 00:19:53,600
단순히
노드의 크기를 반환할 것입니다.

388
00:19:53,600 --> 00:19:55,610
그러니까 그건 일정한 시간이라는 거죠.

389
00:19:55,610 --> 00:19:58,100
그래서 지금 제가 직면한 과제는 나무에 어떤 작업을 하든
이 크기들을 최신 상태로 유지해야 한다는 것입니다

390
00:19:58,100 --> 00:20:00,470

.

391
00:20:00,470 --> 00:20:02,450
그리고
지난 강의를 다시 살펴보면서

392
00:20:02,450 --> 00:20:06,500
,
내가 나무에 어떤 변화를 주었는지 확인할 수 있을 거예요.

393
00:20:06,500 --> 00:20:09,620
저희는
삽입 및 삭제 과정에서만 변경 작업을 수행했습니다.

394
00:20:09,620 --> 00:20:16,940
그리고 제가 여러분께 말씀드리자면,
삽입과 삭제 기능을 구현했을 때, 결국

395
00:20:16,940 --> 00:20:22,640
그들이 한 일은

396
00:20:22,640 --> 00:20:29,090

나무의 잎을 추가하거나 제거하는 것이었습니다.

397
00:20:35,050 --> 00:20:39,170
리프 노드는
자식 노드가 없는 노드라는 것을 기억하세요.

398
00:20:39,170 --> 00:20:42,730
자, 그럼
나무에 새 잎을 하나 추가한다고 생각해 봅시다.

399
00:20:42,730 --> 00:20:45,440
여기 나무가 있는데,
여기에 잎을 하나 추가하면

400
00:20:45,440 --> 00:20:48,160
어떤 하위 나무들이 변할까요?

401
00:20:48,160 --> 00:20:52,570
그렇다면
해당 노드를 포함하는 서브트리는 어떤 것들인가요?

402
00:20:52,570 --> 00:20:54,040
그것은 그 자체로 새로운 하위 트리입니다.

403
00:20:54,040 --> 00:20:58,480
그러면 해당 하위 트리는 상위 하위 트리,
조부모 하위 트리,

404
00:20:58,480 --> 00:21:00,970
그리고 전체 하위 트리에 속하게 됩니다.

405
00:21:00,970 --> 00:21:04,240
일반적으로 이러한 노드들을

406
00:21:04,240 --> 00:21:06,250
우리가 추가한 노드의 조상이라고 부릅니다.

407
00:21:06,250 --> 00:21:07,930
그리고 그것들이 바로
업데이트되는 것들입니다.

408
00:21:07,930 --> 00:21:10,360
이쪽 하위 트리는
변하지 않았습니다.

409
00:21:10,360 --> 00:21:11,560
크기는 변하지 않았습니다.

410
00:21:11,560 --> 00:21:13,770
그리고 이는
하위 트리 속성이기 때문에

411
00:21:13,770 --> 00:21:15,520
하위 트리가 변경되지 않았으므로 여기에서는 하위 트리 속성이 변경되지 않습니다

412
00:21:15,520 --> 00:21:18,370

.

413
00:21:18,370 --> 00:21:22,630
그래서 이 부분을 건드릴 때는

414
00:21:22,630 --> 00:21:24,610

여기 서브트리 속성을 업데이트하고, 여기

415
00:21:24,610 --> 00:21:25,990
서브트리 속성을 업데이트하고
,

416
00:21:25,990 --> 00:21:27,190
여기 서브트리 속성을 업데이트하기만 하면 됩니다.

417
00:21:27,190 --> 00:21:28,357
이것들은 몇 개나 있을까요?

418
00:21:32,220 --> 00:21:33,730
응?

419
00:21:33,730 --> 00:21:36,500
h-- 안전을 위해 h 순서라고 하겠습니다.

420
00:21:36,500 --> 00:21:40,090
하지만 제 생각엔 그게 바로 h인 것 같아요.

421
00:21:40,090 --> 00:21:42,610
마찬가지로, 잎을 제거할 때도
같은 현상이 발생합니다.

422
00:21:42,610 --> 00:21:44,830
이 잎을 제거하면 변경되는
하위 트리는

423
00:21:44,830 --> 00:21:46,870
정확히
그 잎의 이전 조상 트리가 됩니다.

424
00:21:51,430 --> 00:22:01,360
좋아요, 그럼 이제

425
00:22:01,360 --> 00:22:13,770
트리의 위쪽 순서대로 h 조상들을 업데이트해 보겠습니다.

426
00:22:13,770 --> 00:22:15,950
그렇다면 제가 말하는 '업데이트'란 무엇을 의미하는 걸까요?  제 말은

427
00:22:15,950 --> 00:22:18,740
이 규칙을 적용하라는 뜻입니다.

428
00:22:18,740 --> 00:22:21,810
크기에 있어서는 이 규칙이 적용됩니다.

429
00:22:21,810 --> 00:22:23,540
하지만 일반적으로
서브트리 속성은

430
00:22:23,540 --> 00:22:26,250

일정한 시간이 걸리는 업데이트 규칙을 제공합니다.

431
00:22:26,250 --> 00:22:28,820
그래서 저는 이 노드에 해당
업데이트 규칙을 적용하여

432
00:22:28,820 --> 00:22:32,570


433
00:22:32,570 --> 00:22:33,560
거기에 저장된 속성을 수정할 것입니다.

434
00:22:33,560 --> 00:22:35,130

부동산이 하나 이상일 수도 있습니다.

435
00:22:35,130 --> 00:22:36,630
그런 다음
이 노드에 적용하겠습니다.

436
00:22:36,630 --> 00:22:40,040
그리고 이것은
귀납적으로 이미 올바르고,

437
00:22:40,040 --> 00:22:42,470

제가 이 서브트리를 건드리지 않았기 때문에(변경되지 않았기 때문에) 이미 올바르므로,

438
00:22:44,030 --> 00:22:46,790

이 노드의 값, 즉

439
00:22:46,790 --> 00:22:49,160
이 노드의 속성을
상수 시간 안에 업데이트할 수 있습니다.

440
00:22:49,160 --> 00:22:51,200
그런 다음 이 항목을 업데이트합니다.

441
00:22:51,200 --> 00:22:53,468
그리고 이것은
귀납적으로 이미 올바르고,

442
00:22:53,468 --> 00:22:55,760

이 하위 트리가

443
00:22:55,760 --> 00:22:58,880
변경되지 않았기 때문에 저것도 이미 올바르므로,
여기서 속성을

444
00:22:58,880 --> 00:23:00,500
상수 시간 안에 정확하게 업데이트할 수 있습니다.

445
00:23:00,500 --> 00:23:03,170
따라서
h번의 시간 안에 순서를 변경할 때, 상수 시간 알고리즘을

446
00:23:03,170 --> 00:23:06,200
h번 호출하기 때문에

447
00:23:06,200 --> 00:23:11,570
상수
개수의 서브트리 속성을 업데이트할 수 있습니다.

448
00:23:11,570 --> 00:23:12,620
이것은 매우 강력합니다.

449
00:23:12,620 --> 00:23:14,660
데이터 구조 증강은
매우 유용합니다.

450
00:23:14,660 --> 00:23:16,160
여러분은 이 자료를 문제 풀이에 활용하게 될 것입니다
.

451
00:23:16,160 --> 00:23:19,080
우리는 오늘도 그것을 다시 사용할 것입니다.

452
00:23:19,080 --> 00:23:22,550

서브트리 속성의 몇 가지 예를 들어보겠습니다.

453
00:23:27,980 --> 00:23:35,060
그것들은 여러 가지가 될 수 있습니다. 흔히 볼 수 있는 예로는 서브트리의 모든 노드의 특정 특징에 대한 합,
곱,

454
00:23:35,060 --> 00:23:42,290
최소값,
최대값, 제곱합

455
00:23:42,290 --> 00:23:50,090
등 다양한
것들이 있습니다

456
00:23:50,090 --> 00:23:52,055
.

457
00:23:57,860 --> 00:24:01,310
사실, 서브트리 크기가
그러한 예 중 하나입니다.

458
00:24:01,310 --> 00:24:05,990
이는 서브트리에 있는 모든 노드 중에서
값이 1인 노드의 합계입니다. 즉,

459
00:24:05,990 --> 00:24:08,510

노드의 개수를 세는 것과 같은 의미입니다.

460
00:24:08,510 --> 00:24:10,460
하지만 이렇게도
말할 수 있습니다. "

461
00:24:10,460 --> 00:24:11,697
이 노드들에 있는 키들의 합은 얼마입니까?"

462
00:24:11,697 --> 00:24:14,030
또는 이렇게 말할 수도 있습니다. "
이 노드들에서 최대 키 값은 무엇인가요?"

463
00:24:14,030 --> 00:24:21,737
또는 이렇게 말할 수도 있습니다.
이 노드들의 최댓값은 무엇입니까?

464
00:24:21,737 --> 00:24:22,820
어떤 물건이든 가져가실 수 있습니다.  꼭

465
00:24:22,820 --> 00:24:23,900
중요한 요소일 필요는 없습니다.  특별히 정해진 것이 있을 필요는

466
00:24:23,900 --> 00:24:25,775
없습니다
.

467
00:24:25,775 --> 00:24:26,730
매우 강력합니다.

468
00:24:26,730 --> 00:24:28,808
모든 합계와
곱셈 결과를 아래쪽으로 향하는 형태로 유지하고 관리할 수 있습니다.

469
00:24:28,808 --> 00:24:30,350


470
00:24:30,350 --> 00:24:33,890
즉,
하위 트리에 대해서만 생각하면 됩니다.  유지 관리할 수 없는

471
00:24:33,890 --> 00:24:38,860
것들의 예로는

472
00:24:41,880 --> 00:24:45,345
노드 인덱스가 아닌 것들이 있습니다.

473
00:24:48,480 --> 00:24:51,750

증강현실에 너무 흥분하면 '

474
00:24:51,750 --> 00:24:54,150
아,
난 뭐든지 할 수 있겠어'라고 생각할 수도 있죠.

475
00:24:54,150 --> 00:24:56,850
저는 `
subtree_at`, 또는

476
00:24:56,850 --> 00:24:59,370
간단히 말해서 `get_at` 함수를
전역적으로 지원해야 했습니다.

477
00:24:59,370 --> 00:25:01,500

제 트리에서 i번째 노드가 무엇인지 알고 싶었습니다.

478
00:25:01,500 --> 00:25:03,690
음, 데이터
구조 증강을 사용해서

479
00:25:03,690 --> 00:25:09,240
각 노드에
인덱스(0부터 n-1까지)를 저장하면 될 것 같네요. 하지만 그렇게 하면 효율적으로

480
00:25:09,240 --> 00:25:11,370
관리할 수 없을 것 같아요
.

481
00:25:11,370 --> 00:25:13,890


482
00:25:13,890 --> 00:25:18,340
순회 순서의 맨 처음에 삽입하면
모든 인덱스가 변경되기 때문입니다.  이것이 바로

483
00:25:18,340 --> 00:25:20,910
편집의 예시입니다.

484
00:25:20,910 --> 00:25:23,530
만약
여기에 새 노드를 삽입하면,

485
00:25:23,530 --> 00:25:25,650
이 노드의 인덱스는
0이었는데 이제 1이 되고,

486
00:25:25,650 --> 00:25:27,780
이 노드의 인덱스는
1이었는데 이제

487
00:25:27,780 --> 00:25:29,430
2가 되고, 이 노드는 2가었는데 이제
3이 되는 식입니다.

488
00:25:29,430 --> 00:25:31,380
모든 노드는 인덱스를 변경합니다.

489
00:25:31,380 --> 00:25:33,750
인덱스는 서브트리 속성이 아니므로 유지

490
00:25:33,750 --> 00:25:35,280
관리할 수 없습니다.

491
00:25:35,280 --> 00:25:37,497

트리의 모든 노드에 의존하기 때문입니다.

492
00:25:37,497 --> 00:25:39,330
혹은
왼쪽에 있는 모든 노드, 즉

493
00:25:39,330 --> 00:25:40,900
모든 선행 노드에 따라 달라집니다.

494
00:25:40,900 --> 00:25:43,440
예를 들어, 이
노드의 인덱스는 왼쪽에 있는

495
00:25:43,440 --> 00:25:46,140
노드의 개수에 따라 달라지는데
,

496
00:25:46,140 --> 00:25:47,980
이 노드의 서브트리에는 해당 노드가 포함되지 않습니다.

497
00:25:47,980 --> 00:25:50,400
그래서 그 부분을
조심해야 합니다.  트리의

498
00:25:50,400 --> 00:25:52,630
전역 속성을 사용하지 마십시오
.  하위 트리 속성

499
00:25:52,630 --> 00:25:57,760
만 사용할 수 있습니다
.

500
00:25:57,760 --> 00:26:01,755
또 다른 예로는 깊이가 있습니다.

501
00:26:01,755 --> 00:26:08,220
깊이감 유지 관리가 까다롭지만, 그
이유는 아직 명확하지 않습니다.  잠시 후에 알게

502
00:26:08,220 --> 00:26:09,780
될 것입니다.

503
00:26:14,610 --> 00:26:20,220
오늘 남은 시간은 이 슬라이드에서 보여주는 것처럼
h차에서 log n차로 넘어가는 것에 대한 내용입니다

504
00:26:20,220 --> 00:26:23,770

.

505
00:26:23,770 --> 00:26:26,460
따라서 이 시점에서 여러분은

506
00:26:26,460 --> 00:26:30,180
시퀀스 데이터 구조의 모든
연산을 생성(build)

507
00:26:30,180 --> 00:26:33,130
과 반복(iterate) 연산(선형 시간 복잡도)을 제외하고 h 시간 안에 수행할 수 있으며,

508
00:26:33,130 --> 00:26:36,750

집합(set)의 모든 연산도 생성(build)

509
00:26:36,750 --> 00:26:38,460
과
반복(iterate) 연산(

510
00:26:38,460 --> 00:26:40,620
각각 n log n과 n 시간 복잡도)을 제외하고 h 시간 안에 수행할 수 있다고 믿어야 합니다.

511
00:26:40,620 --> 00:26:50,790
그리고 우리의 목표는
이제 h를 log n으로 제한하는 것입니다.

512
00:26:50,790 --> 00:26:53,670


513
00:26:53,670 --> 00:26:57,450

로그 함수적으로 키가 자라는 나무들이 존재하기 때문에 어느 정도는 가능하다는 것을 알고 있습니다.  저건 마치

514
00:26:57,450 --> 00:27:00,565

완벽한 나무 같네요.

515
00:27:00,565 --> 00:27:02,190
하지만 우리도 조심해야 한다는 것을 알고 있습니다.

516
00:27:02,190 --> 00:27:04,320
왜냐하면
이 사슬처럼 나쁜 나무들도 있기 때문입니다.

517
00:27:07,170 --> 00:27:15,140
따라서 h가 log n과 같으면
이를 균형 이진 트리라고 합니다.  세상에는

518
00:27:19,430 --> 00:27:21,200

균형 이진 트리가 많이 있습니다.

519
00:27:21,200 --> 00:27:24,302
아마
십여 개에서 스무 개 정도 될 겁니다.

520
00:27:24,302 --> 00:27:25,760
다양한
데이터 구조가 존재하죠.

521
00:27:25,760 --> 00:27:26,260
질문?

522
00:27:26,260 --> 00:27:28,825
청중: [잘 안 들림]

523
00:27:28,825 --> 00:27:30,933

세계적인 차원에서 생각하지 말라고 하셨는데,

524
00:27:30,933 --> 00:27:32,433
그럼 저희가 생각해 볼게요.
[잘 안 들림]…

525
00:27:32,433 --> 00:27:34,382

그게 무슨 뜻인지 좀 더 자세히 설명해 주시겠어요?

526
00:27:34,382 --> 00:27:35,840
에릭 데메인: 좋습니다.

527
00:27:35,840 --> 00:27:40,520
속성이
서브트리에 로컬이라는 것과 전역적이라는 것은 각각 어떤 의미인가요?

528
00:27:40,520 --> 00:27:43,075
가장 적절한 답변은
다음 정의입니다.

529
00:27:43,075 --> 00:27:45,200
하지만 그것은 아마도
가장 직관적인 정의는 아닐 겁니다.

530
00:27:45,200 --> 00:27:46,033
제가 말하려는 게 바로 이겁니다.

531
00:27:46,033 --> 00:27:48,782


532
00:27:48,782 --> 00:27:50,240
왼쪽 자녀
와 오른쪽 자녀에 대한 정보만 알면 계산할 수 있는 것,

533
00:27:50,240 --> 00:27:52,220
그것이 바로
그러한 속성의 의미입니다.

534
00:27:52,220 --> 00:27:54,595
그리고
당신이 유지할 수 있는 것은 이것들뿐입니다.

535
00:27:54,595 --> 00:27:57,320


536
00:27:57,320 --> 00:28:00,500

이 길을 따라 올라가면 쉽게 업데이트할 수 있는 것은 그것들뿐이기 때문입니다.

537
00:28:00,500 --> 00:28:06,050
그리고 그와 대조적으로
인덱스와 같은 전역 속성은

538
00:28:06,050 --> 00:28:08,000
전역적이라는 점이 중요합니다.
왜냐하면 노드를

539
00:28:08,000 --> 00:28:12,140
하나 추가하는 등의 변경 작업을 하면 해당
노드의 모든

540
00:28:12,140 --> 00:28:13,030
속성이 변경되기 때문입니다.

541
00:28:13,030 --> 00:28:15,470
그러니까 그건
세계화의 극단적인 예죠.

542
00:28:15,470 --> 00:28:20,180
우리가 '
로컬'이라는 개념을 원하는 이유는,

543
00:28:20,180 --> 00:28:23,570

실제로 우리가 재계산할 여력이 있는 부분이 바로 그 '로컬'이기 때문입니다.

544
00:28:23,570 --> 00:28:24,920
이해가 되셨기를 바랍니다.

545
00:28:24,920 --> 00:28:27,008
응?

546
00:28:27,008 --> 00:28:31,630
청중: 사이즈가 저거랑 안 맞지 않나요?
[잘 안 들림]

547
00:28:31,630 --> 00:28:33,700
에릭 데메인:
맞아요, 만약 우리가 추가한다면...

548
00:28:33,700 --> 00:28:34,255
아, 안 돼요.

549
00:28:34,255 --> 00:28:35,380
좋아요, 한번 생각해 봅시다.

550
00:28:35,380 --> 00:28:37,340
만약 우리가 트리 구조에 새로운 부모를 추가한다면,

551
00:28:37,340 --> 00:28:40,600
이는
우리가 지금까지 해본 적 없는 일입니다.

552
00:28:40,600 --> 00:28:44,500
하지만 그렇게 한다고 해도
어떤 하위 트리가 변경될까요?

553
00:28:44,500 --> 00:28:47,740
이것 하나뿐이에요.

554
00:28:47,740 --> 00:28:50,410
이 노드는
완전히 새로운 서브트리입니다.

555
00:28:50,410 --> 00:28:52,780
하지만 이 노드의 서브트리는
완전히 변경되지 않았습니다.

556
00:28:52,780 --> 00:28:54,655
서브트리는
항상 아래쪽을 향하고 있기 때문에,

557
00:28:54,655 --> 00:28:58,270
새 루트를 추가해도
서브트리 중 하나를 제외하고는 아무것도 변경되지 않습니다

558
00:28:58,270 --> 00:28:59,890
.

559
00:28:59,890 --> 00:29:01,790
따라서 크기는 서브트리 속성입니다.

560
00:29:01,790 --> 00:29:03,490
자, 그러니까, 제가

561
00:29:03,490 --> 00:29:05,510

그 계통도를 완전히 다시 그릴 수도 있다는 거죠.

562
00:29:05,510 --> 00:29:07,510
그리고 그것은
모든 것을

563
00:29:07,510 --> 00:29:08,980
다시 계산해야 하는 작업입니다.

564
00:29:08,980 --> 00:29:11,740
그래서
트리 구조 내에서 제가 할 수 있는 일이 정확히 제한됩니다.

565
00:29:11,740 --> 00:29:13,960
하지만 저는
지난 수업

566
00:29:13,960 --> 00:29:18,410
과 오늘 수업에서 우리가 할 모든 것을 고려할 때,
이러한 증설 비용을 감당할 수 있다고 주장합니다.

567
00:29:18,410 --> 00:29:21,100
그러니까
모든 이진 트리에 반드시 나타나는 특징은 아니지만,

568
00:29:21,100 --> 00:29:22,600

우리가 다룰 이진 트리들에 공통적으로 나타나는 특징입니다.

569
00:29:22,600 --> 00:29:23,100
응?

570
00:29:23,100 --> 00:29:24,395
청중: 분이란 무엇인가요?

571
00:29:24,395 --> 00:29:25,562
에릭 데메인: 분이란 무엇인가요?

572
00:29:25,562 --> 00:29:27,370
청중: [잘 안 들림]

573
00:29:27,370 --> 00:29:31,360
에릭 데메인: 이진 트리, 맞아요.  네

574
00:29:31,360 --> 00:29:35,260
,
잠시 후

575
00:29:35,260 --> 00:29:38,100
우리가 나무들을 가지고 실제로 무엇을 할 건지 말씀드리면 좀 더 이해가 되실 거예요
.  나무 구조를 조작할 수 있는

576
00:29:49,060 --> 00:29:53,830
새로운 도구가 필요합니다
.  지금까지

577
00:29:53,830 --> 00:29:56,530
우리는
물건들을 교환해 왔습니다.

578
00:29:56,530 --> 00:29:59,110
그리고 우리는
잎을 붙이고 떼는 실험을 했습니다.

579
00:29:59,110 --> 00:30:00,010
그것으로는 충분하지 않습니다.

580
00:30:00,010 --> 00:30:01,990


581
00:30:01,990 --> 00:30:05,320
로그 스케일의 높이를 보장하려면 다른 무언가가 필요할 겁니다.

582
00:30:05,320 --> 00:30:07,900
그리고 그 다른 무언가를
회전이라고 합니다.

583
00:30:12,050 --> 00:30:15,350
이 다른 무언가는 무엇을 해야 할까요
?

584
00:30:15,350 --> 00:30:18,470
이것은
트리의 균형을 재조정하는 도구일 뿐입니다.

585
00:30:18,470 --> 00:30:22,280
따라서
트리로 표현된 데이터는 변경되지 않아야 합니다.

586
00:30:22,280 --> 00:30:24,320

이 트리는 어떤 데이터를 나타내는가?

587
00:30:24,320 --> 00:30:25,940
순회 순서.

588
00:30:25,940 --> 00:30:27,660
이동 순서는 신성불가침입니다.

589
00:30:27,660 --> 00:30:28,910
우리는 그것을 만지면 안 돼요.

590
00:30:28,910 --> 00:30:31,250


591
00:30:31,250 --> 00:30:34,410

집합을 사용하는지 순서를 사용하는지에 따라 이미 두 가지 다른 방식으로 정의되어 있습니다.

592
00:30:34,410 --> 00:30:37,130
따라서 우리는

593
00:30:37,130 --> 00:30:39,380
순회 순서를 변경하지 않는 방식으로 트리를 수정하고 싶습니다.

594
00:30:39,380 --> 00:30:41,510
그러니까 우리는 중복성을 활용하고 있는 겁니다.

595
00:30:41,510 --> 00:30:43,820

배열의 순회 순서를 적어 놓으면,

596
00:30:43,820 --> 00:30:45,590


597
00:30:45,590 --> 00:30:46,940
주어진 순서에 대한 표현은 정확히 하나뿐입니다.

598
00:30:46,940 --> 00:30:49,340
하지만 나무에는
여러 가지 의미가 담겨 있습니다.

599
00:30:49,340 --> 00:30:50,840
줄이 길어질 수도 있어요.

600
00:30:50,840 --> 00:30:52,520
균형의 문제일 수도 있습니다.

601
00:30:52,520 --> 00:30:54,770

노드에

602
00:30:54,770 --> 00:30:56,600
올바르게 레이블을 지정하면 정확히 동일한 순서를 나타낼 수 있습니다.

603
00:30:56,600 --> 00:30:59,300
사실, 같은 것을
표현하는 방식은 기하급수적으로 많습니다

604
00:30:59,300 --> 00:31:00,050
.

605
00:31:00,050 --> 00:31:04,880
그리고 우리는 그
순서를 그대로 활용해서 정의할 겁니다.

606
00:31:04,880 --> 00:31:06,560
이건
여러분이 꼭 알아야 할 사항입니다.

607
00:31:20,364 --> 00:31:27,820
A, X, B,
Y, C라고 표시해 볼게요. 제가

608
00:31:27,820 --> 00:31:31,570
이 그림을
전에 수없이 많이 그려봤다는 걸 알 수 있을 거예요.

609
00:31:31,570 --> 00:31:35,060
이는

610
00:31:35,060 --> 00:31:37,060
대부분의
데이터 구조를 차지하는 트리 데이터 구조에서 매우 강력한 도구입니다.

611
00:31:37,060 --> 00:31:46,940
그리고 이것들은 각각 y축의 오른쪽 회전
과 x축의 왼쪽 회전이라고 불립니다.  자,

612
00:31:53,860 --> 00:31:55,730
제가 이런 트리 구조를 가지고 있다고 가정해 볼게요.

613
00:31:55,730 --> 00:31:58,150
여기서 저는
일부 서브트리를

614
00:31:58,150 --> 00:31:59,410
작은 삼각형으로 블랙박스 처리했습니다.

615
00:31:59,410 --> 00:32:02,860
만약 노드가 있고 그 노드에
왼쪽 자식이 있다면, 저는

616
00:32:02,860 --> 00:32:05,590

이 모서리를 오른쪽으로 회전시킬 수 있습니다. 즉,

617
00:32:05,590 --> 00:32:07,000
이 모서리를 잡고 이렇게

618
00:32:07,000 --> 00:32:09,058
90도 정도 회전시키는 것입니다.

619
00:32:09,058 --> 00:32:11,350
아니면 그냥
이런 식으로 다시 쓴다고 생각해도 됩니다.

620
00:32:11,350 --> 00:32:14,290
이제
부모 포인터를 추적해야 할 수도 있습니다.

621
00:32:14,290 --> 00:32:16,720
부모 포인터가 움직입니다.

622
00:32:16,720 --> 00:32:18,610
이전에는 이것이
y의 부모였습니다.

623
00:32:18,610 --> 00:32:20,980
이제 그것은 x의 부모입니다.

624
00:32:20,980 --> 00:32:23,980
그러니까 x와 y가 서로 자리를 바꾸는 겁니다.

625
00:32:23,980 --> 00:32:27,610
하지만
이 항목들을 단순히 서로 바꿀 수는 없었습니다.

626
00:32:27,610 --> 00:32:29,980
그렇게 하면
순회 순서가 바뀌기 때문입니다.

627
00:32:29,980 --> 00:32:32,440
이 그림에서
x가 y보다 앞에 오는 이유는

628
00:32:32,440 --> 00:32:36,850

순회 순서상 x가 y의 왼쪽 서브트리에 있기 때문입니다.

629
00:32:36,850 --> 00:32:40,000
그리고 여기서는 이제 y가
x의 오른쪽 서브트리에 있습니다.

630
00:32:40,000 --> 00:32:41,350
그러니까 x 다음에 오는 거죠.

631
00:32:41,350 --> 00:32:43,600
따라서 두 경우 모두
x가 y보다 먼저 옵니다.

632
00:32:43,600 --> 00:32:48,610
그리고 실제로 이 모든
그림에서 순회 순서,

633
00:32:48,610 --> 00:32:51,520
즉 x와
y뿐만 아니라 A, B, C에 대해서도

634
00:32:51,520 --> 00:32:53,170
순회 순서가
일관적입니다.

635
00:32:53,170 --> 00:33:01,975
A, X, B, Y, C와 같이 표현하는데, 여기서
삼각형이라고 쓸 때는 삼각형 안의 모든 요소들을

636
00:33:01,975 --> 00:33:03,850
재귀적으로
순회하는 순서를 의미합니다

637
00:33:03,850 --> 00:33:05,578
.

638
00:33:05,578 --> 00:33:07,870
따라서
여기에서 순회 순서 알고리즘을 적용하는 것과

639
00:33:07,870 --> 00:33:09,830
여기에서 적용하는 것을 비교해 보면
동일한 결과가 나옵니다. 이는

640
00:33:09,830 --> 00:33:12,970
이러한 연산들이
순회 순서를 유지한다는 것을 의미합니다.

641
00:33:18,770 --> 00:33:21,380
좋아요, 그럼 지금까지

642
00:33:21,380 --> 00:33:24,890


643
00:33:24,890 --> 00:33:26,330
우리가 작업한 내용에 아무런 영향을 주지 않고 트리에서 작업을 진행할 수 있겠네요.

644
00:33:26,330 --> 00:33:28,670
이는
균형을 되찾는 데 사용할 수 있는 도구입니다.  트리 구조에서 변화가

645
00:33:28,670 --> 00:33:34,190
얼마나 깊은지 주목해 보세요
.

646
00:33:34,190 --> 00:33:37,310

이 선형 트리의 문제점은

647
00:33:37,310 --> 00:33:39,200
일부
노드의 깊이가 선형적이라는 것입니다.

648
00:33:39,200 --> 00:33:40,440
우리는 그것들을 없애고 싶습니다.

649
00:33:40,440 --> 00:33:40,940
어떻게?

650
00:33:40,940 --> 00:33:44,030
음, 이 모서리들을 잡고
위쪽으로 회전시키기 시작할 수 있겠네요.

651
00:33:44,030 --> 00:33:47,850
깊이를 살펴보면,
이 그림에서는

652
00:33:47,850 --> 00:33:51,650
A와 B가 C보다 깊습니다.
그리고 이 그림에서는

653
00:33:51,650 --> 00:33:55,100
B와 C가 A보다 깊습니다.
즉, 상충 관계가 있는 거죠.

654
00:33:55,100 --> 00:33:57,470
이건 순위가 올랐어요.

655
00:33:57,470 --> 00:33:58,490
이건 아래로 내려갔어요.

656
00:33:58,490 --> 00:34:01,040
이것은
같은 깊이에 머물러 있었습니다.

657
00:34:01,040 --> 00:34:07,130
그러므로 A가 너무
깊고 C가 너무 얕다면, 이런 식으로 서로

658
00:34:07,130 --> 00:34:08,935
보완할 수 있기를 바랍니다.

659
00:34:08,935 --> 00:34:11,120
어려워 보일 수도 있지만,
사실은

660
00:34:11,120 --> 00:34:18,770

AVL 트리라고 불리는 매우 간단한 방법이 있는데, 이는 높이 균형이라는

661
00:34:18,770 --> 00:34:24,439
특정한 방식으로 균형을 유지합니다
.

662
00:34:34,730 --> 00:34:42,710
이는
노드 왼쪽의 높이에서 노드 오른쪽의 높이를 뺀 값입니다. (

663
00:34:46,130 --> 00:34:47,500
사실, 저는

664
00:34:50,080 --> 00:35:03,190

노드 왼쪽의 높이를 뺀다고 하는 게 더 정확할 것 같습니다.)

665
00:35:03,190 --> 00:35:11,050
따라서 이것을
노드의 기울기라고 합니다.

666
00:35:11,050 --> 00:35:15,040
이 값이 항상
-1, 0 또는 +1이 되도록 하고 싶습니다. 즉,

667
00:35:17,890 --> 00:35:21,930

어떤 노드가 있고, 그 노드의

668
00:35:21,930 --> 00:35:25,372
왼쪽
서브트리와 오른쪽 서브트리의 높이를

669
00:35:25,372 --> 00:35:26,830
측정했을 때(이는

670
00:35:26,830 --> 00:35:30,670
아래쪽으로의 거리, 즉 리프 노드까지의
최대 거리입니다),

671
00:35:30,670 --> 00:35:32,138


672
00:35:32,138 --> 00:35:34,180


673
00:35:34,180 --> 00:35:39,012
이 두 높이가
1 이내의 차이를 가지도록 하고 싶습니다.

674
00:35:39,012 --> 00:35:39,970
이상적으로는 둘의 비율이 같아야 한다.

675
00:35:39,970 --> 00:35:41,740
그게 바로 완벽한 사례겠죠.

676
00:35:41,740 --> 00:35:44,140
하지만 두 값의 차이를 1로 봅시다.

677
00:35:44,140 --> 00:35:48,220
그러면 이 노드는 k
이고 이 노드는 k+1일 수 있습니다.

678
00:35:48,220 --> 00:35:51,670
또는 이 노드는 k
이고 이 노드는 k-1일 수도 있습니다.

679
00:35:51,670 --> 00:35:53,730
이 그림에서
이 노드의 높이는 얼마일까요?

680
00:35:53,730 --> 00:35:56,812
좋은 습관입니다.

681
00:35:56,812 --> 00:35:59,560
k+2, 좋습니다.

682
00:35:59,560 --> 00:36:01,780

이 노드에서 리프 노드까지 가장 긴 경로는 무엇입니까?

683
00:36:01,780 --> 00:36:03,460
음,
이 하위 트리를 통해 진행될 수도 있겠네요.

684
00:36:03,460 --> 00:36:06,160
그리고 그 길이는 k에
1을 더한 값이 될 것입니다. 왜냐하면

685
00:36:06,160 --> 00:36:07,570
이 모서리의 길이는 k에 1을 더한 값이기 때문입니다.

686
00:36:07,570 --> 00:36:10,450
아니면 여기를 통과할 수도 있는데,
그건 k + 1 + 1이 됩니다.

687
00:36:10,450 --> 00:36:12,380
그러니까 가장 큰 방향은
오른쪽으로 가는 것입니다.

688
00:36:12,380 --> 00:36:14,860
그러니까,
이 서브트리들의 높이를 알려드리면

689
00:36:14,860 --> 00:36:16,443

이 노드의 높이를 계산할 수 있습니다.

690
00:36:16,443 --> 00:36:19,490

잠시 후에 그걸 많이 사용하게 될 거예요.

691
00:36:19,490 --> 00:36:21,490
첫 번째 주장은
만약 내가

692
00:36:21,490 --> 00:36:26,620
높이
균형을 유지할 수 있다면,

693
00:36:26,620 --> 00:36:28,640
h가 log n과 같다는 것을 보장할 수 있다는 것입니다.

694
00:36:28,640 --> 00:36:32,180
즉, 높이
균형은 균형을 의미합니다.

695
00:36:32,180 --> 00:36:36,260
그럼
먼저 그 사실을 빠르게 증명해 보죠.

696
00:36:36,260 --> 00:36:40,505
그리고 나서 흥미로운 점은
우리가 어떻게 실제로

697
00:36:44,690 --> 00:36:47,825

균형 속성을 증명하거나 유지할 수 있느냐는 것입니다.

698
00:36:47,825 --> 00:36:49,450
우리는
회전을 이용해서 그렇게 할 겁니다.

699
00:36:49,450 --> 00:36:51,490
하지만 어떻게 할 것인가가 큰 문제입니다.

700
00:37:01,720 --> 00:37:07,420
그렇다면 높이
균형이 왜 균형을 의미하는 걸까요?

701
00:37:16,550 --> 00:37:21,530
즉,
높이가 균형을 이룬 모든 나무는

702
00:37:21,530 --> 00:37:24,810
높이가 로그 함수 형태를 띤다는 뜻입니다.

703
00:37:24,810 --> 00:37:26,390
그래서 제가 생각해보고 싶은 건,

704
00:37:26,390 --> 00:37:30,890

높이 균형이 가장 안 맞는 나무입니다.

705
00:37:30,890 --> 00:37:36,070
가장 균형이 맞지 않는 시스템은
모든 노드에 불일치가 발생할 것입니다.

706
00:37:36,070 --> 00:37:39,170
왼쪽
서브트리가

707
00:37:39,170 --> 00:37:42,800
오른쪽 서브트리보다 깊이가 1만큼 얕다고 가정하고, 이러한 관계가
모든 하위 트리에 걸쳐 재귀적으로 적용된다고 가정해 봅시다.

708
00:37:42,800 --> 00:37:45,650
그래서 모든 노드에는
여기에 간격이 있는데,

709
00:37:49,522 --> 00:37:51,480
뭐라고 부르죠?

710
00:37:51,480 --> 00:37:56,520
1의 왜곡이라고 할까요? 제가

711
00:37:56,520 --> 00:37:58,090

표기법을 하나 도입하겠습니다.

712
00:37:58,090 --> 00:38:00,360
저는
이 항목이

713
00:38:00,360 --> 00:38:03,165
왼쪽 하위 트리보다 더 높다는 반대 의견을 오른쪽 화살표로 표시하겠습니다.

714
00:38:06,470 --> 00:38:08,270
쉽게 말해서,

715
00:38:08,270 --> 00:38:10,120
이것은
우리가 직면한 최악의 시나리오입니다.

716
00:38:10,120 --> 00:38:14,260
이는
최대 깊이에 필요한 최소 노드 수가 될 것입니다.

717
00:38:14,260 --> 00:38:18,370

이 트리에 노드가 몇 개 있는지 세어 봅시다.

718
00:38:18,370 --> 00:38:21,310
저는 그것을 점화식으로 표현하겠습니다. 점화식은

719
00:38:21,310 --> 00:38:25,660

높이가 h인 트리의 노드 개수입니다.  이 그림에서처럼

720
00:38:25,660 --> 00:38:32,680
전체 트리의 높이가 h라고 할 때,

721
00:38:32,680 --> 00:38:35,750

모든 숫자에서 2를 빼면

722
00:38:35,750 --> 00:38:40,270
이 트리의
높이는 h에서 2를 뺀 값이 되고,

723
00:38:40,270 --> 00:38:44,020
이 트리의 높이는
h에서 1을 뺀 값이 됩니다.

724
00:38:44,020 --> 00:38:45,833
그렇다면 이 트리에는 노드가 몇 개 있을까요?

725
00:38:45,833 --> 00:38:47,750
자, 이건 제가 다시 쓰려고 하는 글입니다
.

726
00:38:47,750 --> 00:38:52,060
그래서 이것은 N<sub>h</sub>에서 2를 뺀 값이 됩니다.

727
00:38:52,060 --> 00:38:55,360
이것은 N<sub>h</sub>에서 1을 뺀 값이 됩니다.

728
00:38:55,360 --> 00:38:57,910
그런 다음
이 그림에 노드가 몇 개 있는지 세어 봅니다.

729
00:38:57,910 --> 00:39:06,100
이는 Nh 마이너스 1 + Nh
마이너스 2 + 1, 즉 이 노드입니다.

730
00:39:06,100 --> 00:39:09,520
이제 여러분은 Nh가 왜 재발하는지 궁금해하실 수도 있습니다.

731
00:39:09,520 --> 00:39:15,760
하지만 이는
최악의 경우의

732
00:39:15,760 --> 00:39:18,460

전체 높이가 h일 때의 노드 수입니다.

733
00:39:18,460 --> 00:39:20,350
그러니까 높이가 h인

734
00:39:20,350 --> 00:39:22,090


735
00:39:22,090 --> 00:39:25,780
AVL 트리(

736
00:39:25,780 --> 00:39:38,610

높이 균형 트리)에서 최소한 몇 개의 노드가 있어야 하는지를 묻는 것으로도 생각할 수 있습니다.

737
00:39:38,610 --> 00:39:40,920
좋아요, 이제
이 점화식을 풀기만 하면 돼요.

738
00:39:40,920 --> 00:39:42,450
이 상황이 어딘가
익숙하게 느껴지시나요?  마치

739
00:39:48,050 --> 00:39:49,550
피보나치 수열 같아요.

740
00:39:49,550 --> 00:39:52,130
플러스
1을 빼면 피보나치가 됩니다.

741
00:39:52,130 --> 00:39:54,320
그리고 만약
피보나치 수열이

742
00:39:54,320 --> 00:39:56,690

n에 대해 황금비처럼 비례하여 증가한다는 것을 알고 있다면,

743
00:39:56,690 --> 00:39:58,490

이것이 지수 함수적 증가라는 것을 알 수 있고,

744
00:39:58,490 --> 00:39:59,540
이것이 바로 우리가 원하는 것입니다.

745
00:39:59,540 --> 00:40:02,690
만약 Nh가
h에 대해 지수 함수적이라면,

746
00:40:02,690 --> 00:40:04,670


747
00:40:04,670 --> 00:40:06,618
로그 함수는
지수 함수의 역함수이므로 h는 N에 대해 로그 함수적이라는 뜻입니다.

748
00:40:06,618 --> 00:40:08,660
하지만 여러분은
피보나치 수열에 대해 잘 모를 수도 있습니다.

749
00:40:08,660 --> 00:40:14,300
따라서 우리는 다음과 같이
이것이 지수적임을 쉽게 보여줄 수 있습니다

750
00:40:14,300 --> 00:40:15,960
.

751
00:40:15,960 --> 00:40:18,260
저는 그것이
적어도 지수 함수라는 것을 증명하고 싶습니다.

752
00:40:18,260 --> 00:40:22,830
왜냐하면 그렇게 되면
h가 기껏해야 로그 함수라는 것을 알 수 있기 때문입니다.

753
00:40:22,830 --> 00:40:24,183
그러므로 우리는 하한값이 필요합니다.

754
00:40:24,183 --> 00:40:26,600
그래서
비교하기 어려운 두 항, 즉

755
00:40:26,600 --> 00:40:28,850
Nh 마이너스 1과 Nh 마이너스 2가 생겼습니다.

756
00:40:28,850 --> 00:40:30,212
좀 복잡하죠.

757
00:40:30,212 --> 00:40:31,670
하지만 만약 우리가 좀 허술해도 괜찮다면(

758
00:40:31,670 --> 00:40:33,460
그리고
우리가 너무 허술하지 않은지 한번 확인해 보겠습니다),

759
00:40:33,460 --> 00:40:35,570
그래도
지수적인 결과가 나온다면, 그냥 이렇게

760
00:40:35,570 --> 00:40:40,115

두 값을 같게 만들어 봅시다.

761
00:40:44,150 --> 00:40:48,140
그러므로 이것은 사실 참인 명제이며
, 엄밀히 말하면 보다 큽니다.

762
00:40:48,140 --> 00:40:48,680
왜?  +1을

763
00:40:48,680 --> 00:40:50,420
뺐기 때문입니다.

764
00:40:50,420 --> 00:40:52,310
그러면 값이 더 작아질 뿐입니다
.

765
00:40:52,310 --> 00:40:56,600
그리고 저는 Nh 마이너스
1을 Nh 마이너스 2로 바꿨습니다.

766
00:40:56,600 --> 00:40:58,310
여기서 저는

767
00:40:58,310 --> 00:41:03,170
귀납적으로 자명한 사실, 즉

768
00:41:03,170 --> 00:41:05,270
이 트리와 저 트리를 비교했을 때 이 트리가 저 트리

769
00:41:05,270 --> 00:41:07,850

보다 노드 수가 더 많다는 사실을 암묵적으로 사용하고 있습니다.

770
00:41:07,850 --> 00:41:10,130
만약 제 키가 더 크다면,
이 구조물은

771
00:41:10,130 --> 00:41:13,250

적어도 지금만큼 큰 나무를 만들어낼 겁니다.

772
00:41:13,250 --> 00:41:15,710

굳이 더 클 필요도 없어요.

773
00:41:15,710 --> 00:41:18,140
그러므로 당연히 Nh - 1은 Nh - 2
보다 크거나 같습니다.

774
00:41:20,060 --> 00:41:24,230
이것은 2 곱하기 Nh - 2입니다.

775
00:41:24,230 --> 00:41:25,710
이것은 간단한 점화식입니다.

776
00:41:25,710 --> 00:41:27,920
이건 그냥 2의 거듭제곱이에요.

777
00:41:27,920 --> 00:41:31,460
계속 2를 곱하고
h에서 2를 빼는 거죠.

778
00:41:31,460 --> 00:41:35,150
그래서 이 식은
2의 h/2 제곱으로 풀리는데,

779
00:41:35,150 --> 00:41:37,880
아마 내림이나 다른 연산이 필요할 수도 있겠네요.

780
00:41:37,880 --> 00:41:43,490
하지만 저는 여기서 기본 사례, 즉
N<sub>0</sub>이 1인 경우를 사용하고 있습니다.

781
00:41:46,187 --> 00:41:47,270
그렇다면 상한값일 수도 있겠네요.

782
00:41:47,270 --> 00:41:49,380
하지만 중요한 점은
이것이 기하급수적으로 증가한다는 것입니다.

783
00:41:49,380 --> 00:41:53,810
따라서 이는 높이가
항상 최대

784
00:41:53,810 --> 00:41:55,730
log n의 2배라는 것을 의미합니다.

785
00:41:55,730 --> 00:41:57,810
이 2는 이 2에 해당합니다.

786
00:41:57,810 --> 00:41:59,750

이 공식을 뒤집으면

787
00:41:59,750 --> 00:42:04,500
노드 수는
적어도 2의

788
00:42:04,500 --> 00:42:05,600
h/2가 됩니다.

789
00:42:05,600 --> 00:42:07,710
따라서 h는 최대 2 log n입니다.

790
00:42:07,710 --> 00:42:08,913
그러니까 log n이 아닙니다.

791
00:42:08,913 --> 00:42:09,830
그러면 완벽할 거예요.

792
00:42:09,830 --> 00:42:12,020
하지만 이는
log n의 2배 이내의 오차 범위 내에 있습니다.

793
00:42:12,020 --> 00:42:15,510
그래서 AVL 트리는
항상 상당히 균형 잡혀 있습니다.

794
00:42:15,510 --> 00:42:17,090
레벨 수는

795
00:42:17,090 --> 00:42:19,710
노드 n개를 저장하는 데 필요한 레벨 수의 최대 두 배입니다.

796
00:42:19,710 --> 00:42:20,210
엄청난.  이제

797
00:42:23,980 --> 00:42:27,730
우리에게 남은 건

798
00:42:27,730 --> 00:42:28,780
영역 마법이 아니라 주된 마법입니다.

799
00:42:28,780 --> 00:42:31,060
그건 달라요.  자, 그럼

800
00:42:31,060 --> 00:42:34,180

서브트리 증강을 사용해 보겠습니다.

801
00:42:37,550 --> 00:42:38,150
그거 간직해 둬.

802
00:42:45,510 --> 00:42:48,330
남은 큰
과제는 회전을 사용하여

803
00:42:48,330 --> 00:42:51,240
이러한 높은 균형 속성을 어떻게 유지할 것인가 하는 점입니다.  필요한

804
00:42:51,240 --> 00:42:54,190
재료는 모두
준비되어 있습니다.

805
00:42:54,190 --> 00:42:56,670
우리는 서브트리 증강 기능을 가지고 있습니다.  그렇게 하면 제가

806
00:42:56,670 --> 00:42:57,810
무엇을 할 수 있나요?

807
00:43:00,820 --> 00:43:02,710
AVL 트리와 관련이 있습니다.

808
00:43:02,710 --> 00:43:06,880
음, 높이를 저장할 수 있게 해 주네요.

809
00:43:06,880 --> 00:43:11,230

노드의 높이를 계산할 수 있어야 합니다.

810
00:43:11,230 --> 00:43:13,090
일반적으로 그 작업은
선형적인 시간이 걸립니다.

811
00:43:13,090 --> 00:43:15,173
왜냐하면

812
00:43:15,173 --> 00:43:16,660

하위 트리 내의 모든 노드, 즉 모든 하위 경로를 살펴봐야 하기 때문입니다.

813
00:43:16,660 --> 00:43:20,520
하지만 높이는
서브트리의 속성이므로

814
00:43:20,520 --> 00:43:27,470
, 맞습니다. 높이입니다.

815
00:43:27,470 --> 00:43:28,920
왜?

816
00:43:28,920 --> 00:43:33,670
왜냐하면—
여기에 적어두겠습니다

817
00:43:33,670 --> 00:43:49,140
—node.height는
node.left.height

818
00:43:49,140 --> 00:43:57,150
와 node.right.height 중 최대값에 1을 더한 값
과 같기 때문입니다.

819
00:43:57,150 --> 00:44:00,390
이걸 상자에 넣어둘게요.

820
00:44:00,390 --> 00:44:05,550
이 방정식, 아니면 아마도
할당 연산일 텐데,

821
00:44:05,550 --> 00:44:08,267
이건 1이에요.

822
00:44:08,267 --> 00:44:10,100
우리가 계속해서 반복해 온 바로 그 작업입니다
.

823
00:44:10,100 --> 00:44:11,660
제가
이 노드의 높이가 얼마냐고 물었을 때,

824
00:44:11,660 --> 00:44:12,890
당신은 바로 알아차렸죠
, 그렇죠?

825
00:44:12,890 --> 00:44:14,495

왼쪽 서브트리의 높이와

826
00:44:14,495 --> 00:44:15,995

오른쪽 서브트리의 높이를 최대화한 다음, 이러한 간선을

827
00:44:15,995 --> 00:44:19,250
고려하여 1을 더했습니다
.

828
00:44:19,250 --> 00:44:20,930
이것이
일반적인 업데이트 규칙입니다.

829
00:44:20,930 --> 00:44:23,540
이는 해당 서브트리
속성 패턴과 일치합니다.

830
00:44:23,540 --> 00:44:25,280

왼쪽과 오른쪽 속성을 알고 있다면

831
00:44:25,280 --> 00:44:27,800
노드에 대해 이를 계산할 수 있습니다.

832
00:44:27,800 --> 00:44:29,570
그리고 이 작업을
하려면 지속적인 시간이 필요합니다.

833
00:44:29,570 --> 00:44:30,900
그래서 이는 하위 트리 속성입니다.

834
00:44:30,900 --> 00:44:33,388
그래서 제가
하는 모든 작업을 통해

835
00:44:33,388 --> 00:44:34,430
각 노드의 높이를 일정하게 유지할 수 있습니다.

836
00:44:34,430 --> 00:44:37,800
아, 그리고 회전을 할 때마다

837
00:44:37,800 --> 00:44:41,180

하위 트리 속성도 업데이트해야 해요.

838
00:44:41,180 --> 00:44:45,720
이 모서리를 회전시켜도 A
, B,

839
00:44:45,720 --> 00:44:46,710
C는 변하지 않습니다.  그건

840
00:44:46,710 --> 00:44:48,080
좋은 일이죠.

841
00:44:48,080 --> 00:44:49,685
하지만 x의 서브트리가 변경됩니다.

842
00:44:49,685 --> 00:44:50,840
이제 y가 있습니다.

843
00:44:50,840 --> 00:44:52,320
전에는 그렇지 않았어요.

844
00:44:52,320 --> 00:44:56,620
그래서

845
00:44:56,620 --> 00:44:58,970
y 부분의 증강현실도 업데이트해야 할 것 같습니다.

846
00:44:58,970 --> 00:45:03,550
그리고 우리는
x의 증강을 업데이트해야 할 것입니다.

847
00:45:03,550 --> 00:45:04,940
그리고

848
00:45:04,940 --> 00:45:10,280

결국에는 x의 모든 조상들에 대한 증강을 업데이트해야 할 것입니다.

849
00:45:10,280 --> 00:45:12,660
따라서 회전은
국소적으로

850
00:45:12,660 --> 00:45:13,910
일정한 개수의 포인터를 변경하는 것입니다.

851
00:45:13,910 --> 00:45:18,050
그래서 저는 보통 회전 운동이
일정한 시간이 걸린다고 생각합니다.

852
00:45:18,050 --> 00:45:20,835
하지만 결국 우리는 그렇게 해야 할 것입니다.

853
00:45:20,835 --> 00:45:22,085
이것은 지역적으로 일정한 시간입니다.

854
00:45:25,250 --> 00:45:35,720
하지만

855
00:45:35,720 --> 00:45:39,162
모든
증강 기능을 최신 상태로 유지하려면 h 조상 정보를 업데이트해야 합니다.

856
00:45:39,162 --> 00:45:40,370
그건 나중에 걱정하자.  좋아요

857
00:45:43,380 --> 00:45:44,250
, 아주 좋습니다.

858
00:45:44,250 --> 00:45:45,917
이제
모든 노드의 높이를 알게 되었습니다.

859
00:45:45,917 --> 00:45:50,860

모든 노드의 왜곡도를 계산할 수 있네요, 멋지다.

860
00:45:50,860 --> 00:45:52,570
저희는 교대 근무 제도를 운영하고 있습니다.

861
00:45:52,570 --> 00:45:58,320
그리고 우리는 이러한
높이 균형 속성을 유지하고 싶습니다.

862
00:45:58,320 --> 00:46:02,130
왼쪽 노드의 높이, 즉
모든 노드의 좌우 높이는

863
00:46:02,130 --> 00:46:03,630
플러스 마이너스 1 또는 0입니다.

864
00:46:06,210 --> 00:46:13,740
좋습니다. 제가 여기
어딘가에서 말했듯이, 트리를 변경하는

865
00:46:13,740 --> 00:46:15,365
유일한 요소는

866
00:46:15,365 --> 00:46:17,630

새 노드를 삽입하거나 삭제할 때입니다.

867
00:46:17,630 --> 00:46:20,210

지금까지 우리가 이를 구현한 방식은

868
00:46:20,210 --> 00:46:21,950
리프 노드를 추가하거나 제거하는 것입니다.

869
00:46:21,950 --> 00:46:24,660
그러므로 우리는 여전히 잎을
추가하거나 제거하는 것에 대해 생각해야 합니다

870
00:46:24,660 --> 00:46:25,160
.

871
00:46:25,160 --> 00:46:27,410
문제는
새 잎을 추가하면

872
00:46:27,410 --> 00:46:31,320
나무가
이전보다 더 높아질 수 있다는 것입니다.

873
00:46:31,320 --> 00:46:35,270
따라서 여기 있는 일부 노드의
높이 균형이 더 이상 맞지 않을 수 있습니다.

874
00:46:35,270 --> 00:46:37,220
하지만 높이는
하위 트리의 속성이므로,

875
00:46:37,220 --> 00:46:39,590
우리가
확인해야 할 노드는 이 상위

876
00:46:39,590 --> 00:46:42,330
경로에 있는 노드뿐입니다.

877
00:46:42,330 --> 00:46:44,900
그리고 그 개수는 log n개뿐입니다.
왜냐하면 이제 높이는 log n이기 때문입니다.  우리가 이 부동산을 소유하고 있는 한,

878
00:46:44,900 --> 00:46:47,660
그것이 바로 우리가 방금 증명한 사실입니다
.

879
00:46:47,660 --> 00:46:50,450
지금으로서는 아마도

880
00:46:50,450 --> 00:46:51,620
이 몇몇 노드에 대해서는 해당 기능을 제공하지 않습니다.

881
00:46:51,620 --> 00:46:53,570
하지만 그건 훨씬 전의 일이었어요.  지금은 노드를 하나 추가했기 때문에

882
00:46:53,570 --> 00:46:54,470
최대 log n -

883
00:46:54,470 --> 00:46:58,250
2 log n + 1입니다
.

884
00:46:58,250 --> 00:47:00,920
제가 하려는 것은 아래에서 위로 순서대로
모든 상위 노드를 확인하고

885
00:47:00,920 --> 00:47:04,310

,

886
00:47:04,310 --> 00:47:06,550
균형이 맞지 않는 노드를 찾는 것입니다.

887
00:47:06,550 --> 00:47:15,710
그럼 불균형 정도가 가장 낮은
노드를 살펴보겠습니다.

888
00:47:21,540 --> 00:47:24,860
저는 그걸 x라고 부를 거예요.

889
00:47:24,860 --> 00:47:28,370
이제 우리는
리프 노드 하나를 삽입하거나 삭제했기 때문에 높이

890
00:47:28,370 --> 00:47:32,090

만 변경되어 불균형이 1만큼만 발생합니다. 즉,

891
00:47:33,590 --> 00:47:36,710
하나의 높이가 1만큼 증가하거나
감소한 것입니다.

892
00:47:36,710 --> 00:47:40,730
이전에는 모든 노드의 불균형 값이
플러스 마이너스 1이거나 0이었습니다.

893
00:47:40,730 --> 00:47:44,223
따라서 이제는 불균형 값이
플러스 마이너스 2가 되는 것이 최악의 경우입니다.

894
00:47:44,223 --> 00:47:46,640

모든 노드의 불균형 값이 여전히 이 범위 내에 있다면

895
00:47:46,640 --> 00:47:47,510
우리는 만족합니다.

896
00:47:47,510 --> 00:47:51,080
하지만 이 범위를 벗어나면 오차는
1에 불과합니다.

897
00:47:51,080 --> 00:47:58,550
따라서 비대칭성은
n+2 또는 -2가 됩니다.

898
00:47:58,550 --> 00:48:01,910

대칭성을 고려하여 비대칭성이 2라고 가정해 보겠습니다.

899
00:48:01,910 --> 00:48:06,098
제 그림은 이렇습니다.

900
00:48:06,098 --> 00:48:10,010

오른쪽 방향 화살표 두 개를 그려서

901
00:48:10,010 --> 00:48:18,590
이 서브트리가
저 서브트리보다 2단계 더 높다는 것을 나타내겠습니다.

902
00:48:18,590 --> 00:48:21,320
네, 그건 문제가 있고
우리는 그걸 고치고 싶어요.  가장

903
00:48:21,320 --> 00:48:25,265
확실한 방법은
이 모서리를 회전시키는 것입니다.  그렇게 하면

904
00:48:29,030 --> 00:48:31,590
이건 너무 높고
이건 너무 낮아지니까요.

905
00:48:31,590 --> 00:48:33,410
그러니까 회전시키면 이쪽은
1만큼 내려가고

906
00:48:33,410 --> 00:48:34,550
저쪽은 1만큼 올라가야 합니다.

907
00:48:34,550 --> 00:48:38,070
그리고 대부분의 경우 이렇게 하면 제대로 작동합니다.  첫 번째

908
00:48:38,070 --> 00:48:45,200
경우는 y의 왜곡도입니다.

909
00:48:45,200 --> 00:48:45,860
y는 무엇입니까?

910
00:48:45,860 --> 00:48:50,090
나는 y가
x의 올바른 자녀가 되기를 바란다.  양의

911
00:48:50,090 --> 00:48:54,260
왜곡이 있기 때문에 우리는
올바른 아이가 있다는 것을 알고 있습니다.

912
00:48:54,260 --> 00:48:57,120
이제, 이것이
가장 나쁜 노드였기 때문에,

913
00:48:57,120 --> 00:48:58,770
우리는 y가 실제로 좋은 노드라는 것을 알 수 있습니다.

914
00:48:58,770 --> 00:49:02,300
오른쪽으로 치우쳐 있거나,
두 하위 나무의

915
00:49:02,300 --> 00:49:04,820
높이가 같거나,
아니면 왼쪽으로 치우쳐 있습니다.

916
00:49:04,820 --> 00:49:13,940

y축의 왜도가

917
00:49:13,940 --> 00:49:22,720
1 또는 0인 경우는 쉬운 경우이며, 이 경우를
그림으로 보여드리겠습니다.

918
00:49:29,980 --> 00:49:34,630
그러니까 오른쪽 화살표 두 개, 아니,
오른쪽 화살표 하나라고 해볼게요. 그림을 일관성 있게 보이도록

919
00:49:40,430 --> 00:49:44,020

여기에 몇 가지 레이블을 추가할게요.

920
00:49:44,020 --> 00:49:48,562


921
00:49:48,562 --> 00:49:51,210
k+1, k+2.

922
00:49:51,210 --> 00:49:52,770
나는 절정에 달했다.

923
00:49:52,770 --> 00:49:56,010
이 예시에서는
C가 B보다 키가 크고,

924
00:49:56,010 --> 00:49:58,947
A와 B는
키가 같습니다.

925
00:49:58,947 --> 00:50:00,780
그리고
여기 높이를 계산해 보면,

926
00:50:00,780 --> 00:50:03,480
실제로 이 건물은
오른쪽으로 기울어져 있습니다.

927
00:50:03,480 --> 00:50:05,220
이 정당은 극우
성향이 매우 강합니다.

928
00:50:05,220 --> 00:50:06,850
왜냐하면 이쪽은
높이가 k+1이고,

929
00:50:06,850 --> 00:50:08,100
저쪽은 높이가 k-1이기 때문입니다.

930
00:50:08,100 --> 00:50:08,890
좋지 않네요.

931
00:50:08,890 --> 00:50:11,370
하지만
x축을 기준으로 올바른 회전을 하면

932
00:50:11,370 --> 00:50:14,100
우리가 원하는 결과를 정확히 얻을 수 있습니다.

933
00:50:18,010 --> 00:50:20,940
그래서
A, B, C에 레이블을 복사해서

934
00:50:20,940 --> 00:50:23,760
k-1,
k-1, k라고 표시한

935
00:50:23,760 --> 00:50:24,630
다음 다시 계산해 보겠습니다.

936
00:50:24,630 --> 00:50:26,400
즉, 이
노드의 높이는 k이고,

937
00:50:26,400 --> 00:50:29,040
저 노드의 높이는 k+1입니다.

938
00:50:29,040 --> 00:50:31,653
그리고
제가 이 그림에서 강조 표시한

939
00:50:31,653 --> 00:50:32,820
A, B, C 노드는 모두 변하지 않았습니다.

940
00:50:32,820 --> 00:50:34,195

이전에는 높이 균형이 잘 맞았습니다.  지금도 그렇습니다

941
00:50:34,195 --> 00:50:35,400
.

942
00:50:35,400 --> 00:50:36,720
하지만 지금은 x와 y의 높이가

943
00:50:36,720 --> 00:50:39,030

예전과 같지 않아요. 전에는 x는 높이 균형이 맞지 않았지만, y는 맞았죠.

944
00:50:39,030 --> 00:50:42,420
이제 x와 y는
높이 균형을 이룹니다.

945
00:50:42,420 --> 00:50:44,160
그게 첫 번째 사례입니다.

946
00:50:44,160 --> 00:50:49,390
두 번째 경우,
y의 왜곡이 평평하다는

947
00:50:49,390 --> 00:50:54,870
것은 이것이
k이고, 이것도 k이고,

948
00:50:54,870 --> 00:50:58,570
이것은 k+1이고,
이것은 k+2라는 것을 의미합니다.

949
00:50:58,570 --> 00:51:00,743
하지만 여전히 모든
노드의

950
00:51:00,743 --> 00:51:01,410
높이가 균형을 이루고 있습니다.

951
00:51:01,410 --> 00:51:03,090
여전히 플러스 마이너스 1 범위 내에 있습니다.

952
00:51:03,090 --> 00:51:04,440
따라서 이러한 경우는 쉽습니다.

953
00:51:04,440 --> 00:51:07,240
유감스럽게도,
어려운 사례가 하나 있습니다

954
00:51:07,240 --> 00:51:08,280
. 바로 세 번째 사례입니다.

955
00:51:08,280 --> 00:51:11,280
하지만 정답은 하나뿐이고,
그다지 어렵지도 않습니다.

956
00:51:16,320 --> 00:51:21,780
즉,
y의 왜도가 -1일 때입니다.

957
00:51:21,780 --> 00:51:24,750
이 경우
y의 왼쪽 자식을 살펴봐야 합니다.

958
00:51:28,590 --> 00:51:31,830
알파벳 순서대로 정렬하기 위해
이것을 z로 이름을 바꾸겠습니다.

959
00:51:34,470 --> 00:51:36,780
이것도 마찬가지로
오른쪽 화살표 두 개입니다.

960
00:51:36,780 --> 00:51:39,540
이것은 이제 왼쪽 화살표입니다.

961
00:51:39,540 --> 00:51:41,910
그리고 이것이 바로 알파벳 y입니다.

962
00:51:41,910 --> 00:51:49,950
그래서 우리는 그들로부터 A, B, C, D와 같은
잠재적인 하위 트리를 얻을 수 있습니다

963
00:51:49,950 --> 00:51:50,550
.

964
00:51:50,550 --> 00:51:54,310
그리고 저는
이것들의 높이를 표시할 거예요.

965
00:51:54,310 --> 00:51:59,010
이것들은 각각 k
마이너스 1 또는 k 마이너스 2입니다.

966
00:51:59,010 --> 00:52:00,420
이것은 k 마이너스 1입니다.

967
00:52:00,420 --> 00:52:01,770
이제 내부를 계산해 보세요.

968
00:52:01,770 --> 00:52:06,690
그래서 이것이
왼쪽으로 기울어지도록 하려면 높이가 k가 되어야 합니다.

969
00:52:06,690 --> 00:52:11,520
이것은 k+1이고,
이것은 k+2입니다.

970
00:52:11,520 --> 00:52:13,680
그런데 문제는 이것이
이것보다 2만큼 더 크다는 것입니다.

971
00:52:13,680 --> 00:52:17,370
z축의 높이는 A축의 높이보다 2만큼 높습니다.

972
00:52:17,370 --> 00:52:18,990
이 경우,
이렇게 회전시키면

973
00:52:18,990 --> 00:52:20,910
오히려 상황이 더 악화됩니다.

974
00:52:20,910 --> 00:52:26,610
제가 간단히 말씀드리겠습니다. 가장
옳은 일은 바로 이것입니다.

975
00:52:26,610 --> 00:52:28,650
이것 하나만은 꼭
암기해야 합니다.

976
00:52:41,700 --> 00:52:43,860
그럼 제가 결과를 그려보겠습니다.  이렇게

977
00:52:43,860 --> 00:52:47,300

나무 구조를 다시 그리는 것으로 생각해도 됩니다.

978
00:52:47,300 --> 00:52:49,940
하지만
분석적인 관점에서 보면

979
00:52:49,940 --> 00:52:51,680
이를
두 번의 회전으로 생각하는 것이 더 쉽습니다.

980
00:52:51,680 --> 00:52:52,940
그럼 줄이면 되죠.

981
00:52:52,940 --> 00:52:54,800

회전이 어떻게 작동하는지 알고 있다면,

982
00:52:54,800 --> 00:52:56,460

이 기능이 제대로 작동한다는 것을 알 수 있습니다. 여기서

983
00:52:56,460 --> 00:52:59,060
"작동한다"는 것은
이동 순서를 유지하고

984
00:52:59,060 --> 00:53:01,160

모든 증강 기능을 유지할 수 있다는 의미입니다.  자

985
00:53:01,160 --> 00:53:04,340
, 이제 이
높이 레이블들을 복사해 넣으면

986
00:53:04,340 --> 00:53:05,390
k 마이너스 1이 됩니다.

987
00:53:05,390 --> 00:53:08,600
이 두 사람에 대해서는
k 마이너스 1 또는 k 마이너스 2가 됩니다.

988
00:53:08,600 --> 00:53:11,100
가장 큰 사람이 k 마이너스 1입니다.

989
00:53:11,100 --> 00:53:13,190
이것이 k 마이너스 1입니다.

990
00:53:13,190 --> 00:53:15,410
따라서 이것이 k가 됩니다.

991
00:53:15,410 --> 00:53:17,450
이것은 k가 될 것입니다.

992
00:53:17,450 --> 00:53:19,070
이것은 k+1이 될 것입니다.

993
00:53:19,070 --> 00:53:22,490
그리고 놀랍게도, 이 노드에 대해 세 가지 경우 모두에서
높이가 균형 잡힌 멋진 트리가 생성됩니다

994
00:53:22,490 --> 00:53:25,760

.

995
00:53:25,760 --> 00:53:27,020
자, 여기가 가장 낮은 노드였습니다.

996
00:53:27,020 --> 00:53:28,880

이 부분을 업데이트하면

997
00:53:28,880 --> 00:53:32,090

루트의 높이가 변경될 수 있습니다.

998
00:53:32,090 --> 00:53:35,750
이전에는 k+
2였지만, 이제는 k+1입니다.

999
00:53:35,750 --> 00:53:39,483
또는
이 경우처럼 그대로 유지하는 경우도 있습니다.  자

1000
00:53:39,483 --> 00:53:41,150
, 이제
부모를 확인해야 합니다.

1001
00:53:41,150 --> 00:53:42,740
어쩌면 부모가
균형을 잃었을지도 몰라요.

1002
00:53:42,740 --> 00:53:44,720
그리고 우리는 계속해서
노드를 올라가면서, 그 과정에서

1003
00:53:44,720 --> 00:53:47,660
모든
증강 기능을 유지 관리합니다.

1004
00:53:47,660 --> 00:53:49,790
그런 다음, 필요에 따라
높이와 서브트리 크기

1005
00:53:49,790 --> 00:53:51,980
또는
기타 확장 정보를 추적합니다.

1006
00:53:51,980 --> 00:53:54,425
그리고 h차 연산을 거치면

1007
00:53:54,425 --> 00:53:56,300
높이
균형 속성이 복원되는데, 이는

1008
00:53:56,300 --> 00:53:59,280

h가 전체적으로 log n차와 같다는 것을 의미합니다.

1009
00:53:59,280 --> 00:54:03,250
그래서 이제 우리의 모든 작업은
마법처럼 순서대로 로그 n이 됩니다.

