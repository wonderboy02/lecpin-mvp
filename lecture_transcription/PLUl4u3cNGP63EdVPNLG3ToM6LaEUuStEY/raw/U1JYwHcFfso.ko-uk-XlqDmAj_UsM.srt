1
00:00:00,000 --> 00:00:04,472
[셰트]
[소리] [딸깍]

2
00:00:12,740 --> 00:00:15,919
에릭 데마인: 네, 환영합니다.
다시 데이터 구조의 세계로 돌아가 보겠습니다.

3
00:00:15,919 --> 00:00:21,140
오늘 우리는 계속해서 작업을 진행하고 마무리합니다.
이진 트리에 대한 저희 코너입니다.

4
00:00:21,140 --> 00:00:23,030
자, 이것이 두 번째 부분입니다.

5
00:00:23,030 --> 00:00:26,179
첫 번째 부분을 놓치셨다면,
돌아가서 첫 번째 부분을 보세요.

6
00:00:26,179 --> 00:00:30,649
지난번에 우리는 ~에 대해 이야기했습니다.
이진 트리의 일반적인 개념.

7
00:00:30,649 --> 00:00:36,979
각 노드에 저장됨
왼쪽 요소뿐만 아니라 오른쪽 요소도 마찬가지입니다.

8
00:00:36,979 --> 00:00:38,570
그리고 오른쪽 포인터
다른 노드로,

9
00:00:38,570 --> 00:00:41,420
그리고 부모 포인터도 있습니다.
다른 노드로 이동합니다.

10
00:00:41,420 --> 00:00:43,910
이것은 나무의 한 예였습니다.

11
00:00:43,909 --> 00:00:45,964
B와 C는 A의 자녀입니다.

12
00:00:45,965 --> 00:00:49,010
A는 B의 아버지이다.
그리고 C와 루트

13
00:00:49,009 --> 00:00:50,329
나무 전체.

14
00:00:50,329 --> 00:00:51,847
우리는 노드의 높이를 측정했습니다.

15
00:00:51,847 --> 00:00:53,179
아직 많이 사용해 보지는 않았어요.

16
00:00:53,179 --> 00:00:54,762
하지만 오늘 우리는
자주 사용하세요.

17
00:00:54,762 --> 00:00:58,460
그러니 키를 기억하세요.
여기에 빨간색으로 그려져 있습니다.

18
00:00:58,460 --> 00:01:02,390
노드의 높이는 길이입니다.
가장 긴 하강 경로

19
00:01:02,390 --> 00:01:03,230
가장자리를 고려하여.

20
00:01:03,229 --> 00:01:05,509
예를 들어 B를 보면,
총 길이가 2개의 경로입니다.

21
00:01:05,510 --> 00:01:07,070
그래서 여기에 2라고 씁니다.

22
00:01:07,069 --> 00:01:09,559
여러분은 아마 다음과 같은 생각을 하고 계실지도 모릅니다.
마치 방금 당신이 그것에 대해 이야기한 것처럼

23
00:01:09,560 --> 00:01:14,600
아지트에 살고 있습니다
서브트리 B, B에 뿌리를 두고 있습니다.

24
00:01:14,599 --> 00:01:17,611
그렇다면 최대값은 얼마일까요?
이 노드들의 깊이,

25
00:01:17,611 --> 00:01:19,319
원하시면
그렇게 생각하다니.  안에

26
00:01:19,319 --> 00:01:20,750
어쨌든, 좋네요.

27
00:01:20,750 --> 00:01:22,730
특히,
우리가 선택한

28
00:01:22,730 --> 00:01:25,460
h, 높이
루트 노드의 높이는 다음과 같습니다.

29
00:01:25,459 --> 00:01:27,359
나무 전체.

30
00:01:27,359 --> 00:01:29,450
지난번에 우리는 기본적으로 다음과 같은 것을 달성했습니다.

31
00:01:29,450 --> 00:01:32,850
우리의 모든 운영
실험은 대략 h회 정도 수행되었습니다.

32
00:01:32,848 --> 00:01:37,729
그래서 우리는 서브트리 삽입을 했습니다.
서브트리 삭제, 서브트리 우선

33
00:01:37,729 --> 00:01:38,270
그리고 마지막입니다.

34
00:01:38,269 --> 00:01:40,186
우리는 계산할 수 있습니다
전임자와 후임자

35
00:01:40,186 --> 00:01:42,780
노드, 모든 것이 시간 순서대로 되어 있습니다.

36
00:01:42,780 --> 00:01:48,170
그래서 h가 있는 동안
어렸을 땐 행복했어요.

37
00:01:48,170 --> 00:01:50,509
그리고 그것을 기억하세요
전임자와 후임자를 의미하나요?

38
00:01:50,509 --> 00:01:54,320
암묵적인 것에 관한 것입니다.
트리의 순서, 즉

39
00:01:54,319 --> 00:01:57,589
우리는 순회 순서를 이렇게 부릅니다.
이는 재귀적으로 정의됩니다.

40
00:01:57,590 --> 00:02:02,329
재귀적인 좌측 순회로
하위 트리, 그 다음 루트 출력,

41
00:02:02,329 --> 00:02:05,039
그 다음 재귀 순회
오른쪽 서브트리.

42
00:02:05,040 --> 00:02:10,520
이 예시에서
순회 순서는 다음과 같습니다: F —

43
00:02:10,520 --> 00:02:13,130
끝까지 간다면
왼쪽이 첫 번째였어요.

44
00:02:13,129 --> 00:02:14,930
회전 순서대로.

45
00:02:14,930 --> 00:02:19,430
그럼 이제... 좋아요, 저는
여기 제 자리를 좀 마련해 둘게요.

46
00:02:19,430 --> 00:02:24,140
그다음은 D입니다.
그럼 B가 있습니다.

47
00:02:24,139 --> 00:02:26,000
우리는 옳은 일을 하고 있습니다
서브트리 B는 다음과 같습니다.

48
00:02:26,000 --> 00:02:30,590
E입니다. 그러면 우리는 다음과 같습니다.
루트로 설정하세요. 작업이 완료되었습니다.

49
00:02:30,590 --> 00:02:32,310
루트의 왼쪽 하위 트리.

50
00:02:32,310 --> 00:02:37,219
자, 그게 A입니다. 그리고 C가 있습니다.

51
00:02:37,219 --> 00:02:40,909
따라서 암묵적인 선형 관계가 존재합니다.
이 트리에 인코딩된 순서.

52
00:02:40,909 --> 00:02:42,770
그리고 그게 바로 핵심이죠
이진 트리

53
00:02:42,770 --> 00:02:46,219
이는 우리가 효과적으로 할 수 있다는 것입니다.
트리를 훨씬 빠르게 업데이트합니다.

54
00:02:46,219 --> 00:02:49,159
우리가 분명히 할 수 있는 것보다
순서를 배열에 적어주세요

55
00:02:49,159 --> 00:02:50,129
뭐 그런 거죠.

56
00:02:50,129 --> 00:02:53,478
따라서 이진 트리는 우리가 빠르게 작업할 수 있도록 해줍니다.

57
00:02:53,478 --> 00:02:55,519
지금, 빠르게
그렇게 서두르지 마세요.

58
00:02:55,520 --> 00:02:56,990
모든 게 괜찮으니까요.

59
00:02:56,990 --> 00:02:58,790
최악의 경우
h의 경우는 선형입니다.

60
00:02:58,789 --> 00:03:00,349
왜냐하면 우리는 가질 수 있기 때문입니다
그런 나무.

61
00:03:03,199 --> 00:03:05,119
하지만 오늘 우리는
우리가 하겠습니다...

62
00:03:05,120 --> 00:03:07,490
우리는 h가 log n과 같다는 것을 보장합니다.

63
00:03:07,490 --> 00:03:09,050
그래서 목표는
오늘은 가져가는 날입니다

64
00:03:09,050 --> 00:03:12,080
이 모든 작업들,
이 명령들은 순서대로 h번 실행됩니다.

65
00:03:12,080 --> 00:03:14,405
그리고 그들이 달리게 하세요
로그를 n번 주문하면 간단하게 됩니다.

66
00:03:14,405 --> 00:03:16,530
수정된
우리가 이미 살펴본 데이터 구조입니다.

67
00:03:16,530 --> 00:03:18,822
그래서 우리는 많은 것을 이루었습니다.
힘든 일, 아주 조금만

68
00:03:18,822 --> 00:03:21,590
우리가 해야 할 일이 더 많습니다
오늘날, 무엇이라고 불리는지에 대해

69
00:03:21,590 --> 00:03:25,370
AVL 나무 또는 높이 균형.

70
00:03:25,370 --> 00:03:28,650
하지만 그 전에, 먼저 하고 싶은 말이 있어요.
좀 더 얘기해 봐요.

71
00:03:28,650 --> 00:03:30,150
맨 마지막에
마지막 강의

72
00:03:30,150 --> 00:03:32,969
우리가 그때 그 얘기를 했잖아요.
이러한 서브트리 작업 --

73
00:03:32,969 --> 00:03:36,109
제가 삽입할 수 있도록
하위 트리에서 삭제 --

74
00:03:36,110 --> 00:03:38,780
이걸 실제로 어떻게 사용하나요?
우리가 가진 문제를 해결하다

75
00:03:38,780 --> 00:03:41,629
이 수업에 관심 있는 사람들은 다음과 같습니다.
시퀀스 데이터 구조 및

76
00:03:41,629 --> 00:03:42,870
데이터 구조를 설정하시겠습니까?

77
00:03:42,870 --> 00:03:47,909
지난번에 우리는 주로 다음과 같은 이야기를 나눴습니다.
데이터 세트 구조.

78
00:03:47,909 --> 00:03:50,810
그래서 일반적으로 우리는 다음과 같이 할 것입니다.
순회 순서가 무엇인지 결정하십시오.

79
00:03:50,810 --> 00:03:53,780
저희는 이진 트리 사용을 지원합니다.

80
00:03:53,780 --> 00:03:58,728
그래서 세트의 경우, 왜냐하면
다이얼링 인터페이스용

81
00:03:58,728 --> 00:04:01,699
저희는 그러한 일을 수행하는 데 관심이 있습니다.
find_next와 같은 쿼리

82
00:04:01,699 --> 00:04:04,641
그리고 find_previous는 다음과 같습니다.
만약 없다면, 키

83
00:04:04,641 --> 00:04:06,349
이전 것을 말해줘
아니면 다음 것,

84
00:04:06,349 --> 00:04:08,719
우리가 할 수 있는 일은 이것입니다.
이진 탐색을 수행합니다.

85
00:04:08,719 --> 00:04:12,169
그래서 이건 정말 크고 멋진 일이에요.
이진 트리가 우리에게 가능하게 해주는 것입니다.

86
00:04:12,169 --> 00:04:16,278
만약 우리가 통행 순서를 허용한다면
항상 모든 요소가 되어야 합니다

87
00:04:16,278 --> 00:04:18,680
저장된
키의 오름차순으로 정렬하면 다음과 같습니다.

88
00:04:18,680 --> 00:04:23,449
실제로 지원합니다
원소의 순서

89
00:04:23,449 --> 00:04:24,680
통과의 순서라는 의미에서.

90
00:04:24,680 --> 00:04:27,209
다시 말씀드리지만, 우리는 분명히 그렇지 않습니다.
우리는 그것들을 질서정연하게 유지합니다.

91
00:04:27,209 --> 00:04:29,839
하지만 여기, 저기 위에서 우리는
우리는 나무를 지지합니다

92
00:04:29,839 --> 00:04:32,299
핵심 요소들을 순서대로 제시합니다.

93
00:04:32,300 --> 00:04:37,639
따라서 이를 통해 우리는 수행할 수 있습니다.
하위 트리 찾기 작업,

94
00:04:37,639 --> 00:04:40,219
쉽게 할 수 있는
찾기 기능을 구현하는 데 사용합니다.

95
00:04:40,220 --> 00:04:42,500
find_previous 등

96
00:04:42,500 --> 00:04:43,800
아래 그림과 같습니다.

97
00:04:43,800 --> 00:04:45,889
먼저 ~부터 시작합시다.
나무뿌리.

98
00:04:45,889 --> 00:04:48,769
그러므로 우리는 다음과 같이 말할 수 있습니다.
초기에 해당 노드는 루트와 같습니다.

99
00:04:48,769 --> 00:04:52,769
그런 다음 재귀적으로 실행할 수 있습니다.
다음과 같이 키 k를 검색합니다.

100
00:04:52,769 --> 00:04:56,899
저희가 확인해 보겠습니다.
루트에 있는 요소

101
00:04:56,899 --> 00:04:59,489
키가 k보다 큽니다.

102
00:04:59,490 --> 00:05:00,889
제가 간단한 그림을 그려볼게요.

103
00:05:04,199 --> 00:05:08,348
그래서 우리는 지금 일종의 갈림길에 서 있습니다.

104
00:05:08,348 --> 00:05:10,220
이것은 노드입니다.

105
00:05:10,220 --> 00:05:13,550
그리고 왼쪽 서브트리가 있습니다.
그리고 오른쪽 서브트리.

106
00:05:13,550 --> 00:05:16,780
그리고 몇 가지가 있습니다.
일종의 열쇠를 가진 물체.

107
00:05:16,779 --> 00:05:20,259
그래서 우리가 찾고 있는 열쇠가
노드 요소보다 작습니다.

108
00:05:20,259 --> 00:05:23,079
이는 그가 ~라는 것을 의미합니다.
여기, 왼쪽 하위 트리에 있습니다.

109
00:05:23,079 --> 00:05:25,509
그래서 우리는 노드.left로 재귀 호출을 합니다.

110
00:05:25,509 --> 00:05:27,899
둘이 같으면, 그것은
이 요소는

111
00:05:27,899 --> 00:05:29,149
바로 우리가 찾던 사람입니다.

112
00:05:29,149 --> 00:05:30,847
그래서 우리는 그냥 돌아갈 수 있습니다.
그 사람의 노드,

113
00:05:30,848 --> 00:05:32,389
무엇에 따라
당신이 찾고 있는 것.

114
00:05:32,389 --> 00:05:34,689
그리고 만약 열쇠가 여기에 있다면
열쇠보다 더 큰

115
00:05:34,689 --> 00:05:38,649
우리가 찾고 있는 것은, 그렇다면
우리는 오른쪽으로 돌겠습니다.

116
00:05:38,649 --> 00:05:40,569
만약 당신이
그럼 잠시 생각해 보세요.

117
00:05:40,569 --> 00:05:43,599
이건 확실히 이진법입니다.
배열 검색.  그 대가로

118
00:05:43,600 --> 00:05:46,120
그는 단지 우연히
나무 위에.

119
00:05:46,120 --> 00:05:55,329
만약 당신이 ~에 대해 생각하고 있다면
그러한 배열,

120
00:05:55,329 --> 00:05:56,500
이진 탐색은 무엇을 하는가?

121
00:05:56,500 --> 00:05:58,339
첫인상
가운데 열쇠가 있습니다.

122
00:05:58,339 --> 00:06:00,159
저는 그림을 그릴 거예요.
마치 뿌리 같아요.

123
00:06:00,160 --> 00:06:04,060
그러면 재귀적으로 발생합니다.
또는 왼쪽 편에,

124
00:06:04,060 --> 00:06:08,110
나는 이를 재귀적으로 그려낼 것이다.
또는 오른쪽에.

125
00:06:08,110 --> 00:06:10,240
그래서, 만약 당신이 가지고 있다면
완벽한 이진수입니다.

126
00:06:10,240 --> 00:06:13,689
이런 나무라면,
정확히 모방합니다

127
00:06:13,689 --> 00:06:15,048
이 배열에서 이진 탐색을 수행합니다.

128
00:06:15,048 --> 00:06:17,589
하지만 우리는 할 수 있습니다.
동적으로 지원하기 위해 -

129
00:06:17,589 --> 00:06:19,689
완벽하진 않지만, 거의 완벽에 가깝습니다.

130
00:06:19,689 --> 00:06:23,180
우리는 할 수 없었지만
질서를 유지하세요.

131
00:06:23,180 --> 00:06:27,160
그러니까, 마치
이진 탐색의 일반화

132
00:06:27,160 --> 00:06:30,670
나무를 다루는 일에
배열 대신에.

133
00:06:30,670 --> 00:06:34,444
이러한 이유로 바이너리가 구성됩니다.
트리는 이진 트리라고 불립니다.

134
00:06:34,444 --> 00:06:36,819
트리를 검색하세요. 왜냐하면 트리는 다음과 같기 때문입니다.
이진 검색 트리의 한 버전입니다.

135
00:06:36,819 --> 00:06:38,449
그러므로 많은 것들이 있습니다.
동등한 이름.

136
00:06:38,449 --> 00:06:41,139
그래서 이진 검색 트리도 또 다른 예입니다.
이진 트리 집합의 이름입니다.

137
00:06:41,139 --> 00:06:43,719
핵심은 바로 이것입니다
이 알고리즘은 효과가 있습니다.

138
00:06:43,720 --> 00:06:45,970
소위
이진 검색 트리의 속성, 즉

139
00:06:45,970 --> 00:06:50,050
모든 열쇠
노드의 왼쪽 서브트리

140
00:06:50,050 --> 00:06:54,100
보다
루트 또는 이 노드,

141
00:06:54,100 --> 00:06:57,879
그리고 이 열쇠는 다른 모든 열쇠보다 작습니다.
오른쪽 서브트리에 키가 있습니다.

142
00:06:57,879 --> 00:07:00,379
그리고 이것은 재귀적으로도 참입니다.
끝까지.

143
00:07:00,379 --> 00:07:02,949
따라서 당신은 이를 증명합니다.
이 알고리즘

144
00:07:02,949 --> 00:07:04,849
이 속성에 따라 올바릅니다.

145
00:07:04,850 --> 00:07:06,170
왜 그럴까요?

146
00:07:06,170 --> 00:07:09,160
우리가 할 수 있다면
우회로의 순서를 유지하십시오.

147
00:07:09,160 --> 00:07:12,010
그래서 성장하고 있습니다
열쇠, 그다음 이것

148
00:07:12,009 --> 00:07:13,983
정확히 무엇
순회 순서를 의미합니다.

149
00:07:13,983 --> 00:07:16,149
그는 모든 것이 다 그렇다고 말합니다
왼쪽 하위 트리에서

150
00:07:16,149 --> 00:07:18,069
뿌리 앞에 오는 것, 즉
모든 것 앞에 서 있다

151
00:07:18,069 --> 00:07:18,944
오른쪽 하위 트리에 있습니다.

152
00:07:18,944 --> 00:07:23,680
그래서 이 부동산
이를 제공합니다.

153
00:07:23,680 --> 00:07:26,110
그렇다면 어떻게 지원하시나요?
주요 키 순서대로 오름차순으로 정렬하시겠습니까?

154
00:07:26,110 --> 00:07:27,790
꽤 쉬워요.

155
00:07:27,790 --> 00:07:31,240
삽입하려면
이 요소는 어디에 속합니까?

156
00:07:31,240 --> 00:07:33,759
자, 이건 네가 해 봐.
그가 어디에 있을지 찾기 위해 검색

157
00:07:33,759 --> 00:07:35,379
거기에 있었다면 어울렸을 것이다.

158
00:07:35,379 --> 00:07:38,259
해당 파일이 있다면 덮어쓸 수 있습니다.
이 키를 사용하여 저장된 값입니다.

159
00:07:38,259 --> 00:07:42,392
아니면, 이거요.
찾다

160
00:07:42,392 --> 00:07:43,808
일부에서
그 순간은 나무에서 떨어질 것이고, 그게 전부입니다.

161
00:07:43,810 --> 00:07:48,850
여기에 삽입하세요
트리에 새로운 노드가 추가되었습니다.

162
00:07:48,850 --> 00:07:51,610
이것은 낭독에서 설명되었습니다.
그래서 저는 거기서 멈추고 싶지 않아요.

163
00:07:51,610 --> 00:07:54,920
오늘 제가 집중하고 싶은 것은 다음과 같습니다.
이건 다른 프로그램입니다.

164
00:07:54,920 --> 00:07:57,159
어떻게 해야 할까요...? 이것은 ~을 위한 것입니다
집합의 표현

165
00:07:57,159 --> 00:07:59,080
상대적으로 쉽습니다.

166
00:07:59,079 --> 00:08:01,959
도전,
우리가 귀 기울여야 할 것은 바로 그것입니다.

167
00:08:01,959 --> 00:08:03,969
하지만 우리는 필요합니다
조금 더 할 일이 있습니다.

168
00:08:03,970 --> 00:08:07,540
이진 순차 트리를 생성하는 데 있어서.

169
00:08:07,540 --> 00:08:10,787
내가 이진수를 가지고 있다고 가정해 보자.
나무, 그리고 저는 ~하고 싶습니다 -

170
00:08:10,786 --> 00:08:12,370
우리가 언급했던
지난번 마지막 부분 - 그래서

171
00:08:12,370 --> 00:08:15,639
내 나무를 통과하는 순서

172
00:08:15,639 --> 00:08:20,469
~였다
순서대로, 내가 생각하는 순서대로

173
00:08:20,470 --> 00:08:22,960
나는 이것을 상상해 보려고 노력하고 있다.
그러한 작업으로 인해 변경되었습니다.

174
00:08:22,959 --> 00:08:26,379
insert_at으로.

175
00:08:26,379 --> 00:08:28,473
그래서 저는 그냥 말씀드리고 싶은 게 있어요.
당신도 똑같이 하세요.

176
00:08:28,473 --> 00:08:30,639
하지만 이제 생각을 해야 해요.
검색 방법에 대해 궁금합니다.

177
00:08:30,639 --> 00:08:32,649
insert_at을 어떻게 하나요?
등.

178
00:08:32,649 --> 00:08:36,788
하지만 그 알고리즘은 다음과 같습니다.
제가 일하고 싶은 분야입니다.

179
00:08:36,788 --> 00:08:40,058
하지만 이것은
아직은 제대로 작동하지 않을 거예요.

180
00:08:40,058 --> 00:08:45,699
자, 그럼 제가 여러분께 드린다고 가정해 봅시다.
따라서 해당 노드에 의해 서브트리가 정의됩니다.

181
00:08:45,700 --> 00:08:49,060
그래서, 모두 다 있습니다
이 노드의 후손들.

182
00:08:49,059 --> 00:08:52,359
그리고 저는 그것을 알고 싶습니다.
회전 순서대로

183
00:08:52,360 --> 00:08:55,570
이 하위 트리는
여기서 시작해서 여기서 끝납니다.

184
00:08:55,570 --> 00:08:58,250
그리고 뿌리는 다음과 같습니다.
중간쯤.

185
00:08:58,250 --> 00:09:01,100
i번째 노드를 알려주세요.

186
00:09:01,100 --> 00:09:03,430
그래서 만약 제가 i가 무엇과 같은지 묻는다면
0, 나는 얻고 싶다

187
00:09:03,429 --> 00:09:05,229
이 극좌파 후손.

188
00:09:05,230 --> 00:09:08,800
내가 i가 ~와 같기를 요청한다면
나무 크기에서 1을 뺀 값,

189
00:09:08,799 --> 00:09:11,379
나는 얻고 싶다
극우파의 후손.

190
00:09:11,379 --> 00:09:13,835
이것은 최초였고
하위 트리의 마지막 항목입니다.

191
00:09:13,835 --> 00:09:14,710
우리가 이야기했던 내용 말이에요.

192
00:09:14,710 --> 00:09:16,840
하지만 우리는 찾는 방법을 알고 있습니다.
처음과 마지막.

193
00:09:16,840 --> 00:09:18,220
왼쪽으로 가든 오른쪽으로 가든 상관없어요.

194
00:09:18,220 --> 00:09:22,180
하지만 우리는 그 방법을 모릅니다
i번째 노드를 찾으세요.

195
00:09:22,179 --> 00:09:26,109
현재 목표는 시간 h이기 때문입니다.
로그 n이 아닙니다.

196
00:09:26,110 --> 00:09:30,399
핵심은 다음과 같습니다.
크기가 중요합니다.

197
00:09:30,399 --> 00:09:34,069
[웃음] 죄송합니다
당신은 다른 걸 들었군요.

198
00:09:34,070 --> 00:09:36,940
그러므로 특히,
나는 그 크기를 기억했다.

199
00:09:36,940 --> 00:09:40,300
~에 대해 이야기할 때
시퀀스의 마지막 노드입니다.

200
00:09:40,299 --> 00:09:44,859
이 노드의 인덱스는 다음과 같습니다.
서브트리 크기에서 1을 뺀 값입니다.

201
00:09:44,860 --> 00:09:51,250
그럼 정의해 봅시다.
노드 크기

202
00:09:51,250 --> 00:09:57,309
수량으로서
하위 트리의 노드 --

203
00:09:57,309 --> 00:09:59,049
우리가 전화했어요
이 하위 트리(노드)--

204
00:10:06,509 --> 00:10:09,100
노드 자체를 포함하여.

205
00:10:09,100 --> 00:10:11,340
그래서 만약 제가 어떻게든
크기를 알고 있었어요,

206
00:10:11,340 --> 00:10:13,590
중요한 것 같습니다
지표 이해하기.

207
00:10:13,590 --> 00:10:16,530
그냥 그렇게 가정해 봅시다.
나는 마법처럼 그것을 알아챘다.

208
00:10:16,529 --> 00:10:17,279
일정한 시간으로.

209
00:10:19,980 --> 00:10:23,200
그렇다면 저는 이렇게 주장합니다.
왼쪽 서브트리의 크기 --

210
00:10:23,200 --> 00:10:25,350
그럼 좀 더 자세히 설명해 볼까요?
이 도표 말인가요?

211
00:10:29,059 --> 00:10:31,909
그래서 이전과 마찬가지로 노드가 하나 있습니다.

212
00:10:31,909 --> 00:10:36,120
하지만 우리는 왼쪽 서브트리를 가지고 있습니다.
그리고 오른쪽 서브트리.

213
00:10:36,120 --> 00:10:37,700
여기 있는 이 노드는 node.left입니다.

214
00:10:37,700 --> 00:10:39,080
여기 있는 이 노드는 node.right입니다.

215
00:10:39,080 --> 00:10:42,500
그런 것들이 존재하지 않을지도 모르지만, 일단은 그렇게 해봅시다.
이러한 예외적인 사례들은 무시합시다.

216
00:10:42,500 --> 00:10:43,759
.

217
00:10:43,759 --> 00:10:47,189
우리가 몰랐다고 가정해 봅시다
노드의 크기만 다릅니다.

218
00:10:47,190 --> 00:10:49,280
하지만 또한
크기 노드.left,

219
00:10:49,279 --> 00:10:53,779
이것이 바로 사이즈입니다.
왼쪽에 나무들이 있습니다.

220
00:10:53,779 --> 00:10:55,069
저는 그걸 nL이라고 부를 거예요.

221
00:10:55,070 --> 00:10:59,000
자, 그럼 다음과 같이 가정해 봅시다.
여기에 nL개의 노드가 있습니다.

222
00:10:59,000 --> 00:11:03,769
저는 이것이 제가 공연을 할 수 있게 해준다고 주장합니다.
이진 탐색과 동일합니다.

223
00:11:03,769 --> 00:11:06,439
제가 찾고 있는 것은
일부 인덱스 i.

224
00:11:06,440 --> 00:11:10,737
그리고 만약 i가 nL보다 작다면, i는
분명 여기 아래쪽에 있을 거야.

225
00:11:10,736 --> 00:11:12,319
예를 들어, 만약 내가
0과 같으면, 그것은

226
00:11:12,320 --> 00:11:16,490
왼쪽 서브트리에 있을 것입니다.
nL이 0보다 크면, 또는

227
00:11:16,490 --> 00:11:16,990
잘못된?

228
00:11:16,990 --> 00:11:19,190
이게 바로 계산서입니다.

229
00:11:19,190 --> 00:11:21,080
만약 i가 nL보다 작다면,
재귀 호출을 하겠습니다.

230
00:11:21,080 --> 00:11:25,860
왼쪽, 서브트리 호출
노드 왼쪽에서, i.

231
00:11:25,860 --> 00:11:27,830
여기에 그렇게 쓰여 있어요.

232
00:11:27,830 --> 00:11:31,430
만약 i가 nL과 같다면, 생각해 보세요.
잠깐 그 얘기 좀 해볼까... 그러니까, nL

233
00:11:31,429 --> 00:11:33,149
여기에 있는 노드의 개수는 이렇습니다.

234
00:11:33,149 --> 00:11:37,340
이것은 다음을 의미합니다.
해당 노드의 인덱스는 nL입니다.

235
00:11:37,340 --> 00:11:39,500
이 노드의 인덱스는 nL입니다.

236
00:11:39,500 --> 00:11:42,769
그러므로 만약 i가 ~와 같다면--
우리가 찾고 있는 유일한 인덱스입니다.

237
00:11:42,769 --> 00:11:44,779
그렇다면 우리는
우리는 이 노드를 그대로 반환합니다.

238
00:11:44,779 --> 00:11:46,459
끝났습니다.

239
00:11:46,460 --> 00:11:48,920
그렇지 않으면, 저는
nL보다 더 많습니다.

240
00:11:48,919 --> 00:11:50,929
그리고 이것은 다음을 의미합니다.
우리가 찾고 있는 노드,

241
00:11:50,929 --> 00:11:54,589
올바른 하위 트리에 있습니다.
뿌리 다음에 오기 때문입니다.

242
00:11:54,590 --> 00:11:56,263
다시 한번, 그 의미를 설명해 드리겠습니다.

243
00:11:56,263 --> 00:11:57,680
저것
통과의 순서를 의미합니다.

244
00:11:57,679 --> 00:12:00,829
그렇다면 이것을 정의해 보겠습니다.
순서의 순서대로,

245
00:12:00,830 --> 00:12:03,920
그러면 우리는 모든 것이 그렇다는 것을 알게 됩니다.
이 노드 다음에 오는 것들, 즉

246
00:12:03,919 --> 00:12:06,120
nL의 인덱스는 여기에 있어야 합니다.

247
00:12:06,120 --> 00:12:08,870
자, 여기서 재귀 호출을 하면,
저희 번호 체계가 변경됩니다.

248
00:12:08,870 --> 00:12:12,320
여기 노드의 경우 값이 0이기 때문입니다.

249
00:12:12,320 --> 00:12:15,060
그리고 나서 노드를 여기에 배치합니다.

250
00:12:15,059 --> 00:12:17,629
그래서 우리는 약간의 일을 해야 합니다.
여기서 빼기,

251
00:12:17,629 --> 00:12:19,309
즉, 우리가 돌아올 때
오른쪽에, 우리는

252
00:12:19,309 --> 00:12:22,579
우리는 i에서 nL을 빼고 1을 뺍니다.
이 사람들에게는 nL이 마이너스입니다.

253
00:12:22,580 --> 00:12:25,925
루트 노드의 경우 -1입니다.

254
00:12:25,924 --> 00:12:27,799
그리고 이것은 우리에게 줄 것입니다
우리가 찾고 있는 인덱스

255
00:12:27,799 --> 00:12:30,979
이 하위 트리에 있습니다.

256
00:12:30,980 --> 00:12:34,399
그래서 제가 말씀드리고 싶은 것은 이것입니다.
알고리즘은 기본적으로 다음과 같습니다.

257
00:12:34,399 --> 00:12:35,600
이 알고리즘과 동일합니다.

258
00:12:35,600 --> 00:12:39,080
하지만 여기서는 열쇠가 사용됩니다. 왜냐하면
우리는 집합을 다루고 있습니다.

259
00:12:39,080 --> 00:12:41,450
집합에서 우리는 다음과 같이 가정합니다.
요소에는 키가 있습니다.

260
00:12:41,450 --> 00:12:43,520
여기서는 물체가 아닙니다
그들은 열쇠를 가지고 있어야 합니다.

261
00:12:43,519 --> 00:12:45,809
사실, 우리는
우리는 물건을 전혀 만지지 않습니다.

262
00:12:45,809 --> 00:12:49,822
우리는 단지 i가 무엇인지 묻고 있을 뿐입니다.
그리고 내 시퀀스의 요소는 다음과 같습니다.

263
00:12:49,822 --> 00:12:52,490
정확히 무엇인가
내 순회 순서에서 i번째 요소,

264
00:12:52,490 --> 00:12:54,560
이는 다음과 같습니다.
어느 것을 묻는 것

265
00:12:54,559 --> 00:12:56,599
순회 순서대로 노드가 있나요?

266
00:12:56,600 --> 00:12:58,310
그리고 이 알고리즘
이것을 당신에게 줍니다

267
00:12:58,309 --> 00:13:01,089
완전히 똑같습니다
시간 h 순서대로.

268
00:13:03,547 --> 00:13:05,629
지금은 보여주지 않을 거예요.
모든 작업을 처리해 주세요.

269
00:13:05,629 --> 00:13:11,929
하지만 subtree_at을 사용할 수 있습니다.
get_at set_at을 구현합니다.

270
00:13:11,929 --> 00:13:15,049
딱 맞는 걸 찾으면 되는 거예요.
노드를 생성하고 요소를 반환합니다.

271
00:13:15,049 --> 00:13:17,179
또는 항목을 변경하세요.

272
00:13:17,179 --> 00:13:19,069
또는 다음과 같은 용도로 사용할 수도 있습니다...

273
00:13:19,070 --> 00:13:21,950
가장 중요한 것은, 여러분은 사용할 수 있다는 것입니다.
insert_at delete_at을 수행합니다.

274
00:13:21,950 --> 00:13:25,090
이것은 우리가 새롭게 시도하는 것입니다.
전에는 해본 적이 없어요.

275
00:13:25,090 --> 00:13:25,970
무슨 일을 하세요?

276
00:13:25,970 --> 00:13:28,670
여기처럼, 만약 내가
요소를 삽입하려고 합니다.

277
00:13:28,669 --> 00:13:33,299
저는 이걸 찾고 있어요.
여기에 요소가 있습니다.

278
00:13:33,299 --> 00:13:36,709
예를 들어, 제가 삽입하려고 하면
저는 저를 찾고 있습니다.

279
00:13:36,710 --> 00:13:43,490
그리고 나서 insert_at i를 위해
새 요소를 직접 추가해야 합니다.

280
00:13:43,490 --> 00:13:44,990
이전에는.

281
00:13:44,990 --> 00:13:47,870
게다가 편리하기도 하다.
우리는 이미 가지고 있습니다...

282
00:13:47,870 --> 00:13:50,810
제가 언급하진 않았지만, 저희는 가지고 있습니다.
서브트리 삽입이 있습니다.  안에

283
00:13:50,809 --> 00:13:55,469
우리에게는 두 가지 버전이 있었다.
전후 사진.

284
00:13:55,470 --> 00:13:59,269
그 후에 우리가 고려했던 것 같아요.
제가 사용하는 제품이 후속작입니다.

285
00:13:59,269 --> 00:14:01,129
이전 버전을 사용하기 전에.

286
00:14:01,129 --> 00:14:04,279
하지만 우리는 그냥 할 수 있어요
서브트리 삽입 호출

287
00:14:04,279 --> 00:14:09,470
이 노드의 이전과
붐, 우리가 추가할게요

288
00:14:09,470 --> 00:14:12,230
바로 앞에 있는 새로운 요소.

289
00:14:12,230 --> 00:14:15,710
네, 좋습니다.
어떻게 된 일인지, 마법처럼 우리는

290
00:14:15,710 --> 00:14:18,080
삽입됨
이 시퀀스의 중간 부분입니다.

291
00:14:18,080 --> 00:14:21,980
모든 인덱스가 업데이트되었습니다.
저는 저축을 하지 않기 때문입니다.

292
00:14:21,980 --> 00:14:23,210
지수.

293
00:14:23,210 --> 00:14:25,730
대신 검색하려면
인덱스 i에 있는 요소,

294
00:14:25,730 --> 00:14:28,820
저는 검색 알고리즘을 사용합니다.

295
00:14:28,820 --> 00:14:31,460
하지만 문제가 있습니다.  ~에

296
00:14:31,460 --> 00:14:32,300
왜 문제가 생기는 걸까요?

297
00:14:36,519 --> 00:14:39,189
이건 너무 과한 것 같아.
너무 좋아서 믿기 어려울 정도야.

298
00:14:39,190 --> 00:14:41,500
저는 삽입하고 있습니다
이 나무의 가운데 부분,

299
00:14:41,500 --> 00:14:44,350
그러다가 어쩌다 보니
신기하게도 검색할 수 있고 여전히

300
00:14:44,350 --> 00:14:47,350
설령 ~일지라도 i번째 요소를 찾으세요
오른쪽에 있는 모든 인덱스

301
00:14:47,350 --> 00:14:48,759
이 요소로부터 1이 증가합니다.

302
00:14:52,580 --> 00:14:54,720
거의 맞는 말이에요.

303
00:14:54,720 --> 00:14:55,220
대답하다?

304
00:14:58,019 --> 00:14:59,279
예?

305
00:14:59,279 --> 00:15:00,754
청중: [알아들을 수 없음]

306
00:15:00,754 --> 00:15:03,129
에릭 드메인: 왜냐하면 우리는
치수를 업데이트해야겠죠?

307
00:15:03,129 --> 00:15:06,350
계산 방법을 말하지는 않았습니다.
왼쪽 서브트리의 크기는 얼마입니까?

308
00:15:06,350 --> 00:15:07,659
자, 그럼 다음 주제는 이것입니다.

309
00:15:11,950 --> 00:15:12,850
거의 다 끝났어요.

310
00:15:12,850 --> 00:15:14,509
이건 정말 효과가 있을 거예요.

311
00:15:14,509 --> 00:15:16,779
이거 정말 훌륭하네요.

312
00:15:16,779 --> 00:15:18,789
하지만 이것이 효과를 발휘하려면,
우리에겐 뭔가가 필요해.

313
00:15:18,789 --> 00:15:22,836
그것을 뭐라고 부르나요?
하위 트리를 확장함으로써,

314
00:15:22,836 --> 00:15:23,919
이에 대해 전반적으로 이야기해 보겠습니다.

315
00:15:23,919 --> 00:15:25,389
그리고 나서 우리는
크기에도 적용해 봅시다.

316
00:15:30,370 --> 00:15:32,590
그래서 그 아이디어는...
서브트리 추가

317
00:15:32,590 --> 00:15:37,899
각 노드가 그렇습니다.
우리의 이진 트리에서

318
00:15:37,899 --> 00:15:45,100
일정한 상태를 유지할 수 있습니다.
추가 필드 수.

319
00:15:45,100 --> 00:15:46,779
왜 안 돼

320
00:15:46,779 --> 00:15:49,750
특히,
이러한 필드가

321
00:15:49,750 --> 00:15:51,610
특정 유형에 속하다,

322
00:15:51,610 --> 00:15:53,259
어쩌면 그걸 부동산이라고 부를지도 모르겠네요.

323
00:15:57,700 --> 00:16:10,030
내가 결정하겠다
하위 트리 속성

324
00:16:10,029 --> 00:16:21,329
무언가처럼,
계산 가능한 것은 무엇인가

325
00:16:21,330 --> 00:16:25,520
아이들의 재산에서
노드.

326
00:16:28,740 --> 00:16:30,779
그러므로 저는 이렇게 말해야겠습니다.
이것은 노드입니다.

327
00:16:37,230 --> 00:16:42,029
따라서 하위 요소는 다음과 같습니다.
노드 왼쪽과 노드 오른쪽.

328
00:16:42,029 --> 00:16:44,654
영구적으로 접근할 수도 있습니다.
그 외에도 여러 가지가 있습니다.

329
00:16:44,654 --> 00:16:47,620
예를 들어 노드 자체에 대해.

330
00:16:47,620 --> 00:16:49,139
하지만 요점은
하위 트리 속성

331
00:16:49,139 --> 00:16:50,490
아래쪽으로 향한다는 점에서 그렇습니다.

332
00:16:50,490 --> 00:16:57,360
여기에 노드가 있다면
그리고 저는 원합니다

333
00:16:57,360 --> 00:17:00,750
특정 값을 계산하다
그에 관한 재산 --

334
00:17:00,750 --> 00:17:06,000
무엇이든 말해보세요, 저희는 원합니다.
P 노드를 저장하세요--

335
00:17:06,000 --> 00:17:09,269
그리고 우리가 이미 그렇게 가정해 봅시다.
우리는 여기서 P를 알고 있습니다.

336
00:17:09,269 --> 00:17:11,910
속성, 계산됨
왼쪽 서브트리의 경우

337
00:17:11,910 --> 00:17:13,710
또는 왼쪽의 경우
노드이고, 우리는 이미

338
00:17:13,710 --> 00:17:17,970
우리는 그 부동산에 대해 알고 있습니다
오른쪽 노드라면, 저는 다음과 같이 하고 싶습니다.

339
00:17:17,970 --> 00:17:20,367
그래서 그것은
일정한 시간 내에 계산됩니다.

340
00:17:26,160 --> 00:17:29,750
그래서 저는 이것의 P를 계산할 수 있습니다.
왼쪽 노드의 P가 주어졌을 때 노드

341
00:17:29,750 --> 00:17:30,869
그리고 오른쪽 노드의 P입니다.

342
00:17:30,869 --> 00:17:32,339
이는 하위 트리의 속성입니다.

343
00:17:32,339 --> 00:17:38,339
특히 지금, 크기는
기판의 특성입니다.

344
00:17:38,339 --> 00:17:39,509
왜

345
00:17:39,509 --> 00:17:43,829
나는 글을 쓸 수 있기 때문이다.
이러한 유형의 반복,

346
00:17:43,829 --> 00:17:49,281
노드의 크기는 다음과 같습니다.
노드.왼쪽.크기--

347
00:17:49,281 --> 00:17:52,470
이건 쓰기엔 너무 지루해.

348
00:17:52,470 --> 00:17:59,579
노드 오른쪽 크기를 더하면?

349
00:18:03,789 --> 00:18:05,954
1. 감사합니다.

350
00:18:05,954 --> 00:18:11,184
모든 것의 크기
여기서는 노드라고 부르는 서브트리입니다.

351
00:18:11,184 --> 00:18:13,809
왼쪽 서브트리의 크기와 같습니다.
오른쪽 서브트리의 크기를 더한 값

352
00:18:13,809 --> 00:18:17,289
노드 자체에 +1점을 줍니다.

353
00:18:17,289 --> 00:18:18,865
자, 이것이 업데이트 규칙입니다.

354
00:18:18,865 --> 00:18:20,529
평가하는 데는 지속적인 시간이 필요합니다.

355
00:18:20,529 --> 00:18:22,990
두 가지 버전이 있습니다.

356
00:18:22,990 --> 00:18:27,250
죄송합니다, 제 T자가 이렇게 생겼어요
플러스 기호처럼요.

357
00:18:27,250 --> 00:18:29,390
저는 플러스(+)를 계산하겠습니다.
조금 더.

358
00:18:35,750 --> 00:18:38,029
요약하자면 이렇습니다.
이 세 가지.

359
00:18:38,029 --> 00:18:40,019
짜잔, 노드 크기를 얻을 수 있습니다.

360
00:18:40,019 --> 00:18:46,980
그래서 저는 다음과 같이 주장합니다.
내 부동산에는 이러한 기능이 있습니다.

361
00:18:46,980 --> 00:18:51,680
저는 그것을 동적으로 지원할 수 있습니다.
나무를 바꾸는 것.

362
00:18:51,680 --> 00:18:53,721
그건 좀...
이전 링크,

363
00:18:53,721 --> 00:18:55,430
아직 그러지 않았기 때문입니다
우리가 말한 그대로입니다

364
00:18:55,430 --> 00:18:56,638
우리는 나무를 바꿀 거예요.

365
00:18:56,637 --> 00:18:57,709
하지만 문제는 무엇일까요?

366
00:18:57,710 --> 00:19:01,100
대상: 노드의 크기가
재귀적인,

367
00:19:01,099 --> 00:19:03,289
그렇다면 이런 일은 어떻게 일어나는 걸까요?
일정한 시간으로?

368
00:19:03,289 --> 00:19:05,149
저건 그렇지 않나요?
[알아들을 수 없는 부분]이 일어날까요?

369
00:19:05,150 --> 00:19:06,275
에릭 데마인: 왜 이런 거죠...?

370
00:19:06,275 --> 00:19:07,290
네, 좋은 질문입니다.

371
00:19:07,289 --> 00:19:09,079
그런
어떤 방식으로든, 당신은 인지할 수 있습니다.

372
00:19:09,079 --> 00:19:10,849
마치 재귀 같아요.
그러면 당신에게 주어집니다

373
00:19:10,849 --> 00:19:12,750
재귀 알고리즘.

374
00:19:12,750 --> 00:19:14,779
그래서 제가 글을 쓴 겁니다만...
쓰지 않았다.

375
00:19:14,779 --> 00:19:18,139
하지만 저는 그렇게 쓸 수 있습니다.
노드 크기는 다음과 같습니다.

376
00:19:18,140 --> 00:19:19,910
크기 노드.왼쪽
게다가, 이것까지

377
00:19:19,910 --> 00:19:23,029
선형 시간 알고리즘을 제공할 것입니다.
크기 계산용입니다.

378
00:19:23,029 --> 00:19:24,710
그리고 만약 당신이 가지고 있다면
정보가 없습니다.

379
00:19:24,710 --> 00:19:27,218
당신이라면 그렇게 할 거예요.

380
00:19:27,218 --> 00:19:28,509
그건 정말 고통스러울 거예요.

381
00:19:28,509 --> 00:19:30,426
그럼 이게 되겠네요.
알고리즘이 매우 느립니다.

382
00:19:30,426 --> 00:19:33,859
제가 그 크기를 다음과 같이 부른다면
재귀 함수는 좋지 않습니다.

383
00:19:33,859 --> 00:19:36,409
대신에, 저는
치수를 보관합니다.

384
00:19:36,410 --> 00:19:41,509
각 개별 노드에서
그리고 미리 계산해 두세요.

385
00:19:41,509 --> 00:19:46,220
사실, 저는
노드의 크기를 결정하겠습니다...

386
00:19:46,220 --> 00:19:48,440
그것
수학적 정의.

387
00:19:48,440 --> 00:19:50,000
하지만 알고리즘은
이 함수에 대해

388
00:19:50,000 --> 00:19:53,599
오직 다음과 같은 것만 있을 것입니다
노드 크기를 반환합니다.

389
00:19:53,599 --> 00:19:55,609
그러니까 시간은 끊임없이 흐른다는 뜻이죠.

390
00:19:55,609 --> 00:19:58,099
그래서 제가 직면한 과제는 바로 이것입니다.
나는 이러한 치수를 유지해야 합니다.

391
00:19:58,099 --> 00:20:00,469
최신 상태인지 여부와 관계없이
내가 나무로 뭘 하고 있는 거지?

392
00:20:00,470 --> 00:20:02,450
그리고 당신은 할 수 있습니다
지난 강의를 되돌아보자

393
00:20:02,450 --> 00:20:06,500
자, 보세요, 좋아요, 이게 다 뭐죠?
내가 트리에 어떤 변화를 주었나요?

394
00:20:06,500 --> 00:20:09,619
저희는 단지 변경 작업을 하고 있었을 뿐입니다.
삽입 및 삭제 중에.

395
00:20:09,619 --> 00:20:16,939
제가 말씀드리겠습니다.
삽입과 삭제를 할 때,

396
00:20:16,940 --> 00:20:22,640
그것들은 무엇인가요?
결국 그렇게 했다.

397
00:20:22,640 --> 00:20:29,090
그들은 추가하거나 제거했습니다.
나뭇잎.

398
00:20:35,049 --> 00:20:39,169
편지가 무엇이었는지 기억하세요
자식 노드가 없는 노드.

399
00:20:39,170 --> 00:20:42,730
자, 그럼 한번 생각해 봅시다.
나는 나무에 새 잎을 하나 더 달겠다.

400
00:20:42,730 --> 00:20:45,440
여기 나무 한 그루가 있다고 가정해 봅시다.
여기에 편지 한 통을 추가하겠습니다.

401
00:20:45,440 --> 00:20:48,160
어떤 하위 트리가 변경될까요?

402
00:20:48,160 --> 00:20:52,570
그럼, 어떤 서브트리들을 말씀하시는 건가요?
이 노드를 포함합니까?

403
00:20:52,569 --> 00:20:54,039
이것은 실제로 새로운 하위 트리입니다.

404
00:20:54,039 --> 00:20:58,480
그러면 그것은 상위 하위 트리에 있게 됩니다.
할아버지 하위 트리로

405
00:20:58,480 --> 00:21:00,970
그리고 일반 하위 트리.

406
00:21:00,970 --> 00:21:04,240
일반적으로 이러한 노드들은
조상이라고 불립니다.

407
00:21:04,240 --> 00:21:06,250
우리가 추가한 이 노드입니다.

408
00:21:06,250 --> 00:21:07,930
그리고 이것은
업데이트된 것들입니다.

409
00:21:07,930 --> 00:21:10,360
이것은 하위 트리입니다.
변하지 않았습니다.

410
00:21:10,359 --> 00:21:11,559
크기는 변하지 않았습니다.

411
00:21:11,559 --> 00:21:13,769
그리고 이것 이후로
하위 트리 속성,

412
00:21:13,769 --> 00:21:15,519
하위 트리의 속성은 없습니다.
여기서 변경될 것입니다.

413
00:21:15,519 --> 00:21:18,369
서브트리가
손대지 않은 상태였다.

414
00:21:18,369 --> 00:21:22,629
그래서 제가 이걸 만지면
아, 난 그냥 필요한 게 있어.

415
00:21:22,630 --> 00:21:24,610
업데이트
여기서 서브트리 속성은 다음과 같습니다.

416
00:21:24,609 --> 00:21:25,990
업데이트
여기서 서브트리 속성은 다음과 같습니다.

417
00:21:25,990 --> 00:21:27,190
여기서 서브트리 속성을 업데이트하세요.

418
00:21:27,190 --> 00:21:28,356
몇 개나 있나요?

419
00:21:32,220 --> 00:21:33,730
예?

420
00:21:33,730 --> 00:21:36,500
h-- 안전을 위해 h 순서라고 말하겠습니다.

421
00:21:36,500 --> 00:21:40,089
하지만 제 생각엔 그게 바로 그 이유인 것 같아요.

422
00:21:40,089 --> 00:21:42,609
마찬가지로, 제가 삭제할 때도
잎에서도 똑같은 일이 일어납니다.

423
00:21:42,609 --> 00:21:44,829
이 잎을 삭제하면,
그다음은 하위 트리입니다.

424
00:21:44,829 --> 00:21:46,869
변화하고 있는 것들은
그의 이전 조상들.

425
00:21:51,430 --> 00:22:01,360
좋아요, 그래서 우리가 모이는 거예요.
h 순서의 이러한 조상들을 업데이트하세요

426
00:22:01,359 --> 00:22:13,769
나무 위쪽으로 갈수록 순서대로.

427
00:22:13,769 --> 00:22:15,950
그렇다면 제가 말하는 '업데이트'란 무엇을 의미하는 걸까요?

428
00:22:15,950 --> 00:22:18,740
제 말은 이 규칙의 적용을 말하는 겁니다.  무엇

429
00:22:18,740 --> 00:22:21,809
크기에 관해서는 이것이 규칙입니다.

430
00:22:21,809 --> 00:22:23,539
하지만 일반적으로
하위 트리 속성

431
00:22:23,539 --> 00:22:26,250
업데이트 규칙을 알려줍니다.
이는 일정한 시간이 걸립니다.

432
00:22:26,250 --> 00:22:28,819
그래서 저는 갑니다.
이 업데이트 규칙을 적용하세요

433
00:22:28,819 --> 00:22:32,569
이 노드를 수정하겠습니다.
모든 속성

434
00:22:32,569 --> 00:22:33,559
거기에 저장됩니다.

435
00:22:33,559 --> 00:22:35,129
어쩌면 더 있을지도 몰라요
하나 이상의 부동산.

436
00:22:35,130 --> 00:22:36,630
그런 다음 지원하겠습니다.
이것은 이 노드를 가리킵니다.

437
00:22:36,630 --> 00:22:40,040
그리고 이것은 이미
귀납법에 의해 정답이다.

438
00:22:40,039 --> 00:22:42,470
네, 맞습니다.
내가 만지지 않았으니까

439
00:22:42,470 --> 00:22:44,029
하위 트리 - 변경되지 않았습니다 -

440
00:22:44,029 --> 00:22:46,789
그러면 업데이트할 수 있습니다.
이 노드의 값 --

441
00:22:46,789 --> 00:22:49,159
이 부동산
노드는 일정한 시간에 존재합니다.

442
00:22:49,160 --> 00:22:51,200
그럼 이 글을 업데이트하겠습니다.

443
00:22:51,200 --> 00:22:53,468
그리고 이것 이후로
귀납적으로 이미 옳다.

444
00:22:53,468 --> 00:22:55,759
그리고 이것은 이미 존재합니다.
서브트리이기 때문에 맞습니다.

445
00:22:55,759 --> 00:22:58,879
변하지 않는, 나는 할 수 있다
여기에서 속성을 올바르게 업데이트하세요

446
00:22:58,880 --> 00:23:00,500
일정한 시간으로.

447
00:23:00,500 --> 00:23:03,170
그래서 내가
h 시간의 순서를 바꿉니다.

448
00:23:03,170 --> 00:23:06,200
제가 전화를 걸기 때문에
이 상수 시간 알고리즘은

449
00:23:06,200 --> 00:23:11,569
영구적인 설정을 업데이트할 수 있습니다.
서브트리 속성 수.

450
00:23:11,569 --> 00:23:12,619
이것은 매우 강력합니다.

451
00:23:12,619 --> 00:23:14,659
데이터 구조 확장
매우 유용합니다.

452
00:23:14,660 --> 00:23:16,160
당신은 이것을 다음과 같은 용도로 사용할 것입니다.
당신의 작업 목록입니다.

453
00:23:16,160 --> 00:23:19,080
우리는 오늘도 그것을 다시 사용할 것입니다.

454
00:23:19,079 --> 00:23:22,549
몇 가지 예를 들어보겠습니다.
하위 트리 속성.

455
00:23:27,980 --> 00:23:35,059
그럴 수 있어요. 흔한 일이죠.
예를 들어, 합계 또는 곱.

456
00:23:35,059 --> 00:23:42,289
최소한이거나,
최댓값 또는 제곱합

457
00:23:42,289 --> 00:23:50,089
또는 모든 종류
사물, 몇 가지 특징

458
00:23:50,089 --> 00:23:52,054
서브트리의 각 노드.

459
00:23:57,859 --> 00:24:01,309
실제로 서브트리의 크기는 다음과 같습니다.
그러한 것의 한 예입니다.

460
00:24:01,309 --> 00:24:05,990
이는 모든 노드의 합입니다.
하위 트리의 값은 1입니다.

461
00:24:05,990 --> 00:24:08,509
이것은 또 다른 방법입니다
노드의 개수를 세세요.

462
00:24:08,509 --> 00:24:10,460
하지만 당신은 또한 할 수 있습니다
얼마라고 말하세요

463
00:24:10,460 --> 00:24:11,697
이 노드들에 키가 있나요?

464
00:24:11,696 --> 00:24:14,029
혹은 어느 것인지 말할 수도 있습니다.
이 노드들에서 최대 키는 무엇입니까?

465
00:24:14,029 --> 00:24:21,737
혹은 어느 것인지 말할 수도 있습니다.
이 노드들의 최댓값은 무엇입니까?

466
00:24:21,737 --> 00:24:22,820
어떤 물건이든 가져가실 수 있습니다.

467
00:24:22,819 --> 00:24:23,899
그건 중요한 요소가 되어서는 안 됩니다.

468
00:24:23,900 --> 00:24:25,775
이러면 안 돼요.
특별한 건 없어요.

469
00:24:25,775 --> 00:24:26,730
이것은 매우 강력합니다.

470
00:24:26,730 --> 00:24:28,807
모든 금액을 가져가셔도 됩니다.
제품을 개발하고 지원합니다.

471
00:24:28,807 --> 00:24:30,349
그들이 있는 한
아래를 내려다보며,

472
00:24:30,349 --> 00:24:33,889
당신이 있는 동안
당신은 서브트리에 대해서만 생각합니다.

473
00:24:33,890 --> 00:24:38,860
몇 가지 예를 들면 다음과 같습니다.
당신이 지원할 수 없는 것은

474
00:24:41,880 --> 00:24:45,345
노드 인덱스가 아닙니다.

475
00:24:48,480 --> 00:24:51,750
그러니 당신도 그렇다면
증강현실에 열정적이신가요?

476
00:24:51,750 --> 00:24:54,150
여러분은 이렇게 생각할지도 모릅니다: 아,
저는 무엇이든 할 수 있어요.

477
00:24:54,150 --> 00:24:56,850
나는 지원이 필요했다
subtree_at, 또는,

478
00:24:56,849 --> 00:24:59,369
예를 들어, get_at
전 세계적으로, 저는 원했습니다.

479
00:24:59,369 --> 00:25:01,500
어느 쪽인지 알기 위해
내 트리의 i번째 노드는 무엇인가요?

480
00:25:01,500 --> 00:25:03,690
음, 저는 그냥 사용할게요.
데이터 구조 확장

481
00:25:03,690 --> 00:25:09,240
그리고 각 노드에 저장합니다.
해당 인덱스는 0부터 n-1까지입니다.

482
00:25:09,240 --> 00:25:11,370
저는 지원할 수 없습니다.
효과적입니다.

483
00:25:11,369 --> 00:25:13,889
만약 내가 삽입한다면
일찍

484
00:25:13,890 --> 00:25:18,340
제 작업 순서는 다음과 같습니다.
모든 지표가 바뀔 것입니다.

485
00:25:18,339 --> 00:25:20,909
이것이 바로 편집의 예시입니다.

486
00:25:20,910 --> 00:25:23,529
그래서 만약 제가 삽입한다면
여기에 새로운 노드가 있습니다.

487
00:25:23,529 --> 00:25:25,649
이 사람의 인덱스
이전에는 0이었는데, 지금은 1입니다.

488
00:25:25,650 --> 00:25:27,780
이 사람의 인덱스
1살이었는데, 지금은 2살이에요.

489
00:25:27,779 --> 00:25:29,430
지금은 2시였어요.
이것은 3이고, 이런 식으로 계속됩니다.

490
00:25:29,430 --> 00:25:31,380
각 노드는 인덱스를 변경합니다.

491
00:25:31,380 --> 00:25:33,750
인덱스는 아닙니다
하위 트리의 속성,

492
00:25:33,750 --> 00:25:35,279
그래서 우리는 그것을 지지할 수 없습니다.

493
00:25:35,279 --> 00:25:37,497
모든 사람에게 달려있기 때문입니다
트리의 노드.

494
00:25:37,497 --> 00:25:39,330
아니면 모든 사람에게 달려 있는 걸까요?
왼쪽에 있는 노드들 —

495
00:25:39,329 --> 00:25:40,899
모든 전임자들.

496
00:25:40,900 --> 00:25:43,440
예를 들면,
이 사람의 인덱스는 상황에 따라 다릅니다.

497
00:25:43,440 --> 00:25:46,140
노드 수로부터
여기 왼쪽에 있는 것들은 거기에 없습니다.

498
00:25:46,140 --> 00:25:47,980
이 노드의 하위 트리에 있습니다.

499
00:25:47,980 --> 00:25:50,400
자, 여기
조심해야 해요.

500
00:25:50,400 --> 00:25:52,630
전역 변수를 사용하지 마세요
나무의 특성.

501
00:25:52,630 --> 00:25:57,760
사용 가능한 범위는 다음과 같습니다.
하위 트리 속성.

502
00:25:57,759 --> 00:26:01,754
또 다른 예로는 깊이가 있습니다.

503
00:26:01,755 --> 00:26:08,220
깊이감 유지가 귀찮다.
하지만 그 이유는 여전히 불분명합니다.

504
00:26:08,220 --> 00:26:09,779
잠시 후에 알게 되겠죠.

505
00:26:14,609 --> 00:26:20,219
오늘 남은 시간은 다음과 같은 일에 할애하겠습니다.
h 순서에서 log 순서로의 전환

506
00:26:20,220 --> 00:26:23,769
n, 즉
이 슬라이드를 보여줍니다.

507
00:26:23,769 --> 00:26:26,460
그러므로 이 시점에서 당신은
우리는 모든 작업을 수행할 수 있다고 믿습니다.

508
00:26:26,460 --> 00:26:30,180
시퀀스 데이터 구조
순서대로 h,

509
00:26:30,180 --> 00:26:33,130
건설과 반복을 제외하고,
선형적인 시간이 걸리는,

510
00:26:33,130 --> 00:26:36,750
그리고 우리 모두가 할 수 있는 일은 무엇일까요?
h 순서대로 연산을 수행합니다.  시간,

511
00:26:36,750 --> 00:26:38,460
조립을 제외하고
반복에는 시간이 걸립니다.

512
00:26:38,460 --> 00:26:40,620
n log n과 n입니다.

513
00:26:40,619 --> 00:26:50,789
그리고 우리의 목표는
이제 h와 log n의 관계를 살펴보겠습니다.

514
00:26:50,789 --> 00:26:53,670
우리는 그것이 가능하다는 것을 알고 있습니다.
특정 수준에서,

515
00:26:53,670 --> 00:26:57,450
나무가 있기 때문에
로그 스케일 높이.

516
00:26:57,450 --> 00:27:00,565
여기 있습니다
완벽한 나무.

517
00:27:00,565 --> 00:27:02,190
하지만 우리는 또한 그것을 알고 있습니다.
우리는 조심해야 합니다.

518
00:27:02,190 --> 00:27:04,320
나쁜 사람들이 있기 때문입니다
나무들은 이런 식으로 줄지어 서 있다.

519
00:27:07,170 --> 00:27:15,140
따라서 h가 log n과 같으면, 우리는 이렇게 부릅니다.
이것은 균형 이진 트리입니다.  세계에서

520
00:27:19,430 --> 00:27:21,200
많은 것들이 있습니다
균형 이진 트리

521
00:27:21,200 --> 00:27:24,302
, 아마도,
십여 명에서 스무 명 정도 -

522
00:27:24,301 --> 00:27:25,759
다양한
데이터 구조.

523
00:27:25,759 --> 00:27:26,259
질문?

524
00:27:26,259 --> 00:27:28,825
청중: [알아들을 수 없음]
당신은 아니라고 했잖아요.

525
00:27:28,825 --> 00:27:30,932
사물에 대해 생각하다
세계적인 차원에서,

526
00:27:30,932 --> 00:27:32,432
그래서 우리는 생각해 볼 것입니다.
그들은 [표시 불가].

527
00:27:32,432 --> 00:27:34,382
무엇을 설명해 주시겠어요?
그건 조금 더 많다는 뜻인가요?

528
00:27:34,382 --> 00:27:35,840
에릭 데마인: 알겠습니다.
무슨 뜻인가요?

529
00:27:35,839 --> 00:27:40,519
지역적 특성
전체 트리가 아니라 하위 트리에 대한 말씀이신가요?

530
00:27:40,519 --> 00:27:43,075
가장 적절한 답변은 다음과 같습니다.
이것이 정의입니다.

531
00:27:43,075 --> 00:27:45,200
하지만 이것은 사실이 아닐 수도 있습니다.
가장 직관적인 정의.

532
00:27:45,200 --> 00:27:46,033
제 말이 그 뜻이에요.

533
00:27:46,032 --> 00:27:48,781
계산 가능한 것,
정보를 아는 것만으로도

534
00:27:48,781 --> 00:27:50,240
당신의 좌파들에 대해서
그리고 오른쪽 자식 요소(자식들),

535
00:27:50,240 --> 00:27:52,220
의미는 다음과 같습니다.
그러한 속성.

536
00:27:52,220 --> 00:27:54,595
그게 전부예요.
당신은 후원할 수 있습니다.

537
00:27:54,595 --> 00:27:57,319
왜냐하면 그렇기 때문입니다
유일한 한 명,

538
00:27:57,319 --> 00:28:00,500
업데이트가 쉬운 것,
이쪽으로 가세요.

539
00:28:00,500 --> 00:28:06,049
그리고 그 대조는 바로 이것입니다.
인덱스와 같은 전역 속성

540
00:28:06,049 --> 00:28:08,000
전 세계적입니다.
특히, 왜냐하면 나는

541
00:28:08,000 --> 00:28:12,140
저는 한 가지를 변경하거나 한 가지를 추가할 수 있습니다.
노드, 그리고 모두

542
00:28:12,140 --> 00:28:13,030
노드 속성이 변경됩니다.

543
00:28:13,029 --> 00:28:15,470
이건 극단적인 경우입니다.
글로벌 사례의 한 예입니다.

544
00:28:15,470 --> 00:28:20,180
우리는 이것을 정말 갖고 싶어요
지역에 대한 특정한 개념,

545
00:28:20,180 --> 00:28:23,570
왜냐하면 이것이 우리가 감당할 수 있는 수준이기 때문입니다.
세도록 허용합니다.

546
00:28:23,569 --> 00:28:24,919
이로써 상황이 명확해졌기를 바랍니다.

547
00:28:24,920 --> 00:28:27,008
예?

548
00:28:27,008 --> 00:28:31,630
청중: 크기는 중요하지 않나요?
이 [표시 안 됨]과 호환되나요?

549
00:28:31,630 --> 00:28:33,700
에릭 데마인: 당신은 가지고 있습니다
네, 만약 우리가 더한다면...

550
00:28:33,700 --> 00:28:34,255
안 돼.

551
00:28:34,255 --> 00:28:35,380
좋아요, 한번 생각해 봅시다.

552
00:28:35,380 --> 00:28:37,340
만약 우리가 새로운 것을 추가한다면
나무의 아버지,

553
00:28:37,339 --> 00:28:40,599
이것
우리는 절대 그러지 않았어요.

554
00:28:40,599 --> 00:28:44,500
하지만 설령 우리가 그렇게 한다 해도,
어떤 하위 트리가 변경될까요?

555
00:28:44,500 --> 00:28:47,740
이것 하나뿐이에요.

556
00:28:47,740 --> 00:28:50,410
이 노드, 이
완전히 새로운 하위 트리.

557
00:28:50,410 --> 00:28:52,779
하지만 이 노드의 서브트리는
완전히 바뀌지는 않습니다.

558
00:28:52,779 --> 00:28:54,654
서브트리가
늘 아래를 내려다보고 있다.

559
00:28:54,654 --> 00:28:58,269
만약 제가 새로운 루트를 추가한다면,
하위 트리를 변경하지 않았습니다.

560
00:28:58,269 --> 00:28:59,889
단 한 명을 제외하고.

561
00:28:59,890 --> 00:29:01,790
따라서 크기는 서브트리의 속성입니다.

562
00:29:01,789 --> 00:29:03,490
지금은...

563
00:29:03,490 --> 00:29:05,509
제 말은, 저는 충분히 할 수 있다는 거죠.
트리를 다시 그리세요.

564
00:29:05,509 --> 00:29:07,509
그리고 이것은 작전입니다.
이는 다음을 필요로 합니다

565
00:29:07,509 --> 00:29:08,980
모든 것의 열거.

566
00:29:08,980 --> 00:29:11,740
그러므로 제한되는 것은 바로 그것입니다.
저는 목공 작업을 할 수 있습니다.

567
00:29:11,740 --> 00:29:13,960
하지만 저는 그 모든 것이
우리는 마지막 수업을 할 거예요.

568
00:29:13,960 --> 00:29:18,410
그리고 오늘날 우리는 그것을 감당할 수 있습니다.
이는 증가입니다.

569
00:29:18,410 --> 00:29:21,100
그러므로 이 부동산은 아닙니다
반드시 모든 이진 트리가 필요한 것은 아닙니다.

570
00:29:21,099 --> 00:29:22,599
그리고 저것들은,
저희가 다룰 내용입니다.

571
00:29:22,599 --> 00:29:23,099
예?

572
00:29:23,099 --> 00:29:24,394
청중: 광산이란 무엇인가요?

573
00:29:24,394 --> 00:29:25,561
에릭 드메인: 1분은 얼마죠?

574
00:29:25,561 --> 00:29:27,369
청중: [알아들을 수 없음]

575
00:29:27,369 --> 00:29:31,359
에릭 데메인: 이진 트리 맞습니다.

576
00:29:31,359 --> 00:29:35,259
네, 시간이 좀 걸릴 겁니다.
더 말이 되네요.

577
00:29:35,259 --> 00:29:38,099
우리가 정말로
우리는 나무들을 어떻게 할 건가요?

578
00:29:49,059 --> 00:29:53,829
우리는 새로운 도구가 필요합니다
나무를 다루는 것.

579
00:29:53,829 --> 00:29:56,529
우리가 지금까지 해온 일은 다음과 같습니다.
물건들을 교환했어요.

580
00:29:56,529 --> 00:29:59,109
그리고 우리는 추가했습니다
그리고 잎을 제거했습니다.

581
00:29:59,109 --> 00:30:00,009
이것으로는 충분하지 않습니다.

582
00:30:00,009 --> 00:30:01,990
우리는 필요할 것입니다
다른 무언가

583
00:30:01,990 --> 00:30:05,319
로그 스케일의 높이를 보장합니다.

584
00:30:05,319 --> 00:30:07,899
그리고 이건 또 다른 문제입니다.
이를 회전이라고 합니다.

585
00:30:12,049 --> 00:30:15,349
무엇
이 작업을 위해 필요한 다른 것이 있나요?

586
00:30:15,349 --> 00:30:18,469
그것은 단순히 도구일 뿐입니다.
나무의 균형을 회복하는 것.

587
00:30:18,470 --> 00:30:22,279
따라서 이는 데이터에 영향을 미치지 않을 것입니다.
나무로 표현됩니다.

588
00:30:22,279 --> 00:30:24,319
어떤 데이터
나무를 나타내는 건가요?

589
00:30:24,319 --> 00:30:25,939
통과의 순서.

590
00:30:25,940 --> 00:30:27,660
순례 순서는 신성하다.

591
00:30:27,660 --> 00:30:28,910
우리는 그것을 만지면 안 됩니다.

592
00:30:28,910 --> 00:30:31,250
이것은 이미 결정되었습니다.
두 가지 다른 방식으로,

593
00:30:31,250 --> 00:30:34,410
~에 따라,
집합을 사용하시나요, 아니면 순열을 사용하시나요?

594
00:30:34,410 --> 00:30:37,130
그래서 우리는 바꾸고 싶습니다
나무를 다음과 같은 방식으로 심지 않도록 하십시오.

595
00:30:37,130 --> 00:30:39,380
순회 순서를 변경합니다.

596
00:30:39,380 --> 00:30:41,510
그래서 저희는 예약 시스템을 이용합니다.

597
00:30:41,509 --> 00:30:43,819
녹음하셨다면
배열의 순회 순서,

598
00:30:43,819 --> 00:30:45,589
균등해질 것입니다
하나의 표현

599
00:30:45,589 --> 00:30:46,939
이 주문의.

600
00:30:46,940 --> 00:30:49,340
하지만 나무가 하나 있습니다.
많은 프레젠테이션.

601
00:30:49,339 --> 00:30:50,839
줄이 길어질 수 있습니다.

602
00:30:50,839 --> 00:30:52,519
균형의 문제일 수도 있습니다.

603
00:30:52,519 --> 00:30:54,769
그들은 대표할 수 있습니다
노드 순서가 완전히 동일합니다.

604
00:30:54,769 --> 00:30:56,599
만약 제대로 표시되었다면요.

605
00:30:56,599 --> 00:30:59,299
실제로는 지수적인 증가가 있습니다.
다양한 표현들

606
00:30:59,299 --> 00:31:00,049
한 가지.

607
00:31:00,049 --> 00:31:04,879
그리고 우리는 이것과 저것을 사용할 겁니다.
바로 그 순서로, 우리는 결정할 것입니다...

608
00:31:04,880 --> 00:31:06,560
그냥 그게
당신은 알아야 합니다.

609
00:31:20,364 --> 00:31:27,819
A, X, B로 표시하겠습니다.
Y, C. 당신은 내가

610
00:31:27,819 --> 00:31:31,569
이 도표를 그렸습니다
수없이 많습니다.

611
00:31:31,569 --> 00:31:35,059
이것은 매우 강력한 도구입니다.
모든 트리 데이터 구조에서,

612
00:31:35,059 --> 00:31:37,059
대다수를 차지하는 사람들
데이터 구조.

613
00:31:37,059 --> 00:31:46,940
그리고 그것들을 우회전이라고 부릅니다.
y축과 왼쪽 회전 x축.

614
00:31:53,859 --> 00:31:55,729
만약 제게 이 나무가 있다면,

615
00:31:55,730 --> 00:31:58,150
저는 그냥
저는 일부 하위 트리를 배치하고 있습니다.

616
00:31:58,150 --> 00:31:59,410
작은 삼각형으로 나누세요.

617
00:31:59,410 --> 00:32:02,860
만약 내게 노드가 있다면,
왼쪽 자식 요소가 있습니다.

618
00:32:02,859 --> 00:32:05,589
그럼 회전해도 됩니다.
오른쪽 가장자리를 말하는 것인데, 이는 가져가라는 뜻입니다.

619
00:32:05,589 --> 00:32:07,000
이 가장자리를 따라 이렇게 움직이세요.

620
00:32:07,000 --> 00:32:09,057
90도처럼요.

621
00:32:09,057 --> 00:32:11,349
아니면 그냥 생각해 보세요.
이런 식으로 다시 쓰는 것과 같아요.

622
00:32:11,349 --> 00:32:14,289
이제 당신도 가질 수 있습니다.
상위 인덱스를 추적합니다.

623
00:32:14,289 --> 00:32:16,720
부모 포인터가 이동 중입니다.

624
00:32:16,720 --> 00:32:18,610
이전에는 그랬습니다.
y의 아버지.

625
00:32:18,609 --> 00:32:20,979
이분이 바로 x의 아버지입니다.

626
00:32:20,980 --> 00:32:23,980
그래서 x와 y가 서로 바뀌었습니다.

627
00:32:23,980 --> 00:32:27,610
하지만 우리는 그냥 그렇게 할 수는 없었어요.
이 요소들을 서로 교환하세요.

628
00:32:27,609 --> 00:32:29,979
왜냐하면 그것은
투어 순서를 변경할 것입니다.

629
00:32:29,980 --> 00:32:32,440
이 사진에서
x는 y보다 먼저 온다.

630
00:32:32,440 --> 00:32:36,850
x가 왼쪽에 있으므로
순회 순서대로 나열된 서브트리 y.

631
00:32:36,849 --> 00:32:40,000
그리고 지금 y는 위치해 있습니다.
오른쪽 서브트리 x에 있습니다.

632
00:32:40,000 --> 00:32:41,349
그러니까 x 다음에 오는 거죠.

633
00:32:41,349 --> 00:32:43,599
그래서 두 경우 모두
x는 y보다 먼저 온다.

634
00:32:43,599 --> 00:32:48,609
그리고 실제로 이 모든 것에 대해
도면상의 우회로 순서 -

635
00:32:48,609 --> 00:32:51,519
제 말은, x뿐만 아니라
y뿐만 아니라 A, B, C에도 해당됩니다.

636
00:32:51,519 --> 00:32:53,170
우회 주문
일관성이 있습니다.

637
00:32:53,170 --> 00:33:01,975
이것은 A, X, B, y, C입니다.
내가 삼각형을 그릴 때,

638
00:33:01,974 --> 00:33:03,849
재귀적이라는 뜻입니다.
모든 것을 우회하는 순서

639
00:33:03,849 --> 00:33:05,577
삼각형 안에 있는 것들.

640
00:33:05,577 --> 00:33:07,869
그러니, 그냥 지원하시면 됩니다.
순회 순서 알고리즘은 여기에 있습니다.

641
00:33:07,869 --> 00:33:09,829
그리고 여기, 당신은
동일한 결과가 나올 것입니다.

642
00:33:09,829 --> 00:33:12,970
즉, 이러한 작업들은
통행 순서를 유지하십시오.

643
00:33:18,769 --> 00:33:21,379
좋습니다, 이것은
우리가

644
00:33:21,380 --> 00:33:24,890
우리가 할 수 있는 일은 나무가 아닌 곳에서 하는 것입니다
무엇에 영향을 미칠까요?

645
00:33:24,890 --> 00:33:26,330
우리가 지금까지 해온 일입니다.

646
00:33:26,329 --> 00:33:28,669
이것은 우리가 사용하는 도구입니다.
균형을 회복하는 데 사용할 수 있습니다.

647
00:33:28,670 --> 00:33:34,190
사물이 얼마나 깊은 의미를 지니는지 주목해 보세요.
변경 트리에서.

648
00:33:34,190 --> 00:33:37,309
우리의 문제는 다음과 같습니다.
이 선형 트리

649
00:33:37,309 --> 00:33:39,200
몇 가지가 있다는 것입니다.
선형 깊이 노드.

650
00:33:39,200 --> 00:33:40,440
우리는 그것들을 없애고 싶습니다.

651
00:33:40,440 --> 00:33:40,940
처럼?

652
00:33:40,940 --> 00:33:44,029
그럼, 이 갈비를 가져가도 되겠네.
그리고 위쪽으로 회전시키기 시작하세요.

653
00:33:44,029 --> 00:33:47,849
심연을 들여다보면,
이 사진에서

654
00:33:47,849 --> 00:33:51,649
A와 B는 보다 깊다
C. 그리고 이 사진에서

655
00:33:51,650 --> 00:33:55,100
B와 C는 보다 깊다
A. 그러니까, 일종의 타협안인 거죠.

656
00:33:55,099 --> 00:33:57,469
이 장미 한 송이.

657
00:33:57,470 --> 00:33:58,490
이건 무너졌어.

658
00:33:58,490 --> 00:34:01,039
이것은 남았다
같은 깊이에서.

659
00:34:01,039 --> 00:34:07,129
그러므로, 바라건대, A가 너무
C는 깊고, C는 너무 얕다.

660
00:34:07,130 --> 00:34:08,934
그들은 이런 식으로 거래할 수 있습니다.

661
00:34:08,934 --> 00:34:11,119
이것이 복잡해 보일 수도 있습니다.
하지만 사실은 있습니다

662
00:34:11,119 --> 00:34:18,768
상당히 간단한 방법으로
AVL 트리라고 불리는 것,

663
00:34:18,768 --> 00:34:24,438
일정한 균형을 유지한다
높이 균형이라고 부르는 방식입니다.

664
00:34:34,730 --> 00:34:42,710
이것은 우리가 다음과 같이 한다면입니다.
높이 노드.왼쪽--

665
00:34:46,130 --> 00:34:47,500
사실, 저는 좀 더 선호합니다-

666
00:34:50,079 --> 00:35:03,190
노드 오른쪽, 마이너스
높이 노드.왼쪽,

667
00:35:03,190 --> 00:35:11,050
그래서 그렇게 불립니다
왜곡된 노드.

668
00:35:11,050 --> 00:35:15,039
난 이게 항상 이랬으면 좋겠어.
마이너스 1, 0 또는 플러스 1.

669
00:35:17,889 --> 00:35:21,929
그러니까, 이것은 다음을 의미합니다.
만약 제게 노드가 있다면,

670
00:35:21,929 --> 00:35:25,371
그리고 나는 그의 왼쪽을 바라본다.
서브트리와 그 오른쪽 서브트리,

671
00:35:25,371 --> 00:35:26,829
나는 그것들을 측정한다.
키를 기억하세요.

672
00:35:26,829 --> 00:35:30,670
이것이 아래쪽으로의 거리입니다.
글자까지의 최대 거리 --

673
00:35:30,670 --> 00:35:32,137
저는 키를 재고 있습니다.
이 나무 --

674
00:35:32,137 --> 00:35:34,179
최대 높이 -- 그리고 나
최대 높이를 측정합니다.

675
00:35:34,179 --> 00:35:39,011
이 하위 트리에서, 저는 그들이 다음을 하기를 바랍니다.
서로 1 이내의 차이였습니다.

676
00:35:39,012 --> 00:35:39,970
이상적으로는 둘의 비율이 같아야 합니다.

677
00:35:39,969 --> 00:35:41,739
이것이야말로 이상적인 경우일 것입니다.

678
00:35:41,739 --> 00:35:44,139
하지만 그 차이가 1만큼이라도 나도록 하세요.

679
00:35:44,139 --> 00:35:48,219
어쩌면 괜찮을지도 몰라요.
그리고 이것은 k 더하기 1입니다.

680
00:35:48,219 --> 00:35:51,669
아니면 k일지도 몰라요.
그리고 이것은 k 마이너스 1입니다.

681
00:35:51,670 --> 00:35:53,730
이 사진에서,
이 노드의 높이는 얼마입니까?

682
00:35:53,730 --> 00:35:56,811
이는 좋은 관행입니다.

683
00:35:56,811 --> 00:35:59,559
k 더하기 2, 알겠습니다.

684
00:35:59,559 --> 00:36:01,779
가장 긴 경로는 무엇입니까?
이 마디에서 잎까지?

685
00:36:01,780 --> 00:36:03,460
뭐, 지나갈 수도 있죠.
이 하위 트리를 통해.

686
00:36:03,460 --> 00:36:06,159
이것이 길이 k가 될 것입니다.
k이기 때문에 1을 더합니다.

687
00:36:06,159 --> 00:36:07,569
이 장점에 +1점을 드립니다.

688
00:36:07,570 --> 00:36:10,450
아니면 여기에도 괜찮을 것 같아요.
그리고 이것은 k 더하기 1 더하기 1입니다.

689
00:36:10,449 --> 00:36:12,379
그래서 가장 중요한 것은...
오른쪽으로 가세요.

690
00:36:12,380 --> 00:36:14,860
그러니까, 키는... 제가 말씀드리면...
이 하위 트리들의 높이,

691
00:36:14,860 --> 00:36:16,443
우리는 얻을 수 있습니다
이 노드의 높이.

692
00:36:16,443 --> 00:36:19,490
우리는 사용할 것입니다
순간적으로 많은 일이 일어났네요.

693
00:36:19,489 --> 00:36:21,489
그래서 첫 번째 진술은 다음과 같습니다.
내가 할 수 있다면

694
00:36:21,489 --> 00:36:26,619
구하다
높이 균형을 맞춘 다음, 저는

695
00:36:26,619 --> 00:36:28,639
h는 log n과 같다는 것을 보장합니다.

696
00:36:28,639 --> 00:36:32,179
다시 말해서,
높이 균형은 균형을 의미합니다.

697
00:36:32,179 --> 00:36:36,259
자, 그럼 시작해 볼까요?
우리는 그것을 곧바로 증명할 것입니다.

698
00:36:36,260 --> 00:36:40,505
그리고 나서 흥미로운 부분이 시작됩니다.
이것이 바로 우리가 실제로 증명하는 방식입니다...

699
00:36:44,690 --> 00:36:47,825
또는 우리가 실제로 어떻게
균형의 속성을 유지합니까?

700
00:36:47,824 --> 00:36:49,449
우리가 하겠습니다
이는 회전을 통해 이루어집니다.

701
00:36:49,449 --> 00:36:51,489
하지만 가장 큰 문제는 '어떻게' 하느냐입니다.

702
00:37:01,719 --> 00:37:07,419
그렇다면 왜일까요?
높이 균형이 균형을 의미하는가?

703
00:37:16,550 --> 00:37:21,530
이는 다음을 시사합니다.
높이가 균형 잡힌 모든 나무

704
00:37:21,530 --> 00:37:24,810
로그 스케일의 높이를 가진다.

705
00:37:24,809 --> 00:37:26,389
그래서 저는 다음과 같이 말씀드리고 싶습니다.
생각하다

706
00:37:26,389 --> 00:37:30,889
가장 균형이 안 잡힌
높이가 균형 잡힌 나무.

707
00:37:30,889 --> 00:37:36,069
가장 균형이 안 잡힌
해당 노드에 불일치가 발생할 것입니다.

708
00:37:36,070 --> 00:37:39,170
왼쪽이라고 해봅시다
하위 트리가 더 작습니다.

709
00:37:39,170 --> 00:37:42,800
오른쪽 서브트리보다 1만큼 더 크고,
끝까지 재귀적으로.

710
00:37:42,800 --> 00:37:45,650
따라서 각 노드에는 다음과 같은 것들이 있습니다.
간격,

711
00:37:49,521 --> 00:37:51,480
우리는 그걸 뭐라고 부르죠?

712
00:37:51,480 --> 00:37:56,519
스큐 1, 즉
저는 적어 놓겠습니다.

713
00:37:56,519 --> 00:37:58,090
저는 입장하겠습니다
몇 가지 표기법.

714
00:37:58,090 --> 00:38:00,360
저는 멋진 글을 쓸 거예요.
오른쪽 화살표, 이 화살표가

715
00:38:00,360 --> 00:38:03,164
왼쪽 하위 트리 위쪽.

716
00:38:06,469 --> 00:38:08,269
그래서 가장 쉬운 방법은
한번 생각해 보세요.

717
00:38:08,269 --> 00:38:10,119
그것
최악의 시나리오입니다.

718
00:38:10,119 --> 00:38:14,259
이것이 가장 작은 숫자가 될 것입니다.
최대 깊이를 위한 노드.

719
00:38:14,260 --> 00:38:18,370
몇 개인지 세어보자
이 트리의 노드들.

720
00:38:18,369 --> 00:38:21,309
이것을 적어두겠습니다.
마치 반복처럼

721
00:38:21,309 --> 00:38:25,659
노드의 개수입니다.
높이가 h인 나무에서.

722
00:38:25,659 --> 00:38:32,679
만약 이 나무 전체의 높이가
h, 이 사진에서 말씀드렸듯이,

723
00:38:32,679 --> 00:38:35,750
2를 빼면
이 모든 숫자 중에서,

724
00:38:35,750 --> 00:38:40,269
그렇다면 이 나무는
높이 h에서 2를 뺀 값,

725
00:38:40,269 --> 00:38:44,019
그리고 이 나무는
높이 h에서 1을 뺀 값.

726
00:38:44,019 --> 00:38:45,833
그럼 여기에 노드가 몇 개나 있는 거죠?

727
00:38:45,833 --> 00:38:47,750
음, 이건 반복되는 내용입니다.
나는 글을 쓸 것이다.

728
00:38:47,750 --> 00:38:52,059
그래서 이것은 N<sub>h</sub> 마이너스 2가 될 것입니다.

729
00:38:52,059 --> 00:38:55,360
이것은 N<sub>h</sub> 마이너스 1이 될 것입니다.

730
00:38:55,360 --> 00:38:57,910
그런 다음 몇 개인지 세어 봅니다.
이 그림의 노드.

731
00:38:57,909 --> 00:39:06,099
이것은 Nh 마이너스 1 플러스 Nh입니다.
마이너스 2 플러스 1, 즉 이 노드입니다.

732
00:39:06,099 --> 00:39:09,519
이제 여러분은 이렇게 질문하실 수 있습니다.
Nh 재발의 원인은 무엇인가요?

733
00:39:09,519 --> 00:39:15,759
하지만 이것은 노드의 개수입니다.
최악의 시나리오에서는,

734
00:39:15,760 --> 00:39:18,460
만약에
최악의 경우 총 높이 h.

735
00:39:18,460 --> 00:39:20,349
그러니 당신도 할 수 있습니다.
그것을 다음과 같이 생각해 보세요.

736
00:39:20,349 --> 00:39:22,089
최소 수량
저는 매듭을 묶을 수 있어요

737
00:39:22,090 --> 00:39:25,780
AVL 트리에 있는 것은 다음과 같습니다.
높이가 균형 잡힌 나무, 즉

738
00:39:25,780 --> 00:39:38,610
높이가 h입니다.
높이가 균형 잡힌 나무인가요?

739
00:39:38,610 --> 00:39:40,920
좋아요, 이제 제가 필요한 건...
이 반복 문제를 해결하세요.

740
00:39:40,920 --> 00:39:42,450
이건 반복입니다.
이거 익숙해 보이지 않나요?

741
00:39:48,050 --> 00:39:49,550
마치 피보나치 수열 같아요.

742
00:39:49,550 --> 00:39:52,130
플러스 기호를 제거하면
1, 이것은 피보나치 수열입니다.

743
00:39:52,130 --> 00:39:54,320
그리고 만약 당신이 그것을 알고 있다면
피보나치 수열이 증가합니다

744
00:39:54,320 --> 00:39:56,690
금처럼
n에 대한 비율,

745
00:39:56,690 --> 00:39:58,490
그럼 우리는 알게 되죠.
그것이 지수적으로 증가한다는 것입니다.

746
00:39:58,489 --> 00:39:59,539
이것이 우리가 원하는 것입니다.

747
00:39:59,539 --> 00:40:02,690
왜냐하면 Nh가
h에 대한 지수 함수,

748
00:40:02,690 --> 00:40:04,670
이는 h가
N에 대한 로그 함수,

749
00:40:04,670 --> 00:40:06,617
로그는 역수이기 때문입니다.
지수적으로.

750
00:40:06,617 --> 00:40:08,659
하지만 당신은 모를 수도 있어요.
피보나치 수열에 관하여.

751
00:40:08,659 --> 00:40:14,299
그래서 우리는 쉽게 할 수 있습니다
지수적 증가임을 보여주세요.

752
00:40:14,300 --> 00:40:15,960
아래 그림과 같습니다.

753
00:40:15,960 --> 00:40:18,260
나는 이것이 사실임을 증명하고 싶다
적어도 지수는,

754
00:40:18,260 --> 00:40:22,830
왜냐하면 그것은 내게 다음을 주기 때문이다.
h는 기껏해야 로그 함수입니다.

755
00:40:22,829 --> 00:40:24,182
따라서 하한값이 필요합니다.

756
00:40:24,182 --> 00:40:26,599
그래서 우리는 이 두 가지 용어를 가지고 있습니다.
비교하기 어려운 것들:

757
00:40:26,599 --> 00:40:28,849
Nh 마이너스 1과 Nh 마이너스 2.

758
00:40:28,849 --> 00:40:30,211
이건 왠지 보기 흉하네요.

759
00:40:30,211 --> 00:40:31,670
하지만 만약 허락된다면
부주의하다--

760
00:40:31,670 --> 00:40:33,460
그리고 우리는 그것을 알게 될 것입니다.
우리는 너무 허술하지 않아요.

761
00:40:33,460 --> 00:40:35,570
그리고 동시에 얻습니다
지수적 반응,

762
00:40:35,570 --> 00:40:40,115
그냥 해보자
그들과 동등한 위치에 있는 사람들은 이와 같습니다.

763
00:40:44,150 --> 00:40:48,139
그러므로 이것은 사실입니다.
사실, 엄밀히 말하면 그보다 더 많습니다.

764
00:40:48,139 --> 00:40:48,679
왜

765
00:40:48,679 --> 00:40:50,419
플러스 1을 제거했기 때문입니다.

766
00:40:50,420 --> 00:40:52,309
이것으로 충분할 것입니다.
좀 더 작은 것.

767
00:40:52,309 --> 00:40:56,599
그리고 저는 Nh 마이너스를 교체했습니다.
1에서 Nh 마이너스 2까지.

768
00:40:56,599 --> 00:40:58,309
여기서 나는 암묵적으로 존재한다
나는 그 사실을 이용한다

769
00:40:58,309 --> 00:41:03,170
귀납적으로 자명하다.
이 나무의 높이는 얼마입니까?

770
00:41:03,170 --> 00:41:05,269
내가 이 나무를 가져간다면
이 나무에 기대어,

771
00:41:05,269 --> 00:41:07,849
그것은 더 많은 것을 가지고 있습니다
이것보다 노드가 더 많습니다.

772
00:41:07,849 --> 00:41:10,130
내가 키가 더 컸더라면,
이 건설

773
00:41:10,130 --> 00:41:13,250
더 많이 건설할 것입니다
적어도 그만큼 큰 나무 한 그루.

774
00:41:13,250 --> 00:41:15,710
그는 애초에 그런 짓을 해서는 안 된다.
엄밀히 말하면 더 크다.

775
00:41:15,710 --> 00:41:18,139
그래서 당연히 Nh 마이너스 1입니다.
크거나 같음

776
00:41:18,139 --> 00:41:20,059
Nh 마이너스 2.

777
00:41:20,059 --> 00:41:24,230
이것은 Nh의 2배에서 2를 뺀 값입니다.

778
00:41:24,230 --> 00:41:25,710
그리고 따라하기 쉽습니다.

779
00:41:25,710 --> 00:41:27,920
그냥 2의 거듭제곱이에요.

780
00:41:27,920 --> 00:41:31,460
나는 계속해서 2를 곱하고 있다.
h에서 2를 뺍니다.

781
00:41:31,460 --> 00:41:35,150
그래서, 이것으로 해결됩니다.
2에서 h까지 2씩,

782
00:41:35,150 --> 00:41:37,880
바닥이나 그런 걸로 해결할 수도 있겠죠.

783
00:41:37,880 --> 00:41:43,490
하지만 저는 여기서 기본 사례를 사용하고 있습니다.
여기서 N<sub>0</sub>은 1과 같습니다.

784
00:41:46,186 --> 00:41:47,269
그렇다면 천장이 문제일지도 모르겠네요.

785
00:41:47,269 --> 00:41:49,380
하지만 문제는 바로 이것입니다.
기하급수적으로 증가합니다.

786
00:41:49,380 --> 00:41:53,809
그러니까, 이것은 높이를 의미합니다.
항상 최대 2배 더 높음

787
00:41:53,809 --> 00:41:55,730
로그 n.

788
00:41:55,730 --> 00:41:57,809
이 2는 이 2에 해당합니다.

789
00:41:57,809 --> 00:41:59,750
만약 당신이 그냥 돌아선다면
이 공식, 이

790
00:41:59,750 --> 00:42:04,500
노드 수
최소 2개는 있을 것입니다.

791
00:42:04,500 --> 00:42:05,599
h에 2를 더합니다.

792
00:42:05,599 --> 00:42:07,710
따라서 h는 최대 2 log n입니다.

793
00:42:07,710 --> 00:42:08,913
그러니까 log n이 아닙니다.

794
00:42:08,913 --> 00:42:09,829
그게 가장 이상적일 거예요.

795
00:42:09,829 --> 00:42:12,019
하지만 이는 허용 범위 내에 있습니다.
log n의 계수 2.

796
00:42:12,019 --> 00:42:15,509
따라서 AVL 트리
항상 상당히 균형 잡혀 있습니다.

797
00:42:15,510 --> 00:42:17,090
레벨 수
최대 두 배

798
00:42:17,090 --> 00:42:19,710
n개의 노드를 저장하는 데 필요한 양.

799
00:42:19,710 --> 00:42:20,210
훌륭한 U

800
00:42:23,980 --> 00:42:27,730
이제 우리에게 남은 것은 주요 마법입니다.

801
00:42:27,730 --> 00:42:28,780
영역 마법이 아닙니다.

802
00:42:28,780 --> 00:42:31,060
이건 다릅니다.

803
00:42:31,059 --> 00:42:34,179
자, 어디 보자, 우리는 갈 거야
서브트리 추가 기능을 사용합니다.

804
00:42:37,550 --> 00:42:38,150
이것 좀 잡고 있어.

805
00:42:45,510 --> 00:42:48,330
여전히 남아 있는 큰 문제는 다음과 같습니다.
이것이 우리가 하는 방식입니다

806
00:42:48,329 --> 00:42:51,239
우리는 이러한 고균형 속성을 지지합니다.
회전을 사용하시나요?  우리는 가지고 있습니다

807
00:42:51,239 --> 00:42:54,189
모든 재료가 다 있어요.
.  안에

808
00:42:54,190 --> 00:42:56,670
우리는 하위 트리의 확장을 가지고 있습니다.

809
00:42:56,670 --> 00:42:57,809
이것을 통해 저는 무엇을 할 수 있나요?

810
00:43:00,820 --> 00:43:02,710
이는 AVL 트리에 적용됩니다.

811
00:43:02,710 --> 00:43:06,880
덕분에 고도를 유지할 수 있죠.

812
00:43:06,880 --> 00:43:11,230
저는 계산할 수 있어야 합니다.
노드 높이.

813
00:43:11,230 --> 00:43:13,090
일반적으로 말하자면,
선형적인 시간이 걸립니다.

814
00:43:13,090 --> 00:43:15,173
제가 검토해야 하기 때문입니다
모든 하강 경로--

815
00:43:15,172 --> 00:43:16,659
모든 잎들
이 하위 트리에 있습니다.

816
00:43:16,659 --> 00:43:20,519
하지만 높이는...
하위 트리의 속성,

817
00:43:20,519 --> 00:43:27,469
네, 맞아요. 키요.

818
00:43:27,469 --> 00:43:28,919
왜

819
00:43:28,920 --> 00:43:33,670
왜냐하면... 제가
여기에 적어주세요.

820
00:43:33,670 --> 00:43:49,139
노드의 높이는 1 더하기입니다.
노드의 왼쪽 높이에서 최대값

821
00:43:49,139 --> 00:43:57,150
그리고 노드.오른쪽.높이
그리고 최대치부터.

822
00:43:57,150 --> 00:44:00,389
이걸 상자에 넣어둘게요.

823
00:44:00,389 --> 00:44:05,549
이 방정식, 또는 제가 가정하건대
이것은 할당 연산입니다.

824
00:44:05,550 --> 00:44:08,267
이것은 1입니다--

825
00:44:08,266 --> 00:44:10,099
이것이 바로 우리입니다
우리는 그것을 계속해서 반복합니다.

826
00:44:10,099 --> 00:44:11,659
내가 뭐라고 말했을 때
이 노드의 높이,

827
00:44:11,659 --> 00:44:12,889
당신은 그냥
이해하시죠, 그렇죠?

828
00:44:12,889 --> 00:44:14,494
당신은 높이를 가져갔습니다
왼쪽 하위 트리에 추가됨

829
00:44:14,494 --> 00:44:15,994
높이까지
오른쪽 서브트리,

830
00:44:15,994 --> 00:44:19,250
그리고 이를 고려하여 1을 더했습니다.
이 갈비뼈들.

831
00:44:19,250 --> 00:44:20,929
자, 이것이 바로
업데이트의 일반 규칙.

832
00:44:20,929 --> 00:44:23,539
그는 이에 답합니다.
하위 트리 속성 템플릿.

833
00:44:23,539 --> 00:44:25,279
내가 그 재산을 가지고 있다면
왼쪽과 오른쪽,

834
00:44:25,280 --> 00:44:27,800
저는 노드에 대해 이를 계산할 수 있습니다.

835
00:44:27,800 --> 00:44:29,570
이를 위해서는 다음이 필요합니다.
일정한 시간.

836
00:44:29,570 --> 00:44:30,900
그래서 이것은 서브트리의 속성입니다.

837
00:44:30,900 --> 00:44:33,387
이렇게 하면 각 노드의 높이를 일정하게 유지할 수 있습니다.
내가 취하는 모든 행동들

838
00:44:33,387 --> 00:44:34,429
.

839
00:44:34,429 --> 00:44:37,799
참고로, 매번
저는 실습 중입니다.

840
00:44:37,800 --> 00:44:41,180
저도 그렇게 해야 할 거예요
하위 트리 속성을 업데이트합니다.

841
00:44:41,179 --> 00:44:45,719
이 모서리를 회전시키면 A
변하지 않는다, B는 변하지 않는다.

842
00:44:45,719 --> 00:44:46,709
C는 변하지 않습니다.

843
00:44:46,710 --> 00:44:48,079
그건 좋은 일이죠.

844
00:44:48,079 --> 00:44:49,684
하지만 서브트리 x는 변경됩니다.

845
00:44:49,684 --> 00:44:50,840
이제 그는 y를 가지고 있습니다.

846
00:44:50,840 --> 00:44:52,320
이런 일은 전에는 없었습니다.

847
00:44:52,320 --> 00:44:56,620
그러므로 우리도 그렇게 해야 할 것입니다.
여기에서 확장 프로그램을 업데이트하세요.

848
00:44:56,619 --> 00:44:58,969
y에서.

849
00:44:58,969 --> 00:45:03,549
그리고 우리는 그렇게 해야 할 것입니다
x의 증가량을 업데이트합니다.

850
00:45:03,550 --> 00:45:04,940
그리고 마지막으로, 저희는
업데이트해야 합니다

851
00:45:04,940 --> 00:45:10,280
모든 것의 확장
x의 조상들.

852
00:45:10,280 --> 00:45:12,660
그러니까, 회전
로컬 변경

853
00:45:12,659 --> 00:45:13,909
일정한 수의 포인터.

854
00:45:13,909 --> 00:45:18,049
그래서 저는 보통 회전에 대해 생각합니다.
일정한 시간에 관해서 말하자면.

855
00:45:18,050 --> 00:45:20,835
하지만 결국 우리는
해야 할 것이다...

856
00:45:20,835 --> 00:45:22,085
이는 고정된 현지 시간입니다.

857
00:45:25,250 --> 00:45:35,719
하지만 업데이트가 필요할 것입니다.
h 조상들, 그래서

858
00:45:35,719 --> 00:45:39,161
모두를 지키기 위해... 모두를 지원하기 위해
저희가 추가한 내용은 최신 정보입니다.

859
00:45:39,161 --> 00:45:40,369
그건 나중에 처리할게요.

860
00:45:43,380 --> 00:45:44,250
좋아요, 좋습니다.

861
00:45:44,250 --> 00:45:45,916
이제 우리는 높이를 갖게 되었습니다.
모든 노드.

862
00:45:45,916 --> 00:45:50,860
우리는 왜곡도를 계산할 수 있습니다.
모든 노드, 좋습니다.  안에

863
00:45:50,860 --> 00:45:52,570
저희는 그러한 순환 근무 제도를 운영하고 있습니다.

864
00:45:52,570 --> 00:45:58,320
그리고 우리는 이것을 유지하고 싶습니다
높이 균형 속성.

865
00:45:58,320 --> 00:46:02,130
왼쪽 노드 높이 -- 왼쪽
각 노드의 오른쪽에는 --

866
00:46:02,130 --> 00:46:03,630
플러스 마이너스 1 또는 0과 같습니다.

867
00:46:06,210 --> 00:46:13,740
좋아요, 제가 여기서 그렇게 말했어요.
우리가 어딘가에 있을 때-

868
00:46:13,739 --> 00:46:15,364
그래서 유일한 것들은,
나무를 바꾸는 것들,

869
00:46:15,364 --> 00:46:17,629
이때 우리는 삽입합니다
또는 새 노드를 삭제합니다.

870
00:46:17,630 --> 00:46:20,210
그리고 우리는 어떻게
지금까지 다음과 같이 구현했습니다. —

871
00:46:20,210 --> 00:46:21,949
잎을 추가하거나 제거하세요.

872
00:46:21,949 --> 00:46:24,659
그래서 우리는 여전히 생각해야 합니다
추가 또는 삭제에 관하여

873
00:46:24,659 --> 00:46:25,159
잎.

874
00:46:25,159 --> 00:46:27,409
문제는 바로 그때입니다.
새로운 글자를 추가하겠습니다.

875
00:46:27,409 --> 00:46:31,319
이 나무는 아마도...
이전보다 더 높아졌습니다.

876
00:46:31,320 --> 00:46:35,269
따라서 여기에 있는 일부 노드는 다음과 같을 수 있습니다.
키가 불균형하다.

877
00:46:35,269 --> 00:46:37,219
하지만 높이가...
하위 트리의 속성,

878
00:46:37,219 --> 00:46:39,589
우리가 필요한 유일한 노드
이것을 확인해야 합니다

879
00:46:39,590 --> 00:46:42,329
이 조상 계보의 최상단에 있는 자들.

880
00:46:42,329 --> 00:46:44,900
그리고 그 수는 log n개밖에 되지 않습니다.
이제 높이는 log n과 같기 때문입니다.

881
00:46:44,900 --> 00:46:47,660
이것이 바로 우리가 방금 증명한 것입니다.
우리가 이 부동산을 소유하는 한.

882
00:46:47,659 --> 00:46:50,449
지금 우리는 그렇지 않습니다
저희는 이것을 가지고 있습니다.

883
00:46:50,449 --> 00:46:51,619
아마도 이 몇몇 노드일 겁니다.

884
00:46:51,619 --> 00:46:53,569
하지만 그건 훨씬 이전의 일이었어요.

885
00:46:53,570 --> 00:46:54,470
이것은 최대 log n입니다.

886
00:46:54,469 --> 00:46:58,250
지금 2 log n + 1입니다.
방금 노드를 하나 추가했기 때문입니다.

887
00:46:58,250 --> 00:47:00,920
제가 하고 싶은 것은 다음과 같습니다.
이것들을 모두 확인하세요

888
00:47:00,920 --> 00:47:04,309
조상 노드 순차적으로
아래에서 위로 찾아

889
00:47:04,309 --> 00:47:06,549
균형이 맞지 않는 것.

890
00:47:06,550 --> 00:47:15,710
그럼 가장 낮은 것부터 시작해 볼까요?
불균형 노드.

891
00:47:21,539 --> 00:47:24,860
저는 그걸 x라고 부를게요.

892
00:47:24,860 --> 00:47:28,370
자, 방금 삽입했으니
또는 한 장을 삭제했습니다.

893
00:47:28,369 --> 00:47:32,089
균형이 깨졌을 뿐입니다.
1로 나누면, 왜냐하면 우리는 단지

894
00:47:32,090 --> 00:47:33,590
높이를 변경했습니다.

895
00:47:33,590 --> 00:47:36,710
높이가 1만큼 증가했습니다.
높이가 1만큼 감소했습니다.

896
00:47:36,710 --> 00:47:40,730
그리고 우리의 모든 왜곡 이전에
플러스 마이너스 1 또는 0이었다.

897
00:47:40,730 --> 00:47:44,222
그래서 이제... 운이 없네요.
값이 플러스 마이너스 2와 같을 때.

898
00:47:44,222 --> 00:47:46,639
만약 그가 여전히 그곳에 있다면
이 범위는 모든 노드에 적용됩니다.

899
00:47:46,639 --> 00:47:47,509
우리는 행복합니다.

900
00:47:47,510 --> 00:47:51,080
하지만 이 범위를 벗어나면,
1번에만 있을 겁니다.

901
00:47:51,079 --> 00:47:58,549
그러니까, 이는 왜곡이
n에 2를 더하거나 빼는 것과 같습니다.

902
00:47:58,550 --> 00:48:01,910
그리고 다음과 같이 가정해 봅시다.
이것은 대칭에 의해 2입니다.

903
00:48:01,909 --> 00:48:06,097
제 이미지는...

904
00:48:06,097 --> 00:48:10,009
저는 그림을 그릴 거예요.
오른쪽으로 향하는 이중 화살표,

905
00:48:10,010 --> 00:48:18,590
이것이 ~의 하위 트리라고 말하려면
이 하위 트리에서 2번째입니다.

906
00:48:18,590 --> 00:48:21,320
네, 그건 안 좋은 상황이네요.
우리는 이 문제를 해결하고 싶습니다.

907
00:48:21,320 --> 00:48:25,265
가장 당연한 일은
이 땅을 되찾는 것이 우리의 목표입니다.

908
00:48:25,264 --> 00:48:26,389
그렇게 하면 될 테니까요...

909
00:48:29,030 --> 00:48:31,590
이 금액은 너무 높습니다.
이건 너무 낮습니다.

910
00:48:31,590 --> 00:48:33,410
자, 회전시키면 이렇게 됩니다.
1만큼 감소해야 합니다.

911
00:48:33,409 --> 00:48:34,549
그리고 이 값은 1만큼 증가해야 합니다.

912
00:48:34,550 --> 00:48:38,070
그리고 대부분의 경우 효과가 있습니다.

913
00:48:38,070 --> 00:48:45,200
따라서 첫 번째 경우는 y축으로 치우친 분포입니다.

914
00:48:45,199 --> 00:48:45,859
y는 무엇입니까?

915
00:48:45,860 --> 00:48:50,090
나는 그것이 되기를 원한다
x의 정확한 후손.

916
00:48:50,090 --> 00:48:54,260
양의 왜곡이 있으므로,
우리는 그 아이에게 맞는 아이가 있다는 것을 알고 있습니다.

917
00:48:54,260 --> 00:48:57,120
자, 이제, 그것은
가장 낮은 나쁜 매듭,

918
00:48:57,119 --> 00:48:58,769
우리는 y가 실제로 좋다는 것을 알고 있습니다.

919
00:48:58,769 --> 00:49:02,300
그는 오른손잡이거나 체격이 무거울 거예요.
또는 두 개의 서브트리

920
00:49:02,300 --> 00:49:04,820
높이가 같다 --
혹은 무겁게 남겨두거나.

921
00:49:04,820 --> 00:49:13,940
간단한 경우,
왜곡도 y가

922
00:49:13,940 --> 00:49:22,720
1 또는 0과 같습니다.
무엇을 그릴까요?

923
00:49:29,980 --> 00:49:34,630
그러니까, 오른쪽으로 양방향 화살표를 누르세요.
오른쪽 화살표 하나만 있다고 가정해 봅시다.

924
00:49:40,429 --> 00:49:44,019
그래서 저는 그냥
여기에 태그를 몇 개 추가할게요.

925
00:49:44,019 --> 00:49:48,561
이것을 하기 위해
그림은 일관성이 있습니다.

926
00:49:48,561 --> 00:49:51,210
k+1, k+2.

927
00:49:51,210 --> 00:49:52,769
나는 정상으로 갈 거야.

928
00:49:52,769 --> 00:49:56,009
자, 이것이 한 예입니다.
C가 더 높은 경우

929
00:49:56,010 --> 00:49:58,947
B에 의해. A와 B는 가지고 있다.
높이가 같습니다.

930
00:49:58,947 --> 00:50:00,780
그리고 나서 계산해 보면
높이,

931
00:50:00,780 --> 00:50:03,480
그게 사실인가요?
기울기가 적절합니다.

932
00:50:03,480 --> 00:50:05,219
이것은 두 배입니다
오른쪽 경사면.

933
00:50:05,219 --> 00:50:06,849
왜냐하면 이것은
높이는 k+1입니다.

934
00:50:06,849 --> 00:50:08,099
이것의 높이는 k 마이너스 1입니다.

935
00:50:08,099 --> 00:50:08,889
이건 안 좋은 일이야.

936
00:50:08,889 --> 00:50:11,369
하지만 우리가 이렇게 한다면
x축을 기준으로 올바른 회전,

937
00:50:11,369 --> 00:50:14,099
우리는 우리가 원하는 것을 정확히 얻을 것이다.

938
00:50:18,010 --> 00:50:20,940
그럼 복사할게요.
A, B, C에 라벨을 붙이면--

939
00:50:20,940 --> 00:50:23,760
우리 중 k에서 1을 뺀 수가 있습니다.
k 마이너스 1과 k--

940
00:50:23,760 --> 00:50:24,630
그러고 나서 제가 세어볼게요.

941
00:50:24,630 --> 00:50:26,400
이것은 다음을 의미합니다.
그 소년의 키는 k입니다.

942
00:50:26,400 --> 00:50:29,039
이것의 높이는 k+1입니다.

943
00:50:29,039 --> 00:50:31,652
그리고 이제 여기에 있는 모든 노드
제가 강조 표시한 사진들-

944
00:50:31,652 --> 00:50:32,819
A, B, C는 변하지 않았습니다.  더 일찍

945
00:50:32,820 --> 00:50:34,195
그들은
높이가 균형 잡혀 있습니다.

946
00:50:34,195 --> 00:50:35,400
그들은 여전히 ​​거기에 있습니다.

947
00:50:35,400 --> 00:50:36,720
하지만 이제 x와 y는...

948
00:50:36,719 --> 00:50:39,029
x는 이전에는 거기에 없었습니다.
높이와 y가 균형을 이룹니다.

949
00:50:39,030 --> 00:50:42,420
이제 x와 y 모두
높이가 균형 잡혀 있습니다.

950
00:50:42,420 --> 00:50:44,159
이것이 첫 번째 사례입니다.

951
00:50:44,159 --> 00:50:49,389
두 번째 경우에는
y축 왜곡은 평평합니다.

952
00:50:49,389 --> 00:50:54,869
즉,
이것이 k이고, 이것도 k입니다.

953
00:50:54,869 --> 00:50:58,569
그리고 이것은 k 더하기 1입니다.
그리고 이것은 k 더하기 2입니다.

954
00:50:58,570 --> 00:51:00,742
하지만 여전히 모든 사람들
노드 균형이 맞춰져 있습니다.

955
00:51:00,742 --> 00:51:01,409
높이가 균형 잡혀 있습니다.

956
00:51:01,409 --> 00:51:03,089
여전히 플러스 마이너스 1입니다.

957
00:51:03,090 --> 00:51:04,440
이것들은 간단한 경우입니다.

958
00:51:04,440 --> 00:51:07,240
안타깝게도,
어려운 사건이 있습니다.

959
00:51:07,239 --> 00:51:08,279
세 번째 사례.

960
00:51:08,280 --> 00:51:11,280
하지만 오직 하나뿐이며,
그다지 복잡하지 않아요.

961
00:51:16,320 --> 00:51:21,780
그래서, 왜곡이 있을 때
y는 -1과 같습니다.

962
00:51:21,780 --> 00:51:24,750
이 경우에는 다음이 필요합니다.
y의 왼쪽 자식을 보세요.

963
00:51:28,590 --> 00:51:31,829
그리고 알파벳 순서대로 나열하자면, 저는
이름을 z로 바꾸겠습니다.

964
00:51:34,469 --> 00:51:36,779
자, 또 이러네요.
오른쪽으로 향하는 양방향 화살표.

965
00:51:36,780 --> 00:51:39,540
이것은 이제 왼쪽 화살표입니다.

966
00:51:39,539 --> 00:51:41,909
그리고 이것이 바로 알파벳 y입니다.

967
00:51:41,909 --> 00:51:49,949
그래서 우리는 잠재적인 하위 트리 A, B, C, D를 갖게 됩니다.
교수형

968
00:51:49,949 --> 00:51:50,549
그들 중 일부.

969
00:51:50,550 --> 00:51:54,310
그리고 저는 표시할 거예요
이것들의 높이.

970
00:51:54,309 --> 00:51:59,009
이것은 k입니다
마이너스 1 또는 k 마이너스 2.

971
00:51:59,010 --> 00:52:00,420
이것은 k 마이너스 1입니다.

972
00:52:00,420 --> 00:52:01,769
이제 내재 가치를 계산해 보세요.

973
00:52:01,769 --> 00:52:06,690
따라서 이것이 높이 k가 됩니다.
그래서 왼쪽으로 기울어져 있습니다.

974
00:52:06,690 --> 00:52:11,519
이것은 k 더하기 1입니다.
그리고 이것은 k 더하기 2입니다.

975
00:52:11,519 --> 00:52:13,679
하지만 문제는 그것이 켜져 있다는 것입니다.
그것보다 2개 더 많습니다.

976
00:52:13,679 --> 00:52:17,369
높이 z는 2만큼 더 높습니다.
높이 A의 경우.

977
00:52:17,369 --> 00:52:18,989
이 경우, 만약 내가
저는 이 순환 근무를 하고 있어요.

978
00:52:18,989 --> 00:52:20,909
사실 상황은 점점 악화되고 있습니다.

979
00:52:20,909 --> 00:52:26,609
제가 말씀드리겠습니다
무엇이 옳은 일인가 -

980
00:52:26,610 --> 00:52:28,650
이것이 바로
기억해야 할 것이 있습니다.

981
00:52:41,699 --> 00:52:43,859
그럼 제가 결과를 그려보겠습니다.

982
00:52:43,860 --> 00:52:47,300
다음 사항도 고려해 보시면 좋을 것 같습니다.
트리 구조를 이런 식으로 다시 그려보는 건 어때요?

983
00:52:47,300 --> 00:52:49,940
하지만 ~와 함께
분석 관점에서 더 쉽습니다.

984
00:52:49,940 --> 00:52:51,679
이것을 고려해 보세요
두 바퀴 회전과 같습니다.

985
00:52:51,679 --> 00:52:52,940
그럼 줄이면 되죠.

986
00:52:52,940 --> 00:52:54,800
우리가 아는 한,
회전은 어떻게 작동하는가,

987
00:52:54,800 --> 00:52:56,460
우리는 그것을 알고 있습니다
이거 제대로 작동하네요.

988
00:52:56,460 --> 00:52:59,059
즉, "작품"이라는 뜻입니다.
순회 순서를 유지합니다.

989
00:52:59,059 --> 00:53:01,159
그리고 우리는 지원할 수 있습니다
모든 추가 사항.

990
00:53:01,159 --> 00:53:04,339
그래서 제가 이것들을 복사하면
라벨-- 고도 라벨--

991
00:53:04,340 --> 00:53:05,390
저는 k 마이너스 1을 가지고 있습니다.

992
00:53:05,389 --> 00:53:08,599
저는 이 두 소년을 위해,
k 마이너스 1 또는 k 마이너스 2.

993
00:53:08,599 --> 00:53:11,099
그중 가장 큰 것은 k 마이너스 1입니다.

994
00:53:11,099 --> 00:53:13,190
이것은 k 마이너스 1입니다.

995
00:53:13,190 --> 00:53:15,409
그래서 이것은 k가 될 것입니다.

996
00:53:15,409 --> 00:53:17,449
이것은 k가 될 것입니다.

997
00:53:17,449 --> 00:53:19,069
이것은 k에 1을 더한 값이 될 것입니다.

998
00:53:19,070 --> 00:53:22,490
그리고 지금 우리는
아름답고 균형 잡힌 높이의 나무

999
00:53:22,489 --> 00:53:25,759
세 가지 경우 모두
이 노드 하나에 대해서만 그렇습니다.

1000
00:53:25,760 --> 00:53:27,020
이제 그것은 가장 낮은 매듭이었다.

1001
00:53:27,019 --> 00:53:28,880
업데이트되는 대로 바로 알려드리겠습니다.
이것,

1002
00:53:28,880 --> 00:53:32,090
어쩌면 우리가 변했을지도 몰라요
뿌리 높이.

1003
00:53:32,090 --> 00:53:35,750
예전에는 K 플러스였어요.
2, 이제 k+1입니다.

1004
00:53:35,750 --> 00:53:39,483
혹은 때로는 그대로 두기도 합니다.
이 경우처럼, 그들 스스로가 그렇습니다.

1005
00:53:39,483 --> 00:53:41,150
그러므로 이제 우리는 반드시
부모를 확인하세요.

1006
00:53:41,150 --> 00:53:42,740
어쩌면 아버지일지도
균형이 맞지 않습니다.

1007
00:53:42,739 --> 00:53:44,719
그리고 우리는 계속 나아갑니다.
노드를 따라 이동합니다.

1008
00:53:44,719 --> 00:53:47,659
그리고 저희는 모든 것을 지원합니다.
진행 과정에서 추가된 사항들.

1009
00:53:47,659 --> 00:53:49,789
그럼 추적하겠습니다.
서브트리의 높이와 크기

1010
00:53:49,789 --> 00:53:51,980
우리가 원한다면, 또는 누구든지
기타 확장 기능.

1011
00:53:51,980 --> 00:53:54,425
그리고 h 순서의 작업 후에
우리

1012
00:53:54,425 --> 00:53:56,300
우리는 복원될 것입니다
높이 균형의 속성은 다음과 같습니다.

1013
00:53:56,300 --> 00:53:59,280
즉, 모든 길을 의미합니다.
h는 log n의 차수입니다.

1014
00:53:59,280 --> 00:54:03,250
그래서 우리의 모든 운영은 바로 그런 이유로 이루어지는 것입니다.
이제 마법처럼 저널 n에 정리되었습니다.

