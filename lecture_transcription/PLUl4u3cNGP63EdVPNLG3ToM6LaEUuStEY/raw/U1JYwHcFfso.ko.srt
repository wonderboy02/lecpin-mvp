1
00:00:12,519 --> 00:00:14,629

자, 다시 자료

2
00:00:14,629 --> 00:00:14,639
자, 다시 자료
 

3
00:00:14,639 --> 00:00:18,429
자, 다시 자료
구조의 세계에 오신 것을 환영합니다. 오늘은

4
00:00:18,429 --> 00:00:18,439
구조의 세계에 오신 것을 환영합니다. 오늘은
 

5
00:00:18,439 --> 00:00:21,390
구조의 세계에 오신 것을 환영합니다. 오늘은
이진 트리에 대한 부분을 계속해서 마무리해 보겠습니다.

6
00:00:21,390 --> 00:00:21,400
이진 트리에 대한 부분을 계속해서 마무리해 보겠습니다.
 

7
00:00:21,400 --> 00:00:23,870
이진 트리에 대한 부분을 계속해서 마무리해 보겠습니다.
1부를 놓치셨다면

8
00:00:23,870 --> 00:00:23,880
1부를 놓치셨다면
 

9
00:00:23,880 --> 00:00:26,790
1부를 놓치셨다면
1부를 다시 시청해 주세요. 지난번에는

10
00:00:26,790 --> 00:00:26,800
1부를 다시 시청해 주세요. 지난번에는
 

11
00:00:26,800 --> 00:00:30,349
1부를 다시 시청해 주세요. 지난번에는
이진 트리에 대해 전반적으로 이야기했습니다.

12
00:00:30,349 --> 00:00:30,359
이진 트리에 대해 전반적으로 이야기했습니다.
 

13
00:00:30,359 --> 00:00:35,069
이진 트리에 대해 전반적으로 이야기했습니다.
각 노드는 항목

14
00:00:35,069 --> 00:00:35,079
각 노드는 항목
 

15
00:00:35,079 --> 00:00:37,190
각 노드는 항목
과 다른 노드를 가리키는 왼쪽 포인터와

16
00:00:37,190 --> 00:00:37,200
과 다른 노드를 가리키는 왼쪽 포인터와
 

17
00:00:37,200 --> 00:00:38,790
과 다른 노드를 가리키는 왼쪽 포인터와
오른쪽 포인터, 그리고

18
00:00:38,790 --> 00:00:38,800
오른쪽 포인터, 그리고
 

19
00:00:38,800 --> 00:00:41,549
오른쪽 포인터, 그리고
다른 노드를 가리키는 부모 포인터를 저장한다고 했습니다. 이것은

20
00:00:41,549 --> 00:00:41,559
다른 노드를 가리키는 부모 포인터를 저장한다고 했습니다. 이것은
 

21
00:00:41,559 --> 00:00:45,270
다른 노드를 가리키는 부모 포인터를 저장한다고 했습니다. 이것은
트리의 예시로, A의 자식 노드인 B와 C가 있습니다.

22
00:00:45,270 --> 00:00:45,280
트리의 예시로, A의 자식 노드인 B와 C가 있습니다.
 

23
00:00:45,280 --> 00:00:48,310
트리의 예시로, A의 자식 노드인 B와 C가 있습니다.
A는 B와 C의 부모 노드이자

24
00:00:48,310 --> 00:00:48,320
A는 B와 C의 부모 노드이자
 

25
00:00:48,320 --> 00:00:50,430
A는 B와 C의 부모 노드이자
전체 트리의 루트 노드입니다. 우리는

26
00:00:50,430 --> 00:00:50,440
전체 트리의 루트 노드입니다. 우리는
 

27
00:00:50,440 --> 00:00:52,110
전체 트리의 루트 노드입니다. 우리는
노드의 높이를 정의했습니다.

28
00:00:52,110 --> 00:00:52,120
노드의 높이를 정의했습니다.
 

29
00:00:52,120 --> 00:00:53,549
노드의 높이를 정의했습니다.
아직 많이 사용하지는 않았지만

30
00:00:53,549 --> 00:00:53,559
아직 많이 사용하지는 않았지만
 

31
00:00:53,559 --> 00:00:55,349
아직 많이 사용하지는 않았지만
오늘 많이 사용하게 될 것입니다.

32
00:00:55,349 --> 00:00:55,359
오늘 많이 사용하게 될 것입니다.
 

33
00:00:55,359 --> 00:00:58,590
오늘 많이 사용하게 될 것입니다.
높이는 여기 빨간색으로 표시된 것처럼,

34
00:00:58,590 --> 00:00:58,600
높이는 여기 빨간색으로 표시된 것처럼,
 

35
00:00:58,600 --> 00:01:01,430
높이는 여기 빨간색으로 표시된 것처럼,
노드의 높이는 가장 긴

36
00:01:01,430 --> 00:01:01,440
노드의 높이는 가장 긴
 

37
00:01:01,440 --> 00:01:03,869
노드의 높이는 가장 긴
하향 경로의 길이(간선 수 포함)입니다.

38
00:01:03,869 --> 00:01:03,879
하향 경로의 길이(간선 수 포함)입니다.
 

39
00:01:03,879 --> 00:01:05,710
하향 경로의 길이(간선 수 포함)입니다.
예를 들어 B의 경로 길이는 2이므로

40
00:01:05,710 --> 00:01:05,720
예를 들어 B의 경로 길이는 2이므로
 

41
00:01:05,720 --> 00:01:07,830
예를 들어 B의 경로 길이는 2이므로
여기에 2라고 씁니다. B를 루트로

42
00:01:07,830 --> 00:01:11,270
여기에 2라고 씁니다. B를 루트로
 

43
00:01:11,270 --> 00:01:11,280

 

44
00:01:11,280 --> 00:01:15,789

하는 서브트리, 즉 B의 서브트리 내에서만 생각할 수도 있습니다. 그렇다면 이 서브트리에 있는

45
00:01:15,789 --> 00:01:15,799
하는 서브트리, 즉 B의 서브트리 내에서만 생각할 수도 있습니다. 그렇다면 이 서브트리에 있는
 

46
00:01:15,799 --> 00:01:17,789
하는 서브트리, 즉 B의 서브트리 내에서만 생각할 수도 있습니다. 그렇다면 이 서브트리에 있는
노드들의 최대 깊이는 얼마일까요?

47
00:01:17,789 --> 00:01:19,190
노드들의 최대 깊이는 얼마일까요?
 

48
00:01:19,190 --> 00:01:19,200

 

49
00:01:19,200 --> 00:01:21,510

어느 쪽이든 괜찮습니다. 특히,

50
00:01:21,510 --> 00:01:21,520
어느 쪽이든 괜찮습니다. 특히,
 

51
00:01:21,520 --> 00:01:24,109
어느 쪽이든 괜찮습니다. 특히,
우리는 루트 노드의 높이를 H로 구분했습니다.

52
00:01:24,109 --> 00:01:24,119
우리는 루트 노드의 높이를 H로 구분했습니다.
 

53
00:01:24,119 --> 00:01:26,310
우리는 루트 노드의 높이를 H로 구분했습니다.
전체 트리의 높이

54
00:01:26,310 --> 00:01:26,320
전체 트리의 높이
 

55
00:01:26,320 --> 00:01:28,830
전체 트리의 높이
와 지난번에 우리가 달성한 것은

56
00:01:28,830 --> 00:01:28,840
와 지난번에 우리가 달성한 것은
 

57
00:01:28,840 --> 00:01:31,069
와 지난번에 우리가 달성한 것은
기본적으로 모든 연산이

58
00:01:31,069 --> 00:01:31,079
기본적으로 모든 연산이
 

59
00:01:31,079 --> 00:01:35,630
기본적으로 모든 연산이
H 시간 안에 실행되었다는 것입니다. 즉, 서브트리 삽입,

60
00:01:35,630 --> 00:01:35,640
H 시간 안에 실행되었다는 것입니다. 즉, 서브트리 삽입,
 

61
00:01:35,640 --> 00:01:38,270
H 시간 안에 실행되었다는 것입니다. 즉, 서브트리 삽입,
서브트리 삭제, 그리고 마지막으로

62
00:01:38,270 --> 00:01:39,590
서브트리 삭제, 그리고 마지막으로
 

63
00:01:39,590 --> 00:01:39,600

 

64
00:01:39,600 --> 00:01:42,630

노드의 선행 노드와 후행 노드를 모두 H 시간 안에 계산할 수 있었습니다.

65
00:01:42,630 --> 00:01:42,640
노드의 선행 노드와 후행 노드를 모두 H 시간 안에 계산할 수 있었습니다.
 

66
00:01:42,640 --> 00:01:46,990
노드의 선행 노드와 후행 노드를 모두 H 시간 안에 계산할 수 있었습니다.
따라서 H가 작을 때는

67
00:01:46,990 --> 00:01:47,000
따라서 H가 작을 때는
 

68
00:01:47,000 --> 00:01:49,030
따라서 H가 작을 때는
만족스러웠습니다.

69
00:01:49,030 --> 00:01:49,040
만족스러웠습니다.
 

70
00:01:49,040 --> 00:01:50,910
만족스러웠습니다.
선행 노드와 후행 노드가 무엇을 의미하는지 기억하시나요? 이는

71
00:01:50,910 --> 00:01:53,230
선행 노드와 후행 노드가 무엇을 의미하는지 기억하시나요? 이는
 

72
00:01:53,230 --> 00:01:53,240

 

73
00:01:53,240 --> 00:01:55,550

트리의 암묵적인 순서, 즉 순회

74
00:01:55,550 --> 00:01:55,560
트리의 암묵적인 순서, 즉 순회
 

75
00:01:55,560 --> 00:01:58,550
트리의 암묵적인 순서, 즉 순회
순서를 나타냅니다. 순회 순서는 재귀적으로 다음과 같이 정의됩니다.

76
00:01:58,550 --> 00:01:58,560
순서를 나타냅니다. 순회 순서는 재귀적으로 다음과 같이 정의됩니다.
 

77
00:01:58,560 --> 00:02:01,350
순서를 나타냅니다. 순회 순서는 재귀적으로 다음과 같이 정의됩니다.
왼쪽 서브트리를 순회하고

78
00:02:01,350 --> 00:02:01,360
왼쪽 서브트리를 순회하고
 

79
00:02:01,360 --> 00:02:03,190
왼쪽 서브트리를 순회하고
루트를 출력한 다음,

80
00:02:03,190 --> 00:02:03,200
루트를 출력한 다음,
 

81
00:02:03,200 --> 00:02:05,950
루트를 출력한 다음,
오른쪽 서브트리를 재귀적으로 순회합니다. 이

82
00:02:05,950 --> 00:02:05,960
오른쪽 서브트리를 재귀적으로 순회합니다. 이
 

83
00:02:05,960 --> 00:02:10,510
오른쪽 서브트리를 재귀적으로 순회합니다. 이
예에서 순회 순서는 f입니다.

84
00:02:10,510 --> 00:02:10,520
예에서 순회 순서는 f입니다.
 

85
00:02:10,520 --> 00:02:12,630
예에서 순회 순서는 f입니다.
왼쪽 끝까지 가면 f가

86
00:02:12,630 --> 00:02:12,640
왼쪽 끝까지 가면 f가
 

87
00:02:12,640 --> 00:02:15,910
왼쪽 끝까지 가면 f가
첫 번째 노드입니다. 그다음

88
00:02:15,910 --> 00:02:19,589
첫 번째 노드입니다. 그다음
 

89
00:02:19,589 --> 00:02:22,910

 

90
00:02:22,910 --> 00:02:25,750

 

91
00:02:25,750 --> 00:02:26,670

 

92
00:02:26,670 --> 00:02:30,229

 

93
00:02:30,229 --> 00:02:30,239

 

94
00:02:30,239 --> 00:02:32,229

오른쪽 서브트리(여기에 공간을 확보하기 위해)가 있고, D, B, B의 오른쪽 서브트리(e)를 순회한 다음 루트(

95
00:02:32,229 --> 00:02:32,239
오른쪽 서브트리(여기에 공간을 확보하기 위해)가 있고, D, B, B의 오른쪽 서브트리(e)를 순회한 다음 루트(
 

96
00:02:32,239 --> 00:02:36,030
오른쪽 서브트리(여기에 공간을 확보하기 위해)가 있고, D, B, B의 오른쪽 서브트리(e)를 순회한 다음 루트(
a)가 있습니다. 마지막으로

97
00:02:36,030 --> 00:02:36,040
a)가 있습니다. 마지막으로
 

98
00:02:36,040 --> 00:02:38,589
a)가 있습니다. 마지막으로
C가 있습니다. 이처럼

99
00:02:38,589 --> 00:02:38,599
C가 있습니다. 이처럼
 

100
00:02:38,599 --> 00:02:41,509
C가 있습니다. 이처럼
트리에는 암묵적인 선형 순서가 인코딩되어 있으며,

101
00:02:41,509 --> 00:02:41,519
트리에는 암묵적인 선형 순서가 인코딩되어 있으며,
 

102
00:02:41,519 --> 00:02:43,430
트리에는 암묵적인 선형 순서가 인코딩되어 있으며,
이진 트리의 핵심은

103
00:02:43,430 --> 00:02:43,440
이진 트리의 핵심은
 

104
00:02:43,440 --> 00:02:45,869
이진 트리의 핵심은
트리를 효율적으로 업데이트할 수 있다는 것입니다.  어, 배열이나 그런 것에 순서를

105
00:02:45,869 --> 00:02:45,879
트리를 효율적으로 업데이트할 수 있다는 것입니다.  어, 배열이나 그런 것에 순서를
 

106
00:02:45,879 --> 00:02:47,869
트리를 효율적으로 업데이트할 수 있다는 것입니다.  어, 배열이나 그런 것에 순서를
명시적으로 적어두는 것보다 훨씬 빠르죠.

107
00:02:47,869 --> 00:02:49,550
명시적으로 적어두는 것보다 훨씬 빠르죠.
 

108
00:02:49,550 --> 00:02:49,560

 

109
00:02:49,560 --> 00:02:53,470

이진 트리는 이런 작업을 빠르게 처리할 수 있게 해줍니다. 하지만 지금은

110
00:02:53,470 --> 00:02:55,550
이진 트리는 이런 작업을 빠르게 처리할 수 있게 해줍니다. 하지만 지금은
 

111
00:02:55,550 --> 00:02:55,560

 

112
00:02:55,560 --> 00:02:57,350

모든 연산이 시간 복잡도 H를 가지기 때문에 그렇게 빠르다고 할 수는 없습니다.

113
00:02:57,350 --> 00:02:57,360
모든 연산이 시간 복잡도 H를 가지기 때문에 그렇게 빠르다고 할 수는 없습니다.
 

114
00:02:57,360 --> 00:02:59,190
모든 연산이 시간 복잡도 H를 가지기 때문에 그렇게 빠르다고 할 수는 없습니다.
최악의 경우 H는 선형 시간 복잡도입니다. 예를 들어 이런

115
00:02:59,190 --> 00:02:59,200
최악의 경우 H는 선형 시간 복잡도입니다. 예를 들어 이런
 

116
00:02:59,200 --> 00:03:02,270
최악의 경우 H는 선형 시간 복잡도입니다. 예를 들어 이런
트리를 만들 수도 있죠.

117
00:03:02,270 --> 00:03:02,280

 

118
00:03:02,280 --> 00:03:04,910

하지만 오늘은

119
00:03:04,910 --> 00:03:04,920
하지만 오늘은
 

120
00:03:04,920 --> 00:03:07,630
하지만 오늘은
H가 log n이 되도록 보장할 겁니다.

121
00:03:07,630 --> 00:03:07,640
H가 log n이 되도록 보장할 겁니다.
 

122
00:03:07,640 --> 00:03:09,430
H가 log n이 되도록 보장할 겁니다.
따라서 오늘의 목표는 시간 복잡도 H를 가지는 모든

123
00:03:09,430 --> 00:03:09,440
따라서 오늘의 목표는 시간 복잡도 H를 가지는 모든
 

124
00:03:09,440 --> 00:03:11,509
따라서 오늘의 목표는 시간 복잡도 H를 가지는 모든
연산을 시간 복잡도

125
00:03:11,509 --> 00:03:11,519
연산을 시간 복잡도
 

126
00:03:11,519 --> 00:03:13,910
연산을 시간 복잡도
log n으로 줄이는 것입니다.

127
00:03:13,910 --> 00:03:15,309
log n으로 줄이는 것입니다.
 

128
00:03:15,309 --> 00:03:15,319

 

129
00:03:15,319 --> 00:03:16,630

이미 살펴본 자료 구조를 수정하는 것만으로 말이죠.

130
00:03:16,630 --> 00:03:16,640
이미 살펴본 자료 구조를 수정하는 것만으로 말이죠.
 

131
00:03:16,640 --> 00:03:18,229
이미 살펴본 자료 구조를 수정하는 것만으로 말이죠.
어려운 작업은 대부분 끝냈고,

132
00:03:18,229 --> 00:03:18,239
어려운 작업은 대부분 끝냈고,
 

133
00:03:18,239 --> 00:03:20,270
어려운 작업은 대부분 끝냈고,
오늘은

134
00:03:20,270 --> 00:03:20,280
오늘은
 

135
00:03:20,280 --> 00:03:24,190
오늘은
AVL 트리(높이 균형 트리)라고 하는 부분에서 조금 더 작업해야 합니다.

136
00:03:24,190 --> 00:03:24,200
AVL 트리(높이 균형 트리)라고 하는 부분에서 조금 더 작업해야 합니다.
 

137
00:03:24,200 --> 00:03:26,910
AVL 트리(높이 균형 트리)라고 하는 부분에서 조금 더 작업해야 합니다.
하지만 그 전에

138
00:03:26,910 --> 00:03:28,869
하지만 그 전에
 

139
00:03:28,869 --> 00:03:28,879

 

140
00:03:28,879 --> 00:03:30,990

지난 수업 마지막에 이야기했던 부분

141
00:03:30,990 --> 00:03:31,000
지난 수업 마지막에 이야기했던 부분
 

142
00:03:31,000 --> 00:03:32,830
지난 수업 마지막에 이야기했던 부분
트리 연산,

143
00:03:32,830 --> 00:03:32,840
트리 연산,
 

144
00:03:32,840 --> 00:03:35,470
트리 연산,
즉 부분 트리에 삽입하고 삭제하는 연산에 대해 좀 더 자세히 이야기하고 싶습니다. 그런데 이 연산을

145
00:03:35,470 --> 00:03:35,480
즉 부분 트리에 삽입하고 삭제하는 연산에 대해 좀 더 자세히 이야기하고 싶습니다. 그런데 이 연산을
 

146
00:03:35,480 --> 00:03:37,550
즉 부분 트리에 삽입하고 삭제하는 연산에 대해 좀 더 자세히 이야기하고 싶습니다. 그런데 이 연산을
어떻게 활용해서

147
00:03:37,550 --> 00:03:37,560
어떻게 활용해서
 

148
00:03:37,560 --> 00:03:39,149
어떻게 활용해서
이번 수업에서 다루는

149
00:03:39,149 --> 00:03:39,159
이번 수업에서 다루는
 

150
00:03:39,159 --> 00:03:41,070
이번 수업에서 다루는
순회 구조

151
00:03:41,070 --> 00:03:41,080
순회 구조
 

152
00:03:41,080 --> 00:03:45,470
순회 구조
와 집합 구조 문제를 해결할 수 있을까요?

153
00:03:45,470 --> 00:03:45,480
와 집합 구조 문제를 해결할 수 있을까요?
 

154
00:03:45,480 --> 00:03:47,350
와 집합 구조 문제를 해결할 수 있을까요?
지난번에는 주로 집합 구조에 대해 이야기했습니다.

155
00:03:47,350 --> 00:03:47,360
지난번에는 주로 집합 구조에 대해 이야기했습니다.
 

156
00:03:47,360 --> 00:03:49,350
지난번에는 주로 집합 구조에 대해 이야기했습니다.
일반적으로

157
00:03:49,350 --> 00:03:49,360
일반적으로
 

158
00:03:49,360 --> 00:03:52,509
일반적으로
순회 순서를 정의하고, 그 순서를 다음과 같이 설정합니다.

159
00:03:52,509 --> 00:03:52,519
순회 순서를 정의하고, 그 순서를 다음과 같이 설정합니다.
 

160
00:03:52,519 --> 00:03:57,190
순회 순서를 정의하고, 그 순서를 다음과 같이 설정합니다.
이진 트리를 사용하면

161
00:03:57,190 --> 00:03:57,200
이진 트리를 사용하면
 

162
00:03:57,200 --> 00:03:58,830
이진 트리를 사용하면
집합 인터페이스를 구현할 수 있습니다. 예를 들어, 주어진 키를 사용하여

163
00:03:58,830 --> 00:04:00,229
집합 인터페이스를 구현할 수 있습니다. 예를 들어, 주어진 키를 사용하여
 

164
00:04:00,229 --> 00:04:00,239

 

165
00:04:00,239 --> 00:04:02,030

다음 항목

166
00:04:02,030 --> 00:04:04,630
다음 항목
 

167
00:04:04,630 --> 00:04:04,640

 

168
00:04:04,640 --> 00:04:06,309

이나 이전 항목을 찾는 쿼리를 수행할 수 있습니다. 해당 키가 없으면 이전 항목을, 다음 항목을 찾으면 해당 값을 반환합니다.

169
00:04:06,309 --> 00:04:06,319
이나 이전 항목을 찾는 쿼리를 수행할 수 있습니다. 해당 키가 없으면 이전 항목을, 다음 항목을 찾으면 해당 값을 반환합니다.
 

170
00:04:06,319 --> 00:04:07,350
이나 이전 항목을 찾는 쿼리를 수행할 수 있습니다. 해당 키가 없으면 이전 항목을, 다음 항목을 찾으면 해당 값을 반환합니다.
이는

171
00:04:07,350 --> 00:04:07,360
이는
 

172
00:04:07,360 --> 00:04:10,589
이는
이진 검색을 통해 가능합니다.

173
00:04:10,589 --> 00:04:10,599
이진 검색을 통해 가능합니다.
 

174
00:04:10,599 --> 00:04:12,910
이진 검색을 통해 가능합니다.
이진 트리의 가장 큰 장점은

175
00:04:12,910 --> 00:04:12,920
이진 트리의 가장 큰 장점은
 

176
00:04:12,920 --> 00:04:15,589
이진 트리의 가장 큰 장점은
모든

177
00:04:15,589 --> 00:04:15,599
모든
 

178
00:04:15,599 --> 00:04:17,430
모든
항목을 키 순서대로 오름차순으로 정렬하여 순회하면, 명시적으로

179
00:04:17,430 --> 00:04:19,469
항목을 키 순서대로 오름차순으로 정렬하여 순회하면, 명시적으로
 

180
00:04:19,469 --> 00:04:22,110

 

181
00:04:22,110 --> 00:04:24,670

 

182
00:04:24,670 --> 00:04:26,189

 

183
00:04:26,189 --> 00:04:26,199

 

184
00:04:26,199 --> 00:04:28,590

순서를 유지하는 것이 아니라 트리 구조를 통해 키

185
00:04:28,590 --> 00:04:30,390
순서를 유지하는 것이 아니라 트리 구조를 통해 키
 

186
00:04:30,390 --> 00:04:30,400

 

187
00:04:30,400 --> 00:04:33,870

순서대로 항목을 나타내는 것입니다. 이를 통해

188
00:04:33,870 --> 00:04:33,880
순서대로 항목을 나타내는 것입니다. 이를 통해
 

189
00:04:33,880 --> 00:04:37,870
순서대로 항목을 나타내는 것입니다. 이를 통해
부분 트리 탐색 연산을 수행할 수 있으며, 이를 이용하여 다음 항목

190
00:04:37,870 --> 00:04:37,880
부분 트리 탐색 연산을 수행할 수 있으며, 이를 이용하여 다음 항목
 

191
00:04:37,880 --> 00:04:40,110
부분 트리 탐색 연산을 수행할 수 있으며, 이를 이용하여 다음 항목
찾기, 이전 항목 찾기 등을 쉽게 구현할 수 있습니다.

192
00:04:40,110 --> 00:04:42,830
찾기, 이전 항목 찾기 등을 쉽게 구현할 수 있습니다.
 

193
00:04:42,830 --> 00:04:45,990

 

194
00:04:45,990 --> 00:04:47,830

 

195
00:04:47,830 --> 00:04:47,840

 

196
00:04:47,840 --> 00:04:50,029

먼저 트리의 루트 노드(초기 노드 이름은 root)에서 시작하여 재귀적으로

197
00:04:50,029 --> 00:04:50,039
먼저 트리의 루트 노드(초기 노드 이름은 root)에서 시작하여 재귀적으로
 

198
00:04:50,039 --> 00:04:53,350
먼저 트리의 루트 노드(초기 노드 이름은 root)에서 시작하여 재귀적으로
키 K를 검색합니다.

199
00:04:53,350 --> 00:04:53,360
키 K를 검색합니다.
 

200
00:04:53,360 --> 00:04:57,510
키 K를 검색합니다.
루트 노드의 항목에

201
00:04:57,510 --> 00:04:57,520
루트 노드의 항목에
 

202
00:04:57,520 --> 00:05:00,189
루트 노드의 항목에
K보다 큰 키가 있는지 확인하는 것입니다. 그림을 그려보면, 현재

203
00:05:00,189 --> 00:05:00,199
K보다 큰 키가 있는지 확인하는 것입니다. 그림을 그려보면, 현재
 

204
00:05:00,199 --> 00:05:01,110
K보다 큰 키가 있는지 확인하는 것입니다. 그림을 그려보면, 현재

205
00:05:01,110 --> 00:05:01,120

 

206
00:05:01,120 --> 00:05:03,110


207
00:05:03,110 --> 00:05:03,120

 

208
00:05:03,120 --> 00:05:07,469

노드(

209
00:05:07,469 --> 00:05:07,479
노드(
 

210
00:05:07,479 --> 00:05:09,390
노드(
여기에

211
00:05:09,390 --> 00:05:09,400
여기에
 

212
00:05:09,400 --> 00:05:12,710
여기에
노드가 있습니다)에는 왼쪽 부분 트리가 있습니다.

213
00:05:12,710 --> 00:05:12,720
노드가 있습니다)에는 왼쪽 부분 트리가 있습니다.
 

214
00:05:12,720 --> 00:05:14,830
노드가 있습니다)에는 왼쪽 부분 트리가 있습니다.
오른쪽 하위 트리에

215
00:05:14,830 --> 00:05:14,840
오른쪽 하위 트리에
 

216
00:05:14,840 --> 00:05:17,950
오른쪽 하위 트리에
특정 키를 가진 항목이 있습니다. 만약 우리가

217
00:05:17,950 --> 00:05:17,960
특정 키를 가진 항목이 있습니다. 만약 우리가
 

218
00:05:17,960 --> 00:05:20,350
특정 키를 가진 항목이 있습니다. 만약 우리가
찾고 있는 키가 노드의 항목보다 작다면, 그 항목은

219
00:05:20,350 --> 00:05:20,360
찾고 있는 키가 노드의 항목보다 작다면, 그 항목은
 

220
00:05:20,360 --> 00:05:22,469
찾고 있는 키가 노드의 항목보다 작다면, 그 항목은
왼쪽

221
00:05:22,469 --> 00:05:22,479
왼쪽
 

222
00:05:22,479 --> 00:05:25,550
왼쪽
하위 트리에 있다는 뜻이고, 따라서 노드를 재귀적으로 탐색하게 됩니다.  왼쪽의 키와 값이 같으면

223
00:05:25,550 --> 00:05:25,560
하위 트리에 있다는 뜻이고, 따라서 노드를 재귀적으로 탐색하게 됩니다.  왼쪽의 키와 값이 같으면
 

224
00:05:25,560 --> 00:05:27,590
하위 트리에 있다는 뜻이고, 따라서 노드를 재귀적으로 탐색하게 됩니다.  왼쪽의 키와 값이 같으면
이

225
00:05:27,590 --> 00:05:27,600
이
 

226
00:05:27,600 --> 00:05:29,189
이
항목이 우리가 찾고 있는 항목이므로 해당

227
00:05:29,189 --> 00:05:29,199
항목이 우리가 찾고 있는 항목이므로 해당
 

228
00:05:29,199 --> 00:05:31,150
항목이 우리가 찾고 있는 항목이므로 해당
노드를 이동시키면 됩니다.

229
00:05:31,150 --> 00:05:31,160
노드를 이동시키면 됩니다.
 

230
00:05:31,160 --> 00:05:33,230
노드를 이동시키면 됩니다.
만약

231
00:05:33,230 --> 00:05:33,240
만약
 

232
00:05:33,240 --> 00:05:34,629
만약
여기 있는 키가

233
00:05:34,629 --> 00:05:34,639
여기 있는 키가
 

234
00:05:34,639 --> 00:05:36,110
여기 있는 키가
우리가 찾고 있는 키보다 크면 오른쪽으로 재귀 호출을 합니다.

235
00:05:36,110 --> 00:05:36,120
우리가 찾고 있는 키보다 크면 오른쪽으로 재귀 호출을 합니다.
 

236
00:05:36,120 --> 00:05:37,270
우리가 찾고 있는 키보다 크면 오른쪽으로 재귀 호출을 합니다.

237
00:05:37,270 --> 00:05:37,280

 

238
00:05:37,280 --> 00:05:40,029

조금만 생각해 보면

239
00:05:40,029 --> 00:05:40,039
조금만 생각해 보면
 

240
00:05:40,039 --> 00:05:42,469
조금만 생각해 보면
이것은 배열에서 이진 탐색을 하는 것과 정확히 같습니다. 단지 배열 대신 트리에서 작동한다는 점만 다릅니다. 배열을

241
00:05:42,469 --> 00:05:44,830
이것은 배열에서 이진 탐색을 하는 것과 정확히 같습니다. 단지 배열 대신 트리에서 작동한다는 점만 다릅니다. 배열을
 

242
00:05:44,830 --> 00:05:44,840

 

243
00:05:44,840 --> 00:05:52,110

생각해 보세요. 예를 들어

244
00:05:52,110 --> 00:05:52,120

 

245
00:05:52,120 --> 00:05:55,870

B와 같은 배열에서 이진

246
00:05:55,870 --> 00:05:55,880
B와 같은 배열에서 이진
 

247
00:05:55,880 --> 00:05:57,710
B와 같은 배열에서 이진
탐색은 어떻게 작동할까요? 먼저 가운데 있는 키(루트라고 하겠습니다)를 찾습니다. 그런

248
00:05:57,710 --> 00:05:59,189
탐색은 어떻게 작동할까요? 먼저 가운데 있는 키(루트라고 하겠습니다)를 찾습니다. 그런
 

249
00:05:59,189 --> 00:05:59,199

 

250
00:05:59,199 --> 00:06:02,629

다음

251
00:06:02,629 --> 00:06:02,639
다음
 

252
00:06:02,639 --> 00:06:04,870
다음
왼쪽 영역(재귀적으로 그리겠습니다)

253
00:06:04,870 --> 00:06:04,880
왼쪽 영역(재귀적으로 그리겠습니다)
 

254
00:06:04,880 --> 00:06:07,189
왼쪽 영역(재귀적으로 그리겠습니다)
이나 오른쪽

255
00:06:07,189 --> 00:06:07,199
이나 오른쪽
 

256
00:06:07,199 --> 00:06:09,510
이나 오른쪽
영역에서 재귀 호출을 합니다.

257
00:06:09,510 --> 00:06:09,520
영역에서 재귀 호출을 합니다.
 

258
00:06:09,520 --> 00:06:11,589
영역에서 재귀 호출을 합니다.
이처럼 완벽한 이진 트리가 있다면 이 배열

259
00:06:11,589 --> 00:06:11,599
이처럼 완벽한 이진 트리가 있다면 이 배열
 

260
00:06:11,599 --> 00:06:14,629
이처럼 완벽한 이진 트리가 있다면 이 배열
에서 이진 탐색을 정확히 시뮬레이션하는 것입니다.

261
00:06:14,629 --> 00:06:14,639
에서 이진 탐색을 정확히 시뮬레이션하는 것입니다.
 

262
00:06:14,639 --> 00:06:16,230
에서 이진 탐색을 정확히 시뮬레이션하는 것입니다.
하지만 이 방법은

263
00:06:16,230 --> 00:06:16,240
하지만 이 방법은
 

264
00:06:16,240 --> 00:06:17,950
하지만 이 방법은
동적으로 유지 관리할 수 있습니다. 완벽하지는 않지만 거의

265
00:06:17,950 --> 00:06:17,960
동적으로 유지 관리할 수 있습니다. 완벽하지는 않지만 거의
 

266
00:06:17,960 --> 00:06:20,270
동적으로 유지 관리할 수 있습니다. 완벽하지는 않지만 거의
비슷합니다. 반면에 이 방법은

267
00:06:20,270 --> 00:06:20,280
비슷합니다. 반면에 이 방법은
 

268
00:06:20,280 --> 00:06:23,230
비슷합니다. 반면에 이 방법은
정렬된 상태를 유지할 수 없습니다.

269
00:06:23,230 --> 00:06:23,240
정렬된 상태를 유지할 수 없습니다.
 

270
00:06:23,240 --> 00:06:26,510
정렬된 상태를 유지할 수 없습니다.
따라서 이것은 배열이

271
00:06:26,510 --> 00:06:26,520
따라서 이것은 배열이
 

272
00:06:26,520 --> 00:06:28,629
따라서 이것은 배열이
아닌 트리에서 작동하도록 이진 탐색을 일반화한 것입니다.

273
00:06:28,629 --> 00:06:28,639
아닌 트리에서 작동하도록 이진 탐색을 일반화한 것입니다.
 

274
00:06:28,639 --> 00:06:32,469
아닌 트리에서 작동하도록 이진 탐색을 일반화한 것입니다.
이러한 이유로 집합

275
00:06:32,469 --> 00:06:32,479
이러한 이유로 집합
 

276
00:06:32,479 --> 00:06:34,430
이러한 이유로 집합
이진 트리를 이진 탐색

277
00:06:34,430 --> 00:06:34,440
이진 트리를 이진 탐색
 

278
00:06:34,440 --> 00:06:35,990
이진 트리를 이진 탐색
트리라고 부릅니다. 트리 버전이기 때문입니다.

279
00:06:35,990 --> 00:06:36,000
트리라고 부릅니다. 트리 버전이기 때문입니다.
 

280
00:06:36,000 --> 00:06:37,270
트리라고 부릅니다. 트리 버전이기 때문입니다.
이진 검색은 여러 가지

281
00:06:37,270 --> 00:06:37,280
이진 검색은 여러 가지
 

282
00:06:37,280 --> 00:06:39,309
이진 검색은 여러 가지
동등한 이름이 있는데, 이진 검색 트리는

283
00:06:39,309 --> 00:06:39,319
동등한 이름이 있는데, 이진 검색 트리는
 

284
00:06:39,319 --> 00:06:41,350
동등한 이름이 있는데, 이진 검색 트리는
집합 이진 트리의 다른 이름입니다.

285
00:06:41,350 --> 00:06:41,360
집합 이진 트리의 다른 이름입니다.
 

286
00:06:41,360 --> 00:06:43,150
집합 이진 트리의 다른 이름입니다.
이 알고리즘이

287
00:06:43,150 --> 00:06:43,160
이 알고리즘이
 

288
00:06:43,160 --> 00:06:45,230
이 알고리즘이
작동하는 핵심은 소위 이진 검색 트리

289
00:06:45,230 --> 00:06:45,240
작동하는 핵심은 소위 이진 검색 트리
 

290
00:06:45,240 --> 00:06:48,790
작동하는 핵심은 소위 이진 검색 트리
속성인데, 이는

291
00:06:48,790 --> 00:06:48,800
속성인데, 이는
 

292
00:06:48,800 --> 00:06:51,309
속성인데, 이는
노드의 왼쪽 서브 트리에 있는 모든 키는 루트보다 작고,

293
00:06:51,309 --> 00:06:51,319
노드의 왼쪽 서브 트리에 있는 모든 키는 루트보다 작고,
 

294
00:06:51,319 --> 00:06:54,589
노드의 왼쪽 서브 트리에 있는 모든 키는 루트보다 작고,
해당 노드의 모든 키는

295
00:06:54,589 --> 00:06:56,710
해당 노드의 모든 키는
 

296
00:06:56,710 --> 00:06:56,720

 

297
00:06:56,720 --> 00:06:58,230

오른쪽 서브 트리에 있는 모든 키보다 작다는 것입니다. 그리고 이 조건은 재귀적으로 모든 하위 트리에서 성립합니다. 따라서 이

298
00:06:58,230 --> 00:07:00,350
오른쪽 서브 트리에 있는 모든 키보다 작다는 것입니다. 그리고 이 조건은 재귀적으로 모든 하위 트리에서 성립합니다. 따라서 이
 

299
00:07:00,350 --> 00:07:02,230

 

300
00:07:02,230 --> 00:07:04,110

 

301
00:07:04,110 --> 00:07:04,120

 

302
00:07:04,120 --> 00:07:07,710

속성을 통해 알고리즘의 정확성을 증명할 수 있습니다. 이 속성이 성립하는 이유는 다음과 같습니다.

303
00:07:07,710 --> 00:07:07,720
속성을 통해 알고리즘의 정확성을 증명할 수 있습니다. 이 속성이 성립하는 이유는 다음과 같습니다.
 

304
00:07:07,720 --> 00:07:09,430
속성을 통해 알고리즘의 정확성을 증명할 수 있습니다. 이 속성이 성립하는 이유는 다음과 같습니다.
순회 순서를 키의 오름차순으로 유지할 수 있다면,

305
00:07:09,430 --> 00:07:13,189
순회 순서를 키의 오름차순으로 유지할 수 있다면,
 

306
00:07:13,189 --> 00:07:13,199

 

307
00:07:13,199 --> 00:07:14,830

순회 순서는

308
00:07:14,830 --> 00:07:14,840
순회 순서는
 

309
00:07:14,840 --> 00:07:16,150
순회 순서는
왼쪽 서브 트리의 모든 요소가 루트보다 먼저 오고, 루트는

310
00:07:16,150 --> 00:07:17,629
왼쪽 서브 트리의 모든 요소가 루트보다 먼저 오고, 루트는
 

311
00:07:17,629 --> 00:07:17,639

 

312
00:07:17,639 --> 00:07:19,990

오른쪽 서브 트리의 모든 요소보다 먼저 온다는 것을 의미합니다. 따라서

313
00:07:19,990 --> 00:07:20,000
오른쪽 서브 트리의 모든 요소보다 먼저 온다는 것을 의미합니다. 따라서
 

314
00:07:20,000 --> 00:07:22,749
오른쪽 서브 트리의 모든 요소보다 먼저 온다는 것을 의미합니다. 따라서
이 속성은 다음 속성을 전제로 합니다.

315
00:07:22,749 --> 00:07:25,070
이 속성은 다음 속성을 전제로 합니다.
 

316
00:07:25,070 --> 00:07:25,080

 

317
00:07:25,080 --> 00:07:27,790

키의 오름차순을 유지하는 방법은 매우 간단합니다.

318
00:07:27,790 --> 00:07:27,800
키의 오름차순을 유지하는 방법은 매우 간단합니다.
 

319
00:07:27,800 --> 00:07:30,189
키의 오름차순을 유지하는 방법은 매우 간단합니다.
항목을 삽입하려는 경우, 해당 항목이

320
00:07:30,189 --> 00:07:32,710
항목을 삽입하려는 경우, 해당 항목이
 

321
00:07:32,710 --> 00:07:32,720

 

322
00:07:32,720 --> 00:07:34,670

어디에 위치해야 하는지 검색합니다. 항목이 있으면

323
00:07:34,670 --> 00:07:36,670
어디에 위치해야 하는지 검색합니다. 항목이 있으면
 

324
00:07:36,670 --> 00:07:36,680

 

325
00:07:36,680 --> 00:07:38,670

해당 키로 저장된 값을 덮어쓸 수 있고, 없으면

326
00:07:38,670 --> 00:07:38,680
해당 키로 저장된 값을 덮어쓸 수 있고, 없으면
 

327
00:07:38,680 --> 00:07:40,070
해당 키로 저장된 값을 덮어쓸 수 있고, 없으면

328
00:07:40,070 --> 00:07:40,080

 

329
00:07:40,080 --> 00:07:42,950

이 검색을 통해 기존 값을 덮어쓸 수 있습니다.  어떤 시점에서 트리가 끊어지면,

330
00:07:42,950 --> 00:07:42,960
이 검색을 통해 기존 값을 덮어쓸 수 있습니다.  어떤 시점에서 트리가 끊어지면,
 

331
00:07:42,960 --> 00:07:45,230
이 검색을 통해 기존 값을 덮어쓸 수 있습니다.  어떤 시점에서 트리가 끊어지면,
그

332
00:07:45,230 --> 00:07:45,240
그
 

333
00:07:45,240 --> 00:07:48,790
그
지점에 새로운 노드를 삽입하는 것입니다. 이 부분은

334
00:07:48,790 --> 00:07:48,800
지점에 새로운 노드를 삽입하는 것입니다. 이 부분은
 

335
00:07:48,800 --> 00:07:50,189
지점에 새로운 노드를 삽입하는 것입니다. 이 부분은
수업 시간에 이미 설명했으니 자세히 다루지는

336
00:07:50,189 --> 00:07:50,199
수업 시간에 이미 설명했으니 자세히 다루지는
 

337
00:07:50,199 --> 00:07:52,029
수업 시간에 이미 설명했으니 자세히 다루지는
않겠습니다.

338
00:07:52,029 --> 00:07:52,039
않겠습니다.
 

339
00:07:52,039 --> 00:07:54,869
않겠습니다.
오늘 제가 집중하고 싶은 것은 다른 응용 분야입니다.

340
00:07:54,869 --> 00:07:54,879
오늘 제가 집중하고 싶은 것은 다른 응용 분야입니다.
 

341
00:07:54,879 --> 00:07:56,950
오늘 제가 집중하고 싶은 것은 다른 응용 분야입니다.
집합을 표현하는 데 이 방법을 어떻게 사용하는지 살펴보겠습니다. 이는

342
00:07:56,950 --> 00:07:56,960
집합을 표현하는 데 이 방법을 어떻게 사용하는지 살펴보겠습니다. 이는
 

343
00:07:56,960 --> 00:08:00,629
집합을 표현하는 데 이 방법을 어떻게 사용하는지 살펴보겠습니다. 이는
비교적 쉽습니다. CH(Collective Harmonic)를 사용하는 것은 어느 정도

344
00:08:00,629 --> 00:08:00,639
비교적 쉽습니다. CH(Collective Harmonic)를 사용하는 것은 어느 정도
 

345
00:08:00,639 --> 00:08:02,110
비교적 쉽습니다. CH(Collective Harmonic)를 사용하는 것은 어느 정도
준비가 되어 있지만,

346
00:08:02,110 --> 00:08:04,670
준비가 되어 있지만,
 

347
00:08:04,670 --> 00:08:04,680

 

348
00:08:04,680 --> 00:08:06,550

순차 이진

349
00:08:06,550 --> 00:08:06,560
순차 이진
 

350
00:08:06,560 --> 00:08:09,390
순차 이진
트리를 만드는 데는 약간의 추가 작업이 필요합니다. 이진 트리가 있다고 가정해 보겠습니다.

351
00:08:09,390 --> 00:08:11,510
트리를 만드는 데는 약간의 추가 작업이 필요합니다. 이진 트리가 있다고 가정해 보겠습니다.
 

352
00:08:11,510 --> 00:08:11,520

 

353
00:08:11,520 --> 00:08:13,390

지난 시간에 언급했듯이,

354
00:08:13,390 --> 00:08:13,400
지난 시간에 언급했듯이,
 

355
00:08:13,400 --> 00:08:17,110
지난 시간에 언급했듯이,
트리의 순회 순서가 제가

356
00:08:17,110 --> 00:08:17,120
트리의 순회 순서가 제가
 

357
00:08:17,120 --> 00:08:18,749
트리의 순회 순서가 제가

358
00:08:18,749 --> 00:08:20,749

 

359
00:08:20,749 --> 00:08:20,759

 

360
00:08:20,759 --> 00:08:22,909

표현하려는 순서, 즉 삽입과 같은 연산에 의해 변경되는 순서가 되기를 원합니다. 마찬가지로,

361
00:08:22,909 --> 00:08:25,070
표현하려는 순서, 즉 삽입과 같은 연산에 의해 변경되는 순서가 되기를 원합니다. 마찬가지로,
 

362
00:08:25,070 --> 00:08:27,909

 

363
00:08:27,909 --> 00:08:29,830

 

364
00:08:29,830 --> 00:08:29,840

 

365
00:08:29,840 --> 00:08:31,629

검색과 삽입을 어떻게 수행해야 할지 생각해 봐야 합니다.

366
00:08:31,629 --> 00:08:34,310
검색과 삽입을 어떻게 수행해야 할지 생각해 봐야 합니다.
 

367
00:08:34,310 --> 00:08:34,320

 

368
00:08:34,320 --> 00:08:36,750

제가 원하는 알고리즘은 다음과 같지만,

369
00:08:36,750 --> 00:08:36,760
제가 원하는 알고리즘은 다음과 같지만,
 

370
00:08:36,760 --> 00:08:40,350
제가 원하는 알고리즘은 다음과 같지만,
아직 완벽하게 작동하지는 않습니다.

371
00:08:40,350 --> 00:08:43,990
아직 완벽하게 작동하지는 않습니다.
 

372
00:08:43,990 --> 00:08:44,000

 

373
00:08:44,000 --> 00:08:47,070

노드로 지정된 부분 트리가 주어졌다고 가정해 보겠습니다. 이 부분 트리는

374
00:08:47,070 --> 00:08:47,080
노드로 지정된 부분 트리가 주어졌다고 가정해 보겠습니다. 이 부분 트리는
 

375
00:08:47,080 --> 00:08:49,710
노드로 지정된 부분 트리가 주어졌다고 가정해 보겠습니다. 이 부분 트리는
해당 노드의 모든 자손을 포함합니다. 저는 여기서 시작하는 이 부분 트리

376
00:08:49,710 --> 00:08:49,720
해당 노드의 모든 자손을 포함합니다. 저는 여기서 시작하는 이 부분 트리
 

377
00:08:49,720 --> 00:08:52,550
해당 노드의 모든 자손을 포함합니다. 저는 여기서 시작하는 이 부분 트리
의 순회 순서에 무엇이 있는지 알고 싶습니다.

378
00:08:52,550 --> 00:08:55,310
의 순회 순서에 무엇이 있는지 알고 싶습니다.
 

379
00:08:55,310 --> 00:08:55,320

 

380
00:08:55,320 --> 00:08:56,590

여기서 끝나고 루트는 중간 어딘가에 있을 겁니다.

381
00:08:56,590 --> 00:08:56,600
여기서 끝나고 루트는 중간 어딘가에 있을 겁니다.
 

382
00:08:56,600 --> 00:08:57,269
여기서 끝나고 루트는 중간 어딘가에 있을 겁니다.

383
00:08:57,269 --> 00:08:59,949

 

384
00:08:59,949 --> 00:08:59,959

 

385
00:08:59,959 --> 00:09:02,990

노드를 알려주세요. 예를 들어, I가 z와 같다고 하면 가장

386
00:09:02,990 --> 00:09:03,000
노드를 알려주세요. 예를 들어, I가 z와 같다고 하면 가장
 

387
00:09:03,000 --> 00:09:05,630
노드를 알려주세요. 예를 들어, I가 z와 같다고 하면 가장
왼쪽 자손을 얻고 싶고, I가

388
00:09:05,630 --> 00:09:05,640
왼쪽 자손을 얻고 싶고, I가
 

389
00:09:05,640 --> 00:09:08,430
왼쪽 자손을 얻고 싶고, I가
트리의 크기에서

390
00:09:08,430 --> 00:09:08,440
트리의 크기에서
 

391
00:09:08,440 --> 00:09:10,430
트리의 크기에서
1을 뺀 값과 같다고 하면 가장 오른쪽 자손을 얻고 싶습니다. 이는

392
00:09:10,430 --> 00:09:12,630
1을 뺀 값과 같다고 하면 가장 오른쪽 자손을 얻고 싶습니다. 이는
 

393
00:09:12,630 --> 00:09:12,640

 

394
00:09:12,640 --> 00:09:14,829

우리가 이야기했던 서브트리의 첫 번째와 마지막 노드입니다. 하지만

395
00:09:14,829 --> 00:09:14,839
우리가 이야기했던 서브트리의 첫 번째와 마지막 노드입니다. 하지만
 

396
00:09:14,839 --> 00:09:16,350
우리가 이야기했던 서브트리의 첫 번째와 마지막 노드입니다. 하지만
우리는 첫 번째와 마지막 노드를 찾는 방법을 모릅니다.

397
00:09:16,350 --> 00:09:16,360
우리는 첫 번째와 마지막 노드를 찾는 방법을 모릅니다.
 

398
00:09:16,360 --> 00:09:18,230
우리는 첫 번째와 마지막 노드를 찾는 방법을 모릅니다.
왼쪽이나 오른쪽으로 이동하면 되지만,

399
00:09:18,230 --> 00:09:21,269
왼쪽이나 오른쪽으로 이동하면 되지만,
 

400
00:09:21,269 --> 00:09:21,279

 

401
00:09:21,279 --> 00:09:24,190

순서대로 I 노드를 찾는 방법을 모릅니다. 지금 목표는 시간 복잡도 H입니다.

402
00:09:24,190 --> 00:09:24,200
순서대로 I 노드를 찾는 방법을 모릅니다. 지금 목표는 시간 복잡도 H입니다.
 

403
00:09:24,200 --> 00:09:28,470
순서대로 I 노드를 찾는 방법을 모릅니다. 지금 목표는 시간 복잡도 H입니다.
로그인하지 마세요. 핵심은

404
00:09:28,470 --> 00:09:28,480
로그인하지 마세요. 핵심은
 

405
00:09:28,480 --> 00:09:30,389
로그인하지 마세요. 핵심은
크기가 중요하다는 것입니다. 혹시

406
00:09:30,389 --> 00:09:30,399
크기가 중요하다는 것입니다. 혹시
 

407
00:09:30,399 --> 00:09:33,990
크기가 중요하다는 것입니다. 혹시
다른 이야기를 들으셨다면 죄송합니다.

408
00:09:33,990 --> 00:09:34,000
다른 이야기를 들으셨다면 죄송합니다.
 

409
00:09:34,000 --> 00:09:36,949
다른 이야기를 들으셨다면 죄송합니다.
특히, 시퀀스의

410
00:09:36,949 --> 00:09:36,959
특히, 시퀀스의
 

411
00:09:36,959 --> 00:09:39,350
특히, 시퀀스의
마지막 노드에 대해 이야기할 때 크기를 언급했는데,

412
00:09:39,350 --> 00:09:39,360
마지막 노드에 대해 이야기할 때 크기를 언급했는데,
 

413
00:09:39,360 --> 00:09:41,870
마지막 노드에 대해 이야기할 때 크기를 언급했는데,
그 노드의 인덱스는

414
00:09:41,870 --> 00:09:41,880
그 노드의 인덱스는
 

415
00:09:41,880 --> 00:09:45,030
그 노드의 인덱스는
이 서브트리의 크기에서 1을 뺀 값입니다. 노드의 크기를

416
00:09:45,030 --> 00:09:50,269
이 서브트리의 크기에서 1을 뺀 값입니다. 노드의 크기를
 

417
00:09:50,269 --> 00:09:55,710

 

418
00:09:55,710 --> 00:09:55,720

 

419
00:09:55,720 --> 00:09:58,750

서브트리에 있는 노드의 개수로 정의해 보겠습니다. 여기서 서브트리를 부모 노드라고 부릅니다.

420
00:09:58,750 --> 00:09:58,760
서브트리에 있는 노드의 개수로 정의해 보겠습니다. 여기서 서브트리를 부모 노드라고 부릅니다.
 

421
00:09:58,760 --> 00:10:04,630
서브트리에 있는 노드의 개수로 정의해 보겠습니다. 여기서 서브트리를 부모 노드라고 부릅니다.

422
00:10:04,630 --> 00:10:04,640

 

423
00:10:04,640 --> 00:10:08,030

노드

424
00:10:08,030 --> 00:10:08,040
노드
 

425
00:10:08,040 --> 00:10:11,150
노드
자체도 포함됩니다. 만약 제가 어떻게든 크기를 안다면,

426
00:10:11,150 --> 00:10:11,160
자체도 포함됩니다. 만약 제가 어떻게든 크기를 안다면,
 

427
00:10:11,160 --> 00:10:12,990
자체도 포함됩니다. 만약 제가 어떻게든 크기를 안다면,
이는 인덱스를 이해하는 데 중요해 보입니다. 제가

428
00:10:12,990 --> 00:10:14,990
이는 인덱스를 이해하는 데 중요해 보입니다. 제가
 

429
00:10:14,990 --> 00:10:15,000

 

430
00:10:15,000 --> 00:10:17,750

마법처럼 상수

431
00:10:17,750 --> 00:10:17,760
마법처럼 상수
 

432
00:10:17,760 --> 00:10:22,030
마법처럼 상수
시간 안에 크기를 안다고 가정해 보겠습니다. 그러면

433
00:10:22,030 --> 00:10:22,040
시간 안에 크기를 안다고 가정해 보겠습니다. 그러면
 

434
00:10:22,040 --> 00:10:23,790
시간 안에 크기를 안다고 가정해 보겠습니다. 그러면
왼쪽 서브트리의 크기는 다음과 같다고 주장할 수 있습니다.  트리입니다. 그럼

435
00:10:23,790 --> 00:10:23,800
왼쪽 서브트리의 크기는 다음과 같다고 주장할 수 있습니다.  트리입니다. 그럼
 

436
00:10:23,800 --> 00:10:27,949
왼쪽 서브트리의 크기는 다음과 같다고 주장할 수 있습니다.  트리입니다. 그럼
이 다이어그램을 조금 더 확장해 볼까요?

437
00:10:27,949 --> 00:10:31,030

 

438
00:10:31,030 --> 00:10:31,040

 

439
00:10:31,040 --> 00:10:34,630

이전처럼 노드가 있지만 왼쪽 서브 트리와

440
00:10:34,630 --> 00:10:34,640
이전처럼 노드가 있지만 왼쪽 서브 트리와
 

441
00:10:34,640 --> 00:10:36,910
이전처럼 노드가 있지만 왼쪽 서브 트리와
오른쪽 서브 트리가 있습니다. 여기 있는 이 노드가 바로

442
00:10:36,910 --> 00:10:36,920
오른쪽 서브 트리가 있습니다. 여기 있는 이 노드가 바로
 

443
00:10:36,920 --> 00:10:39,069
오른쪽 서브 트리가 있습니다. 여기 있는 이 노드가 바로
노드입니다.  왼쪽 이 노드는 노드입니다.  네, 그런 경우는

444
00:10:39,069 --> 00:10:39,079
노드입니다.  왼쪽 이 노드는 노드입니다.  네, 그런 경우는
 

445
00:10:39,079 --> 00:10:41,470
노드입니다.  왼쪽 이 노드는 노드입니다.  네, 그런 경우는
존재하지 않을 수도 있지만,

446
00:10:41,470 --> 00:10:41,480
존재하지 않을 수도 있지만,
 

447
00:10:41,480 --> 00:10:43,990
존재하지 않을 수도 있지만,
일단 그런 예외적인 경우는 무시하고

448
00:10:43,990 --> 00:10:46,509
일단 그런 예외적인 경우는 무시하고
 

449
00:10:46,509 --> 00:10:46,519

 

450
00:10:46,519 --> 00:10:49,269

노드의 크기뿐만 아니라 노드의 전체 크기까지 알고 있다고 가정해 봅시다.

451
00:10:49,269 --> 00:10:49,279
노드의 크기뿐만 아니라 노드의 전체 크기까지 알고 있다고 가정해 봅시다.
 

452
00:10:49,279 --> 00:10:52,670
노드의 크기뿐만 아니라 노드의 전체 크기까지 알고 있다고 가정해 봅시다.
왼쪽에 있는 이 트리의 크기를

453
00:10:52,670 --> 00:10:52,680
왼쪽에 있는 이 트리의 크기를
 

454
00:10:52,680 --> 00:10:55,430
왼쪽에 있는 이 트리의 크기를
NL이라고 하겠습니다.

455
00:10:55,430 --> 00:10:57,910
NL이라고 하겠습니다.
 

456
00:10:57,910 --> 00:10:57,920

 

457
00:10:57,920 --> 00:11:00,910

여기에 NL개의 노드가 있다고 가정해 봅시다. 이렇게 하면

458
00:11:00,910 --> 00:11:00,920
여기에 NL개의 노드가 있다고 가정해 봅시다. 이렇게 하면
 

459
00:11:00,920 --> 00:11:02,790
여기에 NL개의 노드가 있다고 가정해 봅시다. 이렇게 하면
이진

460
00:11:02,790 --> 00:11:02,800
이진
 

461
00:11:02,800 --> 00:11:06,509
이진
탐색과 같은 작업을 수행할 수 있습니다. 인덱스 i를 찾고, i가

462
00:11:06,509 --> 00:11:06,519
탐색과 같은 작업을 수행할 수 있습니다. 인덱스 i를 찾고, i가
 

463
00:11:06,519 --> 00:11:09,670
탐색과 같은 작업을 수행할 수 있습니다. 인덱스 i를 찾고, i가
NL보다 작으면 해당 노드는

464
00:11:09,670 --> 00:11:09,680
NL보다 작으면 해당 노드는
 

465
00:11:09,680 --> 00:11:11,150
NL보다 작으면 해당 노드는
여기에 있다는 것을 알 수 있습니다. 예를 들어

466
00:11:11,150 --> 00:11:11,160
여기에 있다는 것을 알 수 있습니다. 예를 들어
 

467
00:11:11,160 --> 00:11:12,910
여기에 있다는 것을 알 수 있습니다. 예를 들어
i가 z이면 왼쪽

468
00:11:12,910 --> 00:11:12,920
i가 z이면 왼쪽
 

469
00:11:12,920 --> 00:11:15,790
i가 z이면 왼쪽
서브트리에 있습니다. 단, NL은 0보다 커야 합니다. 즉, i가

470
00:11:15,790 --> 00:11:18,910
서브트리에 있습니다. 단, NL은 0보다 커야 합니다. 즉, i가
 

471
00:11:18,910 --> 00:11:18,920

 

472
00:11:18,920 --> 00:11:20,509

NL보다 작으면 왼쪽 서브트리로

473
00:11:20,509 --> 00:11:20,519
NL보다 작으면 왼쪽 서브트리로
 

474
00:11:20,519 --> 00:11:23,710
NL보다 작으면 왼쪽 서브트리로
재귀 호출을 하고,

475
00:11:23,710 --> 00:11:25,230
재귀 호출을 하고,
 

476
00:11:25,230 --> 00:11:25,240

 

477
00:11:25,240 --> 00:11:28,310

i가 NL과 같으면 해당

478
00:11:28,310 --> 00:11:29,870
i가 NL과 같으면 해당
 

479
00:11:29,870 --> 00:11:31,389

 

480
00:11:31,389 --> 00:11:33,550

 

481
00:11:33,550 --> 00:11:33,560

 

482
00:11:33,560 --> 00:11:37,750

노드의 인덱스가 NL이라는 것을 알 수 있습니다. 따라서 i가 NL과 같으면

483
00:11:37,750 --> 00:11:41,150
노드의 인덱스가 NL이라는 것을 알 수 있습니다. 따라서 i가 NL과 같으면
 

484
00:11:41,150 --> 00:11:42,790

 

485
00:11:42,790 --> 00:11:42,800

 

486
00:11:42,800 --> 00:11:44,470

해당 노드를 반환하고,

487
00:11:44,470 --> 00:11:45,629
해당 노드를 반환하고,
 

488
00:11:45,629 --> 00:11:45,639

 

489
00:11:45,639 --> 00:11:48,949

i가 NL보다 크면 해당

490
00:11:48,949 --> 00:11:48,959
i가 NL보다 크면 해당
 

491
00:11:48,959 --> 00:11:50,310
i가 NL보다 크면 해당
노드는

492
00:11:50,310 --> 00:11:50,320
노드는
 

493
00:11:50,320 --> 00:11:52,790
노드는
오른쪽 서브트리에 있다는 것을 알 수 있습니다.

494
00:11:52,790 --> 00:11:52,800
오른쪽 서브트리에 있다는 것을 알 수 있습니다.
 

495
00:11:52,800 --> 00:11:55,430
오른쪽 서브트리에 있다는 것을 알 수 있습니다.
루트 다음에 오기 때문에

496
00:11:55,430 --> 00:11:56,670
루트 다음에 오기 때문에
 

497
00:11:56,670 --> 00:11:56,680

 

498
00:11:56,680 --> 00:11:58,350

순회 순서라는 게 그런 의미입니다.

499
00:11:58,350 --> 00:11:58,360
순회 순서라는 게 그런 의미입니다.
 

500
00:11:58,360 --> 00:12:00,629
순회 순서라는 게 그런 의미입니다.
순회 순서로 정의하면

501
00:12:00,629 --> 00:12:02,750
순회 순서로 정의하면
 

502
00:12:02,750 --> 00:12:02,760

 

503
00:12:02,760 --> 00:12:05,150

인덱스 NL인 이 노드 다음에 오는 모든 것은

504
00:12:05,150 --> 00:12:05,160
인덱스 NL인 이 노드 다음에 오는 모든 것은
 

505
00:12:05,160 --> 00:12:07,110
인덱스 NL인 이 노드 다음에 오는 모든 것은
여기에 있어야 합니다.

506
00:12:07,110 --> 00:12:07,120
여기에 있어야 합니다.
 

507
00:12:07,120 --> 00:12:08,990
여기에 있어야 합니다.
여기서 아래로 재귀 호출을 하면 번호 체계가 바뀝니다.

508
00:12:08,990 --> 00:12:09,000
여기서 아래로 재귀 호출을 하면 번호 체계가 바뀝니다.
 

509
00:12:09,000 --> 00:12:12,470
여기서 아래로 재귀 호출을 하면 번호 체계가 바뀝니다.
노드 0은 여기이고, 그

510
00:12:12,470 --> 00:12:12,480
노드 0은 여기이고, 그
 

511
00:12:12,480 --> 00:12:15,350
노드 0은 여기이고, 그
다음 노드는...  자, 여기 Z가 있으니

512
00:12:15,350 --> 00:12:17,150
다음 노드는...  자, 여기 Z가 있으니
 

513
00:12:17,150 --> 00:12:17,160

 

514
00:12:17,160 --> 00:12:18,629

여기서 약간의 뺄셈을 해야 합니다. 오른쪽으로 재귀할 때

515
00:12:18,629 --> 00:12:18,639
여기서 약간의 뺄셈을 해야 합니다. 오른쪽으로 재귀할 때
 

516
00:12:18,639 --> 00:12:21,949
여기서 약간의 뺄셈을 해야 합니다. 오른쪽으로 재귀할 때
IUS NL에서 1을 빼고,

517
00:12:21,949 --> 00:12:21,959
IUS NL에서 1을 빼고,
 

518
00:12:21,959 --> 00:12:25,150
IUS NL에서 1을 빼고,
이 노드들에 대해서는 NL에서 1을 빼고, 루트

519
00:12:25,150 --> 00:12:25,160
이 노드들에 대해서는 NL에서 1을 빼고, 루트
 

520
00:12:25,160 --> 00:12:27,389
이 노드들에 대해서는 NL에서 1을 빼고, 루트
노드에 대해서는 1을 빼는 것입니다. 그러면

521
00:12:27,389 --> 00:12:27,399
노드에 대해서는 1을 빼는 것입니다. 그러면
 

522
00:12:27,399 --> 00:12:30,790
노드에 대해서는 1을 빼는 것입니다. 그러면
이 부분 트리에서 우리가 찾고 있는 인덱스를 얻을 수 있습니다.

523
00:12:30,790 --> 00:12:30,800
이 부분 트리에서 우리가 찾고 있는 인덱스를 얻을 수 있습니다.
 

524
00:12:30,800 --> 00:12:33,269
이 부분 트리에서 우리가 찾고 있는 인덱스를 얻을 수 있습니다.
제 요점은 이 알고리즘이

525
00:12:33,269 --> 00:12:33,279
제 요점은 이 알고리즘이
 

526
00:12:33,279 --> 00:12:35,629
제 요점은 이 알고리즘이
기본적으로 이 알고리즘과 동일

527
00:12:35,629 --> 00:12:35,639
기본적으로 이 알고리즘과 동일
 

528
00:12:35,639 --> 00:12:38,269
기본적으로 이 알고리즘과 동일
하지만, 집합을 다루기 때문에 키를 사용한다는 것입니다.

529
00:12:38,269 --> 00:12:38,279
하지만, 집합을 다루기 때문에 키를 사용한다는 것입니다.
 

530
00:12:38,279 --> 00:12:40,389
하지만, 집합을 다루기 때문에 키를 사용한다는 것입니다.
집합에서는

531
00:12:40,389 --> 00:12:40,399
집합에서는
 

532
00:12:40,399 --> 00:12:42,710
집합에서는
항목에 키가 있다고 가정하지만, 여기서는 항목에

533
00:12:42,710 --> 00:12:42,720
항목에 키가 있다고 가정하지만, 여기서는 항목에
 

534
00:12:42,720 --> 00:12:43,990
항목에 키가 있다고 가정하지만, 여기서는 항목에
키가 없어도 됩니다. 사실, 우리는

535
00:12:43,990 --> 00:12:44,000
키가 없어도 됩니다. 사실, 우리는
 

536
00:12:44,000 --> 00:12:45,990
키가 없어도 됩니다. 사실, 우리는
항목을 전혀 건드리지 않습니다. 단지

537
00:12:45,990 --> 00:12:46,000
항목을 전혀 건드리지 않습니다. 단지
 

538
00:12:46,000 --> 00:12:49,829
항목을 전혀 건드리지 않습니다. 단지
내 시퀀스에서 I번째 항목이 무엇인지 묻는 것인데, 이는

539
00:12:49,829 --> 00:12:51,310
내 시퀀스에서 I번째 항목이 무엇인지 묻는 것인데, 이는
 

540
00:12:51,310 --> 00:12:51,320

 

541
00:12:51,320 --> 00:12:52,750

순회 순서에서 I번째 항목이 무엇인지

542
00:12:52,750 --> 00:12:52,760
순회 순서에서 I번째 항목이 무엇인지
 

543
00:12:52,760 --> 00:12:55,350
순회 순서에서 I번째 항목이 무엇인지
묻는 것과 같고,

544
00:12:55,350 --> 00:12:55,360
묻는 것과 같고,
 

545
00:12:55,360 --> 00:12:56,990
묻는 것과 같고,
순회 순서에서 I번째 노드가 무엇인지 묻는 것과 같습니다. 이

546
00:12:56,990 --> 00:12:57,000
순회 순서에서 I번째 노드가 무엇인지 묻는 것과 같습니다. 이
 

547
00:12:57,000 --> 00:12:58,790
순회 순서에서 I번째 노드가 무엇인지 묻는 것과 같습니다. 이
알고리즘은 정확히

548
00:12:58,790 --> 00:12:58,800
알고리즘은 정확히
 

549
00:12:58,800 --> 00:12:59,670
알고리즘은 정확히
같은 방식으로

550
00:12:59,670 --> 00:12:59,680
같은 방식으로
 

551
00:12:59,680 --> 00:13:02,670
같은 방식으로
H번의

552
00:13:02,670 --> 00:13:02,680
H번의
 

553
00:13:02,680 --> 00:13:04,670
H번의
시간 안에 결과를 제공합니다. 이제 모든 연산을 보여드리지는 않겠지

554
00:13:04,670 --> 00:13:04,680
시간 안에 결과를 제공합니다. 이제 모든 연산을 보여드리지는 않겠지
 

555
00:13:04,680 --> 00:13:07,030
시간 안에 결과를 제공합니다. 이제 모든 연산을 보여드리지는 않겠지
만, 부분 트리를 사용하여

556
00:13:07,030 --> 00:13:08,790
만, 부분 트리를 사용하여
 

557
00:13:08,790 --> 00:13:08,800

 

558
00:13:08,800 --> 00:13:12,430

get과 set을 구현할 수 있습니다.

559
00:13:12,430 --> 00:13:12,440
get과 set을 구현할 수 있습니다.
 

560
00:13:12,440 --> 00:13:14,629
get과 set을 구현할 수 있습니다.
적절한 노드를 찾아서

561
00:13:14,629 --> 00:13:14,639
적절한 노드를 찾아서
 

562
00:13:14,639 --> 00:13:17,710
적절한 노드를 찾아서
항목을 반환하거나 수정하면 됩니다. 또는

563
00:13:17,710 --> 00:13:17,720
항목을 반환하거나 수정하면 됩니다. 또는
 

564
00:13:17,720 --> 00:13:20,150
항목을 반환하거나 수정하면 됩니다. 또는
대부분의 경우에도 사용할 수 있습니다.  무엇보다 중요한 것은 이 기능을 사용하여 특정 위치

565
00:13:20,150 --> 00:13:20,160
대부분의 경우에도 사용할 수 있습니다.  무엇보다 중요한 것은 이 기능을 사용하여 특정 위치
 

566
00:13:20,160 --> 00:13:22,310
대부분의 경우에도 사용할 수 있습니다.  무엇보다 중요한 것은 이 기능을 사용하여 특정 위치
에 삽입하고 특정 위치에서 삭제할 수 있다는 점입니다. 이는

567
00:13:22,310 --> 00:13:23,910
에 삽입하고 특정 위치에서 삭제할 수 있다는 점입니다. 이는
 

568
00:13:23,910 --> 00:13:23,920

 

569
00:13:23,920 --> 00:13:26,790

이전에는 불가능했던 새로운 기능입니다. 어떻게 하냐고요?

570
00:13:26,790 --> 00:13:29,870
이전에는 불가능했던 새로운 기능입니다. 어떻게 하냐고요?
 

571
00:13:29,870 --> 00:13:33,430

 

572
00:13:33,430 --> 00:13:33,440

 

573
00:13:33,440 --> 00:13:35,550

예를 들어, 항목을 삽입하려면 여기에서 해당 항목을 검색합니다. 즉, 인덱스 I에 삽입하려면 I를

574
00:13:35,550 --> 00:13:35,560
예를 들어, 항목을 삽입하려면 여기에서 해당 항목을 검색합니다. 즉, 인덱스 I에 삽입하려면 I를
 

575
00:13:35,560 --> 00:13:39,430
예를 들어, 항목을 삽입하려면 여기에서 해당 항목을 검색합니다. 즉, 인덱스 I에 삽입하려면 I를
검색합니다. 그리고

576
00:13:39,430 --> 00:13:39,440
검색합니다. 그리고
 

577
00:13:39,440 --> 00:13:42,870
검색합니다. 그리고
I에 삽입하려면

578
00:13:42,870 --> 00:13:42,880
I에 삽입하려면
 

579
00:13:42,880 --> 00:13:45,310
I에 삽입하려면
그 바로 앞에 새 항목을 추가해야 합니다.

580
00:13:45,310 --> 00:13:45,320
그 바로 앞에 새 항목을 추가해야 합니다.
 

581
00:13:45,320 --> 00:13:48,230
그 바로 앞에 새 항목을 추가해야 합니다.
다행히 이미

582
00:13:48,230 --> 00:13:48,240
다행히 이미
 

583
00:13:48,240 --> 00:13:51,069
다행히 이미
서브트리 삽입 기능이 있습니다. 언급하지는 않았지만,

584
00:13:51,069 --> 00:13:51,079
서브트리 삽입 기능이 있습니다. 언급하지는 않았지만,
 

585
00:13:51,079 --> 00:13:54,829
서브트리 삽입 기능이 있습니다. 언급하지는 않았지만,
이전과 이후 두 가지 버전이 있습니다. 이후 버전은

586
00:13:54,829 --> 00:13:57,350

 

587
00:13:57,350 --> 00:13:57,360

 

588
00:13:57,360 --> 00:14:00,030

성공 시 선행 노드를 사용하는 방식인데, 이제

589
00:14:00,030 --> 00:14:03,350
성공 시 선행 노드를 사용하는 방식인데, 이제
 

590
00:14:03,350 --> 00:14:03,360

 

591
00:14:03,360 --> 00:14:06,710

서브트리 삽입을 해당 노드 이전에 호출하면 바로 앞에

592
00:14:06,710 --> 00:14:06,720
서브트리 삽입을 해당 노드 이전에 호출하면 바로 앞에
 

593
00:14:06,720 --> 00:14:10,310
서브트리 삽입을 해당 노드 이전에 호출하면 바로 앞에
새 항목이 추가됩니다. 정말 마법처럼

594
00:14:10,310 --> 00:14:14,389
새 항목이 추가됩니다. 정말 마법처럼
 

595
00:14:14,389 --> 00:14:16,389

 

596
00:14:16,389 --> 00:14:16,399

 

597
00:14:16,399 --> 00:14:18,949

시퀀스 중간에 삽입이 완료되고 모든

598
00:14:18,949 --> 00:14:18,959
시퀀스 중간에 삽입이 완료되고 모든
 

599
00:14:18,959 --> 00:14:22,230
시퀀스 중간에 삽입이 완료되고 모든
인덱스가 업데이트됩니다.

600
00:14:22,230 --> 00:14:22,240
인덱스가 업데이트됩니다.
 

601
00:14:22,240 --> 00:14:24,749
인덱스가 업데이트됩니다.
인덱스를 저장하는 대신

602
00:14:24,749 --> 00:14:24,759
인덱스를 저장하는 대신
 

603
00:14:24,759 --> 00:14:27,870
인덱스를 저장하는 대신
인덱스 I에 있는 항목을 검색하는 검색

604
00:14:27,870 --> 00:14:27,880
인덱스 I에 있는 항목을 검색하는 검색
 

605
00:14:27,880 --> 00:14:29,710
인덱스 I에 있는 항목을 검색하는 검색
알고리즘을 사용하기 때문입니다. 하지만

606
00:14:29,710 --> 00:14:29,720
알고리즘을 사용하기 때문입니다. 하지만
 

607
00:14:29,720 --> 00:14:35,470
알고리즘을 사용하기 때문입니다. 하지만
문제가 있습니다. 너무 완벽해

608
00:14:35,470 --> 00:14:35,480

 

609
00:14:35,480 --> 00:14:37,749

보이는데,

610
00:14:37,749 --> 00:14:37,759
보이는데,
 

611
00:14:37,759 --> 00:14:38,470
보이는데,

612
00:14:38,470 --> 00:14:38,480

 

613
00:14:38,480 --> 00:14:41,550

트리 중간에 삽입했는데도

614
00:14:41,550 --> 00:14:41,560
트리 중간에 삽입했는데도
 

615
00:14:41,560 --> 00:14:43,829
트리 중간에 삽입했는데도
검색이 가능하고, 동시에 인덱스도 업데이트되지 않는다는 것입니다.

616
00:14:43,829 --> 00:14:46,069
검색이 가능하고, 동시에 인덱스도 업데이트되지 않는다는 것입니다.
 

617
00:14:46,069 --> 00:14:46,079

 

618
00:14:46,079 --> 00:14:47,550

해당 항목의 오른쪽에 있는 모든 인덱스가

619
00:14:47,550 --> 00:14:51,550
해당 항목의 오른쪽에 있는 모든 인덱스가
 

620
00:14:51,550 --> 00:14:51,560

 

621
00:14:51,560 --> 00:14:57,110

1씩 증가하더라도 I 항목을 찾을 수 있을까요? 거의 맞죠?

622
00:14:57,110 --> 00:14:57,120

 

623
00:14:57,120 --> 00:14:59,710

네,

624
00:14:59,710 --> 00:14:59,720
네,
 

625
00:14:59,720 --> 00:15:01,590
네,
왜냐하면 SI를 업데이트해야 하기 때문입니다.

626
00:15:01,590 --> 00:15:01,600
왜냐하면 SI를 업데이트해야 하기 때문입니다.
 

627
00:15:01,600 --> 00:15:03,230
왜냐하면 SI를 업데이트해야 하기 때문입니다.
크기를 업데이트해야 하니까요.

628
00:15:03,230 --> 00:15:05,350
크기를 업데이트해야 하니까요.
 

629
00:15:05,350 --> 00:15:05,360

 

630
00:15:05,360 --> 00:15:10,910

왼쪽 서브트리의 크기를 어떻게 계산하는지 아직 말씀드리지 않았는데, 그게 다음

631
00:15:10,910 --> 00:15:10,920

 

632
00:15:10,920 --> 00:15:13,590

주제입니다. 거의 다 됐습니다. 이건

633
00:15:13,590 --> 00:15:13,600
주제입니다. 거의 다 됐습니다. 이건
 

634
00:15:13,600 --> 00:15:16,870
주제입니다. 거의 다 됐습니다. 이건
실제로 작동할 겁니다. 정말 멋지죠.

635
00:15:16,870 --> 00:15:16,880
실제로 작동할 겁니다. 정말 멋지죠.
 

636
00:15:16,880 --> 00:15:18,829
실제로 작동할 겁니다. 정말 멋지죠.
하지만 제대로 작동하려면

637
00:15:18,829 --> 00:15:18,839
하지만 제대로 작동하려면
 

638
00:15:18,839 --> 00:15:21,590
하지만 제대로 작동하려면
서브트리

639
00:15:21,590 --> 00:15:21,600
서브트리
 

640
00:15:21,600 --> 00:15:23,430
서브트리
증강이라는 게 필요합니다.

641
00:15:23,430 --> 00:15:23,440
증강이라는 게 필요합니다.
 

642
00:15:23,440 --> 00:15:25,189
증강이라는 게 필요합니다.
먼저 일반적인 설명을 하고 크기에 적용해 보겠습니다.

643
00:15:25,189 --> 00:15:25,199
먼저 일반적인 설명을 하고 크기에 적용해 보겠습니다.
 

644
00:15:25,199 --> 00:15:30,309
먼저 일반적인 설명을 하고 크기에 적용해 보겠습니다.

645
00:15:30,309 --> 00:15:30,319

 

646
00:15:30,319 --> 00:15:33,030

서브트리 증강의 아이디어는

647
00:15:33,030 --> 00:15:33,040
서브트리 증강의 아이디어는
 

648
00:15:33,040 --> 00:15:37,870
서브트리 증강의 아이디어는
이진 트리의 각 노드가

649
00:15:37,870 --> 00:15:37,880
이진 트리의 각 노드가
 

650
00:15:37,880 --> 00:15:39,269
이진 트리의 각 노드가

651
00:15:39,269 --> 00:15:39,279

 

652
00:15:39,279 --> 00:15:44,150

상수 개수의 추가 필드를 저장할 수 있다는 것입니다.

653
00:15:44,150 --> 00:15:45,949
상수 개수의 추가 필드를 저장할 수 있다는 것입니다.
 

654
00:15:45,949 --> 00:15:45,959

 

655
00:15:45,959 --> 00:15:49,670

특히 이러한 필드가

656
00:15:49,670 --> 00:15:49,680
특히 이러한 필드가
 

657
00:15:49,680 --> 00:15:51,910
특히 이러한 필드가
특정 유형이거나 속성이라고

658
00:15:51,910 --> 00:15:51,920
특정 유형이거나 속성이라고
 

659
00:15:51,920 --> 00:15:56,749
특정 유형이거나 속성이라고
부를 수 있는 경우,

660
00:15:56,749 --> 00:15:59,189

 

661
00:15:59,189 --> 00:15:59,199

 

662
00:15:59,199 --> 00:16:07,990

서브트리

663
00:16:07,990 --> 00:16:08,000

 

664
00:16:08,000 --> 00:16:20,389

속성을

665
00:16:20,389 --> 00:16:23,069

 

666
00:16:23,069 --> 00:16:23,079

 

667
00:16:23,079 --> 00:16:27,670

노드 자식의 속성에서 계산할 수 있는 것으로 정의하겠습니다. 즉,

668
00:16:27,670 --> 00:16:27,680

 

669
00:16:27,680 --> 00:16:36,230

이것은

670
00:16:36,230 --> 00:16:36,240

 

671
00:16:36,240 --> 00:16:40,910

노드의 속성이므로 자식은 노드입니다.  왼쪽이고 아니요.   네,

672
00:16:40,910 --> 00:16:40,920
노드의 속성이므로 자식은 노드입니다.  왼쪽이고 아니요.   네,
 

673
00:16:40,920 --> 00:16:43,870
노드의 속성이므로 자식은 노드입니다.  왼쪽이고 아니요.   네,
맞습니다.

674
00:16:43,870 --> 00:16:43,880
맞습니다.
 

675
00:16:43,880 --> 00:16:45,430
맞습니다.
예를 들어 노드 자체와 같은 다른 요소에도 일정한 양의 접근 권한을 가질 수 있습니다.

676
00:16:45,430 --> 00:16:45,440
예를 들어 노드 자체와 같은 다른 요소에도 일정한 양의 접근 권한을 가질 수 있습니다.
 

677
00:16:45,440 --> 00:16:46,389
예를 들어 노드 자체와 같은 다른 요소에도 일정한 양의 접근 권한을 가질 수 있습니다.

678
00:16:46,389 --> 00:16:46,399

 

679
00:16:46,399 --> 00:16:48,749

하지만 서브트리 속성의 핵심은

680
00:16:48,749 --> 00:16:48,759
하지만 서브트리 속성의 핵심은
 

681
00:16:48,759 --> 00:16:50,790
하지만 서브트리 속성의 핵심은
하향식 접근 방식입니다.

682
00:16:50,790 --> 00:16:52,189
하향식 접근 방식입니다.
 

683
00:16:52,189 --> 00:16:52,199

 

684
00:16:52,199 --> 00:16:54,110


685
00:16:54,110 --> 00:16:54,120

 

686
00:16:54,120 --> 00:16:55,949

여기에 노드가 있고 이 노드에

687
00:16:55,949 --> 00:16:59,389
여기에 노드가 있고 이 노드에
 

688
00:16:59,389 --> 00:16:59,399

 

689
00:16:59,399 --> 00:17:04,110

대한 속성(예: P)을 계산하고 싶다고 가정해 보겠습니다. 그리고 왼쪽

690
00:17:04,110 --> 00:17:08,350
대한 속성(예: P)을 계산하고 싶다고 가정해 보겠습니다. 그리고 왼쪽
 

691
00:17:08,350 --> 00:17:10,909

 

692
00:17:10,909 --> 00:17:10,919

 

693
00:17:10,919 --> 00:17:13,069

서브트리 또는 왼쪽 노드에 대해 계산된 속성 P와 오른쪽 노드에

694
00:17:13,069 --> 00:17:13,079
서브트리 또는 왼쪽 노드에 대해 계산된 속성 P와 오른쪽 노드에
 

695
00:17:13,079 --> 00:17:14,990
서브트리 또는 왼쪽 노드에 대해 계산된 속성 P와 오른쪽 노드에
대한 속성 P를 이미 알고 있다고 가정해 보겠습니다.

696
00:17:14,990 --> 00:17:15,000
대한 속성 P를 이미 알고 있다고 가정해 보겠습니다.
 

697
00:17:15,000 --> 00:17:18,350
대한 속성 P를 이미 알고 있다고 가정해 보겠습니다.
그러면

698
00:17:18,350 --> 00:17:18,360
그러면
 

699
00:17:18,360 --> 00:17:25,189
그러면
이 계산이 상수 시간 안에 이루어지기를 바랍니다. 즉,

700
00:17:25,189 --> 00:17:28,350

 

701
00:17:28,350 --> 00:17:28,360

 

702
00:17:28,360 --> 00:17:30,270

왼쪽 노드의 P와 오른쪽 노드의 P가 주어졌을 때 이 노드의 P를 계산할 수 있기를 원하는 것입니다. 이것이 바로

703
00:17:30,270 --> 00:17:30,280
왼쪽 노드의 P와 오른쪽 노드의 P가 주어졌을 때 이 노드의 P를 계산할 수 있기를 원하는 것입니다. 이것이 바로
 

704
00:17:30,280 --> 00:17:32,350
왼쪽 노드의 P와 오른쪽 노드의 P가 주어졌을 때 이 노드의 P를 계산할 수 있기를 원하는 것입니다. 이것이 바로
서브트리 속성입니다.

705
00:17:32,350 --> 00:17:33,230
서브트리 속성입니다.
 

706
00:17:33,230 --> 00:17:33,240

 

707
00:17:33,240 --> 00:17:37,549

특히 크기도 서브트리 속성입니다.

708
00:17:37,549 --> 00:17:40,190
특히 크기도 서브트리 속성입니다.
 

709
00:17:40,190 --> 00:17:40,200

 

710
00:17:40,200 --> 00:17:42,669

왜냐하면 다음과 같은

711
00:17:42,669 --> 00:17:42,679
왜냐하면 다음과 같은
 

712
00:17:42,679 --> 00:17:45,510
왜냐하면 다음과 같은
점화식을 작성할 수 있기 때문입니다.

713
00:17:45,510 --> 00:17:45,520
점화식을 작성할 수 있기 때문입니다.
 

714
00:17:45,520 --> 00:17:48,630
점화식을 작성할 수 있기 때문입니다.
크기는 왼쪽으로 하지 않고

715
00:17:48,630 --> 00:17:48,640
크기는 왼쪽으로 하지 않고
 

716
00:17:48,640 --> 00:17:51,590
크기는 왼쪽으로 하지 않고
크기를 쓰는 것이 매우 번거롭다는 것을 의미하며,

717
00:17:51,590 --> 00:17:51,600
크기를 쓰는 것이 매우 번거롭다는 것을 의미하며,
 

718
00:17:51,600 --> 00:18:02,830
크기를 쓰는 것이 매우 번거롭다는 것을 의미하며,
오른쪽으로 하지 않는 것도 마찬가지입니다.  크기

719
00:18:02,830 --> 00:18:02,840

 

720
00:18:02,840 --> 00:18:05,430

+ 1 감사합니다.

721
00:18:05,430 --> 00:18:08,510
+ 1 감사합니다.
 

722
00:18:08,510 --> 00:18:08,520

 

723
00:18:08,520 --> 00:18:12,029

여기 전체 서브 트리의 크기, 즉 노드의 크기는

724
00:18:12,029 --> 00:18:12,039
여기 전체 서브 트리의 크기, 즉 노드의 크기는
 

725
00:18:12,039 --> 00:18:13,310
여기 전체 서브 트리의 크기, 즉 노드의 크기는
왼쪽 서브 트리의 크기와

726
00:18:13,310 --> 00:18:13,320
왼쪽 서브 트리의 크기와
 

727
00:18:13,320 --> 00:18:16,110
왼쪽 서브 트리의 크기와
오른쪽 서브 트리의 크기를 더한 값에 해당 노드 자체의 크기를 1 더한 것입니다. 자,

728
00:18:16,110 --> 00:18:16,120
오른쪽 서브 트리의 크기를 더한 값에 해당 노드 자체의 크기를 1 더한 것입니다. 자,
 

729
00:18:16,120 --> 00:18:19,110
오른쪽 서브 트리의 크기를 더한 값에 해당 노드 자체의 크기를 1 더한 것입니다. 자,
이 업데이트 규칙은

730
00:18:19,110 --> 00:18:19,120
이 업데이트 규칙은
 

731
00:18:19,120 --> 00:18:21,950
이 업데이트 규칙은
평가하는 데 상수 시간이 걸립니다. 두 번의

732
00:18:21,950 --> 00:18:21,960
평가하는 데 상수 시간이 걸립니다. 두 번의
 

733
00:18:21,960 --> 00:18:24,270
평가하는 데 상수 시간이 걸립니다. 두 번의
덧셈이죠. 죄송합니다. 제 T자가

734
00:18:24,270 --> 00:18:24,280
덧셈이죠. 죄송합니다. 제 T자가
 

735
00:18:24,280 --> 00:18:26,909
덧셈이죠. 죄송합니다. 제 T자가
플러스

736
00:18:26,909 --> 00:18:26,919

 

737
00:18:26,919 --> 00:18:34,510

기호처럼 보이네요. 플러스 기호를 좀 더

738
00:18:34,510 --> 00:18:34,520

 

739
00:18:34,520 --> 00:18:37,029

크게 하겠습니다. 자, 이렇게 세

740
00:18:37,029 --> 00:18:37,039
크게 하겠습니다. 자, 이렇게 세
 

741
00:18:37,039 --> 00:18:41,149
크게 하겠습니다. 자, 이렇게 세
가지를 더하면 노드의 크기를 얻을 수 있습니다. 따라서

742
00:18:41,149 --> 00:18:41,159
가지를 더하면 노드의 크기를 얻을 수 있습니다. 따라서
 

743
00:18:41,159 --> 00:18:45,430
가지를 더하면 노드의 크기를 얻을 수 있습니다. 따라서
제 속성이

744
00:18:45,430 --> 00:18:45,440
제 속성이
 

745
00:18:45,440 --> 00:18:48,230
제 속성이
이 기능을 가지고 있는 한, 트리를 변경하면서 동적으로 유지할 수 있다고 주장합니다. 자,

746
00:18:48,230 --> 00:18:50,430
이 기능을 가지고 있는 한, 트리를 변경하면서 동적으로 유지할 수 있다고 주장합니다. 자,
 

747
00:18:50,430 --> 00:18:50,440

 

748
00:18:50,440 --> 00:18:53,390

이것은 아직 트리를 어떻게 변경할지 정확히 말하지

749
00:18:53,390 --> 00:18:53,400
이것은 아직 트리를 어떻게 변경할지 정확히 말하지
 

750
00:18:53,400 --> 00:18:54,549
이것은 아직 트리를 어떻게 변경할지 정확히 말하지
않았기 때문에 약간의 전방 참조입니다. 그런데,

751
00:18:54,549 --> 00:18:55,750
않았기 때문에 약간의 전방 참조입니다. 그런데,
 

752
00:18:55,750 --> 00:18:55,760

 

753
00:18:55,760 --> 00:18:59,669

SI가

754
00:18:59,669 --> 00:18:59,679
SI가
 

755
00:18:59,679 --> 00:19:04,590
SI가
재귀적이라면 어떻게 가능할까요?

756
00:19:04,590 --> 00:19:04,600
재귀적이라면 어떻게 가능할까요?
 

757
00:19:04,600 --> 00:19:07,630
재귀적이라면 어떻게 가능할까요?
왜 그럴까요? 좋은 질문입니다.

758
00:19:07,630 --> 00:19:07,640
왜 그럴까요? 좋은 질문입니다.
 

759
00:19:07,640 --> 00:19:09,470
왜 그럴까요? 좋은 질문입니다.
한 가지 자연스러운 방법은 이것을 재귀로 생각하는 것입니다.

760
00:19:09,470 --> 00:19:11,549
한 가지 자연스러운 방법은 이것을 재귀로 생각하는 것입니다.
 

761
00:19:11,549 --> 00:19:11,559

 

762
00:19:11,559 --> 00:19:14,230

그러면 재귀 알고리즘이 나옵니다. 제가 직접 쓴 것은 아니지만,

763
00:19:14,230 --> 00:19:15,990
그러면 재귀 알고리즘이 나옵니다. 제가 직접 쓴 것은 아니지만,
 

764
00:19:15,990 --> 00:19:16,000

 

765
00:19:16,000 --> 00:19:19,310

노드의 크기는 이 노드의 크기와 같다고 쓸 수도 있었습니다.  왼쪽

766
00:19:19,310 --> 00:19:19,320
노드의 크기는 이 노드의 크기와 같다고 쓸 수도 있었습니다.  왼쪽
 

767
00:19:19,320 --> 00:19:20,710
노드의 크기는 이 노드의 크기와 같다고 쓸 수도 있었습니다.  왼쪽
플러스 연산자를 사용하면

768
00:19:20,710 --> 00:19:20,720
플러스 연산자를 사용하면
 

769
00:19:20,720 --> 00:19:23,270
플러스 연산자를 사용하면
크기를 계산하는 데 선형 시간 알고리즘이 필요하게 되는데,

770
00:19:23,270 --> 00:19:23,280
크기를 계산하는 데 선형 시간 알고리즘이 필요하게 되는데,
 

771
00:19:23,280 --> 00:19:25,669
크기를 계산하는 데 선형 시간 알고리즘이 필요하게 되는데,
정보가 전혀 없다면 그렇게 해야 하고,

772
00:19:25,669 --> 00:19:25,679
정보가 전혀 없다면 그렇게 해야 하고,
 

773
00:19:25,679 --> 00:19:27,710
정보가 전혀 없다면 그렇게 해야 하고,
이는

774
00:19:27,710 --> 00:19:27,720
이는
 

775
00:19:27,720 --> 00:19:28,990
이는
매우 비효율적일 것입니다. 따라서

776
00:19:28,990 --> 00:19:30,549
매우 비효율적일 것입니다. 따라서
 

777
00:19:30,549 --> 00:19:30,559

 

778
00:19:30,559 --> 00:19:32,710

크기를 재귀 함수로 호출하는 것은

779
00:19:32,710 --> 00:19:32,720
크기를 재귀 함수로 호출하는 것은
 

780
00:19:32,720 --> 00:19:35,669
크기를 재귀 함수로 호출하는 것은
좋지 않으므로, 이 알고리즘은 매우 느려질 것입니다. 대신 저는

781
00:19:35,669 --> 00:19:35,679
좋지 않으므로, 이 알고리즘은 매우 느려질 것입니다. 대신 저는
 

782
00:19:35,679 --> 00:19:37,870
좋지 않으므로, 이 알고리즘은 매우 느려질 것입니다. 대신 저는
모든 노드에 크기를 저장하고 미리

783
00:19:37,870 --> 00:19:37,880
모든 노드에 크기를 저장하고 미리
 

784
00:19:37,880 --> 00:19:41,830
모든 노드에 크기를 저장하고 미리
계산해 두려고 합니다.

785
00:19:41,830 --> 00:19:41,840
계산해 두려고 합니다.
 

786
00:19:41,840 --> 00:19:45,710
계산해 두려고 합니다.
즉, 노드의 크기를 다음과 같이

787
00:19:45,710 --> 00:19:47,549
즉, 노드의 크기를 다음과 같이
 

788
00:19:47,549 --> 00:19:47,559

 

789
00:19:47,559 --> 00:19:49,390

수학적으로 정의할 것입니다. 하지만

790
00:19:49,390 --> 00:19:49,400
수학적으로 정의할 것입니다. 하지만
 

791
00:19:49,400 --> 00:19:51,470
수학적으로 정의할 것입니다. 하지만
이 함수의 알고리즘은 단순히

792
00:19:51,470 --> 00:19:51,480
이 함수의 알고리즘은 단순히
 

793
00:19:51,480 --> 00:19:55,630
이 함수의 알고리즘은 단순히
노드를 반환하는 것입니다.  크기, 좋아요. 이건 상수 시간이에요.

794
00:19:55,630 --> 00:19:55,640
노드를 반환하는 것입니다.  크기, 좋아요. 이건 상수 시간이에요.
 

795
00:19:55,640 --> 00:19:57,430
노드를 반환하는 것입니다.  크기, 좋아요. 이건 상수 시간이에요.
이제 제 과제는 트리에

796
00:19:57,430 --> 00:19:57,440
이제 제 과제는 트리에
 

797
00:19:57,440 --> 00:19:59,149
이제 제 과제는 트리에
어떤 작업을 하든 이 크기를 일정하게 유지하는 거예요.

798
00:19:59,149 --> 00:20:01,630
어떤 작업을 하든 이 크기를 일정하게 유지하는 거예요.
 

799
00:20:01,630 --> 00:20:01,640

 

800
00:20:01,640 --> 00:20:03,390

지난 강의를 다시 보면 트리에 어떤

801
00:20:03,390 --> 00:20:03,400
지난 강의를 다시 보면 트리에 어떤
 

802
00:20:03,400 --> 00:20:06,510
지난 강의를 다시 보면 트리에 어떤
변화를 주었는지 알 수 있을 거예요.

803
00:20:06,510 --> 00:20:06,520
변화를 주었는지 알 수 있을 거예요.
 

804
00:20:06,520 --> 00:20:08,750
변화를 주었는지 알 수 있을 거예요.
삽입과 삭제 작업만 했죠.

805
00:20:08,750 --> 00:20:12,549
삽입과 삭제 작업만 했죠.
 

806
00:20:12,549 --> 00:20:12,559

 

807
00:20:12,559 --> 00:20:15,990

삽입과

808
00:20:15,990 --> 00:20:16,000
삽입과
 

809
00:20:16,000 --> 00:20:18,710
삽입과
삭제는

810
00:20:18,710 --> 00:20:21,789
삭제는
 

811
00:20:21,789 --> 00:20:21,799

 

812
00:20:21,799 --> 00:20:26,590

결국 트리

813
00:20:26,590 --> 00:20:26,600
결국 트리
 

814
00:20:26,600 --> 00:20:33,830
결국 트리
의 리프 노드를 추가하거나 제거하는 거예요. 리프 노드는

815
00:20:33,830 --> 00:20:36,070

 

816
00:20:36,070 --> 00:20:36,080

 

817
00:20:36,080 --> 00:20:40,190

자식이 없는 노드였죠. 자,

818
00:20:40,190 --> 00:20:40,200
자식이 없는 노드였죠. 자,
 

819
00:20:40,200 --> 00:20:42,990
자식이 없는 노드였죠. 자,
트리에 새로운 리프 노드를 추가한다고 생각해 볼게요. 여기

820
00:20:42,990 --> 00:20:43,000
트리에 새로운 리프 노드를 추가한다고 생각해 볼게요. 여기
 

821
00:20:43,000 --> 00:20:45,909
트리에 새로운 리프 노드를 추가한다고 생각해 볼게요. 여기
트리가 있다고 가정해 볼게요. 여기에 리프 노드를 추가하면 어떤 서브

822
00:20:45,909 --> 00:20:45,919
트리가 있다고 가정해 볼게요. 여기에 리프 노드를 추가하면 어떤 서브
 

823
00:20:45,919 --> 00:20:47,230
트리가 있다고 가정해 볼게요. 여기에 리프 노드를 추가하면 어떤 서브
트리가

824
00:20:47,230 --> 00:20:47,240
트리가
 

825
00:20:47,240 --> 00:20:51,350
트리가
바뀌나요? 그 노드를 포함하는 서브 트리가 바뀌죠. 그

826
00:20:51,350 --> 00:20:51,360
바뀌나요? 그 노드를 포함하는 서브 트리가 바뀌죠. 그
 

827
00:20:51,360 --> 00:20:54,230
바뀌나요? 그 노드를 포함하는 서브 트리가 바뀌죠. 그
노드 자체는 새로운 서브 트리가 되고, 부모 노드,

828
00:20:54,230 --> 00:20:54,240
노드 자체는 새로운 서브 트리가 되고, 부모 노드,
 

829
00:20:54,240 --> 00:20:56,390
노드 자체는 새로운 서브 트리가 되고, 부모 노드,
부모 노드의

830
00:20:56,390 --> 00:20:56,400
부모 노드의
 

831
00:20:56,400 --> 00:20:58,430
부모 노드의
서브 트리, 조부모 노드의 서브 트리,

832
00:20:58,430 --> 00:20:58,440
서브 트리, 조부모 노드의 서브 트리,
 

833
00:20:58,440 --> 00:21:00,990
서브 트리, 조부모 노드의 서브 트리,
그리고 전체 서브 트리가 바뀌어요.

834
00:21:00,990 --> 00:21:01,000
그리고 전체 서브 트리가 바뀌어요.
 

835
00:21:01,000 --> 00:21:03,270
그리고 전체 서브 트리가 바뀌어요.
일반적으로 이러한 노드들을

836
00:21:03,270 --> 00:21:03,280
일반적으로 이러한 노드들을
 

837
00:21:03,280 --> 00:21:06,549
일반적으로 이러한 노드들을
새로 추가한 노드의 조상이라고 해요. 이 노드들이 바로

838
00:21:06,549 --> 00:21:06,559
새로 추가한 노드의 조상이라고 해요. 이 노드들이 바로
 

839
00:21:06,559 --> 00:21:08,310
새로 추가한 노드의 조상이라고 해요. 이 노드들이 바로
이 서브

840
00:21:08,310 --> 00:21:08,320
이 서브
 

841
00:21:08,320 --> 00:21:10,710
이 서브
트리를 업데이트하는 거예요. 여기 있는

842
00:21:10,710 --> 00:21:10,720
트리를 업데이트하는 거예요. 여기 있는
 

843
00:21:10,720 --> 00:21:13,390
트리를 업데이트하는 거예요. 여기 있는
서브 트리는 크기가 바뀌지 않았어요. 서브 트리

844
00:21:13,390 --> 00:21:13,400
서브 트리는 크기가 바뀌지 않았어요. 서브 트리
 

845
00:21:13,400 --> 00:21:15,110
서브 트리는 크기가 바뀌지 않았어요. 서브 트리
속성이 그대로 유지되었기 때문에 다른 서브 트리 속성은 변하지 않아요.  자, 그럼 제가

846
00:21:15,110 --> 00:21:17,149
속성이 그대로 유지되었기 때문에 다른 서브 트리 속성은 변하지 않아요.  자, 그럼 제가
 

847
00:21:17,149 --> 00:21:20,110

 

848
00:21:20,110 --> 00:21:20,120

 

849
00:21:20,120 --> 00:21:22,710

이 노드를 건드리면

850
00:21:22,710 --> 00:21:22,720
이 노드를 건드리면
 

851
00:21:22,720 --> 00:21:24,870
이 노드를 건드리면
여기 서브트리 속성을 업데이트해야 합니다. 여기

852
00:21:24,870 --> 00:21:24,880
여기 서브트리 속성을 업데이트해야 합니다. 여기
 

853
00:21:24,880 --> 00:21:26,230
여기 서브트리 속성을 업데이트해야 합니다. 여기
서브트리 속성을 업데이트하고, 여기

854
00:21:26,230 --> 00:21:26,240
서브트리 속성을 업데이트하고, 여기
 

855
00:21:26,240 --> 00:21:27,710
서브트리 속성을 업데이트하고, 여기
서브트리 속성을 업데이트하고, 여기 서브트리 속성을 업데이트해야 합니다. 이런 속성이 몇 개나 있죠?

856
00:21:27,710 --> 00:21:32,789
서브트리 속성을 업데이트하고, 여기 서브트리 속성을 업데이트해야 합니다. 이런 속성이 몇 개나 있죠?
 

857
00:21:32,789 --> 00:21:32,799

 

858
00:21:32,799 --> 00:21:36,669

네, 안전을 위해 H라고 하겠습니다. 하지만

859
00:21:36,669 --> 00:21:36,679
네, 안전을 위해 H라고 하겠습니다. 하지만
 

860
00:21:36,679 --> 00:21:40,870
네, 안전을 위해 H라고 하겠습니다. 하지만
정확히 H일 겁니다. 음, 그리고 리프 노드를

861
00:21:40,870 --> 00:21:40,880
정확히 H일 겁니다. 음, 그리고 리프 노드를
 

862
00:21:40,880 --> 00:21:43,149
정확히 H일 겁니다. 음, 그리고 리프 노드를
제거할 때도 마찬가지입니다.

863
00:21:43,149 --> 00:21:43,159
제거할 때도 마찬가지입니다.
 

864
00:21:43,159 --> 00:21:44,830
제거할 때도 마찬가지입니다.
이 리프 노드를 제거하면 변경되는 서브트리는

865
00:21:44,830 --> 00:21:44,840
이 리프 노드를 제거하면 변경되는 서브트리는
 

866
00:21:44,840 --> 00:21:48,630
이 리프 노드를 제거하면 변경되는 서브트리는
정확히 이전

867
00:21:48,630 --> 00:21:48,640

 

868
00:21:48,640 --> 00:21:50,510

조상 노드들입니다. 좋습니다. 그럼 이제

869
00:21:50,510 --> 00:21:54,750
조상 노드들입니다. 좋습니다. 그럼 이제
 

870
00:21:54,750 --> 00:21:59,350

 

871
00:21:59,350 --> 00:21:59,360

 

872
00:21:59,360 --> 00:22:05,110

H 순서로

873
00:22:05,110 --> 00:22:05,120

 

874
00:22:05,120 --> 00:22:09,669

조상 노드들을

875
00:22:09,669 --> 00:22:12,630
조상 노드들을
 

876
00:22:12,630 --> 00:22:12,640

 

877
00:22:12,640 --> 00:22:16,909

트리의 위쪽 순서대로 업데이트하겠습니다. 업데이트라는 건

878
00:22:16,909 --> 00:22:16,919
트리의 위쪽 순서대로 업데이트하겠습니다. 업데이트라는 건
 

879
00:22:16,919 --> 00:22:20,950
트리의 위쪽 순서대로 업데이트하겠습니다. 업데이트라는 건
서브트리 속성에 대한 규칙을 적용하는 것을 의미합니다. 크기에 대한

880
00:22:20,950 --> 00:22:20,960
서브트리 속성에 대한 규칙을 적용하는 것을 의미합니다. 크기에 대한
 

881
00:22:20,960 --> 00:22:23,149
서브트리 속성에 대한 규칙을 적용하는 것을 의미합니다. 크기에 대한
규칙은 이렇지만, 일반적으로 서브트리

882
00:22:23,149 --> 00:22:23,159
규칙은 이렇지만, 일반적으로 서브트리
 

883
00:22:23,159 --> 00:22:24,669
규칙은 이렇지만, 일반적으로 서브트리
속성은 상수 시간 복잡도를 갖는 업데이트 규칙을 제공합니다.

884
00:22:24,669 --> 00:22:24,679
속성은 상수 시간 복잡도를 갖는 업데이트 규칙을 제공합니다.
 

885
00:22:24,679 --> 00:22:27,070
속성은 상수 시간 복잡도를 갖는 업데이트 규칙을 제공합니다.
그래서

886
00:22:27,070 --> 00:22:27,080
그래서
 

887
00:22:27,080 --> 00:22:30,110
그래서
이 노드에 해당 업데이트 규칙을 적용하여

888
00:22:30,110 --> 00:22:32,190
이 노드에 해당 업데이트 규칙을 적용하여
 

889
00:22:32,190 --> 00:22:32,200

 

890
00:22:32,200 --> 00:22:34,230

여기에 저장된 속성을 수정합니다.

891
00:22:34,230 --> 00:22:34,240
여기에 저장된 속성을 수정합니다.
 

892
00:22:34,240 --> 00:22:35,990
여기에 저장된 속성을 수정합니다.
속성이 여러 개 있을 수도 있습니다. 그런 다음 이 노드에 적용합니다. 이 노드는 이미

893
00:22:35,990 --> 00:22:38,029
속성이 여러 개 있을 수도 있습니다. 그런 다음 이 노드에 적용합니다. 이 노드는 이미
 

894
00:22:38,029 --> 00:22:38,039

 

895
00:22:38,039 --> 00:22:40,870

수정되었기

896
00:22:40,870 --> 00:22:40,880
수정되었기
 

897
00:22:40,880 --> 00:22:42,390
수정되었기
때문에, 제가 이 서브트리를 건드리지 않았으므로 변경되지 않았습니다.

898
00:22:42,390 --> 00:22:42,400
때문에, 제가 이 서브트리를 건드리지 않았으므로 변경되지 않았습니다.
 

899
00:22:42,400 --> 00:22:45,390
때문에, 제가 이 서브트리를 건드리지 않았으므로 변경되지 않았습니다.
따라서 이 노드의

900
00:22:45,390 --> 00:22:45,400
따라서 이 노드의
 

901
00:22:45,400 --> 00:22:47,470
따라서 이 노드의
속성 값을

902
00:22:47,470 --> 00:22:47,480
속성 값을
 

903
00:22:47,480 --> 00:22:49,909
속성 값을
상수 시간으로 업데이트할 수 있습니다. 그다음

904
00:22:49,909 --> 00:22:49,919
상수 시간으로 업데이트할 수 있습니다. 그다음
 

905
00:22:49,919 --> 00:22:52,470
상수 시간으로 업데이트할 수 있습니다. 그다음
이 노드를 업데이트합니다. 이 노드는 이미 수정되었기 때문에

906
00:22:52,470 --> 00:22:52,480
이 노드를 업데이트합니다. 이 노드는 이미 수정되었기 때문에
 

907
00:22:52,480 --> 00:22:54,390
이 노드를 업데이트합니다. 이 노드는 이미 수정되었기 때문에
귀납적으로 올바르고,

908
00:22:54,390 --> 00:22:54,400
귀납적으로 올바르고,
 

909
00:22:54,400 --> 00:22:55,710
귀납적으로 올바르고,
이 서브트리는

910
00:22:55,710 --> 00:22:55,720
이 서브트리는
 

911
00:22:55,720 --> 00:22:58,029
이 서브트리는
변경되지 않았으므로 이미 올바릅니다.

912
00:22:58,029 --> 00:22:58,039
변경되지 않았으므로 이미 올바릅니다.
 

913
00:22:58,039 --> 00:23:00,590
변경되지 않았으므로 이미 올바릅니다.
여기서 속성을 상수 시간 안에 정확하게 업데이트할 수 있습니다. 따라서

914
00:23:00,590 --> 00:23:00,600
여기서 속성을 상수 시간 안에 정확하게 업데이트할 수 있습니다. 따라서
 

915
00:23:00,600 --> 00:23:03,149
여기서 속성을 상수 시간 안에 정확하게 업데이트할 수 있습니다. 따라서
순서 변경을 할 때 H 시간 안에

916
00:23:03,149 --> 00:23:03,159
순서 변경을 할 때 H 시간 안에
 

917
00:23:03,159 --> 00:23:04,990
순서 변경을 할 때 H 시간 안에
이

918
00:23:04,990 --> 00:23:05,000
이
 

919
00:23:05,000 --> 00:23:07,269
이
상수 시간 알고리즘을 H번 호출하므로

920
00:23:07,269 --> 00:23:07,279
상수 시간 알고리즘을 H번 호출하므로
 

921
00:23:07,279 --> 00:23:10,590
상수 시간 알고리즘을 H번 호출하므로
상수 개수의 서브트리

922
00:23:10,590 --> 00:23:10,600
상수 개수의 서브트리
 

923
00:23:10,600 --> 00:23:12,750
상수 개수의 서브트리
속성을 업데이트할 수 있습니다. 이것은 매우 강력한 데이터

924
00:23:12,750 --> 00:23:12,760
속성을 업데이트할 수 있습니다. 이것은 매우 강력한 데이터
 

925
00:23:12,760 --> 00:23:14,549
속성을 업데이트할 수 있습니다. 이것은 매우 강력한 데이터
구조이며, 논증은 매우 유용합니다.

926
00:23:14,549 --> 00:23:14,559
구조이며, 논증은 매우 유용합니다.
 

927
00:23:14,559 --> 00:23:16,190
구조이며, 논증은 매우 유용합니다.
문제 풀이에 활용하게 될 것이고,

928
00:23:16,190 --> 00:23:17,990
문제 풀이에 활용하게 될 것이고,
 

929
00:23:17,990 --> 00:23:18,000

 

930
00:23:18,000 --> 00:23:21,310

오늘 다시 사용하겠습니다.

931
00:23:21,310 --> 00:23:21,320
오늘 다시 사용하겠습니다.
 

932
00:23:21,320 --> 00:23:27,070
오늘 다시 사용하겠습니다.
서브트리

933
00:23:27,070 --> 00:23:27,080

 

934
00:23:27,080 --> 00:23:30,190

속성의 몇 가지 예를 들어보겠습니다. 일반적인 예로는

935
00:23:30,190 --> 00:23:35,310
속성의 몇 가지 예를 들어보겠습니다. 일반적인 예로는
 

936
00:23:35,310 --> 00:23:39,789

 

937
00:23:39,789 --> 00:23:42,990

 

938
00:23:42,990 --> 00:23:45,470

 

939
00:23:45,470 --> 00:23:45,480

 

940
00:23:45,480 --> 00:23:49,190


941
00:23:49,190 --> 00:23:56,669

 

942
00:23:56,669 --> 00:23:56,679

 

943
00:23:56,679 --> 00:23:59,230

서브트리의 각 노드의 합, 곱, 최소값, 최대값, 제곱합 등이 있습니다. 실제로

944
00:23:59,230 --> 00:23:59,240
서브트리의 각 노드의 합, 곱, 최소값, 최대값, 제곱합 등이 있습니다. 실제로
 

945
00:23:59,240 --> 00:24:01,110
서브트리의 각 노드의 합, 곱, 최소값, 최대값, 제곱합 등이 있습니다. 실제로
서브트리 크기가 그러한 예입니다.

946
00:24:01,110 --> 00:24:03,230
서브트리 크기가 그러한 예입니다.
 

947
00:24:03,230 --> 00:24:03,240

 

948
00:24:03,240 --> 00:24:05,909

서브트리의 모든 노드에 대해 값 1의 합입니다. 즉,

949
00:24:05,909 --> 00:24:07,149
서브트리의 모든 노드에 대해 값 1의 합입니다. 즉,
 

950
00:24:07,149 --> 00:24:07,159

 

951
00:24:07,159 --> 00:24:09,149

노드의 개수를 세는 다른 방법입니다. 또한

952
00:24:09,149 --> 00:24:11,350
노드의 개수를 세는 다른 방법입니다. 또한
 

953
00:24:11,350 --> 00:24:11,360

 

954
00:24:11,360 --> 00:24:12,789

노드의 키의 합, 노드의

955
00:24:12,789 --> 00:24:12,799
노드의 키의 합, 노드의
 

956
00:24:12,799 --> 00:24:14,630
노드의 키의 합, 노드의
최대 키,

957
00:24:14,630 --> 00:24:14,640
최대 키,
 

958
00:24:14,640 --> 00:24:16,789
최대 키,

959
00:24:16,789 --> 00:24:19,750

 

960
00:24:19,750 --> 00:24:19,760

 

961
00:24:19,760 --> 00:24:21,950

노드의 최대값 등 어떤

962
00:24:21,950 --> 00:24:21,960
노드의 최대값 등 어떤
 

963
00:24:21,960 --> 00:24:23,470
노드의 최대값 등 어떤
속성이든 사용할 수 있습니다. 키일 필요도 없고, 다른 어떤 속성일 필요도

964
00:24:23,470 --> 00:24:23,480
속성이든 사용할 수 있습니다. 키일 필요도 없고, 다른 어떤 속성일 필요도
 

965
00:24:23,480 --> 00:24:25,029
속성이든 사용할 수 있습니다. 키일 필요도 없고, 다른 어떤 속성일 필요도
없습니다.

966
00:24:25,029 --> 00:24:25,039
없습니다.
 

967
00:24:25,039 --> 00:24:26,830
없습니다.
특히,

968
00:24:26,830 --> 00:24:26,840
특히,
 

969
00:24:26,840 --> 00:24:28,669
특히,
모든 합과 곱을 가져와서

970
00:24:28,669 --> 00:24:30,269
모든 합과 곱을 가져와서
 

971
00:24:30,269 --> 00:24:31,430

 

972
00:24:31,430 --> 00:24:31,440

 

973
00:24:31,440 --> 00:24:32,389

하위

974
00:24:32,389 --> 00:24:32,399
하위
 

975
00:24:32,399 --> 00:24:35,590
하위
트리에 대해서만 생각하고 하향식으로 유지하는 한 매우 강력합니다. 하지만 유지 관리할 수 없는 몇 가지 예가 있습니다.

976
00:24:35,590 --> 00:24:35,600
트리에 대해서만 생각하고 하향식으로 유지하는 한 매우 강력합니다. 하지만 유지 관리할 수 없는 몇 가지 예가 있습니다.
 

977
00:24:35,600 --> 00:24:37,389
트리에 대해서만 생각하고 하향식으로 유지하는 한 매우 강력합니다. 하지만 유지 관리할 수 없는 몇 가지 예가 있습니다.

978
00:24:37,389 --> 00:24:37,399

 

979
00:24:37,399 --> 00:24:40,950


980
00:24:40,950 --> 00:24:40,960

 

981
00:24:40,960 --> 00:24:43,510


982
00:24:43,510 --> 00:24:43,520

 

983
00:24:43,520 --> 00:24:47,430

노드 인덱스는 유지 관리할 수 없습니다.

984
00:24:47,430 --> 00:24:50,310

 

985
00:24:50,310 --> 00:24:50,320

 

986
00:24:50,320 --> 00:24:51,909

증강에 너무 흥분해서

987
00:24:51,909 --> 00:24:51,919
증강에 너무 흥분해서
 

988
00:24:51,919 --> 00:24:54,149
증강에 너무 흥분해서
모든 것을 할 수 있다고 생각할 수도 있습니다. 예를 들어,

989
00:24:54,149 --> 00:24:54,159
모든 것을 할 수 있다고 생각할 수도 있습니다. 예를 들어,
 

990
00:24:54,159 --> 00:24:56,789
모든 것을 할 수 있다고 생각할 수도 있습니다. 예를 들어,
하위 트리를 지원해야 하거나, 전역적으로 접근해서

991
00:24:56,789 --> 00:24:59,389
하위 트리를 지원해야 하거나, 전역적으로 접근해서
 

992
00:24:59,389 --> 00:24:59,399

 

993
00:24:59,399 --> 00:25:01,990

트리의 첫 번째 노드가 무엇인지 알고 싶다고 가정해 보겠습니다. 그러면

994
00:25:01,990 --> 00:25:02,000
트리의 첫 번째 노드가 무엇인지 알고 싶다고 가정해 보겠습니다. 그러면
 

995
00:25:02,000 --> 00:25:03,070
트리의 첫 번째 노드가 무엇인지 알고 싶다고 가정해 보겠습니다. 그러면
데이터 구조

996
00:25:03,070 --> 00:25:03,080
데이터 구조
 

997
00:25:03,080 --> 00:25:04,909
데이터 구조
증강을 사용하여 모든 노드에

998
00:25:04,909 --> 00:25:04,919
증강을 사용하여 모든 노드에
 

999
00:25:04,919 --> 00:25:08,310
증강을 사용하여 모든 노드에
인덱스(0부터 n-

1000
00:25:08,310 --> 00:25:08,320
인덱스(0부터 n-
 

1001
00:25:08,320 --> 00:25:11,470
인덱스(0부터 n-
1까지)를 저장할 수 있습니다. 하지만 이렇게 효율적으로 유지할 수는 없습니다.

1002
00:25:11,470 --> 00:25:14,149
1까지)를 저장할 수 있습니다. 하지만 이렇게 효율적으로 유지할 수는 없습니다.
 

1003
00:25:14,149 --> 00:25:14,159

 

1004
00:25:14,159 --> 00:25:17,070

순회 순서의 맨 처음에 삽입하면 모든 인덱스가

1005
00:25:17,070 --> 00:25:17,080
순회 순서의 맨 처음에 삽입하면 모든 인덱스가
 

1006
00:25:17,080 --> 00:25:19,269
순회 순서의 맨 처음에 삽입하면 모든 인덱스가
변경되기 때문입니다. 예를 들어

1007
00:25:19,269 --> 00:25:19,279
변경되기 때문입니다. 예를 들어
 

1008
00:25:19,279 --> 00:25:22,430
변경되기 때문입니다. 예를 들어
편집을 생각해 보겠습니다. 여기에 새 노드를 삽입하면

1009
00:25:22,430 --> 00:25:22,440
편집을 생각해 보겠습니다. 여기에 새 노드를 삽입하면
 

1010
00:25:22,440 --> 00:25:25,029
편집을 생각해 보겠습니다. 여기에 새 노드를 삽입하면
이 노드의 인덱스는 0에서 1로,

1011
00:25:25,029 --> 00:25:25,039
이 노드의 인덱스는 0에서 1로,
 

1012
00:25:25,039 --> 00:25:26,909
이 노드의 인덱스는 0에서 1로,
이 노드의 인덱스는 1에서

1013
00:25:26,909 --> 00:25:26,919
이 노드의 인덱스는 1에서
 

1014
00:25:26,919 --> 00:25:28,789
이 노드의 인덱스는 1에서
2로, 이 노드는 2에서

1015
00:25:28,789 --> 00:25:28,799
2로, 이 노드는 2에서
 

1016
00:25:28,799 --> 00:25:30,510
2로, 이 노드는 2에서
3으로 변경됩니다. 모든 노드의 인덱스는 변경됩니다.

1017
00:25:30,510 --> 00:25:30,520
3으로 변경됩니다. 모든 노드의 인덱스는 변경됩니다.
 

1018
00:25:30,520 --> 00:25:33,389
3으로 변경됩니다. 모든 노드의 인덱스는 변경됩니다.
인덱스는 하위 트리의 속성이 아니기 때문에 유지

1019
00:25:33,389 --> 00:25:33,399
인덱스는 하위 트리의 속성이 아니기 때문에 유지
 

1020
00:25:33,399 --> 00:25:35,350
인덱스는 하위 트리의 속성이 아니기 때문에 유지
관리할 수 없습니다. 인덱스는 하위 트리에

1021
00:25:35,350 --> 00:25:35,360
관리할 수 없습니다. 인덱스는 하위 트리에
 

1022
00:25:35,360 --> 00:25:37,070
관리할 수 없습니다. 인덱스는 하위 트리에
의존하기 때문입니다.

1023
00:25:37,070 --> 00:25:37,080
의존하기 때문입니다.
 

1024
00:25:37,080 --> 00:25:38,389
의존하기 때문입니다.
트리의 모든 노드에 의존하거나,

1025
00:25:38,389 --> 00:25:38,399
트리의 모든 노드에 의존하거나,
 

1026
00:25:38,399 --> 00:25:40,750
트리의 모든 노드에 의존하거나,
왼쪽에 있는 모든 노드, 즉 모든 선행 노드에 의존합니다.

1027
00:25:40,750 --> 00:25:40,760
왼쪽에 있는 모든 노드, 즉 모든 선행 노드에 의존합니다.
 

1028
00:25:40,760 --> 00:25:43,430
왼쪽에 있는 모든 노드, 즉 모든 선행 노드에 의존합니다.
예를 들어, 이 노드의 인덱스는

1029
00:25:43,430 --> 00:25:45,070
예를 들어, 이 노드의 인덱스는
 

1030
00:25:45,070 --> 00:25:45,080

 

1031
00:25:45,080 --> 00:25:46,870

왼쪽에 있는 노드의 개수에 따라 달라지는데, 이 노드의 서브트리에는 해당 노드가 포함되지 않습니다.

1032
00:25:46,870 --> 00:25:46,880
왼쪽에 있는 노드의 개수에 따라 달라지는데, 이 노드의 서브트리에는 해당 노드가 포함되지 않습니다.
 

1033
00:25:46,880 --> 00:25:49,350
왼쪽에 있는 노드의 개수에 따라 달라지는데, 이 노드의 서브트리에는 해당 노드가 포함되지 않습니다.
따라서 트리

1034
00:25:49,350 --> 00:25:49,360
따라서 트리
 

1035
00:25:49,360 --> 00:25:51,710
따라서 트리
의 전역 속성을 사용하지 않도록 주의해야 합니다.

1036
00:25:51,710 --> 00:25:54,149
의 전역 속성을 사용하지 않도록 주의해야 합니다.
 

1037
00:25:54,149 --> 00:25:54,159

 

1038
00:25:54,159 --> 00:25:56,430

서브트리

1039
00:25:56,430 --> 00:25:56,440
서브트리
 

1040
00:25:56,440 --> 00:26:00,870
서브트리
속성만 사용할 수 있습니다. 또 다른 예로 깊이(depth)가 있습니다. 깊이는

1041
00:26:00,870 --> 00:26:04,990
속성만 사용할 수 있습니다. 또 다른 예로 깊이(depth)가 있습니다. 깊이는
 

1042
00:26:04,990 --> 00:26:05,000

 

1043
00:26:05,000 --> 00:26:08,190

관리하기가 까다롭지만, 아직 그 이유가 명확하지 않습니다. 잠시 후에

1044
00:26:08,190 --> 00:26:08,200
관리하기가 까다롭지만, 아직 그 이유가 명확하지 않습니다. 잠시 후에
 

1045
00:26:08,200 --> 00:26:12,350
관리하기가 까다롭지만, 아직 그 이유가 명확하지 않습니다. 잠시 후에
살펴보겠습니다.

1046
00:26:12,350 --> 00:26:12,360

 

1047
00:26:12,360 --> 00:26:16,389

오늘 나머지 내용은 시간 복잡도

1048
00:26:16,389 --> 00:26:16,399
오늘 나머지 내용은 시간 복잡도
 

1049
00:26:16,399 --> 00:26:21,710
오늘 나머지 내용은 시간 복잡도
H에서 log n으로의 전환에 관한 것으로,

1050
00:26:21,710 --> 00:26:21,720
H에서 log n으로의 전환에 관한 것으로,
 

1051
00:26:21,720 --> 00:26:24,510
H에서 log n으로의 전환에 관한 것으로,
이 슬라이드에서 보여주고 있습니다. 따라서

1052
00:26:24,510 --> 00:26:24,520
이 슬라이드에서 보여주고 있습니다. 따라서
 

1053
00:26:24,520 --> 00:26:25,630
이 슬라이드에서 보여주고 있습니다. 따라서
현재 시점에서

1054
00:26:25,630 --> 00:26:25,640
현재 시점에서
 

1055
00:26:25,640 --> 00:26:27,870
현재 시점에서
시퀀스 데이터

1056
00:26:27,870 --> 00:26:27,880
시퀀스 데이터
 

1057
00:26:27,880 --> 00:26:30,149
시퀀스 데이터
구조의 모든 연산을 생성(

1058
00:26:30,149 --> 00:26:30,159
구조의 모든 연산을 생성(
 

1059
00:26:30,159 --> 00:26:31,549
구조의 모든 연산을 생성(
build)과 반복(iterate)을 제외하고 시간 복잡도 H로 수행할 수 있다고 생각해야 합니다. 생성과 반복은

1060
00:26:31,549 --> 00:26:31,559
build)과 반복(iterate)을 제외하고 시간 복잡도 H로 수행할 수 있다고 생각해야 합니다. 생성과 반복은
 

1061
00:26:31,559 --> 00:26:34,310
build)과 반복(iterate)을 제외하고 시간 복잡도 H로 수행할 수 있다고 생각해야 합니다. 생성과 반복은
선형 시간입니다. 또한 집합(

1062
00:26:34,310 --> 00:26:34,320
선형 시간입니다. 또한 집합(
 

1063
00:26:34,320 --> 00:26:36,750
선형 시간입니다. 또한 집합(
set) 연산을 제외하고 시간 복잡도 H로 수행할 수 있으며,

1064
00:26:36,750 --> 00:26:36,760
set) 연산을 제외하고 시간 복잡도 H로 수행할 수 있으며,
 

1065
00:26:36,760 --> 00:26:38,630
set) 연산을 제외하고 시간 복잡도 H로 수행할 수 있으며,
생성과 반복은

1066
00:26:38,630 --> 00:26:38,640
생성과 반복은
 

1067
00:26:38,640 --> 00:26:41,870
생성과 반복은
각각 N log n과 n이 걸립니다. 우리의 목표는 시간 복잡도

1068
00:26:41,870 --> 00:26:44,830
각각 N log n과 n이 걸립니다. 우리의 목표는 시간 복잡도
 

1069
00:26:44,830 --> 00:26:44,840

 

1070
00:26:44,840 --> 00:26:47,909


1071
00:26:47,909 --> 00:26:47,919

 

1072
00:26:47,919 --> 00:26:53,070

H를 log n으로 제한하는 것입니다. 완벽 트리(Perfect Tree)처럼

1073
00:26:53,070 --> 00:26:54,990
H를 log n으로 제한하는 것입니다. 완벽 트리(Perfect Tree)처럼
 

1074
00:26:54,990 --> 00:26:55,000

 

1075
00:26:55,000 --> 00:26:57,549

높이가 로그 함수인 트리가 존재하기 때문에 어느 정도 가능하다고 알고 있지만,

1076
00:26:57,549 --> 00:26:59,590
높이가 로그 함수인 트리가 존재하기 때문에 어느 정도 가능하다고 알고 있지만,
 

1077
00:26:59,590 --> 00:27:01,830

 

1078
00:27:01,830 --> 00:27:01,840

 

1079
00:27:01,840 --> 00:27:03,549

주의해야 할 점도 있습니다.  이런 체인처럼 나쁜 트리는... 음,

1080
00:27:03,549 --> 00:27:06,149
주의해야 할 점도 있습니다.  이런 체인처럼 나쁜 트리는... 음,
 

1081
00:27:06,149 --> 00:27:08,950

 

1082
00:27:08,950 --> 00:27:08,960

 

1083
00:27:08,960 --> 00:27:13,430

H가 log n과 같으면 이것을

1084
00:27:13,430 --> 00:27:13,440
H가 log n과 같으면 이것을
 

1085
00:27:13,440 --> 00:27:18,430
H가 log n과 같으면 이것을
균형 이진

1086
00:27:18,430 --> 00:27:18,440

 

1087
00:27:18,440 --> 00:27:20,789

트리라고 합니다. 세상에는 균형 이진 트리

1088
00:27:20,789 --> 00:27:20,799
트리라고 합니다. 세상에는 균형 이진 트리
 

1089
00:27:20,799 --> 00:27:23,549
트리라고 합니다. 세상에는 균형 이진 트리
가 많습니다. 아마 십여 개에서 스무 개 정도 될 겁니다.

1090
00:27:23,549 --> 00:27:23,559
가 많습니다. 아마 십여 개에서 스무 개 정도 될 겁니다.
 

1091
00:27:23,559 --> 00:27:25,830
가 많습니다. 아마 십여 개에서 스무 개 정도 될 겁니다.
다양한 데이터 구조가 있죠.

1092
00:27:25,830 --> 00:27:25,840
다양한 데이터 구조가 있죠.
 

1093
00:27:25,840 --> 00:27:29,350
다양한 데이터 구조가 있죠.
질문입니다. 안녕하세요. 당신은

1094
00:27:29,350 --> 00:27:29,360
질문입니다. 안녕하세요. 당신은
 

1095
00:27:29,360 --> 00:27:31,269
질문입니다. 안녕하세요. 당신은
전역적인 수준에서 생각하지 말고

1096
00:27:31,269 --> 00:27:31,279
전역적인 수준에서 생각하지 말고
 

1097
00:27:31,279 --> 00:27:32,750
전역적인 수준에서 생각하지 말고
하위 수준에서 생각하라고 하셨는데, 그게

1098
00:27:32,750 --> 00:27:32,760
하위 수준에서 생각하라고 하셨는데, 그게
 

1099
00:27:32,760 --> 00:27:33,950
하위 수준에서 생각하라고 하셨는데, 그게
무슨 뜻인지 설명해 주시겠어요?

1100
00:27:33,950 --> 00:27:33,960
무슨 뜻인지 설명해 주시겠어요?
 

1101
00:27:33,960 --> 00:27:36,510
무슨 뜻인지 설명해 주시겠어요?
속성이

1102
00:27:36,510 --> 00:27:36,520
속성이
 

1103
00:27:36,520 --> 00:27:39,549
속성이
하위 트리에 로컬이라는 것과

1104
00:27:39,549 --> 00:27:39,559
하위 트리에 로컬이라는 것과
 

1105
00:27:39,559 --> 00:27:42,269
하위 트리에 로컬이라는 것과
전역이라는 것은 무엇을 의미하나요? 가장 좋은 설명은 이

1106
00:27:42,269 --> 00:27:42,279
전역이라는 것은 무엇을 의미하나요? 가장 좋은 설명은 이
 

1107
00:27:42,279 --> 00:27:44,310
전역이라는 것은 무엇을 의미하나요? 가장 좋은 설명은 이
정의이지만, 가장

1108
00:27:44,310 --> 00:27:44,320
정의이지만, 가장
 

1109
00:27:44,320 --> 00:27:45,950
정의이지만, 가장
직관적인 정의는 아닐 수도 있습니다. 제가 말하는 것은

1110
00:27:45,950 --> 00:27:47,870
직관적인 정의는 아닐 수도 있습니다. 제가 말하는 것은
 

1111
00:27:47,870 --> 00:27:47,880

 

1112
00:27:47,880 --> 00:27:49,350

왼쪽 자식과 오른쪽 자식에 대한 정보만 알면 계산할 수 있는 것입니다. 이것이

1113
00:27:49,350 --> 00:27:51,310
왼쪽 자식과 오른쪽 자식에 대한 정보만 알면 계산할 수 있는 것입니다. 이것이
 

1114
00:27:51,310 --> 00:27:51,320

 

1115
00:27:51,320 --> 00:27:52,830

하위 속성의 의미입니다. 그리고 이러한 것들만 유지

1116
00:27:52,830 --> 00:27:52,840
하위 속성의 의미입니다. 그리고 이러한 것들만 유지
 

1117
00:27:52,840 --> 00:27:54,350
하위 속성의 의미입니다. 그리고 이러한 것들만 유지
관리할 수 있습니다.

1118
00:27:54,350 --> 00:27:54,360
관리할 수 있습니다.
 

1119
00:27:54,360 --> 00:27:55,870
관리할 수 있습니다.
왜냐하면 이 경로를 따라 올라가면서

1120
00:27:55,870 --> 00:27:55,880
왜냐하면 이 경로를 따라 올라가면서
 

1121
00:27:55,880 --> 00:27:58,789
왜냐하면 이 경로를 따라 올라가면서
쉽게 업데이트할 수 있는 것들만 유지 관리할 수 있기 때문입니다.

1122
00:27:58,789 --> 00:27:58,799
쉽게 업데이트할 수 있는 것들만 유지 관리할 수 있기 때문입니다.
 

1123
00:27:58,799 --> 00:28:01,870
쉽게 업데이트할 수 있는 것들만 유지 관리할 수 있기 때문입니다.
반대로

1124
00:28:01,870 --> 00:28:04,630
반대로
 

1125
00:28:04,630 --> 00:28:04,640

 

1126
00:28:04,640 --> 00:28:07,509

인덱스 I과 같은 전역 속성은 전역적입니다. 특히

1127
00:28:07,509 --> 00:28:10,470
인덱스 I과 같은 전역 속성은 전역적입니다. 특히
 

1128
00:28:10,470 --> 00:28:10,480

 

1129
00:28:10,480 --> 00:28:12,509

노드를 하나 변경하거나 추가하면 모든 노드의 속성이

1130
00:28:12,509 --> 00:28:12,519
노드를 하나 변경하거나 추가하면 모든 노드의 속성이
 

1131
00:28:12,519 --> 00:28:14,430
노드를 하나 변경하거나 추가하면 모든 노드의 속성이
변경되기 때문입니다. 이것은 전역 속성의 극단적인 예입니다.

1132
00:28:14,430 --> 00:28:14,440
변경되기 때문입니다. 이것은 전역 속성의 극단적인 예입니다.
 

1133
00:28:14,440 --> 00:28:16,830
변경되기 때문입니다. 이것은 전역 속성의 극단적인 예입니다.
우리는 지역 속성이라는 개념을 원하는데, 왜냐하면

1134
00:28:16,830 --> 00:28:18,310
우리는 지역 속성이라는 개념을 원하는데, 왜냐하면
 

1135
00:28:18,310 --> 00:28:21,190

 

1136
00:28:21,190 --> 00:28:21,200

 

1137
00:28:21,200 --> 00:28:23,830

실제로 다시 계산할 수 있는 것만 다시 계산할 수 있기 때문입니다. 이해가 되셨기를 바랍니다. 네,

1138
00:28:23,830 --> 00:28:26,110
실제로 다시 계산할 수 있는 것만 다시 계산할 수 있기 때문입니다. 이해가 되셨기를 바랍니다. 네,
 

1139
00:28:26,110 --> 00:28:31,710

 

1140
00:28:31,710 --> 00:28:31,720

 

1141
00:28:31,720 --> 00:28:34,070

맞습니다.  아,

1142
00:28:34,070 --> 00:28:34,080
맞습니다.  아,
 

1143
00:28:34,080 --> 00:28:35,669
맞습니다.  아,
잠깐만요. 생각해 봅시다.

1144
00:28:35,669 --> 00:28:35,679
잠깐만요. 생각해 봅시다.
 

1145
00:28:35,679 --> 00:28:37,430
잠깐만요. 생각해 봅시다.
트리에 새로운 부모 노드를 추가한다고 가정해 볼게요. 이건

1146
00:28:37,430 --> 00:28:37,440
트리에 새로운 부모 노드를 추가한다고 가정해 볼게요. 이건
 

1147
00:28:37,440 --> 00:28:40,630
트리에 새로운 부모 노드를 추가한다고 가정해 볼게요. 이건
우리가 지금까지 해본 적 없는 일이죠.

1148
00:28:40,630 --> 00:28:40,640
우리가 지금까지 해본 적 없는 일이죠.
 

1149
00:28:40,640 --> 00:28:43,509
우리가 지금까지 해본 적 없는 일이죠.
하지만 설령 그렇게 한다고 해도 어떤 서브 트리가

1150
00:28:43,509 --> 00:28:43,519
하지만 설령 그렇게 한다고 해도 어떤 서브 트리가
 

1151
00:28:43,519 --> 00:28:46,509
하지만 설령 그렇게 한다고 해도 어떤 서브 트리가
바뀔까요?

1152
00:28:46,509 --> 00:28:46,519
바뀔까요?
 

1153
00:28:46,519 --> 00:28:49,149
바뀔까요?
이 노드만 바뀔 거예요.

1154
00:28:49,149 --> 00:28:49,159
이 노드만 바뀔 거예요.
 

1155
00:28:49,159 --> 00:28:51,070
이 노드만 바뀔 거예요.
완전히 새로운 서브 트리가 생기는 거죠. 하지만 이 노드의 서브 트리는

1156
00:28:51,070 --> 00:28:51,080
완전히 새로운 서브 트리가 생기는 거죠. 하지만 이 노드의 서브 트리는
 

1157
00:28:51,080 --> 00:28:52,909
완전히 새로운 서브 트리가 생기는 거죠. 하지만 이 노드의 서브 트리는
전혀 변하지 않아요.

1158
00:28:52,909 --> 00:28:52,919
전혀 변하지 않아요.
 

1159
00:28:52,919 --> 00:28:54,070
전혀 변하지 않아요.
서브 트리는 항상 아래쪽을 향하고 있으니까요.

1160
00:28:54,070 --> 00:28:54,080
서브 트리는 항상 아래쪽을 향하고 있으니까요.
 

1161
00:28:54,080 --> 00:28:57,149
서브 트리는 항상 아래쪽을 향하고 있으니까요.
만약 새로운 루트 노드를 추가한다면,

1162
00:28:57,149 --> 00:28:57,159
만약 새로운 루트 노드를 추가한다면,
 

1163
00:28:57,159 --> 00:29:00,110
만약 새로운 루트 노드를 추가한다면,
서브 트리는 하나만 바뀌겠죠.

1164
00:29:00,110 --> 00:29:00,120
서브 트리는 하나만 바뀌겠죠.
 

1165
00:29:00,120 --> 00:29:03,630
서브 트리는 하나만 바뀌겠죠.
크기는 서브 트리의 속성이에요.

1166
00:29:03,630 --> 00:29:03,640
크기는 서브 트리의 속성이에요.
 

1167
00:29:03,640 --> 00:29:05,549
크기는 서브 트리의 속성이에요.
트리를 완전히 다시 그릴 수도 있는데, 이

1168
00:29:05,549 --> 00:29:05,559
트리를 완전히 다시 그릴 수도 있는데, 이
 

1169
00:29:05,559 --> 00:29:07,149
트리를 완전히 다시 그릴 수도 있는데, 이
작업은

1170
00:29:07,149 --> 00:29:07,159
작업은
 

1171
00:29:07,159 --> 00:29:09,149
작업은
모든 것을 다시 계산해야 해요. 그러니까

1172
00:29:09,149 --> 00:29:10,750
모든 것을 다시 계산해야 해요. 그러니까
 

1173
00:29:10,750 --> 00:29:10,760

 

1174
00:29:10,760 --> 00:29:12,630

트리에서 할 수 있는 작업에는 한계가 있지만,

1175
00:29:12,630 --> 00:29:12,640
트리에서 할 수 있는 작업에는 한계가 있지만,
 

1176
00:29:12,640 --> 00:29:16,149
트리에서 할 수 있는 작업에는 한계가 있지만,
지난 수업과 오늘 수업에서 배운 모든 것을 할 수 있을 거예요. 우리는

1177
00:29:16,149 --> 00:29:16,159
지난 수업과 오늘 수업에서 배운 모든 것을 할 수 있을 거예요. 우리는
 

1178
00:29:16,159 --> 00:29:17,310
지난 수업과 오늘 수업에서 배운 모든 것을 할 수 있을 거예요. 우리는
이런

1179
00:29:17,310 --> 00:29:17,320
이런
 

1180
00:29:17,320 --> 00:29:19,990
이런
확장을 할 수 있으니까요. 모든 이진 트리에 해당되는 기능은 아니지만,

1181
00:29:19,990 --> 00:29:21,669
확장을 할 수 있으니까요. 모든 이진 트리에 해당되는 기능은 아니지만,
 

1182
00:29:21,669 --> 00:29:21,679

 

1183
00:29:21,679 --> 00:29:23,350

우리가 다룰 트리에는 적용될 거예요.

1184
00:29:23,350 --> 00:29:25,990
우리가 다룰 트리에는 적용될 거예요.
 

1185
00:29:25,990 --> 00:29:26,000

 

1186
00:29:26,000 --> 00:29:30,590

최소 이진 트리란 무엇일까요? 네, 잠시 후에

1187
00:29:30,590 --> 00:29:33,149

 

1188
00:29:33,149 --> 00:29:36,190

 

1189
00:29:36,190 --> 00:29:45,430

 

1190
00:29:45,430 --> 00:29:45,440

 

1191
00:29:45,440 --> 00:29:48,029

트리를 가지고 실제로 무엇을 할 건지 설명하면 좀 더 이해가 될 거예요. 우리는

1192
00:29:48,029 --> 00:29:52,909
트리를 가지고 실제로 무엇을 할 건지 설명하면 좀 더 이해가 될 거예요. 우리는
 

1193
00:29:52,909 --> 00:29:52,919

 

1194
00:29:52,919 --> 00:29:55,149

트리를 조작하기 위한 새로운 도구가 필요해요. 지금까지는 그렇게 해왔죠.  우리는

1195
00:29:55,149 --> 00:29:55,159
트리를 조작하기 위한 새로운 도구가 필요해요. 지금까지는 그렇게 해왔죠.  우리는
 

1196
00:29:55,159 --> 00:29:58,110
트리를 조작하기 위한 새로운 도구가 필요해요. 지금까지는 그렇게 해왔죠.  우리는
몇 가지 항목을 교환하고

1197
00:29:58,110 --> 00:29:58,120
몇 가지 항목을 교환하고
 

1198
00:29:58,120 --> 00:30:00,110
몇 가지 항목을 교환하고
리프 노드를 추가하거나 제거하는 작업을 했습니다. 하지만 그것만으로는 충분하지 않습니다.

1199
00:30:00,110 --> 00:30:01,990
리프 노드를 추가하거나 제거하는 작업을 했습니다. 하지만 그것만으로는 충분하지 않습니다.
 

1200
00:30:01,990 --> 00:30:02,000

 

1201
00:30:02,000 --> 00:30:04,430

로그 스케일의 높이를 보장하려면 다른 작업이 필요합니다. 바로

1202
00:30:04,430 --> 00:30:06,710
로그 스케일의 높이를 보장하려면 다른 작업이 필요합니다. 바로
 

1203
00:30:06,710 --> 00:30:11,110

 

1204
00:30:11,110 --> 00:30:11,120

 

1205
00:30:11,120 --> 00:30:13,110

회전(rotation)입니다. 이 회전은

1206
00:30:13,110 --> 00:30:16,750
회전(rotation)입니다. 이 회전은
 

1207
00:30:16,750 --> 00:30:16,760

 

1208
00:30:16,760 --> 00:30:19,669

트리의 균형을 맞추는 도구일 뿐이므로 트리가 나타내는

1209
00:30:19,669 --> 00:30:19,679
트리의 균형을 맞추는 도구일 뿐이므로 트리가 나타내는
 

1210
00:30:19,679 --> 00:30:21,630
트리의 균형을 맞추는 도구일 뿐이므로 트리가 나타내는
데이터는 변경해서는 안 됩니다.

1211
00:30:21,630 --> 00:30:23,549
데이터는 변경해서는 안 됩니다.
 

1212
00:30:23,549 --> 00:30:23,559

 

1213
00:30:23,559 --> 00:30:26,750

트리가 나타내는 데이터는 무엇일까요? 바로 순회 순서입니다. 순회 순서는

1214
00:30:26,750 --> 00:30:26,760
트리가 나타내는 데이터는 무엇일까요? 바로 순회 순서입니다. 순회 순서는
 

1215
00:30:26,760 --> 00:30:28,909
트리가 나타내는 데이터는 무엇일까요? 바로 순회 순서입니다. 순회 순서는
SACRAN(Sacramental Rules of Reversal Order)으로 정의되어 있어 건드릴 수 없습니다. 순회 순서는

1216
00:30:28,909 --> 00:30:31,190
SACRAN(Sacramental Rules of Reversal Order)으로 정의되어 있어 건드릴 수 없습니다. 순회 순서는
 

1217
00:30:31,190 --> 00:30:31,200

 

1218
00:30:31,200 --> 00:30:32,669

집합 또는 시퀀스를 사용하는지에 따라 두 가지 방식으로 이미 정의되어 있습니다.

1219
00:30:32,669 --> 00:30:35,950
집합 또는 시퀀스를 사용하는지에 따라 두 가지 방식으로 이미 정의되어 있습니다.
 

1220
00:30:35,950 --> 00:30:38,029

 

1221
00:30:38,029 --> 00:30:38,039

 

1222
00:30:38,039 --> 00:30:40,830

따라서 순회 순서를 변경하지 않는 방식으로 트리를 수정해야 합니다. 이는 중복성을 이용하는 것입니다.

1223
00:30:40,830 --> 00:30:42,310
따라서 순회 순서를 변경하지 않는 방식으로 트리를 수정해야 합니다. 이는 중복성을 이용하는 것입니다.
 

1224
00:30:42,310 --> 00:30:42,320

 

1225
00:30:42,320 --> 00:30:44,110

순회 순서를 배열에 저장하면

1226
00:30:44,110 --> 00:30:44,120
순회 순서를 배열에 저장하면
 

1227
00:30:44,120 --> 00:30:45,950
순회 순서를 배열에 저장하면
주어진 순서를 나타내는 표현은 하나뿐이지만,

1228
00:30:45,950 --> 00:30:45,960
주어진 순서를 나타내는 표현은 하나뿐이지만,
 

1229
00:30:45,960 --> 00:30:48,350
주어진 순서를 나타내는 표현은 하나뿐이지만,
트리에서는 여러 가지

1230
00:30:48,350 --> 00:30:48,360
트리에서는 여러 가지
 

1231
00:30:48,360 --> 00:30:50,870
트리에서는 여러 가지
표현이 가능합니다. 긴 직선 형태일 수도 있고,

1232
00:30:50,870 --> 00:30:50,880
표현이 가능합니다. 긴 직선 형태일 수도 있고,
 

1233
00:30:50,880 --> 00:30:52,870
표현이 가능합니다. 긴 직선 형태일 수도 있고,
균형 잡힌 형태일 수도 있으며, 노드

1234
00:30:52,870 --> 00:30:52,880
균형 잡힌 형태일 수도 있으며, 노드
 

1235
00:30:52,880 --> 00:30:54,430
균형 잡힌 형태일 수도 있으며, 노드
에 레이블을 잘 지정하면 정확히 같은 순서를 나타낼 수도 있습니다.

1236
00:30:54,430 --> 00:30:56,669
에 레이블을 잘 지정하면 정확히 같은 순서를 나타낼 수도 있습니다.
 

1237
00:30:56,669 --> 00:30:56,679

 

1238
00:30:56,679 --> 00:30:58,389

사실,

1239
00:30:58,389 --> 00:30:58,399
사실,
 

1240
00:30:58,399 --> 00:30:59,789
사실,
같은

1241
00:30:59,789 --> 00:30:59,799
같은
 

1242
00:30:59,799 --> 00:31:01,629
같은
것을 나타내는 표현은 기하급수적으로 많으며, 우리는 이 중복성을 활용할 것입니다.

1243
00:31:01,629 --> 00:31:01,639
것을 나타내는 표현은 기하급수적으로 많으며, 우리는 이 중복성을 활용할 것입니다.
 

1244
00:31:01,639 --> 00:31:02,950
것을 나타내는 표현은 기하급수적으로 많으며, 우리는 이 중복성을 활용할 것입니다.
순서는 동일하며,

1245
00:31:02,950 --> 00:31:02,960
순서는 동일하며,
 

1246
00:31:02,960 --> 00:31:05,669
순서는 동일하며,
이것은

1247
00:31:05,669 --> 00:31:05,679
이것은
 

1248
00:31:05,679 --> 00:31:20,110
이것은
여러분이

1249
00:31:20,110 --> 00:31:20,120

 

1250
00:31:20,120 --> 00:31:26,149

알아야 할 간단한 내용입니다. 제가 A, X, B, Y,

1251
00:31:26,149 --> 00:31:26,159
알아야 할 간단한 내용입니다. 제가 A, X, B, Y,
 

1252
00:31:26,159 --> 00:31:28,990
알아야 할 간단한 내용입니다. 제가 A, X, B, Y,
C로 레이블을 지정했습니다. 제가 이 다이어그램을

1253
00:31:28,990 --> 00:31:29,000
C로 레이블을 지정했습니다. 제가 이 다이어그램을
 

1254
00:31:29,000 --> 00:31:32,389
C로 레이블을 지정했습니다. 제가 이 다이어그램을
전에 여러 번 그렸다는 것을 알 수 있을 겁니다. 이것은

1255
00:31:32,389 --> 00:31:32,399
전에 여러 번 그렸다는 것을 알 수 있을 겁니다. 이것은
 

1256
00:31:32,399 --> 00:31:34,389
전에 여러 번 그렸다는 것을 알 수 있을 겁니다. 이것은
모든 트리 데이터 구조에서 매우 강력한 도구이며,

1257
00:31:34,389 --> 00:31:34,399
모든 트리 데이터 구조에서 매우 강력한 도구이며,
 

1258
00:31:34,399 --> 00:31:35,950
모든 트리 데이터 구조에서 매우 강력한 도구이며,
대부분의 데이터

1259
00:31:35,950 --> 00:31:35,960
대부분의 데이터
 

1260
00:31:35,960 --> 00:31:42,470
대부분의 데이터
구조에서 사용되는 기능입니다. 이 기능은

1261
00:31:42,470 --> 00:31:42,480

 

1262
00:31:42,480 --> 00:31:52,669

Y의 오른쪽 회전과 X의 왼쪽 회전이라고 합니다. 예를 들어, 제가

1263
00:31:52,669 --> 00:31:56,070

 

1264
00:31:56,070 --> 00:31:56,080

 

1265
00:31:56,080 --> 00:31:58,350

일부 하위 트리를

1266
00:31:58,350 --> 00:31:58,360
일부 하위 트리를
 

1267
00:31:58,360 --> 00:32:01,230
일부 하위 트리를
작은 삼각형으로 블랙박스 처리한 이 트리에서, 노드가

1268
00:32:01,230 --> 00:32:01,240
작은 삼각형으로 블랙박스 처리한 이 트리에서, 노드가
 

1269
00:32:01,240 --> 00:32:03,990
작은 삼각형으로 블랙박스 처리한 이 트리에서, 노드가
왼쪽 자식을 가지고 있다면,

1270
00:32:03,990 --> 00:32:04,000
왼쪽 자식을 가지고 있다면,
 

1271
00:32:04,000 --> 00:32:05,590
왼쪽 자식을 가지고 있다면,
해당 노드를 오른쪽으로 회전시킬 수 있습니다. 즉, 이

1272
00:32:05,590 --> 00:32:05,600
해당 노드를 오른쪽으로 회전시킬 수 있습니다. 즉, 이
 

1273
00:32:05,600 --> 00:32:08,430
해당 노드를 오른쪽으로 회전시킬 수 있습니다. 즉, 이
노드를 90도 회전시키는 것입니다.

1274
00:32:08,430 --> 00:32:08,440
노드를 90도 회전시키는 것입니다.
 

1275
00:32:08,440 --> 00:32:10,310
노드를 90도 회전시키는 것입니다.
또는 이렇게

1276
00:32:10,310 --> 00:32:10,320
또는 이렇게
 

1277
00:32:10,320 --> 00:32:12,230
또는 이렇게
다시 작성하는 것으로 생각할 수도 있습니다.

1278
00:32:12,230 --> 00:32:12,240
다시 작성하는 것으로 생각할 수도 있습니다.
 

1279
00:32:12,240 --> 00:32:14,269
다시 작성하는 것으로 생각할 수도 있습니다.
부모 포인터의 위치도 기억해 두는 것이 좋습니다.

1280
00:32:14,269 --> 00:32:14,279
부모 포인터의 위치도 기억해 두는 것이 좋습니다.
 

1281
00:32:14,279 --> 00:32:17,149
부모 포인터의 위치도 기억해 두는 것이 좋습니다.
이전에는

1282
00:32:17,149 --> 00:32:17,159
이전에는
 

1283
00:32:17,159 --> 00:32:19,070
이전에는
Y의 부모였던 노드가 이제는

1284
00:32:19,070 --> 00:32:20,110
Y의 부모였던 노드가 이제는
 

1285
00:32:20,110 --> 00:32:20,120

 

1286
00:32:20,120 --> 00:32:23,389

X의 부모가 됩니다. 즉, X와 Y의

1287
00:32:23,389 --> 00:32:23,399
X의 부모가 됩니다. 즉, X와 Y의
 

1288
00:32:23,399 --> 00:32:26,590
X의 부모가 됩니다. 즉, X와 Y의
위치가 바뀌는 것입니다. 만약 이러한 요소들을 서로 바꿀 수 없다면

1289
00:32:26,590 --> 00:32:28,710
위치가 바뀌는 것입니다. 만약 이러한 요소들을 서로 바꿀 수 없다면
 

1290
00:32:28,710 --> 00:32:28,720

 

1291
00:32:28,720 --> 00:32:31,629

순회 순서가 바뀔 것입니다. 이 그림에서 X는 Y의

1292
00:32:31,629 --> 00:32:31,639
순회 순서가 바뀔 것입니다. 이 그림에서 X는 Y의
 

1293
00:32:31,639 --> 00:32:34,389
순회 순서가 바뀔 것입니다. 이 그림에서 X는 Y의
왼쪽 하위 트리에 있으므로 Y보다 먼저 옵니다.

1294
00:32:34,389 --> 00:32:37,350
왼쪽 하위 트리에 있으므로 Y보다 먼저 옵니다.
 

1295
00:32:37,350 --> 00:32:37,360

 

1296
00:32:37,360 --> 00:32:39,950

여기서는 Y가 X의 오른쪽 하위 트리에 있으므로 Y보다

1297
00:32:39,950 --> 00:32:39,960
여기서는 Y가 X의 오른쪽 하위 트리에 있으므로 Y보다
 

1298
00:32:39,960 --> 00:32:42,590
여기서는 Y가 X의 오른쪽 하위 트리에 있으므로 Y보다
나중에 옵니다.  두 경우 모두 X가

1299
00:32:42,590 --> 00:32:42,600
나중에 옵니다.  두 경우 모두 X가
 

1300
00:32:42,600 --> 00:32:45,149
나중에 옵니다.  두 경우 모두 X가
Y보다 먼저 옵니다. 실제로 이 모든

1301
00:32:45,149 --> 00:32:45,159
Y보다 먼저 옵니다. 실제로 이 모든
 

1302
00:32:45,159 --> 00:32:46,029
Y보다 먼저 옵니다. 실제로 이 모든

1303
00:32:46,029 --> 00:32:46,039

 

1304
00:32:46,039 --> 00:32:48,830

그림에서 순회 순서는 일관적입니다.

1305
00:32:48,830 --> 00:32:48,840
그림에서 순회 순서는 일관적입니다.
 

1306
00:32:48,840 --> 00:32:50,629
그림에서 순회 순서는 일관적입니다.
X와 Y뿐만 아니라 A, B,

1307
00:32:50,629 --> 00:32:50,639
X와 Y뿐만 아니라 A, B,
 

1308
00:32:50,639 --> 00:32:53,269
X와 Y뿐만 아니라 A, B,
C의 순회 순서도 동일합니다. 즉, A >

1309
00:32:53,269 --> 00:32:54,310
C의 순회 순서도 동일합니다. 즉, A >
 

1310
00:32:54,310 --> 00:32:54,320

 

1311
00:32:54,320 --> 00:32:59,029

X > B > Y >

1312
00:32:59,029 --> 00:32:59,039
X > B > Y >
 

1313
00:32:59,039 --> 00:33:02,310
X > B > Y >
C입니다. 여기서 삼각형을 그릴 때, 삼각형 안의

1314
00:33:02,310 --> 00:33:02,320
C입니다. 여기서 삼각형을 그릴 때, 삼각형 안의
 

1315
00:33:02,320 --> 00:33:03,830
C입니다. 여기서 삼각형을 그릴 때, 삼각형 안의
모든 요소의 순회 순서를 재귀적으로 나타냅니다. 따라서

1316
00:33:03,830 --> 00:33:05,950
모든 요소의 순회 순서를 재귀적으로 나타냅니다. 따라서
 

1317
00:33:05,950 --> 00:33:05,960

 

1318
00:33:05,960 --> 00:33:07,710

순회 순서 알고리즘을 적용하면

1319
00:33:07,710 --> 00:33:07,720
순회 순서 알고리즘을 적용하면
 

1320
00:33:07,720 --> 00:33:09,830
순회 순서 알고리즘을 적용하면
동일한 결과가 나옵니다.

1321
00:33:09,830 --> 00:33:09,840
동일한 결과가 나옵니다.
 

1322
00:33:09,840 --> 00:33:11,830
동일한 결과가 나옵니다.
이는 이러한 연산이

1323
00:33:11,830 --> 00:33:11,840
이는 이러한 연산이
 

1324
00:33:11,840 --> 00:33:17,950
이는 이러한 연산이
순회

1325
00:33:17,950 --> 00:33:17,960

 

1326
00:33:17,960 --> 00:33:21,310

순서를 유지한다는 것을 의미합니다. 좋습니다. 이것은 지금까지 우리가 해온 작업에

1327
00:33:21,310 --> 00:33:21,320
순서를 유지한다는 것을 의미합니다. 좋습니다. 이것은 지금까지 우리가 해온 작업에
 

1328
00:33:21,320 --> 00:33:24,269
순서를 유지한다는 것을 의미합니다. 좋습니다. 이것은 지금까지 우리가 해온 작업에
영향을 주지 않고 트리에서 할 수 있는 작업입니다. 트리의

1329
00:33:24,269 --> 00:33:26,669
영향을 주지 않고 트리에서 할 수 있는 작업입니다. 트리의
 

1330
00:33:26,669 --> 00:33:26,679

 

1331
00:33:26,679 --> 00:33:28,870

균형을 재조정하는 데 사용할 수 있는 도구입니다.

1332
00:33:28,870 --> 00:33:28,880
균형을 재조정하는 데 사용할 수 있는 도구입니다.
 

1333
00:33:28,880 --> 00:33:30,389
균형을 재조정하는 데 사용할 수 있는 도구입니다.

1334
00:33:30,389 --> 00:33:32,950

 

1335
00:33:32,950 --> 00:33:32,960

 

1336
00:33:32,960 --> 00:33:36,110

트리의 깊이가 변한다는 점에 주목하세요. 이 선형 트리의 문제는

1337
00:33:36,110 --> 00:33:38,269
트리의 깊이가 변한다는 점에 주목하세요. 이 선형 트리의 문제는
 

1338
00:33:38,269 --> 00:33:38,279

 

1339
00:33:38,279 --> 00:33:40,029

선형 깊이를 가진 노드가 있다는 것입니다.

1340
00:33:40,029 --> 00:33:40,039
선형 깊이를 가진 노드가 있다는 것입니다.
 

1341
00:33:40,039 --> 00:33:42,269
선형 깊이를 가진 노드가 있다는 것입니다.
이러한 노드를 제거하려면 어떻게 해야 할까요? 이러한 간선을 위로

1342
00:33:42,269 --> 00:33:42,279
이러한 노드를 제거하려면 어떻게 해야 할까요? 이러한 간선을 위로
 

1343
00:33:42,279 --> 00:33:44,590
이러한 노드를 제거하려면 어떻게 해야 할까요? 이러한 간선을 위로
회전시키면 됩니다.

1344
00:33:44,590 --> 00:33:44,600
회전시키면 됩니다.
 

1345
00:33:44,600 --> 00:33:48,070
회전시키면 됩니다.
깊이를 보면, 이 그림에서는 A와

1346
00:33:48,070 --> 00:33:48,080
깊이를 보면, 이 그림에서는 A와
 

1347
00:33:48,080 --> 00:33:51,430
깊이를 보면, 이 그림에서는 A와
B가 C보다 깊고, 이 그림에서는

1348
00:33:51,430 --> 00:33:51,440
B가 C보다 깊고, 이 그림에서는
 

1349
00:33:51,440 --> 00:33:53,830
B가 C보다 깊고, 이 그림에서는
B와 C가 A보다 깊습니다. 즉,

1350
00:33:53,830 --> 00:33:53,840
B와 C가 A보다 깊습니다. 즉,
 

1351
00:33:53,840 --> 00:33:57,509
B와 C가 A보다 깊습니다. 즉,
트레이드오프가 있습니다. 이쪽은 위로 이동하고 저쪽은 위로 이동합니다.

1352
00:33:57,509 --> 00:33:57,519
트레이드오프가 있습니다. 이쪽은 위로 이동하고 저쪽은 위로 이동합니다.
 

1353
00:33:57,519 --> 00:33:59,230
트레이드오프가 있습니다. 이쪽은 위로 이동하고 저쪽은 위로 이동합니다.
아래로 이동했지만 이 노드는

1354
00:33:59,230 --> 00:33:59,240
아래로 이동했지만 이 노드는
 

1355
00:33:59,240 --> 00:34:00,110
아래로 이동했지만 이 노드는
같은

1356
00:34:00,110 --> 00:34:00,120
같은
 

1357
00:34:00,120 --> 00:34:04,149
같은
깊이를 유지했습니다. 따라서 a가 너무 깊고

1358
00:34:04,149 --> 00:34:04,159
깊이를 유지했습니다. 따라서 a가 너무 깊고
 

1359
00:34:04,159 --> 00:34:07,830
깊이를 유지했습니다. 따라서 a가 너무 깊고
C가 너무 얕으면 이렇게 서로 교환할 수 있습니다.

1360
00:34:07,830 --> 00:34:10,190
C가 너무 얕으면 이렇게 서로 교환할 수 있습니다.
 

1361
00:34:10,190 --> 00:34:10,200

 

1362
00:34:10,200 --> 00:34:11,430

어려워 보일 수 있지만 사실

1363
00:34:11,430 --> 00:34:11,440
어려워 보일 수 있지만 사실
 

1364
00:34:11,440 --> 00:34:17,389
어려워 보일 수 있지만 사실
AVL 트리라고 하는 매우 간단한 방법이 있습니다. 이 트리는

1365
00:34:17,389 --> 00:34:20,149

 

1366
00:34:20,149 --> 00:34:20,159

 

1367
00:34:20,159 --> 00:34:22,510


1368
00:34:22,510 --> 00:34:22,520

 

1369
00:34:22,520 --> 00:34:34,829

높이 균형이라는 특정 방식으로 균형을 유지합니다. 즉,

1370
00:34:34,829 --> 00:34:40,389

 

1371
00:34:40,389 --> 00:34:44,990

 

1372
00:34:44,990 --> 00:34:45,000

 

1373
00:34:45,000 --> 00:34:48,950

왼쪽 노드의 높이에서

1374
00:34:48,950 --> 00:34:52,750
왼쪽 노드의 높이에서
 

1375
00:34:52,750 --> 00:34:52,760

 

1376
00:34:52,760 --> 00:34:54,349


1377
00:34:54,349 --> 00:34:54,359

 

1378
00:34:54,359 --> 00:35:03,150

오른쪽 노드의 높이를 뺀 값입니다.

1379
00:35:03,150 --> 00:35:03,160

 

1380
00:35:03,160 --> 00:35:07,190

이것을 노드

1381
00:35:07,190 --> 00:35:07,200
이것을 노드
 

1382
00:35:07,200 --> 00:35:10,109
이것을 노드
의 왜곡이라고 합니다. 이 값은

1383
00:35:10,109 --> 00:35:10,119
의 왜곡이라고 합니다. 이 값은
 

1384
00:35:10,119 --> 00:35:14,230
의 왜곡이라고 합니다. 이 값은
항상 -1, 0

1385
00:35:14,230 --> 00:35:14,240
항상 -1, 0
 

1386
00:35:14,240 --> 00:35:16,710
항상 -1, 0
또는 +1이 되어야 합니다. 즉,

1387
00:35:16,710 --> 00:35:19,950
또는 +1이 되어야 합니다. 즉,
 

1388
00:35:19,950 --> 00:35:19,960

 

1389
00:35:19,960 --> 00:35:23,109

어떤 노드가 있고 왼쪽 하위 트리

1390
00:35:23,109 --> 00:35:23,119
어떤 노드가 있고 왼쪽 하위 트리
 

1391
00:35:23,119 --> 00:35:26,030
어떤 노드가 있고 왼쪽 하위 트리
와 오른쪽 하위 트리가 있는지 확인하고, 두

1392
00:35:26,030 --> 00:35:27,710
와 오른쪽 하위 트리가 있는지 확인하고, 두
 

1393
00:35:27,710 --> 00:35:27,720

 

1394
00:35:27,720 --> 00:35:30,790

노드의 높이를 측정합니다. 여기서 최대 리프까지의 거리(하향 거리)를

1395
00:35:30,790 --> 00:35:30,800
노드의 높이를 측정합니다. 여기서 최대 리프까지의 거리(하향 거리)를
 

1396
00:35:30,800 --> 00:35:32,870
노드의 높이를 측정합니다. 여기서 최대 리프까지의 거리(하향 거리)를
기준으로 왼쪽 하위 트리의 최대 높이와 ​​오른쪽 하위 트리의

1397
00:35:32,870 --> 00:35:32,880
기준으로 왼쪽 하위 트리의 최대 높이와 ​​오른쪽 하위 트리의
 

1398
00:35:32,880 --> 00:35:34,390
기준으로 왼쪽 하위 트리의 최대 높이와 ​​오른쪽 하위 트리의
최대 높이를 측정합니다.

1399
00:35:34,390 --> 00:35:34,400
최대 높이를 측정합니다.
 

1400
00:35:34,400 --> 00:35:36,910
최대 높이를 측정합니다.
이 두 값이 1 이내,

1401
00:35:36,910 --> 00:35:39,550
이 두 값이 1 이내,
 

1402
00:35:39,550 --> 00:35:39,560

 

1403
00:35:39,560 --> 00:35:42,430

이상적으로는 같으면 좋겠지만, 1만큼 차이가 나도록 하겠습니다. 예를 들어, 이쪽은

1404
00:35:42,430 --> 00:35:44,790
이상적으로는 같으면 좋겠지만, 1만큼 차이가 나도록 하겠습니다. 예를 들어, 이쪽은
 

1405
00:35:44,790 --> 00:35:44,800

 

1406
00:35:44,800 --> 00:35:48,630

K이고 이쪽은 K+1이거나,

1407
00:35:48,630 --> 00:35:48,640
K이고 이쪽은 K+1이거나,
 

1408
00:35:48,640 --> 00:35:51,309
K이고 이쪽은 K+1이거나,
이쪽은 K이고 이쪽은 K-1일 수 있습니다.

1409
00:35:51,309 --> 00:35:51,319
이쪽은 K이고 이쪽은 K-1일 수 있습니다.
 

1410
00:35:51,319 --> 00:35:52,790
이쪽은 K이고 이쪽은 K-1일 수 있습니다.
이 그림에서

1411
00:35:52,790 --> 00:35:52,800
이 그림에서
 

1412
00:35:52,800 --> 00:35:56,030
이 그림에서
이 노드의 높이는 얼마일까요? 좋은

1413
00:35:56,030 --> 00:35:56,040
이 노드의 높이는 얼마일까요? 좋은
 

1414
00:35:56,040 --> 00:35:58,630
이 노드의 높이는 얼마일까요? 좋은
연습이라고 할 수 있겠네요. k+2입니다.

1415
00:35:58,630 --> 00:35:58,640
연습이라고 할 수 있겠네요. k+2입니다.
 

1416
00:35:58,640 --> 00:36:00,829
연습이라고 할 수 있겠네요. k+2입니다.
이 노드에서 리프 노드까지의 가장 긴 경로는 무엇일까요?

1417
00:36:00,829 --> 00:36:02,589
이 노드에서 리프 노드까지의 가장 긴 경로는 무엇일까요?
 

1418
00:36:02,589 --> 00:36:02,599

 

1419
00:36:02,599 --> 00:36:04,630

이 서브트리를 통과할 수도 있는데, 그러면 길이는

1420
00:36:04,630 --> 00:36:04,640
이 서브트리를 통과할 수도 있는데, 그러면 길이는
 

1421
00:36:04,640 --> 00:36:06,750
이 서브트리를 통과할 수도 있는데, 그러면 길이는
k+1이 됩니다. 왜냐하면 여기에 K가 있고

1422
00:36:06,750 --> 00:36:06,760
k+1이 됩니다. 왜냐하면 여기에 K가 있고
 

1423
00:36:06,760 --> 00:36:08,630
k+1이 됩니다. 왜냐하면 여기에 K가 있고
이 엣지에 1이 더해지기 때문입니다. 또는 여기를 통과할 수도 있는데,

1424
00:36:08,630 --> 00:36:08,640
이 엣지에 1이 더해지기 때문입니다. 또는 여기를 통과할 수도 있는데,
 

1425
00:36:08,640 --> 00:36:11,150
이 엣지에 1이 더해지기 때문입니다. 또는 여기를 통과할 수도 있는데,
그러면 k+1에 1을 더한 값이 됩니다. 따라서 가장 긴 경로는

1426
00:36:11,150 --> 00:36:11,160
그러면 k+1에 1을 더한 값이 됩니다. 따라서 가장 긴 경로는
 

1427
00:36:11,160 --> 00:36:13,589
그러면 k+1에 1을 더한 값이 됩니다. 따라서 가장 긴 경로는
오른쪽으로 가는 것입니다.

1428
00:36:13,589 --> 00:36:13,599
오른쪽으로 가는 것입니다.
 

1429
00:36:13,599 --> 00:36:14,829
오른쪽으로 가는 것입니다.
이 서브트리들의 높이를 알면

1430
00:36:14,829 --> 00:36:14,839
이 서브트리들의 높이를 알면
 

1431
00:36:14,839 --> 00:36:16,190
이 서브트리들의 높이를 알면
이 노드의 높이를 유도할 수 있습니다.

1432
00:36:16,190 --> 00:36:16,200
이 노드의 높이를 유도할 수 있습니다.
 

1433
00:36:16,200 --> 00:36:18,430
이 노드의 높이를 유도할 수 있습니다.
잠시 후에 이 방법을 많이 사용할 것입니다.

1434
00:36:18,430 --> 00:36:18,440
잠시 후에 이 방법을 많이 사용할 것입니다.
 

1435
00:36:18,440 --> 00:36:21,430
잠시 후에 이 방법을 많이 사용할 것입니다.
첫 번째 주장은

1436
00:36:21,430 --> 00:36:21,440
첫 번째 주장은
 

1437
00:36:21,440 --> 00:36:25,150
첫 번째 주장은
높이 균형을 유지할 수 있다면

1438
00:36:25,150 --> 00:36:25,160
높이 균형을 유지할 수 있다면
 

1439
00:36:25,160 --> 00:36:28,190
높이 균형을 유지할 수 있다면
H가

1440
00:36:28,190 --> 00:36:28,200
H가
 

1441
00:36:28,200 --> 00:36:29,790
H가
log n과 같다는 것을 보장할 수 있다는 것입니다. 즉, 높이 균형은

1442
00:36:29,790 --> 00:36:29,800
log n과 같다는 것을 보장할 수 있다는 것입니다. 즉, 높이 균형은
 

1443
00:36:29,800 --> 00:36:31,309
log n과 같다는 것을 보장할 수 있다는 것입니다. 즉, 높이 균형은

1444
00:36:31,309 --> 00:36:31,319

 

1445
00:36:31,319 --> 00:36:33,950

균형을 의미합니다. 먼저 이것을

1446
00:36:33,950 --> 00:36:33,960
균형을 의미합니다. 먼저 이것을
 

1447
00:36:33,960 --> 00:36:38,390
균형을 의미합니다. 먼저 이것을
빠르게 증명해 보겠습니다. 그다음 흥미로운

1448
00:36:38,390 --> 00:36:38,400
빠르게 증명해 보겠습니다. 그다음 흥미로운
 

1449
00:36:38,400 --> 00:36:43,870
빠르게 증명해 보겠습니다. 그다음 흥미로운
부분은 실제로 어떻게

1450
00:36:43,870 --> 00:36:46,349

 

1451
00:36:46,349 --> 00:36:46,359

 

1452
00:36:46,359 --> 00:36:48,349

균형 속성을 증명하거나 유지하는가입니다.

1453
00:36:48,349 --> 00:36:48,359
균형 속성을 증명하거나 유지하는가입니다.
 

1454
00:36:48,359 --> 00:36:51,109
균형 속성을 증명하거나 유지하는가입니다.
회전을 사용하여 이를 수행할 것입니다. 하지만 어떻게 하는지는 큰

1455
00:36:51,109 --> 00:36:51,119
회전을 사용하여 이를 수행할 것입니다. 하지만 어떻게 하는지는 큰
 

1456
00:36:51,119 --> 00:37:01,470
회전을 사용하여 이를 수행할 것입니다. 하지만 어떻게 하는지는 큰
문제입니다.

1457
00:37:01,470 --> 00:37:01,480

 

1458
00:37:01,480 --> 00:37:05,589

높이 균형이 왜

1459
00:37:05,589 --> 00:37:15,630

 

1460
00:37:15,630 --> 00:37:15,640

 

1461
00:37:15,640 --> 00:37:19,750

균형을 의미할까요? 이것은

1462
00:37:19,750 --> 00:37:19,760
균형을 의미할까요? 이것은
 

1463
00:37:19,760 --> 00:37:22,150
균형을 의미할까요? 이것은
모든 높이 균형 트리가

1464
00:37:22,150 --> 00:37:22,160
모든 높이 균형 트리가
 

1465
00:37:22,160 --> 00:37:23,710
모든 높이 균형 트리가
로그

1466
00:37:23,710 --> 00:37:23,720
로그
 

1467
00:37:23,720 --> 00:37:26,150
로그
높이를 가진다는 것을 의미합니다. 제가 생각해 보고 싶은 것은...

1468
00:37:26,150 --> 00:37:26,160
높이를 가진다는 것을 의미합니다. 제가 생각해 보고 싶은 것은...
 

1469
00:37:26,160 --> 00:37:29,190
높이를 가진다는 것을 의미합니다. 제가 생각해 보고 싶은 것은...
가장 불균형한 높이

1470
00:37:29,190 --> 00:37:29,200
가장 불균형한 높이
 

1471
00:37:29,200 --> 00:37:31,990
가장 불균형한 높이
균형 트리는

1472
00:37:31,990 --> 00:37:32,000
균형 트리는
 

1473
00:37:32,000 --> 00:37:34,349
균형 트리는
모든 노드에서

1474
00:37:34,349 --> 00:37:34,359
모든 노드에서
 

1475
00:37:34,359 --> 00:37:36,630
모든 노드에서
왼쪽 서브트리와 높이 차이가 발생합니다. 예를 들어 왼쪽 서브트리가

1476
00:37:36,630 --> 00:37:36,640
왼쪽 서브트리와 높이 차이가 발생합니다. 예를 들어 왼쪽 서브트리가
 

1477
00:37:36,640 --> 00:37:40,470
왼쪽 서브트리와 높이 차이가 발생합니다. 예를 들어 왼쪽 서브트리가
오른쪽 서브트리보다 높이가 1만큼 낮다고 가정해 보겠습니다. 이러한 불균형은

1478
00:37:40,470 --> 00:37:42,710
오른쪽 서브트리보다 높이가 1만큼 낮다고 가정해 보겠습니다. 이러한 불균형은
 

1479
00:37:42,710 --> 00:37:42,720

 

1480
00:37:42,720 --> 00:37:46,150

모든 노드에 재귀적으로 발생합니다. 즉, 모든 노드에 높이 차이가

1481
00:37:46,150 --> 00:37:46,160
모든 노드에 재귀적으로 발생합니다. 즉, 모든 노드에 높이 차이가
 

1482
00:37:46,160 --> 00:37:48,589
모든 노드에 재귀적으로 발생합니다. 즉, 모든 노드에 높이 차이가

1483
00:37:48,589 --> 00:37:53,990

 

1484
00:37:53,990 --> 00:37:54,000

 

1485
00:37:54,000 --> 00:37:56,630

1만큼 발생하는 것입니다. 이를 나타내기 위해 새로운

1486
00:37:56,630 --> 00:37:56,640
1만큼 발생하는 것입니다. 이를 나타내기 위해 새로운
 

1487
00:37:56,640 --> 00:37:58,150
1만큼 발생하는 것입니다. 이를 나타내기 위해 새로운
표기법을 도입하겠습니다. 오른쪽으로 향하는 화살표(내림차순)를 사용하여

1488
00:37:58,150 --> 00:37:59,990
표기법을 도입하겠습니다. 오른쪽으로 향하는 화살표(내림차순)를 사용하여
 

1489
00:37:59,990 --> 00:38:00,000

 

1490
00:38:00,000 --> 00:38:04,950

왼쪽 서브

1491
00:38:04,950 --> 00:38:04,960
왼쪽 서브
 

1492
00:38:04,960 --> 00:38:07,910
왼쪽 서브
트리보다 높이가 높은 경우를 표시하겠습니다. 쉽게 말하면,

1493
00:38:07,910 --> 00:38:07,920
트리보다 높이가 높은 경우를 표시하겠습니다. 쉽게 말하면,
 

1494
00:38:07,920 --> 00:38:09,829
트리보다 높이가 높은 경우를 표시하겠습니다. 쉽게 말하면,
이것은 최악의 경우이며

1495
00:38:09,829 --> 00:38:12,030
이것은 최악의 경우이며
 

1496
00:38:12,030 --> 00:38:12,040

 

1497
00:38:12,040 --> 00:38:14,950

최대 깊이에 비해 노드 수가 가장 적은 경우입니다. 이제

1498
00:38:14,950 --> 00:38:14,960
최대 깊이에 비해 노드 수가 가장 적은 경우입니다. 이제
 

1499
00:38:14,960 --> 00:38:17,390
최대 깊이에 비해 노드 수가 가장 적은 경우입니다. 이제
이 트리에 있는 노드 수를 세어 보겠습니다.

1500
00:38:17,390 --> 00:38:17,400
이 트리에 있는 노드 수를 세어 보겠습니다.
 

1501
00:38:17,400 --> 00:38:19,790
이 트리에 있는 노드 수를 세어 보겠습니다.
이를 재귀 관계식으로 나타내면

1502
00:38:19,790 --> 00:38:22,069
이를 재귀 관계식으로 나타내면
 

1503
00:38:22,069 --> 00:38:22,079

 

1504
00:38:22,079 --> 00:38:24,630

높이가 H인 트리의 노드 수를 알 수 있습니다.

1505
00:38:24,630 --> 00:38:24,640
높이가 H인 트리의 노드 수를 알 수 있습니다.
 

1506
00:38:24,640 --> 00:38:29,630
높이가 H인 트리의 노드 수를 알 수 있습니다.
이 트리의 전체 높이가

1507
00:38:29,630 --> 00:38:29,640

 

1508
00:38:29,640 --> 00:38:32,990

H라고 할 때, 그림에서처럼

1509
00:38:32,990 --> 00:38:33,000
H라고 할 때, 그림에서처럼
 

1510
00:38:33,000 --> 00:38:35,670
H라고 할 때, 그림에서처럼
모든 노드 수에서 2를 빼면

1511
00:38:35,670 --> 00:38:35,680
모든 노드 수에서 2를 빼면
 

1512
00:38:35,680 --> 00:38:40,309
모든 노드 수에서 2를 빼면
이 노드는 H-2,

1513
00:38:40,309 --> 00:38:40,319
이 노드는 H-2,
 

1514
00:38:40,319 --> 00:38:42,870
이 노드는 H-2,
이 노드는 H-

1515
00:38:42,870 --> 00:38:42,880
이 노드는 H-
 

1516
00:38:42,880 --> 00:38:45,990
이 노드는 H-
1이 됩니다. 따라서 이 트리에는 총 몇 개의 노드가 있을까요?

1517
00:38:45,990 --> 00:38:46,000
1이 됩니다. 따라서 이 트리에는 총 몇 개의 노드가 있을까요?
 

1518
00:38:46,000 --> 00:38:47,550
1이 됩니다. 따라서 이 트리에는 총 몇 개의 노드가 있을까요?
점화식을

1519
00:38:47,550 --> 00:38:47,560
점화식을
 

1520
00:38:47,560 --> 00:38:52,150
점화식을
쓰면 이게 N<sub>h-2</sub>가 되고, 이게

1521
00:38:52,150 --> 00:38:52,160
쓰면 이게 N<sub>h-2</sub>가 되고, 이게
 

1522
00:38:52,160 --> 00:38:54,349
쓰면 이게 N<sub>h-2</sub>가 되고, 이게
N<sub>

1523
00:38:54,349 --> 00:38:54,359
N<sub>
 

1524
00:38:54,359 --> 00:38:56,430
N<sub>
h1</sub>이 됩니다. 그리고

1525
00:38:56,430 --> 00:38:56,440
h1</sub>이 됩니다. 그리고
 

1526
00:38:56,440 --> 00:38:57,990
h1</sub>이 됩니다. 그리고
이 그림에 있는 노드의 개수를 세면

1527
00:38:57,990 --> 00:38:58,000
이 그림에 있는 노드의 개수를 세면
 

1528
00:38:58,000 --> 00:39:04,750
이 그림에 있는 노드의 개수를 세면
N<sub>h-1</sub> + N<sub>h-2</sub> + 1이 됩니다.

1529
00:39:04,750 --> 00:39:04,760
N<sub>h-1</sub> + N<sub>h-2</sub> + 1이 됩니다.
 

1530
00:39:04,760 --> 00:39:07,589
N<sub>h-1</sub> + N<sub>h-2</sub> + 1이 됩니다.
여기서 N<sub>h</sub> 또는 점화식이 무엇인지 궁금하실 수 있는데,

1531
00:39:07,589 --> 00:39:07,599
여기서 N<sub>h</sub> 또는 점화식이 무엇인지 궁금하실 수 있는데,
 

1532
00:39:07,599 --> 00:39:10,230
여기서 N<sub>h</sub> 또는 점화식이 무엇인지 궁금하실 수 있는데,
이는

1533
00:39:10,230 --> 00:39:13,630
이는
 

1534
00:39:13,630 --> 00:39:13,640

 

1535
00:39:13,640 --> 00:39:17,190

최악의 경우, 즉 전체

1536
00:39:17,190 --> 00:39:17,200
최악의 경우, 즉 전체
 

1537
00:39:17,200 --> 00:39:20,150
최악의 경우, 즉 전체
높이가 H인 경우의 노드 개수를 나타냅니다. 다시 말해, 높이가 h인

1538
00:39:20,150 --> 00:39:21,910
높이가 H인 경우의 노드 개수를 나타냅니다. 다시 말해, 높이가 h인
 

1539
00:39:21,910 --> 00:39:21,920

 

1540
00:39:21,920 --> 00:39:23,750

AVL 트리(

1541
00:39:23,750 --> 00:39:33,470
AVL 트리(
 

1542
00:39:33,470 --> 00:39:33,480

 

1543
00:39:33,480 --> 00:39:37,630

높이 균형

1544
00:39:37,630 --> 00:39:37,640
높이 균형
 

1545
00:39:37,640 --> 00:39:39,750
높이 균형
트리)에서 가질 수 있는 최소 노드 개수를 나타내는 것입니다. 자, 이제

1546
00:39:39,750 --> 00:39:39,760
트리)에서 가질 수 있는 최소 노드 개수를 나타내는 것입니다. 자, 이제
 

1547
00:39:39,760 --> 00:39:45,430
트리)에서 가질 수 있는 최소 노드 개수를 나타내는 것입니다. 자, 이제
이 점화식을 풀어야 합니다. 이 점화식이 익숙해 보이죠? 피보나치 수열과 비슷하잖아요. +1을

1548
00:39:45,430 --> 00:39:45,440

 

1549
00:39:45,440 --> 00:39:47,109


1550
00:39:47,109 --> 00:39:49,670

 

1551
00:39:49,670 --> 00:39:49,680

 

1552
00:39:49,680 --> 00:39:52,270

빼면 피보나치 수열이 되고,

1553
00:39:52,270 --> 00:39:52,280
빼면 피보나치 수열이 되고,
 

1554
00:39:52,280 --> 00:39:53,550
빼면 피보나치 수열이 되고,
피보나치

1555
00:39:53,550 --> 00:39:53,560
피보나치
 

1556
00:39:53,560 --> 00:39:55,910
피보나치
수열은 N에 대해 황금비처럼 증가한다는 것을 알고 있다면, 이것이 지수 함수라는 것을 알 수 있습니다.

1557
00:39:55,910 --> 00:39:57,870
수열은 N에 대해 황금비처럼 증가한다는 것을 알고 있다면, 이것이 지수 함수라는 것을 알 수 있습니다.
 

1558
00:39:57,870 --> 00:39:57,880

 

1559
00:39:57,880 --> 00:39:59,670

우리가 원하는 것은 바로 이것입니다. N<sub>h</sub>가 h에 대해 지수 함수적이라는 것은

1560
00:39:59,670 --> 00:40:02,790
우리가 원하는 것은 바로 이것입니다. N<sub>h</sub>가 h에 대해 지수 함수적이라는 것은
 

1561
00:40:02,790 --> 00:40:02,800

 

1562
00:40:02,800 --> 00:40:05,069

H가 N에 대해 로그 함수적이라는 것을 의미합니다. 왜냐하면 로그는

1563
00:40:05,069 --> 00:40:05,079
H가 N에 대해 로그 함수적이라는 것을 의미합니다. 왜냐하면 로그는
 

1564
00:40:05,079 --> 00:40:07,150
H가 N에 대해 로그 함수적이라는 것을 의미합니다. 왜냐하면 로그는
지수 함수의 역함수이기 때문입니다.  알겠습니다. 하지만

1565
00:40:07,150 --> 00:40:07,160
지수 함수의 역함수이기 때문입니다.  알겠습니다. 하지만
 

1566
00:40:07,160 --> 00:40:08,670
지수 함수의 역함수이기 때문입니다.  알겠습니다. 하지만
피보나치 수열에 대해 잘 모르실 수도 있으니,

1567
00:40:08,670 --> 00:40:12,910
피보나치 수열에 대해 잘 모르실 수도 있으니,
 

1568
00:40:12,910 --> 00:40:12,920

 

1569
00:40:12,920 --> 00:40:16,109

다음과 같이 이것이 지수 함수임을 쉽게 증명할 수 있습니다.

1570
00:40:16,109 --> 00:40:16,119
다음과 같이 이것이 지수 함수임을 쉽게 증명할 수 있습니다.
 

1571
00:40:16,119 --> 00:40:17,630
다음과 같이 이것이 지수 함수임을 쉽게 증명할 수 있습니다.
적어도 지수 함수라는 것을 증명하고 싶습니다. 왜냐하면 그렇게 하면

1572
00:40:17,630 --> 00:40:17,640
적어도 지수 함수라는 것을 증명하고 싶습니다. 왜냐하면 그렇게 하면
 

1573
00:40:17,640 --> 00:40:19,510
적어도 지수 함수라는 것을 증명하고 싶습니다. 왜냐하면 그렇게 하면
H가

1574
00:40:19,510 --> 00:40:19,520
H가
 

1575
00:40:19,520 --> 00:40:21,230
H가
최대

1576
00:40:21,230 --> 00:40:21,240
최대
 

1577
00:40:21,240 --> 00:40:24,390
최대
로그 함수라는 것을 알 수 있기 때문입니다. 따라서 하한값이 필요하고,

1578
00:40:24,390 --> 00:40:25,829
로그 함수라는 것을 알 수 있기 때문입니다. 따라서 하한값이 필요하고,
 

1579
00:40:25,829 --> 00:40:25,839

 

1580
00:40:25,839 --> 00:40:28,150

비교하기 어려운 두 항, n<sub>h-1</sub>과 n<sub>h-

1581
00:40:28,150 --> 00:40:28,160
비교하기 어려운 두 항, n<sub>h-1</sub>과 n<sub>h-
 

1582
00:40:28,160 --> 00:40:30,589
비교하기 어려운 두 항, n<sub>h-1</sub>과 n<sub>h-
2</sub>가 있습니다. 좀 복잡하지만, 약간

1583
00:40:30,589 --> 00:40:30,599
2</sub>가 있습니다. 좀 복잡하지만, 약간
 

1584
00:40:30,599 --> 00:40:32,109
2</sub>가 있습니다. 좀 복잡하지만, 약간
허술해도 괜찮다면 (

1585
00:40:32,109 --> 00:40:32,119
허술해도 괜찮다면 (
 

1586
00:40:32,119 --> 00:40:33,910
허술해도 괜찮다면 (
너무 허술하지 않으면서

1587
00:40:33,910 --> 00:40:33,920
너무 허술하지 않으면서
 

1588
00:40:33,920 --> 00:40:36,390
너무 허술하지 않으면서
지수 함수라는 답을 얻을 수 있는지 확인해 보겠습니다), 두 항을 같게 놓아 보겠습니다. 이렇게요. 따라서

1589
00:40:36,390 --> 00:40:36,400
지수 함수라는 답을 얻을 수 있는지 확인해 보겠습니다), 두 항을 같게 놓아 보겠습니다. 이렇게요. 따라서
 

1590
00:40:36,400 --> 00:40:38,349
지수 함수라는 답을 얻을 수 있는지 확인해 보겠습니다), 두 항을 같게 놓아 보겠습니다. 이렇게요. 따라서

1591
00:40:38,349 --> 00:40:40,550

 

1592
00:40:40,550 --> 00:40:40,560

 

1593
00:40:40,560 --> 00:40:43,150


1594
00:40:43,150 --> 00:40:43,160

 

1595
00:40:43,160 --> 00:40:46,390

이것은 참입니다. 사실, 보다 엄밀히

1596
00:40:46,390 --> 00:40:46,400
이것은 참입니다. 사실, 보다 엄밀히
 

1597
00:40:46,400 --> 00:40:49,390
이것은 참입니다. 사실, 보다 엄밀히
큽니다. 왜냐하면 +1을

1598
00:40:49,390 --> 00:40:49,400
큽니다. 왜냐하면 +1을
 

1599
00:40:49,400 --> 00:40:50,910
큽니다. 왜냐하면 +1을
제거했기 때문입니다. +1은 더

1600
00:40:50,910 --> 00:40:50,920
제거했기 때문입니다. +1은 더
 

1601
00:40:50,920 --> 00:40:54,349
제거했기 때문입니다. +1은 더
작은 값만 만들어야 합니다. 그리고 n

1602
00:40:54,349 --> 00:40:54,359
작은 값만 만들어야 합니다. 그리고 n
 

1603
00:40:54,359 --> 00:40:56,750
작은 값만 만들어야 합니다. 그리고 n
<sub>h-1</sub>을 n<sub>h-2</sub>로 바꿨습니다. 여기서

1604
00:40:56,750 --> 00:40:56,760
<sub>h-1</sub>을 n<sub>h-2</sub>로 바꿨습니다. 여기서
 

1605
00:40:56,760 --> 00:40:59,230
<sub>h-1</sub>을 n<sub>h-2</sub>로 바꿨습니다. 여기서
저는 귀납적으로 자명한 사실을 사용하고 있습니다. 이 트리의

1606
00:40:59,230 --> 00:40:59,240
저는 귀납적으로 자명한 사실을 사용하고 있습니다. 이 트리의
 

1607
00:40:59,240 --> 00:41:03,190
저는 귀납적으로 자명한 사실을 사용하고 있습니다. 이 트리의
높이를

1608
00:41:03,190 --> 00:41:03,200
높이를
 

1609
00:41:03,200 --> 00:41:05,309
높이를
비교해 보면, 이 트리가 저 트리보다

1610
00:41:05,309 --> 00:41:05,319
비교해 보면, 이 트리가 저 트리보다
 

1611
00:41:05,319 --> 00:41:07,630
비교해 보면, 이 트리가 저 트리보다
노드 수가 더 많습니다.

1612
00:41:07,630 --> 00:41:07,640
노드 수가 더 많습니다.
 

1613
00:41:07,640 --> 00:41:09,550
노드 수가 더 많습니다.
높이가 더 크다면 이

1614
00:41:09,550 --> 00:41:09,560
높이가 더 크다면 이
 

1615
00:41:09,560 --> 00:41:11,230
높이가 더 크다면 이
구조는 더 작습니다.  더 큰

1616
00:41:11,230 --> 00:41:11,240
구조는 더 작습니다.  더 큰
 

1617
00:41:11,240 --> 00:41:14,109
구조는 더 작습니다.  더 큰
트리를 만들 것입니다. 적어도 기존 트리만큼 클 것이고, 반드시

1618
00:41:14,109 --> 00:41:14,119
트리를 만들 것입니다. 적어도 기존 트리만큼 클 것이고, 반드시
 

1619
00:41:14,119 --> 00:41:16,309
트리를 만들 것입니다. 적어도 기존 트리만큼 클 것이고, 반드시
더 클 필요는 없습니다. 따라서

1620
00:41:16,309 --> 00:41:16,319
더 클 필요는 없습니다. 따라서
 

1621
00:41:16,319 --> 00:41:17,910
더 클 필요는 없습니다. 따라서
n<sub>h-1</sub>은 확실히

1622
00:41:17,910 --> 00:41:17,920
n<sub>h-1</sub>은 확실히
 

1623
00:41:17,920 --> 00:41:22,390
n<sub>h-1</sub>은 확실히
n<sub>h-2</sub>보다 크거나 같습니다. 이것은 2 *

1624
00:41:22,390 --> 00:41:22,400
n<sub>h-2</sub>보다 크거나 같습니다. 이것은 2 *
 

1625
00:41:22,400 --> 00:41:25,630
n<sub>h-2</sub>보다 크거나 같습니다. 이것은 2 *
n<sub>h</sub>2이고, 이것은 간단한 점화식입니다.

1626
00:41:25,630 --> 00:41:25,640
n<sub>h</sub>2이고, 이것은 간단한 점화식입니다.
 

1627
00:41:25,640 --> 00:41:28,190
n<sub>h</sub>2이고, 이것은 간단한 점화식입니다.
2의 거듭제곱이죠. H에서

1628
00:41:28,190 --> 00:41:28,200
2의 거듭제곱이죠. H에서
 

1629
00:41:28,200 --> 00:41:30,430
2의 거듭제곱이죠. H에서
2를 계속 곱하고 빼는 겁니다.

1630
00:41:30,430 --> 00:41:30,440
2를 계속 곱하고 빼는 겁니다.
 

1631
00:41:30,440 --> 00:41:35,190
2를 계속 곱하고 빼는 겁니다.
그래서 이 식은 2의 h²이 됩니다.

1632
00:41:35,190 --> 00:41:35,200
그래서 이 식은 2의 h²이 됩니다.
 

1633
00:41:35,200 --> 00:41:38,790
그래서 이 식은 2의 h²이 됩니다.
내림이나 다른 연산이 필요할 수도 있지만,

1634
00:41:38,790 --> 00:41:38,800
내림이나 다른 연산이 필요할 수도 있지만,
 

1635
00:41:38,800 --> 00:41:41,710
내림이나 다른 연산이 필요할 수도 있지만,
어쨌든 저는 기본 사례

1636
00:41:41,710 --> 00:41:41,720
어쨌든 저는 기본 사례
 

1637
00:41:41,720 --> 00:41:44,030
어쨌든 저는 기본 사례
인 n<sub>0</sub>a</sub>a<sub>

1638
00:41:44,030 --> 00:41:44,040
인 n<sub>0</sub>a</sub>a<sub>
 

1639
00:41:44,040 --> 00:41:47,589
인 n<sub>0</sub>a</sub>a<sub>
1</sub>을 사용하고 있습니다. 어쩌면 올림이 필요할 수도 있지만, 중요한 것은

1640
00:41:47,589 --> 00:41:47,599
1</sub>을 사용하고 있습니다. 어쩌면 올림이 필요할 수도 있지만, 중요한 것은
 

1641
00:41:47,599 --> 00:41:49,670
1</sub>을 사용하고 있습니다. 어쩌면 올림이 필요할 수도 있지만, 중요한 것은
이것이 지수 함수라는 점입니다.

1642
00:41:49,670 --> 00:41:49,680
이것이 지수 함수라는 점입니다.
 

1643
00:41:49,680 --> 00:41:52,390
이것이 지수 함수라는 점입니다.
따라서 트리의 높이는 항상

1644
00:41:52,390 --> 00:41:52,400
따라서 트리의 높이는 항상
 

1645
00:41:52,400 --> 00:41:54,589
따라서 트리의 높이는 항상
최대 2 * log

1646
00:41:54,589 --> 00:41:54,599
최대 2 * log
 

1647
00:41:54,599 --> 00:41:57,750
최대 2 * log
n입니다. 이 2는 이것에 해당합니다. 이

1648
00:41:57,750 --> 00:41:57,760
n입니다. 이 2는 이것에 해당합니다. 이
 

1649
00:41:57,760 --> 00:41:59,790
n입니다. 이 2는 이것에 해당합니다. 이
공식을 역으로 하면

1650
00:41:59,790 --> 00:41:59,800
공식을 역으로 하면
 

1651
00:41:59,800 --> 00:42:03,030
공식을 역으로 하면
노드 수는

1652
00:42:03,030 --> 00:42:03,040
노드 수는
 

1653
00:42:03,040 --> 00:42:06,910
노드 수는
적어도 H²의 2배가 되므로 H는 최대 2

1654
00:42:06,910 --> 00:42:06,920
적어도 H²의 2배가 되므로 H는 최대 2
 

1655
00:42:06,920 --> 00:42:09,349
적어도 H²의 2배가 되므로 H는 최대 2
log n입니다. log n이 아니라

1656
00:42:09,349 --> 00:42:11,390
log n입니다. log n이 아니라
 

1657
00:42:11,390 --> 00:42:11,400

 

1658
00:42:11,400 --> 00:42:14,550

log n의 2배 이내입니다. 따라서 AVL 트리는 항상 상당히

1659
00:42:14,550 --> 00:42:14,560
log n의 2배 이내입니다. 따라서 AVL 트리는 항상 상당히
 

1660
00:42:14,560 --> 00:42:16,710
log n의 2배 이내입니다. 따라서 AVL 트리는 항상 상당히
균형 잡혀 있으며, 레벨 수는

1661
00:42:16,710 --> 00:42:16,720
균형 잡혀 있으며, 레벨 수는
 

1662
00:42:16,720 --> 00:42:22,910
균형 잡혀 있으며, 레벨 수는
엔드 노드를 저장하는 데 필요한 레벨 수의 최대 두 배입니다.  이제

1663
00:42:22,910 --> 00:42:22,920

 

1664
00:42:22,920 --> 00:42:27,670

남은 건 메인 매직이지

1665
00:42:27,670 --> 00:42:27,680
남은 건 메인 매직이지
 

1666
00:42:27,680 --> 00:42:31,750
남은 건 메인 매직이지
도메인 매직이 아닙니다. 그건 다른 거죠. 자,

1667
00:42:31,750 --> 00:42:31,760
도메인 매직이 아닙니다. 그건 다른 거죠. 자,
 

1668
00:42:31,760 --> 00:42:36,510
도메인 매직이 아닙니다. 그건 다른 거죠. 자,
서브트리 증강을 사용할 건데,

1669
00:42:36,510 --> 00:42:44,510

 

1670
00:42:44,510 --> 00:42:44,520

 

1671
00:42:44,520 --> 00:42:48,109

남은 큰 과제는 회전을 이용해서

1672
00:42:48,109 --> 00:42:48,119
남은 큰 과제는 회전을 이용해서
 

1673
00:42:48,119 --> 00:42:50,109
남은 큰 과제는 회전을 이용해서
높이 균형 속성을 어떻게 유지하느냐입니다. 필요한

1674
00:42:50,109 --> 00:42:51,829
높이 균형 속성을 어떻게 유지하느냐입니다. 필요한
 

1675
00:42:51,829 --> 00:42:51,839

 

1676
00:42:51,839 --> 00:42:54,670

재료는 다 갖췄습니다. 서브

1677
00:42:54,670 --> 00:42:54,680
재료는 다 갖췄습니다. 서브
 

1678
00:42:54,680 --> 00:42:55,630
재료는 다 갖췄습니다. 서브
트리

1679
00:42:55,630 --> 00:42:55,640
트리
 

1680
00:42:55,640 --> 00:42:59,710
트리
증강이 있죠.

1681
00:42:59,710 --> 00:42:59,720

 

1682
00:42:59,720 --> 00:43:03,190

AVL 트리와 관련해서 이걸로 뭘 할 수 있을까요? 높이를

1683
00:43:03,190 --> 00:43:03,200
AVL 트리와 관련해서 이걸로 뭘 할 수 있을까요? 높이를
 

1684
00:43:03,200 --> 00:43:05,390
AVL 트리와 관련해서 이걸로 뭘 할 수 있을까요? 높이를
저장할 수 있게 해줍니다. 노드

1685
00:43:05,390 --> 00:43:07,910
저장할 수 있게 해줍니다. 노드
 

1686
00:43:07,910 --> 00:43:07,920

 

1687
00:43:07,920 --> 00:43:10,309

의 높이를 계산해야 하는데,

1688
00:43:10,309 --> 00:43:10,319
의 높이를 계산해야 하는데,
 

1689
00:43:10,319 --> 00:43:13,030
의 높이를 계산해야 하는데,
일반적으로 선형 시간이 걸립니다.

1690
00:43:13,030 --> 00:43:13,040
일반적으로 선형 시간이 걸립니다.
 

1691
00:43:13,040 --> 00:43:14,030
일반적으로 선형 시간이 걸립니다.
왜냐하면 모든

1692
00:43:14,030 --> 00:43:14,040
왜냐하면 모든
 

1693
00:43:14,040 --> 00:43:15,510
왜냐하면 모든
하위 경로,

1694
00:43:15,510 --> 00:43:15,520
하위 경로,
 

1695
00:43:15,520 --> 00:43:19,630
하위 경로,
즉 서브트리 내의 모든 리프 노드를 살펴봐야 하기 때문입니다. 하지만 높이는 서브트리의 속성입니다. 네,

1696
00:43:19,630 --> 00:43:23,829
즉 서브트리 내의 모든 리프 노드를 살펴봐야 하기 때문입니다. 하지만 높이는 서브트리의 속성입니다. 네,
 

1697
00:43:23,829 --> 00:43:23,839

 

1698
00:43:23,839 --> 00:43:28,069

높이가 중요하죠.

1699
00:43:28,069 --> 00:43:28,079

 

1700
00:43:28,079 --> 00:43:29,829


1701
00:43:29,829 --> 00:43:29,839

 

1702
00:43:29,839 --> 00:43:33,630

왜냐하면... 여기

1703
00:43:33,630 --> 00:43:33,640
왜냐하면... 여기
 

1704
00:43:33,640 --> 00:43:37,030
왜냐하면... 여기
노드라고 적어 놓겠습니다.

1705
00:43:37,030 --> 00:43:37,040

 

1706
00:43:37,040 --> 00:43:48,150

높이는 노드의 최대값에 1을 더한 값과 같습니다.  왼쪽.

1707
00:43:48,150 --> 00:43:48,160

 

1708
00:43:48,160 --> 00:43:54,829

키가 크고 제대로 하지 못한다.

1709
00:43:54,829 --> 00:43:54,839

 

1710
00:43:54,839 --> 00:43:59,510

높이와 Max 값을 상자에 넣어두겠습니다.

1711
00:43:59,510 --> 00:43:59,520
높이와 Max 값을 상자에 넣어두겠습니다.
 

1712
00:43:59,520 --> 00:44:01,270
높이와 Max 값을 상자에 넣어두겠습니다.

1713
00:44:01,270 --> 00:44:01,280

 

1714
00:44:01,280 --> 00:44:03,829

이 방정식, 또는

1715
00:44:03,829 --> 00:44:03,839
이 방정식, 또는
 

1716
00:44:03,839 --> 00:44:07,549
이 방정식, 또는
할당 연산이라고 할 수 있겠네요. 이것은

1717
00:44:07,549 --> 00:44:07,559
할당 연산이라고 할 수 있겠네요. 이것은
 

1718
00:44:07,559 --> 00:44:09,670
할당 연산이라고 할 수 있겠네요. 이것은
우리가 계속해서 해왔던 것입니다. 제가

1719
00:44:09,670 --> 00:44:11,030
우리가 계속해서 해왔던 것입니다. 제가
 

1720
00:44:11,030 --> 00:44:11,040

 

1721
00:44:11,040 --> 00:44:12,670

이 노드의 높이가 얼마냐고 물었을 때 여러분은 이미 계산해냈죠.

1722
00:44:12,670 --> 00:44:12,680
이 노드의 높이가 얼마냐고 물었을 때 여러분은 이미 계산해냈죠.
 

1723
00:44:12,680 --> 00:44:13,750
이 노드의 높이가 얼마냐고 물었을 때 여러분은 이미 계산해냈죠.
왼쪽

1724
00:44:13,750 --> 00:44:13,760
왼쪽
 

1725
00:44:13,760 --> 00:44:15,109
왼쪽
서브트리의 높이와 오른쪽 서브트리의 높이를 곱하고,

1726
00:44:15,109 --> 00:44:17,349
서브트리의 높이와 오른쪽 서브트리의 높이를 곱하고,
 

1727
00:44:17,349 --> 00:44:17,359

 

1728
00:44:17,359 --> 00:44:19,750

이 간선들을 고려하기 위해 1을 더한 것입니다. 자, 이것은

1729
00:44:19,750 --> 00:44:19,760
이 간선들을 고려하기 위해 1을 더한 것입니다. 자, 이것은
 

1730
00:44:19,760 --> 00:44:21,790
이 간선들을 고려하기 위해 1을 더한 것입니다. 자, 이것은
일반적인 업데이트 규칙입니다. 이

1731
00:44:21,790 --> 00:44:21,800
일반적인 업데이트 규칙입니다. 이
 

1732
00:44:21,800 --> 00:44:24,069
일반적인 업데이트 규칙입니다. 이
서브트리 속성 패턴과 일치합니다.

1733
00:44:24,069 --> 00:44:24,079
서브트리 속성 패턴과 일치합니다.
 

1734
00:44:24,079 --> 00:44:25,910
서브트리 속성 패턴과 일치합니다.
왼쪽과 오른쪽 속성이 있으면 노드의 높이를 계산할 수 있고,

1735
00:44:25,910 --> 00:44:27,910
왼쪽과 오른쪽 속성이 있으면 노드의 높이를 계산할 수 있고,
 

1736
00:44:27,910 --> 00:44:27,920

 

1737
00:44:27,920 --> 00:44:29,670

이 작업은 상수 시간으로 완료됩니다.

1738
00:44:29,670 --> 00:44:29,680
이 작업은 상수 시간으로 완료됩니다.
 

1739
00:44:29,680 --> 00:44:31,150
이 작업은 상수 시간으로 완료됩니다.
따라서 서브트리 속성이므로

1740
00:44:31,150 --> 00:44:31,160
따라서 서브트리 속성이므로
 

1741
00:44:31,160 --> 00:44:32,950
따라서 서브트리 속성이므로
제가 하는 모든 작업에서

1742
00:44:32,950 --> 00:44:32,960
제가 하는 모든 작업에서
 

1743
00:44:32,960 --> 00:44:34,950
제가 하는 모든 작업에서
모든 노드의 높이를 유지할 수 있습니다. 아, 그리고

1744
00:44:34,950 --> 00:44:34,960
모든 노드의 높이를 유지할 수 있습니다. 아, 그리고
 

1745
00:44:34,960 --> 00:44:38,270
모든 노드의 높이를 유지할 수 있습니다. 아, 그리고
회전을 할 때마다

1746
00:44:38,270 --> 00:44:38,280
회전을 할 때마다
 

1747
00:44:38,280 --> 00:44:40,230
회전을 할 때마다
서브트리

1748
00:44:40,230 --> 00:44:40,240
서브트리
 

1749
00:44:40,240 --> 00:44:43,950
서브트리
속성도 업데이트해야 합니다. 이 간선을 회전해도 A,

1750
00:44:43,950 --> 00:44:43,960
속성도 업데이트해야 합니다. 이 간선을 회전해도 A,
 

1751
00:44:43,960 --> 00:44:46,069
속성도 업데이트해야 합니다. 이 간선을 회전해도 A,
B, C는 변하지 않습니다.

1752
00:44:46,069 --> 00:44:46,079
B, C는 변하지 않습니다.
 

1753
00:44:46,079 --> 00:44:49,150
B, C는 변하지 않습니다.
좋습니다. 하지만 X의 서브

1754
00:44:49,150 --> 00:44:49,160
좋습니다. 하지만 X의 서브
 

1755
00:44:49,160 --> 00:44:51,230
좋습니다. 하지만 X의 서브
트리는 이제 변합니다.

1756
00:44:51,230 --> 00:44:51,240
트리는 이제 변합니다.
 

1757
00:44:51,240 --> 00:44:54,430
트리는 이제 변합니다.
이전에는 왜 변하지 않았는지 모르겠네요. 그래서

1758
00:44:54,430 --> 00:44:58,109
이전에는 왜 변하지 않았는지 모르겠네요. 그래서
 

1759
00:44:58,109 --> 00:44:58,119

 

1760
00:44:58,119 --> 00:45:00,309

Y의 증강 값과

1761
00:45:00,309 --> 00:45:02,790
Y의 증강 값과
 

1762
00:45:02,790 --> 00:45:02,800

 

1763
00:45:02,800 --> 00:45:05,030

X의 증강 값도 업데이트해야 합니다.  X

1764
00:45:05,030 --> 00:45:05,040
X의 증강 값도 업데이트해야 합니다.  X
 

1765
00:45:05,040 --> 00:45:07,190
X의 증강 값도 업데이트해야 합니다.  X
의 모든 조상 노드의 증강을

1766
00:45:07,190 --> 00:45:07,200
의 모든 조상 노드의 증강을
 

1767
00:45:07,200 --> 00:45:12,270
의 모든 조상 노드의 증강을
결국 업데이트해야 합니다. 회전은 로컬에서

1768
00:45:12,270 --> 00:45:12,280
결국 업데이트해야 합니다. 회전은 로컬에서
 

1769
00:45:12,280 --> 00:45:13,549
결국 업데이트해야 합니다. 회전은 로컬에서
상수 개수의 포인터만 변경하는 작업이므로

1770
00:45:13,549 --> 00:45:13,559
상수 개수의 포인터만 변경하는 작업이므로
 

1771
00:45:13,559 --> 00:45:15,150
상수 개수의 포인터만 변경하는 작업이므로
일반적으로 회전은

1772
00:45:15,150 --> 00:45:15,160
일반적으로 회전은
 

1773
00:45:15,160 --> 00:45:16,950
일반적으로 회전은
상수

1774
00:45:16,950 --> 00:45:16,960
상수
 

1775
00:45:16,960 --> 00:45:19,790
상수
시간으로 처리된다고 생각합니다. 하지만 결국에는

1776
00:45:19,790 --> 00:45:22,670
시간으로 처리된다고 생각합니다. 하지만 결국에는
 

1777
00:45:22,670 --> 00:45:22,680

 

1778
00:45:22,680 --> 00:45:24,390

로컬에서 상수 시간으로 처리해야 합니다.

1779
00:45:24,390 --> 00:45:32,470
로컬에서 상수 시간으로 처리해야 합니다.
 

1780
00:45:32,470 --> 00:45:34,270

 

1781
00:45:34,270 --> 00:45:34,280

 

1782
00:45:34,280 --> 00:45:36,910

모든 증강을 최신 상태로 유지하려면 H개의 조상 노드를 업데이트해야 합니다. 이 부분은

1783
00:45:36,910 --> 00:45:39,349
모든 증강을 최신 상태로 유지하려면 H개의 조상 노드를 업데이트해야 합니다. 이 부분은
 

1784
00:45:39,349 --> 00:45:42,390

 

1785
00:45:42,390 --> 00:45:42,400

 

1786
00:45:42,400 --> 00:45:44,750

나중에 처리하도록 하겠습니다. 좋습니다. 이제

1787
00:45:44,750 --> 00:45:44,760
나중에 처리하도록 하겠습니다. 좋습니다. 이제
 

1788
00:45:44,760 --> 00:45:46,270
나중에 처리하도록 하겠습니다. 좋습니다. 이제
모든 노드의 높이를 알았으니

1789
00:45:46,270 --> 00:45:46,280
모든 노드의 높이를 알았으니
 

1790
00:45:46,280 --> 00:45:50,829
모든 노드의 높이를 알았으니
모든 노드의 SK 왜곡을 계산할 수 있습니다. 좋습니다.

1791
00:45:50,829 --> 00:45:50,839
모든 노드의 SK 왜곡을 계산할 수 있습니다. 좋습니다.
 

1792
00:45:50,839 --> 00:45:52,870
모든 노드의 SK 왜곡을 계산할 수 있습니다. 좋습니다.
회전 연산을 수행하면서

1793
00:45:52,870 --> 00:45:52,880
회전 연산을 수행하면서
 

1794
00:45:52,880 --> 00:45:53,829
회전 연산을 수행하면서

1795
00:45:53,829 --> 00:45:53,839

 

1796
00:45:53,839 --> 00:45:55,670


1797
00:45:55,670 --> 00:45:55,680

 

1798
00:45:55,680 --> 00:45:58,470

높이 균형 속성을 유지해야 합니다.

1799
00:45:58,470 --> 00:45:58,480
높이 균형 속성을 유지해야 합니다.
 

1800
00:45:58,480 --> 00:46:00,670
높이 균형 속성을 유지해야 합니다.
모든 노드의 왼쪽 노드 높이와 오른쪽 노드 높이의 합이 ±

1801
00:46:00,670 --> 00:46:00,680
모든 노드의 왼쪽 노드 높이와 오른쪽 노드 높이의 합이 ±
 

1802
00:46:00,680 --> 00:46:03,670
모든 노드의 왼쪽 노드 높이와 오른쪽 노드 높이의 합이 ±
1 또는

1803
00:46:03,670 --> 00:46:03,680
1 또는
 

1804
00:46:03,680 --> 00:46:05,309
1 또는
0 이내여야 합니다. 좋습니다.

1805
00:46:05,309 --> 00:46:05,319
0 이내여야 합니다. 좋습니다.
 

1806
00:46:05,319 --> 00:46:08,150
0 이내여야 합니다. 좋습니다.

1807
00:46:08,150 --> 00:46:08,160

 

1808
00:46:08,160 --> 00:46:11,790

제가 앞서 언급했듯이 트리를 변경하는

1809
00:46:11,790 --> 00:46:11,800
제가 앞서 언급했듯이 트리를 변경하는
 

1810
00:46:11,800 --> 00:46:14,630
제가 앞서 언급했듯이 트리를 변경하는
유일한 요소는

1811
00:46:14,630 --> 00:46:15,950
유일한 요소는
 

1812
00:46:15,950 --> 00:46:15,960

 

1813
00:46:15,960 --> 00:46:18,470

새 노드를 삽입하거나 삭제할 때입니다.

1814
00:46:18,470 --> 00:46:18,480
새 노드를 삽입하거나 삭제할 때입니다.
 

1815
00:46:18,480 --> 00:46:20,510
새 노드를 삽입하거나 삭제할 때입니다.
지금까지 구현한 방식은

1816
00:46:20,510 --> 00:46:20,520
지금까지 구현한 방식은
 

1817
00:46:20,520 --> 00:46:22,710
지금까지 구현한 방식은
리프 노드를 추가하거나 제거하는 것이었으므로 리프 노드

1818
00:46:22,710 --> 00:46:22,720
리프 노드를 추가하거나 제거하는 것이었으므로 리프 노드
 

1819
00:46:22,720 --> 00:46:24,829
리프 노드를 추가하거나 제거하는 것이었으므로 리프 노드
추가 또는 제거에 대해 계속 생각해야 합니다.

1820
00:46:24,829 --> 00:46:24,839
추가 또는 제거에 대해 계속 생각해야 합니다.
 

1821
00:46:24,839 --> 00:46:26,470
추가 또는 제거에 대해 계속 생각해야 합니다.
문제는 새 리프 노드를 추가하면

1822
00:46:26,470 --> 00:46:26,480
문제는 새 리프 노드를 추가하면
 

1823
00:46:26,480 --> 00:46:27,510
문제는 새 리프 노드를 추가하면

1824
00:46:27,510 --> 00:46:27,520

 

1825
00:46:27,520 --> 00:46:30,109

트리가 이전보다 높아질 수 있다는 것입니다.

1826
00:46:30,109 --> 00:46:33,630
트리가 이전보다 높아질 수 있다는 것입니다.
 

1827
00:46:33,630 --> 00:46:33,640

 

1828
00:46:33,640 --> 00:46:35,910

따라서 일부 노드의 높이 균형이 깨질 수 있습니다.

1829
00:46:35,910 --> 00:46:35,920
따라서 일부 노드의 높이 균형이 깨질 수 있습니다.
 

1830
00:46:35,920 --> 00:46:37,870
따라서 일부 노드의 높이 균형이 깨질 수 있습니다.
높이는 서브트리 속성이므로

1831
00:46:37,870 --> 00:46:37,880
높이는 서브트리 속성이므로
 

1832
00:46:37,880 --> 00:46:40,309
높이는 서브트리 속성이므로
확인해야 할 노드는 이 조상 경로 위에 있는 노드뿐입니다.

1833
00:46:40,309 --> 00:46:42,710
확인해야 할 노드는 이 조상 경로 위에 있는 노드뿐입니다.
 

1834
00:46:42,710 --> 00:46:42,720

 

1835
00:46:42,720 --> 00:46:44,430

따라서 현재 높이가 log n이므로 노드의 수는 log n개뿐입니다. 방금

1836
00:46:44,430 --> 00:46:44,440
따라서 현재 높이가 log n이므로 노드의 수는 log n개뿐입니다. 방금
 

1837
00:46:44,440 --> 00:46:46,790
따라서 현재 높이가 log n이므로 노드의 수는 log n개뿐입니다. 방금
증명했듯이

1838
00:46:46,790 --> 00:46:46,800
증명했듯이
 

1839
00:46:46,800 --> 00:46:48,430
증명했듯이
이 속성이 유지되는 한, 현재는

1840
00:46:48,430 --> 00:46:48,440
이 속성이 유지되는 한, 현재는
 

1841
00:46:48,440 --> 00:46:51,150
이 속성이 유지되는 한, 현재는
몇몇 노드에 대해서는 이 속성이 적용되지 않지만, 이전에는

1842
00:46:51,150 --> 00:46:51,160
몇몇 노드에 대해서는 이 속성이 적용되지 않지만, 이전에는
 

1843
00:46:51,160 --> 00:46:53,470
몇몇 노드에 대해서는 이 속성이 적용되지 않지만, 이전에는
log n이었지만 현재는

1844
00:46:53,470 --> 00:46:53,480
log n이었지만 현재는
 

1845
00:46:53,480 --> 00:46:55,630
log n이었지만 현재는
최대 log n + 2 log n + 1입니다. 방금

1846
00:46:55,630 --> 00:46:55,640
최대 log n + 2 log n + 1입니다. 방금
 

1847
00:46:55,640 --> 00:46:58,309
최대 log n + 2 log n + 1입니다. 방금
노드를 하나 추가했기 때문입니다. 이제

1848
00:46:58,309 --> 00:47:00,069
노드를 하나 추가했기 때문입니다. 이제
 

1849
00:47:00,069 --> 00:47:02,630

 

1850
00:47:02,630 --> 00:47:02,640

 

1851
00:47:02,640 --> 00:47:05,430

아래에서 위로 순서대로 모든 조상 노드를 확인하고 균형이 맞지 않는 노드를 찾아보겠습니다. 가장 아래쪽에 있는 균형이 맞지

1852
00:47:05,430 --> 00:47:10,870
아래에서 위로 순서대로 모든 조상 노드를 확인하고 균형이 맞지 않는 노드를 찾아보겠습니다. 가장 아래쪽에 있는 균형이 맞지
 

1853
00:47:10,870 --> 00:47:10,880

 

1854
00:47:10,880 --> 00:47:13,349


1855
00:47:13,349 --> 00:47:13,359

 

1856
00:47:13,359 --> 00:47:20,990

않는

1857
00:47:20,990 --> 00:47:21,000

 

1858
00:47:21,000 --> 00:47:25,109

노드를 X라고 하겠습니다. 방금

1859
00:47:25,109 --> 00:47:26,990
노드를 X라고 하겠습니다. 방금
 

1860
00:47:26,990 --> 00:47:27,000

 

1861
00:47:27,000 --> 00:47:30,390

리프 노드 하나를 삽입하거나 삭제했으므로 균형이 맞지 않는 값은

1862
00:47:30,390 --> 00:47:30,400
리프 노드 하나를 삽입하거나 삭제했으므로 균형이 맞지 않는 값은
 

1863
00:47:30,400 --> 00:47:33,670
리프 노드 하나를 삽입하거나 삭제했으므로 균형이 맞지 않는 값은
1입니다. 높이가 하나만 변경되었기 때문입니다. 높이가 1 증가하거나 1

1864
00:47:33,670 --> 00:47:35,470
1입니다. 높이가 하나만 변경되었기 때문입니다. 높이가 1 증가하거나 1
 

1865
00:47:35,470 --> 00:47:35,480

 

1866
00:47:35,480 --> 00:47:38,309

감소했습니다. 이전에는 모든

1867
00:47:38,309 --> 00:47:38,319
감소했습니다. 이전에는 모든
 

1868
00:47:38,319 --> 00:47:40,990
감소했습니다. 이전에는 모든
SKS 값이 ±1 또는 0이었습니다.

1869
00:47:40,990 --> 00:47:41,000
SKS 값이 ±1 또는 0이었습니다.
 

1870
00:47:41,000 --> 00:47:42,990
SKS 값이 ±1 또는 0이었습니다.
이제 최악의 경우는

1871
00:47:42,990 --> 00:47:43,000
이제 최악의 경우는
 

1872
00:47:43,000 --> 00:47:45,470
이제 최악의 경우는
±2가 되는 경우입니다.

1873
00:47:45,470 --> 00:47:45,480
±2가 되는 경우입니다.
 

1874
00:47:45,480 --> 00:47:46,790
±2가 되는 경우입니다.
모든 노드의 SKS 값이 이 범위 내에 있으면

1875
00:47:46,790 --> 00:47:46,800
모든 노드의 SKS 값이 이 범위 내에 있으면
 

1876
00:47:46,800 --> 00:47:48,710
모든 노드의 SKS 값이 이 범위 내에 있으면
괜찮지만, 범위를 벗어나면 문제가 없습니다.

1877
00:47:48,710 --> 00:47:48,720
괜찮지만, 범위를 벗어나면 문제가 없습니다.
 

1878
00:47:48,720 --> 00:47:51,349
괜찮지만, 범위를 벗어나면 문제가 없습니다.
1만큼만 차이가 날 거예요. 그러니까

1879
00:47:51,349 --> 00:47:52,750
1만큼만 차이가 날 거예요. 그러니까
 

1880
00:47:52,750 --> 00:47:52,760

 

1881
00:47:52,760 --> 00:47:57,710

왜곡도가 +2 또는 -2라는 뜻이죠.

1882
00:47:57,710 --> 00:48:01,150
왜곡도가 +2 또는 -2라는 뜻이죠.
 

1883
00:48:01,150 --> 00:48:01,160

 

1884
00:48:01,160 --> 00:48:04,950

대칭 때문에 2라고 해볼게요. 제 그림에서는

1885
00:48:04,950 --> 00:48:04,960
대칭 때문에 2라고 해볼게요. 제 그림에서는
 

1886
00:48:04,960 --> 00:48:08,990
대칭 때문에 2라고 해볼게요. 제 그림에서는
오른쪽

1887
00:48:08,990 --> 00:48:09,000
오른쪽
 

1888
00:48:09,000 --> 00:48:13,470
오른쪽
화살표 두 개를 그려서

1889
00:48:13,470 --> 00:48:13,480

 

1890
00:48:13,480 --> 00:48:17,150

이 서브트리가

1891
00:48:17,150 --> 00:48:17,160
이 서브트리가
 

1892
00:48:17,160 --> 00:48:19,910
이 서브트리가
저 서브트리보다 2만큼 높다는 걸 나타낼게요. 이건 잘못된 거고,

1893
00:48:19,910 --> 00:48:19,920
저 서브트리보다 2만큼 높다는 걸 나타낼게요. 이건 잘못된 거고,
 

1894
00:48:19,920 --> 00:48:23,510
저 서브트리보다 2만큼 높다는 걸 나타낼게요. 이건 잘못된 거고,
고쳐야 해요. 가장 확실한 방법은

1895
00:48:23,510 --> 00:48:23,520
고쳐야 해요. 가장 확실한 방법은
 

1896
00:48:23,520 --> 00:48:25,790
고쳐야 해요. 가장 확실한 방법은
이 모서리를 회전시키는 거예요. 그러면

1897
00:48:25,790 --> 00:48:25,800
이 모서리를 회전시키는 거예요. 그러면
 

1898
00:48:25,800 --> 00:48:27,990
이 모서리를 회전시키는 거예요. 그러면
이쪽은

1899
00:48:27,990 --> 00:48:28,000
이쪽은
 

1900
00:48:28,000 --> 00:48:31,470
이쪽은
너무 높고, 이쪽은 너무 낮으니까요.

1901
00:48:31,470 --> 00:48:31,480
너무 높고, 이쪽은 너무 낮으니까요.
 

1902
00:48:31,480 --> 00:48:33,150
너무 높고, 이쪽은 너무 낮으니까요.
회전시키면 이쪽은 1만큼 내려가고,

1903
00:48:33,150 --> 00:48:33,160
회전시키면 이쪽은 1만큼 내려가고,
 

1904
00:48:33,160 --> 00:48:34,670
회전시키면 이쪽은 1만큼 내려가고,
이쪽은 1만큼 올라가겠죠.

1905
00:48:34,670 --> 00:48:34,680
이쪽은 1만큼 올라가겠죠.
 

1906
00:48:34,680 --> 00:48:37,069
이쪽은 1만큼 올라가겠죠.
대부분의 경우에 이렇게 하면 돼요. 첫 번째 경우는

1907
00:48:37,069 --> 00:48:40,109
대부분의 경우에 이렇게 하면 돼요. 첫 번째 경우는
 

1908
00:48:40,109 --> 00:48:42,829

 

1909
00:48:42,829 --> 00:48:42,839

 

1910
00:48:42,839 --> 00:48:47,190

Y의 왜곡도가 0일 때예요. 저는 Y가

1911
00:48:47,190 --> 00:48:47,200
Y의 왜곡도가 0일 때예요. 저는 Y가
 

1912
00:48:47,200 --> 00:48:51,030
Y의 왜곡도가 0일 때예요. 저는 Y가
X의 오른쪽 자식이 되길 원해요. 왜곡도가 양수니까

1913
00:48:51,030 --> 00:48:51,040
X의 오른쪽 자식이 되길 원해요. 왜곡도가 양수니까
 

1914
00:48:51,040 --> 00:48:53,349
X의 오른쪽 자식이 되길 원해요. 왜곡도가 양수니까
오른쪽

1915
00:48:53,349 --> 00:48:53,359
오른쪽
 

1916
00:48:53,359 --> 00:48:56,349
오른쪽
자식이 있다는 걸 알 수 있죠. 이제 이게 가장 낮았으니,

1917
00:48:56,349 --> 00:48:56,359
자식이 있다는 걸 알 수 있죠. 이제 이게 가장 낮았으니,
 

1918
00:48:56,359 --> 00:48:58,990
자식이 있다는 걸 알 수 있죠. 이제 이게 가장 낮았으니,
Y는 사실 좋은 상태라는 걸 알 수 있어요.

1919
00:48:58,990 --> 00:48:59,000
Y는 사실 좋은 상태라는 걸 알 수 있어요.
 

1920
00:48:59,000 --> 00:49:01,990
Y는 사실 좋은 상태라는 걸 알 수 있어요.
오른쪽으로 치우쳐 있거나, 두 서브

1921
00:49:01,990 --> 00:49:02,000
오른쪽으로 치우쳐 있거나, 두 서브
 

1922
00:49:02,000 --> 00:49:04,829
오른쪽으로 치우쳐 있거나, 두 서브
트리의 높이가 같거나, 왼쪽으로 치우쳐 있는 경우죠.

1923
00:49:04,829 --> 00:49:04,839
트리의 높이가 같거나, 왼쪽으로 치우쳐 있는 경우죠.
 

1924
00:49:04,839 --> 00:49:05,990
트리의 높이가 같거나, 왼쪽으로 치우쳐 있는 경우죠.
쉬운 경우는

1925
00:49:05,990 --> 00:49:11,309
쉬운 경우는
 

1926
00:49:11,309 --> 00:49:11,319

 

1927
00:49:11,319 --> 00:49:20,710

Y의 왜곡도가 1 또는

1928
00:49:20,710 --> 00:49:20,720

 

1929
00:49:20,720 --> 00:49:29,270

0일 때예요. 제가 모두 그려볼게요. 오른쪽

1930
00:49:29,270 --> 00:49:29,280

 

1931
00:49:29,280 --> 00:49:32,390

화살표 두 개, 오른쪽

1932
00:49:32,390 --> 00:49:39,430
화살표 두 개, 오른쪽
 

1933
00:49:39,430 --> 00:49:39,440

 

1934
00:49:39,440 --> 00:49:42,309

화살표 하나.

1935
00:49:42,309 --> 00:49:42,319
화살표 하나.
 

1936
00:49:42,319 --> 00:49:47,549
화살표 하나.
이 그림을 일관성 있게 만들기 위해 여기에 몇 가지 레이블을 추가하겠습니다.

1937
00:49:47,549 --> 00:49:47,559

 

1938
00:49:47,559 --> 00:49:51,309

k + 1, k + 2, 높이를 적겠습니다.

1939
00:49:51,309 --> 00:49:53,430
k + 1, k + 2, 높이를 적겠습니다.
 

1940
00:49:53,430 --> 00:49:53,440

 

1941
00:49:53,440 --> 00:49:57,190

예를 들어 C가 b보다 키가 큰 경우입니다.

1942
00:49:57,190 --> 00:49:57,200
예를 들어 C가 b보다 키가 큰 경우입니다.
 

1943
00:49:57,200 --> 00:49:59,230
예를 들어 C가 b보다 키가 큰 경우입니다.
A와 B는 높이가 같습니다.

1944
00:49:59,230 --> 00:49:59,240
A와 B는 높이가 같습니다.
 

1945
00:49:59,240 --> 00:50:00,829
A와 B는 높이가 같습니다.
여기서 높이를 계산해 보면,

1946
00:50:00,829 --> 00:50:00,839
여기서 높이를 계산해 보면,
 

1947
00:50:00,839 --> 00:50:03,589
여기서 높이를 계산해 보면,
이 노드는 오른쪽으로 기울어져 있고, 이 노드는 두 방향으로 오른쪽으로

1948
00:50:03,589 --> 00:50:03,599
이 노드는 오른쪽으로 기울어져 있고, 이 노드는 두 방향으로 오른쪽으로
 

1949
00:50:03,599 --> 00:50:05,829
이 노드는 오른쪽으로 기울어져 있고, 이 노드는 두 방향으로 오른쪽으로
기울어져 있습니다. 이 노드는

1950
00:50:05,829 --> 00:50:05,839
기울어져 있습니다. 이 노드는
 

1951
00:50:05,839 --> 00:50:07,470
기울어져 있습니다. 이 노드는
높이가 k + 1이고, 이 노드는 높이가 k - 1입니다. 이건 좋지 않지만,

1952
00:50:07,470 --> 00:50:09,510
높이가 k + 1이고, 이 노드는 높이가 k - 1입니다. 이건 좋지 않지만,
 

1953
00:50:09,510 --> 00:50:09,520

 

1954
00:50:09,520 --> 00:50:13,589

X축을 기준으로 오른쪽으로 회전시키면

1955
00:50:13,589 --> 00:50:13,599
X축을 기준으로 오른쪽으로 회전시키면
 

1956
00:50:13,599 --> 00:50:16,829
X축을 기준으로 오른쪽으로 회전시키면

1957
00:50:16,829 --> 00:50:16,839

 

1958
00:50:16,839 --> 00:50:19,630

원하는 결과를 얻을 수 있습니다. 그래서

1959
00:50:19,630 --> 00:50:19,640
원하는 결과를 얻을 수 있습니다. 그래서
 

1960
00:50:19,640 --> 00:50:22,670
원하는 결과를 얻을 수 있습니다. 그래서
ABC에 레이블을 복사해서 k - 1, k -

1961
00:50:22,670 --> 00:50:22,680
ABC에 레이블을 복사해서 k - 1, k -
 

1962
00:50:22,680 --> 00:50:24,950
ABC에 레이블을 복사해서 k - 1, k -
1, K라고 적고 다시 계산해 보겠습니다. 그러면

1963
00:50:24,950 --> 00:50:24,960
1, K라고 적고 다시 계산해 보겠습니다. 그러면
 

1964
00:50:24,960 --> 00:50:27,109
1, K라고 적고 다시 계산해 보겠습니다. 그러면
이 노드는 높이가 K이고, 이 노드는

1965
00:50:27,109 --> 00:50:27,119
이 노드는 높이가 K이고, 이 노드는
 

1966
00:50:27,119 --> 00:50:30,510
이 노드는 높이가 K이고, 이 노드는
높이가 k + 1입니다. 이제

1967
00:50:30,510 --> 00:50:30,520
높이가 k + 1입니다. 이제
 

1968
00:50:30,520 --> 00:50:32,030
높이가 k + 1입니다. 이제
제가 강조 표시한 A와

1969
00:50:32,030 --> 00:50:32,040
제가 강조 표시한 A와
 

1970
00:50:32,040 --> 00:50:33,230
제가 강조 표시한 A와
C 노드는 변하지 않았습니다.

1971
00:50:33,230 --> 00:50:33,240
C 노드는 변하지 않았습니다.
 

1972
00:50:33,240 --> 00:50:35,630
C 노드는 변하지 않았습니다.
이전에도 높이가 균형을 이루었고, 지금도 그렇습니다. 하지만

1973
00:50:35,630 --> 00:50:35,640
이전에도 높이가 균형을 이루었고, 지금도 그렇습니다. 하지만
 

1974
00:50:35,640 --> 00:50:37,789
이전에도 높이가 균형을 이루었고, 지금도 그렇습니다. 하지만
X와 Y 노드는 어떨까요? 이전에는 X가 높이 균형을 이루지 못했지만,

1975
00:50:37,789 --> 00:50:37,799
X와 Y 노드는 어떨까요? 이전에는 X가 높이 균형을 이루지 못했지만,
 

1976
00:50:37,799 --> 00:50:41,069
X와 Y 노드는 어떨까요? 이전에는 X가 높이 균형을 이루지 못했지만,
이제 X와 Y 모두 높이

1977
00:50:41,069 --> 00:50:41,079
이제 X와 Y 모두 높이
 

1978
00:50:41,079 --> 00:50:44,910
이제 X와 Y 모두 높이
균형을 이룹니다. 이것이 첫 번째 경우입니다.

1979
00:50:44,910 --> 00:50:44,920
균형을 이룹니다. 이것이 첫 번째 경우입니다.
 

1980
00:50:44,920 --> 00:50:50,670
균형을 이룹니다. 이것이 첫 번째 경우입니다.
두 번째 경우, Y 노드의 SK가 평평합니다. 즉,

1981
00:50:50,670 --> 00:50:50,680
두 번째 경우, Y 노드의 SK가 평평합니다. 즉,
 

1982
00:50:50,680 --> 00:50:55,349
두 번째 경우, Y 노드의 SK가 평평합니다. 즉,
이 노드는 k, 이 노드는 k, 이 노드는

1983
00:50:55,349 --> 00:50:55,359
이 노드는 k, 이 노드는 k, 이 노드는
 

1984
00:50:55,359 --> 00:50:58,390
이 노드는 k, 이 노드는 k, 이 노드는
k + 1입니다.  그리고 이건 K+2입니다.

1985
00:50:58,390 --> 00:50:58,400
k + 1입니다.  그리고 이건 K+2입니다.
 

1986
00:50:58,400 --> 00:50:59,789
k + 1입니다.  그리고 이건 K+2입니다.
하지만 여전히 모든 노드의

1987
00:50:59,789 --> 00:50:59,799
하지만 여전히 모든 노드의
 

1988
00:50:59,799 --> 00:51:01,710
하지만 여전히 모든 노드의
높이가 균형을 이루고 있습니다. 여전히 ±1 범위 내에 있습니다.

1989
00:51:01,710 --> 00:51:01,720
높이가 균형을 이루고 있습니다. 여전히 ±1 범위 내에 있습니다.
 

1990
00:51:01,720 --> 00:51:03,950
높이가 균형을 이루고 있습니다. 여전히 ±1 범위 내에 있습니다.
그래서 이것들은 쉬운

1991
00:51:03,950 --> 00:51:03,960
그래서 이것들은 쉬운
 

1992
00:51:03,960 --> 00:51:06,430
그래서 이것들은 쉬운
경우입니다. 불행히도 어려운 경우가 하나 있는데,

1993
00:51:06,430 --> 00:51:06,440
경우입니다. 불행히도 어려운 경우가 하나 있는데,
 

1994
00:51:06,440 --> 00:51:10,150
경우입니다. 불행히도 어려운 경우가 하나 있는데,
세 번째 경우입니다. 하지만 하나뿐이고 그렇게

1995
00:51:10,150 --> 00:51:15,430
세 번째 경우입니다. 하지만 하나뿐이고 그렇게
 

1996
00:51:15,430 --> 00:51:15,440

 

1997
00:51:15,440 --> 00:51:20,870

어렵지는 않습니다. Y의 기울기가 -1인 경우입니다.

1998
00:51:20,870 --> 00:51:20,880
어렵지는 않습니다. Y의 기울기가 -1인 경우입니다.
 

1999
00:51:20,880 --> 00:51:23,470
어렵지는 않습니다. Y의 기울기가 -1인 경우입니다.
이 경우

2000
00:51:23,470 --> 00:51:23,480
이 경우
 

2001
00:51:23,480 --> 00:51:27,309
이 경우
Y의 왼쪽 자식을 살펴봐야 합니다.

2002
00:51:27,309 --> 00:51:27,319
Y의 왼쪽 자식을 살펴봐야 합니다.
 

2003
00:51:27,319 --> 00:51:30,589
Y의 왼쪽 자식을 살펴봐야 합니다.
알파벳 순서대로

2004
00:51:30,589 --> 00:51:32,270
알파벳 순서대로
 

2005
00:51:32,270 --> 00:51:32,280

 

2006
00:51:32,280 --> 00:51:35,710

Z로 이름을 바꾸겠습니다. 죄송합니다. 이것은 다시 오른쪽 화살표이고,

2007
00:51:35,710 --> 00:51:35,720
Z로 이름을 바꾸겠습니다. 죄송합니다. 이것은 다시 오른쪽 화살표이고,
 

2008
00:51:35,720 --> 00:51:38,670
Z로 이름을 바꾸겠습니다. 죄송합니다. 이것은 다시 오른쪽 화살표이고,
이것은 왼쪽

2009
00:51:38,670 --> 00:51:38,680
이것은 왼쪽
 

2010
00:51:38,680 --> 00:51:42,549
이것은 왼쪽
화살표입니다. 그리고 이것은 Y입니다. 따라서

2011
00:51:42,549 --> 00:51:42,559
화살표입니다. 그리고 이것은 Y입니다. 따라서
 

2012
00:51:42,559 --> 00:51:44,870
화살표입니다. 그리고 이것은 Y입니다. 따라서
a, b,

2013
00:51:44,870 --> 00:51:44,880
a, b,
 

2014
00:51:44,880 --> 00:51:49,710
a, b,
c, d와 같은 잠재적인 서브 트리가

2015
00:51:49,710 --> 00:51:49,720
c, d와 같은 잠재적인 서브 트리가
 

2016
00:51:49,720 --> 00:51:52,150
c, d와 같은 잠재적인 서브 트리가
이들로부터 연결되어 있습니다.

2017
00:51:52,150 --> 00:51:52,160
이들로부터 연결되어 있습니다.
 

2018
00:51:52,160 --> 00:51:55,030
이들로부터 연결되어 있습니다.
이들의 높이를 각각 K-

2019
00:51:55,030 --> 00:51:55,040
이들의 높이를 각각 K-
 

2020
00:51:55,040 --> 00:51:59,710
이들의 높이를 각각 K-
1 또는 K-2로 표시하겠습니다. 이것은 K-1입니다.

2021
00:51:59,710 --> 00:51:59,720
1 또는 K-2로 표시하겠습니다. 이것은 K-1입니다.
 

2022
00:51:59,720 --> 00:52:02,470
1 또는 K-2로 표시하겠습니다. 이것은 K-1입니다.
이제 내부를 계산해 보겠습니다.

2023
00:52:02,470 --> 00:52:04,589
이제 내부를 계산해 보겠습니다.
 

2024
00:52:04,589 --> 00:52:04,599

 

2025
00:52:04,599 --> 00:52:08,950

왼쪽으로 기울어지려면 이 부분의 높이는 k가 되어야 하므로 이것은 k+1이고

2026
00:52:08,950 --> 00:52:08,960
왼쪽으로 기울어지려면 이 부분의 높이는 k가 되어야 하므로 이것은 k+1이고
 

2027
00:52:08,960 --> 00:52:12,230
왼쪽으로 기울어지려면 이 부분의 높이는 k가 되어야 하므로 이것은 k+1이고
이것은 k+2입니다. 하지만 문제는

2028
00:52:12,230 --> 00:52:12,240
이것은 k+2입니다. 하지만 문제는
 

2029
00:52:12,240 --> 00:52:13,910
이것은 k+2입니다. 하지만 문제는
이것이 이것보다 2만큼 높다는 것입니다.

2030
00:52:13,910 --> 00:52:13,920
이것이 이것보다 2만큼 높다는 것입니다.
 

2031
00:52:13,920 --> 00:52:17,150
이것이 이것보다 2만큼 높다는 것입니다.
Z의 높이가 a의 높이보다 2만큼 높습니다.

2032
00:52:17,150 --> 00:52:17,160
Z의 높이가 a의 높이보다 2만큼 높습니다.
 

2033
00:52:17,160 --> 00:52:18,950
Z의 높이가 a의 높이보다 2만큼 높습니다.
이 경우 회전을 하면

2034
00:52:18,950 --> 00:52:18,960
이 경우 회전을 하면
 

2035
00:52:18,960 --> 00:52:21,670
이 경우 회전을 하면
상황이 더 악화됩니다. 사실,

2036
00:52:21,670 --> 00:52:21,680
상황이 더 악화됩니다. 사실,
 

2037
00:52:21,680 --> 00:52:23,789
상황이 더 악화됩니다. 사실,
제가 말씀드리는 올바른 방법은

2038
00:52:23,789 --> 00:52:23,799
제가 말씀드리는 올바른 방법은
 

2039
00:52:23,799 --> 00:52:25,510
제가 말씀드리는 올바른 방법은

2040
00:52:25,510 --> 00:52:25,520

 

2041
00:52:25,520 --> 00:52:40,950

이것 하나만 암기하는 것입니다.

2042
00:52:40,950 --> 00:52:40,960

 

2043
00:52:40,960 --> 00:52:43,870

결과를 그림으로 보여드리겠습니다.

2044
00:52:43,870 --> 00:52:45,309
결과를 그림으로 보여드리겠습니다.
 

2045
00:52:45,309 --> 00:52:45,319

 

2046
00:52:45,319 --> 00:52:48,549

트리를 이렇게 다시 그리는 것으로 생각해도 되지만,

2047
00:52:48,549 --> 00:52:48,559
트리를 이렇게 다시 그리는 것으로 생각해도 되지만,
 

2048
00:52:48,559 --> 00:52:50,150
트리를 이렇게 다시 그리는 것으로 생각해도 되지만,
분석적인 관점에서 보면

2049
00:52:50,150 --> 00:52:50,160
분석적인 관점에서 보면
 

2050
00:52:50,160 --> 00:52:52,109
분석적인 관점에서 보면
두 번의 회전으로 생각하는 것이 더 쉽습니다.

2051
00:52:52,109 --> 00:52:52,119
두 번의 회전으로 생각하는 것이 더 쉽습니다.
 

2052
00:52:52,119 --> 00:52:53,950
두 번의 회전으로 생각하는 것이 더 쉽습니다.
회전이 제대로 작동하는지 알고 있다면,

2053
00:52:53,950 --> 00:52:53,960
회전이 제대로 작동하는지 알고 있다면,
 

2054
00:52:53,960 --> 00:52:56,510
회전이 제대로 작동하는지 알고 있다면,
이 방법이 제대로 작동한다는 것을 알 수 있습니다.

2055
00:52:56,510 --> 00:52:56,520
이 방법이 제대로 작동한다는 것을 알 수 있습니다.
 

2056
00:52:56,520 --> 00:52:58,510
이 방법이 제대로 작동한다는 것을 알 수 있습니다.
즉, 순회

2057
00:52:58,510 --> 00:52:58,520
즉, 순회
 

2058
00:52:58,520 --> 00:53:00,150
즉, 순회
순서를 유지하고 모든

2059
00:53:00,150 --> 00:53:00,160
순서를 유지하고 모든
 

2060
00:53:00,160 --> 00:53:02,630
순서를 유지하고 모든
확장을 유지할 수 있다는 뜻입니다. 이제

2061
00:53:02,630 --> 00:53:02,640
확장을 유지할 수 있다는 뜻입니다. 이제
 

2062
00:53:02,640 --> 00:53:04,710
확장을 유지할 수 있다는 뜻입니다. 이제
이 높이 레이블을 복사하면 K-

2063
00:53:04,710 --> 00:53:04,720
이 높이 레이블을 복사하면 K-
 

2064
00:53:04,720 --> 00:53:06,670
이 높이 레이블을 복사하면 K-
1이 되고, 이 두 노드에는 K-

2065
00:53:06,670 --> 00:53:06,680
1이 되고, 이 두 노드에는 K-
 

2066
00:53:06,680 --> 00:53:09,870
1이 되고, 이 두 노드에는 K-
1 또는 K-2가 됩니다. 가장 큰 노드는 K1이고, 이것은 K-1입니다.

2067
00:53:09,870 --> 00:53:09,880
1 또는 K-2가 됩니다. 가장 큰 노드는 K1이고, 이것은 K-1입니다.
 

2068
00:53:09,880 --> 00:53:13,670
1 또는 K-2가 됩니다. 가장 큰 노드는 K1이고, 이것은 K-1입니다.
따라서 이것은 K가 되고, 이것은 K가 되고, 이것은

2069
00:53:13,670 --> 00:53:13,680
따라서 이것은 K가 되고, 이것은 K가 되고, 이것은
 

2070
00:53:13,680 --> 00:53:18,069
따라서 이것은 K가 되고, 이것은 K가 되고, 이것은
K

2071
00:53:18,069 --> 00:53:18,079
K
 

2072
00:53:18,079 --> 00:53:20,990
K
+1이 됩니다. 보시다시피, 이 노드 하나에 대해

2073
00:53:20,990 --> 00:53:21,000
+1이 됩니다. 보시다시피, 이 노드 하나에 대해
 

2074
00:53:21,000 --> 00:53:24,470
+1이 됩니다. 보시다시피, 이 노드 하나에 대해
세 가지 경우 모두 높이 균형이 잘 잡힌 트리가 만들어졌습니다. 이

2075
00:53:24,470 --> 00:53:24,480
세 가지 경우 모두 높이 균형이 잘 잡힌 트리가 만들어졌습니다. 이
 

2076
00:53:24,480 --> 00:53:26,750
세 가지 경우 모두 높이 균형이 잘 잡힌 트리가 만들어졌습니다. 이
노드는 이전에는 가장 낮은

2077
00:53:26,750 --> 00:53:26,760
노드는 이전에는 가장 낮은
 

2078
00:53:26,760 --> 00:53:29,150
노드는 이전에는 가장 낮은
노드였는데, 이 노드를 업데이트하면 높이가 K+

2079
00:53:29,150 --> 00:53:31,789
노드였는데, 이 노드를 업데이트하면 높이가 K+
 

2080
00:53:31,789 --> 00:53:31,799

 

2081
00:53:31,799 --> 00:53:35,710

1이 됩니다. 예를 들어 루트 노드의 높이가 이전에는 K+2였지만 지금은 K+1이 되거나,

2082
00:53:35,710 --> 00:53:37,549
1이 됩니다. 예를 들어 루트 노드의 높이가 이전에는 K+2였지만 지금은 K+1이 되거나,
 

2083
00:53:37,549 --> 00:53:37,559

 

2084
00:53:37,559 --> 00:53:40,349

이 경우처럼 그대로 유지될 수도 있습니다. 이제

2085
00:53:40,349 --> 00:53:40,359
이 경우처럼 그대로 유지될 수도 있습니다. 이제
 

2086
00:53:40,359 --> 00:53:41,910
이 경우처럼 그대로 유지될 수도 있습니다. 이제
부모 노드를 확인해야 합니다. 부모 노드가

2087
00:53:41,910 --> 00:53:41,920
부모 노드를 확인해야 합니다. 부모 노드가
 

2088
00:53:41,920 --> 00:53:44,230
부모 노드를 확인해야 합니다. 부모 노드가
균형이 맞지 않는 경우,

2089
00:53:44,230 --> 00:53:44,240
균형이 맞지 않는 경우,
 

2090
00:53:44,240 --> 00:53:46,069
균형이 맞지 않는 경우,
노드를 따라 계속 올라가면서 모든

2091
00:53:46,069 --> 00:53:46,079
노드를 따라 계속 올라가면서 모든
 

2092
00:53:46,079 --> 00:53:48,150
노드를 따라 계속 올라가면서 모든
확장 작업을 유지하고, 필요에 따라

2093
00:53:48,150 --> 00:53:48,160
확장 작업을 유지하고, 필요에 따라
 

2094
00:53:48,160 --> 00:53:49,990
확장 작업을 유지하고, 필요에 따라
높이와 서브트리 크기

2095
00:53:49,990 --> 00:53:50,000
높이와 서브트리 크기
 

2096
00:53:50,000 --> 00:53:52,309
높이와 서브트리 크기
또는 기타 확장 작업을 추적합니다. 이렇게

2097
00:53:52,309 --> 00:53:52,319
또는 기타 확장 작업을 추적합니다. 이렇게
 

2098
00:53:52,319 --> 00:53:54,630
또는 기타 확장 작업을 추적합니다. 이렇게
H차 연산을 수행하면

2099
00:53:54,630 --> 00:53:54,640
H차 연산을 수행하면
 

2100
00:53:54,640 --> 00:53:56,069
H차 연산을 수행하면
높이 균형 속성이 복원되므로, 전체 연산 시간(

2101
00:53:56,069 --> 00:53:56,079
높이 균형 속성이 복원되므로, 전체 연산 시간(
 

2102
00:53:56,079 --> 00:53:58,470
높이 균형 속성이 복원되므로, 전체 연산 시간(
H)은

2103
00:53:58,470 --> 00:53:58,480
H)은
 

2104
00:53:58,480 --> 00:54:00,349
H)은
log n차가 되고, 결과적으로 모든 연산의 시간 복잡도는

2105
00:54:00,349 --> 00:54:00,359
log n차가 되고, 결과적으로 모든 연산의 시간 복잡도는
 

2106
00:54:00,359 --> 00:54:04,680
log n차가 되고, 결과적으로 모든 연산의 시간 복잡도는
마법처럼 log n차가 됩니다.

