1
00:00:12,320 --> 00:00:14,549

all right welcome back to double06 data

2
00:00:14,549 --> 00:00:14,559
all right welcome back to double06 data
 

3
00:00:14,559 --> 00:00:15,829
all right welcome back to double06 data
structures

4
00:00:15,829 --> 00:00:15,839
structures
 

5
00:00:15,839 --> 00:00:18,870
structures
today we're going to cover a different

6
00:00:18,870 --> 00:00:18,880
today we're going to cover a different
 

7
00:00:18,880 --> 00:00:19,510
today we're going to cover a different
kind of

8
00:00:19,510 --> 00:00:19,520
kind of
 

9
00:00:19,520 --> 00:00:21,990
kind of
tree-like data structure called the heap

10
00:00:21,990 --> 00:00:22,000
tree-like data structure called the heap
 

11
00:00:22,000 --> 00:00:24,150
tree-like data structure called the heap
binary heap it's going to let us solve

12
00:00:24,150 --> 00:00:24,160
binary heap it's going to let us solve
 

13
00:00:24,160 --> 00:00:26,870
binary heap it's going to let us solve
sorting problem in a new way let me

14
00:00:26,870 --> 00:00:26,880
sorting problem in a new way let me
 

15
00:00:26,880 --> 00:00:27,269
sorting problem in a new way let me
first

16
00:00:27,269 --> 00:00:27,279
first
 

17
00:00:27,279 --> 00:00:30,470
first
remind you of a portion

18
00:00:30,470 --> 00:00:30,480
remind you of a portion
 

19
00:00:30,480 --> 00:00:31,589
remind you of a portion
the problem we're going to be solving

20
00:00:31,589 --> 00:00:31,599
the problem we're going to be solving
 

21
00:00:31,599 --> 00:00:33,510
the problem we're going to be solving
today is called priority queue

22
00:00:33,510 --> 00:00:33,520
today is called priority queue
 

23
00:00:33,520 --> 00:00:35,350
today is called priority queue
this is the interface we'll see several

24
00:00:35,350 --> 00:00:35,360
this is the interface we'll see several
 

25
00:00:35,360 --> 00:00:36,870
this is the interface we'll see several
data structures but one main data

26
00:00:36,870 --> 00:00:36,880
data structures but one main data
 

27
00:00:36,880 --> 00:00:39,910
data structures but one main data
structure for today

28
00:00:39,910 --> 00:00:39,920

 

29
00:00:39,920 --> 00:00:43,270

and this is a subset of

30
00:00:43,270 --> 00:00:43,280
and this is a subset of
 

31
00:00:43,280 --> 00:00:47,110
and this is a subset of
the set interface

32
00:00:47,110 --> 00:00:47,120

 

33
00:00:47,120 --> 00:00:48,630

and subsets are interesting because

34
00:00:48,630 --> 00:00:48,640
and subsets are interesting because
 

35
00:00:48,640 --> 00:00:50,470
and subsets are interesting because
potentially we can solve them better

36
00:00:50,470 --> 00:00:50,480
potentially we can solve them better
 

37
00:00:50,480 --> 00:00:53,750
potentially we can solve them better
faster simpler something

38
00:00:53,750 --> 00:00:53,760
faster simpler something
 

39
00:00:53,760 --> 00:00:56,950
faster simpler something
and so you'll recognize

40
00:00:56,950 --> 00:00:56,960
and so you'll recognize
 

41
00:00:56,960 --> 00:00:58,229
and so you'll recognize
you should recognize all of these

42
00:00:58,229 --> 00:00:58,239
you should recognize all of these
 

43
00:00:58,239 --> 00:01:00,069
you should recognize all of these
operations except we don't we didn't

44
00:01:00,069 --> 00:01:00,079
operations except we don't we didn't
 

45
00:01:00,079 --> 00:01:01,189
operations except we don't we didn't
normally highlight

46
00:01:01,189 --> 00:01:01,199
normally highlight
 

47
00:01:01,199 --> 00:01:03,189
normally highlight
the max operation so here we're

48
00:01:03,189 --> 00:01:03,199
the max operation so here we're
 

49
00:01:03,199 --> 00:01:06,070
the max operation so here we're
interested in storing a bunch of items

50
00:01:06,070 --> 00:01:06,080
interested in storing a bunch of items
 

51
00:01:06,080 --> 00:01:08,870
interested in storing a bunch of items
they have keys which we think of as

52
00:01:08,870 --> 00:01:08,880
they have keys which we think of as
 

53
00:01:08,880 --> 00:01:09,990
they have keys which we think of as
priorities

54
00:01:09,990 --> 00:01:10,000
priorities
 

55
00:01:10,000 --> 00:01:12,230
priorities
and we want to be able to identify the

56
00:01:12,230 --> 00:01:12,240
and we want to be able to identify the
 

57
00:01:12,240 --> 00:01:13,830
and we want to be able to identify the
maximum priority

58
00:01:13,830 --> 00:01:13,840
maximum priority
 

59
00:01:13,840 --> 00:01:17,270
maximum priority
item in our set and remove it

60
00:01:17,270 --> 00:01:17,280
item in our set and remove it
 

61
00:01:17,280 --> 00:01:18,789
item in our set and remove it
and so there's lots of motivations for

62
00:01:18,789 --> 00:01:18,799
and so there's lots of motivations for
 

63
00:01:18,799 --> 00:01:20,310
and so there's lots of motivations for
this maybe you have a router packets

64
00:01:20,310 --> 00:01:20,320
this maybe you have a router packets
 

65
00:01:20,320 --> 00:01:21,429
this maybe you have a router packets
going into the router they have

66
00:01:21,429 --> 00:01:21,439
going into the router they have
 

67
00:01:21,439 --> 00:01:22,789
going into the router they have
different priorities assigned to them

68
00:01:22,789 --> 00:01:22,799
different priorities assigned to them
 

69
00:01:22,799 --> 00:01:24,230
different priorities assigned to them
you want to route the highest priority

70
00:01:24,230 --> 00:01:24,240
you want to route the highest priority
 

71
00:01:24,240 --> 00:01:24,950
you want to route the highest priority
first

72
00:01:24,950 --> 00:01:24,960
first
 

73
00:01:24,960 --> 00:01:27,429
first
or you have processes on your computer

74
00:01:27,429 --> 00:01:27,439
or you have processes on your computer
 

75
00:01:27,439 --> 00:01:29,429
or you have processes on your computer
running trying to run on

76
00:01:29,429 --> 00:01:29,439
running trying to run on
 

77
00:01:29,439 --> 00:01:32,550
running trying to run on
your single threaded single core

78
00:01:32,550 --> 00:01:32,560
your single threaded single core
 

79
00:01:32,560 --> 00:01:33,749
your single threaded single core
and you've got to choose which one to

80
00:01:33,749 --> 00:01:33,759
and you've got to choose which one to
 

81
00:01:33,759 --> 00:01:35,830
and you've got to choose which one to
run next and you usually run higher

82
00:01:35,830 --> 00:01:35,840
run next and you usually run higher
 

83
00:01:35,840 --> 00:01:37,749
run next and you usually run higher
priority processes first

84
00:01:37,749 --> 00:01:37,759
priority processes first
 

85
00:01:37,759 --> 00:01:41,670
priority processes first
or you're trying to simulate uh a system

86
00:01:41,670 --> 00:01:41,680
or you're trying to simulate uh a system
 

87
00:01:41,680 --> 00:01:43,429
or you're trying to simulate uh a system
where events happen at different times

88
00:01:43,429 --> 00:01:43,439
where events happen at different times
 

89
00:01:43,439 --> 00:01:45,830
where events happen at different times
and you want to process the next event

90
00:01:45,830 --> 00:01:45,840
and you want to process the next event
 

91
00:01:45,840 --> 00:01:47,429
and you want to process the next event
ordered by time all of these are

92
00:01:47,429 --> 00:01:47,439
ordered by time all of these are
 

93
00:01:47,439 --> 00:01:50,310
ordered by time all of these are
examples of the priority queue interface

94
00:01:50,310 --> 00:01:50,320
examples of the priority queue interface
 

95
00:01:50,320 --> 00:01:51,990
examples of the priority queue interface
we'll even see applications within this

96
00:01:51,990 --> 00:01:52,000
we'll even see applications within this
 

97
00:01:52,000 --> 00:01:53,910
we'll even see applications within this
class when we get to graph algorithms

98
00:01:53,910 --> 00:01:53,920
class when we get to graph algorithms
 

99
00:01:53,920 --> 00:01:55,670
class when we get to graph algorithms
but the general the main two things we

100
00:01:55,670 --> 00:01:55,680
but the general the main two things we
 

101
00:01:55,680 --> 00:01:57,190
but the general the main two things we
want to be able to support are inserting

102
00:01:57,190 --> 00:01:57,200
want to be able to support are inserting
 

103
00:01:57,200 --> 00:01:57,910
want to be able to support are inserting
an item which

104
00:01:57,910 --> 00:01:57,920
an item which
 

105
00:01:57,920 --> 00:02:00,310
an item which
includes a key and deleting the maximum

106
00:02:00,310 --> 00:02:00,320
includes a key and deleting the maximum
 

107
00:02:00,320 --> 00:02:02,310
includes a key and deleting the maximum
item and also returning it at the same

108
00:02:02,310 --> 00:02:02,320
item and also returning it at the same
 

109
00:02:02,320 --> 00:02:03,510
item and also returning it at the same
time

110
00:02:03,510 --> 00:02:03,520
time
 

111
00:02:03,520 --> 00:02:06,469
time
we'll also talk some about being able to

112
00:02:06,469 --> 00:02:06,479
we'll also talk some about being able to
 

113
00:02:06,479 --> 00:02:07,510
we'll also talk some about being able to
build the structure

114
00:02:07,510 --> 00:02:07,520
build the structure
 

115
00:02:07,520 --> 00:02:09,109
build the structure
faster than just inserting it but of

116
00:02:09,109 --> 00:02:09,119
faster than just inserting it but of
 

117
00:02:09,119 --> 00:02:11,110
faster than just inserting it but of
course we could implement build by

118
00:02:11,110 --> 00:02:11,120
course we could implement build by
 

119
00:02:11,120 --> 00:02:11,589
course we could implement build by
starting

120
00:02:11,589 --> 00:02:11,599
starting
 

121
00:02:11,599 --> 00:02:14,630
starting
empty and repeatedly inserting and

122
00:02:14,630 --> 00:02:14,640
empty and repeatedly inserting and
 

123
00:02:14,640 --> 00:02:17,030
empty and repeatedly inserting and
also the complexity of just finding the

124
00:02:17,030 --> 00:02:17,040
also the complexity of just finding the
 

125
00:02:17,040 --> 00:02:18,550
also the complexity of just finding the
max without deleting it

126
00:02:18,550 --> 00:02:18,560
max without deleting it
 

127
00:02:18,560 --> 00:02:20,309
max without deleting it
this you could simulate with these two

128
00:02:20,309 --> 00:02:20,319
this you could simulate with these two
 

129
00:02:20,319 --> 00:02:21,990
this you could simulate with these two
operations by deleting the max and then

130
00:02:21,990 --> 00:02:22,000
operations by deleting the max and then
 

131
00:02:22,000 --> 00:02:24,070
operations by deleting the max and then
re-inserting it

132
00:02:24,070 --> 00:02:24,080
re-inserting it
 

133
00:02:24,080 --> 00:02:27,910
re-inserting it
which works but often we can do faster

134
00:02:27,910 --> 00:02:27,920
which works but often we can do faster
 

135
00:02:27,920 --> 00:02:30,710
which works but often we can do faster
okay but the two key main operations are

136
00:02:30,710 --> 00:02:30,720
okay but the two key main operations are
 

137
00:02:30,720 --> 00:02:31,509
okay but the two key main operations are
insert

138
00:02:31,509 --> 00:02:31,519
insert
 

139
00:02:31,519 --> 00:02:34,309
insert
and delete max and we're going to see a

140
00:02:34,309 --> 00:02:34,319
and delete max and we're going to see a
 

141
00:02:34,319 --> 00:02:37,110
and delete max and we're going to see a
few data structures to do this

142
00:02:37,110 --> 00:02:37,120
few data structures to do this
 

143
00:02:37,120 --> 00:02:39,270
few data structures to do this
any suggestions among the data

144
00:02:39,270 --> 00:02:39,280
any suggestions among the data
 

145
00:02:39,280 --> 00:02:40,790
any suggestions among the data
structures we've seen in this class what

146
00:02:40,790 --> 00:02:40,800
structures we've seen in this class what
 

147
00:02:40,800 --> 00:02:42,150
structures we've seen in this class what
should we

148
00:02:42,150 --> 00:02:42,160
should we
 

149
00:02:42,160 --> 00:02:53,750
should we
use to solve priority queue interface

150
00:02:53,750 --> 00:02:53,760

 

151
00:02:53,760 --> 00:02:58,790

any possible answers

152
00:02:58,790 --> 00:02:58,800

 

153
00:02:58,800 --> 00:03:01,430

sequence avl oh that's interesting uh

154
00:03:01,430 --> 00:03:01,440
sequence avl oh that's interesting uh
 

155
00:03:01,440 --> 00:03:03,110
sequence avl oh that's interesting uh
sequence fl is a good answer

156
00:03:03,110 --> 00:03:03,120
sequence fl is a good answer
 

157
00:03:03,120 --> 00:03:06,949
sequence fl is a good answer
but that's maybe the fancier version

158
00:03:06,949 --> 00:03:06,959
but that's maybe the fancier version
 

159
00:03:06,959 --> 00:03:10,790
but that's maybe the fancier version
yeah set avl sounds good

160
00:03:10,790 --> 00:03:10,800
yeah set avl sounds good
 

161
00:03:10,800 --> 00:03:13,030
yeah set avl sounds good
set avl supports these operations and

162
00:03:13,030 --> 00:03:13,040
set avl supports these operations and
 

163
00:03:13,040 --> 00:03:13,910
set avl supports these operations and
many more

164
00:03:13,910 --> 00:03:13,920
many more
 

165
00:03:13,920 --> 00:03:16,229
many more
all in log n time except for build which

166
00:03:16,229 --> 00:03:16,239
all in log n time except for build which
 

167
00:03:16,239 --> 00:03:17,190
all in log n time except for build which
takes

168
00:03:17,190 --> 00:03:17,200
takes
 

169
00:03:17,200 --> 00:03:18,869
takes
n log n time because you have to sort

170
00:03:18,869 --> 00:03:18,879
n log n time because you have to sort
 

171
00:03:18,879 --> 00:03:20,790
n log n time because you have to sort
first uh

172
00:03:20,790 --> 00:03:20,800
first uh
 

173
00:03:20,800 --> 00:03:22,949
first uh
so set avl is a good good way to do this

174
00:03:22,949 --> 00:03:22,959
so set avl is a good good way to do this
 

175
00:03:22,959 --> 00:03:24,229
so set avl is a good good way to do this
we'll talk we'll come back to your

176
00:03:24,229 --> 00:03:24,239
we'll talk we'll come back to your
 

177
00:03:24,239 --> 00:03:25,430
we'll talk we'll come back to your
sequence avl

178
00:03:25,430 --> 00:03:25,440
sequence avl
 

179
00:03:25,440 --> 00:03:29,910
sequence avl
idea later uh this gets login

180
00:03:29,910 --> 00:03:29,920
idea later uh this gets login
 

181
00:03:29,920 --> 00:03:33,190
idea later uh this gets login
for operation great i mean this is

182
00:03:33,190 --> 00:03:33,200
for operation great i mean this is
 

183
00:03:33,200 --> 00:03:34,789
for operation great i mean this is
set avl is our most powerful data

184
00:03:34,789 --> 00:03:34,799
set avl is our most powerful data
 

185
00:03:34,799 --> 00:03:36,229
set avl is our most powerful data
structure it does all the operations we

186
00:03:36,229 --> 00:03:36,239
structure it does all the operations we
 

187
00:03:36,239 --> 00:03:37,030
structure it does all the operations we
care about

188
00:03:37,030 --> 00:03:37,040
care about
 

189
00:03:37,040 --> 00:03:39,030
care about
uh on the set side and the sequence of

190
00:03:39,030 --> 00:03:39,040
uh on the set side and the sequence of
 

191
00:03:39,040 --> 00:03:40,229
uh on the set side and the sequence of
vl does all the operations on the

192
00:03:40,229 --> 00:03:40,239
vl does all the operations on the
 

193
00:03:40,239 --> 00:03:41,670
vl does all the operations on the
sequence side but note that this is a

194
00:03:41,670 --> 00:03:41,680
sequence side but note that this is a
 

195
00:03:41,680 --> 00:03:42,949
sequence side but note that this is a
set not a sequence

196
00:03:42,949 --> 00:03:42,959
set not a sequence
 

197
00:03:42,959 --> 00:03:44,949
set not a sequence
we care about keys there are hacks to

198
00:03:44,949 --> 00:03:44,959
we care about keys there are hacks to
 

199
00:03:44,959 --> 00:03:46,949
we care about keys there are hacks to
get around that with sequence avls but

200
00:03:46,949 --> 00:03:46,959
get around that with sequence avls but
 

201
00:03:46,959 --> 00:03:50,149
get around that with sequence avls but
let's do that later

202
00:03:50,149 --> 00:03:50,159

 

203
00:03:50,159 --> 00:03:52,630

so great if we wanted to for example

204
00:03:52,630 --> 00:03:52,640
so great if we wanted to for example
 

205
00:03:52,640 --> 00:03:54,149
so great if we wanted to for example
speed up find max

206
00:03:54,149 --> 00:03:54,159
speed up find max
 

207
00:03:54,159 --> 00:03:58,309
speed up find max
in a set avl we could add augmentation

208
00:03:58,309 --> 00:03:58,319
in a set avl we could add augmentation
 

209
00:03:58,319 --> 00:04:01,509
in a set avl we could add augmentation
we could

210
00:04:01,509 --> 00:04:01,519

 

211
00:04:01,519 --> 00:04:05,270

remember subtree property augmentations

212
00:04:05,270 --> 00:04:05,280
remember subtree property augmentations
 

213
00:04:05,280 --> 00:04:08,229
remember subtree property augmentations
we can use that to get constant time

214
00:04:08,229 --> 00:04:08,239
we can use that to get constant time
 

215
00:04:08,239 --> 00:04:10,470
we can use that to get constant time
find max

216
00:04:10,470 --> 00:04:10,480
find max
 

217
00:04:10,480 --> 00:04:13,509
find max
by storing in every node the maximum

218
00:04:13,509 --> 00:04:13,519
by storing in every node the maximum
 

219
00:04:13,519 --> 00:04:15,750
by storing in every node the maximum
key item within the subtree and that's a

220
00:04:15,750 --> 00:04:15,760
key item within the subtree and that's a
 

221
00:04:15,760 --> 00:04:17,270
key item within the subtree and that's a
subtree property it's one we mentioned

222
00:04:17,270 --> 00:04:17,280
subtree property it's one we mentioned
 

223
00:04:17,280 --> 00:04:18,150
subtree property it's one we mentioned
last

224
00:04:18,150 --> 00:04:18,160
last
 

225
00:04:18,160 --> 00:04:20,310
last
class so we could even improve that to

226
00:04:20,310 --> 00:04:20,320
class so we could even improve that to
 

227
00:04:20,320 --> 00:04:21,189
class so we could even improve that to
constant time

228
00:04:21,189 --> 00:04:21,199
constant time
 

229
00:04:21,199 --> 00:04:24,950
constant time
great um so we're done end of lecture

230
00:04:24,950 --> 00:04:24,960
great um so we're done end of lecture
 

231
00:04:24,960 --> 00:04:27,270
great um so we're done end of lecture
in some sense that's true but what we're

232
00:04:27,270 --> 00:04:27,280
in some sense that's true but what we're
 

233
00:04:27,280 --> 00:04:28,469
in some sense that's true but what we're
going to see today

234
00:04:28,469 --> 00:04:28,479
going to see today
 

235
00:04:28,479 --> 00:04:29,909
going to see today
is another data structure called the

236
00:04:29,909 --> 00:04:29,919
is another data structure called the
 

237
00:04:29,919 --> 00:04:31,749
is another data structure called the
binary heap which is in some sense a

238
00:04:31,749 --> 00:04:31,759
binary heap which is in some sense a
 

239
00:04:31,759 --> 00:04:33,590
binary heap which is in some sense a
simplification of

240
00:04:33,590 --> 00:04:33,600
simplification of
 

241
00:04:33,600 --> 00:04:36,629
simplification of
set avl it achieves basically the same

242
00:04:36,629 --> 00:04:36,639
set avl it achieves basically the same
 

243
00:04:36,639 --> 00:04:37,350
set avl it achieves basically the same
time bounds

244
00:04:37,350 --> 00:04:37,360
time bounds
 

245
00:04:37,360 --> 00:04:41,030
time bounds
build will be faster by a log factor

246
00:04:41,030 --> 00:04:41,040
build will be faster by a log factor
 

247
00:04:41,040 --> 00:04:43,670
build will be faster by a log factor
but that's not the main reason we care

248
00:04:43,670 --> 00:04:43,680
but that's not the main reason we care
 

249
00:04:43,680 --> 00:04:44,469
but that's not the main reason we care
about them

250
00:04:44,469 --> 00:04:44,479
about them
 

251
00:04:44,479 --> 00:04:45,830
about them
the main advantage is that they're

252
00:04:45,830 --> 00:04:45,840
the main advantage is that they're
 

253
00:04:45,840 --> 00:04:48,870
the main advantage is that they're
simpler and they give us

254
00:04:48,870 --> 00:04:48,880
simpler and they give us
 

255
00:04:48,880 --> 00:04:54,150
simpler and they give us
an in-place sorting algorithm

256
00:04:54,150 --> 00:04:54,160

 

257
00:04:54,160 --> 00:04:57,510

so i have up here the three of the

258
00:04:57,510 --> 00:04:57,520
so i have up here the three of the
 

259
00:04:57,520 --> 00:04:59,110
so i have up here the three of the
operations i've been talking about build

260
00:04:59,110 --> 00:04:59,120
operations i've been talking about build
 

261
00:04:59,120 --> 00:05:00,710
operations i've been talking about build
insert and delete max

262
00:05:00,710 --> 00:05:00,720
insert and delete max
 

263
00:05:00,720 --> 00:05:03,270
insert and delete max
uh so we have set avl trees there and

264
00:05:03,270 --> 00:05:03,280
uh so we have set avl trees there and
 

265
00:05:03,280 --> 00:05:04,230
uh so we have set avl trees there and
log n build

266
00:05:04,230 --> 00:05:04,240
log n build
 

267
00:05:04,240 --> 00:05:07,830
log n build
log n insert log n delete so along the

268
00:05:07,830 --> 00:05:07,840
log n insert log n delete so along the
 

269
00:05:07,840 --> 00:05:08,469
log n insert log n delete so along the
way to

270
00:05:08,469 --> 00:05:08,479
way to
 

271
00:05:08,479 --> 00:05:11,909
way to
our heap i want to mention two other

272
00:05:11,909 --> 00:05:11,919
our heap i want to mention two other
 

273
00:05:11,919 --> 00:05:15,350
our heap i want to mention two other
data structures one is

274
00:05:15,350 --> 00:05:15,360
data structures one is
 

275
00:05:15,360 --> 00:05:18,310
data structures one is
a dynamic but unsorted array and the

276
00:05:18,310 --> 00:05:18,320
a dynamic but unsorted array and the
 

277
00:05:18,320 --> 00:05:25,749
a dynamic but unsorted array and the
other is a dynamic sorted array

278
00:05:25,749 --> 00:05:25,759
other is a dynamic sorted array
 

279
00:05:25,759 --> 00:05:27,510
other is a dynamic sorted array
these are simpler data structures we've

280
00:05:27,510 --> 00:05:27,520
these are simpler data structures we've
 

281
00:05:27,520 --> 00:05:29,189
these are simpler data structures we've
talked about many times before

282
00:05:29,189 --> 00:05:29,199
talked about many times before
 

283
00:05:29,199 --> 00:05:31,430
talked about many times before
and they're useful kind of motivations

284
00:05:31,430 --> 00:05:31,440
and they're useful kind of motivations
 

285
00:05:31,440 --> 00:05:32,629
and they're useful kind of motivations
for getting started because

286
00:05:32,629 --> 00:05:32,639
for getting started because
 

287
00:05:32,639 --> 00:05:35,990
for getting started because
a heap is going to be built on top of

288
00:05:35,990 --> 00:05:36,000
a heap is going to be built on top of
 

289
00:05:36,000 --> 00:05:38,629
a heap is going to be built on top of
arrays instead of what's sort of a

290
00:05:38,629 --> 00:05:38,639
arrays instead of what's sort of a
 

291
00:05:38,639 --> 00:05:42,710
arrays instead of what's sort of a
fusion between arrays and trees

292
00:05:42,710 --> 00:05:42,720

 

293
00:05:42,720 --> 00:05:46,230

so um if i have an unsorted array

294
00:05:46,230 --> 00:05:46,240
so um if i have an unsorted array
 

295
00:05:46,240 --> 00:05:49,350
so um if i have an unsorted array
this is very easy to insert into right i

296
00:05:49,350 --> 00:05:49,360
this is very easy to insert into right i
 

297
00:05:49,360 --> 00:05:50,230
this is very easy to insert into right i
just

298
00:05:50,230 --> 00:05:50,240
just
 

299
00:05:50,240 --> 00:05:52,230
just
append to the end this is what we called

300
00:05:52,230 --> 00:05:52,240
append to the end this is what we called
 

301
00:05:52,240 --> 00:05:53,510
append to the end this is what we called
insert last

302
00:05:53,510 --> 00:05:53,520
insert last
 

303
00:05:53,520 --> 00:05:56,629
insert last
so insert is fast

304
00:05:56,629 --> 00:05:56,639
so insert is fast
 

305
00:05:56,639 --> 00:05:59,110
so insert is fast
constant amortized we might have to

306
00:05:59,110 --> 00:05:59,120
constant amortized we might have to
 

307
00:05:59,120 --> 00:06:00,469
constant amortized we might have to
resize the array but

308
00:06:00,469 --> 00:06:00,479
resize the array but
 

309
00:06:00,479 --> 00:06:02,870
resize the array but
so that's the amortized part but delete

310
00:06:02,870 --> 00:06:02,880
so that's the amortized part but delete
 

311
00:06:02,880 --> 00:06:04,870
so that's the amortized part but delete
max is slow in unsorted array i don't

312
00:06:04,870 --> 00:06:04,880
max is slow in unsorted array i don't
 

313
00:06:04,880 --> 00:06:06,230
max is slow in unsorted array i don't
know where the maximum is so i have to

314
00:06:06,230 --> 00:06:06,240
know where the maximum is so i have to
 

315
00:06:06,240 --> 00:06:11,029
know where the maximum is so i have to
scan through the whole array

316
00:06:11,029 --> 00:06:11,039

 

317
00:06:11,039 --> 00:06:13,189

so i scan through the array identify the

318
00:06:13,189 --> 00:06:13,199
so i scan through the array identify the
 

319
00:06:13,199 --> 00:06:15,189
so i scan through the array identify the
max is somewhere in the middle

320
00:06:15,189 --> 00:06:15,199
max is somewhere in the middle
 

321
00:06:15,199 --> 00:06:22,710
max is somewhere in the middle
and then if i want to delete it

322
00:06:22,710 --> 00:06:22,720

 

323
00:06:22,720 --> 00:06:24,309

i want to delete that maximum element

324
00:06:24,309 --> 00:06:24,319
i want to delete that maximum element
 

325
00:06:24,319 --> 00:06:26,070
i want to delete that maximum element
well in a dynamic array all i can really

326
00:06:26,070 --> 00:06:26,080
well in a dynamic array all i can really
 

327
00:06:26,080 --> 00:06:27,830
well in a dynamic array all i can really
do is delete the last element

328
00:06:27,830 --> 00:06:27,840
do is delete the last element
 

329
00:06:27,840 --> 00:06:30,469
do is delete the last element
efficiently so i could for example swap

330
00:06:30,469 --> 00:06:30,479
efficiently so i could for example swap
 

331
00:06:30,479 --> 00:06:31,749
efficiently so i could for example swap
it with the

332
00:06:31,749 --> 00:06:31,759
it with the
 

333
00:06:31,759 --> 00:06:34,710
it with the
last element so i take this element and

334
00:06:34,710 --> 00:06:34,720
last element so i take this element and
 

335
00:06:34,720 --> 00:06:35,590
last element so i take this element and
put it here

336
00:06:35,590 --> 00:06:35,600
put it here
 

337
00:06:35,600 --> 00:06:38,230
put it here
and then delete the last element in that

338
00:06:38,230 --> 00:06:38,240
and then delete the last element in that
 

339
00:06:38,240 --> 00:06:39,110
and then delete the last element in that
array

340
00:06:39,110 --> 00:06:39,120
array
 

341
00:06:39,120 --> 00:06:41,830
array
which is pop in python or delete last in

342
00:06:41,830 --> 00:06:41,840
which is pop in python or delete last in
 

343
00:06:41,840 --> 00:06:42,390
which is pop in python or delete last in
our

344
00:06:42,390 --> 00:06:42,400
our
 

345
00:06:42,400 --> 00:06:45,510
our
world so overall this is

346
00:06:45,510 --> 00:06:45,520
world so overall this is
 

347
00:06:45,520 --> 00:06:50,150
world so overall this is
linear time which is bad

348
00:06:50,150 --> 00:06:50,160
linear time which is bad
 

349
00:06:50,160 --> 00:06:51,589
linear time which is bad
but i wanted to highlight exactly how

350
00:06:51,589 --> 00:06:51,599
but i wanted to highlight exactly how
 

351
00:06:51,599 --> 00:06:53,430
but i wanted to highlight exactly how
it's done for a reason we'll get to in a

352
00:06:53,430 --> 00:06:53,440
it's done for a reason we'll get to in a
 

353
00:06:53,440 --> 00:06:54,390
it's done for a reason we'll get to in a
moment

354
00:06:54,390 --> 00:06:54,400
moment
 

355
00:06:54,400 --> 00:06:56,309
moment
sorted array is sort of the reverse it's

356
00:06:56,309 --> 00:06:56,319
sorted array is sort of the reverse it's
 

357
00:06:56,319 --> 00:06:58,070
sorted array is sort of the reverse it's
very easy to find the max

358
00:06:58,070 --> 00:06:58,080
very easy to find the max
 

359
00:06:58,080 --> 00:07:02,390
very easy to find the max
where is it at the end

360
00:07:02,390 --> 00:07:02,400
where is it at the end
 

361
00:07:02,400 --> 00:07:04,629
where is it at the end
delete max uh the maximum element is

362
00:07:04,629 --> 00:07:04,639
delete max uh the maximum element is
 

363
00:07:04,639 --> 00:07:05,589
delete max uh the maximum element is
always the last

364
00:07:05,589 --> 00:07:05,599
always the last
 

365
00:07:05,599 --> 00:07:11,029
always the last
element in a increasing sorted array

366
00:07:11,029 --> 00:07:11,039

 

367
00:07:11,039 --> 00:07:13,110

i guess that's constant amortized

368
00:07:13,110 --> 00:07:13,120
i guess that's constant amortized
 

369
00:07:13,120 --> 00:07:14,710
i guess that's constant amortized
because then i have to delete it which

370
00:07:14,710 --> 00:07:14,720
because then i have to delete it which
 

371
00:07:14,720 --> 00:07:15,430
because then i have to delete it which
may incur

372
00:07:15,430 --> 00:07:15,440
may incur
 

373
00:07:15,440 --> 00:07:19,110
may incur
resizing insert

374
00:07:19,110 --> 00:07:19,120
resizing insert
 

375
00:07:19,120 --> 00:07:23,110
resizing insert
though is going to be linear because

376
00:07:23,110 --> 00:07:23,120
though is going to be linear because
 

377
00:07:23,120 --> 00:07:24,790
though is going to be linear because
maybe i can binary search to find where

378
00:07:24,790 --> 00:07:24,800
maybe i can binary search to find where
 

379
00:07:24,800 --> 00:07:28,070
maybe i can binary search to find where
that item where the added item belongs

380
00:07:28,070 --> 00:07:28,080
that item where the added item belongs
 

381
00:07:28,080 --> 00:07:32,390
that item where the added item belongs
let's say i just added

382
00:07:32,390 --> 00:07:32,400

 

383
00:07:32,400 --> 00:07:35,909

this item here um i could bind our

384
00:07:35,909 --> 00:07:35,919
this item here um i could bind our
 

385
00:07:35,919 --> 00:07:37,189
this item here um i could bind our
search to find it but then i'm going to

386
00:07:37,189 --> 00:07:37,199
search to find it but then i'm going to
 

387
00:07:37,199 --> 00:07:39,029
search to find it but then i'm going to
have to do a big shift so i might as

388
00:07:39,029 --> 00:07:39,039
have to do a big shift so i might as
 

389
00:07:39,039 --> 00:07:39,749
have to do a big shift so i might as
well just

390
00:07:39,749 --> 00:07:39,759
well just
 

391
00:07:39,759 --> 00:07:42,710
well just
swap repeatedly until i find the

392
00:07:42,710 --> 00:07:42,720
swap repeatedly until i find the
 

393
00:07:42,720 --> 00:07:43,990
swap repeatedly until i find the
position where

394
00:07:43,990 --> 00:07:44,000
position where
 

395
00:07:44,000 --> 00:07:47,430
position where
the added item x belongs

396
00:07:47,430 --> 00:07:47,440
the added item x belongs
 

397
00:07:47,440 --> 00:07:49,430
the added item x belongs
and now i've restored sorted order that

398
00:07:49,430 --> 00:07:49,440
and now i've restored sorted order that
 

399
00:07:49,440 --> 00:07:51,029
and now i've restored sorted order that
takes linear time

400
00:07:51,029 --> 00:07:51,039
takes linear time
 

401
00:07:51,039 --> 00:07:53,430
takes linear time
which is bad and what we want is somehow

402
00:07:53,430 --> 00:07:53,440
which is bad and what we want is somehow
 

403
00:07:53,440 --> 00:07:56,070
which is bad and what we want is somehow
the best of these two worlds

404
00:07:56,070 --> 00:07:56,080
the best of these two worlds
 

405
00:07:56,080 --> 00:07:59,350
the best of these two worlds
insert is fast for array uh

406
00:07:59,350 --> 00:07:59,360
insert is fast for array uh
 

407
00:07:59,360 --> 00:08:01,830
insert is fast for array uh
delete is fast for a sorted array we

408
00:08:01,830 --> 00:08:01,840
delete is fast for a sorted array we
 

409
00:08:01,840 --> 00:08:03,510
delete is fast for a sorted array we
can't get constant time for both but we

410
00:08:03,510 --> 00:08:03,520
can't get constant time for both but we
 

411
00:08:03,520 --> 00:08:05,350
can't get constant time for both but we
can get login time for both we already

412
00:08:05,350 --> 00:08:05,360
can get login time for both we already
 

413
00:08:05,360 --> 00:08:06,230
can get login time for both we already
know how

414
00:08:06,230 --> 00:08:06,240
know how
 

415
00:08:06,240 --> 00:08:08,150
know how
with set avl trees but we're going to

416
00:08:08,150 --> 00:08:08,160
with set avl trees but we're going to
 

417
00:08:08,160 --> 00:08:10,869
with set avl trees but we're going to
see a different way to do it today

418
00:08:10,869 --> 00:08:10,879
see a different way to do it today
 

419
00:08:10,879 --> 00:08:14,150
see a different way to do it today
and the main motivation for a different

420
00:08:14,150 --> 00:08:14,160
and the main motivation for a different
 

421
00:08:14,160 --> 00:08:16,710
and the main motivation for a different
way to do this

422
00:08:16,710 --> 00:08:16,720
way to do this
 

423
00:08:16,720 --> 00:08:19,830
way to do this
is sorting so i want to define

424
00:08:19,830 --> 00:08:19,840
is sorting so i want to define
 

425
00:08:19,840 --> 00:08:29,189
is sorting so i want to define
a priority queue sort

426
00:08:29,189 --> 00:08:29,199

 

427
00:08:29,199 --> 00:08:31,909

so given any data structure that

428
00:08:31,909 --> 00:08:31,919
so given any data structure that
 

429
00:08:31,919 --> 00:08:33,589
so given any data structure that
implements a priority queue interface in

430
00:08:33,589 --> 00:08:33,599
implements a priority queue interface in
 

431
00:08:33,599 --> 00:08:34,790
implements a priority queue interface in
particular insert

432
00:08:34,790 --> 00:08:34,800
particular insert
 

433
00:08:34,800 --> 00:08:37,350
particular insert
and delete max i can make a sorting

434
00:08:37,350 --> 00:08:37,360
and delete max i can make a sorting
 

435
00:08:37,360 --> 00:08:38,070
and delete max i can make a sorting
algorithm

436
00:08:38,070 --> 00:08:38,080
algorithm
 

437
00:08:38,080 --> 00:08:41,110
algorithm
what do i do insert all the items delete

438
00:08:41,110 --> 00:08:41,120
what do i do insert all the items delete
 

439
00:08:41,120 --> 00:08:42,149
what do i do insert all the items delete
all the items

440
00:08:42,149 --> 00:08:42,159
all the items
 

441
00:08:42,159 --> 00:08:44,230
all the items
but because when i delete them they come

442
00:08:44,230 --> 00:08:44,240
but because when i delete them they come
 

443
00:08:44,240 --> 00:08:45,829
but because when i delete them they come
out largest first

444
00:08:45,829 --> 00:08:45,839
out largest first
 

445
00:08:45,839 --> 00:08:47,670
out largest first
i get them in reverse sorted order then

446
00:08:47,670 --> 00:08:47,680
i get them in reverse sorted order then
 

447
00:08:47,680 --> 00:08:49,350
i get them in reverse sorted order then
i could reverse in linear time

448
00:08:49,350 --> 00:08:49,360
i could reverse in linear time
 

449
00:08:49,360 --> 00:08:53,910
i could reverse in linear time
and i've sorted my items so we can

450
00:08:53,910 --> 00:08:53,920
and i've sorted my items so we can
 

451
00:08:53,920 --> 00:08:56,070
and i've sorted my items so we can
insert

452
00:08:56,070 --> 00:08:56,080
insert
 

453
00:08:56,080 --> 00:08:59,509
insert
x for x and a

454
00:08:59,509 --> 00:08:59,519
x for x and a
 

455
00:08:59,519 --> 00:09:04,710
x for x and a
or build a

456
00:09:04,710 --> 00:09:04,720

 

457
00:09:04,720 --> 00:09:08,790

and then repeatedly

458
00:09:08,790 --> 00:09:08,800
and then repeatedly
 

459
00:09:08,800 --> 00:09:16,710
and then repeatedly
delete max

460
00:09:16,710 --> 00:09:16,720

 

461
00:09:16,720 --> 00:09:18,389

okay how much time does this algorithm

462
00:09:18,389 --> 00:09:18,399
okay how much time does this algorithm
 

463
00:09:18,399 --> 00:09:19,910
okay how much time does this algorithm
take i'm going to

464
00:09:19,910 --> 00:09:19,920
take i'm going to
 

465
00:09:19,920 --> 00:09:21,910
take i'm going to
introduce some notation here it takes

466
00:09:21,910 --> 00:09:21,920
introduce some notation here it takes
 

467
00:09:21,920 --> 00:09:24,949
introduce some notation here it takes
however long it takes to build and items

468
00:09:24,949 --> 00:09:24,959
however long it takes to build and items
 

469
00:09:24,959 --> 00:09:28,150
however long it takes to build and items
call that t sub build uh

470
00:09:28,150 --> 00:09:28,160
call that t sub build uh
 

471
00:09:28,160 --> 00:09:33,710
call that t sub build uh
n plus uh

472
00:09:33,710 --> 00:09:33,720

 

473
00:09:33,720 --> 00:09:35,750

sorry

474
00:09:35,750 --> 00:09:35,760
sorry
 

475
00:09:35,760 --> 00:09:40,150
sorry
plus n

476
00:09:40,150 --> 00:09:40,160

 

477
00:09:40,160 --> 00:09:44,870

times the time to do a delete max

478
00:09:44,870 --> 00:09:44,880

 

479
00:09:44,880 --> 00:09:47,910

okay or uh we can write this as

480
00:09:47,910 --> 00:09:47,920
okay or uh we can write this as
 

481
00:09:47,920 --> 00:09:51,829
okay or uh we can write this as
n times time to do an insert

482
00:09:51,829 --> 00:09:51,839
n times time to do an insert
 

483
00:09:51,839 --> 00:09:57,910
n times time to do an insert
plus time to do a delete max

484
00:09:57,910 --> 00:09:57,920

 

485
00:09:57,920 --> 00:09:59,750

okay so i'm using these t functions to

486
00:09:59,750 --> 00:09:59,760
okay so i'm using these t functions to
 

487
00:09:59,760 --> 00:10:01,190
okay so i'm using these t functions to
just abstract

488
00:10:01,190 --> 00:10:01,200
just abstract
 

489
00:10:01,200 --> 00:10:03,509
just abstract
what are the running times provided by

490
00:10:03,509 --> 00:10:03,519
what are the running times provided by
 

491
00:10:03,519 --> 00:10:05,269
what are the running times provided by
my data structure that implements this

492
00:10:05,269 --> 00:10:05,279
my data structure that implements this
 

493
00:10:05,279 --> 00:10:06,069
my data structure that implements this
interface

494
00:10:06,069 --> 00:10:06,079
interface
 

495
00:10:06,079 --> 00:10:07,750
interface
the interface says what's correct is and

496
00:10:07,750 --> 00:10:07,760
the interface says what's correct is and
 

497
00:10:07,760 --> 00:10:09,350
the interface says what's correct is and
these t functions to give me my

498
00:10:09,350 --> 00:10:09,360
these t functions to give me my
 

499
00:10:09,360 --> 00:10:10,710
these t functions to give me my
performance bounce

500
00:10:10,710 --> 00:10:10,720
performance bounce
 

501
00:10:10,720 --> 00:10:12,710
performance bounce
so if i plug in each of these data

502
00:10:12,710 --> 00:10:12,720
so if i plug in each of these data
 

503
00:10:12,720 --> 00:10:13,750
so if i plug in each of these data
structures

504
00:10:13,750 --> 00:10:13,760
structures
 

505
00:10:13,760 --> 00:10:17,590
structures
i get a sorting algorithm i get avl sort

506
00:10:17,590 --> 00:10:17,600
i get a sorting algorithm i get avl sort
 

507
00:10:17,600 --> 00:10:17,990
i get a sorting algorithm i get avl sort
i get

508
00:10:17,990 --> 00:10:18,000
i get
 

509
00:10:18,000 --> 00:10:20,150
i get
array sort i get a sorted array sort

510
00:10:20,150 --> 00:10:20,160
array sort i get a sorted array sort
 

511
00:10:20,160 --> 00:10:21,030
array sort i get a sorted array sort
what do those

512
00:10:21,030 --> 00:10:21,040
what do those
 

513
00:10:21,040 --> 00:10:22,710
what do those
look like it turns out many of these are

514
00:10:22,710 --> 00:10:22,720
look like it turns out many of these are
 

515
00:10:22,720 --> 00:10:24,870
look like it turns out many of these are
familiar

516
00:10:24,870 --> 00:10:24,880
familiar
 

517
00:10:24,880 --> 00:10:27,990
familiar
uh so set avls take

518
00:10:27,990 --> 00:10:28,000
uh so set avls take
 

519
00:10:28,000 --> 00:10:31,269
uh so set avls take
login for operation so we get an n login

520
00:10:31,269 --> 00:10:31,279
login for operation so we get an n login
 

521
00:10:31,279 --> 00:10:34,069
login for operation so we get an n login
sorting algorithm out of them which is

522
00:10:34,069 --> 00:10:34,079
sorting algorithm out of them which is
 

523
00:10:34,079 --> 00:10:36,150
sorting algorithm out of them which is
insert all of the items into the abl

524
00:10:36,150 --> 00:10:36,160
insert all of the items into the abl
 

525
00:10:36,160 --> 00:10:37,990
insert all of the items into the abl
tree i don't want to use avl build

526
00:10:37,990 --> 00:10:38,000
tree i don't want to use avl build
 

527
00:10:38,000 --> 00:10:38,949
tree i don't want to use avl build
because that uses

528
00:10:38,949 --> 00:10:38,959
because that uses
 

529
00:10:38,959 --> 00:10:40,870
because that uses
sort i'm not allowed to sort in order to

530
00:10:40,870 --> 00:10:40,880
sort i'm not allowed to sort in order to
 

531
00:10:40,880 --> 00:10:41,990
sort i'm not allowed to sort in order to
implement sort

532
00:10:41,990 --> 00:10:42,000
implement sort
 

533
00:10:42,000 --> 00:10:43,670
implement sort
but we saw how to insert into an abl

534
00:10:43,670 --> 00:10:43,680
but we saw how to insert into an abl
 

535
00:10:43,680 --> 00:10:45,750
but we saw how to insert into an abl
tree and keep the thing balanced

536
00:10:45,750 --> 00:10:45,760
tree and keep the thing balanced
 

537
00:10:45,760 --> 00:10:48,710
tree and keep the thing balanced
so that takes log n each and then we can

538
00:10:48,710 --> 00:10:48,720
so that takes log n each and then we can
 

539
00:10:48,720 --> 00:10:50,710
so that takes log n each and then we can
find the max delete it rebalance

540
00:10:50,710 --> 00:10:50,720
find the max delete it rebalance
 

541
00:10:50,720 --> 00:10:52,630
find the max delete it rebalance
and so on total time will be n log n

542
00:10:52,630 --> 00:10:52,640
and so on total time will be n log n
 

543
00:10:52,640 --> 00:10:55,430
and so on total time will be n log n
this is an algorithm we call avl sort

544
00:10:55,430 --> 00:10:55,440
this is an algorithm we call avl sort
 

545
00:10:55,440 --> 00:10:57,430
this is an algorithm we call avl sort
it's a bit complicated because avl trees

546
00:10:57,430 --> 00:10:57,440
it's a bit complicated because avl trees
 

547
00:10:57,440 --> 00:10:58,550
it's a bit complicated because avl trees
are complicated

548
00:10:58,550 --> 00:10:58,560
are complicated
 

549
00:10:58,560 --> 00:11:01,670
are complicated
but it gives us optimal comparison bound

550
00:11:01,670 --> 00:11:01,680
but it gives us optimal comparison bound
 

551
00:11:01,680 --> 00:11:04,069
but it gives us optimal comparison bound
and login

552
00:11:04,069 --> 00:11:04,079
and login
 

553
00:11:04,079 --> 00:11:07,190
and login
now what about

554
00:11:07,190 --> 00:11:07,200
now what about
 

555
00:11:07,200 --> 00:11:10,230
now what about
array sort so suppose i use an

556
00:11:10,230 --> 00:11:10,240
array sort so suppose i use an
 

557
00:11:10,240 --> 00:11:13,430
array sort so suppose i use an
unsorted array i

558
00:11:13,430 --> 00:11:13,440
unsorted array i
 

559
00:11:13,440 --> 00:11:15,910
unsorted array i
insert the item so if i insert the items

560
00:11:15,910 --> 00:11:15,920
insert the item so if i insert the items
 

561
00:11:15,920 --> 00:11:17,269
insert the item so if i insert the items
so i'm doing all the insertions here

562
00:11:17,269 --> 00:11:17,279
so i'm doing all the insertions here
 

563
00:11:17,279 --> 00:11:18,710
so i'm doing all the insertions here
before all the deletions so what's going

564
00:11:18,710 --> 00:11:18,720
before all the deletions so what's going
 

565
00:11:18,720 --> 00:11:20,310
before all the deletions so what's going
to happen is i just insert the items in

566
00:11:20,310 --> 00:11:20,320
to happen is i just insert the items in
 

567
00:11:20,320 --> 00:11:21,910
to happen is i just insert the items in
the original array order in other words

568
00:11:21,910 --> 00:11:21,920
the original array order in other words
 

569
00:11:21,920 --> 00:11:23,670
the original array order in other words
i just take the array

570
00:11:23,670 --> 00:11:23,680
i just take the array
 

571
00:11:23,680 --> 00:11:26,790
i just take the array
and then what i do is repeatedly

572
00:11:26,790 --> 00:11:26,800
and then what i do is repeatedly
 

573
00:11:26,800 --> 00:11:30,389
and then what i do is repeatedly
extract the maximum item

574
00:11:30,389 --> 00:11:30,399

 

575
00:11:30,399 --> 00:11:33,430

by searching for it moving it to the end

576
00:11:33,430 --> 00:11:33,440
by searching for it moving it to the end
 

577
00:11:33,440 --> 00:11:34,470
by searching for it moving it to the end
of the array

578
00:11:34,470 --> 00:11:34,480
of the array
 

579
00:11:34,480 --> 00:11:36,230
of the array
and then repeating that process that's

580
00:11:36,230 --> 00:11:36,240
and then repeating that process that's
 

581
00:11:36,240 --> 00:11:38,389
and then repeating that process that's
unfamiliar

582
00:11:38,389 --> 00:11:38,399
unfamiliar
 

583
00:11:38,399 --> 00:11:41,509
unfamiliar
that's selection sort from lecture

584
00:11:41,509 --> 00:11:41,519
that's selection sort from lecture
 

585
00:11:41,519 --> 00:11:45,030
that's selection sort from lecture
three um so this

586
00:11:45,030 --> 00:11:45,040
three um so this
 

587
00:11:45,040 --> 00:11:53,110
three um so this
arrays give us selection sort

588
00:11:53,110 --> 00:11:53,120

 

589
00:11:53,120 --> 00:11:54,870

this is a new way to think about what we

590
00:11:54,870 --> 00:11:54,880
this is a new way to think about what we
 

591
00:11:54,880 --> 00:11:56,870
this is a new way to think about what we
were doing way back then

592
00:11:56,870 --> 00:11:56,880
were doing way back then
 

593
00:11:56,880 --> 00:12:00,230
were doing way back then
with a sorted array

594
00:12:00,230 --> 00:12:00,240

 

595
00:12:00,240 --> 00:12:02,230

what are we doing we insert all the

596
00:12:02,230 --> 00:12:02,240
what are we doing we insert all the
 

597
00:12:02,240 --> 00:12:03,750
what are we doing we insert all the
items that's actually where

598
00:12:03,750 --> 00:12:03,760
items that's actually where
 

599
00:12:03,760 --> 00:12:05,350
items that's actually where
all the work happens because we maintain

600
00:12:05,350 --> 00:12:05,360
all the work happens because we maintain
 

601
00:12:05,360 --> 00:12:07,190
all the work happens because we maintain
the sorted array so we start with an

602
00:12:07,190 --> 00:12:07,200
the sorted array so we start with an
 

603
00:12:07,200 --> 00:12:08,470
the sorted array so we start with an
empty array it's sorted

604
00:12:08,470 --> 00:12:08,480
empty array it's sorted
 

605
00:12:08,480 --> 00:12:10,389
empty array it's sorted
we add an item okay still sorted we add

606
00:12:10,389 --> 00:12:10,399
we add an item okay still sorted we add
 

607
00:12:10,399 --> 00:12:12,470
we add an item okay still sorted we add
a second item and we swap if we need to

608
00:12:12,470 --> 00:12:12,480
a second item and we swap if we need to
 

609
00:12:12,480 --> 00:12:14,389
a second item and we swap if we need to
in order to sort in general we add an

610
00:12:14,389 --> 00:12:14,399
in order to sort in general we add an
 

611
00:12:14,399 --> 00:12:16,629
in order to sort in general we add an
item we swap it to the left until it's

612
00:12:16,629 --> 00:12:16,639
item we swap it to the left until it's
 

613
00:12:16,639 --> 00:12:17,430
item we swap it to the left until it's
sorted again

614
00:12:17,430 --> 00:12:17,440
sorted again
 

615
00:12:17,440 --> 00:12:25,590
sorted again
that is insertion sort

616
00:12:25,590 --> 00:12:25,600
that is insertion sort
 

617
00:12:25,600 --> 00:12:27,910
that is insertion sort
okay kind of cool this is a unifying

618
00:12:27,910 --> 00:12:27,920
okay kind of cool this is a unifying
 

619
00:12:27,920 --> 00:12:28,870
okay kind of cool this is a unifying
framework for

620
00:12:28,870 --> 00:12:28,880
framework for
 

621
00:12:28,880 --> 00:12:31,670
framework for
three uh sorting algorithms that we saw

622
00:12:31,670 --> 00:12:31,680
three uh sorting algorithms that we saw
 

623
00:12:31,680 --> 00:12:32,870
three uh sorting algorithms that we saw
before we didn't

624
00:12:32,870 --> 00:12:32,880
before we didn't
 

625
00:12:32,880 --> 00:12:34,629
before we didn't
actually talk about avl sort last time

626
00:12:34,629 --> 00:12:34,639
actually talk about avl sort last time
 

627
00:12:34,639 --> 00:12:36,069
actually talk about avl sort last time
but it was in the notes

628
00:12:36,069 --> 00:12:36,079
but it was in the notes
 

629
00:12:36,079 --> 00:12:38,230
but it was in the notes
and so that is the right part of this

630
00:12:38,230 --> 00:12:38,240
and so that is the right part of this
 

631
00:12:38,240 --> 00:12:39,670
and so that is the right part of this
table so of course

632
00:12:39,670 --> 00:12:39,680
table so of course
 

633
00:12:39,680 --> 00:12:41,670
table so of course
uh these array data structures are not

634
00:12:41,670 --> 00:12:41,680
uh these array data structures are not
 

635
00:12:41,680 --> 00:12:43,750
uh these array data structures are not
efficient they take linear time some for

636
00:12:43,750 --> 00:12:43,760
efficient they take linear time some for
 

637
00:12:43,760 --> 00:12:45,030
efficient they take linear time some for
some of the operations so the sorting

638
00:12:45,030 --> 00:12:45,040
some of the operations so the sorting
 

639
00:12:45,040 --> 00:12:46,389
some of the operations so the sorting
algorithms are not efficient

640
00:12:46,389 --> 00:12:46,399
algorithms are not efficient
 

641
00:12:46,399 --> 00:12:47,750
algorithms are not efficient
but they're ones we've seen before so

642
00:12:47,750 --> 00:12:47,760
but they're ones we've seen before so
 

643
00:12:47,760 --> 00:12:49,590
but they're ones we've seen before so
it's neat to see how they fit in here

644
00:12:49,590 --> 00:12:49,600
it's neat to see how they fit in here
 

645
00:12:49,600 --> 00:12:51,269
it's neat to see how they fit in here
uh they had the selection sort of

646
00:12:51,269 --> 00:12:51,279
uh they had the selection sort of
 

647
00:12:51,279 --> 00:12:52,629
uh they had the selection sort of
insertion sort had the advantage that

648
00:12:52,629 --> 00:12:52,639
insertion sort had the advantage that
 

649
00:12:52,639 --> 00:12:54,310
insertion sort had the advantage that
they were in place you just needed a

650
00:12:54,310 --> 00:12:54,320
they were in place you just needed a
 

651
00:12:54,320 --> 00:12:56,949
they were in place you just needed a
constant number of pointers or indices

652
00:12:56,949 --> 00:12:56,959
constant number of pointers or indices
 

653
00:12:56,959 --> 00:12:59,670
constant number of pointers or indices
uh beyond the array itself so they're

654
00:12:59,670 --> 00:12:59,680
uh beyond the array itself so they're
 

655
00:12:59,680 --> 00:13:00,790
uh beyond the array itself so they're
very space efficient

656
00:13:00,790 --> 00:13:00,800
very space efficient
 

657
00:13:00,800 --> 00:13:02,710
very space efficient
so that was a plus for them but they

658
00:13:02,710 --> 00:13:02,720
so that was a plus for them but they
 

659
00:13:02,720 --> 00:13:04,230
so that was a plus for them but they
take n squared time so you should never

660
00:13:04,230 --> 00:13:04,240
take n squared time so you should never
 

661
00:13:04,240 --> 00:13:05,269
take n squared time so you should never
use them

662
00:13:05,269 --> 00:13:05,279
use them
 

663
00:13:05,279 --> 00:13:07,030
use them
except for like n at most 100 or

664
00:13:07,030 --> 00:13:07,040
except for like n at most 100 or
 

665
00:13:07,040 --> 00:13:09,190
except for like n at most 100 or
something

666
00:13:09,190 --> 00:13:09,200
something
 

667
00:13:09,200 --> 00:13:12,150
something
avl tree sort is great and then it gets

668
00:13:12,150 --> 00:13:12,160
avl tree sort is great and then it gets
 

669
00:13:12,160 --> 00:13:12,550
avl tree sort is great and then it gets
n log

670
00:13:12,550 --> 00:13:12,560
n log
 

671
00:13:12,560 --> 00:13:15,269
n log
end time probably more complicated than

672
00:13:15,269 --> 00:13:15,279
end time probably more complicated than
 

673
00:13:15,279 --> 00:13:16,629
end time probably more complicated than
merge sort and you could stick to merge

674
00:13:16,629 --> 00:13:16,639
merge sort and you could stick to merge
 

675
00:13:16,639 --> 00:13:17,350
merge sort and you could stick to merge
sort

676
00:13:17,350 --> 00:13:17,360
sort
 

677
00:13:17,360 --> 00:13:19,670
sort
but neither merge short nor set avl tree

678
00:13:19,670 --> 00:13:19,680
but neither merge short nor set avl tree
 

679
00:13:19,680 --> 00:13:20,629
but neither merge short nor set avl tree
sort

680
00:13:20,629 --> 00:13:20,639
sort
 

681
00:13:20,639 --> 00:13:24,310
sort
are in place and so the goal of today

682
00:13:24,310 --> 00:13:24,320
are in place and so the goal of today
 

683
00:13:24,320 --> 00:13:25,990
are in place and so the goal of today
is to get the best of all those worlds

684
00:13:25,990 --> 00:13:26,000
is to get the best of all those worlds
 

685
00:13:26,000 --> 00:13:28,310
is to get the best of all those worlds
in sorting to get n log n comparisons

686
00:13:28,310 --> 00:13:28,320
in sorting to get n log n comparisons
 

687
00:13:28,320 --> 00:13:30,790
in sorting to get n log n comparisons
which is optimal in the comparison model

688
00:13:30,790 --> 00:13:30,800
which is optimal in the comparison model
 

689
00:13:30,800 --> 00:13:33,350
which is optimal in the comparison model
but get it to be in place

690
00:13:33,350 --> 00:13:33,360
but get it to be in place
 

691
00:13:33,360 --> 00:13:34,710
but get it to be in place
and that's what we're going to get with

692
00:13:34,710 --> 00:13:34,720
and that's what we're going to get with
 

693
00:13:34,720 --> 00:13:38,550
and that's what we're going to get with
binary heaps

694
00:13:38,550 --> 00:13:38,560

 

695
00:13:38,560 --> 00:13:40,790

we're going to design a data structure

696
00:13:40,790 --> 00:13:40,800
we're going to design a data structure
 

697
00:13:40,800 --> 00:13:42,150
we're going to design a data structure
that happens to build a little bit

698
00:13:42,150 --> 00:13:42,160
that happens to build a little bit
 

699
00:13:42,160 --> 00:13:43,670
that happens to build a little bit
faster as i mentioned linear time

700
00:13:43,670 --> 00:13:43,680
faster as i mentioned linear time
 

701
00:13:43,680 --> 00:13:45,350
faster as i mentioned linear time
building

702
00:13:45,350 --> 00:13:45,360
building
 

703
00:13:45,360 --> 00:13:47,350
building
so it's not representing a sorted order

704
00:13:47,350 --> 00:13:47,360
so it's not representing a sorted order
 

705
00:13:47,360 --> 00:13:49,750
so it's not representing a sorted order
in the same way that avl trees are

706
00:13:49,750 --> 00:13:49,760
in the same way that avl trees are
 

707
00:13:49,760 --> 00:13:51,350
in the same way that avl trees are
but it will be kind of true based it

708
00:13:51,350 --> 00:13:51,360
but it will be kind of true based it
 

709
00:13:51,360 --> 00:13:53,590
but it will be kind of true based it
will also be array-based

710
00:13:53,590 --> 00:13:53,600
will also be array-based
 

711
00:13:53,600 --> 00:13:55,350
will also be array-based
we're going to get logarithmic time for

712
00:13:55,350 --> 00:13:55,360
we're going to get logarithmic time for
 

713
00:13:55,360 --> 00:13:57,189
we're going to get logarithmic time for
insert and delete max it happens to be

714
00:13:57,189 --> 00:13:57,199
insert and delete max it happens to be
 

715
00:13:57,199 --> 00:14:00,150
insert and delete max it happens to be
amortized because we use arrays

716
00:14:00,150 --> 00:14:00,160
amortized because we use arrays
 

717
00:14:00,160 --> 00:14:01,990
amortized because we use arrays
but when the key thing is that it's an

718
00:14:01,990 --> 00:14:02,000
but when the key thing is that it's an
 

719
00:14:02,000 --> 00:14:03,910
but when the key thing is that it's an
in-place data structure

720
00:14:03,910 --> 00:14:03,920
in-place data structure
 

721
00:14:03,920 --> 00:14:06,230
in-place data structure
it only consists of an array of the

722
00:14:06,230 --> 00:14:06,240
it only consists of an array of the
 

723
00:14:06,240 --> 00:14:07,910
it only consists of an array of the
items

724
00:14:07,910 --> 00:14:07,920
items
 

725
00:14:07,920 --> 00:14:09,590
items
and so when we plug it into our sorting

726
00:14:09,590 --> 00:14:09,600
and so when we plug it into our sorting
 

727
00:14:09,600 --> 00:14:11,030
and so when we plug it into our sorting
algorithm

728
00:14:11,030 --> 00:14:11,040
algorithm
 

729
00:14:11,040 --> 00:14:12,710
algorithm
priority q sort our generic sorting

730
00:14:12,710 --> 00:14:12,720
priority q sort our generic sorting
 

731
00:14:12,720 --> 00:14:14,949
priority q sort our generic sorting
algorithm not only do we get n log n

732
00:14:14,949 --> 00:14:14,959
algorithm not only do we get n log n
 

733
00:14:14,959 --> 00:14:17,590
algorithm not only do we get n log n
performance but we also get it in place

734
00:14:17,590 --> 00:14:17,600
performance but we also get it in place
 

735
00:14:17,600 --> 00:14:19,189
performance but we also get it in place
sorting algorithm this will be our first

736
00:14:19,189 --> 00:14:19,199
sorting algorithm this will be our first
 

737
00:14:19,199 --> 00:14:21,269
sorting algorithm this will be our first
and m and only this class

738
00:14:21,269 --> 00:14:21,279
and m and only this class
 

739
00:14:21,279 --> 00:14:24,470
and m and only this class
and log n in place sorting algorithm

740
00:14:24,470 --> 00:14:24,480
and log n in place sorting algorithm
 

741
00:14:24,480 --> 00:14:29,670
and log n in place sorting algorithm
cool that's the goal

742
00:14:29,670 --> 00:14:29,680
cool that's the goal
 

743
00:14:29,680 --> 00:14:32,710
cool that's the goal
let's do it so uh

744
00:14:32,710 --> 00:14:32,720
let's do it so uh
 

745
00:14:32,720 --> 00:14:35,910
let's do it so uh
what we're going to do uh because we're

746
00:14:35,910 --> 00:14:35,920
what we're going to do uh because we're
 

747
00:14:35,920 --> 00:14:37,590
what we're going to do uh because we're
in place basically we have to have an

748
00:14:37,590 --> 00:14:37,600
in place basically we have to have an
 

749
00:14:37,600 --> 00:14:38,470
in place basically we have to have an
array

750
00:14:38,470 --> 00:14:38,480
array
 

751
00:14:38,480 --> 00:14:40,150
array
storing our n items that's sort of the

752
00:14:40,150 --> 00:14:40,160
storing our n items that's sort of the
 

753
00:14:40,160 --> 00:14:41,509
storing our n items that's sort of the
definition of in place

754
00:14:41,509 --> 00:14:41,519
definition of in place
 

755
00:14:41,519 --> 00:14:44,870
definition of in place
just using n slots of memory exactly the

756
00:14:44,870 --> 00:14:44,880
just using n slots of memory exactly the
 

757
00:14:44,880 --> 00:14:45,910
just using n slots of memory exactly the
size of

758
00:14:45,910 --> 00:14:45,920
size of
 

759
00:14:45,920 --> 00:14:48,150
size of
the number of items in our structure but

760
00:14:48,150 --> 00:14:48,160
the number of items in our structure but
 

761
00:14:48,160 --> 00:14:49,189
the number of items in our structure but
we're obviously not going to use a

762
00:14:49,189 --> 00:14:49,199
we're obviously not going to use a
 

763
00:14:49,199 --> 00:14:51,269
we're obviously not going to use a
regular unsorted array or a regular

764
00:14:51,269 --> 00:14:51,279
regular unsorted array or a regular
 

765
00:14:51,279 --> 00:14:53,910
regular unsorted array or a regular
sorted array we're going to use array

766
00:14:53,910 --> 00:14:53,920
sorted array we're going to use array
 

767
00:14:53,920 --> 00:14:55,269
sorted array we're going to use array
just as sort of the underlying

768
00:14:55,269 --> 00:14:55,279
just as sort of the underlying
 

769
00:14:55,279 --> 00:14:56,150
just as sort of the underlying
technology

770
00:14:56,150 --> 00:14:56,160
technology
 

771
00:14:56,160 --> 00:14:58,310
technology
for how things are stored but we'd

772
00:14:58,310 --> 00:14:58,320
for how things are stored but we'd
 

773
00:14:58,320 --> 00:14:59,269
for how things are stored but we'd
really like

774
00:14:59,269 --> 00:14:59,279
really like
 

775
00:14:59,279 --> 00:15:01,030
really like
logarithmic performance which should

776
00:15:01,030 --> 00:15:01,040
logarithmic performance which should
 

777
00:15:01,040 --> 00:15:02,790
logarithmic performance which should
make you think tree

778
00:15:02,790 --> 00:15:02,800
make you think tree
 

779
00:15:02,800 --> 00:15:04,550
make you think tree
only way to get a log is with the binary

780
00:15:04,550 --> 00:15:04,560
only way to get a log is with the binary
 

781
00:15:04,560 --> 00:15:06,470
only way to get a log is with the binary
tree more or less

782
00:15:06,470 --> 00:15:06,480
tree more or less
 

783
00:15:06,480 --> 00:15:09,590
tree more or less
so tree

784
00:15:09,590 --> 00:15:09,600
so tree
 

785
00:15:09,600 --> 00:15:13,350
so tree
somehow we want to embed a tree

786
00:15:13,350 --> 00:15:13,360
somehow we want to embed a tree
 

787
00:15:13,360 --> 00:15:23,829
somehow we want to embed a tree
into an array let me grab an example

788
00:15:23,829 --> 00:15:23,839

 

789
00:15:23,839 --> 00:15:44,550

let me draw a tree

790
00:15:44,550 --> 00:15:44,560

 

791
00:15:44,560 --> 00:15:47,189

if i got to choose any old tree i want i

792
00:15:47,189 --> 00:15:47,199
if i got to choose any old tree i want i
 

793
00:15:47,199 --> 00:15:48,310
if i got to choose any old tree i want i
would choose

794
00:15:48,310 --> 00:15:48,320
would choose
 

795
00:15:48,320 --> 00:15:50,550
would choose
a tree that's basically perfectly

796
00:15:50,550 --> 00:15:50,560
a tree that's basically perfectly
 

797
00:15:50,560 --> 00:15:51,350
a tree that's basically perfectly
balanced

798
00:15:51,350 --> 00:15:51,360
balanced
 

799
00:15:51,360 --> 00:15:54,949
balanced
perfectly balanced to be like this where

800
00:15:54,949 --> 00:15:54,959
perfectly balanced to be like this where
 

801
00:15:54,959 --> 00:15:57,749
perfectly balanced to be like this where
what's the property that i have all of

802
00:15:57,749 --> 00:15:57,759
what's the property that i have all of
 

803
00:15:57,759 --> 00:15:58,230
what's the property that i have all of
these

804
00:15:58,230 --> 00:15:58,240
these
 

805
00:15:58,240 --> 00:15:59,829
these
levels all of these depths are

806
00:15:59,829 --> 00:15:59,839
levels all of these depths are
 

807
00:15:59,839 --> 00:16:01,670
levels all of these depths are
completely filled with nodes

808
00:16:01,670 --> 00:16:01,680
completely filled with nodes
 

809
00:16:01,680 --> 00:16:05,590
completely filled with nodes
this is depth zero

810
00:16:05,590 --> 00:16:05,600

 

811
00:16:05,600 --> 00:16:08,389

remember this is depth one this is depth

812
00:16:08,389 --> 00:16:08,399
remember this is depth one this is depth
 

813
00:16:08,399 --> 00:16:09,430
remember this is depth one this is depth
two

814
00:16:09,430 --> 00:16:09,440
two
 

815
00:16:09,440 --> 00:16:11,910
two
this is depth three so what i'd really

816
00:16:11,910 --> 00:16:11,920
this is depth three so what i'd really
 

817
00:16:11,920 --> 00:16:12,790
this is depth three so what i'd really
like

818
00:16:12,790 --> 00:16:12,800
like
 

819
00:16:12,800 --> 00:16:18,550
like
uh is to have uh two to the i nodes

820
00:16:18,550 --> 00:16:18,560

 

821
00:16:18,560 --> 00:16:23,030

at depth i that would be a perfect

822
00:16:23,030 --> 00:16:23,040
at depth i that would be a perfect
 

823
00:16:23,040 --> 00:16:26,470
at depth i that would be a perfect
binary tree uh but that only works when

824
00:16:26,470 --> 00:16:26,480
binary tree uh but that only works when
 

825
00:16:26,480 --> 00:16:28,150
binary tree uh but that only works when
n is one less than a power of two

826
00:16:28,150 --> 00:16:28,160
n is one less than a power of two
 

827
00:16:28,160 --> 00:16:30,629
n is one less than a power of two
right uh i can't always achieve that for

828
00:16:30,629 --> 00:16:30,639
right uh i can't always achieve that for
 

829
00:16:30,639 --> 00:16:31,509
right uh i can't always achieve that for
any n

830
00:16:31,509 --> 00:16:31,519
any n
 

831
00:16:31,519 --> 00:16:33,269
any n
and so the next best thing i could hope

832
00:16:33,269 --> 00:16:33,279
and so the next best thing i could hope
 

833
00:16:33,279 --> 00:16:35,030
and so the next best thing i could hope
for is

834
00:16:35,030 --> 00:16:35,040
for is
 

835
00:16:35,040 --> 00:16:37,269
for is
2 to the i knows a depth i until the

836
00:16:37,269 --> 00:16:37,279
2 to the i knows a depth i until the
 

837
00:16:37,279 --> 00:16:38,310
2 to the i knows a depth i until the
very last i

838
00:16:38,310 --> 00:16:38,320
very last i
 

839
00:16:38,320 --> 00:16:41,590
very last i
the largest depth and in that

840
00:16:41,590 --> 00:16:41,600
the largest depth and in that
 

841
00:16:41,600 --> 00:16:43,509
the largest depth and in that
level i'm still going to restrict things

842
00:16:43,509 --> 00:16:43,519
level i'm still going to restrict things
 

843
00:16:43,519 --> 00:16:44,629
level i'm still going to restrict things
i'm going to force

844
00:16:44,629 --> 00:16:44,639
i'm going to force
 

845
00:16:44,639 --> 00:16:46,389
i'm going to force
all of the nodes to be as far left as

846
00:16:46,389 --> 00:16:46,399
all of the nodes to be as far left as
 

847
00:16:46,399 --> 00:16:48,069
all of the nodes to be as far left as
possible

848
00:16:48,069 --> 00:16:48,079
possible
 

849
00:16:48,079 --> 00:16:53,030
possible
okay so i want to say accept

850
00:16:53,030 --> 00:16:53,040

 

851
00:16:53,040 --> 00:16:58,150

at max depth

852
00:16:58,150 --> 00:16:58,160

 

853
00:16:58,160 --> 00:17:01,350

where

854
00:17:01,350 --> 00:17:01,360

 

855
00:17:01,360 --> 00:17:10,549

nodes are i'll call them left justified

856
00:17:10,549 --> 00:17:10,559

 

857
00:17:10,559 --> 00:17:12,789

and these two properties together is

858
00:17:12,789 --> 00:17:12,799
and these two properties together is
 

859
00:17:12,799 --> 00:17:14,390
and these two properties together is
what i call a complete

860
00:17:14,390 --> 00:17:14,400
what i call a complete
 

861
00:17:14,400 --> 00:17:26,549
what i call a complete
binary tree

862
00:17:26,549 --> 00:17:26,559

 

863
00:17:26,559 --> 00:17:30,310

uh why is this interesting because i

864
00:17:30,310 --> 00:17:30,320
uh why is this interesting because i
 

865
00:17:30,320 --> 00:17:33,350
uh why is this interesting because i
claim i can represent a tree like this

866
00:17:33,350 --> 00:17:33,360
claim i can represent a tree like this
 

867
00:17:33,360 --> 00:17:36,470
claim i can represent a tree like this
as an array i've narrowed things down

868
00:17:36,470 --> 00:17:36,480
as an array i've narrowed things down
 

869
00:17:36,480 --> 00:17:37,909
as an array i've narrowed things down
enough

870
00:17:37,909 --> 00:17:37,919
enough
 

871
00:17:37,919 --> 00:17:41,270
enough
that i can draw an array down here

872
00:17:41,270 --> 00:17:41,280
that i can draw an array down here
 

873
00:17:41,280 --> 00:17:43,029
that i can draw an array down here
and what i'm going to do is write these

874
00:17:43,029 --> 00:17:43,039
and what i'm going to do is write these
 

875
00:17:43,039 --> 00:17:45,110
and what i'm going to do is write these
nodes in depth order

876
00:17:45,110 --> 00:17:45,120
nodes in depth order
 

877
00:17:45,120 --> 00:17:47,029
nodes in depth order
so write a first because that's step

878
00:17:47,029 --> 00:17:47,039
so write a first because that's step
 

879
00:17:47,039 --> 00:17:50,789
so write a first because that's step
zero then bc that's depth one

880
00:17:50,789 --> 00:17:50,799
zero then bc that's depth one
 

881
00:17:50,799 --> 00:17:53,430
zero then bc that's depth one
then uh well they're alphabetical i made

882
00:17:53,430 --> 00:17:53,440
then uh well they're alphabetical i made
 

883
00:17:53,440 --> 00:17:54,630
then uh well they're alphabetical i made
it that way

884
00:17:54,630 --> 00:17:54,640
it that way
 

885
00:17:54,640 --> 00:17:58,630
it that way
d e f g is depth two

886
00:17:58,630 --> 00:17:58,640
d e f g is depth two
 

887
00:17:58,640 --> 00:18:02,710
d e f g is depth two
and then hij is depth three

888
00:18:02,710 --> 00:18:02,720

 

889
00:18:02,720 --> 00:18:04,549

okay this is very different from

890
00:18:04,549 --> 00:18:04,559
okay this is very different from
 

891
00:18:04,559 --> 00:18:05,990
okay this is very different from
traversal order of a tree

892
00:18:05,990 --> 00:18:06,000
traversal order of a tree
 

893
00:18:06,000 --> 00:18:08,470
traversal order of a tree
traversal order would have been h d i b

894
00:18:08,470 --> 00:18:08,480
traversal order would have been h d i b
 

895
00:18:08,480 --> 00:18:09,190
traversal order would have been h d i b
j e

896
00:18:09,190 --> 00:18:09,200
j e
 

897
00:18:09,200 --> 00:18:12,390
j e
a f c g okay but this

898
00:18:12,390 --> 00:18:12,400
a f c g okay but this
 

899
00:18:12,400 --> 00:18:15,430
a f c g okay but this
is what we might call depth order do the

900
00:18:15,430 --> 00:18:15,440
is what we might call depth order do the
 

901
00:18:15,440 --> 00:18:17,510
is what we might call depth order do the
lowest depth nodes first

902
00:18:17,510 --> 00:18:17,520
lowest depth nodes first
 

903
00:18:17,520 --> 00:18:19,990
lowest depth nodes first
very different way to lay things out or

904
00:18:19,990 --> 00:18:20,000
very different way to lay things out or
 

905
00:18:20,000 --> 00:18:21,750
very different way to lay things out or
to to linearize

906
00:18:21,750 --> 00:18:21,760
to to linearize
 

907
00:18:21,760 --> 00:18:25,669
to to linearize
our data and this is what

908
00:18:25,669 --> 00:18:25,679
our data and this is what
 

909
00:18:25,679 --> 00:18:28,070
our data and this is what
a heap is going to look like so the cool

910
00:18:28,070 --> 00:18:28,080
a heap is going to look like so the cool
 

911
00:18:28,080 --> 00:18:29,110
a heap is going to look like so the cool
thing is

912
00:18:29,110 --> 00:18:29,120
thing is
 

913
00:18:29,120 --> 00:18:32,789
thing is
between complete

914
00:18:32,789 --> 00:18:32,799
between complete
 

915
00:18:32,799 --> 00:18:36,230
between complete
binary trees and arrays is a bijection

916
00:18:36,230 --> 00:18:36,240
binary trees and arrays is a bijection
 

917
00:18:36,240 --> 00:18:38,310
binary trees and arrays is a bijection
for every array there's a unique

918
00:18:38,310 --> 00:18:38,320
for every array there's a unique
 

919
00:18:38,320 --> 00:18:39,590
for every array there's a unique
complete binary tree

920
00:18:39,590 --> 00:18:39,600
complete binary tree
 

921
00:18:39,600 --> 00:18:41,110
complete binary tree
and for every complete binary tree

922
00:18:41,110 --> 00:18:41,120
and for every complete binary tree
 

923
00:18:41,120 --> 00:18:43,270
and for every complete binary tree
there's a unique array

924
00:18:43,270 --> 00:18:43,280
there's a unique array
 

925
00:18:43,280 --> 00:18:46,150
there's a unique array
why because the complete constraint

926
00:18:46,150 --> 00:18:46,160
why because the complete constraint
 

927
00:18:46,160 --> 00:18:47,590
why because the complete constraint
forces everything

928
00:18:47,590 --> 00:18:47,600
forces everything
 

929
00:18:47,600 --> 00:18:49,669
forces everything
forces my hand there's only if i give

930
00:18:49,669 --> 00:18:49,679
forces my hand there's only if i give
 

931
00:18:49,679 --> 00:18:50,789
forces my hand there's only if i give
you a number n

932
00:18:50,789 --> 00:18:50,799
you a number n
 

933
00:18:50,799 --> 00:18:53,590
you a number n
there's one tree shape of size n right

934
00:18:53,590 --> 00:18:53,600
there's one tree shape of size n right
 

935
00:18:53,600 --> 00:18:55,990
there's one tree shape of size n right
you just fill in the nodes

936
00:18:55,990 --> 00:18:56,000
you just fill in the nodes
 

937
00:18:56,000 --> 00:18:57,669
you just fill in the nodes
top down until you get to the last level

938
00:18:57,669 --> 00:18:57,679
top down until you get to the last level
 

939
00:18:57,679 --> 00:18:58,870
top down until you get to the last level
and then you have to fill them in left

940
00:18:58,870 --> 00:18:58,880
and then you have to fill them in left
 

941
00:18:58,880 --> 00:18:59,750
and then you have to fill them in left
to right

942
00:18:59,750 --> 00:18:59,760
to right
 

943
00:18:59,760 --> 00:19:02,549
to right
what you might call reading order for

944
00:19:02,549 --> 00:19:02,559
what you might call reading order for
 

945
00:19:02,559 --> 00:19:03,750
what you might call reading order for
writing down nodes

946
00:19:03,750 --> 00:19:03,760
writing down nodes
 

947
00:19:03,760 --> 00:19:06,230
writing down nodes
and the array is telling you which keys

948
00:19:06,230 --> 00:19:06,240
and the array is telling you which keys
 

949
00:19:06,240 --> 00:19:06,950
and the array is telling you which keys
go where

950
00:19:06,950 --> 00:19:06,960
go where
 

951
00:19:06,960 --> 00:19:08,549
go where
this is the first node you write down at

952
00:19:08,549 --> 00:19:08,559
this is the first node you write down at
 

953
00:19:08,559 --> 00:19:10,310
this is the first node you write down at
the root this is the next node you write

954
00:19:10,310 --> 00:19:10,320
the root this is the next node you write
 

955
00:19:10,320 --> 00:19:11,990
the root this is the next node you write
down at the left child of the root

956
00:19:11,990 --> 00:19:12,000
down at the left child of the root
 

957
00:19:12,000 --> 00:19:14,789
down at the left child of the root
and so on okay so here we have a binary

958
00:19:14,789 --> 00:19:14,799
and so on okay so here we have a binary
 

959
00:19:14,799 --> 00:19:15,510
and so on okay so here we have a binary
tree

960
00:19:15,510 --> 00:19:15,520
tree
 

961
00:19:15,520 --> 00:19:17,909
tree
represented as an array or an array

962
00:19:17,909 --> 00:19:17,919
represented as an array or an array
 

963
00:19:17,919 --> 00:19:19,430
represented as an array or an array
representing a binary tree

964
00:19:19,430 --> 00:19:19,440
representing a binary tree
 

965
00:19:19,440 --> 00:19:22,390
representing a binary tree
the very specific binary tree it has a

966
00:19:22,390 --> 00:19:22,400
the very specific binary tree it has a
 

967
00:19:22,400 --> 00:19:23,190
the very specific binary tree it has a
clear

968
00:19:23,190 --> 00:19:23,200
clear
 

969
00:19:23,200 --> 00:19:24,950
clear
advantage which is it is guaranteed

970
00:19:24,950 --> 00:19:24,960
advantage which is it is guaranteed
 

971
00:19:24,960 --> 00:19:27,029
advantage which is it is guaranteed
balance no rotation is necessary in

972
00:19:27,029 --> 00:19:27,039
balance no rotation is necessary in
 

973
00:19:27,039 --> 00:19:28,070
balance no rotation is necessary in
heaps because

974
00:19:28,070 --> 00:19:28,080
heaps because
 

975
00:19:28,080 --> 00:19:29,350
heaps because
complete binary trees are always

976
00:19:29,350 --> 00:19:29,360
complete binary trees are always
 

977
00:19:29,360 --> 00:19:30,870
complete binary trees are always
balanced in fact they have the best

978
00:19:30,870 --> 00:19:30,880
balanced in fact they have the best
 

979
00:19:30,880 --> 00:19:33,669
balanced in fact they have the best
height they possibly could

980
00:19:33,669 --> 00:19:33,679
height they possibly could
 

981
00:19:33,679 --> 00:19:39,430
height they possibly could
which is ceiling of log n

982
00:19:39,430 --> 00:19:39,440
which is ceiling of log n
 

983
00:19:39,440 --> 00:19:41,270
which is ceiling of log n
balanced remember just meant your big o

984
00:19:41,270 --> 00:19:41,280
balanced remember just meant your big o
 

985
00:19:41,280 --> 00:19:43,029
balanced remember just meant your big o
of log n this is

986
00:19:43,029 --> 00:19:43,039
of log n this is
 

987
00:19:43,039 --> 00:19:46,230
of log n this is
one times log n so it's the best level

988
00:19:46,230 --> 00:19:46,240
one times log n so it's the best level
 

989
00:19:46,240 --> 00:19:47,750
one times log n so it's the best level
of balance you could hope for

990
00:19:47,750 --> 00:19:47,760
of balance you could hope for
 

991
00:19:47,760 --> 00:19:51,270
of balance you could hope for
so somehow i claim we can maintain a

992
00:19:51,270 --> 00:19:51,280
so somehow i claim we can maintain a
 

993
00:19:51,280 --> 00:19:52,070
so somehow i claim we can maintain a
complete binary

994
00:19:52,070 --> 00:19:52,080
complete binary
 

995
00:19:52,080 --> 00:19:54,230
complete binary
tree for solving priority queues this

996
00:19:54,230 --> 00:19:54,240
tree for solving priority queues this
 

997
00:19:54,240 --> 00:19:55,669
tree for solving priority queues this
would not be possible if we were trying

998
00:19:55,669 --> 00:19:55,679
would not be possible if we were trying
 

999
00:19:55,679 --> 00:19:57,510
would not be possible if we were trying
to solve the whole set interface

1000
00:19:57,510 --> 00:19:57,520
to solve the whole set interface
 

1001
00:19:57,520 --> 00:19:58,789
to solve the whole set interface
and that's kind of the cool thing about

1002
00:19:58,789 --> 00:19:58,799
and that's kind of the cool thing about
 

1003
00:19:58,799 --> 00:20:01,029
and that's kind of the cool thing about
heaps is that by just focusing on the

1004
00:20:01,029 --> 00:20:01,039
heaps is that by just focusing on the
 

1005
00:20:01,039 --> 00:20:02,870
heaps is that by just focusing on the
subset of the set interface

1006
00:20:02,870 --> 00:20:02,880
subset of the set interface
 

1007
00:20:02,880 --> 00:20:06,230
subset of the set interface
we can do more we can maintain this very

1008
00:20:06,230 --> 00:20:06,240
we can do more we can maintain this very
 

1009
00:20:06,240 --> 00:20:07,430
we can do more we can maintain this very
strong property

1010
00:20:07,430 --> 00:20:07,440
strong property
 

1011
00:20:07,440 --> 00:20:08,870
strong property
and because we have this very strong

1012
00:20:08,870 --> 00:20:08,880
and because we have this very strong
 

1013
00:20:08,880 --> 00:20:10,310
and because we have this very strong
property we don't even need to store

1014
00:20:10,310 --> 00:20:10,320
property we don't even need to store
 

1015
00:20:10,320 --> 00:20:11,750
property we don't even need to store
this tree we're not going to store left

1016
00:20:11,750 --> 00:20:11,760
this tree we're not going to store left
 

1017
00:20:11,760 --> 00:20:13,029
this tree we're not going to store left
and right pointers

1018
00:20:13,029 --> 00:20:13,039
and right pointers
 

1019
00:20:13,039 --> 00:20:14,630
and right pointers
and parent pointers we're just going to

1020
00:20:14,630 --> 00:20:14,640
and parent pointers we're just going to
 

1021
00:20:14,640 --> 00:20:16,390
and parent pointers we're just going to
store the array

1022
00:20:16,390 --> 00:20:16,400
store the array
 

1023
00:20:16,400 --> 00:20:19,029
store the array
this is what we call an implicit data

1024
00:20:19,029 --> 00:20:19,039
this is what we call an implicit data
 

1025
00:20:19,039 --> 00:20:28,549
this is what we call an implicit data
structure

1026
00:20:28,549 --> 00:20:28,559

 

1027
00:20:28,559 --> 00:20:33,270

which basically means no pointers

1028
00:20:33,270 --> 00:20:33,280

 

1029
00:20:33,280 --> 00:20:37,510

just an array

1030
00:20:37,510 --> 00:20:37,520

 

1031
00:20:37,520 --> 00:20:43,990

of the n items

1032
00:20:43,990 --> 00:20:44,000

 

1033
00:20:44,000 --> 00:20:45,270

how are we going to get away without

1034
00:20:45,270 --> 00:20:45,280
how are we going to get away without
 

1035
00:20:45,280 --> 00:20:47,750
how are we going to get away without
storing pointers i'd still like to treat

1036
00:20:47,750 --> 00:20:47,760
storing pointers i'd still like to treat
 

1037
00:20:47,760 --> 00:20:50,230
storing pointers i'd still like to treat
it like a tree i'd still like to know

1038
00:20:50,230 --> 00:20:50,240
it like a tree i'd still like to know
 

1039
00:20:50,240 --> 00:20:52,470
it like a tree i'd still like to know
the left child of b is d and the right

1040
00:20:52,470 --> 00:20:52,480
the left child of b is d and the right
 

1041
00:20:52,480 --> 00:20:53,270
the left child of b is d and the right
child of b

1042
00:20:53,270 --> 00:20:53,280
child of b
 

1043
00:20:53,280 --> 00:20:56,310
child of b
is e we'll see why in a moment

1044
00:20:56,310 --> 00:20:56,320
is e we'll see why in a moment
 

1045
00:20:56,320 --> 00:20:59,990
is e we'll see why in a moment
we can do this with uh

1046
00:20:59,990 --> 00:21:00,000
we can do this with uh
 

1047
00:21:00,000 --> 00:21:04,149
we can do this with uh
index arithmetic so

1048
00:21:04,149 --> 00:21:04,159
index arithmetic so
 

1049
00:21:04,159 --> 00:21:06,070
index arithmetic so
maybe i should add some labels before i

1050
00:21:06,070 --> 00:21:06,080
maybe i should add some labels before i
 

1051
00:21:06,080 --> 00:21:11,190
maybe i should add some labels before i
get there

1052
00:21:11,190 --> 00:21:11,200

 

1053
00:21:11,200 --> 00:21:13,750

so this array naturally has indices

1054
00:21:13,750 --> 00:21:13,760
so this array naturally has indices
 

1055
00:21:13,760 --> 00:21:16,390
so this array naturally has indices
right this is index zero

1056
00:21:16,390 --> 00:21:16,400
right this is index zero
 

1057
00:21:16,400 --> 00:21:19,190
right this is index zero
this is index one index two index three

1058
00:21:19,190 --> 00:21:19,200
this is index one index two index three
 

1059
00:21:19,200 --> 00:21:19,990
this is index one index two index three
index four

1060
00:21:19,990 --> 00:21:20,000
index four
 

1061
00:21:20,000 --> 00:21:23,270
index four
index five index six seven eight

1062
00:21:23,270 --> 00:21:23,280
index five index six seven eight
 

1063
00:21:23,280 --> 00:21:26,149
index five index six seven eight
nine because there are ten items zero

1064
00:21:26,149 --> 00:21:26,159
nine because there are ten items zero
 

1065
00:21:26,159 --> 00:21:27,669
nine because there are ten items zero
through nine

1066
00:21:27,669 --> 00:21:27,679
through nine
 

1067
00:21:27,679 --> 00:21:29,510
through nine
and i can apply those labels up here too

1068
00:21:29,510 --> 00:21:29,520
and i can apply those labels up here too
 

1069
00:21:29,520 --> 00:21:31,430
and i can apply those labels up here too
these are the same nodes so 0

1070
00:21:31,430 --> 00:21:31,440
these are the same nodes so 0
 

1071
00:21:31,440 --> 00:21:36,710
these are the same nodes so 0
1 2. this is just depth order

1072
00:21:36,710 --> 00:21:36,720

 

1073
00:21:36,720 --> 00:21:38,149

but once i have this labeling it's going

1074
00:21:38,149 --> 00:21:38,159
but once i have this labeling it's going
 

1075
00:21:38,159 --> 00:21:39,830
but once i have this labeling it's going
to be a lot easier to figure things out

1076
00:21:39,830 --> 00:21:39,840
to be a lot easier to figure things out
 

1077
00:21:39,840 --> 00:21:41,510
to be a lot easier to figure things out
so if i wanted to know the left child of

1078
00:21:41,510 --> 00:21:41,520
so if i wanted to know the left child of
 

1079
00:21:41,520 --> 00:21:43,270
so if i wanted to know the left child of
b is d somehow

1080
00:21:43,270 --> 00:21:43,280
b is d somehow
 

1081
00:21:43,280 --> 00:21:45,750
b is d somehow
given the number one i want to compute

1082
00:21:45,750 --> 00:21:45,760
given the number one i want to compute
 

1083
00:21:45,760 --> 00:21:48,310
given the number one i want to compute
the number three

1084
00:21:48,310 --> 00:21:48,320
the number three
 

1085
00:21:48,320 --> 00:21:51,669
the number three
uh add two they're all sort of

1086
00:21:51,669 --> 00:21:51,679
uh add two they're all sort of
 

1087
00:21:51,679 --> 00:21:53,110
uh add two they're all sort of
multiplied by three there are all sorts

1088
00:21:53,110 --> 00:21:53,120
multiplied by three there are all sorts
 

1089
00:21:53,120 --> 00:21:54,870
multiplied by three there are all sorts
of operations that take one and turn it

1090
00:21:54,870 --> 00:21:54,880
of operations that take one and turn it
 

1091
00:21:54,880 --> 00:21:55,590
of operations that take one and turn it
into three

1092
00:21:55,590 --> 00:21:55,600
into three
 

1093
00:21:55,600 --> 00:21:56,870
into three
but there's only one that's going to

1094
00:21:56,870 --> 00:21:56,880
but there's only one that's going to
 

1095
00:21:56,880 --> 00:21:59,510
but there's only one that's going to
work in all cases and the intuition here

1096
00:21:59,510 --> 00:21:59,520
work in all cases and the intuition here
 

1097
00:21:59,520 --> 00:21:59,750
work in all cases and the intuition here
is

1098
00:21:59,750 --> 00:21:59,760
is
 

1099
00:21:59,760 --> 00:22:02,390
is
well i have 2 to the i nodes at level i

1100
00:22:02,390 --> 00:22:02,400
well i have 2 to the i nodes at level i
 

1101
00:22:02,400 --> 00:22:03,830
well i have 2 to the i nodes at level i
if i want to go to the child

1102
00:22:03,830 --> 00:22:03,840
if i want to go to the child
 

1103
00:22:03,840 --> 00:22:05,909
if i want to go to the child
level there's 2 to the i plus 1 nodes

1104
00:22:05,909 --> 00:22:05,919
level there's 2 to the i plus 1 nodes
 

1105
00:22:05,919 --> 00:22:08,070
level there's 2 to the i plus 1 nodes
down there right exactly double

1106
00:22:08,070 --> 00:22:08,080
down there right exactly double
 

1107
00:22:08,080 --> 00:22:09,830
down there right exactly double
except the very last one but that won't

1108
00:22:09,830 --> 00:22:09,840
except the very last one but that won't
 

1109
00:22:09,840 --> 00:22:11,909
except the very last one but that won't
really matter if there is a left child

1110
00:22:11,909 --> 00:22:11,919
really matter if there is a left child
 

1111
00:22:11,919 --> 00:22:13,190
really matter if there is a left child
it will behave the same

1112
00:22:13,190 --> 00:22:13,200
it will behave the same
 

1113
00:22:13,200 --> 00:22:14,870
it will behave the same
and so intuitively i have this space of

1114
00:22:14,870 --> 00:22:14,880
and so intuitively i have this space of
 

1115
00:22:14,880 --> 00:22:16,789
and so intuitively i have this space of
size 2 to the i have to expand it to a

1116
00:22:16,789 --> 00:22:16,799
size 2 to the i have to expand it to a
 

1117
00:22:16,799 --> 00:22:17,830
size 2 to the i have to expand it to a
spacer size

1118
00:22:17,830 --> 00:22:17,840
spacer size
 

1119
00:22:17,840 --> 00:22:20,710
spacer size
to the i plus 1 so i should multiply by

1120
00:22:20,710 --> 00:22:20,720
to the i plus 1 so i should multiply by
 

1121
00:22:20,720 --> 00:22:22,149
to the i plus 1 so i should multiply by
2.

1122
00:22:22,149 --> 00:22:22,159
2.
 

1123
00:22:22,159 --> 00:22:24,149
2.
okay and that's almost right but then

1124
00:22:24,149 --> 00:22:24,159
okay and that's almost right but then
 

1125
00:22:24,159 --> 00:22:25,430
okay and that's almost right but then
there's some

1126
00:22:25,430 --> 00:22:25,440
there's some
 

1127
00:22:25,440 --> 00:22:29,350
there's some
constants so i'd like to say 2 times i

1128
00:22:29,350 --> 00:22:29,360
constants so i'd like to say 2 times i
 

1129
00:22:29,360 --> 00:22:32,230
constants so i'd like to say 2 times i
but if we look at the examples here 1

1130
00:22:32,230 --> 00:22:32,240
but if we look at the examples here 1
 

1131
00:22:32,240 --> 00:22:33,270
but if we look at the examples here 1
times 2 is

1132
00:22:33,270 --> 00:22:33,280
times 2 is
 

1133
00:22:33,280 --> 00:22:37,190
times 2 is
2 which is 1 less than 3. 2 times 2 is 4

1134
00:22:37,190 --> 00:22:37,200
2 which is 1 less than 3. 2 times 2 is 4
 

1135
00:22:37,200 --> 00:22:38,710
2 which is 1 less than 3. 2 times 2 is 4
which is 1 less than 5. hey

1136
00:22:38,710 --> 00:22:38,720
which is 1 less than 5. hey
 

1137
00:22:38,720 --> 00:22:40,149
which is 1 less than 5. hey
we almost got it right it's just off by

1138
00:22:40,149 --> 00:22:40,159
we almost got it right it's just off by
 

1139
00:22:40,159 --> 00:22:43,110
we almost got it right it's just off by
one

1140
00:22:43,110 --> 00:22:43,120

 

1141
00:22:43,120 --> 00:22:46,470

off my one is you know index errors are

1142
00:22:46,470 --> 00:22:46,480
off my one is you know index errors are
 

1143
00:22:46,480 --> 00:22:47,750
off my one is you know index errors are
the most common things in computer

1144
00:22:47,750 --> 00:22:47,760
the most common things in computer
 

1145
00:22:47,760 --> 00:22:50,710
the most common things in computer
science

1146
00:22:50,710 --> 00:22:50,720

 

1147
00:22:50,720 --> 00:22:54,070

what about the right child

1148
00:22:54,070 --> 00:22:54,080
what about the right child
 

1149
00:22:54,080 --> 00:22:55,590
what about the right child
if the left child's a two i plus one

1150
00:22:55,590 --> 00:22:55,600
if the left child's a two i plus one
 

1151
00:22:55,600 --> 00:22:59,350
if the left child's a two i plus one
where's the right child

1152
00:22:59,350 --> 00:22:59,360

 

1153
00:22:59,360 --> 00:23:03,270

i hear lots of mumbles two i plus two

1154
00:23:03,270 --> 00:23:03,280
i hear lots of mumbles two i plus two
 

1155
00:23:03,280 --> 00:23:04,789
i hear lots of mumbles two i plus two
one more because we're writing things

1156
00:23:04,789 --> 00:23:04,799
one more because we're writing things
 

1157
00:23:04,799 --> 00:23:06,470
one more because we're writing things
left to right in depth order

1158
00:23:06,470 --> 00:23:06,480
left to right in depth order
 

1159
00:23:06,480 --> 00:23:08,870
left to right in depth order
the right child is the right sibling of

1160
00:23:08,870 --> 00:23:08,880
the right child is the right sibling of
 

1161
00:23:08,880 --> 00:23:10,390
the right child is the right sibling of
the left child so it's just one

1162
00:23:10,390 --> 00:23:10,400
the left child so it's just one
 

1163
00:23:10,400 --> 00:23:13,909
the left child so it's just one
one larger okay given those rules

1164
00:23:13,909 --> 00:23:13,919
one larger okay given those rules
 

1165
00:23:13,919 --> 00:23:16,630
one larger okay given those rules
we can also compute parent it's just

1166
00:23:16,630 --> 00:23:16,640
we can also compute parent it's just
 

1167
00:23:16,640 --> 00:23:17,190
we can also compute parent it's just
whatever

1168
00:23:17,190 --> 00:23:17,200
whatever
 

1169
00:23:17,200 --> 00:23:18,549
whatever
is the inverse of both of these

1170
00:23:18,549 --> 00:23:18,559
is the inverse of both of these
 

1171
00:23:18,559 --> 00:23:20,830
is the inverse of both of these
functions

1172
00:23:20,830 --> 00:23:20,840
functions
 

1173
00:23:20,840 --> 00:23:23,990
functions
which i want to divide by two at some

1174
00:23:23,990 --> 00:23:24,000
which i want to divide by two at some
 

1175
00:23:24,000 --> 00:23:24,789
which i want to divide by two at some
point

1176
00:23:24,789 --> 00:23:24,799
point
 

1177
00:23:24,799 --> 00:23:26,789
point
but be to get i want to get back to i

1178
00:23:26,789 --> 00:23:26,799
but be to get i want to get back to i
 

1179
00:23:26,799 --> 00:23:29,350
but be to get i want to get back to i
given 2i plus 1 or given 2i plus 2.

1180
00:23:29,350 --> 00:23:29,360
given 2i plus 1 or given 2i plus 2.
 

1181
00:23:29,360 --> 00:23:32,710
given 2i plus 1 or given 2i plus 2.
and so um

1182
00:23:32,710 --> 00:23:32,720
and so um
 

1183
00:23:32,720 --> 00:23:35,750
and so um
if i subtract 1 from i

1184
00:23:35,750 --> 00:23:35,760
if i subtract 1 from i
 

1185
00:23:35,760 --> 00:23:38,230
if i subtract 1 from i
then i either get 2i or 2i plus 1 and

1186
00:23:38,230 --> 00:23:38,240
then i either get 2i or 2i plus 1 and
 

1187
00:23:38,240 --> 00:23:40,950
then i either get 2i or 2i plus 1 and
then if i take an integer division by 2

1188
00:23:40,950 --> 00:23:40,960
then if i take an integer division by 2
 

1189
00:23:40,960 --> 00:23:44,149
then if i take an integer division by 2
i get i the original i sorry maybe i'll

1190
00:23:44,149 --> 00:23:44,159
i get i the original i sorry maybe i'll
 

1191
00:23:44,159 --> 00:23:44,950
i get i the original i sorry maybe i'll
call this j

1192
00:23:44,950 --> 00:23:44,960
call this j
 

1193
00:23:44,960 --> 00:23:48,390
call this j
to be clearer so j is the left or right

1194
00:23:48,390 --> 00:23:48,400
to be clearer so j is the left or right
 

1195
00:23:48,400 --> 00:23:49,350
to be clearer so j is the left or right
child

1196
00:23:49,350 --> 00:23:49,360
child
 

1197
00:23:49,360 --> 00:23:51,430
child
then i can reconstruct i which was the

1198
00:23:51,430 --> 00:23:51,440
then i can reconstruct i which was the
 

1199
00:23:51,440 --> 00:23:52,789
then i can reconstruct i which was the
parent

1200
00:23:52,789 --> 00:23:52,799
parent
 

1201
00:23:52,799 --> 00:23:54,950
parent
okay so this is you know constant number

1202
00:23:54,950 --> 00:23:54,960
okay so this is you know constant number
 

1203
00:23:54,960 --> 00:23:56,870
okay so this is you know constant number
arithmetic operations so i don't have to

1204
00:23:56,870 --> 00:23:56,880
arithmetic operations so i don't have to
 

1205
00:23:56,880 --> 00:23:57,669
arithmetic operations so i don't have to
store

1206
00:23:57,669 --> 00:23:57,679
store
 

1207
00:23:57,679 --> 00:23:58,870
store
left and right pointers i can just

1208
00:23:58,870 --> 00:23:58,880
left and right pointers i can just
 

1209
00:23:58,880 --> 00:24:00,230
left and right pointers i can just
compute them whenever i need them

1210
00:24:00,230 --> 00:24:00,240
compute them whenever i need them
 

1211
00:24:00,240 --> 00:24:03,029
compute them whenever i need them
whenever i'm at some node like e

1212
00:24:03,029 --> 00:24:03,039
whenever i'm at some node like e
 

1213
00:24:03,039 --> 00:24:04,870
whenever i'm at some node like e
and i want to know what's its left child

1214
00:24:04,870 --> 00:24:04,880
and i want to know what's its left child
 

1215
00:24:04,880 --> 00:24:06,070
and i want to know what's its left child
if sorry i

1216
00:24:06,070 --> 00:24:06,080
if sorry i
 

1217
00:24:06,080 --> 00:24:08,870
if sorry i
given the node index 4 which happens to

1218
00:24:08,870 --> 00:24:08,880
given the node index 4 which happens to
 

1219
00:24:08,880 --> 00:24:09,669
given the node index 4 which happens to
contain

1220
00:24:09,669 --> 00:24:09,679
contain
 

1221
00:24:09,679 --> 00:24:11,830
contain
the item e and i want to know what's

1222
00:24:11,830 --> 00:24:11,840
the item e and i want to know what's
 

1223
00:24:11,840 --> 00:24:13,430
the item e and i want to know what's
this left child i just multiply by 2 and

1224
00:24:13,430 --> 00:24:13,440
this left child i just multiply by 2 and
 

1225
00:24:13,440 --> 00:24:14,710
this left child i just multiply by 2 and
add 1 i get 9.

1226
00:24:14,710 --> 00:24:14,720
add 1 i get 9.
 

1227
00:24:14,720 --> 00:24:16,470
add 1 i get 9.
and then i can index into this array at

1228
00:24:16,470 --> 00:24:16,480
and then i can index into this array at
 

1229
00:24:16,480 --> 00:24:17,990
and then i can index into this array at
position nine because i don't this

1230
00:24:17,990 --> 00:24:18,000
position nine because i don't this
 

1231
00:24:18,000 --> 00:24:20,470
position nine because i don't this
is just in my head remember uh this is

1232
00:24:20,470 --> 00:24:20,480
is just in my head remember uh this is
 

1233
00:24:20,480 --> 00:24:21,909
is just in my head remember uh this is
we're just thinking that there's a tree

1234
00:24:21,909 --> 00:24:21,919
we're just thinking that there's a tree
 

1235
00:24:21,919 --> 00:24:22,549
we're just thinking that there's a tree
here

1236
00:24:22,549 --> 00:24:22,559
here
 

1237
00:24:22,559 --> 00:24:24,470
here
but in reality on the computer there's

1238
00:24:24,470 --> 00:24:24,480
but in reality on the computer there's
 

1239
00:24:24,480 --> 00:24:26,149
but in reality on the computer there's
just the array

1240
00:24:26,149 --> 00:24:26,159
just the array
 

1241
00:24:26,159 --> 00:24:28,950
just the array
so if we wanna go from e to j we can

1242
00:24:28,950 --> 00:24:28,960
so if we wanna go from e to j we can
 

1243
00:24:28,960 --> 00:24:30,149
so if we wanna go from e to j we can
from four to nine

1244
00:24:30,149 --> 00:24:30,159
from four to nine
 

1245
00:24:30,159 --> 00:24:32,230
from four to nine
uh if we go try to go to the right child

1246
00:24:32,230 --> 00:24:32,240
uh if we go try to go to the right child
 

1247
00:24:32,240 --> 00:24:33,510
uh if we go try to go to the right child
we multiply by 2

1248
00:24:33,510 --> 00:24:33,520
we multiply by 2
 

1249
00:24:33,520 --> 00:24:36,710
we multiply by 2
8 add 2 10 and we see oh 10 is beyond

1250
00:24:36,710 --> 00:24:36,720
8 add 2 10 and we see oh 10 is beyond
 

1251
00:24:36,720 --> 00:24:37,669
8 add 2 10 and we see oh 10 is beyond
the end of the array

1252
00:24:37,669 --> 00:24:37,679
the end of the array
 

1253
00:24:37,679 --> 00:24:39,430
the end of the array
but our race stores its size so we

1254
00:24:39,430 --> 00:24:39,440
but our race stores its size so we
 

1255
00:24:39,440 --> 00:24:41,909
but our race stores its size so we
realize oh e does not have a right child

1256
00:24:41,909 --> 00:24:41,919
realize oh e does not have a right child
 

1257
00:24:41,919 --> 00:24:43,590
realize oh e does not have a right child
this is something you can only do in a

1258
00:24:43,590 --> 00:24:43,600
this is something you can only do in a
 

1259
00:24:43,600 --> 00:24:45,830
this is something you can only do in a
complete binary tree in a general binary

1260
00:24:45,830 --> 00:24:45,840
complete binary tree in a general binary
 

1261
00:24:45,840 --> 00:24:46,950
complete binary tree in a general binary
tree you don't have these nice

1262
00:24:46,950 --> 00:24:46,960
tree you don't have these nice
 

1263
00:24:46,960 --> 00:24:49,669
tree you don't have these nice
properties

1264
00:24:49,669 --> 00:24:49,679

 

1265
00:24:49,679 --> 00:24:53,269

cool so this is basically

1266
00:24:53,269 --> 00:24:53,279
cool so this is basically
 

1267
00:24:53,279 --> 00:24:55,350
cool so this is basically
a heap i just need to add one more

1268
00:24:55,350 --> 00:24:55,360
a heap i just need to add one more
 

1269
00:24:55,360 --> 00:24:58,310
a heap i just need to add one more
property

1270
00:24:58,310 --> 00:24:58,320

 

1271
00:24:58,320 --> 00:25:04,789

naturally called the heap property

1272
00:25:04,789 --> 00:25:04,799

 

1273
00:25:04,799 --> 00:25:08,070

so uh there are

1274
00:25:08,070 --> 00:25:08,080
so uh there are
 

1275
00:25:08,080 --> 00:25:10,149
so uh there are
multiple types of heaps this type of

1276
00:25:10,149 --> 00:25:10,159
multiple types of heaps this type of
 

1277
00:25:10,159 --> 00:25:11,669
multiple types of heaps this type of
heap is called a binary heap

1278
00:25:11,669 --> 00:25:11,679
heap is called a binary heap
 

1279
00:25:11,679 --> 00:25:13,269
heap is called a binary heap
we will talk about others in future

1280
00:25:13,269 --> 00:25:13,279
we will talk about others in future
 

1281
00:25:13,279 --> 00:25:15,350
we will talk about others in future
lectures i'm going to call it

1282
00:25:15,350 --> 00:25:15,360
lectures i'm going to call it
 

1283
00:25:15,360 --> 00:25:21,190
lectures i'm going to call it
q

1284
00:25:21,190 --> 00:25:21,200

 

1285
00:25:21,200 --> 00:25:27,430

i should write

1286
00:25:27,430 --> 00:25:27,440

 

1287
00:25:27,440 --> 00:25:30,549

explicit thing this is an array

1288
00:25:30,549 --> 00:25:30,559
explicit thing this is an array
 

1289
00:25:30,559 --> 00:25:48,230
explicit thing this is an array
representing a complete binary tree

1290
00:25:48,230 --> 00:25:48,240

 

1291
00:25:48,240 --> 00:25:51,909

call the array q and we want

1292
00:25:51,909 --> 00:25:51,919
call the array q and we want
 

1293
00:25:51,919 --> 00:25:56,789
call the array q and we want
every node

1294
00:25:56,789 --> 00:25:56,799
every node
 

1295
00:25:56,799 --> 00:26:02,230
every node
to satisfy

1296
00:26:02,230 --> 00:26:02,240

 

1297
00:26:02,240 --> 00:26:16,710

the so-called max heap property

1298
00:26:16,710 --> 00:26:16,720

 

1299
00:26:16,720 --> 00:26:20,070

which says q of i

1300
00:26:20,070 --> 00:26:20,080
which says q of i
 

1301
00:26:20,080 --> 00:26:24,230
which says q of i
is greater than or equal to q of j

1302
00:26:24,230 --> 00:26:24,240
is greater than or equal to q of j
 

1303
00:26:24,240 --> 00:26:28,710
is greater than or equal to q of j
for both children left of eye

1304
00:26:28,710 --> 00:26:28,720
for both children left of eye
 

1305
00:26:28,720 --> 00:26:36,710
for both children left of eye
and right of eye

1306
00:26:36,710 --> 00:26:36,720

 

1307
00:26:36,720 --> 00:26:40,470

okay so um we have a node

1308
00:26:40,470 --> 00:26:40,480
okay so um we have a node
 

1309
00:26:40,480 --> 00:26:44,630
okay so um we have a node
i and has two children

1310
00:26:44,630 --> 00:26:44,640
i and has two children
 

1311
00:26:44,640 --> 00:26:48,149
i and has two children
two i plus one and two i plus two

1312
00:26:48,149 --> 00:26:48,159
two i plus one and two i plus two
 

1313
00:26:48,159 --> 00:26:53,190
two i plus one and two i plus two
these are our two values of j

1314
00:26:53,190 --> 00:26:53,200
these are our two values of j
 

1315
00:26:53,200 --> 00:26:56,070
these are our two values of j
what we want is a greater than or equal

1316
00:26:56,070 --> 00:26:56,080
what we want is a greater than or equal
 

1317
00:26:56,080 --> 00:26:56,630
what we want is a greater than or equal
to up

1318
00:26:56,630 --> 00:26:56,640
to up
 

1319
00:26:56,640 --> 00:26:59,669
to up
uh relation here and here

1320
00:26:59,669 --> 00:26:59,679
uh relation here and here
 

1321
00:26:59,679 --> 00:27:01,190
uh relation here and here
okay so this node should be bigger than

1322
00:27:01,190 --> 00:27:01,200
okay so this node should be bigger than
 

1323
00:27:01,200 --> 00:27:02,710
okay so this node should be bigger than
both this one and this one which of

1324
00:27:02,710 --> 00:27:02,720
both this one and this one which of
 

1325
00:27:02,720 --> 00:27:03,750
both this one and this one which of
these is larger

1326
00:27:03,750 --> 00:27:03,760
these is larger
 

1327
00:27:03,760 --> 00:27:06,470
these is larger
we don't know and we don't care very

1328
00:27:06,470 --> 00:27:06,480
we don't know and we don't care very
 

1329
00:27:06,480 --> 00:27:07,350
we don't know and we don't care very
different from

1330
00:27:07,350 --> 00:27:07,360
different from
 

1331
00:27:07,360 --> 00:27:09,669
different from
binary search trees or set binary trees

1332
00:27:09,669 --> 00:27:09,679
binary search trees or set binary trees
 

1333
00:27:09,679 --> 00:27:10,549
binary search trees or set binary trees
where we said

1334
00:27:10,549 --> 00:27:10,559
where we said
 

1335
00:27:10,559 --> 00:27:12,070
where we said
these guys were less than equal to this

1336
00:27:12,070 --> 00:27:12,080
these guys were less than equal to this
 

1337
00:27:12,080 --> 00:27:14,070
these guys were less than equal to this
this one this one was less than equal to

1338
00:27:14,070 --> 00:27:14,080
this one this one was less than equal to
 

1339
00:27:14,080 --> 00:27:15,510
this one this one was less than equal to
all the nodes in the sum tree here we're

1340
00:27:15,510 --> 00:27:15,520
all the nodes in the sum tree here we're
 

1341
00:27:15,520 --> 00:27:16,630
all the nodes in the sum tree here we're
just locally saying

1342
00:27:16,630 --> 00:27:16,640
just locally saying
 

1343
00:27:16,640 --> 00:27:17,990
just locally saying
this node is greater than or equal to

1344
00:27:17,990 --> 00:27:18,000
this node is greater than or equal to
 

1345
00:27:18,000 --> 00:27:20,549
this node is greater than or equal to
this node and this node so this is the

1346
00:27:20,549 --> 00:27:20,559
this node and this node so this is the
 

1347
00:27:20,559 --> 00:27:24,149
this node and this node so this is the
biggest is at the top

1348
00:27:24,149 --> 00:27:24,159

 

1349
00:27:24,159 --> 00:27:28,149

okay so one nice

1350
00:27:28,149 --> 00:27:28,159
okay so one nice
 

1351
00:27:28,159 --> 00:27:32,269
okay so one nice
lemma about these heaps this is

1352
00:27:32,269 --> 00:27:32,279
lemma about these heaps this is
 

1353
00:27:32,279 --> 00:27:34,789
lemma about these heaps this is
weird let me give you some more

1354
00:27:34,789 --> 00:27:34,799
weird let me give you some more
 

1355
00:27:34,799 --> 00:27:36,549
weird let me give you some more
intuition

1356
00:27:36,549 --> 00:27:36,559
intuition
 

1357
00:27:36,559 --> 00:27:38,549
intuition
if you are a binary heap if you satisfy

1358
00:27:38,549 --> 00:27:38,559
if you are a binary heap if you satisfy
 

1359
00:27:38,559 --> 00:27:40,470
if you are a binary heap if you satisfy
this max heap property everywhere

1360
00:27:40,470 --> 00:27:40,480
this max heap property everywhere
 

1361
00:27:40,480 --> 00:27:44,710
this max heap property everywhere
then in fact you learn that every node i

1362
00:27:44,710 --> 00:27:44,720
then in fact you learn that every node i
 

1363
00:27:44,720 --> 00:27:47,510
then in fact you learn that every node i
is greater than or equal to all nodes in

1364
00:27:47,510 --> 00:27:47,520
is greater than or equal to all nodes in
 

1365
00:27:47,520 --> 00:27:49,190
is greater than or equal to all nodes in
its subtree these are what we call

1366
00:27:49,190 --> 00:27:49,200
its subtree these are what we call
 

1367
00:27:49,200 --> 00:27:53,830
its subtree these are what we call
descendants

1368
00:27:53,830 --> 00:27:53,840

 

1369
00:27:53,840 --> 00:27:59,830

and subtree of i

1370
00:27:59,830 --> 00:27:59,840

 

1371
00:27:59,840 --> 00:28:03,110

okay let me look at this example

1372
00:28:03,110 --> 00:28:03,120
okay let me look at this example
 

1373
00:28:03,120 --> 00:28:04,710
okay let me look at this example
so i haven't written any numbers here

1374
00:28:04,710 --> 00:28:04,720
so i haven't written any numbers here
 

1375
00:28:04,720 --> 00:28:06,470
so i haven't written any numbers here
but you can imagine

1376
00:28:06,470 --> 00:28:06,480
but you can imagine
 

1377
00:28:06,480 --> 00:28:09,190
but you can imagine
so a here is greater than or equal to

1378
00:28:09,190 --> 00:28:09,200
so a here is greater than or equal to
 

1379
00:28:09,200 --> 00:28:09,669
so a here is greater than or equal to
both b

1380
00:28:09,669 --> 00:28:09,679
both b
 

1381
00:28:09,679 --> 00:28:12,070
both b
and c and b is greater than equal to d

1382
00:28:12,070 --> 00:28:12,080
and c and b is greater than equal to d
 

1383
00:28:12,080 --> 00:28:12,789
and c and b is greater than equal to d
and e

1384
00:28:12,789 --> 00:28:12,799
and e
 

1385
00:28:12,799 --> 00:28:14,230
and e
and c is greater than or equal to f and

1386
00:28:14,230 --> 00:28:14,240
and c is greater than or equal to f and
 

1387
00:28:14,240 --> 00:28:16,149
and c is greater than or equal to f and
g and d is greater than equal to h and i

1388
00:28:16,149 --> 00:28:16,159
g and d is greater than equal to h and i
 

1389
00:28:16,159 --> 00:28:17,510
g and d is greater than equal to h and i
and e is greater than equal to j

1390
00:28:17,510 --> 00:28:17,520
and e is greater than equal to j
 

1391
00:28:17,520 --> 00:28:19,909
and e is greater than equal to j
that would make this structure a heap

1392
00:28:19,909 --> 00:28:19,919
that would make this structure a heap
 

1393
00:28:19,919 --> 00:28:23,430
that would make this structure a heap
not just a complete binary tree

1394
00:28:23,430 --> 00:28:23,440

 

1395
00:28:23,440 --> 00:28:25,269

so what does that imply it implies that

1396
00:28:25,269 --> 00:28:25,279
so what does that imply it implies that
 

1397
00:28:25,279 --> 00:28:27,029
so what does that imply it implies that
a must be the maximum

1398
00:28:27,029 --> 00:28:27,039
a must be the maximum
 

1399
00:28:27,039 --> 00:28:30,149
a must be the maximum
so you look at any node here like j a is

1400
00:28:30,149 --> 00:28:30,159
so you look at any node here like j a is
 

1401
00:28:30,159 --> 00:28:31,029
so you look at any node here like j a is
greater than or equal to b

1402
00:28:31,029 --> 00:28:31,039
greater than or equal to b
 

1403
00:28:31,039 --> 00:28:32,470
greater than or equal to b
is greater than or equal to e is greater

1404
00:28:32,470 --> 00:28:32,480
is greater than or equal to e is greater
 

1405
00:28:32,480 --> 00:28:34,310
is greater than or equal to e is greater
than or equal to j

1406
00:28:34,310 --> 00:28:34,320
than or equal to j
 

1407
00:28:34,320 --> 00:28:36,230
than or equal to j
and in general what we're saying is that

1408
00:28:36,230 --> 00:28:36,240
and in general what we're saying is that
 

1409
00:28:36,240 --> 00:28:37,510
and in general what we're saying is that
a is greater equal to

1410
00:28:37,510 --> 00:28:37,520
a is greater equal to
 

1411
00:28:37,520 --> 00:28:39,190
a is greater equal to
all nodes in the tree b is greater than

1412
00:28:39,190 --> 00:28:39,200
all nodes in the tree b is greater than
 

1413
00:28:39,200 --> 00:28:41,110
all nodes in the tree b is greater than
or equal to all nodes in its sub tree

1414
00:28:41,110 --> 00:28:41,120
or equal to all nodes in its sub tree
 

1415
00:28:41,120 --> 00:28:42,230
or equal to all nodes in its sub tree
down here

1416
00:28:42,230 --> 00:28:42,240
down here
 

1417
00:28:42,240 --> 00:28:43,510
down here
c is greater than or equal to all nodes

1418
00:28:43,510 --> 00:28:43,520
c is greater than or equal to all nodes
 

1419
00:28:43,520 --> 00:28:45,750
c is greater than or equal to all nodes
in its subtree that's what this lemma is

1420
00:28:45,750 --> 00:28:45,760
in its subtree that's what this lemma is
 

1421
00:28:45,760 --> 00:28:47,110
in its subtree that's what this lemma is
saying

1422
00:28:47,110 --> 00:28:47,120
saying
 

1423
00:28:47,120 --> 00:28:50,710
saying
you can prove this lemma by induction uh

1424
00:28:50,710 --> 00:28:50,720
you can prove this lemma by induction uh
 

1425
00:28:50,720 --> 00:28:55,190
you can prove this lemma by induction uh
but it's really simple

1426
00:28:55,190 --> 00:28:55,200

 

1427
00:28:55,200 --> 00:28:57,269

if you have two nodes i and j and j is

1428
00:28:57,269 --> 00:28:57,279
if you have two nodes i and j and j is
 

1429
00:28:57,279 --> 00:28:58,630
if you have two nodes i and j and j is
somewhere in the sub tree

1430
00:28:58,630 --> 00:28:58,640
somewhere in the sub tree
 

1431
00:28:58,640 --> 00:29:01,510
somewhere in the sub tree
that means there's some downward path

1432
00:29:01,510 --> 00:29:01,520
that means there's some downward path
 

1433
00:29:01,520 --> 00:29:01,909
that means there's some downward path
from

1434
00:29:01,909 --> 00:29:01,919
from
 

1435
00:29:01,919 --> 00:29:05,350
from
i to j and you know that for every edge

1436
00:29:05,350 --> 00:29:05,360
i to j and you know that for every edge
 

1437
00:29:05,360 --> 00:29:07,430
i to j and you know that for every edge
we traverse on a downward path

1438
00:29:07,430 --> 00:29:07,440
we traverse on a downward path
 

1439
00:29:07,440 --> 00:29:10,389
we traverse on a downward path
our key is going down non-strictly

1440
00:29:10,389 --> 00:29:10,399
our key is going down non-strictly
 

1441
00:29:10,399 --> 00:29:11,990
our key is going down non-strictly
because every child is less than equal

1442
00:29:11,990 --> 00:29:12,000
because every child is less than equal
 

1443
00:29:12,000 --> 00:29:13,669
because every child is less than equal
to its parent i is greater than or equal

1444
00:29:13,669 --> 00:29:13,679
to its parent i is greater than or equal
 

1445
00:29:13,679 --> 00:29:14,870
to its parent i is greater than or equal
to this is greater than equal to this is

1446
00:29:14,870 --> 00:29:14,880
to this is greater than equal to this is
 

1447
00:29:14,880 --> 00:29:15,830
to this is greater than equal to this is
greater equal this is greater than or

1448
00:29:15,830 --> 00:29:15,840
greater equal this is greater than or
 

1449
00:29:15,840 --> 00:29:17,430
greater equal this is greater than or
equal to j

1450
00:29:17,430 --> 00:29:17,440
equal to j
 

1451
00:29:17,440 --> 00:29:20,710
equal to j
okay so by uh transitivity of less than

1452
00:29:20,710 --> 00:29:20,720
okay so by uh transitivity of less than
 

1453
00:29:20,720 --> 00:29:21,669
okay so by uh transitivity of less than
or equal to

1454
00:29:21,669 --> 00:29:21,679
or equal to
 

1455
00:29:21,679 --> 00:29:23,590
or equal to
you know that i is in fact greater than

1456
00:29:23,590 --> 00:29:23,600
you know that i is in fact greater than
 

1457
00:29:23,600 --> 00:29:25,510
you know that i is in fact greater than
equal to j or sorry the key

1458
00:29:25,510 --> 00:29:25,520
equal to j or sorry the key
 

1459
00:29:25,520 --> 00:29:27,830
equal to j or sorry the key
in i is greater than or equal to the key

1460
00:29:27,830 --> 00:29:27,840
in i is greater than or equal to the key
 

1461
00:29:27,840 --> 00:29:28,789
in i is greater than or equal to the key
in j

1462
00:29:28,789 --> 00:29:28,799
in j
 

1463
00:29:28,799 --> 00:29:30,710
in j
this is what we're calling i the index

1464
00:29:30,710 --> 00:29:30,720
this is what we're calling i the index
 

1465
00:29:30,720 --> 00:29:32,549
this is what we're calling i the index
this is what we call q

1466
00:29:32,549 --> 00:29:32,559
this is what we call q
 

1467
00:29:32,559 --> 00:29:36,149
this is what we call q
of i this is index j

1468
00:29:36,149 --> 00:29:36,159
of i this is index j
 

1469
00:29:36,159 --> 00:29:39,510
of i this is index j
q of j

1470
00:29:39,510 --> 00:29:39,520

 

1471
00:29:39,520 --> 00:29:43,430

okay very different way to organize um

1472
00:29:43,430 --> 00:29:43,440
okay very different way to organize um
 

1473
00:29:43,440 --> 00:29:46,549
okay very different way to organize um
keys in a tree

1474
00:29:46,549 --> 00:29:46,559
keys in a tree
 

1475
00:29:46,559 --> 00:29:49,190
keys in a tree
but as you might imagine this is going

1476
00:29:49,190 --> 00:29:49,200
but as you might imagine this is going
 

1477
00:29:49,200 --> 00:29:50,710
but as you might imagine this is going
to be good for priority queues because

1478
00:29:50,710 --> 00:29:50,720
to be good for priority queues because
 

1479
00:29:50,720 --> 00:29:52,549
to be good for priority queues because
priority queues just need to find the

1480
00:29:52,549 --> 00:29:52,559
priority queues just need to find the
 

1481
00:29:52,559 --> 00:29:54,310
priority queues just need to find the
maximum element

1482
00:29:54,310 --> 00:29:54,320
maximum element
 

1483
00:29:54,320 --> 00:29:55,909
maximum element
okay then they need to delete it that's

1484
00:29:55,909 --> 00:29:55,919
okay then they need to delete it that's
 

1485
00:29:55,919 --> 00:29:57,110
okay then they need to delete it that's
going to be harder because deleting the

1486
00:29:57,110 --> 00:29:57,120
going to be harder because deleting the
 

1487
00:29:57,120 --> 00:29:59,110
going to be harder because deleting the
root is like that's the hardest node to

1488
00:29:59,110 --> 00:29:59,120
root is like that's the hardest node to
 

1489
00:29:59,120 --> 00:30:00,789
root is like that's the hardest node to
delete intuitively

1490
00:30:00,789 --> 00:30:00,799
delete intuitively
 

1491
00:30:00,799 --> 00:30:03,430
delete intuitively
i'd really prefer to delete leaves but

1492
00:30:03,430 --> 00:30:03,440
i'd really prefer to delete leaves but
 

1493
00:30:03,440 --> 00:30:05,190
i'd really prefer to delete leaves but
deleting leaves

1494
00:30:05,190 --> 00:30:05,200
deleting leaves
 

1495
00:30:05,200 --> 00:30:06,950
deleting leaves
and keeping a complete binary tree is

1496
00:30:06,950 --> 00:30:06,960
and keeping a complete binary tree is
 

1497
00:30:06,960 --> 00:30:08,310
and keeping a complete binary tree is
actually kind of hard right

1498
00:30:08,310 --> 00:30:08,320
actually kind of hard right
 

1499
00:30:08,320 --> 00:30:10,870
actually kind of hard right
if i want to delete h that doesn't look

1500
00:30:10,870 --> 00:30:10,880
if i want to delete h that doesn't look
 

1501
00:30:10,880 --> 00:30:12,149
if i want to delete h that doesn't look
like a binary tree

1502
00:30:12,149 --> 00:30:12,159
like a binary tree
 

1503
00:30:12,159 --> 00:30:13,269
like a binary tree
or it doesn't look like a complete

1504
00:30:13,269 --> 00:30:13,279
or it doesn't look like a complete
 

1505
00:30:13,279 --> 00:30:14,549
or it doesn't look like a complete
binary tree anymore it's not left

1506
00:30:14,549 --> 00:30:14,559
binary tree anymore it's not left
 

1507
00:30:14,559 --> 00:30:16,389
binary tree anymore it's not left
justified

1508
00:30:16,389 --> 00:30:16,399
justified
 

1509
00:30:16,399 --> 00:30:17,990
justified
similarly if i want to delete f that's

1510
00:30:17,990 --> 00:30:18,000
similarly if i want to delete f that's
 

1511
00:30:18,000 --> 00:30:20,149
similarly if i want to delete f that's
bad because now i don't have four

1512
00:30:20,149 --> 00:30:20,159
bad because now i don't have four
 

1513
00:30:20,159 --> 00:30:21,830
bad because now i don't have four
nodes here the one node that's easy to

1514
00:30:21,830 --> 00:30:21,840
nodes here the one node that's easy to
 

1515
00:30:21,840 --> 00:30:24,470
nodes here the one node that's easy to
delete is j

1516
00:30:24,470 --> 00:30:24,480
delete is j
 

1517
00:30:24,480 --> 00:30:26,070
delete is j
right if i remove that node i still have

1518
00:30:26,070 --> 00:30:26,080
right if i remove that node i still have
 

1519
00:30:26,080 --> 00:30:28,870
right if i remove that node i still have
a complete tree the last leaf

1520
00:30:28,870 --> 00:30:28,880
a complete tree the last leaf
 

1521
00:30:28,880 --> 00:30:31,990
a complete tree the last leaf
the last position in my array is the one

1522
00:30:31,990 --> 00:30:32,000
the last position in my array is the one
 

1523
00:30:32,000 --> 00:30:33,029
the last position in my array is the one
that's easy to delete

1524
00:30:33,029 --> 00:30:33,039
that's easy to delete
 

1525
00:30:33,039 --> 00:30:34,470
that's easy to delete
that's good because arrays are good at

1526
00:30:34,470 --> 00:30:34,480
that's good because arrays are good at
 

1527
00:30:34,480 --> 00:30:36,230
that's good because arrays are good at
deleting the last item

1528
00:30:36,230 --> 00:30:36,240
deleting the last item
 

1529
00:30:36,240 --> 00:30:38,630
deleting the last item
but what i've set up here is it's easy

1530
00:30:38,630 --> 00:30:38,640
but what i've set up here is it's easy
 

1531
00:30:38,640 --> 00:30:40,549
but what i've set up here is it's easy
to find the max it's going to be up here

1532
00:30:40,549 --> 00:30:40,559
to find the max it's going to be up here
 

1533
00:30:40,559 --> 00:30:41,510
to find the max it's going to be up here
at the root

1534
00:30:41,510 --> 00:30:41,520
at the root
 

1535
00:30:41,520 --> 00:30:43,990
at the root
deleting it is annoying i'd like to

1536
00:30:43,990 --> 00:30:44,000
deleting it is annoying i'd like to
 

1537
00:30:44,000 --> 00:30:45,750
deleting it is annoying i'd like to
somehow take that key

1538
00:30:45,750 --> 00:30:45,760
somehow take that key
 

1539
00:30:45,760 --> 00:30:48,710
somehow take that key
and put it at position at the last

1540
00:30:48,710 --> 00:30:48,720
and put it at position at the last
 

1541
00:30:48,720 --> 00:30:50,389
and put it at position at the last
position at the last leaf

1542
00:30:50,389 --> 00:30:50,399
position at the last leaf
 

1543
00:30:50,399 --> 00:30:51,750
position at the last leaf
because that's the one that's easy to

1544
00:30:51,750 --> 00:30:51,760
because that's the one that's easy to
 

1545
00:30:51,760 --> 00:30:53,430
because that's the one that's easy to
delete

1546
00:30:53,430 --> 00:30:53,440
delete
 

1547
00:30:53,440 --> 00:30:54,950
delete
okay and that's indeed what we're going

1548
00:30:54,950 --> 00:30:54,960
okay and that's indeed what we're going
 

1549
00:30:54,960 --> 00:30:57,269
okay and that's indeed what we're going
to do do in a delete

1550
00:30:57,269 --> 00:30:57,279
to do do in a delete
 

1551
00:30:57,279 --> 00:30:59,509
to do do in a delete
algorithm uh let me first do insert i

1552
00:30:59,509 --> 00:30:59,519
algorithm uh let me first do insert i
 

1553
00:30:59,519 --> 00:31:05,430
algorithm uh let me first do insert i
guess that's a little simpler

1554
00:31:05,430 --> 00:31:05,440
guess that's a little simpler
 

1555
00:31:05,440 --> 00:31:07,080
guess that's a little simpler
kind of symmetric

1556
00:31:07,080 --> 00:31:07,090
kind of symmetric
 

1557
00:31:07,090 --> 00:31:09,750
kind of symmetric
[Applause]

1558
00:31:09,750 --> 00:31:09,760
[Applause]
 

1559
00:31:09,760 --> 00:31:11,830
[Applause]
to what we just said so if i want to

1560
00:31:11,830 --> 00:31:11,840
to what we just said so if i want to
 

1561
00:31:11,840 --> 00:31:13,509
to what we just said so if i want to
insert a key

1562
00:31:13,509 --> 00:31:13,519
insert a key
 

1563
00:31:13,519 --> 00:31:16,549
insert a key
or an item x which has some key

1564
00:31:16,549 --> 00:31:16,559
or an item x which has some key
 

1565
00:31:16,559 --> 00:31:19,990
or an item x which has some key
uh again the only thing i really can do

1566
00:31:19,990 --> 00:31:20,000
uh again the only thing i really can do
 

1567
00:31:20,000 --> 00:31:22,149
uh again the only thing i really can do
in an array if i want to add a new item

1568
00:31:22,149 --> 00:31:22,159
in an array if i want to add a new item
 

1569
00:31:22,159 --> 00:31:23,430
in an array if i want to add a new item
it has to go at the end

1570
00:31:23,430 --> 00:31:23,440
it has to go at the end
 

1571
00:31:23,440 --> 00:31:24,870
it has to go at the end
the only thing we know how to do is

1572
00:31:24,870 --> 00:31:24,880
the only thing we know how to do is
 

1573
00:31:24,880 --> 00:31:26,630
the only thing we know how to do is
insert at the end of an array this is

1574
00:31:26,630 --> 00:31:26,640
insert at the end of an array this is
 

1575
00:31:26,640 --> 00:31:33,909
insert at the end of an array this is
what we called insert last

1576
00:31:33,909 --> 00:31:33,919

 

1577
00:31:33,919 --> 00:31:37,190

this corresponds to adding no a node

1578
00:31:37,190 --> 00:31:37,200
this corresponds to adding no a node
 

1579
00:31:37,200 --> 00:31:37,830
this corresponds to adding no a node
containing

1580
00:31:37,830 --> 00:31:37,840
containing
 

1581
00:31:37,840 --> 00:31:41,029
containing
x the item x at the

1582
00:31:41,029 --> 00:31:41,039
x the item x at the
 

1583
00:31:41,039 --> 00:31:43,669
x the item x at the
in the very last level of the binary

1584
00:31:43,669 --> 00:31:43,679
in the very last level of the binary
 

1585
00:31:43,679 --> 00:31:44,789
in the very last level of the binary
complete binary tree

1586
00:31:44,789 --> 00:31:44,799
complete binary tree
 

1587
00:31:44,799 --> 00:31:46,070
complete binary tree
either it goes to the right of all the

1588
00:31:46,070 --> 00:31:46,080
either it goes to the right of all the
 

1589
00:31:46,080 --> 00:31:47,990
either it goes to the right of all the
existing nodes or it starts a new level

1590
00:31:47,990 --> 00:31:48,000
existing nodes or it starts a new level
 

1591
00:31:48,000 --> 00:31:49,350
existing nodes or it starts a new level
but it's always going to be the last

1592
00:31:49,350 --> 00:31:49,360
but it's always going to be the last
 

1593
00:31:49,360 --> 00:31:51,509
but it's always going to be the last
leaf after we do the insertion it will

1594
00:31:51,509 --> 00:31:51,519
leaf after we do the insertion it will
 

1595
00:31:51,519 --> 00:31:52,710
leaf after we do the insertion it will
be at position

1596
00:31:52,710 --> 00:31:52,720
be at position
 

1597
00:31:52,720 --> 00:31:57,029
be at position
size of q minus one

1598
00:31:57,029 --> 00:31:57,039

 

1599
00:31:57,039 --> 00:31:59,669

okay this is probably not enough though

1600
00:31:59,669 --> 00:31:59,679
okay this is probably not enough though
 

1601
00:31:59,679 --> 00:32:01,430
okay this is probably not enough though
we just insert an arbitrary item in a

1602
00:32:01,430 --> 00:32:01,440
we just insert an arbitrary item in a
 

1603
00:32:01,440 --> 00:32:03,190
we just insert an arbitrary item in a
leaf and now it may not satisfy the max

1604
00:32:03,190 --> 00:32:03,200
leaf and now it may not satisfy the max
 

1605
00:32:03,200 --> 00:32:04,630
leaf and now it may not satisfy the max
heap property anymore

1606
00:32:04,630 --> 00:32:04,640
heap property anymore
 

1607
00:32:04,640 --> 00:32:06,630
heap property anymore
so let's just check if it does and if it

1608
00:32:06,630 --> 00:32:06,640
so let's just check if it does and if it
 

1609
00:32:06,640 --> 00:32:07,909
so let's just check if it does and if it
doesn't fix it

1610
00:32:07,909 --> 00:32:07,919
doesn't fix it
 

1611
00:32:07,919 --> 00:32:10,630
doesn't fix it
that's what we know how to do but this

1612
00:32:10,630 --> 00:32:10,640
that's what we know how to do but this
 

1613
00:32:10,640 --> 00:32:11,269
that's what we know how to do but this
time

1614
00:32:11,269 --> 00:32:11,279
time
 

1615
00:32:11,279 --> 00:32:20,149
time
we're not even going to need

1616
00:32:20,149 --> 00:32:20,159

 

1617
00:32:20,159 --> 00:32:21,669

we're not even going to need rotations

1618
00:32:21,669 --> 00:32:21,679
we're not even going to need rotations
 

1619
00:32:21,679 --> 00:32:23,990
we're not even going to need rotations
which is cool

1620
00:32:23,990 --> 00:32:24,000
which is cool
 

1621
00:32:24,000 --> 00:32:25,350
which is cool
so i'm going to define an operation

1622
00:32:25,350 --> 00:32:25,360
so i'm going to define an operation
 

1623
00:32:25,360 --> 00:32:29,029
so i'm going to define an operation
called max heapify up

1624
00:32:29,029 --> 00:32:29,039
called max heapify up
 

1625
00:32:29,039 --> 00:32:30,789
called max heapify up
this will make things more like a max

1626
00:32:30,789 --> 00:32:30,799
this will make things more like a max
 

1627
00:32:30,799 --> 00:32:32,950
this will make things more like a max
heap

1628
00:32:32,950 --> 00:32:32,960
heap
 

1629
00:32:32,960 --> 00:32:36,310
heap
we're going to start at size of q minus

1630
00:32:36,310 --> 00:32:36,320
we're going to start at size of q minus
 

1631
00:32:36,320 --> 00:32:38,070
we're going to start at size of q minus
1

1632
00:32:38,070 --> 00:32:38,080
1
 

1633
00:32:38,080 --> 00:32:40,830
1
for our value i but it's going to be

1634
00:32:40,830 --> 00:32:40,840
for our value i but it's going to be
 

1635
00:32:40,840 --> 00:32:42,789
for our value i but it's going to be
recursive

1636
00:32:42,789 --> 00:32:42,799
recursive
 

1637
00:32:42,799 --> 00:32:44,630
recursive
so what we're going to do is look at a

1638
00:32:44,630 --> 00:32:44,640
so what we're going to do is look at a
 

1639
00:32:44,640 --> 00:32:48,230
so what we're going to do is look at a
node i

1640
00:32:48,230 --> 00:32:48,240

 

1641
00:32:48,240 --> 00:32:49,590

in particular the one that just got

1642
00:32:49,590 --> 00:32:49,600
in particular the one that just got
 

1643
00:32:49,600 --> 00:32:51,750
in particular the one that just got
inserted and where could it violate

1644
00:32:51,750 --> 00:32:51,760
inserted and where could it violate
 

1645
00:32:51,760 --> 00:32:56,870
inserted and where could it violate
things well with its parent

1646
00:32:56,870 --> 00:32:56,880
things well with its parent
 

1647
00:32:56,880 --> 00:32:58,950
things well with its parent
because we have no idea what key we just

1648
00:32:58,950 --> 00:32:58,960
because we have no idea what key we just
 

1649
00:32:58,960 --> 00:33:01,029
because we have no idea what key we just
put here maybe it's less than our parent

1650
00:33:01,029 --> 00:33:01,039
put here maybe it's less than our parent
 

1651
00:33:01,039 --> 00:33:01,990
put here maybe it's less than our parent
then we're happy

1652
00:33:01,990 --> 00:33:02,000
then we're happy
 

1653
00:33:02,000 --> 00:33:04,230
then we're happy
but if it's greater than our parent

1654
00:33:04,230 --> 00:33:04,240
but if it's greater than our parent
 

1655
00:33:04,240 --> 00:33:05,029
but if it's greater than our parent
we're in trouble

1656
00:33:05,029 --> 00:33:05,039
we're in trouble
 

1657
00:33:05,039 --> 00:33:08,830
we're in trouble
and we should fix it so

1658
00:33:08,830 --> 00:33:08,840
and we should fix it so
 

1659
00:33:08,840 --> 00:33:13,750
and we should fix it so
if

1660
00:33:13,750 --> 00:33:13,760

 

1661
00:33:13,760 --> 00:33:18,230

the item in the parent

1662
00:33:18,230 --> 00:33:18,240

 

1663
00:33:18,240 --> 00:33:22,230

this key is less than

1664
00:33:22,230 --> 00:33:22,240
this key is less than
 

1665
00:33:22,240 --> 00:33:25,750
this key is less than
eyes key

1666
00:33:25,750 --> 00:33:25,760
eyes key
 

1667
00:33:25,760 --> 00:33:27,590
eyes key
ah i see i forgot to write key in all

1668
00:33:27,590 --> 00:33:27,600
ah i see i forgot to write key in all
 

1669
00:33:27,600 --> 00:33:31,029
ah i see i forgot to write key in all
these spots this should be dot key

1670
00:33:31,029 --> 00:33:31,039
these spots this should be dot key
 

1671
00:33:31,039 --> 00:33:34,230
these spots this should be dot key
and dot key because q of i is an item

1672
00:33:34,230 --> 00:33:34,240
and dot key because q of i is an item
 

1673
00:33:34,240 --> 00:33:38,230
and dot key because q of i is an item
let's guess it's key so this is the bad

1674
00:33:38,230 --> 00:33:38,240
let's guess it's key so this is the bad
 

1675
00:33:38,240 --> 00:33:40,230
let's guess it's key so this is the bad
case this is if the parent is smaller

1676
00:33:40,230 --> 00:33:40,240
case this is if the parent is smaller
 

1677
00:33:40,240 --> 00:33:41,269
case this is if the parent is smaller
than the child

1678
00:33:41,269 --> 00:33:41,279
than the child
 

1679
00:33:41,279 --> 00:33:42,950
than the child
we wanted the parents to always be

1680
00:33:42,950 --> 00:33:42,960
we wanted the parents to always be
 

1681
00:33:42,960 --> 00:33:45,029
we wanted the parents to always be
greater than or equal to its children

1682
00:33:45,029 --> 00:33:45,039
greater than or equal to its children
 

1683
00:33:45,039 --> 00:33:49,269
greater than or equal to its children
so in that case uh what can we do

1684
00:33:49,269 --> 00:33:49,279
so in that case uh what can we do
 

1685
00:33:49,279 --> 00:33:53,509
so in that case uh what can we do
swap them

1686
00:33:53,509 --> 00:33:53,519
swap them
 

1687
00:33:53,519 --> 00:33:58,630
swap them
let's swap q parent of i

1688
00:33:58,630 --> 00:33:58,640

 

1689
00:33:58,640 --> 00:34:03,830

excellent more chuck uh with q of i

1690
00:34:03,830 --> 00:34:03,840
excellent more chuck uh with q of i
 

1691
00:34:03,840 --> 00:34:06,070
excellent more chuck uh with q of i
now they're in the right order okay now

1692
00:34:06,070 --> 00:34:06,080
now they're in the right order okay now
 

1693
00:34:06,080 --> 00:34:07,669
now they're in the right order okay now
we need to think about what about the

1694
00:34:07,669 --> 00:34:07,679
we need to think about what about the
 

1695
00:34:07,679 --> 00:34:08,550
we need to think about what about the
other child

1696
00:34:08,550 --> 00:34:08,560
other child
 

1697
00:34:08,560 --> 00:34:12,470
other child
of that node and what about its parent

1698
00:34:12,470 --> 00:34:12,480
of that node and what about its parent
 

1699
00:34:12,480 --> 00:34:15,669
of that node and what about its parent
okay so um i have some numbers here

1700
00:34:15,669 --> 00:34:15,679
okay so um i have some numbers here
 

1701
00:34:15,679 --> 00:34:19,349
okay so um i have some numbers here
let's say this was 5

1702
00:34:19,349 --> 00:34:19,359
let's say this was 5
 

1703
00:34:19,359 --> 00:34:22,950
let's say this was 5
and this was 10. what do i know about

1704
00:34:22,950 --> 00:34:22,960
and this was 10. what do i know about
 

1705
00:34:22,960 --> 00:34:24,869
and this was 10. what do i know about
this picture before

1706
00:34:24,869 --> 00:34:24,879
this picture before
 

1707
00:34:24,879 --> 00:34:28,149
this picture before
well i know that 10

1708
00:34:28,149 --> 00:34:28,159
well i know that 10
 

1709
00:34:28,159 --> 00:34:29,750
well i know that 10
is this newly inserted item it's the

1710
00:34:29,750 --> 00:34:29,760
is this newly inserted item it's the
 

1711
00:34:29,760 --> 00:34:31,109
is this newly inserted item it's the
only one that could have caused

1712
00:34:31,109 --> 00:34:31,119
only one that could have caused
 

1713
00:34:31,119 --> 00:34:32,230
only one that could have caused
violations

1714
00:34:32,230 --> 00:34:32,240
violations
 

1715
00:34:32,240 --> 00:34:34,310
violations
when i first inserted it so i know that

1716
00:34:34,310 --> 00:34:34,320
when i first inserted it so i know that
 

1717
00:34:34,320 --> 00:34:36,310
when i first inserted it so i know that
before this before i

1718
00:34:36,310 --> 00:34:36,320
before this before i
 

1719
00:34:36,320 --> 00:34:38,790
before this before i
moved 10 around i knew all the things in

1720
00:34:38,790 --> 00:34:38,800
moved 10 around i knew all the things in
 

1721
00:34:38,800 --> 00:34:40,069
moved 10 around i knew all the things in
this left subtree

1722
00:34:40,069 --> 00:34:40,079
this left subtree
 

1723
00:34:40,079 --> 00:34:42,950
this left subtree
are less than or equal to 5 and

1724
00:34:42,950 --> 00:34:42,960
are less than or equal to 5 and
 

1725
00:34:42,960 --> 00:34:44,149
are less than or equal to 5 and
everything up here

1726
00:34:44,149 --> 00:34:44,159
everything up here
 

1727
00:34:44,159 --> 00:34:47,510
everything up here
are greater than or equal to 5.

1728
00:34:47,510 --> 00:34:47,520
are greater than or equal to 5.
 

1729
00:34:47,520 --> 00:34:49,750
are greater than or equal to 5.
i also know that the nodes in here in

1730
00:34:49,750 --> 00:34:49,760
i also know that the nodes in here in
 

1731
00:34:49,760 --> 00:34:51,109
i also know that the nodes in here in
fact were less than or equal to five

1732
00:34:51,109 --> 00:34:51,119
fact were less than or equal to five
 

1733
00:34:51,119 --> 00:34:51,990
fact were less than or equal to five
other than

1734
00:34:51,990 --> 00:34:52,000
other than
 

1735
00:34:52,000 --> 00:34:55,430
other than
this node ten that we just inserted uh

1736
00:34:55,430 --> 00:34:55,440
this node ten that we just inserted uh
 

1737
00:34:55,440 --> 00:34:57,910
this node ten that we just inserted uh
this was a correct heap so five was a

1738
00:34:57,910 --> 00:34:57,920
this was a correct heap so five was a
 

1739
00:34:57,920 --> 00:34:59,190
this was a correct heap so five was a
separator between

1740
00:34:59,190 --> 00:34:59,200
separator between
 

1741
00:34:59,200 --> 00:35:01,030
separator between
things above it on the ancestor chain

1742
00:35:01,030 --> 00:35:01,040
things above it on the ancestor chain
 

1743
00:35:01,040 --> 00:35:02,630
things above it on the ancestor chain
are are greater than or equal to five

1744
00:35:02,630 --> 00:35:02,640
are are greater than or equal to five
 

1745
00:35:02,640 --> 00:35:03,589
are are greater than or equal to five
and things in its

1746
00:35:03,589 --> 00:35:03,599
and things in its
 

1747
00:35:03,599 --> 00:35:05,990
and things in its
sub tree are less than or equal to it

1748
00:35:05,990 --> 00:35:06,000
sub tree are less than or equal to it
 

1749
00:35:06,000 --> 00:35:08,870
sub tree are less than or equal to it
okay so after i do this swap

1750
00:35:08,870 --> 00:35:08,880
okay so after i do this swap
 

1751
00:35:08,880 --> 00:35:15,190
okay so after i do this swap
which i'm just going to do

1752
00:35:15,190 --> 00:35:15,200

 

1753
00:35:15,200 --> 00:35:18,870

after i swap the items 5 and 10.

1754
00:35:18,870 --> 00:35:18,880
after i swap the items 5 and 10.
 

1755
00:35:18,880 --> 00:35:21,910
after i swap the items 5 and 10.
10 is up here 5 is here and now i

1756
00:35:21,910 --> 00:35:21,920
10 is up here 5 is here and now i
 

1757
00:35:21,920 --> 00:35:24,150
10 is up here 5 is here and now i
realize okay great this edge is happy

1758
00:35:24,150 --> 00:35:24,160
realize okay great this edge is happy
 

1759
00:35:24,160 --> 00:35:25,430
realize okay great this edge is happy
because now 10 is greater than or equal

1760
00:35:25,430 --> 00:35:25,440
because now 10 is greater than or equal
 

1761
00:35:25,440 --> 00:35:27,430
because now 10 is greater than or equal
to 5. but also this edge is happy

1762
00:35:27,430 --> 00:35:27,440
to 5. but also this edge is happy
 

1763
00:35:27,440 --> 00:35:28,950
to 5. but also this edge is happy
because it used to be happy and we only

1764
00:35:28,950 --> 00:35:28,960
because it used to be happy and we only
 

1765
00:35:28,960 --> 00:35:31,109
because it used to be happy and we only
made its parent larger

1766
00:35:31,109 --> 00:35:31,119
made its parent larger
 

1767
00:35:31,119 --> 00:35:34,470
made its parent larger
okay now this edge maybe is bad

1768
00:35:34,470 --> 00:35:34,480
okay now this edge maybe is bad
 

1769
00:35:34,480 --> 00:35:39,030
okay now this edge maybe is bad
and so we need to recurse

1770
00:35:39,030 --> 00:35:39,040

 

1771
00:35:39,040 --> 00:35:44,870

recurse on the parent

1772
00:35:44,870 --> 00:35:44,880
recurse on the parent
 

1773
00:35:44,880 --> 00:35:47,349
recurse on the parent
but that's it okay so we fixed this one

1774
00:35:47,349 --> 00:35:47,359
but that's it okay so we fixed this one
 

1775
00:35:47,359 --> 00:35:49,190
but that's it okay so we fixed this one
edge initially this happens way down at

1776
00:35:49,190 --> 00:35:49,200
edge initially this happens way down at
 

1777
00:35:49,200 --> 00:35:50,630
edge initially this happens way down at
the leaf but in general

1778
00:35:50,630 --> 00:35:50,640
the leaf but in general
 

1779
00:35:50,640 --> 00:35:53,349
the leaf but in general
we're taking our item that we inserted

1780
00:35:53,349 --> 00:35:53,359
we're taking our item that we inserted
 

1781
00:35:53,359 --> 00:35:54,630
we're taking our item that we inserted
which is x

1782
00:35:54,630 --> 00:35:54,640
which is x
 

1783
00:35:54,640 --> 00:35:56,470
which is x
and it starts at the last leaf and it

1784
00:35:56,470 --> 00:35:56,480
and it starts at the last leaf and it
 

1785
00:35:56,480 --> 00:35:57,990
and it starts at the last leaf and it
maybe bubbles up for a while

1786
00:35:57,990 --> 00:35:58,000
maybe bubbles up for a while
 

1787
00:35:58,000 --> 00:35:59,270
maybe bubbles up for a while
maybe it gets all the way to the root if

1788
00:35:59,270 --> 00:35:59,280
maybe it gets all the way to the root if
 

1789
00:35:59,280 --> 00:36:01,510
maybe it gets all the way to the root if
we inserted a new maximum item

1790
00:36:01,510 --> 00:36:01,520
we inserted a new maximum item
 

1791
00:36:01,520 --> 00:36:03,829
we inserted a new maximum item
but in each step it goes up one and so

1792
00:36:03,829 --> 00:36:03,839
but in each step it goes up one and so
 

1793
00:36:03,839 --> 00:36:06,710
but in each step it goes up one and so
the running time of all this stuff

1794
00:36:06,710 --> 00:36:06,720
the running time of all this stuff
 

1795
00:36:06,720 --> 00:36:12,310
the running time of all this stuff
is the height of the tree which is log n

1796
00:36:12,310 --> 00:36:12,320
is the height of the tree which is log n
 

1797
00:36:12,320 --> 00:36:13,750
is the height of the tree which is log n
okay and because there's only this one

1798
00:36:13,750 --> 00:36:13,760
okay and because there's only this one
 

1799
00:36:13,760 --> 00:36:15,109
okay and because there's only this one
item that could potentially be wrong if

1800
00:36:15,109 --> 00:36:15,119
item that could potentially be wrong if
 

1801
00:36:15,119 --> 00:36:17,109
item that could potentially be wrong if
it ever stops moving we've just checked

1802
00:36:17,109 --> 00:36:17,119
it ever stops moving we've just checked
 

1803
00:36:17,119 --> 00:36:19,829
it ever stops moving we've just checked
that it satisfies the maxi property

1804
00:36:19,829 --> 00:36:19,839
that it satisfies the maxi property
 

1805
00:36:19,839 --> 00:36:21,430
that it satisfies the maxi property
if it gets to the root you can also

1806
00:36:21,430 --> 00:36:21,440
if it gets to the root you can also
 

1807
00:36:21,440 --> 00:36:23,510
if it gets to the root you can also
check it satisfies the maxi property so

1808
00:36:23,510 --> 00:36:23,520
check it satisfies the maxi property so
 

1809
00:36:23,520 --> 00:36:24,870
check it satisfies the maxi property so
there's a base case i didn't write here

1810
00:36:24,870 --> 00:36:24,880
there's a base case i didn't write here
 

1811
00:36:24,880 --> 00:36:25,670
there's a base case i didn't write here
which is

1812
00:36:25,670 --> 00:36:25,680
which is
 

1813
00:36:25,680 --> 00:36:28,150
which is
if i equals zero we're at the root uh

1814
00:36:28,150 --> 00:36:28,160
if i equals zero we're at the root uh
 

1815
00:36:28,160 --> 00:36:29,990
if i equals zero we're at the root uh
we're done

1816
00:36:29,990 --> 00:36:30,000
we're done
 

1817
00:36:30,000 --> 00:36:32,069
we're done
okay and then you can prove this correct

1818
00:36:32,069 --> 00:36:32,079
okay and then you can prove this correct
 

1819
00:36:32,079 --> 00:36:34,470
okay and then you can prove this correct
by induction

1820
00:36:34,470 --> 00:36:34,480
by induction
 

1821
00:36:34,480 --> 00:36:35,750
by induction
there's just one item that's in the

1822
00:36:35,750 --> 00:36:35,760
there's just one item that's in the
 

1823
00:36:35,760 --> 00:36:37,589
there's just one item that's in the
wrong spot initially and we put it into

1824
00:36:37,589 --> 00:36:37,599
wrong spot initially and we put it into
 

1825
00:36:37,599 --> 00:36:39,030
wrong spot initially and we put it into
a right spot there are many places it

1826
00:36:39,030 --> 00:36:39,040
a right spot there are many places it
 

1827
00:36:39,040 --> 00:36:40,630
a right spot there are many places it
could go

1828
00:36:40,630 --> 00:36:40,640
could go
 

1829
00:36:40,640 --> 00:36:43,030
could go
but we will move it to the i guess

1830
00:36:43,030 --> 00:36:43,040
but we will move it to the i guess
 

1831
00:36:43,040 --> 00:36:45,910
but we will move it to the i guess
unique ancestor position that is correct

1832
00:36:45,910 --> 00:36:45,920
unique ancestor position that is correct
 

1833
00:36:45,920 --> 00:36:48,470
unique ancestor position that is correct
that satisfies maxi property okay so

1834
00:36:48,470 --> 00:36:48,480
that satisfies maxi property okay so
 

1835
00:36:48,480 --> 00:36:50,069
that satisfies maxi property okay so
that's insert

1836
00:36:50,069 --> 00:36:50,079
that's insert
 

1837
00:36:50,079 --> 00:36:53,270
that's insert
delete is going to be

1838
00:36:53,270 --> 00:36:53,280
delete is going to be
 

1839
00:36:53,280 --> 00:37:01,829
delete is going to be
almost the same

1840
00:37:01,829 --> 00:37:01,839

 

1841
00:37:01,839 --> 00:37:13,750

delete man that is

1842
00:37:13,750 --> 00:37:13,760

 

1843
00:37:13,760 --> 00:37:17,270

sorry delete max thank you

1844
00:37:17,270 --> 00:37:17,280

 

1845
00:37:17,280 --> 00:37:18,710

you can of course define all of these

1846
00:37:18,710 --> 00:37:18,720
you can of course define all of these
 

1847
00:37:18,720 --> 00:37:20,310
you can of course define all of these
things for min instead of max everything

1848
00:37:20,310 --> 00:37:20,320
things for min instead of max everything
 

1849
00:37:20,320 --> 00:37:21,190
things for min instead of max everything
works the same

1850
00:37:21,190 --> 00:37:21,200
works the same
 

1851
00:37:21,200 --> 00:37:22,950
works the same
i just have a hard time remembering

1852
00:37:22,950 --> 00:37:22,960
i just have a hard time remembering
 

1853
00:37:22,960 --> 00:37:24,230
i just have a hard time remembering
which one we're doing

1854
00:37:24,230 --> 00:37:24,240
which one we're doing
 

1855
00:37:24,240 --> 00:37:27,030
which one we're doing
um just don't switch you can't use a max

1856
00:37:27,030 --> 00:37:27,040
um just don't switch you can't use a max
 

1857
00:37:27,040 --> 00:37:28,630
um just don't switch you can't use a max
heap to do delete min you can't use the

1858
00:37:28,630 --> 00:37:28,640
heap to do delete min you can't use the
 

1859
00:37:28,640 --> 00:37:31,030
heap to do delete min you can't use the
mini heap to do delete max but

1860
00:37:31,030 --> 00:37:31,040
mini heap to do delete max but
 

1861
00:37:31,040 --> 00:37:32,630
mini heap to do delete max but
you can use a min heap to do deletemin

1862
00:37:32,630 --> 00:37:32,640
you can use a min heap to do deletemin
 

1863
00:37:32,640 --> 00:37:35,109
you can use a min heap to do deletemin
that's fine

1864
00:37:35,109 --> 00:37:35,119
that's fine
 

1865
00:37:35,119 --> 00:37:38,310
that's fine
so like i said the only le

1866
00:37:38,310 --> 00:37:38,320
so like i said the only le
 

1867
00:37:38,320 --> 00:37:40,150
so like i said the only le
the only node we really know how to

1868
00:37:40,150 --> 00:37:40,160
the only node we really know how to
 

1869
00:37:40,160 --> 00:37:41,990
the only node we really know how to
delete is the last leaf and the last

1870
00:37:41,990 --> 00:37:42,000
delete is the last leaf and the last
 

1871
00:37:42,000 --> 00:37:43,750
delete is the last leaf and the last
level which is the end of the array

1872
00:37:43,750 --> 00:37:43,760
level which is the end of the array
 

1873
00:37:43,760 --> 00:37:45,589
level which is the end of the array
because that's what arrays can delete

1874
00:37:45,589 --> 00:37:45,599
because that's what arrays can delete
 

1875
00:37:45,599 --> 00:37:46,950
because that's what arrays can delete
efficiently

1876
00:37:46,950 --> 00:37:46,960
efficiently
 

1877
00:37:46,960 --> 00:37:49,030
efficiently
and what we what we need to delete is

1878
00:37:49,030 --> 00:37:49,040
and what we what we need to delete is
 

1879
00:37:49,040 --> 00:37:49,990
and what we what we need to delete is
the root item

1880
00:37:49,990 --> 00:37:50,000
the root item
 

1881
00:37:50,000 --> 00:37:51,990
the root item
because that's always the maximum one

1882
00:37:51,990 --> 00:37:52,000
because that's always the maximum one
 

1883
00:37:52,000 --> 00:37:53,349
because that's always the maximum one
which is at the first position in the

1884
00:37:53,349 --> 00:37:53,359
which is at the first position in the
 

1885
00:37:53,359 --> 00:37:54,230
which is at the first position in the
array

1886
00:37:54,230 --> 00:37:54,240
array
 

1887
00:37:54,240 --> 00:37:57,670
array
so what do we do swap them our usual

1888
00:37:57,670 --> 00:37:57,680
so what do we do swap them our usual
 

1889
00:37:57,680 --> 00:38:00,230
so what do we do swap them our usual
trick

1890
00:38:00,230 --> 00:38:00,240

 

1891
00:38:00,240 --> 00:38:02,069

i think the cool thing about heaps is we

1892
00:38:02,069 --> 00:38:02,079
i think the cool thing about heaps is we
 

1893
00:38:02,079 --> 00:38:03,750
i think the cool thing about heaps is we
never have to do rotations we're only

1894
00:38:03,750 --> 00:38:03,760
never have to do rotations we're only
 

1895
00:38:03,760 --> 00:38:05,270
never have to do rotations we're only
going to do swaps which is something we

1896
00:38:05,270 --> 00:38:05,280
going to do swaps which is something we
 

1897
00:38:05,280 --> 00:38:06,710
going to do swaps which is something we
had to do with trees also

1898
00:38:06,710 --> 00:38:06,720
had to do with trees also
 

1899
00:38:06,720 --> 00:38:10,710
had to do with trees also
binary trees

1900
00:38:10,710 --> 00:38:10,720

 

1901
00:38:10,720 --> 00:38:13,829

sorry q of 0 with

1902
00:38:13,829 --> 00:38:13,839
sorry q of 0 with
 

1903
00:38:13,839 --> 00:38:18,710
sorry q of 0 with
q of the last item

1904
00:38:18,710 --> 00:38:18,720
q of the last item
 

1905
00:38:18,720 --> 00:38:21,109
q of the last item
great done now we have the last item is

1906
00:38:21,109 --> 00:38:21,119
great done now we have the last item is
 

1907
00:38:21,119 --> 00:38:22,630
great done now we have the last item is
the one we want to delete so we do

1908
00:38:22,630 --> 00:38:22,640
the one we want to delete so we do
 

1909
00:38:22,640 --> 00:38:24,630
the one we want to delete so we do
delete last

1910
00:38:24,630 --> 00:38:24,640
delete last
 

1911
00:38:24,640 --> 00:38:27,990
delete last
or pop in python

1912
00:38:27,990 --> 00:38:28,000

 

1913
00:38:28,000 --> 00:38:31,349

and boom we've got we've now deleted the

1914
00:38:31,349 --> 00:38:31,359
and boom we've got we've now deleted the
 

1915
00:38:31,359 --> 00:38:32,230
and boom we've got we've now deleted the
maximum item

1916
00:38:32,230 --> 00:38:32,240
maximum item
 

1917
00:38:32,240 --> 00:38:34,710
maximum item
of course we may have also messed up the

1918
00:38:34,710 --> 00:38:34,720
of course we may have also messed up the
 

1919
00:38:34,720 --> 00:38:36,069
of course we may have also messed up the
maxi property

1920
00:38:36,069 --> 00:38:36,079
maxi property
 

1921
00:38:36,079 --> 00:38:40,069
maxi property
just like we did with insert

1922
00:38:40,069 --> 00:38:40,079
just like we did with insert
 

1923
00:38:40,079 --> 00:38:41,829
just like we did with insert
so with insert we were adding a last

1924
00:38:41,829 --> 00:38:41,839
so with insert we were adding a last
 

1925
00:38:41,839 --> 00:38:43,349
so with insert we were adding a last
leaf

1926
00:38:43,349 --> 00:38:43,359
leaf
 

1927
00:38:43,359 --> 00:38:45,270
leaf
now what we're doing is swapping the

1928
00:38:45,270 --> 00:38:45,280
now what we're doing is swapping the
 

1929
00:38:45,280 --> 00:38:46,470
now what we're doing is swapping the
last leaf with the

1930
00:38:46,470 --> 00:38:46,480
last leaf with the
 

1931
00:38:46,480 --> 00:38:48,310
last leaf with the
i'm pointing at the wrong picture let me

1932
00:38:48,310 --> 00:38:48,320
i'm pointing at the wrong picture let me
 

1933
00:38:48,320 --> 00:38:50,470
i'm pointing at the wrong picture let me
go back to this tree

1934
00:38:50,470 --> 00:38:50,480
go back to this tree
 

1935
00:38:50,480 --> 00:38:53,510
go back to this tree
what we did is swap item j

1936
00:38:53,510 --> 00:38:53,520
what we did is swap item j
 

1937
00:38:53,520 --> 00:38:55,750
what we did is swap item j
with a so the problem is now and then we

1938
00:38:55,750 --> 00:38:55,760
with a so the problem is now and then we
 

1939
00:38:55,760 --> 00:38:57,270
with a so the problem is now and then we
deleted this node

1940
00:38:57,270 --> 00:38:57,280
deleted this node
 

1941
00:38:57,280 --> 00:38:59,910
deleted this node
the problem is now that that root node

1942
00:38:59,910 --> 00:38:59,920
the problem is now that that root node
 

1943
00:38:59,920 --> 00:39:00,310
the problem is now that that root node
has

1944
00:39:00,310 --> 00:39:00,320
has
 

1945
00:39:00,320 --> 00:39:02,710
has
maybe a very small key because the key

1946
00:39:02,710 --> 00:39:02,720
maybe a very small key because the key
 

1947
00:39:02,720 --> 00:39:03,670
maybe a very small key because the key
that's here now

1948
00:39:03,670 --> 00:39:03,680
that's here now
 

1949
00:39:03,680 --> 00:39:05,349
that's here now
is whatever was down here which is very

1950
00:39:05,349 --> 00:39:05,359
is whatever was down here which is very
 

1951
00:39:05,359 --> 00:39:06,950
is whatever was down here which is very
low in the tree so intuitively that's a

1952
00:39:06,950 --> 00:39:06,960
low in the tree so intuitively that's a
 

1953
00:39:06,960 --> 00:39:08,390
low in the tree so intuitively that's a
small value

1954
00:39:08,390 --> 00:39:08,400
small value
 

1955
00:39:08,400 --> 00:39:10,150
small value
and this is supposed to be the maximum

1956
00:39:10,150 --> 00:39:10,160
and this is supposed to be the maximum
 

1957
00:39:10,160 --> 00:39:11,829
and this is supposed to be the maximum
value we just put a small value in the

1958
00:39:11,829 --> 00:39:11,839
value we just put a small value in the
 

1959
00:39:11,839 --> 00:39:12,390
value we just put a small value in the
root

1960
00:39:12,390 --> 00:39:12,400
root
 

1961
00:39:12,400 --> 00:39:15,990
root
so what do we do heapify down

1962
00:39:15,990 --> 00:39:16,000
so what do we do heapify down
 

1963
00:39:16,000 --> 00:39:18,150
so what do we do heapify down
uh we're going to take that item and

1964
00:39:18,150 --> 00:39:18,160
uh we're going to take that item and
 

1965
00:39:18,160 --> 00:39:19,670
uh we're going to take that item and
somehow push it down

1966
00:39:19,670 --> 00:39:19,680
somehow push it down
 

1967
00:39:19,680 --> 00:39:22,390
somehow push it down
to the tree until the down in the tree

1968
00:39:22,390 --> 00:39:22,400
to the tree until the down in the tree
 

1969
00:39:22,400 --> 00:39:24,550
to the tree until the down in the tree
until maxi property is satisfied

1970
00:39:24,550 --> 00:39:24,560
until maxi property is satisfied
 

1971
00:39:24,560 --> 00:39:28,390
until maxi property is satisfied
so this is going to be max

1972
00:39:28,390 --> 00:39:28,400
so this is going to be max
 

1973
00:39:28,400 --> 00:39:32,630
so this is going to be max
keepify down and we will start

1974
00:39:32,630 --> 00:39:32,640
keepify down and we will start
 

1975
00:39:32,640 --> 00:39:36,550
keepify down and we will start
at position zero which is the root

1976
00:39:36,550 --> 00:39:36,560

 

1977
00:39:36,560 --> 00:39:42,870

uh and max heapify down

1978
00:39:42,870 --> 00:39:42,880
uh and max heapify down
 

1979
00:39:42,880 --> 00:39:45,750
uh and max heapify down
is going to be a recursive algorithm so

1980
00:39:45,750 --> 00:39:45,760
is going to be a recursive algorithm so
 

1981
00:39:45,760 --> 00:39:47,829
is going to be a recursive algorithm so
we'll start at some position i

1982
00:39:47,829 --> 00:39:47,839
we'll start at some position i
 

1983
00:39:47,839 --> 00:39:50,150
we'll start at some position i
but initially that's the root and what

1984
00:39:50,150 --> 00:39:50,160
but initially that's the root and what
 

1985
00:39:50,160 --> 00:39:50,870
but initially that's the root and what
we're going to do

1986
00:39:50,870 --> 00:39:50,880
we're going to do
 

1987
00:39:50,880 --> 00:39:54,829
we're going to do
is look at position i and its two

1988
00:39:54,829 --> 00:39:54,839
is look at position i and its two
 

1989
00:39:54,839 --> 00:39:57,190
is look at position i and its two
children

1990
00:39:57,190 --> 00:39:57,200
children
 

1991
00:39:57,200 --> 00:39:59,270
children
so let's say we put a very small value

1992
00:39:59,270 --> 00:39:59,280
so let's say we put a very small value
 

1993
00:39:59,280 --> 00:40:01,030
so let's say we put a very small value
up here like zero

1994
00:40:01,030 --> 00:40:01,040
up here like zero
 

1995
00:40:01,040 --> 00:40:03,030
up here like zero
and let's say we have our children five

1996
00:40:03,030 --> 00:40:03,040
and let's say we have our children five
 

1997
00:40:03,040 --> 00:40:04,710
and let's say we have our children five
and ten we don't know

1998
00:40:04,710 --> 00:40:04,720
and ten we don't know
 

1999
00:40:04,720 --> 00:40:07,430
and ten we don't know
maybe i'll swap their order just to be

2000
00:40:07,430 --> 00:40:07,440
maybe i'll swap their order just to be
 

2001
00:40:07,440 --> 00:40:08,230
maybe i'll swap their order just to be
more generic

2002
00:40:08,230 --> 00:40:08,240
more generic
 

2003
00:40:08,240 --> 00:40:10,950
more generic
because that looks like well not quite a

2004
00:40:10,950 --> 00:40:10,960
because that looks like well not quite a
 

2005
00:40:10,960 --> 00:40:12,150
because that looks like well not quite a
minor search tree but

2006
00:40:12,150 --> 00:40:12,160
minor search tree but
 

2007
00:40:12,160 --> 00:40:13,910
minor search tree but
we don't know their relative order but

2008
00:40:13,910 --> 00:40:13,920
we don't know their relative order but
 

2009
00:40:13,920 --> 00:40:15,829
we don't know their relative order but
one of them is greater than or equal to

2010
00:40:15,829 --> 00:40:15,839
one of them is greater than or equal to
 

2011
00:40:15,839 --> 00:40:16,390
one of them is greater than or equal to
the other

2012
00:40:16,390 --> 00:40:16,400
the other
 

2013
00:40:16,400 --> 00:40:19,349
the other
because they're in some order and so

2014
00:40:19,349 --> 00:40:19,359
because they're in some order and so
 

2015
00:40:19,359 --> 00:40:20,950
because they're in some order and so
what would i like to do to fix this

2016
00:40:20,950 --> 00:40:20,960
what would i like to do to fix this
 

2017
00:40:20,960 --> 00:40:25,270
what would i like to do to fix this
local picture

2018
00:40:25,270 --> 00:40:25,280
local picture
 

2019
00:40:25,280 --> 00:40:28,390
local picture
yeah i want to swap and i could swap

2020
00:40:28,390 --> 00:40:28,400
yeah i want to swap and i could swap
 

2021
00:40:28,400 --> 00:40:29,910
yeah i want to swap and i could swap
zero is clearly in the wrong spot it

2022
00:40:29,910 --> 00:40:29,920
zero is clearly in the wrong spot it
 

2023
00:40:29,920 --> 00:40:31,750
zero is clearly in the wrong spot it
needs to go lower in the tree i can swap

2024
00:40:31,750 --> 00:40:31,760
needs to go lower in the tree i can swap
 

2025
00:40:31,760 --> 00:40:34,069
needs to go lower in the tree i can swap
zero with five or zero with ten

2026
00:40:34,069 --> 00:40:34,079
zero with five or zero with ten
 

2027
00:40:34,079 --> 00:40:38,870
zero with five or zero with ten
which one ten

2028
00:40:38,870 --> 00:40:38,880
which one ten
 

2029
00:40:38,880 --> 00:40:42,230
which one ten
i could draw the picture with 5 but

2030
00:40:42,230 --> 00:40:42,240
i could draw the picture with 5 but
 

2031
00:40:42,240 --> 00:40:46,150
i could draw the picture with 5 but
it will not be happy

2032
00:40:46,150 --> 00:40:46,160

 

2033
00:40:46,160 --> 00:40:48,309

y10 we want to do it with the larger one

2034
00:40:48,309 --> 00:40:48,319
y10 we want to do it with the larger one
 

2035
00:40:48,319 --> 00:40:50,870
y10 we want to do it with the larger one
because then this edge will be happy

2036
00:40:50,870 --> 00:40:50,880
because then this edge will be happy
 

2037
00:40:50,880 --> 00:40:52,870
because then this edge will be happy
and also this edge will be happy if i

2038
00:40:52,870 --> 00:40:52,880
and also this edge will be happy if i
 

2039
00:40:52,880 --> 00:40:55,270
and also this edge will be happy if i
swapped five up there instead the 510

2040
00:40:55,270 --> 00:40:55,280
swapped five up there instead the 510
 

2041
00:40:55,280 --> 00:40:56,710
swapped five up there instead the 510
edge would be unhappy

2042
00:40:56,710 --> 00:40:56,720
edge would be unhappy
 

2043
00:40:56,720 --> 00:40:58,309
edge would be unhappy
it wouldn't satisfy the maxi property so

2044
00:40:58,309 --> 00:40:58,319
it wouldn't satisfy the maxi property so
 

2045
00:40:58,319 --> 00:41:00,150
it wouldn't satisfy the maxi property so
i can do one swap and fix

2046
00:41:00,150 --> 00:41:00,160
i can do one swap and fix
 

2047
00:41:00,160 --> 00:41:03,270
i can do one swap and fix
maxi property except that again zero

2048
00:41:03,270 --> 00:41:03,280
maxi property except that again zero
 

2049
00:41:03,280 --> 00:41:05,829
maxi property except that again zero
may be unhappy with its children zero

2050
00:41:05,829 --> 00:41:05,839
may be unhappy with its children zero
 

2051
00:41:05,839 --> 00:41:07,670
may be unhappy with its children zero
was this one item that was in the wrong

2052
00:41:07,670 --> 00:41:07,680
was this one item that was in the wrong
 

2053
00:41:07,680 --> 00:41:08,230
was this one item that was in the wrong
spot

2054
00:41:08,230 --> 00:41:08,240
spot
 

2055
00:41:08,240 --> 00:41:10,069
spot
and so it may have to go farther down

2056
00:41:10,069 --> 00:41:10,079
and so it may have to go farther down
 

2057
00:41:10,079 --> 00:41:11,430
and so it may have to go farther down
but five will be

2058
00:41:11,430 --> 00:41:11,440
but five will be
 

2059
00:41:11,440 --> 00:41:13,510
but five will be
five didn't even move so it's happy

2060
00:41:13,510 --> 00:41:13,520
five didn't even move so it's happy
 

2061
00:41:13,520 --> 00:41:16,550
five didn't even move so it's happy
everything in this subtree is good

2062
00:41:16,550 --> 00:41:16,560
everything in this subtree is good
 

2063
00:41:16,560 --> 00:41:18,950
everything in this subtree is good
uh what about the parent well if you

2064
00:41:18,950 --> 00:41:18,960
uh what about the parent well if you
 

2065
00:41:18,960 --> 00:41:20,069
uh what about the parent well if you
think about it

2066
00:41:20,069 --> 00:41:20,079
think about it
 

2067
00:41:20,079 --> 00:41:22,069
think about it
because everything was correct a correct

2068
00:41:22,069 --> 00:41:22,079
because everything was correct a correct
 

2069
00:41:22,079 --> 00:41:24,470
because everything was correct a correct
heap before we added 0 or before we put

2070
00:41:24,470 --> 00:41:24,480
heap before we added 0 or before we put
 

2071
00:41:24,480 --> 00:41:25,750
heap before we added 0 or before we put
0 too high

2072
00:41:25,750 --> 00:41:25,760
0 too high
 

2073
00:41:25,760 --> 00:41:27,670
0 too high
all of these nodes will be greater than

2074
00:41:27,670 --> 00:41:27,680
all of these nodes will be greater than
 

2075
00:41:27,680 --> 00:41:29,589
all of these nodes will be greater than
or equal to 10

2076
00:41:29,589 --> 00:41:29,599
or equal to 10
 

2077
00:41:29,599 --> 00:41:33,750
or equal to 10
and so on the ancestor path

2078
00:41:33,750 --> 00:41:33,760
and so on the ancestor path
 

2079
00:41:33,760 --> 00:41:35,349
and so on the ancestor path
and all of these nodes were less than

2080
00:41:35,349 --> 00:41:35,359
and all of these nodes were less than
 

2081
00:41:35,359 --> 00:41:36,870
and all of these nodes were less than
equal to 10 before

2082
00:41:36,870 --> 00:41:36,880
equal to 10 before
 

2083
00:41:36,880 --> 00:41:38,870
equal to 10 before
and less or equal to 5 so that's still

2084
00:41:38,870 --> 00:41:38,880
and less or equal to 5 so that's still
 

2085
00:41:38,880 --> 00:41:41,349
and less or equal to 5 so that's still
true

2086
00:41:41,349 --> 00:41:41,359

 

2087
00:41:41,359 --> 00:41:44,230

but you see this tree is happy this tree

2088
00:41:44,230 --> 00:41:44,240
but you see this tree is happy this tree
 

2089
00:41:44,240 --> 00:41:45,910
but you see this tree is happy this tree
still may be unhappy zeros still might

2090
00:41:45,910 --> 00:41:45,920
still may be unhappy zeros still might
 

2091
00:41:45,920 --> 00:41:47,270
still may be unhappy zeros still might
need to push down farther

2092
00:41:47,270 --> 00:41:47,280
need to push down farther
 

2093
00:41:47,280 --> 00:41:50,550
need to push down farther
that's going to be the recursion okay so

2094
00:41:50,550 --> 00:41:50,560
that's going to be the recursion okay so
 

2095
00:41:50,560 --> 00:41:50,870
that's going to be the recursion okay so
we

2096
00:41:50,870 --> 00:41:50,880
we
 

2097
00:41:50,880 --> 00:41:53,450
we
check

2098
00:41:53,450 --> 00:41:53,460

 

2099
00:41:53,460 --> 00:42:00,829

[Applause]

2100
00:42:00,829 --> 00:42:00,839

 

2101
00:42:00,839 --> 00:42:05,990

here

2102
00:42:05,990 --> 00:42:06,000

 

2103
00:42:06,000 --> 00:42:08,150

okay there's a base case which is if i

2104
00:42:08,150 --> 00:42:08,160
okay there's a base case which is if i
 

2105
00:42:08,160 --> 00:42:09,589
okay there's a base case which is if i
as a leaf we're done

2106
00:42:09,589 --> 00:42:09,599
as a leaf we're done
 

2107
00:42:09,599 --> 00:42:13,750
as a leaf we're done
because there's nothing below them uh

2108
00:42:13,750 --> 00:42:13,760
because there's nothing below them uh
 

2109
00:42:13,760 --> 00:42:16,870
because there's nothing below them uh
so we satisfy the maxi property at i

2110
00:42:16,870 --> 00:42:16,880
so we satisfy the maxi property at i
 

2111
00:42:16,880 --> 00:42:18,630
so we satisfy the maxi property at i
because there's no children

2112
00:42:18,630 --> 00:42:18,640
because there's no children
 

2113
00:42:18,640 --> 00:42:22,790
because there's no children
otherwise let's look at the leaf

2114
00:42:22,790 --> 00:42:22,800
otherwise let's look at the leaf
 

2115
00:42:22,800 --> 00:42:26,710
otherwise let's look at the leaf
among the left sorry left not leaf

2116
00:42:26,710 --> 00:42:26,720
among the left sorry left not leaf
 

2117
00:42:26,720 --> 00:42:28,870
among the left sorry left not leaf
among the two children left and right of

2118
00:42:28,870 --> 00:42:28,880
among the two children left and right of
 

2119
00:42:28,880 --> 00:42:31,030
among the two children left and right of
eye right of i might not exist then

2120
00:42:31,030 --> 00:42:31,040
eye right of i might not exist then
 

2121
00:42:31,040 --> 00:42:31,829
eye right of i might not exist then
ignore it

2122
00:42:31,829 --> 00:42:31,839
ignore it
 

2123
00:42:31,839 --> 00:42:35,910
ignore it
but among the two children that exist

2124
00:42:35,910 --> 00:42:35,920
but among the two children that exist
 

2125
00:42:35,920 --> 00:42:39,349
but among the two children that exist
find the one that has maximum

2126
00:42:39,349 --> 00:42:39,359
find the one that has maximum
 

2127
00:42:39,359 --> 00:42:42,390
find the one that has maximum
key value q

2128
00:42:42,390 --> 00:42:42,400
key value q
 

2129
00:42:42,400 --> 00:42:46,069
key value q
of dot key

2130
00:42:46,069 --> 00:42:46,079

 

2131
00:42:46,079 --> 00:42:49,030

okay that's that was 10 in our example

2132
00:42:49,030 --> 00:42:49,040
okay that's that was 10 in our example
 

2133
00:42:49,040 --> 00:42:50,069
okay that's that was 10 in our example
and then if

2134
00:42:50,069 --> 00:42:50,079
and then if
 

2135
00:42:50,079 --> 00:42:52,309
and then if
these items are out of order if we do

2136
00:42:52,309 --> 00:42:52,319
these items are out of order if we do
 

2137
00:42:52,319 --> 00:42:54,309
these items are out of order if we do
not satisfy

2138
00:42:54,309 --> 00:42:54,319
not satisfy
 

2139
00:42:54,319 --> 00:42:56,950
not satisfy
so greater than would be satisfy less

2140
00:42:56,950 --> 00:42:56,960
so greater than would be satisfy less
 

2141
00:42:56,960 --> 00:42:58,550
so greater than would be satisfy less
than q of j

2142
00:42:58,550 --> 00:42:58,560
than q of j
 

2143
00:42:58,560 --> 00:43:00,470
than q of j
would be the opposite of the maxi

2144
00:43:00,470 --> 00:43:00,480
would be the opposite of the maxi
 

2145
00:43:00,480 --> 00:43:02,069
would be the opposite of the maxi
property

2146
00:43:02,069 --> 00:43:02,079
property
 

2147
00:43:02,079 --> 00:43:06,309
property
here if if maxi property is violated

2148
00:43:06,309 --> 00:43:06,319
here if if maxi property is violated
 

2149
00:43:06,319 --> 00:43:10,470
here if if maxi property is violated
then we fix it by swapping

2150
00:43:10,470 --> 00:43:10,480

 

2151
00:43:10,480 --> 00:43:15,030

q of i with q of j

2152
00:43:15,030 --> 00:43:15,040

 

2153
00:43:15,040 --> 00:43:21,270

and then we recurse on j

2154
00:43:21,270 --> 00:43:21,280

 

2155
00:43:21,280 --> 00:43:24,870

okay call max heapify down of j

2156
00:43:24,870 --> 00:43:24,880
okay call max heapify down of j
 

2157
00:43:24,880 --> 00:43:27,109
okay call max heapify down of j
that's it so pretty symmetric uh insert

2158
00:43:27,109 --> 00:43:27,119
that's it so pretty symmetric uh insert
 

2159
00:43:27,119 --> 00:43:28,309
that's it so pretty symmetric uh insert
was a little bit simpler because we only

2160
00:43:28,309 --> 00:43:28,319
was a little bit simpler because we only
 

2161
00:43:28,319 --> 00:43:29,589
was a little bit simpler because we only
have one parent

2162
00:43:29,589 --> 00:43:29,599
have one parent
 

2163
00:43:29,599 --> 00:43:31,589
have one parent
delete min because we're pushing down we

2164
00:43:31,589 --> 00:43:31,599
delete min because we're pushing down we
 

2165
00:43:31,599 --> 00:43:33,109
delete min because we're pushing down we
have two children we have to

2166
00:43:33,109 --> 00:43:33,119
have two children we have to
 

2167
00:43:33,119 --> 00:43:35,270
have two children we have to
pick one but there's a clear choice the

2168
00:43:35,270 --> 00:43:35,280
pick one but there's a clear choice the
 

2169
00:43:35,280 --> 00:43:36,390
pick one but there's a clear choice the
bigger one

2170
00:43:36,390 --> 00:43:36,400
bigger one
 

2171
00:43:36,400 --> 00:43:38,230
bigger one
and again this algorithm this whole

2172
00:43:38,230 --> 00:43:38,240
and again this algorithm this whole
 

2173
00:43:38,240 --> 00:43:40,309
and again this algorithm this whole
thing will take order h time the height

2174
00:43:40,309 --> 00:43:40,319
thing will take order h time the height
 

2175
00:43:40,319 --> 00:43:42,309
thing will take order h time the height
of the tree which is log n

2176
00:43:42,309 --> 00:43:42,319
of the tree which is log n
 

2177
00:43:42,319 --> 00:43:44,150
of the tree which is log n
because our node just sort of bubbles

2178
00:43:44,150 --> 00:43:44,160
because our node just sort of bubbles
 

2179
00:43:44,160 --> 00:43:45,510
because our node just sort of bubbles
down at some point it stops when it

2180
00:43:45,510 --> 00:43:45,520
down at some point it stops when it
 

2181
00:43:45,520 --> 00:43:46,390
down at some point it stops when it
stops we know

2182
00:43:46,390 --> 00:43:46,400
stops we know
 

2183
00:43:46,400 --> 00:43:48,870
stops we know
the maxi property was satisfied there

2184
00:43:48,870 --> 00:43:48,880
the maxi property was satisfied there
 

2185
00:43:48,880 --> 00:43:50,550
the maxi property was satisfied there
and if you check along the way

2186
00:43:50,550 --> 00:43:50,560
and if you check along the way
 

2187
00:43:50,560 --> 00:43:52,390
and if you check along the way
by induction all the other maxi

2188
00:43:52,390 --> 00:43:52,400
by induction all the other maxi
 

2189
00:43:52,400 --> 00:43:54,069
by induction all the other maxi
properties will be satisfied

2190
00:43:54,069 --> 00:43:54,079
properties will be satisfied
 

2191
00:43:54,079 --> 00:43:57,349
properties will be satisfied
because they were before okay

2192
00:43:57,349 --> 00:43:57,359
because they were before okay
 

2193
00:43:57,359 --> 00:43:59,670
because they were before okay
so almost forced what we could do here

2194
00:43:59,670 --> 00:43:59,680
so almost forced what we could do here
 

2195
00:43:59,680 --> 00:44:00,950
so almost forced what we could do here
the amazing thing is that you can

2196
00:44:00,950 --> 00:44:00,960
the amazing thing is that you can
 

2197
00:44:00,960 --> 00:44:02,309
the amazing thing is that you can
actually maintain a complete

2198
00:44:02,309 --> 00:44:02,319
actually maintain a complete
 

2199
00:44:02,319 --> 00:44:04,630
actually maintain a complete
binary tree that satisfies the maxi

2200
00:44:04,630 --> 00:44:04,640
binary tree that satisfies the maxi
 

2201
00:44:04,640 --> 00:44:05,589
binary tree that satisfies the maxi
property

2202
00:44:05,589 --> 00:44:05,599
property
 

2203
00:44:05,599 --> 00:44:07,670
property
but once you're told that the algorithm

2204
00:44:07,670 --> 00:44:07,680
but once you're told that the algorithm
 

2205
00:44:07,680 --> 00:44:09,190
but once you're told that the algorithm
kind of falls out because

2206
00:44:09,190 --> 00:44:09,200
kind of falls out because
 

2207
00:44:09,200 --> 00:44:10,710
kind of falls out because
we have an array the only thing we can

2208
00:44:10,710 --> 00:44:10,720
we have an array the only thing we can
 

2209
00:44:10,720 --> 00:44:12,470
we have an array the only thing we can
do is insert and delete the last item

2210
00:44:12,470 --> 00:44:12,480
do is insert and delete the last item
 

2211
00:44:12,480 --> 00:44:13,990
do is insert and delete the last item
and so we've got to swap things to there

2212
00:44:13,990 --> 00:44:14,000
and so we've got to swap things to there
 

2213
00:44:14,000 --> 00:44:15,910
and so we've got to swap things to there
in order to or out of there in order to

2214
00:44:15,910 --> 00:44:15,920
in order to or out of there in order to
 

2215
00:44:15,920 --> 00:44:17,990
in order to or out of there in order to
make that work

2216
00:44:17,990 --> 00:44:18,000
make that work
 

2217
00:44:18,000 --> 00:44:19,990
make that work
and then the rest is just checking

2218
00:44:19,990 --> 00:44:20,000
and then the rest is just checking
 

2219
00:44:20,000 --> 00:44:21,430
and then the rest is just checking
locally that you can fix

2220
00:44:21,430 --> 00:44:21,440
locally that you can fix
 

2221
00:44:21,440 --> 00:44:24,950
locally that you can fix
fix the property

2222
00:44:24,950 --> 00:44:24,960

 

2223
00:44:24,960 --> 00:44:28,950

cool uh so

2224
00:44:28,950 --> 00:44:28,960
cool uh so
 

2225
00:44:28,960 --> 00:44:31,349
cool uh so
that's almost it not quite what we

2226
00:44:31,349 --> 00:44:31,359
that's almost it not quite what we
 

2227
00:44:31,359 --> 00:44:32,069
that's almost it not quite what we
wanted

2228
00:44:32,069 --> 00:44:32,079
wanted
 

2229
00:44:32,079 --> 00:44:35,270
wanted
so we now have login amortize insert and

2230
00:44:35,270 --> 00:44:35,280
so we now have login amortize insert and
 

2231
00:44:35,280 --> 00:44:36,309
so we now have login amortize insert and
delete max

2232
00:44:36,309 --> 00:44:36,319
delete max
 

2233
00:44:36,319 --> 00:44:40,630
delete max
in our heap we did not yet cover linear

2234
00:44:40,630 --> 00:44:40,640
in our heap we did not yet cover linear
 

2235
00:44:40,640 --> 00:44:41,190
in our heap we did not yet cover linear
builds

2236
00:44:41,190 --> 00:44:41,200
builds
 

2237
00:44:41,200 --> 00:44:44,230
builds
right now it's n log n if you insert n

2238
00:44:44,230 --> 00:44:44,240
right now it's n log n if you insert n
 

2239
00:44:44,240 --> 00:44:44,950
right now it's n log n if you insert n
times

2240
00:44:44,950 --> 00:44:44,960
times
 

2241
00:44:44,960 --> 00:44:46,550
times
and we did not yet cover how to make

2242
00:44:46,550 --> 00:44:46,560
and we did not yet cover how to make
 

2243
00:44:46,560 --> 00:44:49,030
and we did not yet cover how to make
this an in-place sorting algorithm

2244
00:44:49,030 --> 00:44:49,040
this an in-place sorting algorithm
 

2245
00:44:49,040 --> 00:44:52,870
this an in-place sorting algorithm
so let me sketch each of those

2246
00:44:52,870 --> 00:44:52,880
so let me sketch each of those
 

2247
00:44:52,880 --> 00:44:56,390
so let me sketch each of those
i think first is in place

2248
00:44:56,390 --> 00:44:56,400
i think first is in place
 

2249
00:44:56,400 --> 00:44:59,430
i think first is in place
so

2250
00:44:59,430 --> 00:44:59,440

 

2251
00:44:59,440 --> 00:45:01,430

how do we make this algorithm in place i

2252
00:45:01,430 --> 00:45:01,440
how do we make this algorithm in place i
 

2253
00:45:01,440 --> 00:45:02,950
how do we make this algorithm in place i
guess i want that

2254
00:45:02,950 --> 00:45:02,960
guess i want that
 

2255
00:45:02,960 --> 00:45:06,470
guess i want that
but i don't need this

2256
00:45:06,470 --> 00:45:06,480

 

2257
00:45:06,480 --> 00:45:09,990

so we want to follow priority queue sort

2258
00:45:09,990 --> 00:45:10,000
so we want to follow priority queue sort
 

2259
00:45:10,000 --> 00:45:16,470
so we want to follow priority queue sort
do you want that

2260
00:45:16,470 --> 00:45:16,480

 

2261
00:45:16,480 --> 00:45:20,470

but i don't want to have to uh

2262
00:45:20,470 --> 00:45:20,480
but i don't want to have to uh
 

2263
00:45:20,480 --> 00:45:22,390
but i don't want to have to uh
grow and shrink my array i would just

2264
00:45:22,390 --> 00:45:22,400
grow and shrink my array i would just
 

2265
00:45:22,400 --> 00:45:36,309
grow and shrink my array i would just
like to start with the array itself

2266
00:45:36,309 --> 00:45:36,319

 

2267
00:45:36,319 --> 00:45:41,910

so this is in place

2268
00:45:41,910 --> 00:45:41,920

 

2269
00:45:41,920 --> 00:45:43,349

so what we're going to do is say okay

2270
00:45:43,349 --> 00:45:43,359
so what we're going to do is say okay
 

2271
00:45:43,359 --> 00:45:45,349
so what we're going to do is say okay
here's my array

2272
00:45:45,349 --> 00:45:45,359
here's my array
 

2273
00:45:45,359 --> 00:45:48,150
here's my array
that i want to sort that's given to me

2274
00:45:48,150 --> 00:45:48,160
that i want to sort that's given to me
 

2275
00:45:48,160 --> 00:45:49,270
that i want to sort that's given to me
that's the input

2276
00:45:49,270 --> 00:45:49,280
that's the input
 

2277
00:45:49,280 --> 00:45:53,510
that's the input
to priority queue sort

2278
00:45:53,510 --> 00:45:53,520

 

2279
00:45:53,520 --> 00:45:55,430

and what i'd like is to build a priority

2280
00:45:55,430 --> 00:45:55,440
and what i'd like is to build a priority
 

2281
00:45:55,440 --> 00:45:57,030
and what i'd like is to build a priority
queue out of it initially

2282
00:45:57,030 --> 00:45:57,040
queue out of it initially
 

2283
00:45:57,040 --> 00:45:58,870
queue out of it initially
it's empty and then i want to insert the

2284
00:45:58,870 --> 00:45:58,880
it's empty and then i want to insert the
 

2285
00:45:58,880 --> 00:46:00,550
it's empty and then i want to insert the
items one at a time

2286
00:46:00,550 --> 00:46:00,560
items one at a time
 

2287
00:46:00,560 --> 00:46:03,750
items one at a time
let's say okay so uh

2288
00:46:03,750 --> 00:46:03,760
let's say okay so uh
 

2289
00:46:03,760 --> 00:46:04,950
let's say okay so uh
in general what i'm going to do is

2290
00:46:04,950 --> 00:46:04,960
in general what i'm going to do is
 

2291
00:46:04,960 --> 00:46:09,190
in general what i'm going to do is
maintain that q is some prefix of a

2292
00:46:09,190 --> 00:46:09,200
maintain that q is some prefix of a
 

2293
00:46:09,200 --> 00:46:10,470
maintain that q is some prefix of a
that's going to be my priority queue

2294
00:46:10,470 --> 00:46:10,480
that's going to be my priority queue
 

2295
00:46:10,480 --> 00:46:12,230
that's going to be my priority queue
it's going to live in this

2296
00:46:12,230 --> 00:46:12,240
it's going to live in this
 

2297
00:46:12,240 --> 00:46:15,750
it's going to live in this
subarray this prefix okay so how do i

2298
00:46:15,750 --> 00:46:15,760
subarray this prefix okay so how do i
 

2299
00:46:15,760 --> 00:46:17,109
subarray this prefix okay so how do i
insert a new item

2300
00:46:17,109 --> 00:46:17,119
insert a new item
 

2301
00:46:17,119 --> 00:46:20,390
insert a new item
well i just increment

2302
00:46:20,390 --> 00:46:20,400
well i just increment
 

2303
00:46:20,400 --> 00:46:23,750
well i just increment
so to do an insert the first step

2304
00:46:23,750 --> 00:46:23,760
so to do an insert the first step
 

2305
00:46:23,760 --> 00:46:28,950
so to do an insert the first step
is increment size of q

2306
00:46:28,950 --> 00:46:28,960
is increment size of q
 

2307
00:46:28,960 --> 00:46:30,550
is increment size of q
then i will have taken the next item

2308
00:46:30,550 --> 00:46:30,560
then i will have taken the next item
 

2309
00:46:30,560 --> 00:46:32,230
then i will have taken the next item
from a and injected it into this queue

2310
00:46:32,230 --> 00:46:32,240
from a and injected it into this queue
 

2311
00:46:32,240 --> 00:46:33,270
from a and injected it into this queue
and conveniently

2312
00:46:33,270 --> 00:46:33,280
and conveniently
 

2313
00:46:33,280 --> 00:46:35,910
and conveniently
if we look at our insert code which is

2314
00:46:35,910 --> 00:46:35,920
if we look at our insert code which is
 

2315
00:46:35,920 --> 00:46:37,270
if we look at our insert code which is
here

2316
00:46:37,270 --> 00:46:37,280
here
 

2317
00:46:37,280 --> 00:46:38,950
here
the first thing we wanted to do was add

2318
00:46:38,950 --> 00:46:38,960
the first thing we wanted to do was add
 

2319
00:46:38,960 --> 00:46:40,630
the first thing we wanted to do was add
an item at the end of the array so we

2320
00:46:40,630 --> 00:46:40,640
an item at the end of the array so we
 

2321
00:46:40,640 --> 00:46:41,990
an item at the end of the array so we
just did it

2322
00:46:41,990 --> 00:46:42,000
just did it
 

2323
00:46:42,000 --> 00:46:44,309
just did it
without any actual work just conceptual

2324
00:46:44,309 --> 00:46:44,319
without any actual work just conceptual
 

2325
00:46:44,319 --> 00:46:46,150
without any actual work just conceptual
work we just said oh our q is one bigger

2326
00:46:46,150 --> 00:46:46,160
work we just said oh our q is one bigger
 

2327
00:46:46,160 --> 00:46:49,270
work we just said oh our q is one bigger
boom now this is at the end of the array

2328
00:46:49,270 --> 00:46:49,280
boom now this is at the end of the array
 

2329
00:46:49,280 --> 00:46:51,910
boom now this is at the end of the array
no more amortization in fact because

2330
00:46:51,910 --> 00:46:51,920
no more amortization in fact because
 

2331
00:46:51,920 --> 00:46:52,390
no more amortization in fact because
we're not

2332
00:46:52,390 --> 00:46:52,400
we're not
 

2333
00:46:52,400 --> 00:46:53,670
we're not
ever resizing our array we're just

2334
00:46:53,670 --> 00:46:53,680
ever resizing our array we're just
 

2335
00:46:53,680 --> 00:46:55,829
ever resizing our array we're just
saying oh now q is a little bit bigger

2336
00:46:55,829 --> 00:46:55,839
saying oh now q is a little bit bigger
 

2337
00:46:55,839 --> 00:46:56,950
saying oh now q is a little bit bigger
of a prefix

2338
00:46:56,950 --> 00:46:56,960
of a prefix
 

2339
00:46:56,960 --> 00:46:59,430
of a prefix
it just absorbed the next item of a

2340
00:46:59,430 --> 00:46:59,440
it just absorbed the next item of a
 

2341
00:46:59,440 --> 00:47:01,270
it just absorbed the next item of a
similarly

2342
00:47:01,270 --> 00:47:01,280
similarly
 

2343
00:47:01,280 --> 00:47:05,109
similarly
delete max

2344
00:47:05,109 --> 00:47:05,119

 

2345
00:47:05,119 --> 00:47:08,069

is going to at the end decrement the

2346
00:47:08,069 --> 00:47:08,079
is going to at the end decrement the
 

2347
00:47:08,079 --> 00:47:10,870
is going to at the end decrement the
size of q

2348
00:47:10,870 --> 00:47:10,880
size of q
 

2349
00:47:10,880 --> 00:47:14,069
size of q
why is that okay because at the end

2350
00:47:14,069 --> 00:47:14,079
why is that okay because at the end
 

2351
00:47:14,079 --> 00:47:16,870
why is that okay because at the end
of our delete max operation not quite at

2352
00:47:16,870 --> 00:47:16,880
of our delete max operation not quite at
 

2353
00:47:16,880 --> 00:47:19,349
of our delete max operation not quite at
the end but almost the end

2354
00:47:19,349 --> 00:47:19,359
the end but almost the end
 

2355
00:47:19,359 --> 00:47:21,990
the end but almost the end
we deleted the last item from our array

2356
00:47:21,990 --> 00:47:22,000
we deleted the last item from our array
 

2357
00:47:22,000 --> 00:47:23,670
we deleted the last item from our array
so we just replaced that delete last

2358
00:47:23,670 --> 00:47:23,680
so we just replaced that delete last
 

2359
00:47:23,680 --> 00:47:23,990
so we just replaced that delete last
with

2360
00:47:23,990 --> 00:47:24,000
with
 

2361
00:47:24,000 --> 00:47:26,230
with
a decrement and that's going to shrink

2362
00:47:26,230 --> 00:47:26,240
a decrement and that's going to shrink
 

2363
00:47:26,240 --> 00:47:27,270
a decrement and that's going to shrink
the queue by

2364
00:47:27,270 --> 00:47:27,280
the queue by
 

2365
00:47:27,280 --> 00:47:30,549
the queue by
one it has exact same impact as deleting

2366
00:47:30,549 --> 00:47:30,559
one it has exact same impact as deleting
 

2367
00:47:30,559 --> 00:47:32,390
one it has exact same impact as deleting
the last item but now it's constant time

2368
00:47:32,390 --> 00:47:32,400
the last item but now it's constant time
 

2369
00:47:32,400 --> 00:47:34,470
the last item but now it's constant time
worst case not amortized

2370
00:47:34,470 --> 00:47:34,480
worst case not amortized
 

2371
00:47:34,480 --> 00:47:36,630
worst case not amortized
and the result is we never actually

2372
00:47:36,630 --> 00:47:36,640
and the result is we never actually
 

2373
00:47:36,640 --> 00:47:37,990
and the result is we never actually
build a dynamic array we just

2374
00:47:37,990 --> 00:47:38,000
build a dynamic array we just
 

2375
00:47:38,000 --> 00:47:40,230
build a dynamic array we just
use a portion of a to do it so what's

2376
00:47:40,230 --> 00:47:40,240
use a portion of a to do it so what's
 

2377
00:47:40,240 --> 00:47:41,430
use a portion of a to do it so what's
going to happen is

2378
00:47:41,430 --> 00:47:41,440
going to happen is
 

2379
00:47:41,440 --> 00:47:42,950
going to happen is
we're going to absorb all the items into

2380
00:47:42,950 --> 00:47:42,960
we're going to absorb all the items into
 

2381
00:47:42,960 --> 00:47:44,470
we're going to absorb all the items into
the priority queue and then start

2382
00:47:44,470 --> 00:47:44,480
the priority queue and then start
 

2383
00:47:44,480 --> 00:47:45,589
the priority queue and then start
kicking them out

2384
00:47:45,589 --> 00:47:45,599
kicking them out
 

2385
00:47:45,599 --> 00:47:47,990
kicking them out
as we kick them out we kick out the

2386
00:47:47,990 --> 00:47:48,000
as we kick them out we kick out the
 

2387
00:47:48,000 --> 00:47:48,710
as we kick them out we kick out the
largest

2388
00:47:48,710 --> 00:47:48,720
largest
 

2389
00:47:48,720 --> 00:47:51,030
largest
key item first and we put it here then

2390
00:47:51,030 --> 00:47:51,040
key item first and we put it here then
 

2391
00:47:51,040 --> 00:47:52,630
key item first and we put it here then
the next largest then the next largest

2392
00:47:52,630 --> 00:47:52,640
the next largest then the next largest
 

2393
00:47:52,640 --> 00:47:54,309
the next largest then the next largest
and so on the minimum item's going to be

2394
00:47:54,309 --> 00:47:54,319
and so on the minimum item's going to be
 

2395
00:47:54,319 --> 00:47:54,950
and so on the minimum item's going to be
here

2396
00:47:54,950 --> 00:47:54,960
here
 

2397
00:47:54,960 --> 00:47:56,710
here
and boom it's sorted this is the whole

2398
00:47:56,710 --> 00:47:56,720
and boom it's sorted this is the whole
 

2399
00:47:56,720 --> 00:47:58,790
and boom it's sorted this is the whole
reason i did max heaps instead of min

2400
00:47:58,790 --> 00:47:58,800
reason i did max heaps instead of min
 

2401
00:47:58,800 --> 00:47:59,990
reason i did max heaps instead of min
heaps

2402
00:47:59,990 --> 00:48:00,000
heaps
 

2403
00:48:00,000 --> 00:48:03,349
heaps
is that in the end this will be a upward

2404
00:48:03,349 --> 00:48:03,359
is that in the end this will be a upward
 

2405
00:48:03,359 --> 00:48:05,109
is that in the end this will be a upward
sorted array with the max at the end

2406
00:48:05,109 --> 00:48:05,119
sorted array with the max at the end
 

2407
00:48:05,119 --> 00:48:06,710
sorted array with the max at the end
because we always kick out items at the

2408
00:48:06,710 --> 00:48:06,720
because we always kick out items at the
 

2409
00:48:06,720 --> 00:48:07,190
because we always kick out items at the
end

2410
00:48:07,190 --> 00:48:07,200
end
 

2411
00:48:07,200 --> 00:48:11,109
end
we delete the max first okay so that is

2412
00:48:11,109 --> 00:48:11,119
we delete the max first okay so that is
 

2413
00:48:11,119 --> 00:48:15,030
we delete the max first okay so that is
what's normally called heap sort

2414
00:48:15,030 --> 00:48:15,040

 

2415
00:48:15,040 --> 00:48:17,270

you can apply this same trick to

2416
00:48:17,270 --> 00:48:17,280
you can apply this same trick to
 

2417
00:48:17,280 --> 00:48:18,950
you can apply this same trick to
insertion sort and selection sort and

2418
00:48:18,950 --> 00:48:18,960
insertion sort and selection sort and
 

2419
00:48:18,960 --> 00:48:20,790
insertion sort and selection sort and
you actually get the insertion sort and

2420
00:48:20,790 --> 00:48:20,800
you actually get the insertion sort and
 

2421
00:48:20,800 --> 00:48:21,270
you actually get the insertion sort and
selection

2422
00:48:21,270 --> 00:48:21,280
selection
 

2423
00:48:21,280 --> 00:48:23,190
selection
sort algorithms that we've seen which

2424
00:48:23,190 --> 00:48:23,200
sort algorithms that we've seen which
 

2425
00:48:23,200 --> 00:48:24,870
sort algorithms that we've seen which
operate in prefixes

2426
00:48:24,870 --> 00:48:24,880
operate in prefixes
 

2427
00:48:24,880 --> 00:48:27,910
operate in prefixes
of the array okay cool

2428
00:48:27,910 --> 00:48:27,920
of the array okay cool
 

2429
00:48:27,920 --> 00:48:30,549
of the array okay cool
so now we have we've achieved the y up

2430
00:48:30,549 --> 00:48:30,559
so now we have we've achieved the y up
 

2431
00:48:30,559 --> 00:48:31,910
so now we have we've achieved the y up
there which is n log n

2432
00:48:31,910 --> 00:48:31,920
there which is n log n
 

2433
00:48:31,920 --> 00:48:34,309
there which is n log n
sorting algorithm that is in place so

2434
00:48:34,309 --> 00:48:34,319
sorting algorithm that is in place so
 

2435
00:48:34,319 --> 00:48:35,510
sorting algorithm that is in place so
that was our main goal

2436
00:48:35,510 --> 00:48:35,520
that was our main goal
 

2437
00:48:35,520 --> 00:48:41,510
that was our main goal
keep sort let me very quickly mention

2438
00:48:41,510 --> 00:48:41,520

 

2439
00:48:41,520 --> 00:48:45,990

you can build a heap in linear time

2440
00:48:45,990 --> 00:48:46,000
you can build a heap in linear time
 

2441
00:48:46,000 --> 00:48:49,109
you can build a heap in linear time
with a clever trick so if you insert the

2442
00:48:49,109 --> 00:48:49,119
with a clever trick so if you insert the
 

2443
00:48:49,119 --> 00:48:50,230
with a clever trick so if you insert the
items one at a time that would

2444
00:48:50,230 --> 00:48:50,240
items one at a time that would
 

2445
00:48:50,240 --> 00:48:51,349
items one at a time that would
correspond to

2446
00:48:51,349 --> 00:48:51,359
correspond to
 

2447
00:48:51,359 --> 00:48:53,589
correspond to
inserting down the array and every time

2448
00:48:53,589 --> 00:48:53,599
inserting down the array and every time
 

2449
00:48:53,599 --> 00:48:55,190
inserting down the array and every time
i insert an item i have to walk

2450
00:48:55,190 --> 00:48:55,200
i insert an item i have to walk
 

2451
00:48:55,200 --> 00:48:59,430
i insert an item i have to walk
up the tree so this would be the sum

2452
00:48:59,430 --> 00:48:59,440
up the tree so this would be the sum
 

2453
00:48:59,440 --> 00:49:04,069
up the tree so this would be the sum
of the depth of each node

2454
00:49:04,069 --> 00:49:04,079

 

2455
00:49:04,079 --> 00:49:08,069

if you do that you get n log n

2456
00:49:08,069 --> 00:49:08,079

 

2457
00:49:08,079 --> 00:49:11,990

okay this is the sum over i of log i

2458
00:49:11,990 --> 00:49:12,000
okay this is the sum over i of log i
 

2459
00:49:12,000 --> 00:49:15,190
okay this is the sum over i of log i
that turns out to be n log n it's

2460
00:49:15,190 --> 00:49:15,200
that turns out to be n log n it's
 

2461
00:49:15,200 --> 00:49:18,230
that turns out to be n log n it's
log of n factorial the cool trick

2462
00:49:18,230 --> 00:49:18,240
log of n factorial the cool trick
 

2463
00:49:18,240 --> 00:49:20,710
log of n factorial the cool trick
is to instead imagine adding all the

2464
00:49:20,710 --> 00:49:20,720
is to instead imagine adding all the
 

2465
00:49:20,720 --> 00:49:22,230
is to instead imagine adding all the
items at once and not heapifying

2466
00:49:22,230 --> 00:49:22,240
items at once and not heapifying
 

2467
00:49:22,240 --> 00:49:22,950
items at once and not heapifying
anything

2468
00:49:22,950 --> 00:49:22,960
anything
 

2469
00:49:22,960 --> 00:49:25,349
anything
and then heapify up or sorry heapify

2470
00:49:25,349 --> 00:49:25,359
and then heapify up or sorry heapify
 

2471
00:49:25,359 --> 00:49:26,150
and then heapify up or sorry heapify
down

2472
00:49:26,150 --> 00:49:26,160
down
 

2473
00:49:26,160 --> 00:49:28,630
down
from the bottom up so here we're

2474
00:49:28,630 --> 00:49:28,640
from the bottom up so here we're
 

2475
00:49:28,640 --> 00:49:29,349
from the bottom up so here we're
heapifying

2476
00:49:29,349 --> 00:49:29,359
heapifying
 

2477
00:49:29,359 --> 00:49:35,030
heapifying
up now we're going to heapify down

2478
00:49:35,030 --> 00:49:35,040

 

2479
00:49:35,040 --> 00:49:37,430

and surprisingly that's better because

2480
00:49:37,430 --> 00:49:37,440
and surprisingly that's better because
 

2481
00:49:37,440 --> 00:49:39,349
and surprisingly that's better because
this is the sum of the heights of the

2482
00:49:39,349 --> 00:49:39,359
this is the sum of the heights of the
 

2483
00:49:39,359 --> 00:49:42,069
this is the sum of the heights of the
nodes

2484
00:49:42,069 --> 00:49:42,079

 

2485
00:49:42,079 --> 00:49:44,069

and that turns out to be linear it's not

2486
00:49:44,069 --> 00:49:44,079
and that turns out to be linear it's not
 

2487
00:49:44,079 --> 00:49:45,270
and that turns out to be linear it's not
obvious but

2488
00:49:45,270 --> 00:49:45,280
obvious but
 

2489
00:49:45,280 --> 00:49:48,309
obvious but
intuitively for depth this is zero this

2490
00:49:48,309 --> 00:49:48,319
intuitively for depth this is zero this
 

2491
00:49:48,319 --> 00:49:49,589
intuitively for depth this is zero this
is log n

2492
00:49:49,589 --> 00:49:49,599
is log n
 

2493
00:49:49,599 --> 00:49:51,349
is log n
and we've got a whole ton of leaves so

2494
00:49:51,349 --> 00:49:51,359
and we've got a whole ton of leaves so
 

2495
00:49:51,359 --> 00:49:52,549
and we've got a whole ton of leaves so
right at the leaf level you can see

2496
00:49:52,549 --> 00:49:52,559
right at the leaf level you can see
 

2497
00:49:52,559 --> 00:49:54,309
right at the leaf level you can see
we're paying n log n

2498
00:49:54,309 --> 00:49:54,319
we're paying n log n
 

2499
00:49:54,319 --> 00:49:56,150
we're paying n log n
right because there are n of them and

2500
00:49:56,150 --> 00:49:56,160
right because there are n of them and
 

2501
00:49:56,160 --> 00:49:57,430
right because there are n of them and
each one costs log n

2502
00:49:57,430 --> 00:49:57,440
each one costs log n
 

2503
00:49:57,440 --> 00:49:59,190
each one costs log n
down here at the leaf level we're paying

2504
00:49:59,190 --> 00:49:59,200
down here at the leaf level we're paying
 

2505
00:49:59,200 --> 00:50:00,870
down here at the leaf level we're paying
constant because

2506
00:50:00,870 --> 00:50:00,880
constant because
 

2507
00:50:00,880 --> 00:50:03,589
constant because
um the height of the leaves are one here

2508
00:50:03,589 --> 00:50:03,599
um the height of the leaves are one here
 

2509
00:50:03,599 --> 00:50:05,430
um the height of the leaves are one here
the height of the root is log n and this

2510
00:50:05,430 --> 00:50:05,440
the height of the root is log n and this
 

2511
00:50:05,440 --> 00:50:05,670
the height of the root is log n and this
is

2512
00:50:05,670 --> 00:50:05,680
is
 

2513
00:50:05,680 --> 00:50:08,470
is
this is better now we're paying a small

2514
00:50:08,470 --> 00:50:08,480
this is better now we're paying a small
 

2515
00:50:08,480 --> 00:50:09,349
this is better now we're paying a small
amount for the thing

2516
00:50:09,349 --> 00:50:09,359
amount for the thing
 

2517
00:50:09,359 --> 00:50:11,190
amount for the thing
of which there are many and it's not

2518
00:50:11,190 --> 00:50:11,200
of which there are many and it's not
 

2519
00:50:11,200 --> 00:50:13,030
of which there are many and it's not
quite a geometric series but it turns

2520
00:50:13,030 --> 00:50:13,040
quite a geometric series but it turns
 

2521
00:50:13,040 --> 00:50:13,510
quite a geometric series but it turns
out

2522
00:50:13,510 --> 00:50:13,520
out
 

2523
00:50:13,520 --> 00:50:16,230
out
this is linear so that's how you can do

2524
00:50:16,230 --> 00:50:16,240
this is linear so that's how you can do
 

2525
00:50:16,240 --> 00:50:17,670
this is linear so that's how you can do
linear building heap

2526
00:50:17,670 --> 00:50:17,680
linear building heap
 

2527
00:50:17,680 --> 00:50:20,630
linear building heap
to come back to your question about

2528
00:50:20,630 --> 00:50:20,640
to come back to your question about
 

2529
00:50:20,640 --> 00:50:21,910
to come back to your question about
sequence

2530
00:50:21,910 --> 00:50:21,920
sequence
 

2531
00:50:21,920 --> 00:50:24,710
sequence
avl trees turns out you can get all of

2532
00:50:24,710 --> 00:50:24,720
avl trees turns out you can get all of
 

2533
00:50:24,720 --> 00:50:26,150
avl trees turns out you can get all of
the same bounds as heaps

2534
00:50:26,150 --> 00:50:26,160
the same bounds as heaps
 

2535
00:50:26,160 --> 00:50:28,150
the same bounds as heaps
except for the in-place part by taking a

2536
00:50:28,150 --> 00:50:28,160
except for the in-place part by taking a
 

2537
00:50:28,160 --> 00:50:30,150
except for the in-place part by taking a
sequence avl tree storing

2538
00:50:30,150 --> 00:50:30,160
sequence avl tree storing
 

2539
00:50:30,160 --> 00:50:32,470
sequence avl tree storing
the items in an arbitrary order and

2540
00:50:32,470 --> 00:50:32,480
the items in an arbitrary order and
 

2541
00:50:32,480 --> 00:50:33,910
the items in an arbitrary order and
augmenting by max

2542
00:50:33,910 --> 00:50:33,920
augmenting by max
 

2543
00:50:33,920 --> 00:50:36,950
augmenting by max
which is a crazy idea but it also gives

2544
00:50:36,950 --> 00:50:36,960
which is a crazy idea but it also gives
 

2545
00:50:36,960 --> 00:50:38,470
which is a crazy idea but it also gives
you linear build time

2546
00:50:38,470 --> 00:50:38,480
you linear build time
 

2547
00:50:38,480 --> 00:50:40,309
you linear build time
and yeah there's other fun stuff in your

2548
00:50:40,309 --> 00:50:40,319
and yeah there's other fun stuff in your
 

2549
00:50:40,319 --> 00:50:52,800
and yeah there's other fun stuff in your
notes but i'll stop there

