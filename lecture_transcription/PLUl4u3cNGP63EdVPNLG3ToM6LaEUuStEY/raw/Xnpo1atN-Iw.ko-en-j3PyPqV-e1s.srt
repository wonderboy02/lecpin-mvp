1
00:00:00,000 --> 00:00:12,580
[삐걱거리는 소리]
[바스락거리는 소리] [딸깍거리는 소리]

2
00:00:12,580 --> 00:00:15,970
에릭 데메인: 자,
006 자료구조 수업에 다시 오신 것을 환영합니다.

3
00:00:15,970 --> 00:00:19,330
오늘은 트리와
유사한

4
00:00:19,330 --> 00:00:22,910
데이터 구조인 힙, 즉
이진 힙에 대해 알아보겠습니다.

5
00:00:22,910 --> 00:00:26,710
이것은 우리가
정렬 문제를 새로운 방식으로 해결할 수 있게 해 줄 것입니다.

6
00:00:26,710 --> 00:00:30,228
먼저 오늘

7
00:00:30,228 --> 00:00:32,020
우리가 풀게 될 문제의 일부를 다시 한번 알려드리겠습니다. 이 문제는 우선

8
00:00:32,020 --> 00:00:33,760
순위 큐라고 불립니다.

9
00:00:33,760 --> 00:00:34,803
이것이 인터페이스입니다.

10
00:00:34,803 --> 00:00:36,220
우리는 여러 가지
데이터 구조를 살펴보겠지만, 오늘은

11
00:00:36,220 --> 00:00:40,070
한 가지 주요 데이터
구조에 집중하겠습니다.

12
00:00:40,070 --> 00:00:44,650
그리고 이것은
인터페이스 집합의 부분 집합입니다.

13
00:00:47,230 --> 00:00:49,420
부분집합은
잠재적으로 더

14
00:00:49,420 --> 00:00:53,750
좋고,
더 빠르고, 더 간단하게 해결할 수 있기 때문에 흥미롭습니다.

15
00:00:53,750 --> 00:00:57,880
그래서 여러분은

16
00:00:57,880 --> 00:01:00,670
이러한 모든 연산들을 알아볼 수 있을 겁니다.
다만, 우리는 일반적으로

17
00:01:00,670 --> 00:01:02,930
최댓값 연산을 강조하지는 않았습니다.

18
00:01:02,930 --> 00:01:06,190
여기서 우리는
여러 가지 물건을 저장하는 데 관심이 있습니다.

19
00:01:06,190 --> 00:01:10,060
그들에게는 우리가
우선순위라고 생각하는 핵심 요소들이 있습니다.

20
00:01:10,060 --> 00:01:13,840
그리고 우리는

21
00:01:13,840 --> 00:01:17,350
우리 데이터 세트에서 가장 우선순위가 높은 항목을 식별하고 제거할 수 있기를 원합니다.

22
00:01:17,350 --> 00:01:19,250
그래서
여기에는 여러 가지 동기가 있습니다.

23
00:01:19,250 --> 00:01:21,370
라우터가 있고,
패킷이 라우터로 들어가는 것일 수도 있습니다.

24
00:01:21,370 --> 00:01:23,060
그들에게는 서로 다른
우선순위가 부여되어 있습니다.  우선

25
00:01:23,060 --> 00:01:25,090

순위가 가장 높은 것부터 먼저 처리해야 합니다.

26
00:01:25,090 --> 00:01:28,360
또는
컴퓨터에서 여러 프로세스가

27
00:01:28,360 --> 00:01:32,620
단일
스레드(단일 코어)에서 실행되려고 할 때,

28
00:01:32,620 --> 00:01:34,850

다음에 어떤 프로세스를 실행할지 선택해야 하는 경우도 있습니다.

29
00:01:34,850 --> 00:01:37,840
일반적으로 우선
순위가 높은 프로세스를 먼저 실행합니다.

30
00:01:37,840 --> 00:01:42,730
혹은 여러
사건이 서로

31
00:01:42,730 --> 00:01:44,800
다른 시간에 발생하는 시스템을 시뮬레이션하고,

32
00:01:44,800 --> 00:01:46,990
시간 순서대로 다음 사건을 처리하려는 것일 수도 있습니다.

33
00:01:46,990 --> 00:01:50,470
이것들은 모두
우선순위 큐 인터페이스의 예입니다.  그래프 알고리즘을 배우게 되면

34
00:01:50,470 --> 00:01:52,420

이 수업 내에서 이러한 응용 사례를 보게 될 것입니다

35
00:01:52,420 --> 00:01:54,160
.

36
00:01:54,160 --> 00:01:56,740
하지만 우리가 지원하고자 하는 두 가지 주요 기능은

37
00:01:56,740 --> 00:01:59,140

키를 포함한 항목을 삽입

38
00:01:59,140 --> 00:02:01,930
하고 최대
항목을 앞에 배치한 다음 동시에 반환하는 것입니다

39
00:02:01,930 --> 00:02:03,670
.

40
00:02:03,670 --> 00:02:07,600
또한
구조물을

41
00:02:07,600 --> 00:02:09,164
단순히 삽입하는 것보다 더 빠르게 구축할 수 있는 방법에 대해서도 이야기해 보겠습니다.

42
00:02:09,164 --> 00:02:10,539
물론,

43
00:02:10,539 --> 00:02:14,260
빈 상태로 시작해서
반복적으로 데이터를 삽입하는 방식으로 빌드를 구현할 수도 있습니다.

44
00:02:14,260 --> 00:02:17,500
또한
최댓값을

45
00:02:17,500 --> 00:02:20,410
삭제하지 않고 찾는 것의 복잡성은,

46
00:02:20,410 --> 00:02:24,190
최댓값을 삭제한
다음 다시 삽입하는 두 가지 연산을 통해 시뮬레이션할 수 있으며,

47
00:02:24,190 --> 00:02:25,930
이는 제대로 작동합니다.

48
00:02:25,930 --> 00:02:28,360
하지만 종종 우리는 더 빨리 할 수 ​​있습니다.

49
00:02:28,360 --> 00:02:32,470
하지만 두 가지 핵심적인 주요 작업은
삽입과 삭제입니다.

50
00:02:32,470 --> 00:02:37,180
그리고
이를 위해 몇 가지 데이터 구조를 살펴보겠습니다.

51
00:02:37,180 --> 00:02:39,718


52
00:02:39,718 --> 00:02:40,760
이번 수업에서 배운 데이터 구조 중에서 어떤 게 좋을지 추천해 주실 만한 게 있을까요?  우선순위 큐 인터페이스 문제를

53
00:02:40,760 --> 00:02:45,604
해결하려면 무엇을 사용해야 할까요
?

54
00:02:53,840 --> 00:02:54,770
가능한 답변은 여러 가지입니다.

55
00:02:57,882 --> 00:02:58,840
청중: AVL 순서?

56
00:02:58,840 --> 00:02:59,965
에릭 데메인: 시퀀스 AVL?

57
00:02:59,965 --> 00:03:01,540
오, 그거 흥미롭네요!

58
00:03:01,540 --> 00:03:07,030
시퀀스 AVL이 좋은 답변이지만, 좀 더
세련된 버전일 수도 있습니다.

59
00:03:07,030 --> 00:03:07,830
응?

60
00:03:07,830 --> 00:03:08,770
청중: AVL 설정하시겠습니까?

61
00:03:08,770 --> 00:03:10,960
에릭 데메인:
AVL 설정이 괜찮네요.

62
00:03:10,960 --> 00:03:14,090
Set AVL은 이러한
작업들을 비롯한 다양한 작업을 지원합니다.  빌드 과정을

63
00:03:14,090 --> 00:03:18,190
제외한 모든 과정은 log n 시간이 걸리지만
, 빌드 과정은 먼저 정렬해야 하므로 n log n 시간이 걸립니다

64
00:03:18,190 --> 00:03:20,980
.

65
00:03:20,980 --> 00:03:23,530
따라서 AVL을 설정하는 좋은
방법을 알아보세요.

66
00:03:23,530 --> 00:03:27,580

AVL 시퀀스 아이디어는 나중에 다시 논의하겠습니다.

67
00:03:27,580 --> 00:03:31,650
이것은 작업에 대한 로그 n을 가져옵니다.

68
00:03:31,650 --> 00:03:32,150
엄청난.

69
00:03:32,150 --> 00:03:33,310
제 말은,

70
00:03:33,310 --> 00:03:35,370
AVL 세트는 우리가 가진 가장
강력한 데이터 구조라는 겁니다.  이 장비는

71
00:03:35,370 --> 00:03:38,407

세트장 측면에서 우리가 중요하게 생각하는 모든 작업을 처리합니다.

72
00:03:38,407 --> 00:03:40,240
그리고 시퀀스 AVL은

73
00:03:40,240 --> 00:03:41,115
시퀀스 측면에서 모든 작업을 수행합니다.

74
00:03:41,115 --> 00:03:43,090
하지만 이것은
수열이 아니라 집합이라는 점에 유의하세요.

75
00:03:43,090 --> 00:03:44,350
우리는 열쇠에 신경 씁니다.

76
00:03:44,350 --> 00:03:46,600

순차 AVL을 사용하면 이 문제를 해결할 수 있는 편법이 있지만, 그건

77
00:03:46,600 --> 00:03:50,420
나중에 다루도록 하겠습니다.

78
00:03:50,420 --> 00:03:52,880

예를 들어,

79
00:03:52,880 --> 00:03:55,840
집합 AVL에서 find_max의 속도를 높이고 싶다면 아주 좋습니다.

80
00:03:55,840 --> 00:03:58,420
증강현실을 추가할 수 있습니다.

81
00:03:58,420 --> 00:04:05,410
우리는 서브트리
속성 증강을 기억할 수 있었죠?

82
00:04:05,410 --> 00:04:10,600
이를 이용하여 서브트리 내의

83
00:04:10,600 --> 00:04:14,260
모든 노드에
최댓 키 항목을 저장함으로써 상수 시간 복잡도를 갖는 find_max 함수를 구현할 수 있습니다

84
00:04:14,260 --> 00:04:15,550
.

85
00:04:15,550 --> 00:04:16,850
그리고 그건 서브트리 속성이에요.

86
00:04:16,850 --> 00:04:18,740

지난 수업 시간에 언급했던 거예요.

87
00:04:18,740 --> 00:04:21,279
그래서
시간을 단축하기 위해 그 부분을 개선할 수도 있습니다.

88
00:04:21,279 --> 00:04:22,690
엄청난.  자, 이제 끝났습니다

89
00:04:22,690 --> 00:04:23,400
.

90
00:04:23,400 --> 00:04:24,025
강의 끝.

91
00:04:24,025 --> 00:04:27,040
[웃음] 어떤
의미에서는 맞는 말이에요.

92
00:04:27,040 --> 00:04:28,540
하지만
오늘 우리가 살펴볼 것은 바이너리 힙이라는

93
00:04:28,540 --> 00:04:30,800
또 다른 데이터 구조인데
,

94
00:04:30,800 --> 00:04:34,780
이는 어떤 의미에서는
집합 AVL의 간소화된 형태입니다.

95
00:04:34,780 --> 00:04:37,480
기본적으로
동일한 시간 제한을 달성합니다.

96
00:04:37,480 --> 00:04:41,240
빌드 속도가
로그 스케일로 빨라질 것입니다.

97
00:04:41,240 --> 00:04:44,680
하지만
우리가 그들에게 관심을 갖는 주된 이유는 그것이 아닙니다.

98
00:04:44,680 --> 00:04:46,960
가장 큰 장점은 더
간단

99
00:04:46,960 --> 00:04:51,070
하고
제자리 정렬 알고리즘을 제공한다는 것입니다.

100
00:04:54,220 --> 00:04:58,150
여기 제가

101
00:04:58,150 --> 00:05:01,120
말씀드렸던
빌드, 삽입, 최대 삭제 세 가지 작업이 있습니다.

102
00:05:01,120 --> 00:05:05,470
그래서 우리는 거기에 AVL 트리를 설정했습니다.
n log n 빌드, log n 삽입,

103
00:05:05,470 --> 00:05:07,180
log n 삭제입니다.

104
00:05:07,180 --> 00:05:12,310
힙을 만드는 과정에서
다른 두 가지 데이터 구조에 대해 언급하고 싶습니다

105
00:05:12,310 --> 00:05:13,670
.

106
00:05:13,670 --> 00:05:18,010
하나는 동적
이지만 정렬되지 않은 배열입니다.

107
00:05:18,010 --> 00:05:20,320
다른 하나는
동적으로 정렬되는 배열입니다.

108
00:05:25,850 --> 00:05:27,530
이것들은

109
00:05:27,530 --> 00:05:29,300
우리가
이전에 여러 번 이야기했던 더 간단한 데이터 구조입니다.

110
00:05:29,300 --> 00:05:32,000
그리고 이러한 동기 부여는

111
00:05:32,000 --> 00:05:36,770
시작하는 데 유용한데, 힙은
배열 위에 구축되기 때문입니다. 힙은

112
00:05:38,060 --> 00:05:42,720

배열과 트리의 융합과 같은 개념입니다.

113
00:05:42,720 --> 00:05:47,400
정렬되지 않은
배열이 있다면, 여기에 데이터를 삽입하는 것은 매우 쉽겠죠

114
00:05:47,400 --> 00:05:49,320
?

115
00:05:49,320 --> 00:05:51,580
저는 그냥 끝에 덧붙이기만 하면 됩니다.

116
00:05:51,580 --> 00:05:53,650
이것이 우리가 '
마지막에 삽입'이라고 부르는 것입니다.

117
00:05:53,650 --> 00:05:58,750
따라서 삽입은 빠르고,
비용 상각은 일정합니다.

118
00:05:58,750 --> 00:06:00,180

배열 크기를 조정해야 할 수도 있지만,

119
00:06:00,180 --> 00:06:02,520
그건
비용 상각이 되는 부분입니다.

120
00:06:02,520 --> 00:06:03,577
하지만 최대 삭제 속도가 느립니다.

121
00:06:03,577 --> 00:06:05,910
정렬되지 않은 배열에서는
최댓값이 어디에 있는지 알 수 없습니다.

122
00:06:05,910 --> 00:06:07,770
그래서 저는
전체 배열을 스캔해야 합니다.

123
00:06:11,240 --> 00:06:12,865
그래서 배열을 스캔해서

124
00:06:12,865 --> 00:06:15,700
최댓값이 중간쯤에 있다는 걸 확인한
다음,

125
00:06:22,780 --> 00:06:24,700
그 최댓값을 삭제하고 싶다면
,

126
00:06:24,700 --> 00:06:26,230
동적 배열에서는

127
00:06:26,230 --> 00:06:28,940
마지막
요소를 효율적으로 삭제하는 방법밖에 없습니다.  예를 들어

128
00:06:28,940 --> 00:06:33,870
,
마지막 요소와 교체할 수도 있습니다.

129
00:06:33,870 --> 00:06:36,940
그래서 저는 이 요소를 가져와서
여기에 넣고,

130
00:06:36,940 --> 00:06:40,900
그 배열의 마지막 요소를 삭제합니다.
파이썬에서는 `pop`이고,

131
00:06:40,900 --> 00:06:43,640
영어에서는 `delete_last`입니다.

132
00:06:43,640 --> 00:06:50,160
결론적으로 말하자면, 이것은
선형적인 시간 흐름인데, 이는 좋지 않습니다.

133
00:06:50,160 --> 00:06:51,910
하지만 제가
그 과정이 정확히 어떻게

134
00:06:51,910 --> 00:06:54,220
진행되는지 강조하고 싶었던 이유는 잠시 후에 설명드리겠습니다
.

135
00:06:54,220 --> 00:06:56,200
정렬된 배열은
일종의 역순입니다.

136
00:06:56,200 --> 00:06:58,180
최댓값을 찾는 건 아주 쉽습니다.

137
00:06:58,180 --> 00:07:01,110
어디에 있나요?

138
00:07:01,110 --> 00:07:02,580
끝으로.

139
00:07:02,580 --> 00:07:06,210
delete_max는 오름차순으로

140
00:07:06,210 --> 00:07:07,920
정렬된 배열에서 항상 마지막 요소를 최댓값으로 만듭니다.

141
00:07:11,440 --> 00:07:14,040
제 생각엔 그건
상각이 계속되는 것 같아요. 왜냐하면 그러면

142
00:07:14,040 --> 00:07:18,030
삭제해야 하는데, 그러면
크기 조정이 발생할 수도 있거든요.

143
00:07:18,030 --> 00:07:21,630
하지만 삽입 작업은
순차적으로 진행될 것입니다.

144
00:07:21,630 --> 00:07:25,680
왜냐하면

145
00:07:25,680 --> 00:07:28,200
추가된 항목이 어디에 속하는지 이진 탐색을 통해 찾을 수 있기 때문입니다.  제가 방금

146
00:07:28,200 --> 00:07:35,445

이 항목을 여기에 추가했다고 가정해 보겠습니다.

147
00:07:35,445 --> 00:07:36,820
이진
탐색을 이용하면 찾을 수 있겠지만,

148
00:07:36,820 --> 00:07:38,695
그러려면
큰 변화를 겪어야 할 거예요.

149
00:07:38,695 --> 00:07:41,590
그러니

150
00:07:41,590 --> 00:07:47,560

추가된 항목 x가 속해야 할 위치를 찾을 때까지 계속해서 위치를 바꿔보는 게 낫겠네요.

151
00:07:47,560 --> 00:07:49,330
이제
정렬된 상태를 복원했습니다.

152
00:07:49,330 --> 00:07:52,300
그렇게 하면 선형적인
시간이 걸리는데, 이는 좋지 않습니다.

153
00:07:52,300 --> 00:07:56,110
우리가 원하는 것은 어떻게든
이 두 가지 장점을 모두 누리는 것입니다.

154
00:07:56,110 --> 00:07:59,470
배열 삽입은 빠릅니다.  정렬된 배열

155
00:07:59,470 --> 00:08:01,750
의 경우 삭제 속도가 빠릅니다
.

156
00:08:01,750 --> 00:08:03,460
우리는
두 가지 모두를 위한 일정한 시간을 확보할 수 없습니다.

157
00:08:03,460 --> 00:08:04,960
하지만 우리는
둘 다에 대해 log n 시간을 구할 수 있습니다.

158
00:08:04,960 --> 00:08:07,870
우리는 이미
AVL 트리를 설정하는 방법을 알고 있습니다.

159
00:08:07,870 --> 00:08:10,870
하지만
오늘은 다른 방법을 살펴보겠습니다.  이러한 방식을 바꾸려는

160
00:08:10,870 --> 00:08:16,780
주된 동기는 바로

161
00:08:16,780 --> 00:08:18,670
분류 작업입니다.

162
00:08:18,670 --> 00:08:21,490

우선순위 큐 정렬을 정의하고 싶습니다.

163
00:08:29,280 --> 00:08:33,120
따라서 우선
순위 큐

164
00:08:33,120 --> 00:08:36,419
인터페이스, 특히
insert 및 delete_max를 구현하는 모든 데이터 구조를 사용하면

165
00:08:36,419 --> 00:08:38,220
정렬 알고리즘을 만들 수 있습니다.

166
00:08:38,220 --> 00:08:39,270
어떻게 해야 하죠?

167
00:08:39,270 --> 00:08:42,270
모든 항목을 삽입하고,
모든 항목을 삭제합니다.

168
00:08:42,270 --> 00:08:45,990
하지만 삭제할 때
가장 큰 파일부터 먼저 나오기 때문에 역순으로 정렬된

169
00:08:45,990 --> 00:08:47,610

상태로 표시됩니다.

170
00:08:47,610 --> 00:08:51,840
그러면 시간 역순으로 진행해서
항목들을 정리할 수 있습니다.

171
00:08:51,840 --> 00:09:04,740
따라서 우리는 A에 대한 x에 대해 (x)를 삽입
하거나 (build(A))를 삽입한

172
00:09:04,740 --> 00:09:10,210
다음 반복적으로 delete_max를 실행할 수 있습니다.

173
00:09:17,170 --> 00:09:19,520

이 알고리즘을 실행하는 데 얼마나 시간이 걸립니까?

174
00:09:19,520 --> 00:09:21,270

여기서 몇 가지 표기법을 소개하겠습니다.

175
00:09:21,270 --> 00:09:25,080

n개의 항목을 빌드하는 데 걸리는 시간만큼 걸립니다. 이를

176
00:09:25,080 --> 00:09:29,460
T 하위 빌드(n)에 더하고 --

177
00:09:32,280 --> 00:09:42,655
죄송합니다 --
delete_max를 수행하는 데 걸리는 n배의 시간을 더합니다.

178
00:09:45,510 --> 00:09:49,710
또는
이를 삽입에 걸리는 시간(n배)에

179
00:09:49,710 --> 00:09:54,267

delete_max에 걸리는 시간을 더한 것으로 표현할 수도 있습니다.

180
00:09:58,350 --> 00:10:01,590
그래서 저는 이 T 함수들을 사용하여

181
00:10:01,590 --> 00:10:04,770


182
00:10:04,770 --> 00:10:06,210
이 인터페이스를 구현하는 제 데이터 구조가 제공하는 실행 시간을 추상화하고 있습니다.

183
00:10:06,210 --> 00:10:07,830
인터페이스는
무엇이 올바른지 알려주고,

184
00:10:07,830 --> 00:10:10,990
이러한 T 함수들은
성능 한계를 알려줍니다.

185
00:10:10,990 --> 00:10:13,860

이러한 데이터 구조들을 각각 대입하면

186
00:10:13,860 --> 00:10:16,560
정렬 알고리즘을 얻을 수 있습니다.

187
00:10:16,560 --> 00:10:18,840
AVL 정렬,
배열 정렬,

188
00:10:18,840 --> 00:10:20,280
혼합 배열 정렬이 모두 이해됩니다.

189
00:10:20,280 --> 00:10:21,478
저것들은 어떻게 생겼나요?  알고

190
00:10:21,478 --> 00:10:23,145
보니 이 중 상당수가
낯익은 것들이었습니다.

191
00:10:26,180 --> 00:10:29,530
따라서 설정된 AVL은
작업당 log n을 사용합니다.

192
00:10:29,530 --> 00:10:33,490
그래서 우리는 이들로부터 n log n 정렬
알고리즘을 얻게 되는데, 이는

193
00:10:33,490 --> 00:10:36,580
모든
항목을 AVL 트리에 삽입하는 것입니다.

194
00:10:36,580 --> 00:10:39,930
AVL 빌드를 사용하고 싶지 않습니다.
왜냐하면 AVL 빌드는 정렬을 사용하는데,

195
00:10:39,930 --> 00:10:42,220

정렬을 구현하기 위해 정렬을 사용하는 것이 허용되지 않기 때문입니다.

196
00:10:42,220 --> 00:10:43,990
하지만 우리는
AVL 트리에 삽입

197
00:10:43,990 --> 00:10:45,880
하고 균형을 유지하는 방법을 살펴보았습니다.

198
00:10:45,880 --> 00:10:47,350
그러므로 각각 log n이 걸립니다.

199
00:10:47,350 --> 00:10:50,800
그런 다음
최댓값을 찾아서 삭제하고, 다시 균형을 맞추는 등의 작업을 할 수 있습니다

200
00:10:50,800 --> 00:10:51,430
.

201
00:10:51,430 --> 00:10:52,780
총 소요 시간은 n log n입니다.

202
00:10:52,780 --> 00:10:55,600
이것은
우리가 AVL 정렬이라고 부르는 알고리즘입니다.

203
00:10:55,600 --> 00:10:58,630

AVL 트리가 복잡하기 때문에 다소 복잡합니다.

204
00:10:58,630 --> 00:11:04,150
하지만 이것은 우리에게 최적의
비교 한계와 log n을 제공합니다.

205
00:11:04,150 --> 00:11:08,200
그렇다면 배열 정렬은 어떨까요?  정렬

206
00:11:08,200 --> 00:11:13,310

되지 않은 배열을 사용한다고 가정해 보겠습니다.

207
00:11:13,310 --> 00:11:14,580
저는 그 물건을 넣습니다.

208
00:11:14,580 --> 00:11:15,957
그러니까 제가 항목을 삽입한다면,

209
00:11:15,957 --> 00:11:18,540

삭제 작업을 하기 전에 모든 삽입 작업을 먼저 수행하는 겁니다.

210
00:11:18,540 --> 00:11:20,330
그러니까 이제부터는

211
00:11:20,330 --> 00:11:21,780
원래 배열 순서대로 항목들을 삽입할 겁니다.

212
00:11:21,780 --> 00:11:23,720
다시 말해, 저는
그냥 배열을 가져옵니다.

213
00:11:23,720 --> 00:11:30,460
그리고 나서 제가 하는 일은
가장 큰 항목을 반복적으로 추출하는 것입니다. 즉, 해당 항목을

214
00:11:30,460 --> 00:11:34,570
찾아서
배열의 끝으로 이동시킨

215
00:11:34,570 --> 00:11:36,190
다음, 이 과정을 반복하는 것입니다.

216
00:11:36,190 --> 00:11:38,530
어디서 많이 들어본 이야기 같지 않나요?

217
00:11:38,530 --> 00:11:43,960
그것은
3강에서 다룬 선택 정렬 방식입니다.

218
00:11:43,960 --> 00:11:47,800
그래서 배열을 사용하면
선택 정렬을 할 수 있습니다.

219
00:11:53,260 --> 00:11:54,880
이것은 우리가 예전에 했던 일들을 새롭게 생각해 보는 방식입니다

220
00:11:54,880 --> 00:11:57,070
.

221
00:11:57,070 --> 00:12:01,360
정렬된 배열을 사용하면
어떤 작업을 할 수 있을까요?

222
00:12:01,360 --> 00:12:02,800
우리는 모든 품목을 넣습니다.

223
00:12:02,800 --> 00:12:05,050
실제로 모든
작업이 이루어지는 곳은 바로 그곳입니다. 왜냐하면 우리가

224
00:12:05,050 --> 00:12:06,490
정렬된 배열을 유지하기 때문입니다.

225
00:12:06,490 --> 00:12:07,870
그럼 빈 배열부터 시작해 보겠습니다.

226
00:12:07,870 --> 00:12:08,590
해결됐습니다.

227
00:12:08,590 --> 00:12:09,353
우리는 항목을 추가합니다.

228
00:12:09,353 --> 00:12:10,270
네, 아직 해결됐습니다.

229
00:12:10,270 --> 00:12:11,710
두 번째 항목을 추가하고
,

230
00:12:11,710 --> 00:12:13,390
정렬을 위해 필요한 경우 서로 교환합니다.

231
00:12:13,390 --> 00:12:16,420
일반적으로 항목을 추가할 때는

232
00:12:16,420 --> 00:12:17,530
정렬될 때까지 왼쪽으로 이동합니다.

233
00:12:17,530 --> 00:12:19,810
그것은 삽입 정렬입니다.

234
00:12:26,080 --> 00:12:30,670
꽤 멋지네요.

235
00:12:30,670 --> 00:12:32,290
이전에 살펴본 세 가지 정렬 알고리즘을 통합하는 프레임워크입니다.

236
00:12:32,290 --> 00:12:34,880

지난번에 AVL 정렬에 대해 실제로 이야기하지는 않았지만,

237
00:12:34,880 --> 00:12:36,190
메모에는 나와 있었습니다.

238
00:12:36,190 --> 00:12:39,110
그래서
이 표의 오른쪽 부분이 바로 그 부분입니다.

239
00:12:39,110 --> 00:12:42,430
그러므로 당연히 이러한 배열 데이터
구조는 효율적이지 않습니다.  일부 작업

240
00:12:42,430 --> 00:12:44,710
에는 선형적인 시간이 소요됩니다
.

241
00:12:44,710 --> 00:12:46,570
따라서 정렬 알고리즘은
효율적이지 않습니다.

242
00:12:46,570 --> 00:12:48,028
하지만
이전에 본 적 있는 것들이라,

243
00:12:48,028 --> 00:12:49,938

여기에 어떻게 어울리는지 보는 건 흥미롭네요.

244
00:12:49,938 --> 00:12:51,730
선택
정렬과 삽입

245
00:12:51,730 --> 00:12:53,800
정렬은 이미 자리를 잡았다는 장점이 있었습니다
.  배열 자체 외에

246
00:12:53,800 --> 00:12:57,490
일정한
개수의 포인터 또는 인덱스만 있으면 됩니다

247
00:12:57,490 --> 00:12:59,540
.

248
00:12:59,540 --> 00:13:01,070
그래서 공간 효율성이 매우 뛰어납니다.

249
00:13:01,070 --> 00:13:02,348
그래서 그건 그들에게 유리한 점이었어요.

250
00:13:02,348 --> 00:13:04,390
하지만 이것들은 n의 제곱에 비례하는
시간이 걸리므로,

251
00:13:04,390 --> 00:13:09,310
n이
최대 100 정도일 때를 제외하고는 절대 사용해서는 안 됩니다.

252
00:13:09,310 --> 00:13:14,393
AVL 트리 정렬은 훌륭하지만 시간 복잡도가
n log n이 되고, 아마도 병합 정렬

253
00:13:14,393 --> 00:13:16,060
보다 더 복잡할 것이며, 차라리

254
00:13:16,060 --> 00:13:17,660
병합 정렬을 사용하는 것이 나을 수도 있습니다.

255
00:13:17,660 --> 00:13:21,950
하지만 병합 정렬이나
AVL 트리 정렬 설정은 모두 구현되어 있지 않습니다.

256
00:13:21,950 --> 00:13:24,910
그래서
오늘 우리의 목표는 비교 모델에서 최적의

257
00:13:24,910 --> 00:13:26,770


258
00:13:26,770 --> 00:13:28,390
n log n
비교 횟수를 달성하면서도, 모든 장점을 결합하여 정렬을 구현하는 것입니다

259
00:13:28,390 --> 00:13:30,910


260
00:13:30,910 --> 00:13:33,367
.

261
00:13:33,367 --> 00:13:35,575
그리고 그것이 바로
바이너리 힙을 사용했을 때 얻게 될 결과입니다.

262
00:13:38,750 --> 00:13:40,970
우리는 구축 속도가

263
00:13:40,970 --> 00:13:43,220
조금
더 빠른, 앞서 언급했듯이

264
00:13:43,220 --> 00:13:45,470
선형 시간으로 구축되는 데이터 구조를 설계할 것입니다.

265
00:13:45,470 --> 00:13:48,110
그러니까 AVL 트리처럼
정렬된 순서를 나타내는 건 아닙니다

266
00:13:48,110 --> 00:13:49,880
.

267
00:13:49,880 --> 00:13:51,410
하지만
트리 구조를 기반으로 할 것입니다.

268
00:13:51,410 --> 00:13:53,687
이 또한 배열 기반이 될 것입니다.

269
00:13:53,687 --> 00:13:56,270

삽입과 최대 삭제에 대해 로그 시간 복잡도가 발생할 것입니다.

270
00:13:56,270 --> 00:14:00,230

배열을 사용하기 때문에 상각이 이루어집니다.

271
00:14:00,230 --> 00:14:04,010
하지만 핵심은 이것이
제자리 데이터 구조라는 점입니다.

272
00:14:04,010 --> 00:14:07,970
그것은 단순히
항목들의 배열로만 구성되어 있습니다.

273
00:14:07,970 --> 00:14:11,120
따라서 이를 우선

274
00:14:11,120 --> 00:14:13,460
순위 큐 정렬이나
일반 정렬 알고리즘과 같은 정렬 알고리즘에 적용하면

275
00:14:13,460 --> 00:14:15,650

n log n의 성능을 얻을 뿐만

276
00:14:15,650 --> 00:14:18,530
아니라
제자리 정렬 알고리즘도 얻을 수 있습니다.

277
00:14:18,530 --> 00:14:21,510
이것은
이번 수업에서 우리가 배우게 될 최초이자 유일한

278
00:14:21,510 --> 00:14:24,570
n log n 제자리
정렬 알고리즘입니다.

279
00:14:24,570 --> 00:14:27,250
시원한.

280
00:14:27,250 --> 00:14:29,890
그게 목표입니다.  자,

281
00:14:29,890 --> 00:14:31,300
해봅시다.

282
00:14:31,300 --> 00:14:36,420
그래서 우리가 할 일은, 현재
위치에 있으므로,

283
00:14:36,420 --> 00:14:39,690
기본적으로
최종 항목을 저장하는 배열을 만들어야 한다는 것입니다.

284
00:14:39,690 --> 00:14:41,580
그게 바로 인플레이스(
in-place)의 정의라고 할 수 있죠. 구조체에 있는 항목 수와 정확히 같은 크기의 메모리

285
00:14:41,580 --> 00:14:44,820
슬롯 n개를 사용하는 겁니다

286
00:14:44,820 --> 00:14:47,918

.

287
00:14:47,918 --> 00:14:50,460
하지만 우리는 당연히
일반적인 정렬되지 않은 배열

288
00:14:50,460 --> 00:14:52,998
이나 일반적인 정렬된 배열을 사용하지 않을 것입니다.

289
00:14:52,998 --> 00:14:54,540
우리는
배열을

290
00:14:54,540 --> 00:14:58,050

데이터를 저장하는 기본 기술로 사용할 것입니다.

291
00:14:58,050 --> 00:15:00,810
하지만 우리는 로그
함수적인 성능을 원하며, 이는

292
00:15:00,810 --> 00:15:02,850
트리 구조를 떠올리게 합니다.

293
00:15:02,850 --> 00:15:06,510
로그를 얻는 유일한 방법은
이진 트리를 사용하는 것인데, 이는 거의 확실합니다.

294
00:15:06,510 --> 00:15:14,740
그러니까 어떤 식으로든
트리 구조를 배열에 포함시키고 싶다는 겁니다.

295
00:15:14,740 --> 00:15:16,050
예를 하나 들어보겠습니다.

296
00:15:23,960 --> 00:15:26,480
나무를 그려볼게요.

297
00:15:44,680 --> 00:15:47,110
만약 내가
원하는 오래된 나무를 고를 수 있다면,

298
00:15:47,110 --> 00:15:51,550
나는
기본적으로 완벽하게 균형 잡힌 나무를 고를 것이다.

299
00:15:51,550 --> 00:15:55,120
완벽하게 균형 잡힌 상태라면
이런 모습일 텐데,

300
00:15:55,120 --> 00:15:56,050
어떤 속성이 적용되는 거죠?

301
00:15:56,050 --> 00:15:58,900
제가 가진 모든
레벨, 즉

302
00:15:58,900 --> 00:16:01,810
모든 깊이가
노드로 완전히 채워져 있다는 것입니다.

303
00:16:01,810 --> 00:16:03,025
여기가 깊이 0입니다.

304
00:16:05,800 --> 00:16:11,340
기억하세요, 여기가 깊이 1이고, 여기가
깊이 2이고, 여기가 깊이 3입니다.

305
00:16:11,340 --> 00:16:15,850
제가 정말로 원하는 것은

306
00:16:15,850 --> 00:16:20,860
깊이 i에 있는 노드에 2개의 노드가 있는 것입니다.

307
00:16:20,860 --> 00:16:25,180
그것은
완벽한 이진 트리가 될 것입니다.

308
00:16:25,180 --> 00:16:29,050
하지만 그건 n이
2의 거듭제곱보다 1 작을 때만 성립하는 거잖아요, 그렇죠?

309
00:16:29,050 --> 00:16:31,630

모든 n에 대해 항상 그렇게 할 수는 없습니다.

310
00:16:31,630 --> 00:16:34,090
그래서
제가 바랄 수 있는 차선책은 가장 깊은 i, 즉 마지막 i까지 깊이 i에 있는 노드에서

311
00:16:34,090 --> 00:16:36,850
2의 i제곱이 되는 것입니다

312
00:16:36,850 --> 00:16:40,340

.

313
00:16:40,340 --> 00:16:43,640
그리고 그 수준에서도 저는 여전히
몇 가지를 제한할 겁니다.

314
00:16:43,640 --> 00:16:45,410

모든 노드를

315
00:16:45,410 --> 00:16:48,950
최대한 왼쪽으로 이동시키겠습니다.

316
00:16:48,950 --> 00:17:03,550
그러니까 제가 말씀드리고 싶은 건,
노드가 왼쪽 정렬되는 최대 깊이 부분을 제외하고는 모든 노드가

317
00:17:03,550 --> 00:17:05,050
왼쪽 정렬된다는 겁니다.

318
00:17:10,660 --> 00:17:12,640
그리고 이 두 가지
속성을 합쳐서

319
00:17:12,640 --> 00:17:15,280
저는
완전 이진 트리라고 부릅니다.

320
00:17:27,839 --> 00:17:29,580
이것이 왜 흥미로운가요?  저는

321
00:17:29,580 --> 00:17:35,400

이와 같은 트리 구조를 배열로 표현할 수 있다고 주장하기 때문입니다.  이제 범위를 좁혀서

322
00:17:35,400 --> 00:17:39,720


323
00:17:39,720 --> 00:17:41,440
여기에 배열을 그릴 수 있습니다.

324
00:17:41,440 --> 00:17:43,560
그리고 제가 하려는 것은
이 노드들을

325
00:17:43,560 --> 00:17:45,250
깊이 순서대로 나열하는 것입니다.

326
00:17:45,250 --> 00:17:47,910
그래서 저는 A를 먼저 씁니다.
그게 0단계니까요.

327
00:17:47,910 --> 00:17:50,850
그다음 B, C, 그게 1단계입니다.

328
00:17:50,850 --> 00:17:53,140
그다음은
알파벳 순서대로 쓰는 거죠.

329
00:17:53,140 --> 00:17:54,880
내가 그렇게 만들었어.

330
00:17:54,880 --> 00:17:58,680
D, E, F, G는 깊이 2에 해당합니다.

331
00:17:58,680 --> 00:18:03,150
그리고 H, I, J는 3단계입니다.

332
00:18:03,150 --> 00:18:06,210
이는
트리의 순회 순서와는 매우 다릅니다.

333
00:18:06,210 --> 00:18:10,500
순회 순서는
H, D, I, B, J, E, A, F, C,

334
00:18:10,500 --> 00:18:11,790
G, OK였겠죠?

335
00:18:11,790 --> 00:18:15,330
하지만 이것은 우리가
깊이 순서라고 부를 수 있는 것인데,

336
00:18:15,330 --> 00:18:17,670
가장
깊이가 낮은 노드부터 먼저 처리하는 것입니다. 이는

337
00:18:17,670 --> 00:18:24,440

데이터를 배열하거나 선형화하는 매우 다른 방식입니다.

338
00:18:24,440 --> 00:18:27,260
이것이 바로 더미의 모습입니다
.

339
00:18:27,260 --> 00:18:33,310
흥미로운 점은
완전 이진

340
00:18:33,310 --> 00:18:36,400
트리와 배열 사이에는 일대일 대응 관계가 있다는 것입니다.

341
00:18:36,400 --> 00:18:39,760
모든 배열에는
고유한 완전 이진 트리가 존재합니다.

342
00:18:39,760 --> 00:18:43,340
그리고 모든 완전 이진
트리에는 고유한 배열이 존재합니다.

343
00:18:43,340 --> 00:18:43,880
왜?

344
00:18:43,880 --> 00:18:46,700
완전한 제약 때문에

345
00:18:46,700 --> 00:18:48,660
모든 것이 강제로 이루어지게 되고, 결국 내 행동 또한 그렇게 될 수밖에 없게 된다.

346
00:18:48,660 --> 00:18:50,870
만약 제가
숫자 n을 드린다면,

347
00:18:50,870 --> 00:18:53,810

크기가 n인 나무 모양은 하나밖에 없죠, 그렇죠?

348
00:18:53,810 --> 00:18:57,043


349
00:18:57,043 --> 00:18:57,960
마지막 레벨에 도달할 때까지 위에서 아래로 노드를 채워 넣으면 됩니다.

350
00:18:57,960 --> 00:18:59,960
그다음에는
왼쪽에서 오른쪽으로 순서대로 채워 넣으면 됩니다.

351
00:18:59,960 --> 00:19:03,830

노드를 기록할 때 읽는 순서라고 할 수 있겠죠.

352
00:19:03,830 --> 00:19:07,070
그리고 배열은
어떤 키가 어디에 들어가야 하는지 알려줍니다.

353
00:19:07,070 --> 00:19:09,210
이것은
루트에 처음으로 기록하는 노드이고,

354
00:19:09,210 --> 00:19:10,790
이것은 루트의 왼쪽 자식에 다음으로
기록하는 노드이며

355
00:19:10,790 --> 00:19:13,670

, 이런 식으로 계속됩니다.

356
00:19:13,670 --> 00:19:16,820
여기서는 이진
트리를 배열로 표현했거나,

357
00:19:16,820 --> 00:19:19,280
배열을
이진 트리로 표현한 것을 볼 수 있습니다.

358
00:19:19,280 --> 00:19:21,830

이진 트리는 매우 특수한 방식으로, 균형이 보장된다는

359
00:19:21,830 --> 00:19:25,580
명확한 장점을 가지고 있습니다
.

360
00:19:25,580 --> 00:19:29,007

완전 이진 트리는

361
00:19:29,007 --> 00:19:29,840
항상 균형을 이루기 때문에 힙에서는 회전이 필요하지 않습니다.

362
00:19:29,840 --> 00:19:33,770
사실, 그들은
가능한 최고의 높이,

363
00:19:33,770 --> 00:19:35,420
즉 log n의 천장 높이를 가지고 있습니다.

364
00:19:39,560 --> 00:19:42,290
균형이 잡혔다는 건,
log n의 큰 O 값을 의미한다는 걸 기억하세요.

365
00:19:42,290 --> 00:19:44,330
이것은 1 곱하기 log n입니다.

366
00:19:44,330 --> 00:19:47,900
그러니 더할 나위 없이 완벽한
균형 상태라고 할 수 있죠.

367
00:19:47,900 --> 00:19:52,910
그래서 저는 우선

368
00:19:52,910 --> 00:19:54,145
순위 큐 문제를 해결하기 위해 완전한 이진 트리를 유지할 수 있다고 주장합니다.  전체 인터페이스 세트를 해결하려고 한다면

369
00:19:54,145 --> 00:19:55,520
이것은 불가능할 것입니다

370
00:19:55,520 --> 00:19:57,620

.

371
00:19:57,620 --> 00:19:59,660
그리고
힙의 멋진 점은 바로 그 부분 인터페이스

372
00:19:59,660 --> 00:20:03,030
에만 집중함으로써

373
00:20:03,030 --> 00:20:05,030
더 많은 작업을 수행할 수 있다는 것입니다.

374
00:20:05,030 --> 00:20:07,493
우리는 이
매우 강력한 장점을 유지할 수 있습니다.

375
00:20:07,493 --> 00:20:09,410
그리고 이처럼
강력한 특성을 가지고 있기 때문에,

376
00:20:09,410 --> 00:20:10,993

이 나무를 보관할 필요조차 없습니다.

377
00:20:10,993 --> 00:20:13,610
우리는 왼쪽
포인터, 오른쪽 포인터, 부모

378
00:20:13,610 --> 00:20:16,620
포인터를 저장하지 않고
배열 자체만 저장할 것입니다.

379
00:20:16,620 --> 00:20:28,960
이것을 우리는
암묵적 데이터 구조라고 부릅니다.

380
00:20:28,960 --> 00:20:38,530
기본적으로 포인터가 없고,
n개의 항목으로 이루어진 배열만 있는 것을 의미합니다.

381
00:20:44,080 --> 00:20:46,630

포인터를 저장하지 않고 어떻게 문제를 해결할 수 있을까요?

382
00:20:46,630 --> 00:20:48,790
저는 여전히
그것을 나무처럼 대하고 싶어요.

383
00:20:48,790 --> 00:20:52,150
저는 여전히
B의 왼쪽 자식이 D

384
00:20:52,150 --> 00:20:56,350
이고 오른쪽 자식이 E라는 것을 알고 싶습니다.
잠시 후에 그 이유를 알게 될 것입니다.

385
00:20:56,350 --> 00:21:01,990
음, 우리는
인덱스 연산을 이용해서 이걸 할 수 있어요.

386
00:21:01,990 --> 00:21:06,710
그러니 그곳에 도착하기 전에 몇 가지 라벨을 추가해야 할지도 모르겠네요
.

387
00:21:11,420 --> 00:21:14,170
따라서 이 배열에는
자연스럽게 인덱스가 있습니다.

388
00:21:14,170 --> 00:21:16,630
이것은 인덱스 0입니다.

389
00:21:16,630 --> 00:21:21,580
이것은 인덱스 1, 인덱스 2, 인덱스
3, 인덱스 4, 인덱스 5, 인덱스 6,

390
00:21:21,580 --> 00:21:27,610
7, 8, 9입니다.
항목이 0부터 9까지 총 10개이기 때문입니다.

391
00:21:27,610 --> 00:21:29,650
그리고 여기에도 이러한 레이블을 적용할 수 있습니다
.

392
00:21:29,650 --> 00:21:32,590
이것들은 동일한
노드이므로 0, 1, 2입니다.

393
00:21:32,590 --> 00:21:34,300
이것은 단지 깊이 순서일 뿐입니다.

394
00:21:36,742 --> 00:21:38,200
하지만 이렇게
라벨을 붙여놓으면

395
00:21:38,200 --> 00:21:40,130
훨씬 쉽게
파악할 수 있을 거예요.

396
00:21:40,130 --> 00:21:42,790
만약 제가
B의 왼쪽 자식이 D라는 것을 알고 싶다면,

397
00:21:42,790 --> 00:21:48,596
숫자 1이 주어졌을 때
숫자 3을 계산해야 합니다.

398
00:21:48,596 --> 00:21:52,655
2를 더하는 방법은 여러 가지가 있고,
3을 곱하는 방법도 1을 3으로 바꾸는

399
00:21:52,655 --> 00:21:54,030
여러 가지 연산이 있습니다.

400
00:21:55,770 --> 00:21:58,590
하지만
모든 경우에 적용되는 방법은 단 하나뿐입니다.

401
00:21:58,590 --> 00:22:00,840
여기서 직관적으로 생각해보면
,

402
00:22:00,840 --> 00:22:02,265
레벨 i에 있는 i번째 노드를 2로 만들어야 한다는 것입니다.

403
00:22:02,265 --> 00:22:04,530
만약 제가
하위 레벨로 이동하고 싶다면, 아래쪽에

404
00:22:04,530 --> 00:22:06,990
i+1 노드가 2개 있습니다

405
00:22:06,990 --> 00:22:08,310
. 정확히 두 배죠.  이게

406
00:22:08,310 --> 00:22:10,980
마지막이긴 한데, 사실 그건
별로 중요하지 않을 거예요.

407
00:22:10,980 --> 00:22:13,350
만약 왼쪽에 자식이 있다면,
그 자식도 똑같이 행동할 것입니다.

408
00:22:13,350 --> 00:22:15,810
그래서 직관적으로 저는
i의 거듭제곱에 2의 크기를 가진 공간을 갖게 됩니다.

409
00:22:15,810 --> 00:22:19,350

2의 i+1제곱 크기로 확장해야 하므로

410
00:22:19,350 --> 00:22:22,580
2를 곱해야 합니다.

411
00:22:22,580 --> 00:22:27,110
거의 맞지만,
상수가 몇 개 남았습니다.

412
00:22:27,110 --> 00:22:29,450
그래서 저는 두 번 말하고 싶습니다.

413
00:22:29,450 --> 00:22:32,900
하지만
여기 예시들을 보면, 1 곱하기 2는

414
00:22:32,900 --> 00:22:36,170
2이고, 2는 3보다 1 작습니다.

415
00:22:36,170 --> 00:22:38,420
2 곱하기 2는 4이고, 4는
5보다 1 작습니다.

416
00:22:38,420 --> 00:22:39,770
거의 맞췄네요!

417
00:22:39,770 --> 00:22:43,055
딱 1만큼 차이가 나네요.

418
00:22:43,055 --> 00:22:45,680
1만큼 차이가 난다는 건,

419
00:22:45,680 --> 00:22:50,840
인덱스 오류는
컴퓨터 과학에서 아주 흔한 일이죠.  그렇다면

420
00:22:50,840 --> 00:22:53,760
적합한 아이는 어떨까요?

421
00:22:53,760 --> 00:22:56,540
왼쪽 자식이 2i 더하기
1이라면, 오른쪽 자식은 어디에 있습니까?

422
00:22:59,640 --> 00:23:00,630
웅얼거리는 소리가 많이 들려요.

423
00:23:00,630 --> 00:23:03,930
2i에 2를 더하면 하나 더입니다.

424
00:23:03,930 --> 00:23:06,600
우리는 내용을
왼쪽에서 오른쪽으로, 깊이 순서대로 쓰고 있기 때문에

425
00:23:06,600 --> 00:23:09,830
오른쪽 아이는
왼쪽 아이의 오른쪽 형제자매입니다.

426
00:23:09,830 --> 00:23:12,000
그러니까 그냥 더 큰 거라는 거죠, 알겠죠?

427
00:23:12,000 --> 00:23:15,990
이러한 규칙을 따르면
부모도 계산할 수 있습니다.

428
00:23:15,990 --> 00:23:18,120


429
00:23:18,120 --> 00:23:22,500
이 두
함수의 역함수가 무엇이든 간에, 나중에 이 값을

430
00:23:22,500 --> 00:23:25,890
2로 나누고 싶습니다.

431
00:23:25,890 --> 00:23:29,400

2i + 1 또는 2i + 2가 주어졌을 때 원래의 i로 돌아가고 싶습니다. i에서

432
00:23:29,400 --> 00:23:36,530
1을 빼면

433
00:23:36,530 --> 00:23:38,150
2i가 되거나 2i + 1이 됩니다.

434
00:23:38,150 --> 00:23:42,680
그리고 정수로
2로 나누면 원래의 i, 즉 i가 됩니다

435
00:23:42,680 --> 00:23:43,720
.

436
00:23:43,720 --> 00:23:46,790
죄송합니다, 좀 더
명확하게 하기 위해 이름을 j로 바꾸겠습니다.

437
00:23:46,790 --> 00:23:49,580
그러니까 j는 왼쪽 아이인지 오른쪽 아이인지를 나타내는 겁니다.

438
00:23:49,580 --> 00:23:53,210
그러면
부모였던 i를 재구성할 수 있습니다.

439
00:23:53,210 --> 00:23:56,160
이것은 상수
연산입니다.

440
00:23:56,160 --> 00:23:58,535
그래서
왼쪽 포인터와 오른쪽 포인터를 저장할 필요가 없습니다.

441
00:23:58,535 --> 00:24:00,410

필요할 때마다 계산할 수 있어요.

442
00:24:00,410 --> 00:24:03,140
제가
E 같은 노드에 있을 때, 그 노드의

443
00:24:03,140 --> 00:24:05,540

왼쪽 자식이 무엇인지 알고 싶을 때, 그러니까

444
00:24:05,540 --> 00:24:08,630

노드 인덱스 4에

445
00:24:08,630 --> 00:24:11,127

E라는 항목이 있고 그 노드의

446
00:24:11,127 --> 00:24:13,460
왼쪽 자식이 무엇인지 알고 싶을 때
, 그냥 2를 곱하고

447
00:24:13,460 --> 00:24:13,960
1을 더하면 됩니다. 그러면

448
00:24:13,960 --> 00:24:14,930
9가 나오죠.

449
00:24:14,930 --> 00:24:17,360
그리고 나서
이 배열의 9번째 위치에 있는 노드를 인덱싱하면 됩니다.

450
00:24:17,360 --> 00:24:20,630
이건
그냥 제 머릿속에서 하는 방식이에요.

451
00:24:20,630 --> 00:24:22,770
우리는 단지
여기에 나무가 있다는 생각을 하고 있을 뿐입니다.

452
00:24:22,770 --> 00:24:26,340
하지만 실제로는 컴퓨터 상에
배열만 존재합니다.

453
00:24:26,340 --> 00:24:30,530
그래서 E에서
J로 가려면, 4에서 9로 갈 수 있습니다.

454
00:24:30,530 --> 00:24:33,620
만약
올바른 자식 노드로 이동하려고 한다면 2를 곱해야 합니다.

455
00:24:33,620 --> 00:24:35,430
8에 2를 더하면 10이 됩니다.

456
00:24:35,430 --> 00:24:37,820
그런데 10은
배열의 끝을 넘어섰습니다.

457
00:24:37,820 --> 00:24:40,280
하지만 우리 배열은 크기를 저장하므로, '
아, E에

458
00:24:40,280 --> 00:24:42,110
올바른 자식 요소가 없구나'라고 알 수 있습니다.

459
00:24:42,110 --> 00:24:45,050
이것은
완전 이진 트리에서만 가능한 작업입니다.

460
00:24:45,050 --> 00:24:46,490
일반적인 이진 트리에는

461
00:24:46,490 --> 00:24:49,650
이러한 좋은 속성이 없습니다.

462
00:24:49,650 --> 00:24:53,970
좋아, 그럼 이건
기본적으로 더미라는 거네.

463
00:24:53,970 --> 00:24:58,372
이제 힙 속성이라고 부르는
속성 하나만 더 추가하면 됩니다

464
00:24:58,372 --> 00:24:59,830

.

465
00:25:04,880 --> 00:25:09,520

힙에는 여러 종류가 있습니다.

466
00:25:09,520 --> 00:25:11,890
이러한 유형의 힙을
바이너리 힙이라고 합니다.

467
00:25:11,890 --> 00:25:14,430
다른 것들에 대해서는
앞으로의 강의에서 이야기하겠습니다.

468
00:25:14,430 --> 00:25:28,690
이것을 Q라고 부르겠습니다.
명확히 하자면,

469
00:25:28,690 --> 00:25:47,913
이것은
완전 이진 트리를 나타내는

470
00:25:47,913 --> 00:26:02,270
배열 Q입니다. 그리고 우리는
모든 노드가

471
00:26:02,270 --> 00:26:20,770
소위 최대 힙 속성을 만족하기를 원합니다.
즉, i의 왼쪽 자식과 오른쪽 자식 모두에 대해 Q[i]가

472
00:26:20,770 --> 00:26:29,360
Q[j]보다 크거나 같아야 합니다

473
00:26:29,360 --> 00:26:29,860
.

474
00:26:37,160 --> 00:26:41,690
그래서 우리는 노드 i를 가지고 있습니다.

475
00:26:41,690 --> 00:26:44,750
그리고 이것은 두 개의 자식 함수, 즉

476
00:26:44,750 --> 00:26:48,290
2i + 1과 2i + 2를 갖습니다.

477
00:26:48,290 --> 00:26:50,360
이것들은 j의 두 가지 값입니다.

478
00:26:53,360 --> 00:26:57,140
우리가 원하는 것은

479
00:26:57,140 --> 00:26:59,940
여기와 저기에서 크거나 같다는 관계입니다.

480
00:26:59,940 --> 00:27:01,940
그러므로 이 노드는
이 노드

481
00:27:01,940 --> 00:27:02,520
와 이 노드보다 모두 커야 합니다.

482
00:27:02,520 --> 00:27:03,890
이 중 어느 것이 더 큽니까?

483
00:27:03,890 --> 00:27:06,230
우리는 모르고,
신경도 안 씁니다.

484
00:27:06,230 --> 00:27:08,360

이진 탐색 트리

485
00:27:08,360 --> 00:27:11,640
나 집합 이진 트리와는 아주 다르죠. 그런 트리에서는
이 노드들이

486
00:27:11,640 --> 00:27:13,613
저 노드보다 작거나 같다거나,
저 노드는

487
00:27:13,613 --> 00:27:15,530

여기 서브트리의 모든 노드보다 작거나 같다고 말하곤 했으니까요.

488
00:27:15,530 --> 00:27:17,240
우리는 단지 로컬에서
이 노드가

489
00:27:17,240 --> 00:27:20,000

이 노드와 저 노드보다 크거나 같다고 말하는 것뿐입니다.

490
00:27:20,000 --> 00:27:21,800
그러니까 가장 큰 게 맨 위에 있는 거죠.  이런 더미들에

491
00:27:26,270 --> 00:27:34,010
대한 재밌는 설명 하나:
이건 좀 이상해.

492
00:27:34,010 --> 00:27:36,590

좀 더 직관적으로 설명해 드릴게요.

493
00:27:36,590 --> 00:27:39,680
이진 힙에서
최대 힙 속성을

494
00:27:39,680 --> 00:27:41,960
모든 곳에서 만족한다면,
실제로

495
00:27:41,960 --> 00:27:47,510
모든 노드 i가

496
00:27:47,510 --> 00:27:48,320
해당 서브트리의 모든 노드보다 크거나 같다는 것을 알게 됩니다.

497
00:27:48,320 --> 00:27:55,760
이것들은
i의 하위 트리에서 우리가 후손이라고 부르는 것들입니다.

498
00:28:00,750 --> 00:28:03,390
이 예시를 한번 살펴보겠습니다.

499
00:28:03,390 --> 00:28:05,180
그래서 저는
여기에 숫자를 하나도 적지 않았습니다.

500
00:28:05,180 --> 00:28:06,650
상상해 보세요.

501
00:28:06,650 --> 00:28:10,880
여기서 A는
B와 C 모두보다 크거나 같고,

502
00:28:10,880 --> 00:28:12,950
B는
D와 E보다 크거나 같으며,

503
00:28:12,950 --> 00:28:14,757
C는
F와 G보다 크거나 같고,

504
00:28:14,757 --> 00:28:16,340
D는
H와 I보다 크거나 같고,

505
00:28:16,340 --> 00:28:17,840
E는
J보다 크거나 같습니다.

506
00:28:17,840 --> 00:28:20,030
이렇게 되면 이
구조는

507
00:28:20,030 --> 00:28:23,640
완전 이진 트리가 아니라 힙이 됩니다.

508
00:28:23,640 --> 00:28:24,640
그렇다면 그것은 무엇을 의미할까요?  이는

509
00:28:24,640 --> 00:28:27,380
A가 최댓값이어야 함을 의미합니다
.

510
00:28:27,380 --> 00:28:29,802
그러니까
여기 있는 어떤 노드, 예를 들어 J를 보면 A는

511
00:28:29,802 --> 00:28:32,260
B보다 크거나 같고,
B는 E보다 크거나 같고, E는 J보다 크

512
00:28:32,260 --> 00:28:35,400
거나 같습니다.
일반적으로 우리가

513
00:28:35,400 --> 00:28:38,100
말하는 것은 A가 트리의
모든 노드보다 크거나 같다는 것입니다

514
00:28:38,100 --> 00:28:38,730
.

515
00:28:38,730 --> 00:28:41,190
B는 여기에서 하위 트리의 모든 노드보다 크거나 같습니다

516
00:28:41,190 --> 00:28:42,340
.

517
00:28:42,340 --> 00:28:44,760
C는
해당 서브트리의 모든 노드보다 크거나 같습니다.

518
00:28:44,760 --> 00:28:47,220
이
보조정리가 말하는 바가 바로 그것입니다.

519
00:28:47,220 --> 00:28:50,790
이
보조정리는 귀납법으로 증명할 수 있습니다.

520
00:28:50,790 --> 00:28:55,280
하지만 사실 아주 간단해요.

521
00:28:55,280 --> 00:28:57,830
만약 노드 i
와 j가 있고, j가

522
00:28:57,830 --> 00:28:59,450
서브트리의 어딘가에 있다면, 그것은

523
00:28:59,450 --> 00:29:03,770
i에서 j로 향하는 하향 경로가 존재한다는 것을 의미합니다.

524
00:29:03,770 --> 00:29:05,510
그리고 아시다시피,

525
00:29:05,510 --> 00:29:08,060
우리가
하강 경로에서 지나가는 모든 모서리에서 핵심은

526
00:29:08,060 --> 00:29:10,280
엄격하지 않게 내려가는 것입니다.

527
00:29:10,280 --> 00:29:12,692
그러므로 모든 자녀는
부모보다 못하거나 같다.

528
00:29:12,692 --> 00:29:14,150
i는
이것보다 크거나 같고, 이것

529
00:29:14,150 --> 00:29:14,960
보다 크
거나 같고, 이것

530
00:29:14,960 --> 00:29:16,335
보다 크
거나 같고, j

531
00:29:16,335 --> 00:29:17,900
보다 크
거나 같다는 거죠, 알겠죠?

532
00:29:17,900 --> 00:29:21,470
따라서 '작거나 같음'의 추이성에 의해

533
00:29:21,470 --> 00:29:24,710
i는 실제로
j보다 크거나 같다는 것을 알 수 있습니다.

534
00:29:24,710 --> 00:29:27,080
죄송합니다만, i의 키 값이

535
00:29:27,080 --> 00:29:28,940
j의 키 값보다 크거나 같습니다.

536
00:29:28,940 --> 00:29:30,960
이것을 우리는
인덱스인 i라고 부릅니다.

537
00:29:30,960 --> 00:29:34,170
이것이 바로 우리가
Q of i라고 부르는 것입니다.

538
00:29:34,170 --> 00:29:37,142
이것은 j의 인덱스 j Q입니다.

539
00:29:40,010 --> 00:29:46,660

키를 트리 구조로 구성하는 매우 독특한 방식이지만,

540
00:29:46,660 --> 00:29:49,360

예상하시다시피

541
00:29:49,360 --> 00:29:50,680
우선순위 큐에 유용할 것입니다.

542
00:29:50,680 --> 00:29:52,060
우선순위
큐는

543
00:29:52,060 --> 00:29:54,493
최대 요소를 찾기만 하면 되기 때문입니다.

544
00:29:54,493 --> 00:29:55,660
그런 다음에는 그것을 삭제해야 합니다.

545
00:29:55,660 --> 00:29:57,785
그건 더 어려울 거예요.
왜냐하면 루트를 이끄는 건

546
00:29:57,785 --> 00:30:00,880
,
직관적으로 가장 삭제하기 어려운 노드니까요.

547
00:30:00,880 --> 00:30:02,950
저는
잎사귀들을 삭제하고 싶어요.

548
00:30:02,950 --> 00:30:06,970
하지만 주요 잎들을 유지하고
완전한 이진 트리를 만드는 것은

549
00:30:06,970 --> 00:30:08,470
사실 꽤 어렵습니다.

550
00:30:08,470 --> 00:30:10,930
만약 H를 삭제하고 싶다면
, 그것은 더 이상

551
00:30:10,930 --> 00:30:12,760
이진 트리처럼 보이지 않거나
,

552
00:30:12,760 --> 00:30:14,468
완전
이진 트리처럼 보이지 않을 것입니다.

553
00:30:14,468 --> 00:30:16,555
좌측 정렬이 아닙니다.

554
00:30:16,555 --> 00:30:18,430
마찬가지로,
F를 삭제하고 싶다면 그것은 좋지 않습니다.

555
00:30:18,430 --> 00:30:20,800
왜냐하면 지금 제겐
여기에 노드가 네 개 없기 때문입니다.

556
00:30:20,800 --> 00:30:24,870

삭제하기 가장 쉬운 노드는 J죠, 그렇죠?

557
00:30:24,870 --> 00:30:27,380
해당 노드를 제거해도
트리 구조는 여전히 완전합니다.

558
00:30:27,380 --> 00:30:31,700

배열의 맨 마지막 위치, 즉 마지막 리프는

559
00:30:31,700 --> 00:30:33,200

삭제하기 가장 쉬운 부분입니다.

560
00:30:33,200 --> 00:30:36,390
그건 좋은 점이에요. 배열은
마지막 항목을 맨 앞에 배치하는 데 능숙하니까요.

561
00:30:36,390 --> 00:30:39,770
하지만 제가 여기에서 설정한 것은
최대값을 쉽게 찾을 수 있도록 하는 것입니다.

562
00:30:39,770 --> 00:30:41,660

뿌리 부분에 있을 거예요.

563
00:30:41,660 --> 00:30:43,580
삭제하는 건 귀찮아요.

564
00:30:43,580 --> 00:30:48,200
어떻게든 그
열쇠를 가져다가 마지막 잎의 맨 마지막 위치에 놓고 싶어요

565
00:30:48,200 --> 00:30:50,540

.

566
00:30:50,540 --> 00:30:53,683
왜냐하면 그 위치가
삭제하기 가장 쉽기 때문이에요.

567
00:30:53,683 --> 00:30:55,100
그리고 그것이 바로
우리가

568
00:30:55,100 --> 00:30:58,250
삭제 알고리즘에서 할 일입니다.

569
00:30:58,250 --> 00:30:59,600
먼저 삽입부터 하겠습니다.

570
00:30:59,600 --> 00:31:09,450
제 생각엔 그게 좀 더
간단하고, 방금 말한 내용과 어느 정도 대칭적인 것 같네요

571
00:31:09,450 --> 00:31:11,410
.

572
00:31:11,410 --> 00:31:17,130
그래서 만약 제가 키나 특정
키를 가진 항목 x를 삽입하고 싶다면

573
00:31:17,130 --> 00:31:21,210
,
배열에서 할 수 있는 유일한 방법은

574
00:31:21,210 --> 00:31:23,532
새 항목을 배열의
끝에 추가하는 것뿐입니다.

575
00:31:23,532 --> 00:31:24,990
우리가 할 줄 아는 유일한 것은

576
00:31:24,990 --> 00:31:26,650
배열의 끝에 요소를 삽입하는 것뿐입니다.

577
00:31:26,650 --> 00:31:28,742
이것이 우리가
insert_last라고 부르는 기능입니다.

578
00:31:33,820 --> 00:31:34,320
이것?  이는 완전 이진 트리의

579
00:31:34,320 --> 00:31:39,270


580
00:31:39,270 --> 00:31:44,380
맨 마지막 레벨에 항목 x를 포함하는 노드를 추가하는 것과 같습니다

581
00:31:44,380 --> 00:31:44,880
.

582
00:31:44,880 --> 00:31:47,130

기존 노드들의 오른쪽에 위치하거나,

583
00:31:47,130 --> 00:31:48,150
새로운 레벨을 시작하게 됩니다.

584
00:31:48,150 --> 00:31:50,238
하지만 그것은 언제나
마지막 잎사귀일 것이다.

585
00:31:50,238 --> 00:31:51,780
삽입을 완료하면

586
00:31:51,780 --> 00:31:54,030
Q 크기에서 1을 뺀 위치에 삽입될 것입니다.

587
00:31:57,805 --> 00:31:59,830

하지만 이 위치만으로는 충분하지 않을 것 같습니다.

588
00:31:59,830 --> 00:32:01,840
우리는
리프에 임의의 항목을 삽입했습니다.

589
00:32:01,840 --> 00:32:04,890
하지만 이제는
최대 힙 속성을 더 이상 만족시키지 못할 수도 있습니다.

590
00:32:04,890 --> 00:32:08,110
그럼 제대로 작동하는지 확인해보고, 작동하지
않으면 수정해 봅시다.

591
00:32:08,110 --> 00:32:10,490
그게 우리가 할 줄 아는 거예요.

592
00:32:10,490 --> 00:32:12,220
하지만 이번에는

593
00:32:12,220 --> 00:32:23,960
로테이션조차 필요 없으니 정말
좋네요.

594
00:32:23,960 --> 00:32:25,710
그래서 저는

595
00:32:25,710 --> 00:32:29,190
max_heapify_up이라는 연산을 정의할 것입니다.

596
00:32:29,190 --> 00:32:33,170
이렇게 하면
맥스힙과 더 유사한 구조가 됩니다.

597
00:32:33,170 --> 00:32:39,810
우리는
i 값을 Q에서 1을 뺀 값부터 시작할 것입니다.

598
00:32:39,810 --> 00:32:43,860
하지만 이것은 재귀적으로 실행될 것이므로,
우리는

599
00:32:43,860 --> 00:32:49,290
노드 i,
특히 방금

600
00:32:49,290 --> 00:32:50,490
삽입된 노드를 살펴볼 것입니다.

601
00:32:50,490 --> 00:32:52,230
그렇다면 어떤 부분에서
법을 위반할 수 있을까요?

602
00:32:52,230 --> 00:32:58,790
음, 부모 키와 함께 봐야죠. 왜냐하면 우리가

603
00:32:58,790 --> 00:32:59,750
방금 여기에 어떤 키를 입력했는지 전혀 모르기 때문입니다.

604
00:32:59,750 --> 00:33:01,220
어쩌면 부모님 세대보다 못할지도 몰라요.

605
00:33:01,220 --> 00:33:02,210
그럼 우린 행복해.

606
00:33:02,210 --> 00:33:05,180
하지만 만약 그것이 부모보다 크다면
, 우리는 곤경에 처한 것이고,

607
00:33:05,180 --> 00:33:06,950
우리는 그것을 바로잡아야 합니다.

608
00:33:06,950 --> 00:33:23,090
부모 키에 있는 항목이
i 키보다 작으면...

609
00:33:25,736 --> 00:33:28,705
아, 키랑
이런 것들을 적는 걸 깜빡했네요.

610
00:33:28,705 --> 00:33:32,000
이것은 점
키와 점 키여야 합니다.

611
00:33:32,000 --> 00:33:37,190
왜냐하면 Q[i]는
키를 얻는 항목이기 때문입니다.

612
00:33:37,190 --> 00:33:38,660
이것이 최악의 경우입니다.

613
00:33:38,660 --> 00:33:41,360
부모의 키가
자식보다 작을 경우입니다.

614
00:33:41,360 --> 00:33:43,400
우리는 부모가
항상

615
00:33:43,400 --> 00:33:45,240
자식보다 크거나 같기를 바랐습니다.

616
00:33:45,240 --> 00:33:49,310
그렇다면
우리는 어떻게 해야 할까요?

617
00:33:49,310 --> 00:33:50,150
서로 바꿔보세요.

618
00:33:53,690 --> 00:33:58,640
i의 부모 Q를

619
00:33:58,640 --> 00:34:03,970

Q[i]로 바꿔봅시다. 훌륭합니다, 분필이 더 필요해요.

620
00:34:03,970 --> 00:34:06,100
이제 제대로 된 순서대로 정렬되었네요.

621
00:34:06,100 --> 00:34:08,650
이제 우리는

622
00:34:08,650 --> 00:34:10,449
해당 노드의 다른 자식 노드에 대해 생각해 봐야 합니다.

623
00:34:10,449 --> 00:34:13,040
그렇다면 그것의 부모는 어떻습니까?

624
00:34:13,040 --> 00:34:15,889
여기 숫자가 좀 있습니다.

625
00:34:15,889 --> 00:34:22,120
이게
5이고 이게 10이라고 가정해 봅시다.

626
00:34:22,120 --> 00:34:24,909
나는
이 사진에 대해 이전에 무엇을 알고 있었을까요?

627
00:34:24,909 --> 00:34:29,590
음, 저는 10이
새로 추가된 항목이라는 것을 알고 있습니다.

628
00:34:29,590 --> 00:34:32,380


629
00:34:32,380 --> 00:34:33,980
처음 삽입했을 때 규정 위반을 일으킬 수 있는 유일한 항목입니다.

630
00:34:33,980 --> 00:34:37,420
그러니까 제가
10번 노드를 옮기기 전에는,

631
00:34:37,420 --> 00:34:40,090

이 왼쪽 서브트리에 있는 모든 노드의 값이

632
00:34:40,090 --> 00:34:44,199

5 이하이고, 위쪽의 모든 노드의 값

633
00:34:44,199 --> 00:34:47,560
도 5라는 것을 알고 있었습니다.

634
00:34:47,560 --> 00:34:50,590
또한, 여기 있는 노드들의 값도
실제로

635
00:34:50,590 --> 00:34:51,219
5 이하였습니다. 방금 삽입한

636
00:34:51,219 --> 00:34:55,540
10번 노드를 제외하면
,

637
00:34:55,540 --> 00:34:57,139
이 힙은 올바른 구조였습니다.

638
00:34:57,139 --> 00:34:59,320
그러니까 5는 구분자 역할을 했어요.

639
00:34:59,320 --> 00:35:01,090

상위 트리에서 5보다 큰 항목들은 5보다

640
00:35:01,090 --> 00:35:04,180
크거나 같고
, 하위 트리에서는 5

641
00:35:04,180 --> 00:35:06,580
보다 작거나 같습니다.

642
00:35:06,580 --> 00:35:11,920
자, 제가 지금 하려는 것처럼

643
00:35:15,280 --> 00:35:21,310
5번과 10번 아이템을 바꾸고 나면
, 10번은 여기 위에, 5번은 여기가 될 거예요.

644
00:35:21,310 --> 00:35:23,350
그리고 이제야 깨달았죠,
좋아, 이 간선은

645
00:35:23,350 --> 00:35:26,260
이제 10이
5보다 크거나 같으니 정상이야.

646
00:35:26,260 --> 00:35:28,690
하지만 이 간선이 정상인
이유는, 원래도 정상이었는데

647
00:35:28,690 --> 00:35:31,600

부모 간선의 크기만 키웠기 때문이기도 해.

648
00:35:31,600 --> 00:35:34,540
이 부분이 어쩌면 안 좋을 수도 있습니다.

649
00:35:34,540 --> 00:35:35,665
그래서 우리는

650
00:35:39,140 --> 00:35:41,810
부모 클래스에 대해 재귀 호출을 해야 합니다.  그게 전부입니다

651
00:35:45,070 --> 00:35:46,470
.

652
00:35:46,470 --> 00:35:47,845
그래서 우리는 이 부분을 수정했습니다.

653
00:35:47,845 --> 00:35:49,720
처음에는 이 현상이
잎의 맨 아래쪽에서 발생합니다.

654
00:35:49,720 --> 00:35:52,150
하지만 일반적으로
우리가

655
00:35:52,150 --> 00:35:56,350
삽입한 항목인 x를 가져오면,
그것은 마지막 잎에서 시작하여 한동안

656
00:35:56,350 --> 00:35:58,150
거품처럼
올라올 수 있습니다.

657
00:35:58,150 --> 00:35:59,858
그리고

658
00:35:59,858 --> 00:36:01,660
만약
새로운 최대값을 삽입한다면, 문제가 근본 원인까지 도달할 수도 있을 겁니다.

659
00:36:01,660 --> 00:36:03,610
하지만 단계가 올라갈수록 수치는
1씩 증가합니다.

660
00:36:03,610 --> 00:36:06,730
따라서
이 모든 것의 실행 시간은 트리

661
00:36:06,730 --> 00:36:12,228
의 높이
, 즉 log n입니다.

662
00:36:12,228 --> 00:36:14,770
그리고

663
00:36:14,770 --> 00:36:16,270
만약 이 항목이 움직임을 멈춘다면, 잠재적으로 오류가 발생할 수 있는 항목은 이 하나뿐이므로,

664
00:36:16,270 --> 00:36:18,190
우리는 방금 이 항목이

665
00:36:18,190 --> 00:36:19,990
최대 힙 속성을 만족하는지 확인한 것입니다.

666
00:36:19,990 --> 00:36:21,610
루트에 도달하면

667
00:36:21,610 --> 00:36:23,368

최대 힙 속성을 만족하는지 여부도 확인할 수 있습니다.

668
00:36:23,368 --> 00:36:25,160

제가 여기에 적지 않은 기본 경우가 하나 있는데,

669
00:36:25,160 --> 00:36:30,760
i가 0이면
루트에 도달한 것이고, 계산이 끝난 것입니다.

670
00:36:30,760 --> 00:36:34,413
그러면
귀납법을 통해 이것이 옳다는 것을 증명할 수 있습니다.  처음에 딱

671
00:36:34,413 --> 00:36:36,830
한 가지 물건이
잘못된 위치에 놓여 있었습니다.

672
00:36:36,830 --> 00:36:38,480
그리고 우리는 그것을 적절한 위치에 놓았습니다.  이동할

673
00:36:38,480 --> 00:36:42,770
수 있는 위치는 많지만
, 우리는 그것을 가장

674
00:36:42,770 --> 00:36:46,040

적절하고

675
00:36:46,040 --> 00:36:48,500

최대 힙 속성을 만족하는 조상 위치로 옮기겠습니다. 알겠죠?

676
00:36:48,500 --> 00:36:50,180
그러니까 삽입이라는 뜻이죠.

677
00:36:50,180 --> 00:37:03,000
삭제 기능은 거의
동일합니다. delete_min이라고 해야 하는데,

678
00:37:14,010 --> 00:37:17,307
죄송합니다. delete_max라고 해야겠네요. 감사합니다.

679
00:37:17,307 --> 00:37:19,140
물론 최대값

680
00:37:19,140 --> 00:37:20,130
대신 최소값에 대해 이러한 모든 사항을 정의할 수 있습니다.

681
00:37:20,130 --> 00:37:21,360
모든 것이 똑같이 작동합니다.

682
00:37:21,360 --> 00:37:23,160


683
00:37:23,160 --> 00:37:25,320
어떤 걸 하고 있는지 기억이 잘 안 나네요.

684
00:37:25,320 --> 00:37:28,220
절대 전환하지 마세요.
delete_min을 수행하는 데 max-heap을 사용할 수 없습니다.

685
00:37:28,220 --> 00:37:29,970
최소힙을 사용하여
delete_max를 수행할 수는 없지만,

686
00:37:29,970 --> 00:37:32,790

최소힙을 사용하여 delete_min을 수행할 수는 있습니다.

687
00:37:32,790 --> 00:37:35,200
괜찮아요.  앞서

688
00:37:35,200 --> 00:37:40,680
말했듯이,
우리가 실제로 삭제하는 방법을 아는 유일한 노드는

689
00:37:40,680 --> 00:37:42,520

마지막 레벨의 마지막 리프 노드, 즉

690
00:37:42,520 --> 00:37:43,920
배열의 끝 노드뿐입니다.

691
00:37:43,920 --> 00:37:47,550
배열은 그런 것들을
효율적으로 삭제할 수 있기 때문입니다.

692
00:37:47,550 --> 00:37:50,100
우리가
삭제해야 할 것은 루트 항목입니다.

693
00:37:50,100 --> 00:37:52,380
왜냐하면 루트 항목은 항상

694
00:37:52,380 --> 00:37:54,490

배열의 첫 번째 위치에 있는 최대값이기 때문입니다.

695
00:37:54,490 --> 00:37:55,890
그럼 우리는 어떻게 해야 할까요?

696
00:37:55,890 --> 00:38:00,323
서로 바꿔보는 게 우리 늘 쓰는 방법이지.

697
00:38:00,323 --> 00:38:01,740
제가 생각하기에
대량 생산의 가장 좋은 점은

698
00:38:01,740 --> 00:38:03,370

교대 근무를 전혀 할 필요가 없다는 것입니다.

699
00:38:03,370 --> 00:38:05,370
우리는
스왑 작업만 할 건데, 이건

700
00:38:06,840 --> 00:38:07,650
이진 트리에서도 해야 했던 작업이에요.

701
00:38:11,087 --> 00:38:18,780
마지막 항목의 Q[0]와 함께 -

702
00:38:18,780 --> 00:38:19,440
좋습니다, 완료되었습니다.

703
00:38:19,440 --> 00:38:22,330
이제 마지막으로
삭제하고 싶은 항목이 남았습니다.

704
00:38:22,330 --> 00:38:30,420
그래서 우리는 delete_last, 파이썬에서는 pop이라고 하는 함수를 사용해서 마지막 항목을 삭제합니다. 그러면

705
00:38:30,420 --> 00:38:32,340
이제
가장 큰 항목이 삭제된 것입니다.

706
00:38:32,340 --> 00:38:36,210
물론, 삽입할 때처럼
max-heap 속성도 잘못 설정했을 가능성이 있습니다

707
00:38:36,210 --> 00:38:40,230
.

708
00:38:40,230 --> 00:38:43,410
그래서 삽입 기능을 사용하면
마지막 잎을 추가할 수 있습니다.  자

709
00:38:43,410 --> 00:38:46,050
, 지금 우리가 하려는 건
마지막 잎을...

710
00:38:46,710 --> 00:38:48,300
제가
잘못된 그림을 가리키고 있네요.

711
00:38:48,300 --> 00:38:50,610
이 나무로 다시 돌아가 보겠습니다.

712
00:38:50,610 --> 00:38:55,530
우리가 한 일은 항목 J를
A와 교환한 것입니다. 그래서 문제는 이제...

713
00:38:55,530 --> 00:38:57,450
그리고 나서 우리는 이 노드를 삭제했습니다.

714
00:38:57,450 --> 00:38:59,910
문제는 이제
루트 노드가

715
00:38:59,910 --> 00:39:01,830
매우 작은 키를 가지고 있을 가능성이 있다는 것입니다.

716
00:39:01,830 --> 00:39:04,900
왜냐하면 지금 여기에 있는 열쇠는
바로 여기,

717
00:39:04,900 --> 00:39:06,150
나무 맨 아래쪽에 있던 것이기 때문입니다.

718
00:39:06,150 --> 00:39:08,910
직관적으로 보면,
그 값은 작습니다.

719
00:39:08,910 --> 00:39:10,630
이것이
최댓값이어야 하는데,

720
00:39:10,630 --> 00:39:12,700
우리는
제곱근에 작은 값을 넣었을 뿐입니다.

721
00:39:12,700 --> 00:39:14,040
그럼 우리는 어떻게 해야 할까요?

722
00:39:14,040 --> 00:39:16,540
아래로 힙화합니다.

723
00:39:16,540 --> 00:39:19,050
우리는 그 항목을 가져와서

724
00:39:21,390 --> 00:39:24,760
힙의
최대 크기 조건을 만족할 때까지 트리 아래쪽으로 밀어 넣을 것입니다.

725
00:39:24,760 --> 00:39:30,960
그래서 이것은
max_heapify_down이 될 것입니다.

726
00:39:30,960 --> 00:39:34,590
우리는
루트인 0번 위치부터 시작할 것입니다.

727
00:39:38,120 --> 00:39:45,840
그리고 max_heapify_down은
재귀 알고리즘이 될 것입니다.

728
00:39:45,840 --> 00:39:47,990
그럼 우리는
어떤 위치 i에서 시작할 겁니다.

729
00:39:47,990 --> 00:39:49,940
그리고 처음에는 그것이 근본 원인입니다.  이제

730
00:39:49,940 --> 00:39:53,955
우리는
위치 i와 그 두

731
00:39:53,955 --> 00:39:54,455
자식 요소를 살펴볼 것입니다.  자,

732
00:39:57,350 --> 00:40:01,090

여기에 아주 작은 값, 예를 들어 0을 넣어 봅시다.

733
00:40:01,090 --> 00:40:04,180
그리고
자식 노드가 5와 10이라고 해 봅시다. 우리는 그들의 상대적인 순서를

734
00:40:04,180 --> 00:40:06,220
모릅니다. (좀

735
00:40:06,220 --> 00:40:10,420
더 일반적인 표현을 위해 순서를 바꿔 보겠습니다. 왜냐하면
이것은

736
00:40:10,420 --> 00:40:12,700
이진 탐색
트리처럼 보이지는 않지만요

737
00:40:12,700 --> 00:40:14,060
.)

738
00:40:14,060 --> 00:40:17,070
하지만 그중 하나는 어떤 순서로든
다른 하나보다 크거나 같습니다

739
00:40:17,070 --> 00:40:18,920
.

740
00:40:18,920 --> 00:40:21,910
그렇다면 저는
이 지역 상황을 개선하기 위해 무엇을 하고 싶을까요?

741
00:40:25,370 --> 00:40:26,840
네, 바꾸고 싶어요.

742
00:40:26,840 --> 00:40:28,490
그리고 제가 위치를 바꿀 수도 있겠네요.

743
00:40:28,490 --> 00:40:29,900
0은 분명히 잘못된 위치에 있습니다.

744
00:40:29,900 --> 00:40:31,400

나무 아래쪽으로 더 내려가야 합니다.

745
00:40:31,400 --> 00:40:34,280
0과
5를 바꾸거나 0과 10을 바꿀 수 있어요.

746
00:40:34,280 --> 00:40:35,810
어느 쪽을 바꾸면 될까요?

747
00:40:35,810 --> 00:40:36,310
10. 5

748
00:40:39,010 --> 00:40:43,435
로 그림을 그릴 수도 있지만
, 그러면 그림이 마음에 들지 않을 거예요.

749
00:40:46,180 --> 00:40:46,888
왜 10이죠?

750
00:40:46,888 --> 00:40:48,430

더 큰 것으로 작업을 진행하고 싶습니다.

751
00:40:48,430 --> 00:40:51,010
그러면 이쪽
가장자리도,

752
00:40:51,010 --> 00:40:52,660
저쪽 가장자리도 모두 만족스러울 것입니다
.

753
00:40:52,660 --> 00:40:56,710
만약 제가 저기 있는 5를 다른 값으로 바꾸면,
5/10의 모서리가 마음에 안 들 거예요.

754
00:40:56,710 --> 00:40:58,460
이는
최대힙 속성을 만족시키지 못할 것입니다.

755
00:40:58,460 --> 00:41:01,270
그래서 한 번의 스왑으로
최대 힙 속성을 수정할 수 있습니다.

756
00:41:01,270 --> 00:41:05,680
다만, 0은
자식들에게 불만을 가질 수도 있다는 점을 다시 한번 강조합니다.

757
00:41:05,680 --> 00:41:08,380
0번은
잘못된 위치에 있던 항목이었습니다.

758
00:41:08,380 --> 00:41:10,210
그래서
더 아래로 내려가야만 했습니다.

759
00:41:10,210 --> 00:41:11,560
하지만 5는

760
00:41:11,560 --> 00:41:12,790
움직이지도 않았어요.

761
00:41:12,790 --> 00:41:13,600
그래서 행복한 거죠.

762
00:41:13,600 --> 00:41:16,960
이
하위 트리에 있는 모든 것은 정상입니다.

763
00:41:16,960 --> 00:41:18,460
부모님은 어떠신가요?

764
00:41:18,460 --> 00:41:20,950
음, 생각해 보면
,

765
00:41:20,950 --> 00:41:23,890

0을 추가하기 전,

766
00:41:23,890 --> 00:41:26,770
또는 0을 너무 높은 위치에 두기 전에는 모든 것이 올바른 힙 구조였기 때문에,
이 모든 노드들은

767
00:41:26,770 --> 00:41:33,820

조상 경로상에서 10 이상의 값을 가지게 될 것입니다.

768
00:41:33,820 --> 00:41:36,550
그리고 이 노드들은 모두 이전에는
10 이하이었고

769
00:41:36,550 --> 00:41:38,380
,
5인 경우만 예외였습니다.

770
00:41:38,380 --> 00:41:41,510
따라서 이는 여전히 사실입니다.

771
00:41:41,510 --> 00:41:43,880
하지만 이 나무는 행복해 보입니다.

772
00:41:43,880 --> 00:41:45,200
이 나무는 여전히 불행할지도 모릅니다.

773
00:41:45,200 --> 00:41:47,450
0은 더 아래로
눌러야 할 수도 있습니다.

774
00:41:47,450 --> 00:41:50,300
그게 바로
재귀 호출이 될 겁니다.  자,

775
00:41:50,300 --> 00:41:56,650
그럼 여기서 확인해 볼까요?

776
00:42:06,470 --> 00:42:09,650
기본 경우는
i가 리프 노드인 경우이고, 그러면 작업이 완료됩니다.  그

777
00:42:09,650 --> 00:42:11,270

아래에는 아무것도 없기 때문입니다.

778
00:42:13,900 --> 00:42:17,100
따라서
i에는 자식 요소가 없으므로 최대힙 속성을 만족합니다

779
00:42:17,100 --> 00:42:18,750
.

780
00:42:18,750 --> 00:42:24,400
그렇지 않으면,

781
00:42:26,700 --> 00:42:29,640

i의 왼쪽과 오른쪽에 있는 두 아이 중 왼쪽에 있는 잎을 살펴보겠습니다. (죄송합니다, 잎이 아니라 왼쪽입니다.)

782
00:42:29,640 --> 00:42:30,960
내가 존재하지 않는다면 말이지.

783
00:42:30,960 --> 00:42:32,000
그럼 무시하세요.

784
00:42:32,000 --> 00:42:36,000
하지만 존재하는 두 자식 중에서

785
00:42:36,000 --> 00:42:42,327

키 값 Q[j].key가 가장 큰 자식을 찾습니다.

786
00:42:46,840 --> 00:42:49,090
우리 예시에서는 10이었습니다.

787
00:42:49,090 --> 00:42:52,040
그리고 만약 이
항목들이 순서대로 되어 있지 않거나,

788
00:42:52,040 --> 00:42:54,460
우리가 만족시키지 못한다면,

789
00:42:54,460 --> 00:42:56,710
즉
만족시킬 수 있는 것보다 더 큰 값이 필요하다면,

790
00:42:56,710 --> 00:43:00,550
Q[j]보다 작다는 것은 여기서
최대힙 속성의 반대가 될 것입니다

791
00:43:00,550 --> 00:43:03,850
.

792
00:43:03,850 --> 00:43:06,560
최대힙 속성이 위반되면

793
00:43:06,560 --> 00:43:15,160

Q[i]와 Q[j]를 교환하여 이를 수정하고

794
00:43:21,700 --> 00:43:24,980
j에 대해 재귀적으로 j를 호출합니다.

795
00:43:24,980 --> 00:43:25,560
그게 다예요.

796
00:43:25,560 --> 00:43:26,460
정말 대칭적이네요.

797
00:43:26,460 --> 00:43:28,460
삽입 과정은 부모 요소가 하나
뿐이기 때문에 조금 더 간단했습니다

798
00:43:28,460 --> 00:43:29,780
.

799
00:43:29,780 --> 00:43:31,610
Delete_min, 왜냐하면 아래로 밀어내고 있기 때문에

800
00:43:31,610 --> 00:43:32,760
자식이 두 개 있습니다.

801
00:43:32,760 --> 00:43:34,140
우리는 하나를 선택해야 해요.

802
00:43:34,140 --> 00:43:36,470
하지만 분명한
선택, 더 중요한 선택이 있습니다.

803
00:43:36,470 --> 00:43:38,930
그리고 다시 말하지만, 이 알고리즘,
이 전체 과정은

804
00:43:38,930 --> 00:43:40,980

트리의 높이인 h차 시간(

805
00:43:40,980 --> 00:43:44,410
log n)이 걸립니다. 왜냐하면
노드가 마치 거품처럼 아래로 흘러내리기 때문입니다.

806
00:43:44,410 --> 00:43:45,410
어느 시점에서 멈추게 됩니다.

807
00:43:45,410 --> 00:43:47,480
멈추면
최대힙 속성이

808
00:43:47,480 --> 00:43:49,050
충족되었음을 알 수 있습니다.

809
00:43:49,050 --> 00:43:51,470
그리고
과정을 따라가면서 귀납적으로 확인해 보면, 이전에도 그랬듯이

810
00:43:51,470 --> 00:43:53,000

최대 힙의 다른 모든 속성들도

811
00:43:53,000 --> 00:43:57,400
만족될 것입니다
.

812
00:43:57,400 --> 00:43:59,670
그래서
우리가 여기서 할 수 있었던 일은 거의 강제적인 것이었어요.

813
00:43:59,670 --> 00:44:01,420
놀라운 점은

814
00:44:01,420 --> 00:44:04,240


815
00:44:04,240 --> 00:44:05,800
최대 힙 속성을 만족하는 완전 이진 트리를 실제로 유지할 수 있다는 것입니다.

816
00:44:05,800 --> 00:44:08,560
하지만 일단 그 사실을 알게 되면
알고리즘은 더 이상 작동하지 않게 됩니다.

817
00:44:08,560 --> 00:44:09,805
배열이 있기 때문입니다.

818
00:44:09,805 --> 00:44:11,680
우리가 할 수 있는 유일한 일은 마지막 항목을
삽입하고 삭제하는 것입니다

819
00:44:11,680 --> 00:44:12,585
.

820
00:44:12,585 --> 00:44:14,710
그래서 우리는 그 일이 제대로 진행되도록 하기 위해
순서대로 물건들을 그쪽으로 옮기

821
00:44:14,710 --> 00:44:18,170
거나, 반대로 그쪽에서 물건들을 빼내야 합니다
.

822
00:44:18,170 --> 00:44:20,500
그리고 나머지는 해당

823
00:44:20,500 --> 00:44:22,330
부동산을 현지에서 수리할 수 있는지 확인하는 것입니다.

824
00:44:24,930 --> 00:44:27,000
시원한.

825
00:44:27,000 --> 00:44:32,300
거의 다 됐지만,
우리가 원했던 것과는 조금 다르네요.

826
00:44:32,300 --> 00:44:36,370
이제 우리 힙에는 log n amortize
insert와 delete_max가 있습니다

827
00:44:36,370 --> 00:44:39,330
.

828
00:44:39,330 --> 00:44:41,260
우리는 아직
선형 구축에 대해 다루지 않았습니다.

829
00:44:41,260 --> 00:44:45,070
현재로서는
n번 삽입할 경우 n log n이 됩니다.

830
00:44:45,070 --> 00:44:47,830
그리고 우리는 아직
이것을 제자리 정렬

831
00:44:47,830 --> 00:44:49,030
알고리즘으로 만드는 방법을 다루지 않았습니다.

832
00:44:49,030 --> 00:44:52,660
그럼 각각에 대해 간략하게 설명해 드리겠습니다.

833
00:44:52,660 --> 00:44:56,490
첫 번째는 이미 준비된 것 같습니다.

834
00:44:56,490 --> 00:45:01,530
그렇다면 이
알고리즘을 현장에서 어떻게 구현할까요?  그건 원

835
00:45:01,530 --> 00:45:04,215

하지만, 이건 필요 없어요.

836
00:45:06,720 --> 00:45:09,820
우리는
우선순위 큐 정렬을 따르고자 합니다.

837
00:45:09,820 --> 00:45:10,760
어쩌면 난 정말 그걸 원하는지도 몰라.

838
00:45:16,570 --> 00:45:22,060
하지만 저는
어레이 크기를 늘렸다 줄였다 하고 싶지 않아요.  우선

839
00:45:22,060 --> 00:45:24,235

배열 자체부터 살펴보겠습니다.

840
00:45:36,500 --> 00:45:37,675
그래서 이것이 마련되었습니다.  자

841
00:45:41,977 --> 00:45:43,810

, 그럼 이제

842
00:45:43,810 --> 00:45:47,548
정렬하고 싶은 배열을 제시해 보겠습니다.

843
00:45:47,548 --> 00:45:48,340
그건 제게 주어진 거예요.

844
00:45:48,340 --> 00:45:50,400
그것이
우선순위 큐 정렬의 입력입니다.

845
00:45:53,650 --> 00:45:56,320
제가 원하는 것은
그것으로 우선순위 큐를 만드는 것입니다.

846
00:45:56,320 --> 00:45:57,820
처음에는 비어 있습니다.

847
00:45:57,820 --> 00:46:02,600
그리고 나서
항목들을 하나씩 넣고 싶다고 가정해 봅시다.

848
00:46:02,600 --> 00:46:05,000
그래서 일반적으로
제가 하려는 것은

849
00:46:05,000 --> 00:46:09,018
Q가
A의 접두사라는 것을 유지하는 것입니다.

850
00:46:09,018 --> 00:46:10,560
이것이 제
우선순위 큐가 될 것입니다.  이 접두사, 즉

851
00:46:10,560 --> 00:46:15,110

하위 배열에 위치하게 될 것입니다.

852
00:46:15,110 --> 00:46:17,240
그럼 새 항목을 어떻게 추가하나요?

853
00:46:17,240 --> 00:46:20,510
음, 저는 그냥 점진적으로 늘립니다.

854
00:46:20,510 --> 00:46:29,090
삽입 작업을 하려면 먼저
Q의 크기를 증가시켜야 합니다.

855
00:46:29,090 --> 00:46:31,025
그러면
A에서 다음 항목을 가져와

856
00:46:31,025 --> 00:46:32,540
Q에 삽입하게 됩니다.

857
00:46:32,540 --> 00:46:37,430
그리고
삽입 코드를 살펴보면, 가장 먼저 하려고

858
00:46:37,430 --> 00:46:39,470
했던 작업은

859
00:46:39,470 --> 00:46:40,600
배열의 끝에 항목을 추가하는 것이었습니다.

860
00:46:40,600 --> 00:46:43,940
그래서 우리는
실제 작업은 전혀 하지 않고,

861
00:46:43,940 --> 00:46:44,697
개념적인 작업만 했습니다.

862
00:46:44,697 --> 00:46:46,280
우리는 그냥 "아,
우리 Q 값이 하나 더 크네"라고 말했을 뿐이에요.  팔

863
00:46:46,280 --> 00:46:46,780
!

864
00:46:46,780 --> 00:46:49,430
이제 이것이
배열의 끝입니다.

865
00:46:49,430 --> 00:46:52,480
사실상 더 이상 상각이 필요하지 않습니다.
왜냐하면

866
00:46:52,480 --> 00:46:54,230
배열 크기를 조정하는 것이 아니라, 단지

867
00:46:54,230 --> 00:46:57,050
Q가 이제 조금
더 큰 접두사라고 말하는 것뿐이기 때문입니다.

868
00:46:57,050 --> 00:46:59,450

A의 다음 항목을 흡수할 뿐입니다.

869
00:46:59,450 --> 00:47:06,330
마찬가지로 delete_max는

870
00:47:06,330 --> 00:47:12,260
결국
Q의 크기를 감소시킵니다. 왜 이것이 괜찮은 걸까요?

871
00:47:12,260 --> 00:47:16,520
왜냐하면 delete_max 연산의 마지막 단계에서,

872
00:47:16,520 --> 00:47:19,520
완전히 끝은 아니지만
거의 끝 단계에서

873
00:47:19,520 --> 00:47:22,160

배열의 마지막 항목을 삭제했기 때문입니다.

874
00:47:22,160 --> 00:47:25,310
그래서 방금
마지막 항목을 삭제하는 것을 감소 ​​연산으로 바꿨는데,

875
00:47:25,310 --> 00:47:28,290
이렇게 하면
Q 값이 1만큼 줄어듭니다.

876
00:47:28,290 --> 00:47:31,430
이는
마지막 항목 앞에 놓는 것과 정확히 같은 효과를 냅니다.

877
00:47:31,430 --> 00:47:34,520
하지만 이제는 시간이 일정하게 유지되고,
최악의 경우 상각되지 않습니다.

878
00:47:34,520 --> 00:47:37,790
결과적으로 우리는
실제로 동적 배열을 생성하지 못하게 됩니다.

879
00:47:37,790 --> 00:47:40,140
우리는
그것을 위해 A의 일부만 사용합니다.

880
00:47:40,140 --> 00:47:41,645
그래서 앞으로는

881
00:47:41,645 --> 00:47:43,895
모든 항목을
우선순위 대기열에 넣은

882
00:47:43,895 --> 00:47:45,620
다음 하나씩 제거하기 시작할 겁니다.

883
00:47:45,620 --> 00:47:49,790
우리는 그것들을 제거할 때,
가장 중요한 항목부터 먼저 제거하고

884
00:47:49,790 --> 00:47:52,100
여기에 넣은 다음,
그다음으로 중요한 항목, 그다음으로

885
00:47:52,100 --> 00:47:53,420
중요한 항목 순으로 제거합니다.

886
00:47:53,420 --> 00:47:55,010
최소 필수품은
여기에 있습니다.  자

887
00:47:55,010 --> 00:47:56,150
, 이렇게 하면 해결됩니다.

888
00:47:56,150 --> 00:48:00,080
제가
최소 힙 대신 최대 힙을 사용한 가장 큰 이유는, 최종적으로 배열이 위쪽으로

889
00:48:00,080 --> 00:48:04,100

정렬되어

890
00:48:04,100 --> 00:48:05,300
최댓값이 맨 끝에 오도록 하기 위함입니다.

891
00:48:05,300 --> 00:48:07,400
우리는 항상
마지막에 물건들을 버리기 때문입니다.

892
00:48:07,400 --> 00:48:10,200
먼저 최댓값을 삭제합니다.

893
00:48:10,200 --> 00:48:15,180
이것이 바로
일반적으로 힙 정렬이라고 불리는 것입니다.

894
00:48:15,180 --> 00:48:18,750
이와 같은 요령을
삽입 정렬과 선택

895
00:48:18,750 --> 00:48:21,360
정렬에도 적용할 수 있으며, 실제로 배열의 접두사를 기준으로 작동하는
삽입 정렬 및 선택

896
00:48:21,360 --> 00:48:23,820
정렬 알고리즘을 얻을 수 있습니다

897
00:48:23,820 --> 00:48:26,920
.

898
00:48:26,920 --> 00:48:29,280
좋습니다. 이제

899
00:48:29,280 --> 00:48:31,110
우리는 위에 표시된 y 값을 달성했습니다.
이는

900
00:48:31,110 --> 00:48:34,390
n log n 정렬
알고리즘을 제자리에서 실행하는 것입니다.

901
00:48:34,390 --> 00:48:35,640
그래서 우리의 주요 목표는

902
00:48:35,640 --> 00:48:37,160
힙 정렬이었습니다.

903
00:48:37,160 --> 00:48:46,150
잠깐 말씀드리자면, 영리한 트릭을 사용하면
선형 시간 안에 힙을 구축할 수 있습니다

904
00:48:46,150 --> 00:48:47,930
.

905
00:48:47,930 --> 00:48:50,140
따라서 항목을 한 번에 하나씩 삽입하면

906
00:48:50,140 --> 00:48:53,230

배열 아래쪽으로 삽입하는 것과 같습니다.

907
00:48:53,230 --> 00:48:57,040
그리고 아이템을 넣을 때마다
나무 위로 올라가야 해요.

908
00:48:57,040 --> 00:49:04,170
따라서 이는
각 노드의 깊이의 합이 됩니다.

909
00:49:04,170 --> 00:49:08,520
그렇게 하면 n log n이 됩니다.

910
00:49:08,520 --> 00:49:12,150
이것은 log i의 i에 대한 합입니다.

911
00:49:12,150 --> 00:49:14,610
그 결과는 n log n이 됩니다.

912
00:49:14,610 --> 00:49:17,310
이것은 n 팩토리얼의 로그입니다.

913
00:49:17,310 --> 00:49:20,220
진짜 비결은

914
00:49:20,220 --> 00:49:21,810
모든 항목을
한 번에 추가하고 아무것도 힙화하지 않은

915
00:49:21,810 --> 00:49:24,805

다음,

916
00:49:24,805 --> 00:49:28,420
아래에서 위로 힙화하는 것입니다. 아니, 정확히 말하면 아래에서 위로 힙화하는 것입니다.

917
00:49:28,420 --> 00:49:31,530
그래서 우리는 지금 쌓아 올리고 있는 중입니다.  자

918
00:49:31,530 --> 00:49:35,190
, 이제 아래로 쌓아 올리겠습니다
.

919
00:49:35,190 --> 00:49:37,080
놀랍게도, 그게 더 낫습니다.

920
00:49:37,080 --> 00:49:42,150
이는 노드들의 높이의 합이기 때문입니다
.

921
00:49:42,150 --> 00:49:43,810
그리고 그것은 선형적인 것으로 밝혀졌습니다.

922
00:49:43,810 --> 00:49:45,090
분명하지 않다.

923
00:49:45,090 --> 00:49:49,740
하지만 직관적으로 깊이를 생각하면
이것은 0이고, 이것은 log n

924
00:49:49,740 --> 00:49:51,450
이며, 우리는 엄청나게 많은
잎을 가지고 있습니다.

925
00:49:51,450 --> 00:49:54,220
그러니까 최상위 레벨에서
보면, 우리는 n log n을 지불하고 있는 거죠,

926
00:49:54,220 --> 00:49:54,720
그렇죠?  그

927
00:49:54,720 --> 00:49:57,540
이유는 그것들이 n개 있고,
각각의 비용이 log n이기 때문입니다.

928
00:49:57,540 --> 00:49:59,850
여기, 잎
수준에서는 일정한 값을 지불하고 있습니다.

929
00:49:59,850 --> 00:50:03,480

잎의 높이가 1이기 때문에

930
00:50:03,480 --> 00:50:05,250
, 여기서 뿌리의 높이는
log n입니다.

931
00:50:05,250 --> 00:50:06,480
이게 더 낫습니다.

932
00:50:06,480 --> 00:50:09,530
지금 우리는 흔하디흔한
물건에 대해 아주 적은 금액을 지불하고 있습니다

933
00:50:09,530 --> 00:50:11,040
.  기하

934
00:50:11,040 --> 00:50:12,730

급수는 아니지만,

935
00:50:12,730 --> 00:50:15,090
선형적인 수열인 것으로 밝혀졌습니다.

936
00:50:15,090 --> 00:50:17,790
이렇게 하면
선형적으로 힙을 구축할 수 있습니다.

937
00:50:17,790 --> 00:50:23,450

시퀀스 AVL 트리에 대한 질문으로 돌아가서, 힙과 동일한 제약 조건을 모두

938
00:50:23,450 --> 00:50:25,500
얻을 수 있다는 사실이 밝혀졌습니다.

939
00:50:25,500 --> 00:50:27,750
단, 제자리 저장(
in-place) 부분은 예외입니다.

940
00:50:27,750 --> 00:50:30,330
시퀀스
AVL 트리에

941
00:50:30,330 --> 00:50:33,150
항목을 임의의
순서로 저장하고 최대값을 추가하는 방식은 다소

942
00:50:33,150 --> 00:50:36,210
기발한 아이디어입니다.

943
00:50:36,210 --> 00:50:38,490
하지만 이는
선형적인 구축 시간을 제공하기도 합니다.

944
00:50:38,490 --> 00:50:40,710
네,
노트에 다른 재밌는 내용도 있네요.

945
00:50:40,710 --> 00:50:42,980
하지만 거기서 마치겠습니다.

