1
00:00:00,000 --> 00:00:12,580
[끽끽거리는 소리]
[소리] [딸깍]

2
00:00:12,580 --> 00:00:15,970
에릭 드메인: 네, 환영합니다.
006 자료구조로 돌아가기.

3
00:00:15,970 --> 00:00:19,330
오늘 우리는
다른 유형을 생각해 봅시다.

4
00:00:19,329 --> 00:00:22,909
트리 형태의 데이터 구조,
힙이라고 불리는 것, 즉 바이너리 힙입니다.

5
00:00:22,910 --> 00:00:26,710
이를 통해 우리는 결정할 수 있을 것입니다.
정렬 문제를 새로운 방식으로 접근합니다.

6
00:00:26,710 --> 00:00:30,228
먼저 다시 한번 말씀드리겠습니다.
당신을 위한 한 부분:

7
00:00:30,228 --> 00:00:32,020
우리가 가진 문제
오늘 우리가 풀어볼 문제는 다음과 같습니다.

8
00:00:32,020 --> 00:00:33,760
우선순위 큐라고 합니다.

9
00:00:33,759 --> 00:00:34,802
이것이 인터페이스입니다.

10
00:00:34,802 --> 00:00:36,219
우리는 몇 가지를 보게 될 것입니다
데이터 구조,

11
00:00:36,219 --> 00:00:40,070
하지만 가장 중요한 한 가지
오늘날의 데이터 구조.

12
00:00:40,070 --> 00:00:44,649
그리고 이것은 부분집합입니다.
설치된 인터페이스.

13
00:00:47,229 --> 00:00:49,419
부분집합은 흥미롭습니다.
잠재적으로 우리는

14
00:00:49,420 --> 00:00:53,750
우리는 그 문제들을 더 잘 해결할 수 있습니다.
더 빠르고, 더 쉽게.

15
00:00:53,750 --> 00:00:57,880
그러니까, 당신은 알아차리셨군요...
당신은 알아차려야 합니다

16
00:00:57,880 --> 00:01:00,670
이 모든 작업들,
다만 우리는 보통 그렇지 않다는 점만 빼면요.

17
00:01:00,670 --> 00:01:02,929
우리는 최대 작동을 강조합니다.

18
00:01:02,929 --> 00:01:06,189
그래서 저희는 관심이 있습니다.
여러 물건을 보관할 때.  안에

19
00:01:06,189 --> 00:01:10,060
그것들은 우리가 가진 열쇠입니다.
우리가 우선순위로 여기는 것들입니다.

20
00:01:10,060 --> 00:01:13,840
그리고 우리는 할 수 있기를 원합니다
가장 높은 우선순위를 가진 요소를 결정하십시오.

21
00:01:13,840 --> 00:01:17,350
우리 세트에서 해당 항목을 삭제합니다.

22
00:01:17,349 --> 00:01:19,250
그리고
여기에는 여러 가지 동기가 있습니다.

23
00:01:19,250 --> 00:01:21,370
라우터를 가지고 계실 수도 있습니다.
패킷이 라우터에 도착합니다.

24
00:01:21,370 --> 00:01:23,060
그들은 서로 다릅니다
우선순위.

25
00:01:23,060 --> 00:01:25,090
원하세요?
가장 우선순위가 높은 것부터 처리하세요.

26
00:01:25,090 --> 00:01:28,359
아니면 가지고 계신가요?
컴퓨터에서 실행 중인 프로세스가 있습니다.

27
00:01:28,359 --> 00:01:32,620
시작하다
싱글 스레드 — 싱글 코어,

28
00:01:32,620 --> 00:01:34,850
그리고 당신은 선택해야 합니다.
다음으로 어떤 것을 실행할까요?

29
00:01:34,848 --> 00:01:37,839
대개
우선순위가 높은 프로세스가 먼저 실행됩니다.

30
00:01:37,840 --> 00:01:42,729
아니면 시뮬레이션을 하려는 건가요?
이벤트가 발생하는 시스템

31
00:01:42,729 --> 00:01:44,799
서로 다른 시기에,
그리고 처리하고 싶으신가요?

32
00:01:44,799 --> 00:01:46,989
다음 이벤트는 시간 순서대로 나열됩니다.

33
00:01:46,989 --> 00:01:50,469
이것들은 모두 예시일 뿐입니다.
우선순위 큐 인터페이스.

34
00:01:50,469 --> 00:01:52,420
우리는 프로그램도 보게 될 것입니다.
이 수업에서,

35
00:01:52,420 --> 00:01:54,158
그래프 알고리즘에 대해 이야기할 때 말이죠.

36
00:01:54,158 --> 00:01:56,739
하지만 우리가 가진 두 가지 주요 사항은 다음과 같습니다.
저희는 지원하고 싶습니다.

37
00:01:56,739 --> 00:01:59,140
이것은 요소를 삽입하는 것입니다.
열쇠가 들어 있는 곳,

38
00:01:59,140 --> 00:02:01,930
최대치를 유지하면서
요소와 그 반환

39
00:02:01,930 --> 00:02:03,670
동시에.

40
00:02:03,670 --> 00:02:07,600
우리는 또한 다음과 같은 내용에 대해서도 이야기할 것입니다.
구조물을 건설할 수 있는 능력

41
00:02:07,599 --> 00:02:09,163
그냥 꽂는 것보다 더 빠릅니다.

42
00:02:09,163 --> 00:02:10,538
하지만 물론 우리는
구현할 수 있습니다

43
00:02:10,538 --> 00:02:14,259
처음부터 조립하기
그리고 반복적으로 삽입합니다.

44
00:02:14,259 --> 00:02:17,500
그리고 복잡성도 마찬가지입니다.
단순히 최댓값을 찾는 것

45
00:02:17,500 --> 00:02:20,409
제거하지 않으면, 그건 바로 너야
이 두 가지를 사용하여 모델링할 수 있습니다.

46
00:02:20,409 --> 00:02:24,189
제거를 통한 작업
최대치로 설정한 다음 다시 삽입합니다.

47
00:02:24,189 --> 00:02:25,930
효과가 있네요.

48
00:02:25,930 --> 00:02:28,360
하지만 종종 우리는 더 빨리 할 수 ​​있습니다.

49
00:02:28,360 --> 00:02:32,470
하지만 두 가지 핵심 기본 작업
최대값의 삽입 및 삭제가 가능합니다.

50
00:02:32,469 --> 00:02:37,180
그리고 우리는 몇 가지를 보게 될 것입니다.
이를 위한 데이터 구조.

51
00:02:37,180 --> 00:02:39,718
제안 사항이 있으시면 알려주세요.
데이터 구조

52
00:02:39,716 --> 00:02:40,759
우리가 이 수업에서 본 게 뭐였죠?

53
00:02:40,759 --> 00:02:45,603
우리는 무엇을 이용해서 해결해야 할까요?
우선순위 큐 인터페이스?

54
00:02:53,840 --> 00:02:54,770
가능한 답변은 여러 가지입니다.

55
00:02:57,882 --> 00:02:58,840
청중: AVL 시퀀스?

56
00:02:58,840 --> 00:02:59,965
에릭 데메인: AVL 시퀀스?

57
00:02:59,965 --> 00:03:01,539
오, 그거 흥미롭네요!

58
00:03:01,539 --> 00:03:07,030
AVL 시퀀스가 ​​좋은 답변입니다.
하지만 아마도 좀 더 세련된 버전일 겁니다.

59
00:03:07,030 --> 00:03:07,830
예?

60
00:03:07,830 --> 00:03:08,770
청중: AVL 설치하시겠습니까?

61
00:03:08,770 --> 00:03:10,960
에릭 데메인: 설치
AVL이 괜찮네요.

62
00:03:10,960 --> 00:03:14,090
AVL 세트는 다음을 지원합니다.
그리고 그 외에도 많은 작전들이 있습니다.

63
00:03:14,090 --> 00:03:18,189
모두 log n 시간 안에 완료되지만, 예외는 있습니다.
수집에는 n log n 시간이 걸립니다.

64
00:03:18,189 --> 00:03:20,978
먼저 정렬을 해야 하기 때문입니다.

65
00:03:20,978 --> 00:03:23,530
그러므로 AVL을 좋음으로 설정하세요.
좋은 방법이네요.

66
00:03:23,530 --> 00:03:27,579
저희가 곧 연락드리겠습니다.
AVL 시퀀스에 대한 아이디어는 나중에 다루겠습니다.

67
00:03:27,579 --> 00:03:31,650
이렇게 하면 해당 연산에 대한 log n 값을 얻을 수 있습니다.

68
00:03:31,650 --> 00:03:32,150
아주

69
00:03:32,150 --> 00:03:33,310
제 말은, 이건…

70
00:03:33,310 --> 00:03:35,370
AVL 세트는 우리 것입니다.
가장 강력한 데이터 구조.

71
00:03:35,370 --> 00:03:38,406
이 장치는 우리가 필요로 하는 모든 작업을 수행합니다.
다이얼 쪽에 필요합니다.

72
00:03:38,406 --> 00:03:40,240
그리고 AVL 시퀀스
모든 작업을 수행합니다

73
00:03:40,240 --> 00:03:41,115
순서 측면에서.

74
00:03:41,115 --> 00:03:43,090
하지만 다음 사항에 유의하세요.
수열이 아니라 집합입니다.

75
00:03:43,090 --> 00:03:44,349
열쇠는 저희가 관리하겠습니다.

76
00:03:44,349 --> 00:03:46,599
그 문제를 해결할 방법은 있습니다.
이것은 순차적 AVL을 사용합니다.

77
00:03:46,599 --> 00:03:50,418
하지만 그건 나중에 하도록 하죠.

78
00:03:50,418 --> 00:03:52,879
우리가 그렇게 한다면 정말 좋겠네요
예를 들어, 우리는 다음을 원합니다.

79
00:03:52,879 --> 00:03:55,840
고정된 AVL에서 find_max의 속도를 향상시킵니다.

80
00:03:55,840 --> 00:03:58,420
확대 기능을 추가할 수 있습니다.

81
00:03:58,418 --> 00:04:05,409
우리는 기억할 수 있어요...
서브트리 속성을 확장하시겠습니까?

82
00:04:05,409 --> 00:04:10,599
우리는 이것을 사용하여 얻을 수 있습니다.
상수 시간 find_max,

83
00:04:10,599 --> 00:04:14,259
각 노드에 저장
최대 핵심 요소

84
00:04:14,259 --> 00:04:15,549
하위 트리에 있습니다.

85
00:04:15,550 --> 00:04:16,850
이것은 서브트리의 속성 중 하나입니다.  에 대한

86
00:04:16,850 --> 00:04:18,740
우리는 그에게
지난 수업이 생각났다.

87
00:04:18,740 --> 00:04:21,278
그래서 우리는 더 나아질 수도 있습니다.
이는 시간을 절약하기 위한 것입니다.

88
00:04:21,278 --> 00:04:22,689
아주

89
00:04:22,689 --> 00:04:23,399
자, 이제 끝났습니다.

90
00:04:23,399 --> 00:04:24,024
강의가 끝났습니다.

91
00:04:24,024 --> 00:04:27,039
[웃음] 어떤 면에서는 그렇죠.
어떤 의미에서는 맞는 말입니다.

92
00:04:27,040 --> 00:04:28,540
하지만 우리가
오늘 우리가 살펴볼 것은

93
00:04:28,540 --> 00:04:30,800
또 다른 데이터 구조
이것은 바이너리 힙이라고 불립니다.

94
00:04:30,800 --> 00:04:34,780
어떤 의미에서는 그것은
AVL 세트를 단순화함으로써.

95
00:04:34,779 --> 00:04:37,479
주로 다음과 같은 결과를 얻습니다.
시간 제한은 동일합니다.

96
00:04:37,480 --> 00:04:41,240
조립이 더 빨라질 것입니다.
로그 계수에 대해서.

97
00:04:41,240 --> 00:04:44,680
하지만 이것이 주된 이유는 아닙니다.
우리가 그들에게 관심을 갖는 이유.

98
00:04:44,680 --> 00:04:46,959
가장 큰 장점은 다음과 같습니다.
더 간단하기 때문입니다.

99
00:04:46,959 --> 00:04:51,069
그리고 우리에게 주십시오
제자리 정렬 알고리즘.

100
00:04:54,220 --> 00:04:58,150
그래서 저는 가지고 있습니다
세 가지 작전,

101
00:04:58,149 --> 00:05:01,120
제가 말씀드렸던 바로 그것입니다:
빌드, 삽입 및 최대 삭제.

102
00:05:01,120 --> 00:05:05,470
그래서 우리는 거기에 AVL 트리를 설치했습니다.
n 로그 n 빌드, 로그 n 삽입,

103
00:05:05,470 --> 00:05:07,180
로그를 삭제하세요.

104
00:05:07,180 --> 00:05:12,310
그래서 우리가 쌓아둔 더미로 가는 길에 나는
두 가지를 더 말씀드리고 싶습니다.

105
00:05:12,310 --> 00:05:13,670
데이터 구조.

106
00:05:13,670 --> 00:05:18,009
하나는 역동적입니다.
하지만 정렬된 배열은 아닙니다.

107
00:05:18,009 --> 00:05:20,319
그리고 다른 하나는
동적 정렬 배열.

108
00:05:25,850 --> 00:05:27,530
이것들은 더 간단합니다
데이터 구조,

109
00:05:27,529 --> 00:05:29,299
우리가
이미 여러 번 말했습니다.

110
00:05:29,300 --> 00:05:32,000
그리고 그것들은 유용합니다
동기 부여

111
00:05:32,000 --> 00:05:36,769
시작하세요, 왜냐하면 많은
배열 위에 구축될 것입니다.

112
00:05:36,769 --> 00:05:38,060
대신에...

113
00:05:38,060 --> 00:05:42,720
음, 일종의 합병이라고 할 수 있죠.
산맥과 나무들 사이.

114
00:05:42,720 --> 00:05:47,400
그래서 만약 제가 정렬되지 않은 것을 가지고 있다면
배열은 아주 쉽습니다.

115
00:05:47,399 --> 00:05:49,319
삽입하는 거죠, 그렇죠?

116
00:05:49,319 --> 00:05:51,579
그냥 마지막에 추가하는 거예요.

117
00:05:51,579 --> 00:05:53,649
이것이 바로 우리가
마지막에 삽입하라고 불렀습니다.

118
00:05:53,649 --> 00:05:58,750
따라서 삽입이 빠릅니다.
지속적인 감가상각.

119
00:05:58,750 --> 00:06:00,180
어쩌면 우리는 그렇게 해야 할지도 몰라요
배열의 크기를 변경하세요.

120
00:06:00,180 --> 00:06:02,519
하지만 이것은
감가상각된 부품.

121
00:06:02,519 --> 00:06:03,576
하지만 최대치를 천천히 제거하세요.

122
00:06:03,576 --> 00:06:05,910
정렬되지 않은 배열에서는 그렇지 않습니다.
나는 최대값이 어디인지 알고 있다.

123
00:06:05,910 --> 00:06:07,770
그래서 스캔해야 해요
전체 배열.

124
00:06:11,240 --> 00:06:12,865
그래서 저는 검토 중입니다.
배열, 제가 찾은 것은,

125
00:06:12,865 --> 00:06:15,699
최댓값이 어딘가에 있다는 것
중간에, 그리고 나서,

126
00:06:15,699 --> 00:06:16,990
만약 제가 그것을 삭제하고 싶다면-

127
00:06:22,779 --> 00:06:24,699
이 항목을 삭제하고 싶습니다.
최대 요소, 음,

128
00:06:24,699 --> 00:06:26,229
동적 배열에서
내가 할 수 있는 건 이게 전부야

129
00:06:26,230 --> 00:06:28,939
할 일은 마지막 항목을 삭제하는 것입니다.
요소를 효과적으로.

130
00:06:28,939 --> 00:06:33,870
예를 들어, 저는 바꿀 수 있습니다.
마지막 요소와 함께 위치합니다.

131
00:06:33,870 --> 00:06:36,939
그래서 저는 이 요소를 가져옵니다.
그리고 나서 저는 그것을 여기에 놓았습니다.

132
00:06:36,939 --> 00:06:40,899
이것의 마지막 요소를 삭제하고 있습니다.
파이썬에서 pop이라고 하는 배열

133
00:06:40,899 --> 00:06:43,639
또는 우리 세계에서 delete_last라고 할 수 있습니다.

134
00:06:43,639 --> 00:06:50,159
그래서 전체적으로 보면 이렇습니다.
선형 시간이라는 점이 좋지 않습니다.

135
00:06:50,159 --> 00:06:51,909
하지만 제가 강조하고 싶었던 것은,
이것이 정확히 어떻게 된 일인가요?

136
00:06:51,909 --> 00:06:54,220
완료되었습니다. 왜냐하면 우리는
잠시 후에 이야기해요.

137
00:06:54,220 --> 00:06:56,200
정렬된 배열은 다음과 같습니다.
그 반대입니다.

138
00:06:56,199 --> 00:06:58,180
최댓값을 찾는 것은 매우 쉽습니다.

139
00:06:58,180 --> 00:07:01,110
어디에 있나요?

140
00:07:01,110 --> 00:07:02,580
끝으로.

141
00:07:02,579 --> 00:07:06,209
delete_max, 최대 요소
항상 마지막 요소입니다.

142
00:07:06,209 --> 00:07:07,919
점점 정렬되는 배열에서.

143
00:07:11,439 --> 00:07:14,040
저는 그게 일정하다고 생각해요.
감가상각됩니다. 왜냐하면 그러면 저는

144
00:07:14,040 --> 00:07:18,030
그것을 제거해야 할 것입니다.
크기가 변할 수 있습니다.

145
00:07:18,029 --> 00:07:21,629
하지만 삽입물
선형적일 것입니다.

146
00:07:21,629 --> 00:07:25,680
어쩌면 내가 할 수 있을지도 모르니까요
이진 탐색으로 찾기

147
00:07:25,680 --> 00:07:28,199
추가된 요소의 위치.

148
00:07:28,199 --> 00:07:35,444
내가 그냥
이 항목을 여기에 추가했습니다.

149
00:07:35,444 --> 00:07:36,819
나는 할 수 있다
이진 검색을 찾으세요.

150
00:07:36,819 --> 00:07:38,694
하지만 그때 나는
심각한 변화를 이루어야 할 것입니다.

151
00:07:38,694 --> 00:07:41,589
그래서 저는 할 수 있었어요
그냥 몇 번 자리를 바꿔보면 돼요.

152
00:07:41,589 --> 00:07:47,560
일자리를 찾을 때까지,
추가된 요소 x가 속하는 영역.

153
00:07:47,560 --> 00:07:49,329
이제 복원했습니다.
정렬된 순서.

154
00:07:49,329 --> 00:07:52,300
이것은 선형적으로 진행됩니다.
시간이 문제다.

155
00:07:52,300 --> 00:07:56,110
그리고 우리는 원합니다
두 가지 장점을 모두 누릴 수 있다.

156
00:07:56,110 --> 00:07:59,470
배열에 데이터를 삽입하는 속도는 빠릅니다.

157
00:07:59,470 --> 00:08:01,750
제거는 빠릅니다.
정렬된 배열.

158
00:08:01,750 --> 00:08:03,459
우리는 정규직을 구할 수 없어
둘 다 할 시간.

159
00:08:03,459 --> 00:08:04,959
하지만 우리는 로그를 얻을 수 있습니다.
둘 다 할 시간이 있어요.

160
00:08:04,959 --> 00:08:07,870
우리는 이미 방법을 알고 있습니다
AVL 트리 세트와 함께.

161
00:08:07,870 --> 00:08:10,870
하지만 오늘 우리는 보게 될 것입니다
다른 방법입니다.

162
00:08:10,870 --> 00:08:16,780
그리고 주된 동기는
다른 방법

163
00:08:16,779 --> 00:08:18,669
정렬 기능이 있습니다.

164
00:08:18,670 --> 00:08:21,490
그러므로 저는 결정하고 싶습니다.
우선순위에 따라 대기열을 정렬합니다.

165
00:08:29,279 --> 00:08:33,120
따라서 어떤 데이터 구조가 주어졌든 간에,
우선순위 큐 인터페이스를 구현합니다.

166
00:08:33,120 --> 00:08:36,418
특히
최대값을 삽입하고 삭제합니다.

167
00:08:36,418 --> 00:08:38,220
저는 정렬 알고리즘을 만들 수 있습니다.

168
00:08:38,220 --> 00:08:39,269
어떻게 해야 할까요?

169
00:08:39,269 --> 00:08:42,269
모든 요소를 ​​삽입하세요.
모든 항목을 삭제합니다.

170
00:08:42,269 --> 00:08:45,990
하지만 제가 그것들을 삭제한 이후로는,
처음에는 가장 크게 나옵니다.

171
00:08:45,990 --> 00:08:47,610
저는 그것들을 다음에서 구입합니다.
역순으로.

172
00:08:47,610 --> 00:08:51,840
그러면 선형적인 흐름을 되돌릴 수 있을 거예요.
시간이 남아서 물건들을 정리했어요.

173
00:08:51,840 --> 00:09:04,740
따라서 (x) 대신 삽입할 수 있습니다.
A 또는 (build(A))의 x,

174
00:09:04,740 --> 00:09:10,210
그런 다음 delete_max를 여러 번 실행합니다.

175
00:09:17,169 --> 00:09:19,519
얼마나 걸려요?
이 알고리즘은 어떤 과정을 거치나요?

176
00:09:19,519 --> 00:09:21,269
저는 입장하겠습니다
다음은 몇 가지 표기법입니다.  n개의 요소를 생성합니다

177
00:09:21,269 --> 00:09:25,079
시간이 얼마나 걸리든 상관없습니다.
,

178
00:09:25,080 --> 00:09:29,460
T 하위 빌드(n) 플러스라고 부르세요--

179
00:09:32,279 --> 00:09:42,654
죄송합니다. 거기에 n배를 더한 것입니다.
delete_max를 실행하는 데 걸리는 시간입니다.

180
00:09:45,509 --> 00:09:49,710
또는 우리가 쓸 수도 있습니다
마치 n번의 시간 같아요

181
00:09:49,710 --> 00:09:54,267
삽입을 수행하는 것 외에도
delete_max 실행 시간.

182
00:09:58,350 --> 00:10:01,590
그래서 저는 이러한 T 함수를 사용합니다.
간단히 추상화하다

183
00:10:01,590 --> 00:10:04,769
제공된 근무 시간
내 데이터 구조는 다음과 같습니다.

184
00:10:04,769 --> 00:10:06,210
이 인터페이스를 구현합니다.

185
00:10:06,210 --> 00:10:07,830
인터페이스에는 다음과 같이 표시됩니다.
무엇이 옳은가요?

186
00:10:07,830 --> 00:10:10,990
그리고 이러한 T 함수는 다음과 같은 결과를 제공합니다.
제 생산성에는 한계가 있습니다.

187
00:10:10,990 --> 00:10:13,860
그래서 각각을 연결하면
이러한 데이터 구조,

188
00:10:13,860 --> 00:10:16,560
정렬 알고리즘을 얻었습니다.

189
00:10:16,559 --> 00:10:18,839
AVL 정렬은 이해합니다.
배열 기준으로 정렬됩니다.

190
00:10:18,840 --> 00:10:20,280
다양한 배열을 기준으로 정렬하는 것은 이해합니다.

191
00:10:20,279 --> 00:10:21,477
그들은 어떻게 생겼나요?

192
00:10:21,477 --> 00:10:23,144
알고 보니 많은 사람들이
낯익은 것들이에요.

193
00:10:26,179 --> 00:10:29,529
그래서 AVL 세트는 다음과 같습니다.
작업당 n을 기록합니다.

194
00:10:29,529 --> 00:10:33,490
따라서 우리는 그들로부터 n log n 정렬 알고리즘을 얻습니다.
, 어느

195
00:10:33,490 --> 00:10:36,580
모두 삽입
요소를 AVL 트리로 변환합니다.

196
00:10:36,580 --> 00:10:39,930
저는 AVL 어셈블리를 사용하고 싶지 않습니다.
정렬을 사용하기 때문입니다.

197
00:10:39,929 --> 00:10:42,219
분류는 금지되어 있습니다
정렬 기능을 구현하기 위해.

198
00:10:42,220 --> 00:10:43,990
하지만 우리는 어떻게 되는지 봤습니다
AVL 트리에 삽입

199
00:10:43,990 --> 00:10:45,879
그리고 균형을 유지하세요.

200
00:10:45,879 --> 00:10:47,350
따라서 각각에 대해 log n이 필요합니다.

201
00:10:47,350 --> 00:10:50,800
그러면 우리는 찾을 수 있습니다
최대치, 제거, 균형 복원

202
00:10:50,799 --> 00:10:51,429
등.

203
00:10:51,429 --> 00:10:52,779
총 소요 시간은 n log n입니다.

204
00:10:52,779 --> 00:10:55,600
이것은 알고리즘입니다
우리는 이를 AVL 정렬이라고 부릅니다.

205
00:10:55,600 --> 00:10:58,629
이것은 조금 더 복잡한데, 그 이유는 다음과 같습니다.
AVL 트리는 복잡합니다.

206
00:10:58,629 --> 00:11:04,149
하지만 이것은 우리에게 최적의 결과를 제공합니다.
비교 한계 및 log n.

207
00:11:04,149 --> 00:11:08,199
배열을 정렬하는 건 어떨까요?

208
00:11:08,200 --> 00:11:13,310
자, 제가 사용한다고 가정해 봅시다.
정렬되지 않은 배열.

209
00:11:13,309 --> 00:11:14,579
객체를 삽입합니다.

210
00:11:14,580 --> 00:11:15,956
그래서 만약 제가 요소를 삽입한다면,

211
00:11:15,956 --> 00:11:18,539
저는 모든 삽입 작업을 합니다.
제거하기 전 여기입니다.

212
00:11:18,539 --> 00:11:20,329
그렇다면 무슨 일이 일어날까요?
요소들을 삽입하겠습니다.

213
00:11:20,330 --> 00:11:21,780
배열의 원래 순서대로.

214
00:11:21,779 --> 00:11:23,720
다시 말해서, 나는
저는 그냥 배열을 가져옵니다.

215
00:11:23,720 --> 00:11:30,460
그리고 나서 몇 번 더 해봐요.
최대 요소를 추출합니다.

216
00:11:30,460 --> 00:11:34,570
그를 찾고 있어요.
배열의 끝으로 이동합니다.

217
00:11:34,570 --> 00:11:36,190
그리고 나서 이 과정을 반복합니다.

218
00:11:36,190 --> 00:11:38,530
왠지 익숙한 이야기인가요?

219
00:11:38,529 --> 00:11:43,959
이것은 샘플입니다.
세 번째 강의부터.

220
00:11:43,960 --> 00:11:47,800
그러니까 이건... 배열이 주는 거죠
저희가 선택을 정렬합니다.

221
00:11:53,259 --> 00:11:54,879
이것은 새로운 방식입니다
무엇에 대해 생각해 봅시다

222
00:11:54,879 --> 00:11:57,070
우리는 그때 그렇게 했어요.

223
00:11:57,070 --> 00:12:01,360
정렬된 배열을 어떻게 처리해야 할까요?

224
00:12:01,360 --> 00:12:02,800
우리는 모든 요소를 ​​삽입합니다.

225
00:12:02,799 --> 00:12:05,049
실제로 거기에 있고
모든 일은 우리 덕분에 이루어지고 있습니다.

226
00:12:05,049 --> 00:12:06,490
정렬된 배열을 지원합니다.

227
00:12:06,490 --> 00:12:07,870
자, 그럼 빈 배열부터 시작해 봅시다.

228
00:12:07,870 --> 00:12:08,590
이 문제는 해결되었습니다.

229
00:12:08,590 --> 00:12:09,353
객체를 추가하세요.

230
00:12:09,352 --> 00:12:10,269
네, 모든 게 여전히 정상입니다.

231
00:12:10,269 --> 00:12:11,710
우리는 두 번째 것을 추가합니다.
요소와 위치를 바꾸세요.

232
00:12:11,710 --> 00:12:13,389
필요한 경우, 정렬합니다.

233
00:12:13,389 --> 00:12:16,419
일반적으로, 우리가 더할 때
해당 요소를 왼쪽으로 변경합니다.

234
00:12:16,419 --> 00:12:17,529
문제가 다시 해결될 때까지.

235
00:12:17,529 --> 00:12:19,809
이것은 삽입의 한 유형입니다.

236
00:12:26,080 --> 00:12:30,670
멋있어 보이네요, 통합적인 것 같아요
세 가지를 위한 구조

237
00:12:30,669 --> 00:12:32,289
앞서 살펴본 정렬 알고리즘입니다.

238
00:12:32,289 --> 00:12:34,879
우린 제대로 대화를 나누지 않았어요.
지난번에 AVL 정렬에 대해 이야기했었죠.

239
00:12:34,879 --> 00:12:36,189
하지만 그건 메모에 적혀 있었어요.

240
00:12:36,190 --> 00:12:39,110
자, 이것들이 바로 권리입니다.
테이블의 일부입니다.

241
00:12:39,110 --> 00:12:42,430
그래서 당연히 이러한 배열 데이터 구조들이 있습니다.
효과적인.

242
00:12:42,429 --> 00:12:44,709
그들은 선형적인 시간을 소요합니다.
일부 작업.

243
00:12:44,710 --> 00:12:46,570
따라서 정렬 알고리즘
효과적인.

244
00:12:46,570 --> 00:12:48,028
하지만 이것들은 바로 그런 것들입니다
우리는 이전에 본 적이 있습니다.

245
00:12:48,028 --> 00:12:49,937
그래서 보기 좋네요.
그들은 여기에 어떻게 어울리나요?

246
00:12:49,937 --> 00:12:51,730
그들은 가지고 있었다...
선택 항목별 정렬 및

247
00:12:51,730 --> 00:12:53,800
삽입 정렬은 다음과 같은 장점이 있었습니다.
그들이 그 자리에 있었다는 것입니다.

248
00:12:53,799 --> 00:12:57,490
일정한 것만 있으면 됩니다.
포인터 또는 인덱스의 개수

249
00:12:57,490 --> 00:12:59,539
배열 자체 외부에 있습니다.

250
00:12:59,539 --> 00:13:01,069
그러므로 매우 효과적입니다.

251
00:13:01,070 --> 00:13:02,348
그래서 그건 그들에게 유리한 점이었어요.

252
00:13:02,347 --> 00:13:04,389
하지만 그것들은 n 제곱을 차지합니다.
시간이니까 절대 그러면 안 돼.

253
00:13:04,389 --> 00:13:09,309
n을 제외하고 모두 사용하세요.
많아야 100명 정도일 거예요.

254
00:13:09,309 --> 00:13:14,392
AVL 트리 정렬은 훌륭합니다.
아마도 n log n번이 될 겁니다.

255
00:13:14,393 --> 00:13:16,060
보다
병합 정렬, 그리고 당신은

256
00:13:16,059 --> 00:13:17,659
병합 정렬을 사용해도 됩니다.

257
00:13:17,659 --> 00:13:21,949
하지만 병합 정렬도 아니고
AVL 트리 정렬이 작동하지 않습니다.

258
00:13:21,950 --> 00:13:24,910
그러므로 목표는
오늘 받으세요 —

259
00:13:24,909 --> 00:13:26,769
이 모든 것 중 최고
정렬 중인 세계,

260
00:13:26,769 --> 00:13:28,389
n log n을 얻으려면
비교

261
00:13:28,389 --> 00:13:30,909
최적입니다
비교 모델,

262
00:13:30,909 --> 00:13:33,366
하지만 제자리에 고정시키기 위해서입니다.

263
00:13:33,366 --> 00:13:35,574
그리고 이것이 우리가 하려는 일입니다.
바이너리 힙을 사용하여 가져옵니다.

264
00:13:38,750 --> 00:13:40,970
우리는 개발할 것입니다
데이터 구조

265
00:13:40,970 --> 00:13:43,220
건설될 것입니다
조금 더 빠르게 – 앞서 말씀드렸듯이,

266
00:13:43,220 --> 00:13:45,470
시간의 선형적 형성.

267
00:13:45,470 --> 00:13:48,110
그러므로 그는 대표하지 않습니다.
정렬된 순서 맞습니다.

268
00:13:48,110 --> 00:13:49,879
AVL 트리처럼요.

269
00:13:49,879 --> 00:13:51,409
하지만 켜질 겁니다
나무처럼.

270
00:13:51,409 --> 00:13:53,687
이것 또한 배열을 기반으로 할 것입니다.

271
00:13:53,687 --> 00:13:56,269
우리는 로그 값을 얻게 될 것입니다.
삽입 및 삭제 최대 시간.

272
00:13:56,269 --> 00:14:00,230
감가상각이 발생하는 경우가 있습니다.
배열을 사용하고 있기 때문입니다.

273
00:14:00,230 --> 00:14:04,009
하지만 핵심은 바로 이것입니다.
데이터 구조가 마련되었습니다.

274
00:14:04,009 --> 00:14:07,970
그것은 오직 ~로만 구성되어 있다
요소들의 배열.

275
00:14:07,970 --> 00:14:11,120
그래서 우리가 그것을 연결하면
저희 정렬 알고리즘에 따르면 —

276
00:14:11,120 --> 00:14:13,460
큐에서 우선순위 정렬 또는
일반 정렬 알고리즘 —

277
00:14:13,460 --> 00:14:15,650
우리는 얻을 뿐만 아니라
n log n 성능,

278
00:14:15,649 --> 00:14:18,529
하지만 우리도 얻게 됩니다
제자리 정렬 알고리즘.

279
00:14:18,529 --> 00:14:21,509
이것이 우리의 첫 번째가 될 것입니다
그리고 이 수업에서는 단 한 명뿐이에요.

280
00:14:21,509 --> 00:14:24,569
n 로그 n
제자리 정렬 알고리즘.

281
00:14:24,570 --> 00:14:27,250
가파르게

282
00:14:27,250 --> 00:14:29,889
이것이 목표입니다.

283
00:14:29,889 --> 00:14:31,299
자, 시작해 봅시다.

284
00:14:31,299 --> 00:14:36,419
그럼 우리는 어떻게 할까요?
우리가 여기에 있으니,

285
00:14:36,419 --> 00:14:39,689
본질적으로 우리는 다음과 같이 해야 했습니다.
최종 요소들을 저장하는 배열입니다.

286
00:14:39,690 --> 00:14:41,580
이것은 일종의
현장의 정의,

287
00:14:41,580 --> 00:14:44,820
단순히 n개의 슬롯을 사용하는 것
메모리,

288
00:14:44,820 --> 00:14:47,918
그 크기가 숫자와 정확히 일치하는 것
우리 구조의 요소들.

289
00:14:47,918 --> 00:14:50,460
하지만 우리는 당연히 그러지 않을 겁니다.
정렬되지 않은 일반 배열을 사용하세요

290
00:14:50,460 --> 00:14:52,998
또는 일반적인 정렬된 배열.

291
00:14:52,998 --> 00:14:54,540
우리는 사용할 것입니다
배열만

292
00:14:54,539 --> 00:14:58,049
그것의 기반이 되는 기술,
물건이 보관되는 방식.

293
00:14:58,049 --> 00:15:00,809
하지만 저희는 정말로 그러고 싶습니다.
대수 생산성, 즉

294
00:15:00,809 --> 00:15:02,849
나무를 떠올리게 할 것입니다.

295
00:15:02,850 --> 00:15:06,509
잡지를 구할 수 있는 유일한 방법은
이진 트리와 거의 같습니다.

296
00:15:06,509 --> 00:15:14,740
그러므로 우리는 원합니다
트리를 배열에 삽입합니다.

297
00:15:14,740 --> 00:15:16,049
예를 하나 들어보겠습니다.

298
00:15:23,960 --> 00:15:26,480
나무를 그려볼게요.

299
00:15:44,679 --> 00:15:47,109
만약 꼭 하나를 골라야 한다면
아무 오래된 나무나

300
00:15:47,110 --> 00:15:51,550
저는 다음과 같은 나무를 고르겠습니다.
기본적으로 완벽하게 균형 잡혀 있습니다.

301
00:15:51,549 --> 00:15:55,120
완벽한 균형
이런 식일 겁니다.

302
00:15:55,120 --> 00:15:56,049
어떤 부동산인가요?  안에

303
00:15:56,049 --> 00:15:58,899
저는 모든 사람을 다 데리고 있어요.
이러한 수준들 -

304
00:15:58,899 --> 00:16:01,809
이 모든 깊이들
노드로 완전히 채워져 있습니다.

305
00:16:01,809 --> 00:16:03,024
이것은 깊이 0입니다.

306
00:16:05,799 --> 00:16:11,339
기억하세요, 이것은 1단계 깊이입니다.
깊이 2, 이것은 깊이 3입니다.

307
00:16:11,340 --> 00:16:15,850
그래서 제가 정말로 원하는 것은...
2개를 가지고 있습니다

308
00:16:15,850 --> 00:16:20,860
깊이 i에 있는 노드.

309
00:16:20,860 --> 00:16:25,180
이것은
완벽한 이진 트리.

310
00:16:25,179 --> 00:16:29,049
하지만 이는 n이 1일 때만 성립합니다.
2의 거듭제곱보다 작다는 거죠?

311
00:16:29,049 --> 00:16:31,629
저는 항상 목표를 달성할 수는 없습니다.
이것은 임의의 n에 대해 적용됩니다.

312
00:16:31,629 --> 00:16:34,090
그래서 차선책은 다음과 같습니다.
내가 바랄 수 있는 건 뭘까?

313
00:16:34,090 --> 00:16:36,850
2 대 1입니다.
깊이 i의 노드

314
00:16:36,850 --> 00:16:40,340
마지막까지
가장 깊은 곳에 있는 i--.

315
00:16:40,340 --> 00:16:43,639
그리고 이 수준에서도 저는 여전히
저는 몇 가지를 제한할 거예요.

316
00:16:43,639 --> 00:16:45,409
나는 강제로 할 거야
모든 노드

317
00:16:45,409 --> 00:16:48,949
가능한 한 좌파적인 성향을 띠려고.

318
00:16:48,950 --> 00:17:03,550
그래서 제가 말씀드리고 싶은 것은, 예외를 제외하고는 다음과 같습니다.
노드가 위치하는 최대 깊이,

319
00:17:03,549 --> 00:17:05,049
저는 그것들을 왼쪽 정렬이라고 부르겠습니다.

320
00:17:10,660 --> 00:17:12,640
이 두 사람
속성들을 함께

321
00:17:12,640 --> 00:17:15,280
제가 부르는 이름은 바로 이것입니다.
완전 이진 트리.

322
00:17:27,838 --> 00:17:29,579
이것이 왜 흥미로운가요?

323
00:17:29,579 --> 00:17:35,399
제가 발표할 수 있다고 주장하기 때문입니다.
트리와 같은 배열.

324
00:17:35,400 --> 00:17:39,720
충분히 범위를 좁혔어요.
제가 그림을 그릴 수 있도록

325
00:17:39,720 --> 00:17:41,440
여기에 배열이 있습니다.

326
00:17:41,440 --> 00:17:43,559
그리고 제가 할 일은
해야 할 일은 이 노드들을 적어두는 것입니다.

327
00:17:43,559 --> 00:17:45,250
심층적인 순서대로.

328
00:17:45,250 --> 00:17:47,910
그래서 저는 먼저 A를 씁니다.
이것이 0단계이기 때문입니다.

329
00:17:47,910 --> 00:17:50,850
그다음 B, C, 이게 1단계입니다.

330
00:17:50,849 --> 00:17:53,139
그럼, 알겠습니다. 그들은
알파벳 순서대로.

331
00:17:53,140 --> 00:17:54,880
저는 이렇게 했어요.

332
00:17:54,880 --> 00:17:58,680
D, E, F, G는 깊이 2입니다.

333
00:17:58,680 --> 00:18:03,150
그다음은 H, I, J — 3단계입니다.

334
00:18:03,150 --> 00:18:06,210
이것은 매우 다릅니다
트리를 탐색하는 순서.

335
00:18:06,210 --> 00:18:10,500
작업 순서는 다음과 같습니다.
H, D, I, B, J, E, A, F, C,

336
00:18:10,500 --> 00:18:11,789
네, 알겠죠?

337
00:18:11,789 --> 00:18:15,329
하지만 이것이 바로 우리가 가진 것입니다
우리는 그것을 깊이의 순서라고 부를 수 있습니다. 먼저

338
00:18:15,329 --> 00:18:17,669
가장 낮은 수준을 수행하다
깊이 노드 –

339
00:18:17,670 --> 00:18:24,440
완전히 다른 표현 방식
데이터를 선형화할지 여부.

340
00:18:24,440 --> 00:18:27,259
그렇습니다.
마치 쌓여있는 것처럼 보일 것입니다.

341
00:18:27,259 --> 00:18:33,309
그래서 가장 흥미로운 점은 바로 이것입니다.
완전 이진수 사이

342
00:18:33,309 --> 00:18:36,399
트리와 배열은 일대일 대응입니다.

343
00:18:36,400 --> 00:18:39,759
각 배열마다
유일한 완전 이진 트리.

344
00:18:39,759 --> 00:18:43,339
그리고 모든 완전한 이진수에 대해
이곳에는 독특한 종류의 나무들이 다양하게 있습니다.

345
00:18:43,339 --> 00:18:43,879
왜

346
00:18:43,880 --> 00:18:46,700
완전하기 때문입니다
제한력

347
00:18:46,700 --> 00:18:48,660
모든 상황이 나를 그렇게 만들도록 강요한다.

348
00:18:48,660 --> 00:18:50,870
만약 내가…
제가 숫자 n을 드리겠습니다.

349
00:18:50,869 --> 00:18:53,809
하나 있습니다
크기가 n인 나무 모양 맞죠?

350
00:18:53,809 --> 00:18:57,042
그냥 입력하시면 됩니다
위에서 아래로 노드를 차례로 나열하면

351
00:18:57,042 --> 00:18:57,959
당신은 마지막 레벨에 도달할 것입니다.

352
00:18:57,960 --> 00:18:59,960
그다음에는 입력하셔야 합니다.
왼쪽에서 오른쪽 순으로.

353
00:18:59,960 --> 00:19:03,829
이것을 뭐라고 부를 수 있을까요?
쓰기 노드의 읽기 순서.

354
00:19:03,829 --> 00:19:07,069
그리고 배열 보고서는 다음과 같습니다.
어떤 키가 어디에 쓰이는지 알잖아요.

355
00:19:07,069 --> 00:19:09,210
이것은 첫 번째 노드입니다.
루트에 쓰세요,

356
00:19:09,210 --> 00:19:10,789
이것이 다음입니다
녹화 중인 노드

357
00:19:10,789 --> 00:19:13,670
왼쪽 아이 부분에서
루트 등등.

358
00:19:13,670 --> 00:19:16,820
자, 여기 이진수가 있습니다.
배열로 표현된 트리,

359
00:19:16,819 --> 00:19:19,279
또는 배열을 나타냅니다
이진 트리.

360
00:19:19,279 --> 00:19:21,829
매우 구체적
이진 트리, 그것은

361
00:19:21,829 --> 00:19:25,579
명백한 이점이 있으며,
잔액이 보장됩니다.

362
00:19:25,579 --> 00:19:29,006
쌓아놓고 회전시킬 필요가 없습니다.
완전 이진 트리는

363
00:19:29,007 --> 00:19:29,840
언제나 균형이 잡혀 있습니다.

364
00:19:29,839 --> 00:19:33,769
사실, 그들은 최고를 가지고 있습니다.
그들이 도달할 수 있는 최대 높이,

365
00:19:33,769 --> 00:19:35,420
즉, 통나무로 만든 천장 n.

366
00:19:39,559 --> 00:19:42,289
균형, 기억하세요, 간단합니다.
당신은 log n의 큰 O라는 뜻입니다.

367
00:19:42,289 --> 00:19:44,329
이것은 1 곱하기 log n입니다.

368
00:19:44,329 --> 00:19:47,899
그래서 이게 최고 수준입니다.
기대할 수 있는 균형.

369
00:19:47,900 --> 00:19:52,910
그래서 저는 어떻게든 우리가 할 수 있다고 주장합니다.
완전 이진 트리를 유지합니다

370
00:19:52,910 --> 00:19:54,144
우선순위 대기열을 해결하기 위해.

371
00:19:54,144 --> 00:19:55,519
이것은
당신이 불가능하다면

372
00:19:55,519 --> 00:19:57,619
해결하려고 노력했습니다
전체 전화 걸기 인터페이스.

373
00:19:57,619 --> 00:19:59,659
그리고 이건 마치
쌓아 놓은 것들의 멋진 점은 바로 이것입니다.

374
00:19:59,660 --> 00:20:03,029
그것은 단순히 집중함으로써 가능합니다.
인터페이스 집합의 부분집합,

375
00:20:03,029 --> 00:20:05,029
우리는 더 많은 일을 할 수 있습니다.

376
00:20:05,029 --> 00:20:07,492
우리는 이것을 유지할 수 있습니다
매우 강력한 속성입니다.

377
00:20:07,492 --> 00:20:09,409
그리고 우리는 이것을 가지고 있으니
매우 강력한 속성,

378
00:20:09,410 --> 00:20:10,993
우리는 필요조차 없어요
이 나무를 보존하세요.

379
00:20:10,992 --> 00:20:13,609
왼쪽 것은 보관하지 않겠습니다.
그리고 오른쪽 포인터와 부모

380
00:20:13,609 --> 00:20:16,619
포인터, 우리는 그냥
우리는 배열을 저장할 것입니다.

381
00:20:16,619 --> 00:20:28,959
이것이 우리가 부르는 명칭입니다
암묵적 데이터 구조는 다음과 같습니다.

382
00:20:28,960 --> 00:20:38,529
기본적으로 포인터가 없음을 의미합니다.
단순히 n개의 요소로 이루어진 배열입니다.

383
00:20:44,079 --> 00:20:46,629
우리는 어떻게 헤쳐나갈까요?
포인터를 저장하지 않고?

384
00:20:46,630 --> 00:20:48,790
저는 여전히 그러고 싶습니다
나무처럼 대해주세요.

385
00:20:48,789 --> 00:20:52,149
저는 여전히 무엇을 알고 싶습니다.
B의 왼쪽 자식은 D입니다.

386
00:20:52,150 --> 00:20:56,350
그리고 B의 오른쪽 자식은 E입니다.
잠시 후 그 이유를 알게 될 겁니다.

387
00:20:56,349 --> 00:21:01,990
네, 우리는 할 수 있어요.
인덱스 연산을 사용합니다.

388
00:21:01,990 --> 00:21:06,710
그럼 몇 가지를 더 추가해야겠네요.
제가 도착하기 전에 태그를 달아주세요.

389
00:21:11,420 --> 00:21:14,170
그래서 이 배열은
자연스럽게 인덱스를 가지고 있습니다.

390
00:21:14,170 --> 00:21:16,630
이것은 인덱스 0입니다.

391
00:21:16,630 --> 00:21:21,580
이것은 인덱스 1, 인덱스 2, 인덱스입니다.
3, 인덱스 4, 인덱스 5, 인덱스 6,

392
00:21:21,579 --> 00:21:27,609
7, 8, 9, 왜냐하면
0부터 9까지 총 10개의 요소가 있습니다.

393
00:21:27,609 --> 00:21:29,649
그리고 저는 이것들을 적용할 수 있습니다.
여기에도 태그를 달아주세요.

394
00:21:29,650 --> 00:21:32,590
이것들은 동일합니다
따라서 노드는 0, 1, 2입니다.

395
00:21:32,589 --> 00:21:34,299
이는 단지 대략적인 크기 차이일 뿐입니다.

396
00:21:36,741 --> 00:21:38,200
하지만 내가 도착하자마자
이것이 바로 제가 생각하는 표식입니다.

397
00:21:38,200 --> 00:21:40,130
훨씬 더 쉬울 겁니다
이해하다.

398
00:21:40,130 --> 00:21:42,790
그래서 만약 내가 무엇을 알고 싶다면
B의 왼쪽 자식은 D입니다.

399
00:21:42,789 --> 00:21:48,596
어찌 됐든, 1위를 차지하게 되면서, 나는
숫자 3을 계산하고 싶습니다.

400
00:21:48,596 --> 00:21:52,654
2를 더하면 모두 됩니다.
품종 수 - 3을 곱하세요.

401
00:21:52,654 --> 00:21:54,029
모두 다 있습니다
운영 유형,

402
00:21:54,029 --> 00:21:55,769
1을 받아서 3으로 바꾸는 것입니다.

403
00:21:55,769 --> 00:21:58,589
하지만 오직 한 사람만이 있습니다.
모든 경우에 효과가 있을 것입니다.

404
00:21:58,589 --> 00:22:00,839
그리고 직관이 여기에 있습니다
제가 2개를 가지고 있다는 것입니다.

405
00:22:00,839 --> 00:22:02,264
레벨 i의 노드 i.

406
00:22:02,265 --> 00:22:04,530
내가 바꾸고 싶다면
어린이 수준,

407
00:22:04,529 --> 00:22:06,990
아래쪽에 노드 2부터 i+까지가 있습니다.
1--

408
00:22:06,990 --> 00:22:08,309
정확히 두 번.

409
00:22:08,309 --> 00:22:10,980
자, 이게 마지막입니다.
하지만 그건 중요하지 않아요.

410
00:22:10,980 --> 00:22:13,349
왼쪽 자식 요소가 있는 경우,
그는 똑같이 행동할 것이다.

411
00:22:13,349 --> 00:22:15,809
그래서 직관적으로 저는
이 공간의 크기는 2에서 i까지입니다.

412
00:22:15,809 --> 00:22:19,349
우주 공간으로 확장해야 합니다.
크기 2에서 i+1까지,

413
00:22:19,349 --> 00:22:22,579
그래서 2를 곱해야 합니다.

414
00:22:22,579 --> 00:22:27,109
거의 맞지만,
변하지 않는 몇 가지 요소가 있습니다.

415
00:22:27,109 --> 00:22:29,449
그래서 저는 두 번 "나"라고 말하고 싶습니다.

416
00:22:29,450 --> 00:22:32,900
하지만 우리가 살펴보면
예시로 1에 2를 곱한 값이 있습니다.

417
00:22:32,900 --> 00:22:36,170
이는 2인데, 3보다 1이 적습니다.

418
00:22:36,170 --> 00:22:38,420
2 곱하기 2는 4입니다.
5보다 1 적은 수.

419
00:22:38,420 --> 00:22:39,769
안녕하세요, 저희는 거의 모든 것을 제대로 했습니다.

420
00:22:39,769 --> 00:22:43,055
1인용입니다.

421
00:22:43,055 --> 00:22:45,680
편차 1 -

422
00:22:45,680 --> 00:22:50,840
인덱스 오류가 가장 흔합니다.
컴퓨터 과학 분야의 것들.

423
00:22:50,839 --> 00:22:53,759
그렇다면 적합한 아이는 어떨까요?

424
00:22:53,759 --> 00:22:56,539
왼쪽 자식 요소가 2i + 2i인 경우
1. 그 아이는 어디에 있나요?

425
00:22:59,640 --> 00:23:00,630
웅얼거리는 소리가 많이 들려요.

426
00:23:00,630 --> 00:23:03,930
2i에 2를 더하면 하나 더입니다.

427
00:23:03,930 --> 00:23:06,600
우리가 글을 쓰기 때문에
왼쪽에서 오른쪽으로 깊이 순서대로,

428
00:23:06,599 --> 00:23:09,829
그 아이가 바로 그 아이입니다.
왼쪽 아이의 형.

429
00:23:09,829 --> 00:23:12,000
그러니까, 그냥 더 큰 하나인 거죠, 알겠죠?

430
00:23:12,000 --> 00:23:15,990
이러한 규칙들을 고려할 때, 우리는
부모 요소도 계산할 수 있습니다.

431
00:23:15,990 --> 00:23:18,120
이것이 바로
반전되어 있습니다

432
00:23:18,119 --> 00:23:22,500
이 두 가지 모두에
내가 원하는 기능들

433
00:23:22,500 --> 00:23:25,890
어느 시점에서 2로 나눕니다.

434
00:23:25,890 --> 00:23:29,400
주어진 상황에서 나는 나로 돌아가고 싶다
2i + 1 또는 2i + 2.

435
00:23:29,400 --> 00:23:36,530
그래서 1을 빼면
나로부터, 그 다음 나

436
00:23:36,529 --> 00:23:38,149
2i 또는 2i + 1 중 하나를 선택하겠습니다.

437
00:23:38,150 --> 00:23:42,680
그리고 나서 정수를 나누면
2까지 가면, 나는 얻는다--

438
00:23:42,680 --> 00:23:43,720
원래의 i.

439
00:23:43,720 --> 00:23:46,789
죄송해요, 나중에 전화할게요.
더 명확히 하자면, j입니다.

440
00:23:46,789 --> 00:23:49,579
그러니까 j는 왼쪽 아이인지 오른쪽 아이인지를 나타내는 겁니다.

441
00:23:49,579 --> 00:23:53,210
그러면 재구성할 수 있습니다.
나, 즉 아버지였다.

442
00:23:53,210 --> 00:23:56,160
자, 이것이 바로
상수를 이용한 산술 연산.

443
00:23:56,160 --> 00:23:58,535
그래서 저는 저장할 필요가 없어요.
왼쪽 및 오른쪽 포인터.

444
00:23:58,535 --> 00:24:00,410
제가 직접 계산할 수 있습니다.
필요할 때요.

445
00:24:00,410 --> 00:24:03,140
내가 있을 때마다
예를 들어 E와 같은 노드가 있습니다.

446
00:24:03,140 --> 00:24:05,540
그리고 저는 알고 싶어요.
그것의 왼쪽 자식 요소는 무엇입니까?

447
00:24:05,539 --> 00:24:08,629
죄송합니다, 고려해 주셔서 감사합니다.
노드 인덱스 4, 즉

448
00:24:08,630 --> 00:24:11,127
포함됨
원소 E, 그리고 I

449
00:24:11,126 --> 00:24:13,460
그의 왼쪽 자녀가 누구인지 알고 싶습니다.
해당 요소에 2를 곱하기만 하면 됩니다.

450
00:24:13,460 --> 00:24:13,960
그리고 1을 더하세요.

451
00:24:13,960 --> 00:24:14,930
저는 9점을 받습니다.

452
00:24:14,930 --> 00:24:17,360
그런 다음 인덱스를 만들 수 있습니다.
이 배열은 9번째 위치에 있습니다.

453
00:24:17,359 --> 00:24:20,629
왜냐하면 난... 이게 아니니까
제 머릿속 생각일 뿐이에요, 기억하시죠?

454
00:24:20,630 --> 00:24:22,770
우리는 단지 그렇게 생각할 뿐입니다.
여기에 나무가 한 그루 있습니다.

455
00:24:22,769 --> 00:24:26,339
하지만 실제로는 컴퓨터에서
배열만 있습니다.

456
00:24:26,339 --> 00:24:30,529
그래서, 만약 우리가 E에서 출발하고 싶다면
J까지는 4에서 9까지 가능합니다.

457
00:24:30,529 --> 00:24:33,619
우리가 가려고 하면
올바른 자식 요소의 값에 2를 곱합니다.

458
00:24:33,619 --> 00:24:35,429
8에 2를 더하면 10이 됩니다.

459
00:24:35,430 --> 00:24:37,820
그리고 우리는 이것을 봅니다, 오, 10개
배열의 끝을 넘어.

460
00:24:37,819 --> 00:24:40,279
하지만 우리 배열에는 그것이 저장됩니다.
크기, 그래서 우리는 E를 이해합니다.

461
00:24:40,279 --> 00:24:42,109
유효한 자식 요소가 없습니다.

462
00:24:42,109 --> 00:24:45,049
이것이 바로 당신이 할 수 있는 일입니다.
완전 이진 트리에서만 그렇게 하십시오.

463
00:24:45,049 --> 00:24:46,490
일반적으로 이진수
당신은 나무가 아닙니다

464
00:24:46,490 --> 00:24:49,650
다음과 같은 좋은 특성을 가지고 있습니다.

465
00:24:49,650 --> 00:24:53,970
좋아요, 이게 다군요.
기본적으로 많은 양입니다.

466
00:24:53,970 --> 00:24:58,372
덧붙일 말이 있어요
또 다른 속성은 다음과 같습니다.

467
00:24:58,372 --> 00:24:59,830
당연히 그들은 그렇게 부릅니다.
힙의 속성.

468
00:25:04,880 --> 00:25:09,520
그래서 몇 가지가 있습니다.
말뚝의 종류.

469
00:25:09,519 --> 00:25:11,889
이런 종류의 더미
이를 바이너리 힙이라고 합니다.

470
00:25:11,890 --> 00:25:14,430
나머지 것들에 대해서는 나중에 이야기하죠.
다음 강의에서.

471
00:25:14,430 --> 00:25:28,690
나는 그것을 이렇게 부를 것이다.
Q. 당연하죠 —

472
00:25:28,690 --> 00:25:47,913
배열은 다음을 나타냅니다.
완전 이진 트리

473
00:25:47,913 --> 00:26:02,269
이를 배열 Q라고 합니다. 그리고 우리는
우리는 각 노드가 만족하기를 원합니다

474
00:26:02,269 --> 00:26:20,769
소위 최대 힙 속성,
Q[i]라고 더 말합니다.

475
00:26:20,769 --> 00:26:29,359
또는 둘 다 Q[j]와 같습니다.
i의 왼쪽에 있는 아이들과 오른쪽에 있는 아이들

476
00:26:29,359 --> 00:26:29,859
나로부터.

477
00:26:37,160 --> 00:26:41,690
그래서 우리는 노드 i를 가지고 있습니다.

478
00:26:41,690 --> 00:26:44,750
그에게는 자녀가 두 명 있습니다.

479
00:26:44,750 --> 00:26:48,289
2i + 1과 2i + 2.

480
00:26:48,289 --> 00:26:50,359
이것들은 j의 두 가지 값입니다.

481
00:26:53,359 --> 00:26:57,139
우리는 관계를 원해요
크거나 같음

482
00:26:57,140 --> 00:26:59,940
여기 그리고 여기.

483
00:26:59,940 --> 00:27:01,940
따라서 이 노드는 다음과 같아야 합니다.
이것보다 더 큰 것

484
00:27:01,940 --> 00:27:02,519
그리고 이것은요.

485
00:27:02,519 --> 00:27:03,889
어느 쪽이 더 큰가요?

486
00:27:03,890 --> 00:27:06,230
우리는 모릅니다.
우린 상관없어 - 그게 다야

487
00:27:06,230 --> 00:27:08,360
매우 다릅니다
이진 탐색 트리

488
00:27:08,359 --> 00:27:11,639
또는 이진 트리의 집합, 여기서 우리는
그들은 이 사람들이 더 작다고 말했다.

489
00:27:11,640 --> 00:27:13,613
또는 이와 동등한
이건 더 작았어요.

490
00:27:13,613 --> 00:27:15,529
또는 모든 노드와 같음
여기 하위 트리에 있습니다.

491
00:27:15,529 --> 00:27:17,240
저희는 그냥 지역 주민입니다.
우리는 이 노드라고 말합니다.

492
00:27:17,240 --> 00:27:20,000
크거나 같음
이 노드와 이 노드.

493
00:27:20,000 --> 00:27:21,799
그래서 가장 큰 것이 맨 위에 있습니다.

494
00:27:26,269 --> 00:27:34,009
그래서 한 가지 좋은 보조정리는 다음과 같습니다.
이 더미들... 이상하네.

495
00:27:34,009 --> 00:27:36,589
제가 드리겠습니다
직관력을 조금 더 발휘하면 좋을 것 같아요.

496
00:27:36,589 --> 00:27:39,679
만약 당신이 이진법주의자라면, 만약 당신이 어디에나 있다면
최대 힙의 이러한 속성을 만족합니다.

497
00:27:39,680 --> 00:27:41,960
, 그 다음에
여러분은 실제로 배우게 될 것입니다.

498
00:27:41,960 --> 00:27:47,509
각 노드 i는 다음과 같습니다.
모든 노드보다 크거나 같습니다

499
00:27:47,509 --> 00:27:48,319
하위 트리에 있습니다.

500
00:27:48,319 --> 00:27:55,759
이것이 우리가 부르는 명칭입니다
하위 트리 i의 자손.

501
00:28:00,750 --> 00:28:03,390
이 예시를 한번 살펴보겠습니다.

502
00:28:03,390 --> 00:28:05,180
그래서 글을 쓰지 않았어요.
여기에는 숫자가 없습니다.

503
00:28:05,180 --> 00:28:06,650
상상해 보세요.

504
00:28:06,650 --> 00:28:10,880
여기서는 A가 더 큽니다.
또는 B와 C 모두와 같음,

505
00:28:10,880 --> 00:28:12,950
그리고 B가 더 큽니다.
또는 D 및 E와 동일함,

506
00:28:12,950 --> 00:28:14,757
그리고 C가 더 큽니다.
또는 F와 G와 같음,

507
00:28:14,757 --> 00:28:16,340
디 더
또는 H와 I와 같음,

508
00:28:16,339 --> 00:28:17,839
그리고 E
J 이상.

509
00:28:17,839 --> 00:28:20,029
이렇게 하면 이렇게 됩니다.
더미 구조, 그리고

510
00:28:20,029 --> 00:28:23,639
완전한 이진 트리만이 아닙니다.

511
00:28:23,640 --> 00:28:24,640
그렇다면 이것은 무엇을 의미할까요?

512
00:28:24,640 --> 00:28:27,380
이는 A를 의미합니다.
최대값이어야 합니다.

513
00:28:27,380 --> 00:28:29,802
그러니까, 어떤 것을 보더라도
예를 들어 J, A와 같은 노드가 여기에 있습니다.

514
00:28:29,801 --> 00:28:32,259
B보다 크거나 같음
E보다 크거나 같음

515
00:28:32,259 --> 00:28:35,400
크거나 같음
J. 그리고 일반적으로 우리는

516
00:28:35,400 --> 00:28:38,100
우리는 A라고 말합니다
모든 노드보다 크거나 같습니다

517
00:28:38,099 --> 00:28:38,730
나무들.

518
00:28:38,730 --> 00:28:41,190
B는 크거나 같습니다.
해당 하위 트리의 모든 노드에

519
00:28:41,190 --> 00:28:42,340
여기.

520
00:28:42,339 --> 00:28:44,759
C는 크거나 같습니다.
해당 하위 트리의 모든 노드에.

521
00:28:44,759 --> 00:28:47,220
저것
이 보조정리는 이렇게 말합니다.

522
00:28:47,220 --> 00:28:50,789
이 보조정리는 증명될 수 있다.
유도.

523
00:28:50,789 --> 00:28:55,279
하지만 사실은 간단합니다.

524
00:28:55,279 --> 00:28:57,829
노드가 두 개 있다면,
그리고 j는 어딘가에 있습니다.

525
00:28:57,829 --> 00:28:59,449
나무 아래에서,
이것은 ~이 있다는 것을 의미합니다.

526
00:28:59,450 --> 00:29:03,769
i에서 j로 향하는 하강 경로.

527
00:29:03,769 --> 00:29:05,509
그리고 그거 아세요?
각 모서리에 대해

528
00:29:05,509 --> 00:29:08,059
우리는 지나가고 있습니다
저 아래로, 우리의 열쇠

529
00:29:08,059 --> 00:29:10,279
정확히 그렇게 되지는 않아요.

530
00:29:10,279 --> 00:29:12,692
그래서 아이들 각자의 체구가 더 작습니다.
혹은 아버지와 동등하거나.

531
00:29:12,692 --> 00:29:14,150
그리고 더 많은 것들
또는 이와 동등한

532
00:29:14,150 --> 00:29:14,960
더
또는 이와 동등한

533
00:29:14,960 --> 00:29:16,335
더
또는 이와 동등한

534
00:29:16,335 --> 00:29:17,900
더
또는 j와 같다는 뜻이죠, 알겠죠?

535
00:29:17,900 --> 00:29:21,470
따라서, 전이성 때문에
이하,

536
00:29:21,470 --> 00:29:24,710
사실 내가
j 이상.

537
00:29:24,710 --> 00:29:27,079
아니, 죄송합니다. 열쇠입니다.
더 큰 i에서

538
00:29:27,079 --> 00:29:28,939
또는 j의 키와 같습니다.

539
00:29:28,940 --> 00:29:30,960
이것이 바로 우리가
우리는 이를 인덱스 i라고 부릅니다.

540
00:29:30,960 --> 00:29:34,170
이것이 바로 우리가
그것은 Q of i라고 불릴 것입니다.

541
00:29:34,170 --> 00:29:37,142
이것은 j의 인덱스 j Q입니다.

542
00:29:40,009 --> 00:29:46,660
완전히 다른 방식
트리 구조에서 키의 구성

543
00:29:46,660 --> 00:29:49,360
하지만 어떻게 그럴 수 있겠어요?
이것을 상상해 보세요

544
00:29:49,359 --> 00:29:50,679
우선순위 대기열에 유용할 것입니다.

545
00:29:50,680 --> 00:29:52,060
우선순위 때문에
줄은 그냥 있어야 해요

546
00:29:52,059 --> 00:29:54,492
요소의 최대 개수를 찾으세요.

547
00:29:54,492 --> 00:29:55,659
그렇다면 그것들을 제거해야 합니다.

548
00:29:55,660 --> 00:29:57,785
이건 더 어려울 거예요.
선도 루트 노드 때문에

549
00:29:57,785 --> 00:30:00,880
이것이 가장 어려운 부분입니다.
직관적인 제거를 위한 노드입니다.

550
00:30:00,880 --> 00:30:02,950
저는 정말 그러고 싶어요
잎을 제거하세요.

551
00:30:02,950 --> 00:30:06,970
하지만 글자를 이끌고
완전 이진 트리를 유지합니다

552
00:30:06,970 --> 00:30:08,470
사실 꽤 어렵습니다.

553
00:30:08,470 --> 00:30:10,930
삭제하고 싶다면
아, 그건 아니야

554
00:30:10,930 --> 00:30:12,759
이진수처럼 보일 것입니다.
나무가 되지 않으면 더 이상 나무가 아닐 것입니다.

555
00:30:12,759 --> 00:30:14,468
완전해 보이네요
이진 트리.

556
00:30:14,468 --> 00:30:16,555
이는 정당화될 수 없습니다.

557
00:30:16,555 --> 00:30:18,430
마찬가지로, 만약 제가 원한다면
F를 삭제하세요. 좋지 않습니다.

558
00:30:18,430 --> 00:30:20,799
왜냐하면 이제 나는 가지고 있기 때문이다
여기에는 노드가 네 개 없습니다.

559
00:30:20,799 --> 00:30:24,869
쉬운 유일한 노드
삭제, J 맞죠?

560
00:30:24,869 --> 00:30:27,379
이 노드를 삭제하면 다음과 같은 문제가 발생합니다.
나무 한 그루 전체가 그대로 남을 것입니다.

561
00:30:27,380 --> 00:30:31,700
마지막 장, 마지막 한 장
내 배열에서의 위치,

562
00:30:31,700 --> 00:30:33,200
쉽게 제거할 수 있습니다.

563
00:30:33,200 --> 00:30:36,390
이것은 배열이기 때문에 좋습니다.
그들은 마지막 요소를 잘 해냅니다.

564
00:30:36,390 --> 00:30:39,770
하지만 제가 여기에 마련해 놓은 것은 다음과 같습니다.
최대값을 쉽게 찾을 수 있는 것은 무엇일까요?

565
00:30:39,769 --> 00:30:41,660
이것은
바로 여기, 근본적인 원인입니다.

566
00:30:41,660 --> 00:30:43,580
삭제가 짜증나네요.

567
00:30:43,579 --> 00:30:48,199
어떻게든 이걸 갖고 싶어요.
열쇠를 제자리에 놓으세요.

568
00:30:48,200 --> 00:30:50,539
마지막 위치에
마지막 페이지에,

569
00:30:50,539 --> 00:30:53,682
이것이 바로 그것이기 때문입니다
제거하기 쉽습니다.

570
00:30:53,682 --> 00:30:55,099
그게 전부예요.
우리는 무엇을 할 건가요?

571
00:30:55,099 --> 00:30:58,250
삭제 알고리즘에서 하는 일입니다.

572
00:30:58,250 --> 00:30:59,599
먼저 제 의견을 말씀드리겠습니다.

573
00:30:59,599 --> 00:31:09,449
제 생각엔 좀 그런 것 같아요
더 단순하고, 겉보기에 대칭적인

574
00:31:09,450 --> 00:31:11,410
방금 말씀드렸듯이.

575
00:31:11,410 --> 00:31:17,130
그래서 만약 제가 키를 삽입하고 싶다면,
특정 키를 가진 요소 x,

576
00:31:17,130 --> 00:31:21,210
다시 말하지만, 내가 가진 유일한 것은
사실 배열을 사용해서 할 수 있어요.

577
00:31:21,210 --> 00:31:23,531
새로운 요소를 추가하고 싶다면,
맨 마지막에 있어야 합니다.

578
00:31:23,531 --> 00:31:24,990
우리가 가진 유일한 것
우리는 이것을 알고 있습니다

579
00:31:24,990 --> 00:31:26,650
배열의 끝에 삽입합니다.

580
00:31:26,650 --> 00:31:28,742
이것이 바로 우리가
insert_last라고 호출됩니다.

581
00:31:33,819 --> 00:31:34,319
그것?

582
00:31:34,319 --> 00:31:39,269
추가 사항에 해당합니다.
x를 포함하는 노드--

583
00:31:39,269 --> 00:31:44,379
요소 x-- 마지막에
완전 이진법의 수준

584
00:31:44,380 --> 00:31:44,880
나무들.

585
00:31:44,880 --> 00:31:47,130
그는 오른쪽으로 가거나
기존의 모든 노드에서,

586
00:31:47,130 --> 00:31:48,150
또는 새로운 레벨을 시작합니다.

587
00:31:48,150 --> 00:31:50,238
하지만 언제나 그렇죠
그것이 마지막 잎이 될 것이다.

588
00:31:50,238 --> 00:31:51,779
완료 후
끼워 넣다,

589
00:31:51,779 --> 00:31:54,029
위치 크기는 Q에서 1을 뺀 값이 됩니다. 하지만

590
00:31:57,805 --> 00:31:59,830
아마도 이것일 겁니다
충분하지 않다.

591
00:31:59,829 --> 00:32:01,839
방금 삽입했습니다
시트 내의 임의의 요소.

592
00:32:01,839 --> 00:32:04,889
이제 그는 더 이상 만족시키지 못할지도 모릅니다.
최대 힙 속성.

593
00:32:04,890 --> 00:32:08,110
그럼 그게 사실인지 확인해 봅시다.
만약 그렇지 않다면, 저희가 고치겠습니다.

594
00:32:08,109 --> 00:32:10,490
우리가 할 수 있는 일은 이렇습니다.

595
00:32:10,490 --> 00:32:12,220
하지만 이번에는
우리는 심지어

596
00:32:12,220 --> 00:32:23,960
순환 근무가 필요할 것입니다.
이거 멋지네요.

597
00:32:23,960 --> 00:32:25,710
그래서 저는 결정하겠습니다.
작업이라고 불리는

598
00:32:25,710 --> 00:32:29,190
max_heapify_up.

599
00:32:29,190 --> 00:32:33,170
이것은 효과가 있을 겁니다.
최대 힙에 더 가깝다.

600
00:32:33,170 --> 00:32:39,810
크기부터 시작해 볼까요?
우리의 i 값에 대해서는 Q에서 1을 뺀 값입니다.

601
00:32:39,809 --> 00:32:43,859
하지만 이는 재귀적으로 실행될 것입니다.
그래서 우리는 갈 거예요

602
00:32:43,859 --> 00:32:49,289
노드 i를 보세요.
특히, 그 하나에

603
00:32:49,289 --> 00:32:50,490
방금 삽입된 것입니다.

604
00:32:50,490 --> 00:32:52,230
그리고 어디에
그것 때문에 문제가 생겼을까요?

605
00:32:52,230 --> 00:32:58,789
음, 그의 아버지와 함께, 왜냐하면
우리는 열쇠가 무엇인지 모릅니다

606
00:32:58,789 --> 00:32:59,750
우리는 그냥 여기에 뒀어요.

607
00:32:59,750 --> 00:33:01,220
어쩌면 우리 아버지 세대보다는 못할지도 몰라.

608
00:33:01,220 --> 00:33:02,210
그러면 우리는 행복합니다.

609
00:33:02,210 --> 00:33:05,180
하지만 만약 그것이 보다 크다면
우리 아버지, 우리에게 문제가 있어요.

610
00:33:05,180 --> 00:33:06,950
우리는 이 문제를 해결해야 합니다.

611
00:33:06,950 --> 00:33:23,090
따라서 부모 요소의 요소가 어떤 경우
키 i보다 작은 키--

612
00:33:25,736 --> 00:33:28,705
아, 제가 깜빡하고 안 썼네요.
열쇠와 이 모든 얼룩들.

613
00:33:28,704 --> 00:33:32,000
이건 점 키여야 합니다.
그리고 점이 있는 열쇠,

614
00:33:32,000 --> 00:33:37,190
Q[i]는 다음과 같으므로
키를 얻는 요소.

615
00:33:37,190 --> 00:33:38,660
그래서 이건 좋지 않은 경우입니다.

616
00:33:38,660 --> 00:33:41,360
이것은 아버지가
아이보다 작다.

617
00:33:41,359 --> 00:33:43,399
우리는 부모님들이
항상 그랬다

618
00:33:43,400 --> 00:33:45,240
자녀보다 크거나 같다.

619
00:33:45,240 --> 00:33:49,309
그러므로,
그런 경우 우리는 무엇을 할 수 있을까요?

620
00:33:49,309 --> 00:33:50,149
서로 바꿔보세요.

621
00:33:53,690 --> 00:33:58,640
부모 요소 i의 Q 값을 바꿔봅시다.

622
00:33:58,640 --> 00:34:03,970
훌륭합니다, 더
분필-- Q[i]에.

623
00:34:03,970 --> 00:34:06,100
이제 순서대로 정렬되었습니다.

624
00:34:06,099 --> 00:34:08,650
이제 우리는 다음 사항들을 생각해 봐야 합니다.
또 다른 자식 요소

625
00:34:08,650 --> 00:34:10,449
이 노드 말인가요?

626
00:34:10,449 --> 00:34:13,039
그의 아버지는 어떠셨나요?

627
00:34:13,039 --> 00:34:15,889
제가 몇 가지 수치를 가지고 있습니다.

628
00:34:15,889 --> 00:34:22,120
만약 그랬다고 가정해 봅시다.
5였고, 이건 10이었어요.

629
00:34:22,119 --> 00:34:24,909
내가 뭘 알겠어?
이 사진 이전 모습인가요?

630
00:34:24,909 --> 00:34:29,590
음, 저는 10이라는 걸 알고 있어요 -
이것은 새로 삽입된 요소입니다.

631
00:34:29,590 --> 00:34:32,380
이것이 유일한 것입니다
위반을 초래할 수 있습니다.

632
00:34:32,380 --> 00:34:33,980
처음 삽입했을 때요.

633
00:34:33,980 --> 00:34:37,420
그래서 저는 그 전에는...
내가 10을 재배열하기 전에,

634
00:34:37,420 --> 00:34:40,090
나는 모든 것이 그렇다는 것을 알고 있었다.
이 왼쪽 하위 트리에서

635
00:34:40,090 --> 00:34:44,199
이하
5, 그리고 여기 위에 있는 모든 것

636
00:34:44,199 --> 00:34:47,559
5와 같도록 생성되었습니다.

637
00:34:47,559 --> 00:34:50,590
저는 노드에 대해서도 알고 있습니다.
여기서는 실제로 더 적었습니다.

638
00:34:50,590 --> 00:34:51,219
또는 5와 같음.

639
00:34:51,219 --> 00:34:55,539
노드 10을 제외하면,
방금 삽입한 것,

640
00:34:55,539 --> 00:34:57,139
그것은 적절한 더미였다.

641
00:34:57,139 --> 00:34:59,320
그래서 5가 구분자였습니다.

642
00:34:59,320 --> 00:35:01,090
그 위에 있는 것 때문에
조상의 사슬

643
00:35:01,090 --> 00:35:04,180
크거나 같음
5, 그리고 하위 트리에 있는 객체들

644
00:35:04,179 --> 00:35:06,579
그것보다 작거나 같다.

645
00:35:06,579 --> 00:35:11,920
그래서, 제가 이렇게 교체를 하고 나면,
제가 지금 하려는 일은 바로 그거예요.

646
00:35:15,280 --> 00:35:21,310
5번째 요소와 를 교환한 후에
10, 여기 10, 그리고 여기 5.

647
00:35:21,309 --> 00:35:23,349
이제야 이해가 되네요.
좋아, 훌륭해, 이건 갈비뼈야

648
00:35:23,349 --> 00:35:26,259
이제 10살이 되어서 행복해요
5 이상.

649
00:35:26,260 --> 00:35:28,690
하지만 이 갈비뼈도 행복해 보여요.
전에는 행복했으니까요.

650
00:35:28,690 --> 00:35:31,599
그리고 우리는 오직
상위 요소의 크기를 증가시켰습니다.

651
00:35:31,599 --> 00:35:34,539
이러한 측면은 어쩌면 좋지 않을 수도 있습니다.

652
00:35:34,539 --> 00:35:35,664
그래서 우리는 재귀 호출을 해야 합니다.

653
00:35:39,139 --> 00:35:41,809
부모 요소로 재귀 호출.

654
00:35:45,070 --> 00:35:46,470
그게 전부입니다.

655
00:35:46,469 --> 00:35:47,844
그래서 우리는 이 부분을 수정했습니다.

656
00:35:47,844 --> 00:35:49,719
먼저 그것이 발생합니다
용지 맨 아래쪽에.

657
00:35:49,719 --> 00:35:52,149
하지만 일반적으로
우리는 우리의 요소를 취합니다.

658
00:35:52,150 --> 00:35:56,349
우리가 삽입한 것은 x입니다.
그리고 이야기는 마지막 페이지부터 시작됩니다.

659
00:35:56,349 --> 00:35:58,150
그리고 거품일 수도 있습니다.
한동안은요.

660
00:35:58,150 --> 00:35:59,858
어쩌면 그는 모든 것을 이룰지도 모릅니다.
뿌리,

661
00:35:59,858 --> 00:36:01,660
만약 우리가 삽입한다면
새로운 최대 요소.

662
00:36:01,659 --> 00:36:03,609
하지만 모든 단계에서
그는 한 계단을 올라간다.

663
00:36:03,610 --> 00:36:06,730
그러므로,
이 모든 것의 작동 시간

664
00:36:06,730 --> 00:36:12,228
높이입니다
나무의 경우, 이는 log n과 같습니다.

665
00:36:12,228 --> 00:36:14,769
그리고 단지 하나뿐이기 때문에
잠재적으로 가능한 한 가지 요소

666
00:36:14,769 --> 00:36:16,269
그가 틀렸다면
움직임을 멈추는 일은 결코 없을 것이다.

667
00:36:16,269 --> 00:36:18,190
우리는 방금 확인했습니다.
그는 만족시키나요?

668
00:36:18,190 --> 00:36:19,990
최대 힙 속성.

669
00:36:19,989 --> 00:36:21,609
그가 만약 ~하게 된다면
루트 권한을 얻으면 다음 작업도 수행할 수 있습니다.

670
00:36:21,610 --> 00:36:23,367
조건을 충족하는지 확인하십시오
최대 힙 속성.

671
00:36:23,367 --> 00:36:25,159
따라서 기본 시나리오는 다음과 같습니다.
저는 여기에 글을 쓰지 않았습니다.

672
00:36:25,159 --> 00:36:30,759
즉, i가 0이면 우리는
기본적으로, 우리는 끝났습니다.

673
00:36:30,760 --> 00:36:34,413
그러면 당신은 그것을 증명할 수 있습니다.
이는 귀납적으로 옳습니다.

674
00:36:34,413 --> 00:36:36,829
단 하나의 주제만 있습니다.
처음에 잘못된 위치에 있었습니다.

675
00:36:36,829 --> 00:36:38,480
그리고 우리는 그것을 제자리에 놓았습니다.

676
00:36:38,480 --> 00:36:42,769
그가 갈 수 있는 곳은 많습니다.
가세요, 하지만 저희가 옮기겠습니다.

677
00:36:42,769 --> 00:36:46,039
저는 이것이 독특하다고 생각합니다.
조상의 위치는 정확합니다.

678
00:36:46,039 --> 00:36:48,500
만족시키는
최대 힙 속성, 알겠죠?

679
00:36:48,500 --> 00:36:50,179
이것은 삽입물입니다.

680
00:36:50,179 --> 00:37:03,000
거의 이렇게 삭제될 것입니다.
마찬가지로 delete_min도 마찬가지입니다...

681
00:37:14,010 --> 00:37:17,307
죄송합니다, delete_max님, 감사합니다.

682
00:37:17,306 --> 00:37:19,139
물론, 당신은 결정할 수 있습니다.
이 모든 것들

683
00:37:19,139 --> 00:37:20,129
최대값 대신 최소값을 사용합니다.

684
00:37:20,130 --> 00:37:21,360
모든 것이 똑같이 작동합니다.

685
00:37:21,360 --> 00:37:23,160
저는 그냥
기억하기 어렵네요.

686
00:37:23,159 --> 00:37:25,319
저희는 그렇게 하고 있습니다.

687
00:37:25,320 --> 00:37:28,220
바꾸지 마세요, 사용할 수 없어요
delete_min을 실행하는 데 필요한 최대 힙 크기입니다.

688
00:37:28,219 --> 00:37:29,969
min-heap을 사용할 수 없습니다.
delete_max의 경우,

689
00:37:29,969 --> 00:37:32,789
하지만 사용할 수 있습니다
delete_min에 대한 최소 힙입니다.

690
00:37:32,789 --> 00:37:35,199
이것은 정상입니다

691
00:37:35,199 --> 00:37:40,679
그래서 제가 말씀드린 대로, 유일한 노드는
우리는 삭제하는 방법을 정말 잘 알고 있어요.

692
00:37:40,679 --> 00:37:42,519
이것이 마지막 편지입니다
마지막 단계에서,

693
00:37:42,519 --> 00:37:43,920
이는 배열의 끝입니다.

694
00:37:43,920 --> 00:37:47,550
배열이란 그런 것이니까요.
효과적으로 제거할 수 있습니다.

695
00:37:47,550 --> 00:37:50,100
그렇다면 우리에게 필요한 것은 무엇일까요?
삭제, 그것이 루트 요소입니다.

696
00:37:50,099 --> 00:37:52,380
왜냐하면 언제나 그렇기 때문입니다
최대 요소

697
00:37:52,380 --> 00:37:54,490
첫 번째에 있습니다
배열의 위치.

698
00:37:54,489 --> 00:37:55,889
그렇다면 우리는 어떻게 해야 할까요?

699
00:37:55,889 --> 00:38:00,322
서로 바꿔치기하는 게 우리가 늘 하는 방법이죠.

700
00:38:00,322 --> 00:38:01,739
제 생각에는
더미 중에서 가장 흥미로운 것

701
00:38:01,739 --> 00:38:03,369
우리가 절대 필요로 하지 않는 것
회전을 하기 위해.

702
00:38:03,369 --> 00:38:05,369
우리는 오직 그렇게 할 것입니다
교환

703
00:38:05,369 --> 00:38:06,839
우리는 나무 문제도 처리해야 했습니다.

704
00:38:06,840 --> 00:38:07,650
이진 트리.

705
00:38:11,086 --> 00:38:18,780
Q[0]의 Q 마지막 요소--

706
00:38:18,780 --> 00:38:19,440
좋아요, 완료했습니다.

707
00:38:19,440 --> 00:38:22,329
이제 마지막 요소가 남았습니다.
삭제하고 싶습니다.

708
00:38:22,329 --> 00:38:30,420
그래서 우리는 delete_last를 하거나 입력을 합니다.
파이썬, 그리고 짜잔, 우리는...

709
00:38:30,420 --> 00:38:32,340
이제 우리는 제거했습니다
최대 요소.

710
00:38:32,340 --> 00:38:36,210
물론, 우리도 할 수 있습니다.
max-heap 속성을 잘못 설정하세요

711
00:38:36,210 --> 00:38:40,230
삽입물과 마찬가지입니다.

712
00:38:40,230 --> 00:38:43,409
그래서 삽입물을 사용하면
마지막 장을 추가했습니다.

713
00:38:43,409 --> 00:38:46,049
이제 우리는
우리는 마지막 잎을 바꿉니다

714
00:38:46,050 --> 00:38:46,710
와 함께...

715
00:38:46,710 --> 00:38:48,300
제가 가리키고 있는 것은...
잘못된 이미지입니다.

716
00:38:48,300 --> 00:38:50,610
이 나무로 다시 돌아가 보겠습니다.

717
00:38:50,610 --> 00:38:55,530
우리가 한 일은 J 지점을 변경한 것입니다.
A에 대해서요. 그러니까 문제는 그거예요.

718
00:38:55,530 --> 00:38:57,450
해당 노드를 제거했습니다.

719
00:38:57,449 --> 00:38:59,909
이제 문제는,
이 루트 노드

720
00:38:59,909 --> 00:39:01,829
열쇠가 아주 작을지도 모릅니다.

721
00:39:01,829 --> 00:39:04,900
왜냐하면 핵심은
자, 여기, 여기 아래쪽에 있던 게 바로 이거였어요.

722
00:39:04,900 --> 00:39:06,150
나무의 아주 아랫부분에 있습니다.

723
00:39:06,150 --> 00:39:08,910
그러므로 직관적으로 명확합니다.
그것은 별로 중요하지 않다는 것입니다.

724
00:39:08,909 --> 00:39:10,629
이것은
최댓값이 되어야 합니다.

725
00:39:10,630 --> 00:39:12,700
그리고 우리는 작은 것을 넣었습니다.
루트에 있는 값입니다.

726
00:39:12,699 --> 00:39:14,039
그렇다면 우리는 어떻게 해야 할까요?

727
00:39:14,039 --> 00:39:16,539
쏟아부어라.

728
00:39:16,539 --> 00:39:19,050
저희는 이걸로 할게요.
요소를 어떻게든 밀어붙이는 겁니다.

729
00:39:19,050 --> 00:39:21,390
나무에게,

730
00:39:21,389 --> 00:39:24,759
그것이 될 때까지
max-heap 속성이 구현되었습니다.

731
00:39:24,760 --> 00:39:30,960
자, 이것이 바로
max_heapify_down이 될 것입니다.

732
00:39:30,960 --> 00:39:34,590
그리고 우리는 그 위치에서부터 시작할 것입니다.
0은 근입니다.

733
00:39:38,119 --> 00:39:45,839
그리고 max_heapify_down
이는 재귀 알고리즘이 될 것입니다.

734
00:39:45,840 --> 00:39:47,990
그럼, 먼저 시작하겠습니다.
어떤 위치 i.

735
00:39:47,989 --> 00:39:49,939
그리고 우선 그것이 뿌리입니다.

736
00:39:49,940 --> 00:39:53,954
우리가 하려는 일은 다음과 같습니다.
위치 i와 그 두 위치를 살펴보겠습니다.

737
00:39:53,954 --> 00:39:54,454
어린이들.

738
00:39:57,349 --> 00:40:01,089
우리가 들어간다고 가정해 봅시다.
여기에는 0과 같은 아주 작은 값이 있습니다.

739
00:40:01,090 --> 00:40:04,180
그리고 우리가 가지고 있다고 가정해 봅시다.
아이들, 5살과 10살.

740
00:40:04,179 --> 00:40:06,219
우리는 몰라요, 아마도요.
순서를 바꾸겠습니다.

741
00:40:06,219 --> 00:40:10,419
좀 더 일반적으로 말하자면, 왜냐하면
아닌 것 같네요.

742
00:40:10,420 --> 00:40:12,700
이진수
트리를 검색하지만, 우리는 그렇지 않습니다.

743
00:40:12,699 --> 00:40:14,059
우리는 그들의 상대적인 순서를 알고 있습니다.

744
00:40:14,059 --> 00:40:17,070
하지만 그들 중 한 명은
다른 것보다 크거나 같음

745
00:40:17,070 --> 00:40:18,920
특정한 순서대로.

746
00:40:18,920 --> 00:40:21,909
제가 원하는 건 뭐냐고요?
이러한 지역적 상황을 바로잡기 위해 무엇을 해야 할까요?

747
00:40:25,369 --> 00:40:26,839
네, 교환하고 싶습니다.

748
00:40:26,840 --> 00:40:28,490
그리고 저는 자리를 바꿀 수도 있어요.

749
00:40:28,489 --> 00:40:29,899
0은 분명히 잘못된 위치에 있습니다.

750
00:40:29,900 --> 00:40:31,400
그는 내려가야만 한다.
나무 아래쪽에 있습니다.

751
00:40:31,400 --> 00:40:34,280
0을 다음으로 바꿀 수 있습니다
10점 만점에 5점 또는 0점.

752
00:40:34,280 --> 00:40:35,810
어느?

753
00:40:35,809 --> 00:40:36,309
10.

754
00:40:39,010 --> 00:40:43,435
나는 그림을 그릴 수 있다
5점이지만, 그는 기뻐하지 않을 거예요.

755
00:40:46,179 --> 00:40:46,887
왜 10이죠?

756
00:40:46,887 --> 00:40:48,429
우리는 이것을 하고 싶습니다.
더 많은 것을 더하면,

757
00:40:48,429 --> 00:40:51,009
그러면 이것이
땅은 행복해질 것이다.

758
00:40:51,010 --> 00:40:52,660
그리고 이 지역도 마찬가지입니다
행복할 거예요.

759
00:40:52,659 --> 00:40:56,710
만약 제가 거기에 있는 5를 교체한다면,
5/10의 우위는 불행한 일일 것이다.

760
00:40:56,710 --> 00:40:58,460
이것으로는 충분하지 않습니다.
최대 힙 속성.

761
00:40:58,460 --> 00:41:01,269
그래서 저는 한 가지를 대체할 수 있습니다.
max-heap 속성을 수정합니다.

762
00:41:01,269 --> 00:41:05,679
또한, 다시 말하지만, 0은 다음과 같을 수 있습니다.
자녀들에 불만을 품고 있었다.

763
00:41:05,679 --> 00:41:08,379
0은 하나의 항목입니다.
잘못된 장소에 있었다.

764
00:41:08,380 --> 00:41:10,210
그래서 그것은 필요했습니다.
더 아래로 내려가세요.

765
00:41:10,210 --> 00:41:11,559
하지만 5는...

766
00:41:11,559 --> 00:41:12,789
5는 움직이지도 않았다.

767
00:41:12,789 --> 00:41:13,599
그게 바로 행복한 거죠.

768
00:41:13,599 --> 00:41:16,960
이
하위 트리는 괜찮습니다.  그리고

769
00:41:16,960 --> 00:41:18,460
부모님은 어떻게 하시나요?

770
00:41:18,460 --> 00:41:20,949
음, 생각해 보면 그렇죠.
이는 모든 것 때문입니다

771
00:41:20,949 --> 00:41:23,889
적절한 사람들이었다
0을 추가하기 전에

772
00:41:23,889 --> 00:41:26,769
또는 0을 넣기 전에
높음, 이 모든 노드들

773
00:41:26,769 --> 00:41:33,820
보다 크거나 같을 것입니다
조상의 길을 따라 10번째.

774
00:41:33,820 --> 00:41:36,550
그리고 이 모든 노드는
10 이하

775
00:41:36,550 --> 00:41:38,380
더 일찍, 만약
당신은 5와 같지 않습니다.

776
00:41:38,380 --> 00:41:41,510
그러니까 그건 여전히 사실입니다.

777
00:41:41,510 --> 00:41:43,880
하지만 이 나무는 행복해 보입니다.

778
00:41:43,880 --> 00:41:45,200
이 나무는 여전히 불행할지도 모릅니다.

779
00:41:45,199 --> 00:41:47,449
0이 여전히 필요할 수도 있습니다.
다음 버튼을 누르세요.

780
00:41:47,449 --> 00:41:50,299
그것
재귀 호출이 발생할 것입니다.

781
00:41:50,300 --> 00:41:56,650
자, 그럼 여기서 확인해 봅시다.

782
00:42:06,469 --> 00:42:09,649
기본 사례가 있습니다. 즉,
만약 i가 나뭇잎이라면, 우리는 끝입니다.

783
00:42:09,650 --> 00:42:11,269
을 위한
그 아래에는 아무것도 없다.

784
00:42:13,900 --> 00:42:17,099
그래서 우리는 만족시킵니다.
i번째 힙의 최대 속성,

785
00:42:17,099 --> 00:42:18,750
아이들이 없기 때문입니다.

786
00:42:18,750 --> 00:42:24,400
그렇지 않다면, 한번 살펴보겠습니다.
왼쪽에 있는 잎사귀 중 하나-

787
00:42:24,400 --> 00:42:26,700
죄송합니다, 잎이 아니라 왼쪽입니다.

788
00:42:26,699 --> 00:42:29,639
두 아이 사이
i의 왼쪽과 오른쪽.

789
00:42:29,639 --> 00:42:30,960
맞아요, 제가 존재하지 않는다면 말이죠.

790
00:42:30,960 --> 00:42:32,000
그럼 무시하세요.

791
00:42:32,000 --> 00:42:36,000
하지만 둘 사이에는
기존 자식 요소

792
00:42:36,000 --> 00:42:42,327
가지고 있는 것을 찾으세요
최대 키 값, Q[j].key.

793
00:42:46,840 --> 00:42:49,090
우리 예시에서는 10이었습니다.

794
00:42:49,090 --> 00:42:52,039
그리고 만약 이것들이
점수 순서가 뒤죽박죽입니다.

795
00:42:52,039 --> 00:42:54,460
만약 우리가 만족시키지 못한다면--

796
00:42:54,460 --> 00:42:56,710
네, 그 이상입니다.
만족할 것입니다.

797
00:42:56,710 --> 00:43:00,550
Q[j]보다 작을 것입니다.
최대 힙 속성의 반대

798
00:43:00,550 --> 00:43:03,850
.

799
00:43:03,849 --> 00:43:06,559
최대힙 속성인 경우
위반되었습니다.

800
00:43:06,559 --> 00:43:15,159
우리는 다음과 같이 해결합니다
Q[i]를 Q[j]로 대체합니다.

801
00:43:15,159 --> 00:43:17,589
그런 다음 j를 재귀적으로 실행합니다.

802
00:43:21,699 --> 00:43:24,980
j에 대해 max_heapify_down을 호출합니다.

803
00:43:24,980 --> 00:43:25,559
그게 다예요.

804
00:43:25,559 --> 00:43:26,460
그래서 상당히 대칭적입니다.

805
00:43:26,460 --> 00:43:28,460
끼워 넣기엔 좀 무리가 있었다.
더 쉬운 이유는 우리에게는 단지 몇 가지밖에 없기 때문입니다.

806
00:43:28,460 --> 00:43:29,780
한 아버지.

807
00:43:29,780 --> 00:43:31,610
Delete_min, 왜냐하면
우리는 아래로 누릅니다.

808
00:43:31,610 --> 00:43:32,760
저희에게는 자녀가 두 명 있습니다.

809
00:43:32,760 --> 00:43:34,140
우리는 하나를 선택해야 합니다.

810
00:43:34,139 --> 00:43:36,469
하지만 분명한 점이 있습니다.
선택의 폭이 더 넓어졌습니다.

811
00:43:36,469 --> 00:43:38,929
그리고 다시 한번, 이 알고리즘은—
이 모든 것—

812
00:43:38,929 --> 00:43:40,980
h시간 순서대로 진행됩니다.
나무 높이,

813
00:43:40,980 --> 00:43:44,409
이는 log n입니다. 왜냐하면 우리의
해당 노드가 그냥 사라집니다.

814
00:43:44,409 --> 00:43:45,409
어느 시점에서 멈추게 됩니다.

815
00:43:45,409 --> 00:43:47,480
소리가 멈추면, 우리는 여기서 작업이 끝났다는 것을 알게 됩니다.
최대 힙 속성

816
00:43:47,480 --> 00:43:49,050
.

817
00:43:49,050 --> 00:43:51,470
그리고 가는 길에 확인해 보세요
유도,

818
00:43:51,469 --> 00:43:53,000
나머지 모두
최대 힙의 속성

819
00:43:53,000 --> 00:43:57,400
만족할 것입니다.
왜냐하면 그것들은 예전부터 거기에 있었기 때문입니다.

820
00:43:57,400 --> 00:43:59,670
그러므로 이는 거의 불가피하다.
우리가 여기서 할 수 있는 일.

821
00:43:59,670 --> 00:44:01,420
놀라운 점은,
당신이 실제로 할 수 있는 일

822
00:44:01,420 --> 00:44:04,240
완전한 지원을 위해
조건을 만족하는 이진 트리

823
00:44:04,239 --> 00:44:05,799
최대 힙 속성.

824
00:44:05,800 --> 00:44:08,560
하지만 그들이 당신에게 말하는 순간,
알고리즘에 문제가 있는 것 같습니다.

825
00:44:08,559 --> 00:44:09,804
배열이 있기 때문입니다.

826
00:44:09,804 --> 00:44:11,679
우리가 할 수 있는 유일한 일
해야 할 일은 삽입과 삭제입니다.

827
00:44:11,679 --> 00:44:12,585
마지막 요소.

828
00:44:12,585 --> 00:44:14,710
그러므로 우리는 변화해야 합니다.
그곳은 모든 것이 질서정연하다.

829
00:44:14,710 --> 00:44:18,170
또는 거기서부터,
제대로 작동하도록 하기 위해서요.

830
00:44:18,170 --> 00:44:20,500
그리고 나머지는...
현지 인증만 가능합니다.

831
00:44:20,500 --> 00:44:22,329
그 건물을 수리해 주실 수 있나요?

832
00:44:24,929 --> 00:44:27,000
멋지네요

833
00:44:27,000 --> 00:44:32,300
거의 모든 것, 아니요
바로 우리가 원하던 거예요.

834
00:44:32,300 --> 00:44:36,370
이제 우리 힙에는 log n amortize가 있습니다.
삽입 및 삭제 최대

835
00:44:36,369 --> 00:44:39,329
.

836
00:44:39,329 --> 00:44:41,259
아직 그러지 않았어요.
선형 설계로 간주되었습니다.

837
00:44:41,260 --> 00:44:45,070
지금은 n log n입니다.
n번 삽입하면.

838
00:44:45,070 --> 00:44:47,830
그리고 우리는 아직 그 방법을 알려주지도 않았어요.
제자리 정렬 알고리즘을 사용하여 처리하세요.

839
00:44:47,829 --> 00:44:49,029
.

840
00:44:49,030 --> 00:44:52,660
그럼 하나씩 그려볼게요.

841
00:44:52,659 --> 00:44:56,489
첫 번째 건은 제자리에 있는 것 같아요.

842
00:44:56,489 --> 00:45:01,529
그럼 이걸 어떻게 만드는 걸까요?
알고리즘이 적용되었습니까?

843
00:45:01,530 --> 00:45:04,215
저는 이걸 원하는 것 같아요.
하지만 저는 그게 필요 없어요.

844
00:45:06,719 --> 00:45:09,819
그래서 우리는 다음을 고수하고 싶습니다.
대기열의 우선순위 정렬.

845
00:45:09,820 --> 00:45:10,760
어쩌면 난 그걸 원할지도 몰라.

846
00:45:16,570 --> 00:45:22,059
하지만 저는 그러고 싶지 않아요.
배열을 확장하거나 축소하세요.

847
00:45:22,059 --> 00:45:24,235
저는 시작하고 싶습니다
산맥 자체에서부터.

848
00:45:36,500 --> 00:45:37,675
그러니까 완전히 맞는 말이에요.

849
00:45:41,976 --> 00:45:43,809
그럼 우리는 어떻게 할까요?
할 일은 이렇게 말하는 것입니다: 좋아요, 여기 있어요

850
00:45:43,809 --> 00:45:47,547
정렬하고 싶은 배열입니다.

851
00:45:47,547 --> 00:45:48,339
이것은 내게 주어진 것이다.

852
00:45:48,340 --> 00:45:50,400
이것은 입력값입니다.
대기열의 우선순위 정렬.

853
00:45:53,650 --> 00:45:56,320
제가 하고 싶은 것은 건설하는 것입니다.
우선순위 대기열에서.

854
00:45:56,320 --> 00:45:57,820
처음에는 비어 있습니다.

855
00:45:57,820 --> 00:46:02,600
그리고 나서 삽입하고 싶습니다
요소를 하나씩 차례대로 살펴보자고 합시다.

856
00:46:02,599 --> 00:46:05,000
일반적으로 말하자면
나는 간다

857
00:46:05,000 --> 00:46:09,018
Q라고 주장하다
A의 접두사 중 하나입니다.

858
00:46:09,018 --> 00:46:10,559
이것은
내 우선순위 목록.

859
00:46:10,559 --> 00:46:15,110
그는 이 안에서 살아갈 것이다.
부분 배열 -- 이 접두사.

860
00:46:15,110 --> 00:46:17,240
그렇다면 새 요소를 어떻게 삽입하나요?

861
00:46:17,239 --> 00:46:20,509
자, 지금 확대해서 보고 있어요.

862
00:46:20,510 --> 00:46:29,090
자, 삽입물을 만들려면 먼저
다음 단계는 Q의 크기를 늘리는 것입니다.

863
00:46:29,090 --> 00:46:31,025
그럼 제가 가져가겠습니다.
A에서 다음 요소

864
00:46:31,025 --> 00:46:32,539
그리고 이 질문에 입력하세요.

865
00:46:32,539 --> 00:46:37,429
그리고 우리가 살펴보면 편리합니다.
여기에 저희 임베드 코드가 있습니다.

866
00:46:37,429 --> 00:46:39,469
우리가 제일 먼저 할 일은
아이템을 추가하고 싶습니다

867
00:46:39,469 --> 00:46:40,599
배열의 끝부분에.

868
00:46:40,599 --> 00:46:43,940
그래서 우리는 그냥 없이 했어요
실제 작업만 해당됩니다.

869
00:46:43,940 --> 00:46:44,697
개념적인 작업.

870
00:46:44,697 --> 00:46:46,280
우리는 그냥 "오"라고 말했어요.
우리의 Q는 하나 더 큽니다.

871
00:46:46,280 --> 00:46:46,780
팔!

872
00:46:46,780 --> 00:46:49,430
이제 들어왔습니다
배열의 끝 부분입니다.

873
00:46:49,429 --> 00:46:52,480
더 이상 감가상각이 없습니다.
사실, 왜냐하면 우리는 결코

874
00:46:52,480 --> 00:46:54,230
배열의 크기를 변경합니다.
우리는 그냥 이렇게 말하는 거예요, 아,

875
00:46:54,230 --> 00:46:57,050
지금 Q는 약간
접두사보다 큽니다.

876
00:46:57,050 --> 00:46:59,450
그는 그저 흡수할 뿐입니다.
다음 요소 A.

877
00:46:59,449 --> 00:47:06,329
마찬가지로 delete_max
가고 있다,

878
00:47:06,329 --> 00:47:12,259
마지막으로 줄이세요
크기 Q. 왜 이것이 정상인가요?

879
00:47:12,260 --> 00:47:16,520
왜냐하면 결국 우리
delete_max 작업 —

880
00:47:16,519 --> 00:47:19,519
아직 완전히 끝난 건 아니에요.
하지만 거의 끝부분에 -

881
00:47:19,519 --> 00:47:22,159
우리는 마지막 하나를 제거했습니다
우리 배열의 요소입니다.

882
00:47:22,159 --> 00:47:25,309
그래서 우리는 방금 교체했습니다.
마지막 항목을 감소시켜 제거합니다.

883
00:47:25,309 --> 00:47:28,289
그리고 이것은
Q 값을 1만큼 감소시킵니다.

884
00:47:28,289 --> 00:47:31,429
이것은 완전히 똑같은 효과를 냅니다.
마지막 요소의 우선순위 또한 마찬가지입니다.

885
00:47:31,429 --> 00:47:34,519
하지만 지금은 시간이 끊임없이 흐릅니다.
최악의 경우에도 감가상각이 되지 않습니다.

886
00:47:34,519 --> 00:47:37,789
그 결과 우리는 결코
우리는 동적 배열을 생성합니다.

887
00:47:37,789 --> 00:47:40,139
우리는 그냥 사용합니다
이 파트 A에 대해서입니다.

888
00:47:40,139 --> 00:47:41,644
그래서, 뭐
그렇게 될 겁니다, 우리

889
00:47:41,644 --> 00:47:43,894
우리는 모든 요소를 ​​흡수할 것입니다
우선순위 대기열에서,

890
00:47:43,894 --> 00:47:45,619
그러고 나서 우리는 그것들을 버리기 시작할 겁니다.

891
00:47:45,619 --> 00:47:49,789
우리가 그들을 추방할 때, 우리는
먼저 가장 중요한 핵심 요소를 버립니다.

892
00:47:49,789 --> 00:47:52,099
그리고 여기에 놓으세요.
다음으로 크기가 큰 것은 다음과 같습니다.

893
00:47:52,099 --> 00:47:53,420
다음으로 큰 규모, 그리고 그 다음으로 큰 규모 순으로 이어집니다.

894
00:47:53,420 --> 00:47:55,010
최소 요소
여기 있을 거예요.

895
00:47:55,010 --> 00:47:56,150
자, 짜잔! 모든 게 해결됐습니다.

896
00:47:56,150 --> 00:48:00,079
그래서 제가 만들었습니다
최소힙 대신 최대힙을 사용합니다.

897
00:48:00,079 --> 00:48:04,099
결국에는 그것이
위쪽으로 정렬된 배열이 될 것입니다.

898
00:48:04,099 --> 00:48:05,299
끝에 max가 붙습니다.

899
00:48:05,300 --> 00:48:07,400
왜냐하면 우리는 항상
우리는 마지막에 물건들을 버립니다.

900
00:48:07,400 --> 00:48:10,200
먼저 최대값을 제거합니다.

901
00:48:10,199 --> 00:48:15,179
자, 이것이 바로 그것입니다.
일반적으로 힙 정렬이라고 합니다.

902
00:48:15,179 --> 00:48:18,750
이와 같은 방법을 적용할 수 있습니다.
삽입 전 정렬 및

903
00:48:18,750 --> 00:48:21,360
선택 정렬을 하면 실제로 알고리즘을 얻을 수 있습니다.
삽입 정렬 및

904
00:48:21,360 --> 00:48:23,820
선택에 따른 정렬, 즉
우리는 어떤 것들이 효과가 있는지 확인했습니다.

905
00:48:23,820 --> 00:48:26,920
배열 접두사에서.

906
00:48:26,920 --> 00:48:29,280
좋아요, 이제 우리는...

907
00:48:29,280 --> 00:48:31,110
우리는 도달했습니다
예,

908
00:48:31,110 --> 00:48:34,390
즉, n log n
현재 사용 중인 정렬 알고리즘.

909
00:48:34,389 --> 00:48:35,639
그래서 그것이 우리의 주요 목표였습니다.

910
00:48:35,639 --> 00:48:37,159
힙 정렬.

911
00:48:37,159 --> 00:48:46,149
간단히 말씀드리자면, 당신에 관한 것입니다.
힙을 생성하는 데는 선형 시간이 걸립니다.

912
00:48:46,150 --> 00:48:47,930
기발한 속임수를 써서.

913
00:48:47,929 --> 00:48:50,139
그러므로, 만약 당신이 삽입한다면
요소 하나씩,

914
00:48:50,139 --> 00:48:53,230
이것은 맞을 것입니다
배열 아래로 삽입합니다.

915
00:48:53,230 --> 00:48:57,039
그리고 객체를 삽입할 때마다,
나는 나무에 올라가야 해.

916
00:48:57,039 --> 00:49:04,170
그러면 이것이 합계가 됩니다.
각 노드의 깊이.

917
00:49:04,170 --> 00:49:08,519
그렇게 하면 n log n이 됩니다.

918
00:49:08,519 --> 00:49:12,150
이것은 i log i에 대한 합입니다.

919
00:49:12,150 --> 00:49:14,610
이것은 n log n으로 밝혀졌습니다.

920
00:49:14,610 --> 00:49:17,309
이것은 n의 팩토리얼의 로그입니다.

921
00:49:17,309 --> 00:49:20,219
멋진 비결은...
대신에 당신이

922
00:49:20,219 --> 00:49:21,809
모든 요소를 ​​추가하세요
동시에 그리고

923
00:49:21,809 --> 00:49:24,804
당신은 아무것도 축적하지 않지만
그런 다음 쌓아 올리는 거죠... 죄송합니다.

924
00:49:24,804 --> 00:49:28,419
아래에서 위로 쌓아 올리는 겁니다.

925
00:49:28,420 --> 00:49:31,530
그래서 우리는 모이고 있습니다.

926
00:49:31,530 --> 00:49:35,190
이제 출발합니다.
축적하기 위해.

927
00:49:35,190 --> 00:49:37,079
그리고 이상하게도, 그게 더 낫다.

928
00:49:37,079 --> 00:49:42,150
이것이 금액이기 때문입니다.
노드 높이.

929
00:49:42,150 --> 00:49:43,809
그리고 실제로 선형적인 것으로 밝혀졌습니다.

930
00:49:43,809 --> 00:49:45,090
이것은 명확하지 않습니다.

931
00:49:45,090 --> 00:49:49,740
하지만 직관적으로 깊이를 위해
는 0이고, 는 log n입니다.

932
00:49:49,739 --> 00:49:51,449
그리고 우리는 가지고 있습니다
나뭇잎이 엄청나게 많다.

933
00:49:51,449 --> 00:49:54,219
시트 수준에서 바로 확인할 수 있습니다.
우리는 n log n을 지불합니다.

934
00:49:54,219 --> 00:49:54,719
그렇지 않나요?

935
00:49:54,719 --> 00:49:57,539
그것들이 n개나 있기 때문에,
그리고 각각의 비용은 log n입니다.

936
00:49:57,539 --> 00:49:59,849
여기에서,
평판 시트의 경우, 우리는 지속적으로 지불합니다.

937
00:49:59,849 --> 00:50:03,480
높이 때문에
잎의 수는 1입니다.

938
00:50:03,480 --> 00:50:05,250
여기 높이
루트는 log n과 같습니다.

939
00:50:05,250 --> 00:50:06,480
그게 더 낫죠.

940
00:50:06,480 --> 00:50:09,530
이제 우리는 소액을 지불합니다
물건값,

941
00:50:09,530 --> 00:50:11,040
그중에는 많은 종류가 있습니다.

942
00:50:11,039 --> 00:50:12,730
이건 좀 아니네요.
기하급수,

943
00:50:12,730 --> 00:50:15,090
하지만 알고 보니 선형적인 관계였다.

944
00:50:15,090 --> 00:50:17,789
자, 그럼 이렇게 하시면 됩니다.
선형으로 쌓은 구조물을 만드세요.

945
00:50:17,789 --> 00:50:23,449
질문으로 돌아가서 답변드리겠습니다.
AVL 시퀀스 트리에 관하여,

946
00:50:23,449 --> 00:50:25,500
알고 보니 얻을 수 있더군요.
모든 경계가 동일합니다.

947
00:50:25,500 --> 00:50:27,750
무엇을 사시든, 단,
부품들이 제자리에 있습니다.

948
00:50:27,750 --> 00:50:30,329
취한
AVL 서열 트리, 보존

949
00:50:30,329 --> 00:50:33,150
임의의 요소
주문 및 추가

950
00:50:33,150 --> 00:50:36,210
정말 미친 생각이야.

951
00:50:36,210 --> 00:50:38,490
하지만 그것은 또한 당신에게 해줍니다
선형적인 생성 시간.

952
00:50:38,489 --> 00:50:40,709
그래서,
노트에 흥미로운 내용이 또 있네요.

953
00:50:40,710 --> 00:50:42,980
하지만 거기서 마치겠습니다.

