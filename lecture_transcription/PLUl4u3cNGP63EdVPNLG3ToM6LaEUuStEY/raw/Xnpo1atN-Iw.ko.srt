1
00:00:12,320 --> 00:00:14,549

자, Double06 데이터 구조 수업에 다시 오신 것을 환영합니다.

2
00:00:14,549 --> 00:00:14,559
자, Double06 데이터 구조 수업에 다시 오신 것을 환영합니다.
 

3
00:00:14,559 --> 00:00:15,829
자, Double06 데이터 구조 수업에 다시 오신 것을 환영합니다.

4
00:00:15,829 --> 00:00:15,839

 

5
00:00:15,839 --> 00:00:18,870

오늘은 힙(이진 힙)이라는 트리 형태의

6
00:00:18,870 --> 00:00:19,510
오늘은 힙(이진 힙)이라는 트리 형태의
 

7
00:00:19,510 --> 00:00:19,520

 

8
00:00:19,520 --> 00:00:21,990

데이터 구조를 다뤄보겠습니다. 이진 힙을 사용하면

9
00:00:21,990 --> 00:00:24,150
데이터 구조를 다뤄보겠습니다. 이진 힙을 사용하면
 

10
00:00:24,150 --> 00:00:24,160

 

11
00:00:24,160 --> 00:00:26,870

정렬 문제를 새로운 방식으로 해결할 수 있습니다. 먼저 오늘

12
00:00:26,870 --> 00:00:26,880
정렬 문제를 새로운 방식으로 해결할 수 있습니다. 먼저 오늘
 

13
00:00:26,880 --> 00:00:27,269
정렬 문제를 새로운 방식으로 해결할 수 있습니다. 먼저 오늘

14
00:00:27,269 --> 00:00:30,470

 

15
00:00:30,470 --> 00:00:30,480

 

16
00:00:30,480 --> 00:00:31,589

살펴볼 문제의 일부를 다시 한번 알려드리겠습니다. 오늘 우리가 풀 문제 중 하나는 우선순위

17
00:00:31,589 --> 00:00:31,599
살펴볼 문제의 일부를 다시 한번 알려드리겠습니다. 오늘 우리가 풀 문제 중 하나는 우선순위
 

18
00:00:31,599 --> 00:00:33,510
살펴볼 문제의 일부를 다시 한번 알려드리겠습니다. 오늘 우리가 풀 문제 중 하나는 우선순위
큐(Priority Queue)입니다.

19
00:00:33,510 --> 00:00:33,520
큐(Priority Queue)입니다.
 

20
00:00:33,520 --> 00:00:35,350
큐(Priority Queue)입니다.
이것은 우리가 앞으로 여러

21
00:00:35,350 --> 00:00:35,360
이것은 우리가 앞으로 여러
 

22
00:00:35,360 --> 00:00:36,870
이것은 우리가 앞으로 여러
데이터 구조를 살펴보겠지만, 오늘 다룰 주요 데이터

23
00:00:36,870 --> 00:00:36,880
데이터 구조를 살펴보겠지만, 오늘 다룰 주요 데이터
 

24
00:00:36,880 --> 00:00:39,910
데이터 구조를 살펴보겠지만, 오늘 다룰 주요 데이터
구조는 바로 이 우선순위 큐입니다. 우선순위 큐는 집합(

25
00:00:39,910 --> 00:00:43,270

 

26
00:00:43,270 --> 00:00:43,280

 

27
00:00:43,280 --> 00:00:47,110

Set) 인터페이스의 부분집합입니다.

28
00:00:47,110 --> 00:00:47,120

 

29
00:00:47,120 --> 00:00:48,630

부분집합은 잠재적으로 더 효율적이고, 더 빠르고, 더 간단하게 문제를 해결할 수 있기 때문에 흥미롭습니다.

30
00:00:48,630 --> 00:00:50,470
부분집합은 잠재적으로 더 효율적이고, 더 빠르고, 더 간단하게 문제를 해결할 수 있기 때문에 흥미롭습니다.
 

31
00:00:50,470 --> 00:00:53,750

 

32
00:00:53,750 --> 00:00:53,760

 

33
00:00:53,760 --> 00:00:56,950

따라서 여러분은

34
00:00:56,950 --> 00:00:56,960
따라서 여러분은
 

35
00:00:56,960 --> 00:00:58,229
따라서 여러분은
대부분의

36
00:00:58,229 --> 00:00:58,239
대부분의
 

37
00:00:58,239 --> 00:01:00,069
대부분의
연산을 알아볼 수 있을 것입니다. 다만,

38
00:01:00,069 --> 00:01:01,189
연산을 알아볼 수 있을 것입니다. 다만,
 

39
00:01:01,189 --> 00:01:01,199

 

40
00:01:01,199 --> 00:01:03,189

최댓값 연산은 일반적으로 강조하지 않습니다. 여기서는

41
00:01:03,189 --> 00:01:03,199
최댓값 연산은 일반적으로 강조하지 않습니다. 여기서는
 

42
00:01:03,199 --> 00:01:06,070
최댓값 연산은 일반적으로 강조하지 않습니다. 여기서는
여러 항목을 저장하는데, 각 항목에는 우선순위라고

43
00:01:06,070 --> 00:01:06,080
여러 항목을 저장하는데, 각 항목에는 우선순위라고
 

44
00:01:06,080 --> 00:01:08,870
여러 항목을 저장하는데, 각 항목에는 우선순위라고
생각하는 키가 있습니다. 우리는 이

45
00:01:08,870 --> 00:01:08,880
생각하는 키가 있습니다. 우리는 이
 

46
00:01:08,880 --> 00:01:09,990
생각하는 키가 있습니다. 우리는 이

47
00:01:09,990 --> 00:01:12,230

 

48
00:01:12,230 --> 00:01:13,830

 

49
00:01:13,830 --> 00:01:13,840

 

50
00:01:13,840 --> 00:01:17,270

항목들 중에서 가장 높은 우선순위를 가진 항목을 찾아 제거하려고 합니다. 우선순위 큐를 사용하는

51
00:01:17,270 --> 00:01:17,280
항목들 중에서 가장 높은 우선순위를 가진 항목을 찾아 제거하려고 합니다. 우선순위 큐를 사용하는
 

52
00:01:17,280 --> 00:01:18,789
항목들 중에서 가장 높은 우선순위를 가진 항목을 찾아 제거하려고 합니다. 우선순위 큐를 사용하는
이유는 다양합니다.

53
00:01:18,789 --> 00:01:18,799
이유는 다양합니다.
 

54
00:01:18,799 --> 00:01:20,310
이유는 다양합니다.
예를 들어

55
00:01:20,310 --> 00:01:20,320
예를 들어
 

56
00:01:20,320 --> 00:01:21,429
예를 들어
라우터로 들어오는 패킷에는 각기

57
00:01:21,429 --> 00:01:21,439
라우터로 들어오는 패킷에는 각기
 

58
00:01:21,439 --> 00:01:22,789
라우터로 들어오는 패킷에는 각기
다른 우선순위가 할당되어 있으므로

59
00:01:22,789 --> 00:01:22,799
다른 우선순위가 할당되어 있으므로
 

60
00:01:22,799 --> 00:01:24,230
다른 우선순위가 할당되어 있으므로
가장 높은 우선순위의 패킷을 먼저 처리해야 할 수 있습니다.

61
00:01:24,230 --> 00:01:24,240
가장 높은 우선순위의 패킷을 먼저 처리해야 할 수 있습니다.
 

62
00:01:24,240 --> 00:01:24,950
가장 높은 우선순위의 패킷을 먼저 처리해야 할 수 있습니다.

63
00:01:24,950 --> 00:01:24,960

 

64
00:01:24,960 --> 00:01:27,429

또는 컴퓨터에서 실행 중인 프로세스들이

65
00:01:27,429 --> 00:01:29,429
또는 컴퓨터에서 실행 중인 프로세스들이
 

66
00:01:29,429 --> 00:01:29,439

 

67
00:01:29,439 --> 00:01:32,550

단일 스레드 또는 단일 코어에서 실행되려고 할 때,

68
00:01:32,550 --> 00:01:32,560
단일 스레드 또는 단일 코어에서 실행되려고 할 때,
 

69
00:01:32,560 --> 00:01:33,749
단일 스레드 또는 단일 코어에서 실행되려고 할 때,
어떤 프로세스를 먼저 실행할지 선택해야 할 수도 있습니다.

70
00:01:33,749 --> 00:01:33,759
어떤 프로세스를 먼저 실행할지 선택해야 할 수도 있습니다.
 

71
00:01:33,759 --> 00:01:35,830
어떤 프로세스를 먼저 실행할지 선택해야 할 수도 있습니다.
다음으로 실행할 프로세스를 결정해야 하는데, 일반적으로 우선

72
00:01:35,830 --> 00:01:35,840
다음으로 실행할 프로세스를 결정해야 하는데, 일반적으로 우선
 

73
00:01:35,840 --> 00:01:37,749
다음으로 실행할 프로세스를 결정해야 하는데, 일반적으로 우선
순위가 높은 프로세스부터 먼저 실행합니다.

74
00:01:37,749 --> 00:01:37,759
순위가 높은 프로세스부터 먼저 실행합니다.
 

75
00:01:37,759 --> 00:01:41,670
순위가 높은 프로세스부터 먼저 실행합니다.
또는 여러

76
00:01:41,670 --> 00:01:41,680
또는 여러
 

77
00:01:41,680 --> 00:01:43,429
또는 여러
이벤트가 서로 다른 시간에 발생하는 시스템을 시뮬레이션하고

78
00:01:43,429 --> 00:01:45,830
이벤트가 서로 다른 시간에 발생하는 시스템을 시뮬레이션하고
 

79
00:01:45,830 --> 00:01:45,840

 

80
00:01:45,840 --> 00:01:47,429

시간 순서대로 다음 이벤트를 처리하려는 경우에도 우선

81
00:01:47,429 --> 00:01:47,439
시간 순서대로 다음 이벤트를 처리하려는 경우에도 우선
 

82
00:01:47,439 --> 00:01:50,310
시간 순서대로 다음 이벤트를 처리하려는 경우에도 우선
순위 큐 인터페이스를 사용할 수 있습니다.

83
00:01:50,310 --> 00:01:51,990
순위 큐 인터페이스를 사용할 수 있습니다.
 

84
00:01:51,990 --> 00:01:52,000

 

85
00:01:52,000 --> 00:01:53,910

그래프 알고리즘을 배우면서 이 수업 내에서 이러한 응용 사례를 더 자세히 살펴보겠습니다.

86
00:01:53,910 --> 00:01:53,920
그래프 알고리즘을 배우면서 이 수업 내에서 이러한 응용 사례를 더 자세히 살펴보겠습니다.
 

87
00:01:53,920 --> 00:01:55,670
그래프 알고리즘을 배우면서 이 수업 내에서 이러한 응용 사례를 더 자세히 살펴보겠습니다.
일반적으로 우리가 지원해야 하는 두 가지 주요 기능은

88
00:01:55,670 --> 00:01:57,190
일반적으로 우리가 지원해야 하는 두 가지 주요 기능은
 

89
00:01:57,190 --> 00:01:57,910

 

90
00:01:57,910 --> 00:01:57,920

 

91
00:01:57,920 --> 00:02:00,310

키를 포함하는 항목 삽입과 최댓값

92
00:02:00,310 --> 00:02:00,320
키를 포함하는 항목 삽입과 최댓값
 

93
00:02:00,320 --> 00:02:02,310
키를 포함하는 항목 삽입과 최댓값
항목 삭제 및 반환입니다.

94
00:02:02,310 --> 00:02:02,320
항목 삭제 및 반환입니다.
 

95
00:02:02,320 --> 00:02:03,510
항목 삭제 및 반환입니다.

96
00:02:03,510 --> 00:02:03,520

 

97
00:02:03,520 --> 00:02:06,469

또한

98
00:02:06,469 --> 00:02:07,510
또한
 

99
00:02:07,510 --> 00:02:07,520

 

100
00:02:07,520 --> 00:02:09,109

단순히 삽입하는 것보다 더 빠르게 구조를 구축하는 방법에 대해서도 이야기하겠지만, 물론

101
00:02:09,109 --> 00:02:11,110
단순히 삽입하는 것보다 더 빠르게 구조를 구축하는 방법에 대해서도 이야기하겠지만, 물론
 

102
00:02:11,110 --> 00:02:11,120

 

103
00:02:11,120 --> 00:02:11,589


104
00:02:11,589 --> 00:02:11,599

 

105
00:02:11,599 --> 00:02:14,630

빈 상태에서 시작하여 반복적으로 삽입하는 방식으로 구축을 구현할 수도 있습니다.

106
00:02:14,630 --> 00:02:17,030
빈 상태에서 시작하여 반복적으로 삽입하는 방식으로 구축을 구현할 수도 있습니다.
 

107
00:02:17,030 --> 00:02:17,040

 

108
00:02:17,040 --> 00:02:18,550

최댓값을 삭제하지 않고 찾는 작업의 복잡성은

109
00:02:18,550 --> 00:02:20,309
최댓값을 삭제하지 않고 찾는 작업의 복잡성은
 

110
00:02:20,309 --> 00:02:20,319

 

111
00:02:20,319 --> 00:02:21,990

최댓값을 삭제한 후

112
00:02:21,990 --> 00:02:22,000
최댓값을 삭제한 후
 

113
00:02:22,000 --> 00:02:24,070
최댓값을 삭제한 후
다시 삽입하는 방식으로 시뮬레이션할 수 있지만, 더

114
00:02:24,070 --> 00:02:24,080
다시 삽입하는 방식으로 시뮬레이션할 수 있지만, 더
 

115
00:02:24,080 --> 00:02:27,910
다시 삽입하는 방식으로 시뮬레이션할 수 있지만, 더
빠른 방법이 종종 있습니다.

116
00:02:27,910 --> 00:02:27,920
빠른 방법이 종종 있습니다.
 

117
00:02:27,920 --> 00:02:30,710
빠른 방법이 종종 있습니다.
핵심적인 두 가지 주요 작업은

118
00:02:30,710 --> 00:02:30,720
핵심적인 두 가지 주요 작업은
 

119
00:02:30,720 --> 00:02:31,509
핵심적인 두 가지 주요 작업은
삽입

120
00:02:31,509 --> 00:02:31,519
삽입
 

121
00:02:31,519 --> 00:02:34,309
삽입
과 최댓값 삭제이며,

122
00:02:34,309 --> 00:02:34,319
과 최댓값 삭제이며,
 

123
00:02:34,319 --> 00:02:37,110
과 최댓값 삭제이며,
이를 위한 몇 가지 데이터 구조를 살펴보겠습니다.

124
00:02:37,110 --> 00:02:39,270
이를 위한 몇 가지 데이터 구조를 살펴보겠습니다.
 

125
00:02:39,270 --> 00:02:39,280

 

126
00:02:39,280 --> 00:02:40,790

이 수업에서 배운 데이터 구조 중에서 우선

127
00:02:40,790 --> 00:02:42,150
이 수업에서 배운 데이터 구조 중에서 우선
 

128
00:02:42,150 --> 00:02:42,160

 

129
00:02:42,160 --> 00:02:53,750

순위 큐 인터페이스를 해결하는 데 어떤 것을 사용하는 것이 좋을까요?

130
00:02:53,750 --> 00:02:53,760

 

131
00:02:53,760 --> 00:02:58,790

가능한 답변이 있나요?

132
00:02:58,790 --> 00:02:58,800

 

133
00:02:58,800 --> 00:03:01,430

시퀀스(AvL)요? 오, 흥미롭네요. 시퀀스(AvL)도 괜찮을 것 같습니다.

134
00:03:01,430 --> 00:03:01,440
시퀀스(AvL)요? 오, 흥미롭네요. 시퀀스(AvL)도 괜찮을 것 같습니다.
 

135
00:03:01,440 --> 00:03:03,110
시퀀스(AvL)요? 오, 흥미롭네요. 시퀀스(AvL)도 괜찮을 것 같습니다.
fl은 좋은 답

136
00:03:03,110 --> 00:03:03,120
fl은 좋은 답
 

137
00:03:03,120 --> 00:03:06,949
fl은 좋은 답
이지만, 좀 더 세련된 버전일 수도 있겠네요.

138
00:03:06,949 --> 00:03:06,959
이지만, 좀 더 세련된 버전일 수도 있겠네요.
 

139
00:03:06,959 --> 00:03:10,790
이지만, 좀 더 세련된 버전일 수도 있겠네요.
set avl이 좋아 보입니다.

140
00:03:10,790 --> 00:03:10,800
set avl이 좋아 보입니다.
 

141
00:03:10,800 --> 00:03:13,030
set avl이 좋아 보입니다.
set avl은 이러한 연산들을 비롯해 훨씬 더 많은 연산들을

142
00:03:13,030 --> 00:03:13,910
set avl은 이러한 연산들을 비롯해 훨씬 더 많은 연산들을
 

143
00:03:13,910 --> 00:03:13,920

 

144
00:03:13,920 --> 00:03:16,229

log n 시간 안에 지원합니다. 단, build 연산은

145
00:03:16,229 --> 00:03:16,239
log n 시간 안에 지원합니다. 단, build 연산은
 

146
00:03:16,239 --> 00:03:17,190
log n 시간 안에 지원합니다. 단, build 연산은

147
00:03:17,190 --> 00:03:17,200

 

148
00:03:17,200 --> 00:03:18,869

정렬을 먼저 해야 하기 때문에 n log n 시간이 걸립니다.

149
00:03:18,869 --> 00:03:20,790
정렬을 먼저 해야 하기 때문에 n log n 시간이 걸립니다.
 

150
00:03:20,790 --> 00:03:20,800

 

151
00:03:20,800 --> 00:03:22,949

따라서 set avl은 좋은 방법입니다.

152
00:03:22,949 --> 00:03:24,229
따라서 set avl은 좋은 방법입니다.
 

153
00:03:24,229 --> 00:03:25,430

 

154
00:03:25,430 --> 00:03:25,440

 

155
00:03:25,440 --> 00:03:29,910

나중에 sequence avl 아이디어에 대해 다시 이야기해 보겠습니다. 이 연산은 log n 시간이 걸립니다.

156
00:03:29,910 --> 00:03:29,920
나중에 sequence avl 아이디어에 대해 다시 이야기해 보겠습니다. 이 연산은 log n 시간이 걸립니다.
 

157
00:03:29,920 --> 00:03:33,190
나중에 sequence avl 아이디어에 대해 다시 이야기해 보겠습니다. 이 연산은 log n 시간이 걸립니다.
좋습니다.

158
00:03:33,190 --> 00:03:33,200
좋습니다.
 

159
00:03:33,200 --> 00:03:34,789
좋습니다.
set avl은 가장 강력한 데이터

160
00:03:34,789 --> 00:03:34,799
set avl은 가장 강력한 데이터
 

161
00:03:34,799 --> 00:03:36,229
set avl은 가장 강력한 데이터
구조입니다. 우리가 중요하게 생각하는 모든 연산을

162
00:03:36,229 --> 00:03:37,030
구조입니다. 우리가 중요하게 생각하는 모든 연산을
 

163
00:03:37,030 --> 00:03:37,040

 

164
00:03:37,040 --> 00:03:39,030

세트 측면에서 수행합니다. sequence avl은

165
00:03:39,030 --> 00:03:40,229
세트 측면에서 수행합니다. sequence avl은
 

166
00:03:40,229 --> 00:03:40,239

 

167
00:03:40,239 --> 00:03:41,670

시퀀스 측면에서 모든 연산을 수행합니다. 하지만 이것은 시퀀스가

168
00:03:41,670 --> 00:03:41,680
시퀀스 측면에서 모든 연산을 수행합니다. 하지만 이것은 시퀀스가
 

169
00:03:41,680 --> 00:03:42,949
시퀀스 측면에서 모든 연산을 수행합니다. 하지만 이것은 시퀀스가
아니라 세트라는 점에 유의해야 합니다.

170
00:03:42,949 --> 00:03:42,959
아니라 세트라는 점에 유의해야 합니다.
 

171
00:03:42,959 --> 00:03:44,949
아니라 세트라는 점에 유의해야 합니다.
우리는 키에 관심이 있습니다.

172
00:03:44,949 --> 00:03:44,959
우리는 키에 관심이 있습니다.
 

173
00:03:44,959 --> 00:03:46,949
우리는 키에 관심이 있습니다.
sequence avl을 사용하면 이 문제를 해결할 수 있는 방법이 있지만,

174
00:03:46,949 --> 00:03:46,959
sequence avl을 사용하면 이 문제를 해결할 수 있는 방법이 있지만,
 

175
00:03:46,959 --> 00:03:50,149
sequence avl을 사용하면 이 문제를 해결할 수 있는 방법이 있지만,
나중에 다루도록 하겠습니다.

176
00:03:50,149 --> 00:03:50,159

 

177
00:03:50,159 --> 00:03:52,630

예를 들어 set avl에서

178
00:03:52,630 --> 00:03:52,640
예를 들어 set avl에서
 

179
00:03:52,640 --> 00:03:54,149
예를 들어 set avl에서
최댓값 찾기 속도를 높이려면

180
00:03:54,149 --> 00:03:54,159
최댓값 찾기 속도를 높이려면
 

181
00:03:54,159 --> 00:03:58,309
최댓값 찾기 속도를 높이려면
증강을 추가할 수 있습니다.

182
00:03:58,309 --> 00:04:01,509
증강을 추가할 수 있습니다.
 

183
00:04:01,509 --> 00:04:01,519

 

184
00:04:01,519 --> 00:04:05,270

서브트리 속성 증강을 기억하시나요?

185
00:04:05,270 --> 00:04:08,229
서브트리 속성 증강을 기억하시나요?
 

186
00:04:08,229 --> 00:04:10,470

 

187
00:04:10,470 --> 00:04:13,509

 

188
00:04:13,509 --> 00:04:13,519

 

189
00:04:13,519 --> 00:04:15,750

서브트리 내의 최댓값 키 항목을 각 노드에 저장하여 상수 시간 안에 최댓값을 찾을 수 있습니다. 이것은

190
00:04:15,750 --> 00:04:15,760
서브트리 내의 최댓값 키 항목을 각 노드에 저장하여 상수 시간 안에 최댓값을 찾을 수 있습니다. 이것은
 

191
00:04:15,760 --> 00:04:17,270
서브트리 내의 최댓값 키 항목을 각 노드에 저장하여 상수 시간 안에 최댓값을 찾을 수 있습니다. 이것은
서브트리 속성입니다.

192
00:04:17,270 --> 00:04:17,280
서브트리 속성입니다.
 

193
00:04:17,280 --> 00:04:18,150
서브트리 속성입니다.
지난

194
00:04:18,150 --> 00:04:18,160
지난
 

195
00:04:18,160 --> 00:04:20,310
지난
수업에서 언급했던 속성입니다. 이 또한 개선할 수 있습니다.

196
00:04:20,310 --> 00:04:20,320
수업에서 언급했던 속성입니다. 이 또한 개선할 수 있습니다.
 

197
00:04:20,320 --> 00:04:21,189
수업에서 언급했던 속성입니다. 이 또한 개선할 수 있습니다.
상수 시간,

198
00:04:21,189 --> 00:04:21,199
상수 시간,
 

199
00:04:21,199 --> 00:04:24,950
상수 시간,
훌륭하네요. 음, 그래서 강의가 끝났다고 할 수 있겠죠.

200
00:04:24,950 --> 00:04:24,960
훌륭하네요. 음, 그래서 강의가 끝났다고 할 수 있겠죠.
 

201
00:04:24,960 --> 00:04:27,270
훌륭하네요. 음, 그래서 강의가 끝났다고 할 수 있겠죠.
어느 정도는 맞는 말입니다. 하지만

202
00:04:27,270 --> 00:04:27,280
어느 정도는 맞는 말입니다. 하지만
 

203
00:04:27,280 --> 00:04:28,469
어느 정도는 맞는 말입니다. 하지만
오늘 살펴볼 것은 이진

204
00:04:28,469 --> 00:04:29,909
오늘 살펴볼 것은 이진
 

205
00:04:29,909 --> 00:04:29,919

 

206
00:04:29,919 --> 00:04:31,749

힙이라는 또 다른 자료 구조입니다. 이진 힙은 집합(

207
00:04:31,749 --> 00:04:33,590
힙이라는 또 다른 자료 구조입니다. 이진 힙은 집합(
 

208
00:04:33,590 --> 00:04:33,600

 

209
00:04:33,600 --> 00:04:36,629

set)과 AVL의 간소화된 형태라고 할 수 있습니다. 기본적으로 동일한

210
00:04:36,629 --> 00:04:36,639
set)과 AVL의 간소화된 형태라고 할 수 있습니다. 기본적으로 동일한
 

211
00:04:36,639 --> 00:04:37,350
set)과 AVL의 간소화된 형태라고 할 수 있습니다. 기본적으로 동일한
시간 복잡도를 달성하며,

212
00:04:37,350 --> 00:04:37,360
시간 복잡도를 달성하며,
 

213
00:04:37,360 --> 00:04:41,030
시간 복잡도를 달성하며,
빌드는 로그 인자만큼 더 빠릅니다.

214
00:04:41,030 --> 00:04:41,040
빌드는 로그 인자만큼 더 빠릅니다.
 

215
00:04:41,040 --> 00:04:43,670
빌드는 로그 인자만큼 더 빠릅니다.
하지만 우리가 이진 힙에 관심을 갖는 주된 이유는 시간 복잡도가 아니라, 더

216
00:04:43,670 --> 00:04:44,469
하지만 우리가 이진 힙에 관심을 갖는 주된 이유는 시간 복잡도가 아니라, 더
 

217
00:04:44,469 --> 00:04:45,830

 

218
00:04:45,830 --> 00:04:45,840

 

219
00:04:45,840 --> 00:04:48,870

간단하고

220
00:04:48,870 --> 00:04:48,880
간단하고
 

221
00:04:48,880 --> 00:04:54,150
간단하고
제자리 정렬 알고리즘을 제공한다는 점입니다.

222
00:04:54,150 --> 00:04:54,160

 

223
00:04:54,160 --> 00:04:57,510

여기 제가 지금까지

224
00:04:57,510 --> 00:04:57,520
여기 제가 지금까지
 

225
00:04:57,520 --> 00:04:59,110
여기 제가 지금까지
이야기했던 세 가지 연산, 빌드,

226
00:04:59,110 --> 00:04:59,120
이야기했던 세 가지 연산, 빌드,
 

227
00:04:59,120 --> 00:05:00,710
이야기했던 세 가지 연산, 빌드,
삽입, 삭제, 최대값(max)이 있습니다. 집합(

228
00:05:00,710 --> 00:05:00,720
삽입, 삭제, 최대값(max)이 있습니다. 집합(
 

229
00:05:00,720 --> 00:05:03,270
삽입, 삭제, 최대값(max)이 있습니다. 집합(
set), AVL, 트리가 있고,

230
00:05:03,270 --> 00:05:03,280
set), AVL, 트리가 있고,
 

231
00:05:03,280 --> 00:05:04,230
set), AVL, 트리가 있고,
빌드는 log n,

232
00:05:04,230 --> 00:05:04,240
빌드는 log n,
 

233
00:05:04,240 --> 00:05:07,830
빌드는 log n,
삽입은 log n, 삭제는 log n의 시간이

234
00:05:07,830 --> 00:05:08,469
삽입은 log n, 삭제는 log n의 시간이
 

235
00:05:08,469 --> 00:05:11,909

 

236
00:05:11,909 --> 00:05:15,350

 

237
00:05:15,350 --> 00:05:18,310

 

238
00:05:18,310 --> 00:05:25,749

 

239
00:05:25,749 --> 00:05:27,510

 

240
00:05:27,510 --> 00:05:29,189

 

241
00:05:29,189 --> 00:05:31,430

 

242
00:05:31,430 --> 00:05:32,629

 

243
00:05:32,629 --> 00:05:32,639

 

244
00:05:32,639 --> 00:05:35,990

걸립니다. 힙을 배우는 과정에서 두 가지 다른 자료 구조를 언급하고 싶습니다. 하나는 동적이지만 정렬되지 않은 배열이고, 다른 하나는 동적 정렬된 배열입니다. 이들은 이전에 여러 번 다뤘던 더 간단한 자료 구조이며, 힙을 시작하는 데 유용한 동기 부여가 될 수 있습니다. 힙은

245
00:05:35,990 --> 00:05:38,629
걸립니다. 힙을 배우는 과정에서 두 가지 다른 자료 구조를 언급하고 싶습니다. 하나는 동적이지만 정렬되지 않은 배열이고, 다른 하나는 동적 정렬된 배열입니다. 이들은 이전에 여러 번 다뤘던 더 간단한 자료 구조이며, 힙을 시작하는 데 유용한 동기 부여가 될 수 있습니다. 힙은
 

246
00:05:38,629 --> 00:05:38,639

 

247
00:05:38,639 --> 00:05:42,710

배열과 트리의 결합이 아닌, 배열 위에 구축되기 때문입니다. 정렬되지

248
00:05:42,710 --> 00:05:42,720

 

249
00:05:42,720 --> 00:05:46,230

않은 배열이 있다면,

250
00:05:46,230 --> 00:05:46,240
않은 배열이 있다면,
 

251
00:05:46,240 --> 00:05:49,350
않은 배열이 있다면,
이것은 매우...  배열에 요소를 삽입하는 것은 쉽습니다.

252
00:05:49,350 --> 00:05:49,360
이것은 매우...  배열에 요소를 삽입하는 것은 쉽습니다.
 

253
00:05:49,360 --> 00:05:50,230
이것은 매우...  배열에 요소를 삽입하는 것은 쉽습니다.
그냥

254
00:05:50,230 --> 00:05:50,240
그냥
 

255
00:05:50,240 --> 00:05:52,230
그냥
끝에 추가하면 되니까요. 이걸 '

256
00:05:52,230 --> 00:05:52,240
끝에 추가하면 되니까요. 이걸 '
 

257
00:05:52,240 --> 00:05:53,510
끝에 추가하면 되니까요. 이걸 '
마지막 삽입(insert last)'이라고 합니다.

258
00:05:53,510 --> 00:05:53,520
마지막 삽입(insert last)'이라고 합니다.
 

259
00:05:53,520 --> 00:05:56,629
마지막 삽입(insert last)'이라고 합니다.
삽입은 빠르고

260
00:05:56,629 --> 00:05:56,639
삽입은 빠르고
 

261
00:05:56,639 --> 00:05:59,110
삽입은 빠르고
상각 시간은 일정합니다. 배열 크기를

262
00:05:59,110 --> 00:05:59,120
상각 시간은 일정합니다. 배열 크기를
 

263
00:05:59,120 --> 00:06:00,469
상각 시간은 일정합니다. 배열 크기를
조정해야 할 수도 있지만,

264
00:06:00,469 --> 00:06:00,479
조정해야 할 수도 있지만,
 

265
00:06:00,479 --> 00:06:02,870
조정해야 할 수도 있지만,
그게 상각 시간입니다. 하지만

266
00:06:02,870 --> 00:06:02,880
그게 상각 시간입니다. 하지만
 

267
00:06:02,880 --> 00:06:04,870
그게 상각 시간입니다. 하지만
최댓값을 삭제하는 것은 느립니다. 정렬되지 않은 배열에서는

268
00:06:04,870 --> 00:06:04,880
최댓값을 삭제하는 것은 느립니다. 정렬되지 않은 배열에서는
 

269
00:06:04,880 --> 00:06:06,230
최댓값을 삭제하는 것은 느립니다. 정렬되지 않은 배열에서는
최댓값이 어디에 있는지 알 수 없기 때문에

270
00:06:06,230 --> 00:06:06,240
최댓값이 어디에 있는지 알 수 없기 때문에
 

271
00:06:06,240 --> 00:06:11,029
최댓값이 어디에 있는지 알 수 없기 때문에
배열 전체를 스캔해야 합니다.

272
00:06:11,029 --> 00:06:11,039

 

273
00:06:11,039 --> 00:06:13,189

배열을 스캔해서

274
00:06:13,189 --> 00:06:13,199
배열을 스캔해서
 

275
00:06:13,199 --> 00:06:15,189
배열을 스캔해서
최댓값이 중간 어딘가에 있다는 것을 확인한

276
00:06:15,189 --> 00:06:15,199
최댓값이 중간 어딘가에 있다는 것을 확인한
 

277
00:06:15,199 --> 00:06:22,710
최댓값이 중간 어딘가에 있다는 것을 확인한
다음, 삭제하려면

278
00:06:22,710 --> 00:06:22,720

 

279
00:06:22,720 --> 00:06:24,309

그 최댓값을 가진 요소를 삭제해야 합니다.

280
00:06:24,309 --> 00:06:24,319
그 최댓값을 가진 요소를 삭제해야 합니다.
 

281
00:06:24,319 --> 00:06:26,070
그 최댓값을 가진 요소를 삭제해야 합니다.
동적 배열에서는

282
00:06:26,070 --> 00:06:27,830
동적 배열에서는
 

283
00:06:27,830 --> 00:06:27,840

 

284
00:06:27,840 --> 00:06:30,469

효율적으로 마지막 요소를 삭제하는 방법밖에 없습니다. 예를 들어,

285
00:06:30,469 --> 00:06:31,749
효율적으로 마지막 요소를 삭제하는 방법밖에 없습니다. 예를 들어,
 

286
00:06:31,749 --> 00:06:31,759

 

287
00:06:31,759 --> 00:06:34,710

현재 요소를 다른 요소로 바꾸고

288
00:06:34,710 --> 00:06:35,590
현재 요소를 다른 요소로 바꾸고
 

289
00:06:35,590 --> 00:06:38,230

 

290
00:06:38,230 --> 00:06:38,240

 

291
00:06:38,240 --> 00:06:39,110

배열의 마지막 요소를 삭제하는 것입니다.

292
00:06:39,110 --> 00:06:39,120
배열의 마지막 요소를 삭제하는 것입니다.
 

293
00:06:39,120 --> 00:06:41,830
배열의 마지막 요소를 삭제하는 것입니다.
파이썬에서는 'pop',

294
00:06:41,830 --> 00:06:41,840
파이썬에서는 'pop',
 

295
00:06:41,840 --> 00:06:42,390
파이썬에서는 'pop',
우리

296
00:06:42,390 --> 00:06:42,400
우리
 

297
00:06:42,400 --> 00:06:45,510
우리
말로는 'delete last'라고 합니다. 전체적으로

298
00:06:45,510 --> 00:06:45,520
말로는 'delete last'라고 합니다. 전체적으로
 

299
00:06:45,520 --> 00:06:50,150
말로는 'delete last'라고 합니다. 전체적으로
선형 시간이 걸립니다. 좋지는 않지만,

300
00:06:50,150 --> 00:06:50,160
선형 시간이 걸립니다. 좋지는 않지만,
 

301
00:06:50,160 --> 00:06:51,589
선형 시간이 걸립니다. 좋지는 않지만,
정확한 방법을 강조하고 싶었습니다. 잠시 후에 그

302
00:06:51,589 --> 00:06:51,599
정확한 방법을 강조하고 싶었습니다. 잠시 후에 그
 

303
00:06:51,599 --> 00:06:53,430
정확한 방법을 강조하고 싶었습니다. 잠시 후에 그
이유를 설명하겠습니다.

304
00:06:53,430 --> 00:06:53,440
이유를 설명하겠습니다.
 

305
00:06:53,440 --> 00:06:54,390
이유를 설명하겠습니다.

306
00:06:54,390 --> 00:06:54,400

 

307
00:06:54,400 --> 00:06:56,309

정렬된 배열은 정반대입니다.

308
00:06:56,309 --> 00:06:56,319
정렬된 배열은 정반대입니다.
 

309
00:06:56,319 --> 00:06:58,070
정렬된 배열은 정반대입니다.
최댓값을 찾기가 매우 쉽습니다. 최댓값은 배열

310
00:06:58,070 --> 00:06:58,080
최댓값을 찾기가 매우 쉽습니다. 최댓값은 배열
 

311
00:06:58,080 --> 00:07:02,390
최댓값을 찾기가 매우 쉽습니다. 최댓값은 배열
끝에 있습니다.

312
00:07:02,390 --> 00:07:02,400
끝에 있습니다.
 

313
00:07:02,400 --> 00:07:04,629
끝에 있습니다.
최댓값을 삭제하면 됩니다. 오름차순으로

314
00:07:04,629 --> 00:07:05,589
최댓값을 삭제하면 됩니다. 오름차순으로
 

315
00:07:05,589 --> 00:07:05,599

 

316
00:07:05,599 --> 00:07:11,029

정렬된 배열에서는 최댓값이 항상 마지막 요소입니다. 이것은 상각 시간이

317
00:07:11,029 --> 00:07:11,039

 

318
00:07:11,039 --> 00:07:13,110

일정하다고 할 수 있습니다. 왜냐하면...

319
00:07:13,110 --> 00:07:13,120
일정하다고 할 수 있습니다. 왜냐하면...
 

320
00:07:13,120 --> 00:07:14,710
일정하다고 할 수 있습니다. 왜냐하면...
삭제는

321
00:07:14,710 --> 00:07:15,430
삭제는
 

322
00:07:15,430 --> 00:07:15,440

 

323
00:07:15,440 --> 00:07:19,110

크기 조정을 수반할 수 있지만 삽입은

324
00:07:19,110 --> 00:07:19,120
크기 조정을 수반할 수 있지만 삽입은
 

325
00:07:19,120 --> 00:07:23,110
크기 조정을 수반할 수 있지만 삽입은
선형 시간 복잡도를 가집니다.

326
00:07:23,110 --> 00:07:23,120
선형 시간 복잡도를 가집니다.
 

327
00:07:23,120 --> 00:07:24,790
선형 시간 복잡도를 가집니다.
왜냐하면 추가된 항목이 속한 위치를 이진 탐색으로 찾을 수 있기 때문입니다. 예를 들어,

328
00:07:24,790 --> 00:07:28,070
왜냐하면 추가된 항목이 속한 위치를 이진 탐색으로 찾을 수 있기 때문입니다. 예를 들어,
 

329
00:07:28,070 --> 00:07:32,390

 

330
00:07:32,390 --> 00:07:32,400

 

331
00:07:32,400 --> 00:07:35,909

여기에 항목을 추가했다고 가정해 보겠습니다.

332
00:07:35,909 --> 00:07:35,919
여기에 항목을 추가했다고 가정해 보겠습니다.
 

333
00:07:35,919 --> 00:07:37,189
여기에 항목을 추가했다고 가정해 보겠습니다.
검색을 통해 해당 항목을 찾을 수 있지만, 그러면

334
00:07:37,189 --> 00:07:37,199
검색을 통해 해당 항목을 찾을 수 있지만, 그러면
 

335
00:07:37,199 --> 00:07:39,029
검색을 통해 해당 항목을 찾을 수 있지만, 그러면
큰 이동이 필요합니다. 따라서

336
00:07:39,029 --> 00:07:39,749
큰 이동이 필요합니다. 따라서
 

337
00:07:39,749 --> 00:07:42,710

 

338
00:07:42,710 --> 00:07:43,990

 

339
00:07:43,990 --> 00:07:44,000

 

340
00:07:44,000 --> 00:07:47,430

추가된 항목 x가 속한 위치를 찾을 때까지 반복적으로 위치를 바꾸는 것이 더 효율적일 수 있습니다. 이렇게 하면 정렬된

341
00:07:47,430 --> 00:07:47,440
추가된 항목 x가 속한 위치를 찾을 때까지 반복적으로 위치를 바꾸는 것이 더 효율적일 수 있습니다. 이렇게 하면 정렬된
 

342
00:07:47,440 --> 00:07:49,430
추가된 항목 x가 속한 위치를 찾을 때까지 반복적으로 위치를 바꾸는 것이 더 효율적일 수 있습니다. 이렇게 하면 정렬된
순서가 복원되지만

343
00:07:49,430 --> 00:07:49,440
순서가 복원되지만
 

344
00:07:49,440 --> 00:07:51,029
순서가 복원되지만
선형 시간 복잡도를 가지므로 비효율적입니다.

345
00:07:51,029 --> 00:07:51,039
선형 시간 복잡도를 가지므로 비효율적입니다.
 

346
00:07:51,039 --> 00:07:53,430
선형 시간 복잡도를 가지므로 비효율적입니다.
우리가 원하는 것은

347
00:07:53,430 --> 00:07:53,440
우리가 원하는 것은
 

348
00:07:53,440 --> 00:07:56,070
우리가 원하는 것은
이 두 가지 장점을 모두 활용하는 것입니다.

349
00:07:56,070 --> 00:07:56,080
이 두 가지 장점을 모두 활용하는 것입니다.
 

350
00:07:56,080 --> 00:07:59,350
이 두 가지 장점을 모두 활용하는 것입니다.
배열에 대한 삽입은 빠르고,

351
00:07:59,350 --> 00:07:59,360
배열에 대한 삽입은 빠르고,
 

352
00:07:59,360 --> 00:08:01,830
배열에 대한 삽입은 빠르고,
정렬된 배열에 대한 삭제도 빠릅니다.

353
00:08:01,830 --> 00:08:01,840
정렬된 배열에 대한 삭제도 빠릅니다.
 

354
00:08:01,840 --> 00:08:03,510
정렬된 배열에 대한 삭제도 빠릅니다.
둘 다 상수 시간 복잡도를 달성할 수는 없지만

355
00:08:03,510 --> 00:08:03,520
둘 다 상수 시간 복잡도를 달성할 수는 없지만
 

356
00:08:03,520 --> 00:08:05,350
둘 다 상수 시간 복잡도를 달성할 수는 없지만
선형 시간 복잡도는 달성할 수 있습니다. 집합 AVL 트리를 사용하면 이미 이

357
00:08:05,350 --> 00:08:05,360
선형 시간 복잡도는 달성할 수 있습니다. 집합 AVL 트리를 사용하면 이미 이
 

358
00:08:05,360 --> 00:08:06,230
선형 시간 복잡도는 달성할 수 있습니다. 집합 AVL 트리를 사용하면 이미 이
방법을 알고 있지만,

359
00:08:06,230 --> 00:08:08,150
방법을 알고 있지만,
 

360
00:08:08,150 --> 00:08:08,160

 

361
00:08:08,160 --> 00:08:10,869

오늘은 다른 방법을 살펴보겠습니다. 이

362
00:08:10,869 --> 00:08:10,879
오늘은 다른 방법을 살펴보겠습니다. 이
 

363
00:08:10,879 --> 00:08:14,150
오늘은 다른 방법을 살펴보겠습니다. 이
다른 방법을 사용하는 주된 이유는

364
00:08:14,150 --> 00:08:16,710
다른 방법을 사용하는 주된 이유는
 

365
00:08:16,710 --> 00:08:16,720

 

366
00:08:16,720 --> 00:08:19,830

정렬 때문입니다. 우선

367
00:08:19,830 --> 00:08:19,840
정렬 때문입니다. 우선
 

368
00:08:19,840 --> 00:08:29,189
정렬 때문입니다. 우선
순위 큐 정렬을 정의하려고 합니다. 우선

369
00:08:29,189 --> 00:08:31,909

 

370
00:08:31,909 --> 00:08:31,919

 

371
00:08:31,919 --> 00:08:33,589

순위 큐 인터페이스, 특히

372
00:08:33,589 --> 00:08:33,599
순위 큐 인터페이스, 특히
 

373
00:08:33,599 --> 00:08:34,790
순위 큐 인터페이스, 특히
삽입

374
00:08:34,790 --> 00:08:34,800
삽입
 

375
00:08:34,800 --> 00:08:37,350
삽입
및 삭제 최대값을 구현하는 모든 데이터 구조가 주어졌을 때 정렬 알고리즘을 만들 수 있습니다.

376
00:08:37,350 --> 00:08:37,360
및 삭제 최대값을 구현하는 모든 데이터 구조가 주어졌을 때 정렬 알고리즘을 만들 수 있습니다.
 

377
00:08:37,360 --> 00:08:38,070
및 삭제 최대값을 구현하는 모든 데이터 구조가 주어졌을 때 정렬 알고리즘을 만들 수 있습니다.

378
00:08:38,070 --> 00:08:38,080

 

379
00:08:38,080 --> 00:08:41,110

모든 항목을 삽입하고

380
00:08:41,110 --> 00:08:41,120
모든 항목을 삽입하고
 

381
00:08:41,120 --> 00:08:42,149
모든 항목을 삽입하고
모든 항목을 삭제하는 방법도 있지만,

382
00:08:42,149 --> 00:08:42,159
모든 항목을 삭제하는 방법도 있지만,
 

383
00:08:42,159 --> 00:08:44,230
모든 항목을 삭제하는 방법도 있지만,
삭제할 때 가장 큰 항목부터 나오기 때문에 역순으로 정렬해야 합니다.

384
00:08:44,230 --> 00:08:45,829
삭제할 때 가장 큰 항목부터 나오기 때문에 역순으로 정렬해야 합니다.
 

385
00:08:45,829 --> 00:08:45,839

 

386
00:08:45,839 --> 00:08:47,670

정렬된 순서로 정렬한 다음

387
00:08:47,670 --> 00:08:47,680
정렬된 순서로 정렬한 다음
 

388
00:08:47,680 --> 00:08:49,350
정렬된 순서로 정렬한 다음
선형 시간 안에 역순으로 정렬할 수 있습니다.

389
00:08:49,350 --> 00:08:49,360
선형 시간 안에 역순으로 정렬할 수 있습니다.
 

390
00:08:49,360 --> 00:08:53,910
선형 시간 안에 역순으로 정렬할 수 있습니다.
항목들을 정렬했으니 x개씩

391
00:08:53,910 --> 00:08:53,920
항목들을 정렬했으니 x개씩
 

392
00:08:53,920 --> 00:08:56,070
항목들을 정렬했으니 x개씩
삽입하거나, 배열을 만들고,

393
00:08:56,070 --> 00:08:59,509
삽입하거나, 배열을 만들고,
 

394
00:08:59,509 --> 00:09:04,710

 

395
00:09:04,710 --> 00:09:08,790

 

396
00:09:08,790 --> 00:09:08,800

 

397
00:09:08,800 --> 00:09:16,710

최대값을 반복적으로 삭제할 수 있습니다.

398
00:09:16,710 --> 00:09:16,720

 

399
00:09:16,720 --> 00:09:18,389

이 알고리즘은 얼마나 걸릴까요?

400
00:09:18,389 --> 00:09:19,910
이 알고리즘은 얼마나 걸릴까요?
 

401
00:09:19,910 --> 00:09:19,920

 

402
00:09:19,920 --> 00:09:21,910

여기서 몇 가지 표기법을 도입하겠습니다.

403
00:09:21,910 --> 00:09:21,920
여기서 몇 가지 표기법을 도입하겠습니다.
 

404
00:09:21,920 --> 00:09:24,949
여기서 몇 가지 표기법을 도입하겠습니다.
항목을 만드는 데 걸리는 시간(

405
00:09:24,949 --> 00:09:24,959
항목을 만드는 데 걸리는 시간(
 

406
00:09:24,959 --> 00:09:28,150
항목을 만드는 데 걸리는 시간(
t_subbuild)에 n을 곱한 시간(n배)을 더한

407
00:09:28,150 --> 00:09:33,710
t_subbuild)에 n을 곱한 시간(n배)을 더한
 

408
00:09:33,710 --> 00:09:33,720

 

409
00:09:33,720 --> 00:09:35,750


410
00:09:35,750 --> 00:09:40,150

 

411
00:09:40,150 --> 00:09:40,160

 

412
00:09:40,160 --> 00:09:44,870

시간(n배)이 걸립니다. 즉, 삽입하는 데 걸리는 시간(n배)에 삭제하는 데 걸리는 시간(n배)을 곱한 시간(n배)이 더해집니다.

413
00:09:44,870 --> 00:09:44,880

 

414
00:09:44,880 --> 00:09:47,910

또는 이렇게 쓸 수도 있습니다. 즉, 삽입하는 데 걸리는 시간(n배)에

415
00:09:47,910 --> 00:09:51,829
또는 이렇게 쓸 수도 있습니다. 즉, 삽입하는 데 걸리는 시간(n배)에
 

416
00:09:51,829 --> 00:09:51,839

 

417
00:09:51,839 --> 00:09:57,910

삭제하는 데

418
00:09:57,910 --> 00:09:59,750

 

419
00:09:59,750 --> 00:10:01,190

 

420
00:10:01,190 --> 00:10:01,200

 

421
00:10:01,200 --> 00:10:03,509

걸리는 시간(n배)을 더한 시간(n배)입니다. 저는 이러한 t 함수를 사용하여

422
00:10:03,509 --> 00:10:03,519
걸리는 시간(n배)을 더한 시간(n배)입니다. 저는 이러한 t 함수를 사용하여
 

423
00:10:03,519 --> 00:10:05,269
걸리는 시간(n배)을 더한 시간(n배)입니다. 저는 이러한 t 함수를 사용하여
이 인터페이스를 구현하는 데이터 구조가 제공하는 실행 시간을 추상화하고 있습니다.

424
00:10:05,269 --> 00:10:05,279
이 인터페이스를 구현하는 데이터 구조가 제공하는 실행 시간을 추상화하고 있습니다.
 

425
00:10:05,279 --> 00:10:06,069
이 인터페이스를 구현하는 데이터 구조가 제공하는 실행 시간을 추상화하고 있습니다.

426
00:10:06,069 --> 00:10:06,079

 

427
00:10:06,079 --> 00:10:07,750

인터페이스는 올바른 것이 무엇인지 알려주고,

428
00:10:07,750 --> 00:10:07,760
인터페이스는 올바른 것이 무엇인지 알려주고,
 

429
00:10:07,760 --> 00:10:09,350
인터페이스는 올바른 것이 무엇인지 알려주고,
이러한 t 함수는

430
00:10:09,350 --> 00:10:10,710
이러한 t 함수는
 

431
00:10:10,710 --> 00:10:12,710

 

432
00:10:12,710 --> 00:10:12,720

 

433
00:10:12,720 --> 00:10:13,750


434
00:10:13,750 --> 00:10:17,590

 

435
00:10:17,590 --> 00:10:17,990

 

436
00:10:17,990 --> 00:10:20,150

 

437
00:10:20,150 --> 00:10:21,030

 

438
00:10:21,030 --> 00:10:22,710

 

439
00:10:22,710 --> 00:10:22,720

 

440
00:10:22,720 --> 00:10:24,870


441
00:10:24,870 --> 00:10:27,990

 

442
00:10:27,990 --> 00:10:28,000

 

443
00:10:28,000 --> 00:10:31,269

성능을 보여줍니다. 각 데이터 구조를 입력하면 정렬 알고리즘, AVL 정렬, 배열 정렬, 정렬된 배열 정렬 등이 나옵니다. 이것들은 어떻게 생겼을까요? 대부분 익숙할 것입니다. AVL 정렬은 연산에 10진수를 소요하므로,

444
00:10:31,269 --> 00:10:34,069
성능을 보여줍니다. 각 데이터 구조를 입력하면 정렬 알고리즘, AVL 정렬, 배열 정렬, 정렬된 배열 정렬 등이 나옵니다. 이것들은 어떻게 생겼을까요? 대부분 익숙할 것입니다. AVL 정렬은 연산에 10진수를 소요하므로,
 

445
00:10:34,069 --> 00:10:34,079

 

446
00:10:34,079 --> 00:10:36,150

모든 항목을 ABL 트리에 삽입하는 n진수 정렬 알고리즘을 얻을 수 있습니다. 저는 이것을

447
00:10:36,150 --> 00:10:36,160
모든 항목을 ABL 트리에 삽입하는 n진수 정렬 알고리즘을 얻을 수 있습니다. 저는 이것을
 

448
00:10:36,160 --> 00:10:37,990
모든 항목을 ABL 트리에 삽입하는 n진수 정렬 알고리즘을 얻을 수 있습니다. 저는 이것을
사용하고 싶지 않습니다.  AVL 트리를 구현하려면

449
00:10:37,990 --> 00:10:38,949
사용하고 싶지 않습니다.  AVL 트리를 구현하려면
 

450
00:10:38,949 --> 00:10:38,959

 

451
00:10:38,959 --> 00:10:40,870

정렬을 사용해야 하는데, 정렬을 구현하기 위해 직접 정렬을 할 수는 없습니다.

452
00:10:40,870 --> 00:10:41,990
정렬을 사용해야 하는데, 정렬을 구현하기 위해 직접 정렬을 할 수는 없습니다.
 

453
00:10:41,990 --> 00:10:42,000

 

454
00:10:42,000 --> 00:10:43,670

하지만 AVL 트리에 요소를 삽입하고 균형을 유지하는 방법을 살펴보았는데,

455
00:10:43,670 --> 00:10:45,750
하지만 AVL 트리에 요소를 삽입하고 균형을 유지하는 방법을 살펴보았는데,
 

456
00:10:45,750 --> 00:10:45,760

 

457
00:10:45,760 --> 00:10:48,710

각 삽입에는 log n 시간이 걸립니다. 그런 다음

458
00:10:48,710 --> 00:10:48,720
각 삽입에는 log n 시간이 걸립니다. 그런 다음
 

459
00:10:48,720 --> 00:10:50,710
각 삽입에는 log n 시간이 걸립니다. 그런 다음
최댓값을 찾고 삭제하고 균형을 다시 맞추는 과정을

460
00:10:50,710 --> 00:10:52,630
최댓값을 찾고 삭제하고 균형을 다시 맞추는 과정을
 

461
00:10:52,630 --> 00:10:55,430

 

462
00:10:55,430 --> 00:10:57,430

 

463
00:10:57,430 --> 00:10:58,550

 

464
00:10:58,550 --> 00:11:01,670

 

465
00:11:01,670 --> 00:11:04,069

 

466
00:11:04,069 --> 00:11:07,190

 

467
00:11:07,190 --> 00:11:10,230

 

468
00:11:10,230 --> 00:11:13,430

 

469
00:11:13,430 --> 00:11:13,440

 

470
00:11:13,440 --> 00:11:15,910

반복하면 총 시간은 n log n이 됩니다. 이것이 AVL 정렬이라고 하는 알고리즘입니다. AVL 트리 자체가 복잡하기 때문에 다소 복잡하지만, 최적의 비교 경계를 제공합니다. 자, 배열 정렬은 어떨까요? 정렬되지 않은 배열을 사용한다고 가정해 보겠습니다. 요소를 삽입하는데,

471
00:11:15,910 --> 00:11:15,920
반복하면 총 시간은 n log n이 됩니다. 이것이 AVL 정렬이라고 하는 알고리즘입니다. AVL 트리 자체가 복잡하기 때문에 다소 복잡하지만, 최적의 비교 경계를 제공합니다. 자, 배열 정렬은 어떨까요? 정렬되지 않은 배열을 사용한다고 가정해 보겠습니다. 요소를 삽입하는데,
 

472
00:11:15,920 --> 00:11:17,269
반복하면 총 시간은 n log n이 됩니다. 이것이 AVL 정렬이라고 하는 알고리즘입니다. AVL 트리 자체가 복잡하기 때문에 다소 복잡하지만, 최적의 비교 경계를 제공합니다. 자, 배열 정렬은 어떨까요? 정렬되지 않은 배열을 사용한다고 가정해 보겠습니다. 요소를 삽입하는데,
모든 삽입 작업을 삭제 작업보다 먼저 수행한다고 생각해 보세요. 그러면

473
00:11:17,269 --> 00:11:18,710
모든 삽입 작업을 삭제 작업보다 먼저 수행한다고 생각해 보세요. 그러면
 

474
00:11:18,710 --> 00:11:20,310

 

475
00:11:20,310 --> 00:11:20,320

 

476
00:11:20,320 --> 00:11:21,910

원래 배열 순서대로 요소가

477
00:11:21,910 --> 00:11:23,670
원래 배열 순서대로 요소가
 

478
00:11:23,670 --> 00:11:26,790

 

479
00:11:26,790 --> 00:11:26,800

 

480
00:11:26,800 --> 00:11:30,389

삽입됩니다. 즉, 배열에서 최댓값을

481
00:11:30,389 --> 00:11:30,399

 

482
00:11:30,399 --> 00:11:33,430

찾아 배열의 끝으로 이동시키는 과정을 반복합니다. 이

483
00:11:33,430 --> 00:11:34,470
찾아 배열의 끝으로 이동시키는 과정을 반복합니다. 이
 

484
00:11:34,470 --> 00:11:34,480

 

485
00:11:34,480 --> 00:11:36,230

과정이

486
00:11:36,230 --> 00:11:36,240
과정이
 

487
00:11:36,240 --> 00:11:38,389
과정이
생소하게 느껴지시나요? 이것이 바로

488
00:11:38,389 --> 00:11:41,509
생소하게 느껴지시나요? 이것이 바로
 

489
00:11:41,509 --> 00:11:41,519

 

490
00:11:41,519 --> 00:11:45,030

3강에서 배운 선택 정렬입니다.

491
00:11:45,030 --> 00:11:45,040
3강에서 배운 선택 정렬입니다.
 

492
00:11:45,040 --> 00:11:53,110
3강에서 배운 선택 정렬입니다.
배열에 선택 정렬을 적용하는 것은

493
00:11:53,110 --> 00:11:54,870

 

494
00:11:54,870 --> 00:11:54,880

 

495
00:11:54,880 --> 00:11:56,870

이전에

496
00:11:56,870 --> 00:11:56,880
이전에
 

497
00:11:56,880 --> 00:12:00,230
이전에
정렬된 배열에

498
00:12:00,230 --> 00:12:02,230

 

499
00:12:02,230 --> 00:12:02,240

 

500
00:12:02,240 --> 00:12:03,750

요소를 삽입했던 방식과는 다른 새로운 접근 방식입니다.  실제로

501
00:12:03,750 --> 00:12:03,760
요소를 삽입했던 방식과는 다른 새로운 접근 방식입니다.  실제로
 

502
00:12:03,760 --> 00:12:05,350
요소를 삽입했던 방식과는 다른 새로운 접근 방식입니다.  실제로
모든 작업은

503
00:12:05,350 --> 00:12:05,360
모든 작업은
 

504
00:12:05,360 --> 00:12:07,190
모든 작업은
정렬된 배열을 유지하는 부분에서 이루어집니다. 빈 배열에서 시작하면 정렬된 상태가 됩니다.

505
00:12:07,190 --> 00:12:08,470
정렬된 배열을 유지하는 부분에서 이루어집니다. 빈 배열에서 시작하면 정렬된 상태가 됩니다.
 

506
00:12:08,470 --> 00:12:08,480

 

507
00:12:08,480 --> 00:12:10,389

항목을 하나 추가해도 여전히 정렬된 상태입니다.

508
00:12:10,389 --> 00:12:10,399
항목을 하나 추가해도 여전히 정렬된 상태입니다.
 

509
00:12:10,399 --> 00:12:12,470
항목을 하나 추가해도 여전히 정렬된 상태입니다.
두 번째 항목을 추가하고 필요에 따라 위치를 교환합니다.

510
00:12:12,470 --> 00:12:12,480
두 번째 항목을 추가하고 필요에 따라 위치를 교환합니다.
 

511
00:12:12,480 --> 00:12:14,389
두 번째 항목을 추가하고 필요에 따라 위치를 교환합니다.
일반적으로 정렬을 위해

512
00:12:14,389 --> 00:12:14,399
일반적으로 정렬을 위해
 

513
00:12:14,399 --> 00:12:16,629
일반적으로 정렬을 위해
항목을 추가하고 다시 정렬될 때까지 왼쪽으로 위치를 교환합니다. 이것이

514
00:12:16,629 --> 00:12:17,430
항목을 추가하고 다시 정렬될 때까지 왼쪽으로 위치를 교환합니다. 이것이
 

515
00:12:17,430 --> 00:12:17,440

 

516
00:12:17,440 --> 00:12:25,590

삽입 정렬입니다. 멋지죠?

517
00:12:25,590 --> 00:12:25,600
삽입 정렬입니다. 멋지죠?
 

518
00:12:25,600 --> 00:12:27,910
삽입 정렬입니다. 멋지죠?
이 표는 이전에

519
00:12:27,910 --> 00:12:28,870
이 표는 이전에
 

520
00:12:28,870 --> 00:12:28,880

 

521
00:12:28,880 --> 00:12:31,670

살펴본 세 가지 정렬 알고리즘을 통합하는 프레임워크입니다.

522
00:12:31,670 --> 00:12:32,870
살펴본 세 가지 정렬 알고리즘을 통합하는 프레임워크입니다.
 

523
00:12:32,870 --> 00:12:32,880

 

524
00:12:32,880 --> 00:12:34,629

지난번에는 AVL 정렬에 대해서는 언급하지 않았지만, 노트

525
00:12:34,629 --> 00:12:34,639
지난번에는 AVL 정렬에 대해서는 언급하지 않았지만, 노트
 

526
00:12:34,639 --> 00:12:36,069
지난번에는 AVL 정렬에 대해서는 언급하지 않았지만, 노트
에 있었죠.

527
00:12:36,069 --> 00:12:36,079
에 있었죠.
 

528
00:12:36,079 --> 00:12:38,230
에 있었죠.
이

529
00:12:38,230 --> 00:12:38,240
이
 

530
00:12:38,240 --> 00:12:39,670
이
표의 오른쪽 부분이 바로 그 내용입니다. 물론

531
00:12:39,670 --> 00:12:39,680
표의 오른쪽 부분이 바로 그 내용입니다. 물론
 

532
00:12:39,680 --> 00:12:41,670
표의 오른쪽 부분이 바로 그 내용입니다. 물론
이러한 배열 데이터 구조는

533
00:12:41,670 --> 00:12:41,680
이러한 배열 데이터 구조는
 

534
00:12:41,680 --> 00:12:43,750
이러한 배열 데이터 구조는
효율적이지 않습니다. 일부 연산은 선형 시간 복잡도를 가집니다.

535
00:12:43,750 --> 00:12:43,760
효율적이지 않습니다. 일부 연산은 선형 시간 복잡도를 가집니다.
 

536
00:12:43,760 --> 00:12:45,030
효율적이지 않습니다. 일부 연산은 선형 시간 복잡도를 가집니다.
따라서 정렬

537
00:12:45,030 --> 00:12:45,040
따라서 정렬
 

538
00:12:45,040 --> 00:12:46,389
따라서 정렬
알고리즘 자체는 효율적이지 않지만,

539
00:12:46,389 --> 00:12:46,399
알고리즘 자체는 효율적이지 않지만,
 

540
00:12:46,399 --> 00:12:47,750
알고리즘 자체는 효율적이지 않지만,
이전에 살펴본 알고리즘들이기 때문에

541
00:12:47,750 --> 00:12:47,760
이전에 살펴본 알고리즘들이기 때문에
 

542
00:12:47,760 --> 00:12:49,590
이전에 살펴본 알고리즘들이기 때문에
여기서 어떻게 활용되는지 보는 것은 흥미롭습니다.

543
00:12:49,590 --> 00:12:51,269
여기서 어떻게 활용되는지 보는 것은 흥미롭습니다.
 

544
00:12:51,269 --> 00:12:51,279

 

545
00:12:51,279 --> 00:12:52,629

삽입 정렬은 배열 자체 외에

546
00:12:52,629 --> 00:12:54,310
삽입 정렬은 배열 자체 외에
 

547
00:12:54,310 --> 00:12:54,320

 

548
00:12:54,320 --> 00:12:56,949

일정한 개수의 포인터 또는 인덱스만 있으면 되므로

549
00:12:56,949 --> 00:12:59,670
일정한 개수의 포인터 또는 인덱스만 있으면 되므로
 

550
00:12:59,670 --> 00:12:59,680

 

551
00:12:59,680 --> 00:13:00,790

공간 효율성이 매우 높다는

552
00:13:00,790 --> 00:13:00,800
공간 효율성이 매우 높다는
 

553
00:13:00,800 --> 00:13:02,710
공간 효율성이 매우 높다는
장점이 있습니다. 하지만

554
00:13:02,710 --> 00:13:02,720
장점이 있습니다. 하지만
 

555
00:13:02,720 --> 00:13:04,230
장점이 있습니다. 하지만
시간 복잡도는 n 제곱이므로 특별한 경우가 아니면 사용해서는 안 됩니다.

556
00:13:04,230 --> 00:13:05,269
시간 복잡도는 n 제곱이므로 특별한 경우가 아니면 사용해서는 안 됩니다.
 

557
00:13:05,269 --> 00:13:05,279

 

558
00:13:05,279 --> 00:13:07,030

최대 n이 100

559
00:13:07,030 --> 00:13:07,040
최대 n이 100
 

560
00:13:07,040 --> 00:13:09,190
최대 n이 100
정도일 때는

561
00:13:09,190 --> 00:13:09,200
정도일 때는
 

562
00:13:09,200 --> 00:13:12,150
정도일 때는
AVL 트리 정렬이 훌륭하지만, 그 이후에는

563
00:13:12,150 --> 00:13:12,160
AVL 트리 정렬이 훌륭하지만, 그 이후에는
 

564
00:13:12,160 --> 00:13:12,550
AVL 트리 정렬이 훌륭하지만, 그 이후에는
n log n

565
00:13:12,550 --> 00:13:12,560
n log n
 

566
00:13:12,560 --> 00:13:15,269
n log n
시간 복잡도를 가지게 되고,

567
00:13:15,269 --> 00:13:15,279
시간 복잡도를 가지게 되고,
 

568
00:13:15,279 --> 00:13:16,629
시간 복잡도를 가지게 되고,
병합 정렬보다 더 복잡해질 수 있습니다. 병합 정렬을 고수할 수도 있지만, 병합 정렬이나

569
00:13:16,629 --> 00:13:16,639
병합 정렬보다 더 복잡해질 수 있습니다. 병합 정렬을 고수할 수도 있지만, 병합 정렬이나
 

570
00:13:16,639 --> 00:13:17,350
병합 정렬보다 더 복잡해질 수 있습니다. 병합 정렬을 고수할 수도 있지만, 병합 정렬이나

571
00:13:17,350 --> 00:13:17,360

 

572
00:13:17,360 --> 00:13:19,670

AVL 트리

573
00:13:19,670 --> 00:13:19,680
AVL 트리
 

574
00:13:19,680 --> 00:13:20,629
AVL 트리
정렬 모두 제자리 정렬이 아닙니다.

575
00:13:20,629 --> 00:13:20,639
정렬 모두 제자리 정렬이 아닙니다.
 

576
00:13:20,639 --> 00:13:24,310
정렬 모두 제자리 정렬이 아닙니다.
따라서 오늘 우리의 목표는

577
00:13:24,310 --> 00:13:25,990
따라서 오늘 우리의 목표는
 

578
00:13:25,990 --> 00:13:28,310

 

579
00:13:28,310 --> 00:13:28,320

 

580
00:13:28,320 --> 00:13:30,790

비교 모델에서 최적의 n log n 비교 횟수를 달성

581
00:13:30,790 --> 00:13:30,800
비교 모델에서 최적의 n log n 비교 횟수를 달성
 

582
00:13:30,800 --> 00:13:33,350
비교 모델에서 최적의 n log n 비교 횟수를 달성
하면서도 제자리 정렬을 유지하는 것입니다. 이를 위해 이진 힙을

583
00:13:33,350 --> 00:13:34,710
하면서도 제자리 정렬을 유지하는 것입니다. 이를 위해 이진 힙을
 

584
00:13:34,710 --> 00:13:38,550

 

585
00:13:38,550 --> 00:13:38,560

 

586
00:13:38,560 --> 00:13:40,790

설계할 것입니다. 이진 힙은 구축 시간이

587
00:13:40,790 --> 00:13:42,150
설계할 것입니다. 이진 힙은 구축 시간이
 

588
00:13:42,150 --> 00:13:42,160

 

589
00:13:42,160 --> 00:13:43,670

선형 시간으로 약간 더 빠르며,

590
00:13:43,670 --> 00:13:43,680
선형 시간으로 약간 더 빠르며,
 

591
00:13:43,680 --> 00:13:45,350
선형 시간으로 약간 더 빠르며,

592
00:13:45,350 --> 00:13:47,350

 

593
00:13:47,350 --> 00:13:47,360

 

594
00:13:47,360 --> 00:13:49,750

AVL 트리처럼 정렬된 순서를 직접 표현하지는 않지만,

595
00:13:49,750 --> 00:13:51,350
AVL 트리처럼 정렬된 순서를 직접 표현하지는 않지만,
 

596
00:13:51,350 --> 00:13:51,360

 

597
00:13:51,360 --> 00:13:53,590

배열 기반 데이터 구조를 사용합니다.

598
00:13:53,590 --> 00:13:55,350
배열 기반 데이터 구조를 사용합니다.
 

599
00:13:55,350 --> 00:13:55,360

 

600
00:13:55,360 --> 00:13:57,189

삽입과 삭제에 최대 로그 시간 복잡도를 가지며,

601
00:13:57,189 --> 00:13:57,199
삽입과 삭제에 최대 로그 시간 복잡도를 가지며,
 

602
00:13:57,199 --> 00:14:00,150
삽입과 삭제에 최대 로그 시간 복잡도를 가지며,
배열을 사용하기 때문에 상각 시간 복잡도를 가집니다.

603
00:14:00,150 --> 00:14:00,160
배열을 사용하기 때문에 상각 시간 복잡도를 가집니다.
 

604
00:14:00,160 --> 00:14:01,990
배열을 사용하기 때문에 상각 시간 복잡도를 가집니다.
핵심은 제자리 정렬이 가능하다는 점입니다. 이진 힙은

605
00:14:01,990 --> 00:14:03,910
핵심은 제자리 정렬이 가능하다는 점입니다. 이진 힙은
 

606
00:14:03,910 --> 00:14:03,920

 

607
00:14:03,920 --> 00:14:06,230

항목 배열로만 구성되어 있으므로,

608
00:14:06,230 --> 00:14:06,240
항목 배열로만 구성되어 있으므로,
 

609
00:14:06,240 --> 00:14:07,910
항목 배열로만 구성되어 있으므로,

610
00:14:07,910 --> 00:14:09,590

 

611
00:14:09,590 --> 00:14:09,600

 

612
00:14:09,600 --> 00:14:11,030


613
00:14:11,030 --> 00:14:11,040

 

614
00:14:11,040 --> 00:14:12,710

우선순위 Q 정렬과 같은 일반적인 정렬

615
00:14:12,710 --> 00:14:12,720
우선순위 Q 정렬과 같은 일반적인 정렬
 

616
00:14:12,720 --> 00:14:14,949
우선순위 Q 정렬과 같은 일반적인 정렬
알고리즘에 적용하면 n log n 시간 복잡도를 얻을 수 있습니다.

617
00:14:14,949 --> 00:14:14,959
알고리즘에 적용하면 n log n 시간 복잡도를 얻을 수 있습니다.
 

618
00:14:14,959 --> 00:14:17,590
알고리즘에 적용하면 n log n 시간 복잡도를 얻을 수 있습니다.
성능 향상뿐 아니라, 제자리

619
00:14:17,590 --> 00:14:17,600
성능 향상뿐 아니라, 제자리
 

620
00:14:17,600 --> 00:14:19,189
성능 향상뿐 아니라, 제자리
정렬 알고리즘도 배우게 됩니다.

621
00:14:19,189 --> 00:14:19,199
정렬 알고리즘도 배우게 됩니다.
 

622
00:14:19,199 --> 00:14:21,269
정렬 알고리즘도 배우게 됩니다.
이번 수업에서 처음이자 마지막으로 다룰 내용은

623
00:14:21,269 --> 00:14:21,279
이번 수업에서 처음이자 마지막으로 다룰 내용은
 

624
00:14:21,279 --> 00:14:24,470
이번 수업에서 처음이자 마지막으로 다룰 내용은
log n 제자리 정렬 알고리즘입니다. 좋습니다,

625
00:14:24,470 --> 00:14:24,480
log n 제자리 정렬 알고리즘입니다. 좋습니다,
 

626
00:14:24,480 --> 00:14:29,670
log n 제자리 정렬 알고리즘입니다. 좋습니다,
목표입니다. 시작해 봅시다. 제자리 정렬을 하려면

627
00:14:29,670 --> 00:14:32,710
목표입니다. 시작해 봅시다. 제자리 정렬을 하려면
 

628
00:14:32,710 --> 00:14:35,910

 

629
00:14:35,910 --> 00:14:35,920

 

630
00:14:35,920 --> 00:14:37,590

기본적으로

631
00:14:37,590 --> 00:14:37,600
기본적으로
 

632
00:14:37,600 --> 00:14:38,470
기본적으로

633
00:14:38,470 --> 00:14:38,480

 

634
00:14:38,480 --> 00:14:40,150

n개의 항목을 저장하는 배열이 필요합니다.

635
00:14:40,150 --> 00:14:41,509
n개의 항목을 저장하는 배열이 필요합니다.
 

636
00:14:41,509 --> 00:14:41,519

 

637
00:14:41,519 --> 00:14:44,870

n개의 메모리 슬롯, 즉

638
00:14:44,870 --> 00:14:45,910
n개의 메모리 슬롯, 즉
 

639
00:14:45,910 --> 00:14:45,920

 

640
00:14:45,920 --> 00:14:48,150

구조체에 있는 항목 수만큼의 슬롯을 사용하는 것이죠. 하지만 일반적인 정렬되지 않은 배열

641
00:14:48,150 --> 00:14:49,189
구조체에 있는 항목 수만큼의 슬롯을 사용하는 것이죠. 하지만 일반적인 정렬되지 않은 배열
 

642
00:14:49,189 --> 00:14:49,199

 

643
00:14:49,199 --> 00:14:51,269

이나 정렬된

644
00:14:51,269 --> 00:14:51,279
이나 정렬된
 

645
00:14:51,279 --> 00:14:53,910
이나 정렬된
배열을 사용하는 것이 아니라, 배열을 저장 방식의

646
00:14:53,910 --> 00:14:53,920
배열을 사용하는 것이 아니라, 배열을 저장 방식의
 

647
00:14:53,920 --> 00:14:55,269
배열을 사용하는 것이 아니라, 배열을 저장 방식의
기본 기술로만 사용할 것입니다. 로그 성능을 목표로 하기 때문에,

648
00:14:55,269 --> 00:14:55,279
기본 기술로만 사용할 것입니다. 로그 성능을 목표로 하기 때문에,
 

649
00:14:55,279 --> 00:14:56,150
기본 기술로만 사용할 것입니다. 로그 성능을 목표로 하기 때문에,

650
00:14:56,150 --> 00:14:58,310

 

651
00:14:58,310 --> 00:14:59,269

 

652
00:14:59,269 --> 00:15:01,030

 

653
00:15:01,030 --> 00:15:02,790

 

654
00:15:02,790 --> 00:15:02,800

 

655
00:15:02,800 --> 00:15:04,550

로그 성능을 얻는 유일한 방법은 이진 트리를 사용하는 것이죠. 따라서 배열에 트리를 내장해야 합니다.

656
00:15:04,550 --> 00:15:06,470
로그 성능을 얻는 유일한 방법은 이진 트리를 사용하는 것이죠. 따라서 배열에 트리를 내장해야 합니다.
 

657
00:15:06,470 --> 00:15:09,590

 

658
00:15:09,590 --> 00:15:13,350

 

659
00:15:13,350 --> 00:15:13,360

 

660
00:15:13,360 --> 00:15:23,829

예를 들어 트리를

661
00:15:23,829 --> 00:15:23,839

 

662
00:15:23,839 --> 00:15:44,550

그려 보겠습니다.

663
00:15:44,550 --> 00:15:44,560

 

664
00:15:44,560 --> 00:15:47,189

만약 아무 트리나 선택할 수 있다면, 저는 완벽하게 균형 잡힌 트리를

665
00:15:47,189 --> 00:15:47,199
만약 아무 트리나 선택할 수 있다면, 저는 완벽하게 균형 잡힌 트리를
 

666
00:15:47,199 --> 00:15:48,310
만약 아무 트리나 선택할 수 있다면, 저는 완벽하게 균형 잡힌 트리를
선택할 것입니다. 완벽하게 균형 잡힌

667
00:15:48,310 --> 00:15:48,320
선택할 것입니다. 완벽하게 균형 잡힌
 

668
00:15:48,320 --> 00:15:50,550
선택할 것입니다. 완벽하게 균형 잡힌
트리는 다음과 같습니다.

669
00:15:50,550 --> 00:15:50,560
트리는 다음과 같습니다.
 

670
00:15:50,560 --> 00:15:51,350
트리는 다음과 같습니다.

671
00:15:51,350 --> 00:15:54,949

 

672
00:15:54,949 --> 00:15:54,959

 

673
00:15:54,959 --> 00:15:57,749

모든

674
00:15:57,749 --> 00:15:57,759
모든
 

675
00:15:57,759 --> 00:15:58,230
모든

676
00:15:58,230 --> 00:15:58,240

 

677
00:15:58,240 --> 00:15:59,829

레벨과 모든 깊이에

678
00:15:59,829 --> 00:15:59,839
레벨과 모든 깊이에
 

679
00:15:59,839 --> 00:16:01,670
레벨과 모든 깊이에
노드가 완전히 채워져 있는 것이 특징입니다.

680
00:16:01,670 --> 00:16:01,680
노드가 완전히 채워져 있는 것이 특징입니다.
 

681
00:16:01,680 --> 00:16:05,590
노드가 완전히 채워져 있는 것이 특징입니다.
이 깊이는 다음과 같습니다.  0,

682
00:16:05,590 --> 00:16:05,600

 

683
00:16:05,600 --> 00:16:08,389

기억하세요. 여기가 깊이 1이고, 여기가 깊이

684
00:16:08,389 --> 00:16:08,399
기억하세요. 여기가 깊이 1이고, 여기가 깊이
 

685
00:16:08,399 --> 00:16:09,430
기억하세요. 여기가 깊이 1이고, 여기가 깊이
2,

686
00:16:09,430 --> 00:16:09,440
2,
 

687
00:16:09,440 --> 00:16:11,910
2,
여기가 깊이 3입니다. 제가 정말

688
00:16:11,910 --> 00:16:11,920
여기가 깊이 3입니다. 제가 정말
 

689
00:16:11,920 --> 00:16:12,790
여기가 깊이 3입니다. 제가 정말
원하는 건

690
00:16:12,790 --> 00:16:18,550
원하는 건
 

691
00:16:18,550 --> 00:16:18,560

 

692
00:16:18,560 --> 00:16:23,030

깊이 i에 2의 i승 개의 노드가 있는 건데, 그러면 완벽한

693
00:16:23,030 --> 00:16:23,040
깊이 i에 2의 i승 개의 노드가 있는 건데, 그러면 완벽한
 

694
00:16:23,040 --> 00:16:26,470
깊이 i에 2의 i승 개의 노드가 있는 건데, 그러면 완벽한
이진 트리가 되겠죠. 하지만 이건

695
00:16:26,470 --> 00:16:26,480
이진 트리가 되겠죠. 하지만 이건
 

696
00:16:26,480 --> 00:16:28,150
이진 트리가 되겠죠. 하지만 이건
n이 2의 거듭제곱보다 1 작을 때만 가능해요.

697
00:16:28,150 --> 00:16:30,629
n이 2의 거듭제곱보다 1 작을 때만 가능해요.
 

698
00:16:30,629 --> 00:16:30,639

 

699
00:16:30,639 --> 00:16:31,509

모든 n에 대해 항상 그렇게 할 수는 없잖아요.

700
00:16:31,509 --> 00:16:31,519
모든 n에 대해 항상 그렇게 할 수는 없잖아요.
 

701
00:16:31,519 --> 00:16:33,269
모든 n에 대해 항상 그렇게 할 수는 없잖아요.
그래서 차선책으로

702
00:16:33,269 --> 00:16:35,030
그래서 차선책으로
 

703
00:16:35,030 --> 00:16:35,040

 

704
00:16:35,040 --> 00:16:37,269

깊이 i에 2의 i승 개의 노드가 있고,

705
00:16:37,269 --> 00:16:38,310
깊이 i에 2의 i승 개의 노드가 있고,
 

706
00:16:38,310 --> 00:16:38,320

 

707
00:16:38,320 --> 00:16:41,590

가장 깊은 i

708
00:16:41,590 --> 00:16:41,600
가장 깊은 i
 

709
00:16:41,600 --> 00:16:43,509
가장 깊은 i
레벨에서도 제한을 둘 거예요.

710
00:16:43,509 --> 00:16:44,629
레벨에서도 제한을 둘 거예요.
 

711
00:16:44,629 --> 00:16:44,639

 

712
00:16:44,639 --> 00:16:46,389

모든 노드를 최대한 왼쪽으로 배치하는 거죠. 그러니까

713
00:16:46,389 --> 00:16:46,399
모든 노드를 최대한 왼쪽으로 배치하는 거죠. 그러니까
 

714
00:16:46,399 --> 00:16:48,069
모든 노드를 최대한 왼쪽으로 배치하는 거죠. 그러니까

715
00:16:48,069 --> 00:16:53,030

 

716
00:16:53,030 --> 00:16:53,040

 

717
00:16:53,040 --> 00:16:58,150

최대 깊이에서

718
00:16:58,150 --> 00:16:58,160

 

719
00:16:58,160 --> 00:17:01,350


720
00:17:01,350 --> 00:17:01,360

 

721
00:17:01,360 --> 00:17:10,549

노드들이 왼쪽 정렬된 상태라고 부를게요.

722
00:17:10,549 --> 00:17:10,559

 

723
00:17:10,559 --> 00:17:12,789

이 두 가지 속성을 합쳐서

724
00:17:12,789 --> 00:17:12,799
이 두 가지 속성을 합쳐서
 

725
00:17:12,799 --> 00:17:14,390
이 두 가지 속성을 합쳐서
완전

726
00:17:14,390 --> 00:17:14,400
완전
 

727
00:17:14,400 --> 00:17:26,549
완전
이진 트리라고 부르는 거예요.

728
00:17:26,549 --> 00:17:26,559

 

729
00:17:26,559 --> 00:17:30,310

이게 왜 흥미로울까요? 왜냐하면 저는

730
00:17:30,310 --> 00:17:30,320
이게 왜 흥미로울까요? 왜냐하면 저는
 

731
00:17:30,320 --> 00:17:33,350
이게 왜 흥미로울까요? 왜냐하면 저는
이런 트리를 배열로 표현할 수 있다고 주장했거든요. 이제

732
00:17:33,350 --> 00:17:36,470
이런 트리를 배열로 표현할 수 있다고 주장했거든요. 이제
 

733
00:17:36,470 --> 00:17:36,480

 

734
00:17:36,480 --> 00:17:37,909

충분히 범위를 좁혀서

735
00:17:37,909 --> 00:17:37,919
충분히 범위를 좁혀서
 

736
00:17:37,919 --> 00:17:41,270
충분히 범위를 좁혀서
여기에 배열을 그릴 수 있어요.

737
00:17:41,270 --> 00:17:43,029
여기에 배열을 그릴 수 있어요.
 

738
00:17:43,029 --> 00:17:43,039

 

739
00:17:43,039 --> 00:17:45,110

깊이 순서대로 노드를 쓸게요. 먼저 a를

740
00:17:45,110 --> 00:17:45,120
깊이 순서대로 노드를 쓸게요. 먼저 a를
 

741
00:17:45,120 --> 00:17:47,029
깊이 순서대로 노드를 쓸게요. 먼저 a를
쓸게요. 이게

742
00:17:47,029 --> 00:17:47,039
쓸게요. 이게
 

743
00:17:47,039 --> 00:17:50,789
쓸게요. 이게
0단계니까요. 그다음은 bc예요. 이게 1단계니까요.

744
00:17:50,789 --> 00:17:50,799
0단계니까요. 그다음은 bc예요. 이게 1단계니까요.
 

745
00:17:50,799 --> 00:17:53,430
0단계니까요. 그다음은 bc예요. 이게 1단계니까요.
그다음은 알파벳 순서로 썼어요. 제가 그렇게 만들었거든요.

746
00:17:53,430 --> 00:17:54,630
그다음은 알파벳 순서로 썼어요. 제가 그렇게 만들었거든요.
 

747
00:17:54,630 --> 00:17:54,640

 

748
00:17:54,640 --> 00:17:58,630

d, e, f, g는 깊이가 2

749
00:17:58,630 --> 00:17:58,640
d, e, f, g는 깊이가 2
 

750
00:17:58,640 --> 00:18:02,710
d, e, f, g는 깊이가 2
이고 hij는 깊이가 3입니다.

751
00:18:02,710 --> 00:18:02,720

 

752
00:18:02,720 --> 00:18:04,549

이는

753
00:18:04,549 --> 00:18:04,559
이는
 

754
00:18:04,559 --> 00:18:05,990
이는
트리의 순회 순서와는 매우 다릅니다. 트리의

755
00:18:05,990 --> 00:18:06,000
트리의 순회 순서와는 매우 다릅니다. 트리의
 

756
00:18:06,000 --> 00:18:08,470
트리의 순회 순서와는 매우 다릅니다. 트리의
순회 순서는 h > d > i > b > j > e > a > f >

757
00:18:08,470 --> 00:18:09,190
순회 순서는 h > d > i > b > j > e > a > f >
 

758
00:18:09,190 --> 00:18:09,200

 

759
00:18:09,200 --> 00:18:12,390

c > g입니다. 하지만 이것을

760
00:18:12,390 --> 00:18:12,400
c > g입니다. 하지만 이것을
 

761
00:18:12,400 --> 00:18:15,430
c > g입니다. 하지만 이것을
깊이 순서라고 부를 수 있습니다.

762
00:18:15,430 --> 00:18:15,440
깊이 순서라고 부를 수 있습니다.
 

763
00:18:15,440 --> 00:18:17,510
깊이 순서라고 부를 수 있습니다.
가장 낮은 깊이의 노드부터 먼저 처리합니다.

764
00:18:17,510 --> 00:18:19,990
가장 낮은 깊이의 노드부터 먼저 처리합니다.
 

765
00:18:19,990 --> 00:18:21,750

 

766
00:18:21,750 --> 00:18:21,760

 

767
00:18:21,760 --> 00:18:25,669

데이터를 배열하거나 선형화하는 매우 다른 방식입니다. 이것이 힙의 구조입니다.

768
00:18:25,669 --> 00:18:25,679
데이터를 배열하거나 선형화하는 매우 다른 방식입니다. 이것이 힙의 구조입니다.
 

769
00:18:25,679 --> 00:18:28,070
데이터를 배열하거나 선형화하는 매우 다른 방식입니다. 이것이 힙의 구조입니다.
흥미로운

770
00:18:28,070 --> 00:18:28,080
흥미로운
 

771
00:18:28,080 --> 00:18:29,110
흥미로운
점은

772
00:18:29,110 --> 00:18:29,120
점은
 

773
00:18:29,120 --> 00:18:32,789
점은
완전

774
00:18:32,789 --> 00:18:32,799
완전
 

775
00:18:32,799 --> 00:18:36,230
완전
이진 트리와 배열 사이에 전단사 함수가 존재한다는 것입니다.

776
00:18:36,230 --> 00:18:36,240
이진 트리와 배열 사이에 전단사 함수가 존재한다는 것입니다.
 

777
00:18:36,240 --> 00:18:38,310
이진 트리와 배열 사이에 전단사 함수가 존재한다는 것입니다.
모든 배열에는 고유한

778
00:18:38,310 --> 00:18:38,320
모든 배열에는 고유한
 

779
00:18:38,320 --> 00:18:39,590
모든 배열에는 고유한
완전 이진 트리가 있고,

780
00:18:39,590 --> 00:18:39,600
완전 이진 트리가 있고,
 

781
00:18:39,600 --> 00:18:41,110
완전 이진 트리가 있고,
모든 완전 이진 트리에는

782
00:18:41,110 --> 00:18:41,120
모든 완전 이진 트리에는
 

783
00:18:41,120 --> 00:18:43,270
모든 완전 이진 트리에는
고유한 배열이 있습니다.

784
00:18:43,270 --> 00:18:43,280
고유한 배열이 있습니다.
 

785
00:18:43,280 --> 00:18:46,150
고유한 배열이 있습니다.
왜냐하면 완전성 제약

786
00:18:46,150 --> 00:18:46,160
왜냐하면 완전성 제약
 

787
00:18:46,160 --> 00:18:47,590
왜냐하면 완전성 제약
조건 때문에 모든 것이 제한되기 때문입니다.

788
00:18:47,590 --> 00:18:49,669
조건 때문에 모든 것이 제한되기 때문입니다.
 

789
00:18:49,669 --> 00:18:49,679

 

790
00:18:49,679 --> 00:18:50,789

숫자 n이 주어지면

791
00:18:50,789 --> 00:18:50,799
숫자 n이 주어지면
 

792
00:18:50,799 --> 00:18:53,590
숫자 n이 주어지면
크기가 n인 트리의 형태는 하나뿐입니다.

793
00:18:53,590 --> 00:18:53,600
크기가 n인 트리의 형태는 하나뿐입니다.
 

794
00:18:53,600 --> 00:18:55,990
크기가 n인 트리의 형태는 하나뿐입니다.
노드를

795
00:18:55,990 --> 00:18:56,000
노드를
 

796
00:18:56,000 --> 00:18:57,669
노드를
위에서 아래로 채워 마지막 레벨까지 이동한

797
00:18:57,669 --> 00:18:57,679
위에서 아래로 채워 마지막 레벨까지 이동한
 

798
00:18:57,679 --> 00:18:58,870
위에서 아래로 채워 마지막 레벨까지 이동한
다음, 왼쪽에서 오른쪽으로 채워야 합니다. 이를

799
00:18:58,870 --> 00:18:59,750
다음, 왼쪽에서 오른쪽으로 채워야 합니다. 이를
 

800
00:18:59,750 --> 00:18:59,760

 

801
00:18:59,760 --> 00:19:02,549

읽는 순서라고 할 수 있습니다.

802
00:19:02,549 --> 00:19:03,750
읽는 순서라고 할 수 있습니다.
 

803
00:19:03,750 --> 00:19:03,760

 

804
00:19:03,760 --> 00:19:06,230

배열은 어떤 키가 어디에 위치해야 하는지 알려줍니다.

805
00:19:06,230 --> 00:19:06,950
배열은 어떤 키가 어디에 위치해야 하는지 알려줍니다.
 

806
00:19:06,950 --> 00:19:06,960

 

807
00:19:06,960 --> 00:19:08,549

이것은 루트에 기록하는 첫 번째 노드이고,

808
00:19:08,549 --> 00:19:08,559
이것은 루트에 기록하는 첫 번째 노드이고,
 

809
00:19:08,559 --> 00:19:10,310
이것은 루트에 기록하는 첫 번째 노드이고,
이것은

810
00:19:10,310 --> 00:19:10,320
이것은
 

811
00:19:10,320 --> 00:19:11,990
이것은
루트의 왼쪽 자식에 기록하는 다음 노드입니다. 이런 식으로 계속됩니다. 따라서

812
00:19:11,990 --> 00:19:12,000
루트의 왼쪽 자식에 기록하는 다음 노드입니다. 이런 식으로 계속됩니다. 따라서
 

813
00:19:12,000 --> 00:19:14,789
루트의 왼쪽 자식에 기록하는 다음 노드입니다. 이런 식으로 계속됩니다. 따라서
여기에 이진 트리가 다음과 같이

814
00:19:14,789 --> 00:19:14,799
여기에 이진 트리가 다음과 같이
 

815
00:19:14,799 --> 00:19:15,510
여기에 이진 트리가 다음과 같이

816
00:19:15,510 --> 00:19:15,520

 

817
00:19:15,520 --> 00:19:17,909

표현되어 있습니다.  이진 트리를 나타내는 배열 또는 배열은

818
00:19:17,909 --> 00:19:19,430
표현되어 있습니다.  이진 트리를 나타내는 배열 또는 배열은
 

819
00:19:19,430 --> 00:19:22,390

 

820
00:19:22,390 --> 00:19:22,400

 

821
00:19:22,400 --> 00:19:23,190

명확한

822
00:19:23,190 --> 00:19:23,200
명확한
 

823
00:19:23,200 --> 00:19:24,950
명확한
장점을 가지고 있는데, 바로

824
00:19:24,950 --> 00:19:24,960
장점을 가지고 있는데, 바로
 

825
00:19:24,960 --> 00:19:27,029
장점을 가지고 있는데, 바로
균형이 보장된다는 점입니다. 힙에서는 회전이 필요하지 않습니다.

826
00:19:27,029 --> 00:19:28,070
균형이 보장된다는 점입니다. 힙에서는 회전이 필요하지 않습니다.
 

827
00:19:28,070 --> 00:19:28,080

 

828
00:19:28,080 --> 00:19:29,350

완전 이진 트리는 항상

829
00:19:29,350 --> 00:19:29,360
완전 이진 트리는 항상
 

830
00:19:29,360 --> 00:19:30,870
완전 이진 트리는 항상
균형을 이루기 때문입니다. 실제로 힙은

831
00:19:30,870 --> 00:19:30,880
균형을 이루기 때문입니다. 실제로 힙은
 

832
00:19:30,880 --> 00:19:33,669
균형을 이루기 때문입니다. 실제로 힙은
가능한 최고의 높이, 즉

833
00:19:33,669 --> 00:19:33,679
가능한 최고의 높이, 즉
 

834
00:19:33,679 --> 00:19:39,430
가능한 최고의 높이, 즉
log n의 상한값을 가집니다. 여기서 '균형'이란

835
00:19:39,430 --> 00:19:41,270
log n의 상한값을 가집니다. 여기서 '균형'이란
 

836
00:19:41,270 --> 00:19:41,280

 

837
00:19:41,280 --> 00:19:43,029

log n의 빅 O 표기법을 의미하며, 이는

838
00:19:43,029 --> 00:19:43,039
log n의 빅 O 표기법을 의미하며, 이는
 

839
00:19:43,039 --> 00:19:46,230
log n의 빅 O 표기법을 의미하며, 이는
1 곱하기 log n입니다.

840
00:19:46,230 --> 00:19:47,750
1 곱하기 log n입니다.
 

841
00:19:47,750 --> 00:19:47,760

 

842
00:19:47,760 --> 00:19:51,270

따라서 힙은 우선

843
00:19:51,270 --> 00:19:52,070
따라서 힙은 우선
 

844
00:19:52,070 --> 00:19:52,080

 

845
00:19:52,080 --> 00:19:54,230

순위 큐 문제를 해결하기 위해 완전 이진 트리를 유지할 수 있다고 주장할 수 있습니다.

846
00:19:54,230 --> 00:19:55,669
순위 큐 문제를 해결하기 위해 완전 이진 트리를 유지할 수 있다고 주장할 수 있습니다.
 

847
00:19:55,669 --> 00:19:55,679

 

848
00:19:55,679 --> 00:19:57,510

전체 집합 인터페이스를 해결하려고 한다면 이는 불가능합니다.

849
00:19:57,510 --> 00:19:58,789
전체 집합 인터페이스를 해결하려고 한다면 이는 불가능합니다.
 

850
00:19:58,789 --> 00:19:58,799

 

851
00:19:58,799 --> 00:20:01,029

힙의 멋진 점은

852
00:20:01,029 --> 00:20:01,039
힙의 멋진 점은
 

853
00:20:01,039 --> 00:20:02,870
힙의 멋진 점은
집합 인터페이스의 부분 집합에만 집중함으로써

854
00:20:02,870 --> 00:20:02,880
집합 인터페이스의 부분 집합에만 집중함으로써
 

855
00:20:02,880 --> 00:20:06,230
집합 인터페이스의 부분 집합에만 집중함으로써
더 많은 것을 할 수 있고, 이러한

856
00:20:06,230 --> 00:20:06,240
더 많은 것을 할 수 있고, 이러한
 

857
00:20:06,240 --> 00:20:07,430
더 많은 것을 할 수 있고, 이러한
강력한 속성을 유지할 수 있다는 것입니다.

858
00:20:07,430 --> 00:20:07,440
강력한 속성을 유지할 수 있다는 것입니다.
 

859
00:20:07,440 --> 00:20:08,870
강력한 속성을 유지할 수 있다는 것입니다.
이러한 강력한

860
00:20:08,870 --> 00:20:08,880
이러한 강력한
 

861
00:20:08,880 --> 00:20:10,310
이러한 강력한
속성 덕분에 트리를 저장할 필요조차 없습니다.

862
00:20:10,310 --> 00:20:11,750
속성 덕분에 트리를 저장할 필요조차 없습니다.
 

863
00:20:11,750 --> 00:20:11,760

 

864
00:20:11,760 --> 00:20:13,029

왼쪽, 오른쪽 포인터

865
00:20:13,029 --> 00:20:13,039
왼쪽, 오른쪽 포인터
 

866
00:20:13,039 --> 00:20:14,630
왼쪽, 오른쪽 포인터
나 부모 포인터를 저장할 필요 없이

867
00:20:14,630 --> 00:20:14,640
나 부모 포인터를 저장할 필요 없이
 

868
00:20:14,640 --> 00:20:16,390
나 부모 포인터를 저장할 필요 없이
배열만 저장하면 됩니다.

869
00:20:16,390 --> 00:20:16,400
배열만 저장하면 됩니다.
 

870
00:20:16,400 --> 00:20:19,029
배열만 저장하면 됩니다.
이를 암묵적 데이터 구조라고 하는데,

871
00:20:19,029 --> 00:20:19,039
이를 암묵적 데이터 구조라고 하는데,
 

872
00:20:19,039 --> 00:20:28,549
이를 암묵적 데이터 구조라고 하는데,

873
00:20:28,549 --> 00:20:28,559

 

874
00:20:28,559 --> 00:20:33,270

기본적으로 포인터 없이 n개의 항목으로 구성된 배열만 저장하는 것을 의미합니다.

875
00:20:33,270 --> 00:20:37,510

 

876
00:20:37,510 --> 00:20:43,990

 

877
00:20:43,990 --> 00:20:45,270

 

878
00:20:45,270 --> 00:20:45,280

 

879
00:20:45,280 --> 00:20:47,750

포인터를 저장하지 않고 어떻게 가능할까요? 저는 여전히 트리처럼 다루고 싶습니다.

880
00:20:47,750 --> 00:20:50,230
포인터를 저장하지 않고 어떻게 가능할까요? 저는 여전히 트리처럼 다루고 싶습니다.
 

881
00:20:50,230 --> 00:20:50,240

 

882
00:20:50,240 --> 00:20:52,470

b의 왼쪽 자식이 d이고 오른쪽

883
00:20:52,470 --> 00:20:52,480
b의 왼쪽 자식이 d이고 오른쪽
 

884
00:20:52,480 --> 00:20:53,270
b의 왼쪽 자식이 d이고 오른쪽
자식이

885
00:20:53,270 --> 00:20:53,280
자식이
 

886
00:20:53,280 --> 00:20:56,310
자식이
e라는 것을 알고 싶다고 가정해 보겠습니다. 잠시 후

887
00:20:56,310 --> 00:20:59,990
e라는 것을 알고 싶다고 가정해 보겠습니다. 잠시 후
 

888
00:20:59,990 --> 00:21:00,000

 

889
00:21:00,000 --> 00:21:04,149

인덱스 연산을 사용하여 이를 수행할 수 있다는 것을 알게 될 것입니다. 그

890
00:21:04,149 --> 00:21:04,159
인덱스 연산을 사용하여 이를 수행할 수 있다는 것을 알게 될 것입니다. 그
 

891
00:21:04,159 --> 00:21:06,070
인덱스 연산을 사용하여 이를 수행할 수 있다는 것을 알게 될 것입니다. 그
전에 레이블을 몇 개 추가해야 할 것 같습니다. 이

892
00:21:06,070 --> 00:21:11,190
전에 레이블을 몇 개 추가해야 할 것 같습니다. 이
 

893
00:21:11,190 --> 00:21:11,200

 

894
00:21:11,200 --> 00:21:13,750

배열에는 인덱스가 있습니다.

895
00:21:13,750 --> 00:21:13,760
배열에는 인덱스가 있습니다.
 

896
00:21:13,760 --> 00:21:16,390
배열에는 인덱스가 있습니다.
이것이 인덱스 0,

897
00:21:16,390 --> 00:21:16,400
이것이 인덱스 0,
 

898
00:21:16,400 --> 00:21:19,190
이것이 인덱스 0,
이것이 인덱스 1, 인덱스 2, 인덱스 3, 인덱스

899
00:21:19,190 --> 00:21:19,200
이것이 인덱스 1, 인덱스 2, 인덱스 3, 인덱스
 

900
00:21:19,200 --> 00:21:19,990
이것이 인덱스 1, 인덱스 2, 인덱스 3, 인덱스
4, 인덱스 5,

901
00:21:19,990 --> 00:21:20,000
4, 인덱스 5,
 

902
00:21:20,000 --> 00:21:23,270
4, 인덱스 5,
인덱스 6, 7, 8,

903
00:21:23,270 --> 00:21:23,280
인덱스 6, 7, 8,
 

904
00:21:23,280 --> 00:21:26,149
인덱스 6, 7, 8,
9입니다. 0부터 9까지 10개의 항목이 있으므로

905
00:21:26,149 --> 00:21:27,669
9입니다. 0부터 9까지 10개의 항목이 있으므로
 

906
00:21:27,669 --> 00:21:27,679

 

907
00:21:27,679 --> 00:21:29,510

이 레이블을 적용할 수 있습니다. 위쪽에도

908
00:21:29,510 --> 00:21:29,520
이 레이블을 적용할 수 있습니다. 위쪽에도
 

909
00:21:29,520 --> 00:21:31,430
이 레이블을 적용할 수 있습니다. 위쪽에도
동일한 노드에 레이블을 적용할 수 있습니다. 0,

910
00:21:31,430 --> 00:21:31,440
동일한 노드에 레이블을 적용할 수 있습니다. 0,
 

911
00:21:31,440 --> 00:21:36,710
동일한 노드에 레이블을 적용할 수 있습니다. 0,
1, 2. 이것은 깊이 순서입니다.

912
00:21:36,710 --> 00:21:36,720

 

913
00:21:36,720 --> 00:21:38,149

이렇게 레이블을 지정하면

914
00:21:38,149 --> 00:21:38,159
이렇게 레이블을 지정하면
 

915
00:21:38,159 --> 00:21:39,830
이렇게 레이블을 지정하면
훨씬 쉽게 파악할 수 있습니다. 예를 들어

916
00:21:39,830 --> 00:21:41,510
훨씬 쉽게 파악할 수 있습니다. 예를 들어
 

917
00:21:41,510 --> 00:21:41,520

 

918
00:21:41,520 --> 00:21:43,270

b의 왼쪽 자식이 d라는 것을 알고 싶다면,

919
00:21:43,270 --> 00:21:43,280
b의 왼쪽 자식이 d라는 것을 알고 싶다면,
 

920
00:21:43,280 --> 00:21:45,750
b의 왼쪽 자식이 d라는 것을 알고 싶다면,
숫자 1이 주어졌을 때

921
00:21:45,750 --> 00:21:45,760
숫자 1이 주어졌을 때
 

922
00:21:45,760 --> 00:21:48,310
숫자 1이 주어졌을 때
숫자 3을 계산하려면

923
00:21:48,310 --> 00:21:48,320
숫자 3을 계산하려면
 

924
00:21:48,320 --> 00:21:51,669
숫자 3을 계산하려면
2를 더하면 됩니다. 모든 숫자는

925
00:21:51,669 --> 00:21:51,679
2를 더하면 됩니다. 모든 숫자는
 

926
00:21:51,679 --> 00:21:53,110
2를 더하면 됩니다. 모든 숫자는
3으로 곱해집니다. 1을 3으로 바꾸는 다양한 연산이 있지만

927
00:21:53,110 --> 00:21:54,870
3으로 곱해집니다. 1을 3으로 바꾸는 다양한 연산이 있지만
 

928
00:21:54,870 --> 00:21:55,590

 

929
00:21:55,590 --> 00:21:56,870

 

930
00:21:56,870 --> 00:21:56,880

 

931
00:21:56,880 --> 00:21:59,510

모든 경우에 적용되는 연산은 하나뿐입니다. 직관적으로 생각해 보면,

932
00:21:59,510 --> 00:21:59,520
모든 경우에 적용되는 연산은 하나뿐입니다. 직관적으로 생각해 보면,
 

933
00:21:59,520 --> 00:21:59,750
모든 경우에 적용되는 연산은 하나뿐입니다. 직관적으로 생각해 보면,

934
00:21:59,750 --> 00:21:59,760

 

935
00:21:59,760 --> 00:22:02,390

레벨 i에는 2의 i승 개의 노드가 있고,

936
00:22:02,390 --> 00:22:02,400
레벨 i에는 2의 i승 개의 노드가 있고,
 

937
00:22:02,400 --> 00:22:03,830
레벨 i에는 2의 i승 개의 노드가 있고,
자식

938
00:22:03,830 --> 00:22:03,840
자식
 

939
00:22:03,840 --> 00:22:05,909
자식
레벨로 이동하려면 2의 i승 + 1승 개의 노드가 있습니다.

940
00:22:05,909 --> 00:22:05,919
레벨로 이동하려면 2의 i승 + 1승 개의 노드가 있습니다.
 

941
00:22:05,919 --> 00:22:08,070
레벨로 이동하려면 2의 i승 + 1승 개의 노드가 있습니다.
바로 아래, 마지막 하나를 제외하고는 정확히 두 배입니다.

942
00:22:08,070 --> 00:22:08,080
바로 아래, 마지막 하나를 제외하고는 정확히 두 배입니다.
 

943
00:22:08,080 --> 00:22:09,830
바로 아래, 마지막 하나를 제외하고는 정확히 두 배입니다.
하지만

944
00:22:09,830 --> 00:22:09,840
하지만
 

945
00:22:09,840 --> 00:22:11,909
하지만
왼쪽 자식이 있다면

946
00:22:11,909 --> 00:22:11,919
왼쪽 자식이 있다면
 

947
00:22:11,919 --> 00:22:13,190
왼쪽 자식이 있다면
똑같이 동작하므로 큰 문제는 되지 않습니다.

948
00:22:13,190 --> 00:22:13,200
똑같이 동작하므로 큰 문제는 되지 않습니다.
 

949
00:22:13,200 --> 00:22:14,870
똑같이 동작하므로 큰 문제는 되지 않습니다.
직관적으로,

950
00:22:14,870 --> 00:22:14,880
직관적으로,
 

951
00:22:14,880 --> 00:22:16,789
직관적으로,
크기가 2인 공간을

952
00:22:16,789 --> 00:22:17,830
크기가 2인 공간을
 

953
00:22:17,830 --> 00:22:17,840

 

954
00:22:17,840 --> 00:22:20,710

i+1만큼의 스페이서 크기로 확장해야 하므로 2를 곱해야 합니다.

955
00:22:20,710 --> 00:22:20,720
i+1만큼의 스페이서 크기로 확장해야 하므로 2를 곱해야 합니다.
 

956
00:22:20,720 --> 00:22:22,149
i+1만큼의 스페이서 크기로 확장해야 하므로 2를 곱해야 합니다.

957
00:22:22,149 --> 00:22:22,159

 

958
00:22:22,159 --> 00:22:24,149

거의 맞지만,

959
00:22:24,149 --> 00:22:25,430
거의 맞지만,
 

960
00:22:25,430 --> 00:22:25,440

 

961
00:22:25,440 --> 00:22:29,350

상수가 있습니다. 2 곱하기 i라고 하고 싶지만,

962
00:22:29,350 --> 00:22:29,360
상수가 있습니다. 2 곱하기 i라고 하고 싶지만,
 

963
00:22:29,360 --> 00:22:32,230
상수가 있습니다. 2 곱하기 i라고 하고 싶지만,
여기 예시를 보면 1

964
00:22:32,230 --> 00:22:32,240
여기 예시를 보면 1
 

965
00:22:32,240 --> 00:22:33,270
여기 예시를 보면 1
곱하기 2는

966
00:22:33,270 --> 00:22:33,280
곱하기 2는
 

967
00:22:33,280 --> 00:22:37,190
곱하기 2는
2이고, 이는 3보다 1 작습니다. 2 곱하기 2는 4이고,

968
00:22:37,190 --> 00:22:37,200
2이고, 이는 3보다 1 작습니다. 2 곱하기 2는 4이고,
 

969
00:22:37,200 --> 00:22:38,710
2이고, 이는 3보다 1 작습니다. 2 곱하기 2는 4이고,
이는 5보다 1 작습니다. 거의 맞췄네요. 1 차이가 나는데, 아시다시피

970
00:22:38,710 --> 00:22:40,149
이는 5보다 1 작습니다. 거의 맞췄네요. 1 차이가 나는데, 아시다시피
 

971
00:22:40,149 --> 00:22:40,159

 

972
00:22:40,159 --> 00:22:43,110


973
00:22:43,110 --> 00:22:43,120

 

974
00:22:43,120 --> 00:22:46,470

인덱스 오류는

975
00:22:46,470 --> 00:22:46,480
인덱스 오류는
 

976
00:22:46,480 --> 00:22:47,750
인덱스 오류는
컴퓨터 과학에서 가장 흔한 오류 중 하나입니다. 그렇다면

977
00:22:47,750 --> 00:22:47,760
컴퓨터 과학에서 가장 흔한 오류 중 하나입니다. 그렇다면
 

978
00:22:47,760 --> 00:22:50,710
컴퓨터 과학에서 가장 흔한 오류 중 하나입니다. 그렇다면

979
00:22:50,710 --> 00:22:54,070

 

980
00:22:54,070 --> 00:22:54,080

 

981
00:22:54,080 --> 00:22:55,590

왼쪽 자식이 2i+1이라면 오른쪽 자식은 어떻게 될까요? 많은 사람들이

982
00:22:55,590 --> 00:22:59,350
왼쪽 자식이 2i+1이라면 오른쪽 자식은 어떻게 될까요? 많은 사람들이
 

983
00:22:59,350 --> 00:22:59,360

 

984
00:22:59,360 --> 00:23:03,270

2i+2라고 대답할 것 같은데, 이는

985
00:23:03,270 --> 00:23:03,280
2i+2라고 대답할 것 같은데, 이는
 

986
00:23:03,280 --> 00:23:04,789
2i+2라고 대답할 것 같은데, 이는
우리가

987
00:23:04,789 --> 00:23:04,799
우리가
 

988
00:23:04,799 --> 00:23:06,470
우리가
왼쪽에서 오른쪽으로 깊이 순서대로 작성하기 때문입니다.

989
00:23:06,470 --> 00:23:06,480
왼쪽에서 오른쪽으로 깊이 순서대로 작성하기 때문입니다.
 

990
00:23:06,480 --> 00:23:08,870
왼쪽에서 오른쪽으로 깊이 순서대로 작성하기 때문입니다.
오른쪽 자식은 왼쪽 자식의 오른쪽 형제이므로

991
00:23:08,870 --> 00:23:08,880
오른쪽 자식은 왼쪽 자식의 오른쪽 형제이므로
 

992
00:23:08,880 --> 00:23:10,390
오른쪽 자식은 왼쪽 자식의 오른쪽 형제이므로
1만큼 더 큽니다.

993
00:23:10,390 --> 00:23:10,400
1만큼 더 큽니다.
 

994
00:23:10,400 --> 00:23:13,909
1만큼 더 큽니다.
이러한 규칙을 따르면 부모

995
00:23:13,909 --> 00:23:13,919
이러한 규칙을 따르면 부모
 

996
00:23:13,919 --> 00:23:16,630
이러한 규칙을 따르면 부모
도 계산할 수 있습니다. 그냥 부모의 값이 무엇이든 간에 부모의 값이면 됩니다.

997
00:23:16,630 --> 00:23:16,640
도 계산할 수 있습니다. 그냥 부모의 값이 무엇이든 간에 부모의 값이면 됩니다.
 

998
00:23:16,640 --> 00:23:17,190
도 계산할 수 있습니다. 그냥 부모의 값이 무엇이든 간에 부모의 값이면 됩니다.

999
00:23:17,190 --> 00:23:18,549

 

1000
00:23:18,549 --> 00:23:18,559

 

1001
00:23:18,559 --> 00:23:20,830


1002
00:23:20,830 --> 00:23:20,840

 

1003
00:23:20,840 --> 00:23:23,990

제가 원하는 두 함수의 역함수를 구하고, 어떤 시점에서 2로 나누면 원래의 i를 얻을 수 있습니다. 즉,

1004
00:23:23,990 --> 00:23:24,000
제가 원하는 두 함수의 역함수를 구하고, 어떤 시점에서 2로 나누면 원래의 i를 얻을 수 있습니다. 즉,
 

1005
00:23:24,000 --> 00:23:24,789
제가 원하는 두 함수의 역함수를 구하고, 어떤 시점에서 2로 나누면 원래의 i를 얻을 수 있습니다. 즉,

1006
00:23:24,789 --> 00:23:26,789

 

1007
00:23:26,789 --> 00:23:26,799

 

1008
00:23:26,799 --> 00:23:29,350

2i + 1 또는 2i + 2가 주어졌을 때 i로 돌아가는 것입니다. 따라서

1009
00:23:29,350 --> 00:23:32,710
2i + 1 또는 2i + 2가 주어졌을 때 i로 돌아가는 것입니다. 따라서
 

1010
00:23:32,710 --> 00:23:32,720

 

1011
00:23:32,720 --> 00:23:35,750

i에서 1을 빼면

1012
00:23:35,750 --> 00:23:35,760
i에서 1을 빼면
 

1013
00:23:35,760 --> 00:23:38,230
i에서 1을 빼면
2i가 되고,

1014
00:23:38,230 --> 00:23:38,240
2i가 되고,
 

1015
00:23:38,240 --> 00:23:40,950
2i가 되고,
2로 나누면

1016
00:23:40,950 --> 00:23:40,960
2로 나누면
 

1017
00:23:40,960 --> 00:23:44,149
2로 나누면
원래의 i가 됩니다. 좀 더

1018
00:23:44,149 --> 00:23:44,950
원래의 i가 됩니다. 좀 더
 

1019
00:23:44,950 --> 00:23:44,960

 

1020
00:23:44,960 --> 00:23:48,390

명확하게 하기 위해 j라고 부르겠습니다. j는 왼쪽 또는 오른쪽

1021
00:23:48,390 --> 00:23:48,400
명확하게 하기 위해 j라고 부르겠습니다. j는 왼쪽 또는 오른쪽
 

1022
00:23:48,400 --> 00:23:49,350
명확하게 하기 위해 j라고 부르겠습니다. j는 왼쪽 또는 오른쪽
자식 노드입니다.

1023
00:23:49,350 --> 00:23:49,360
자식 노드입니다.
 

1024
00:23:49,360 --> 00:23:51,430
자식 노드입니다.
그러면 부모 노드인 i를 다시 복원할 수 있습니다.

1025
00:23:51,430 --> 00:23:51,440
그러면 부모 노드인 i를 다시 복원할 수 있습니다.
 

1026
00:23:51,440 --> 00:23:52,789
그러면 부모 노드인 i를 다시 복원할 수 있습니다.

1027
00:23:52,789 --> 00:23:52,799

 

1028
00:23:52,799 --> 00:23:54,950

이것은 상수

1029
00:23:54,950 --> 00:23:54,960
이것은 상수
 

1030
00:23:54,960 --> 00:23:56,870
이것은 상수
연산이므로

1031
00:23:56,870 --> 00:23:56,880
연산이므로
 

1032
00:23:56,880 --> 00:23:57,669
연산이므로

1033
00:23:57,669 --> 00:23:57,679

 

1034
00:23:57,679 --> 00:23:58,870

왼쪽 및 오른쪽 포인터를 저장할 필요 없이

1035
00:23:58,870 --> 00:23:58,880
왼쪽 및 오른쪽 포인터를 저장할 필요 없이
 

1036
00:23:58,880 --> 00:24:00,230
왼쪽 및 오른쪽 포인터를 저장할 필요 없이
필요할 때마다 계산할 수 있습니다. 예를 들어

1037
00:24:00,230 --> 00:24:00,240
필요할 때마다 계산할 수 있습니다. 예를 들어
 

1038
00:24:00,240 --> 00:24:03,029
필요할 때마다 계산할 수 있습니다. 예를 들어
노드 e에 있고 그 노드의

1039
00:24:03,029 --> 00:24:03,039
노드 e에 있고 그 노드의
 

1040
00:24:03,039 --> 00:24:04,870
노드 e에 있고 그 노드의
왼쪽 자식이 무엇인지 알고 싶다면,

1041
00:24:04,870 --> 00:24:06,070
왼쪽 자식이 무엇인지 알고 싶다면,
 

1042
00:24:06,070 --> 00:24:06,080

 

1043
00:24:06,080 --> 00:24:08,870

노드 인덱스 4(

1044
00:24:08,870 --> 00:24:08,880
노드 인덱스 4(
 

1045
00:24:08,880 --> 00:24:09,669
노드 인덱스 4(

1046
00:24:09,669 --> 00:24:09,679

 

1047
00:24:09,679 --> 00:24:11,830

e를 포함하는 노드)에서

1048
00:24:11,830 --> 00:24:11,840
e를 포함하는 노드)에서
 

1049
00:24:11,840 --> 00:24:13,430
e를 포함하는 노드)에서
왼쪽 자식을 알고 싶을 때 2를 곱하고

1050
00:24:13,430 --> 00:24:13,440
왼쪽 자식을 알고 싶을 때 2를 곱하고
 

1051
00:24:13,440 --> 00:24:14,710
왼쪽 자식을 알고 싶을 때 2를 곱하고
1을 더하면 9가 됩니다.

1052
00:24:14,710 --> 00:24:14,720
1을 더하면 9가 됩니다.
 

1053
00:24:14,720 --> 00:24:16,470
1을 더하면 9가 됩니다.
그런 다음 배열의 9번째 위치에 있는 노드를 인덱싱할 수 있습니다.

1054
00:24:16,470 --> 00:24:17,990
그런 다음 배열의 9번째 위치에 있는 노드를 인덱싱할 수 있습니다.
 

1055
00:24:17,990 --> 00:24:18,000

 

1056
00:24:18,000 --> 00:24:20,470

이것은 단지 제 머릿속 생각일 뿐입니다.

1057
00:24:20,470 --> 00:24:21,909
이것은 단지 제 머릿속 생각일 뿐입니다.
 

1058
00:24:21,909 --> 00:24:21,919

 

1059
00:24:21,919 --> 00:24:22,549

여기 트리가 있지만

1060
00:24:22,549 --> 00:24:22,559
여기 트리가 있지만
 

1061
00:24:22,559 --> 00:24:24,470
여기 트리가 있지만
실제 컴퓨터에서는

1062
00:24:24,470 --> 00:24:24,480
실제 컴퓨터에서는
 

1063
00:24:24,480 --> 00:24:26,149
실제 컴퓨터에서는
배열일 뿐입니다.

1064
00:24:26,149 --> 00:24:26,159
배열일 뿐입니다.
 

1065
00:24:26,159 --> 00:24:28,950
배열일 뿐입니다.
그래서 e에서 j로 가려면

1066
00:24:28,950 --> 00:24:28,960
그래서 e에서 j로 가려면
 

1067
00:24:28,960 --> 00:24:30,149
그래서 e에서 j로 가려면
4에서 9로 갈 수 있습니다.

1068
00:24:30,149 --> 00:24:30,159
4에서 9로 갈 수 있습니다.
 

1069
00:24:30,159 --> 00:24:32,230
4에서 9로 갈 수 있습니다.
오른쪽 자식으로 가려면

1070
00:24:32,230 --> 00:24:32,240
오른쪽 자식으로 가려면
 

1071
00:24:32,240 --> 00:24:33,510
오른쪽 자식으로 가려면
2를 곱하고

1072
00:24:33,510 --> 00:24:33,520
2를 곱하고
 

1073
00:24:33,520 --> 00:24:36,710
2를 곱하고
8을 더하고 2를 더하고 10을 더합니다. 그러면 10은

1074
00:24:36,710 --> 00:24:36,720
8을 더하고 2를 더하고 10을 더합니다. 그러면 10은
 

1075
00:24:36,720 --> 00:24:37,669
8을 더하고 2를 더하고 10을 더합니다. 그러면 10은
배열의 끝을 넘어섰다는 것을 알 수 있습니다.

1076
00:24:37,669 --> 00:24:37,679
배열의 끝을 넘어섰다는 것을 알 수 있습니다.
 

1077
00:24:37,679 --> 00:24:39,430
배열의 끝을 넘어섰다는 것을 알 수 있습니다.
하지만 배열은 크기를 저장하므로

1078
00:24:39,430 --> 00:24:39,440
하지만 배열은 크기를 저장하므로
 

1079
00:24:39,440 --> 00:24:41,909
하지만 배열은 크기를 저장하므로
e에는 오른쪽 자식이 없다는 것을 알 수 있습니다.

1080
00:24:41,909 --> 00:24:41,919
e에는 오른쪽 자식이 없다는 것을 알 수 있습니다.
 

1081
00:24:41,919 --> 00:24:43,590
e에는 오른쪽 자식이 없다는 것을 알 수 있습니다.
이것은

1082
00:24:43,590 --> 00:24:43,600
이것은
 

1083
00:24:43,600 --> 00:24:45,830
이것은
완전 이진 트리에서만 가능한 일입니다. 일반 이진

1084
00:24:45,830 --> 00:24:45,840
완전 이진 트리에서만 가능한 일입니다. 일반 이진
 

1085
00:24:45,840 --> 00:24:46,950
완전 이진 트리에서만 가능한 일입니다. 일반 이진
트리에서는 이러한 속성이 없습니다.

1086
00:24:46,950 --> 00:24:46,960
트리에서는 이러한 속성이 없습니다.
 

1087
00:24:46,960 --> 00:24:49,669
트리에서는 이러한 속성이 없습니다.

1088
00:24:49,669 --> 00:24:49,679

 

1089
00:24:49,679 --> 00:24:53,269

좋습니다. 이것은 기본적으로

1090
00:24:53,269 --> 00:24:53,279
좋습니다. 이것은 기본적으로
 

1091
00:24:53,279 --> 00:24:55,350
좋습니다. 이것은 기본적으로
힙입니다. 이제 힙 속성이라는 속성을 하나 더 추가해야 합니다.

1092
00:24:55,350 --> 00:24:55,360
힙입니다. 이제 힙 속성이라는 속성을 하나 더 추가해야 합니다.
 

1093
00:24:55,360 --> 00:24:58,310
힙입니다. 이제 힙 속성이라는 속성을 하나 더 추가해야 합니다.

1094
00:24:58,310 --> 00:25:04,789

 

1095
00:25:04,789 --> 00:25:08,070

 

1096
00:25:08,070 --> 00:25:08,080

 

1097
00:25:08,080 --> 00:25:10,149

힙에는 여러 유형이 있는데, 이 유형은

1098
00:25:10,149 --> 00:25:10,159
힙에는 여러 유형이 있는데, 이 유형은
 

1099
00:25:10,159 --> 00:25:11,669
힙에는 여러 유형이 있는데, 이 유형은
이진 힙이라고 합니다.

1100
00:25:11,669 --> 00:25:11,679
이진 힙이라고 합니다.
 

1101
00:25:11,679 --> 00:25:13,269
이진 힙이라고 합니다.
다른 유형의 힙에 대해서는 앞으로

1102
00:25:13,269 --> 00:25:13,279
다른 유형의 힙에 대해서는 앞으로
 

1103
00:25:13,279 --> 00:25:15,350
다른 유형의 힙에 대해서는 앞으로
강의에서 다루겠습니다. 이것을

1104
00:25:15,350 --> 00:25:15,360
강의에서 다루겠습니다. 이것을
 

1105
00:25:15,360 --> 00:25:21,190
강의에서 다루겠습니다. 이것을
q라고 하겠습니다.

1106
00:25:21,190 --> 00:25:27,430

 

1107
00:25:27,430 --> 00:25:27,440

 

1108
00:25:27,440 --> 00:25:30,549

명확하게 써야겠네요. 이것은

1109
00:25:30,549 --> 00:25:30,559
명확하게 써야겠네요. 이것은
 

1110
00:25:30,559 --> 00:25:48,230
명확하게 써야겠네요. 이것은
완전 이진 트리를 나타내는 배열입니다.

1111
00:25:48,230 --> 00:25:48,240

 

1112
00:25:48,240 --> 00:25:51,909

배열을 q라고 하고,

1113
00:25:51,909 --> 00:25:51,919
배열을 q라고 하고,
 

1114
00:25:51,919 --> 00:25:56,789
배열을 q라고 하고,
모든 노드가

1115
00:25:56,789 --> 00:26:02,230
모든 노드가
 

1116
00:26:02,230 --> 00:26:02,240

 

1117
00:26:02,240 --> 00:26:16,710

소위 최대 힙 속성을 만족해야 합니다.

1118
00:26:16,710 --> 00:26:16,720

 

1119
00:26:16,720 --> 00:26:20,070

즉, i의 q는 i의

1120
00:26:20,070 --> 00:26:24,230
즉, i의 q는 i의
 

1121
00:26:24,230 --> 00:26:24,240

 

1122
00:26:24,240 --> 00:26:28,710

왼쪽 자식과 오른쪽 자식 모두에 대해 j의 q보다 크거나 같아야 합니다. 자,

1123
00:26:28,710 --> 00:26:36,710
왼쪽 자식과 오른쪽 자식 모두에 대해 j의 q보다 크거나 같아야 합니다. 자,
 

1124
00:26:36,710 --> 00:26:36,720

 

1125
00:26:36,720 --> 00:26:40,470

노드

1126
00:26:40,470 --> 00:26:40,480
노드
 

1127
00:26:40,480 --> 00:26:44,630
노드
i에는 두 개의 자식이 있습니다.  자식 노드

1128
00:26:44,630 --> 00:26:44,640
i에는 두 개의 자식이 있습니다.  자식 노드
 

1129
00:26:44,640 --> 00:26:48,149
i에는 두 개의 자식이 있습니다.  자식 노드
2 i + 1과 2 i + 2는

1130
00:26:48,149 --> 00:26:48,159
2 i + 1과 2 i + 2는
 

1131
00:26:48,159 --> 00:26:53,190
2 i + 1과 2 i + 2는
j의 두 값입니다.

1132
00:26:53,190 --> 00:26:53,200
j의 두 값입니다.
 

1133
00:26:53,200 --> 00:26:56,070
j의 두 값입니다.
우리가 원하는 것은 크거나 같다는

1134
00:26:56,070 --> 00:26:56,630
우리가 원하는 것은 크거나 같다는
 

1135
00:26:56,630 --> 00:26:56,640

 

1136
00:26:56,640 --> 00:26:59,669

관계입니다.

1137
00:26:59,669 --> 00:26:59,679
관계입니다.
 

1138
00:26:59,679 --> 00:27:01,190
관계입니다.
즉, 이 노드는

1139
00:27:01,190 --> 00:27:01,200
즉, 이 노드는
 

1140
00:27:01,200 --> 00:27:02,710
즉, 이 노드는
이 노드와 이 노드 모두보다 커야 합니다. 이 중 어느 것이 더 큰가요?

1141
00:27:02,710 --> 00:27:02,720
이 노드와 이 노드 모두보다 커야 합니다. 이 중 어느 것이 더 큰가요?
 

1142
00:27:02,720 --> 00:27:03,750
이 노드와 이 노드 모두보다 커야 합니다. 이 중 어느 것이 더 큰가요?
더 큰 노드가 무엇인지는

1143
00:27:03,750 --> 00:27:03,760
더 큰 노드가 무엇인지는
 

1144
00:27:03,760 --> 00:27:06,470
더 큰 노드가 무엇인지는
모르고, 신경도 쓰지 않습니다.

1145
00:27:06,470 --> 00:27:07,350
모르고, 신경도 쓰지 않습니다.
 

1146
00:27:07,350 --> 00:27:07,360

 

1147
00:27:07,360 --> 00:27:09,669

이진 탐색 트리나 집합 이진 트리와는 매우 다릅니다. 이진 탐색 트리에서는

1148
00:27:09,669 --> 00:27:10,549
이진 탐색 트리나 집합 이진 트리와는 매우 다릅니다. 이진 탐색 트리에서는
 

1149
00:27:10,549 --> 00:27:10,559

 

1150
00:27:10,559 --> 00:27:12,070

이 노드가 저 노드보다 작거나 같다고 했고, 집합 이진

1151
00:27:12,070 --> 00:27:14,070
이 노드가 저 노드보다 작거나 같다고 했고, 집합 이진
 

1152
00:27:14,070 --> 00:27:14,080

 

1153
00:27:14,080 --> 00:27:15,510

트리에서는 저 노드가 트리의 모든 노드보다 작거나 같다고 했습니다. 하지만 여기서는

1154
00:27:15,510 --> 00:27:15,520
트리에서는 저 노드가 트리의 모든 노드보다 작거나 같다고 했습니다. 하지만 여기서는
 

1155
00:27:15,520 --> 00:27:16,630
트리에서는 저 노드가 트리의 모든 노드보다 작거나 같다고 했습니다. 하지만 여기서는
단순히

1156
00:27:16,630 --> 00:27:16,640
단순히
 

1157
00:27:16,640 --> 00:27:17,990
단순히
이 노드가

1158
00:27:17,990 --> 00:27:18,000
이 노드가
 

1159
00:27:18,000 --> 00:27:20,549
이 노드가
저 노드와 저 노드보다 크거나 같다고 국소적으로 말하는 것입니다. 따라서

1160
00:27:20,549 --> 00:27:20,559
저 노드와 저 노드보다 크거나 같다고 국소적으로 말하는 것입니다. 따라서
 

1161
00:27:20,559 --> 00:27:24,149
저 노드와 저 노드보다 크거나 같다고 국소적으로 말하는 것입니다. 따라서
가장 큰 노드는 맨 위에 있습니다. 자,

1162
00:27:24,149 --> 00:27:28,149

 

1163
00:27:28,149 --> 00:27:28,159

 

1164
00:27:28,159 --> 00:27:32,269

이 힙에 대한 흥미로운 정리가 하나 있습니다.

1165
00:27:32,269 --> 00:27:32,279
이 힙에 대한 흥미로운 정리가 하나 있습니다.
 

1166
00:27:32,279 --> 00:27:34,789
이 힙에 대한 흥미로운 정리가 하나 있습니다.
좀 이상하게 들릴 수도 있지만,

1167
00:27:34,789 --> 00:27:34,799
좀 이상하게 들릴 수도 있지만,
 

1168
00:27:34,799 --> 00:27:36,549
좀 이상하게 들릴 수도 있지만,

1169
00:27:36,549 --> 00:27:36,559

 

1170
00:27:36,559 --> 00:27:38,549

직관적으로 이해하기 쉽게 설명하자면, 이진 힙에서

1171
00:27:38,549 --> 00:27:38,559
직관적으로 이해하기 쉽게 설명하자면, 이진 힙에서
 

1172
00:27:38,559 --> 00:27:40,470
직관적으로 이해하기 쉽게 설명하자면, 이진 힙에서
최대 힙 속성을 모든 곳에서 만족한다면,

1173
00:27:40,470 --> 00:27:40,480
최대 힙 속성을 모든 곳에서 만족한다면,
 

1174
00:27:40,480 --> 00:27:44,710
최대 힙 속성을 모든 곳에서 만족한다면,
모든 노드 i는 그 하위 트리

1175
00:27:44,710 --> 00:27:44,720
모든 노드 i는 그 하위 트리
 

1176
00:27:44,720 --> 00:27:47,510
모든 노드 i는 그 하위 트리
에 있는 모든 노드보다 크거나 같다는 것을 알 수 있습니다.

1177
00:27:47,510 --> 00:27:47,520
에 있는 모든 노드보다 크거나 같다는 것을 알 수 있습니다.
 

1178
00:27:47,520 --> 00:27:49,190
에 있는 모든 노드보다 크거나 같다는 것을 알 수 있습니다.
이것들을

1179
00:27:49,190 --> 00:27:49,200
이것들을
 

1180
00:27:49,200 --> 00:27:53,830
이것들을

1181
00:27:53,830 --> 00:27:53,840

 

1182
00:27:53,840 --> 00:27:59,830

i의 자손 노드와 하위 트리라고 부릅니다.

1183
00:27:59,830 --> 00:27:59,840

 

1184
00:27:59,840 --> 00:28:03,110

예를 들어 보겠습니다.

1185
00:28:03,110 --> 00:28:03,120
예를 들어 보겠습니다.
 

1186
00:28:03,120 --> 00:28:04,710
예를 들어 보겠습니다.
여기에 숫자는 쓰지 않았지만,

1187
00:28:04,710 --> 00:28:06,470
여기에 숫자는 쓰지 않았지만,
 

1188
00:28:06,470 --> 00:28:06,480

 

1189
00:28:06,480 --> 00:28:09,190

a는

1190
00:28:09,190 --> 00:28:09,200
a는
 

1191
00:28:09,200 --> 00:28:09,669
a는
b

1192
00:28:09,669 --> 00:28:09,679
b
 

1193
00:28:09,679 --> 00:28:12,070
b
와 c 모두보다 크거나 같고, b는 d

1194
00:28:12,070 --> 00:28:12,080
와 c 모두보다 크거나 같고, b는 d
 

1195
00:28:12,080 --> 00:28:12,789
와 c 모두보다 크거나 같고, b는 d
와 e보다 크거나 같고,

1196
00:28:12,789 --> 00:28:12,799
와 e보다 크거나 같고,
 

1197
00:28:12,799 --> 00:28:14,230
와 e보다 크거나 같고,
c는 f와 g보다 크거나 같고,

1198
00:28:14,230 --> 00:28:14,240
c는 f와 g보다 크거나 같고,
 

1199
00:28:14,240 --> 00:28:16,149
c는 f와 g보다 크거나 같고,
d는 h와 i보다 크고,

1200
00:28:16,149 --> 00:28:16,159
d는 h와 i보다 크고,
 

1201
00:28:16,159 --> 00:28:17,510
d는 h와 i보다 크고,
e는 j보다 크다고 상상해 보세요. 이렇게 되면

1202
00:28:17,510 --> 00:28:17,520
e는 j보다 크다고 상상해 보세요. 이렇게 되면
 

1203
00:28:17,520 --> 00:28:19,909
e는 j보다 크다고 상상해 보세요. 이렇게 되면
이 구조는

1204
00:28:19,909 --> 00:28:19,919
이 구조는
 

1205
00:28:19,919 --> 00:28:23,430
이 구조는
완전 이진 트리가 아니라 힙이 됩니다.

1206
00:28:23,430 --> 00:28:23,440

 

1207
00:28:23,440 --> 00:28:25,269

그렇다면 이것은 무엇을 의미할까요?  이는 a가 최댓값이어야 함을 의미합니다.

1208
00:28:25,269 --> 00:28:27,029
그렇다면 이것은 무엇을 의미할까요?  이는 a가 최댓값이어야 함을 의미합니다.
 

1209
00:28:27,029 --> 00:28:27,039

 

1210
00:28:27,039 --> 00:28:30,149

따라서 여기 있는 어떤 노드 j를 보더라도 a는

1211
00:28:30,149 --> 00:28:30,159
따라서 여기 있는 어떤 노드 j를 보더라도 a는
 

1212
00:28:30,159 --> 00:28:31,029
따라서 여기 있는 어떤 노드 j를 보더라도 a는
b보다 크거나 같고, b는

1213
00:28:31,029 --> 00:28:31,039
b보다 크거나 같고, b는
 

1214
00:28:31,039 --> 00:28:32,470
b보다 크거나 같고, b는
e보다 크거나 같으며, e는 j보다 크거나 같습니다.

1215
00:28:32,470 --> 00:28:34,310
e보다 크거나 같으며, e는 j보다 크거나 같습니다.
 

1216
00:28:34,310 --> 00:28:34,320

 

1217
00:28:34,320 --> 00:28:36,230

일반적으로 우리가 말하는 것은

1218
00:28:36,230 --> 00:28:36,240
일반적으로 우리가 말하는 것은
 

1219
00:28:36,240 --> 00:28:37,510
일반적으로 우리가 말하는 것은
a가

1220
00:28:37,510 --> 00:28:37,520
a가
 

1221
00:28:37,520 --> 00:28:39,190
a가
트리의 모든 노드보다 크고, b는

1222
00:28:39,190 --> 00:28:39,200
트리의 모든 노드보다 크고, b는
 

1223
00:28:39,200 --> 00:28:41,110
트리의 모든 노드보다 크고, b는
하위 트리의 모든 노드보다 크고,

1224
00:28:41,110 --> 00:28:42,230
하위 트리의 모든 노드보다 크고,
 

1225
00:28:42,230 --> 00:28:42,240

 

1226
00:28:42,240 --> 00:28:43,510

c는 하위 트리의 모든 노드보다 크거나 같다는 것입니다.

1227
00:28:43,510 --> 00:28:43,520
c는 하위 트리의 모든 노드보다 크거나 같다는 것입니다.
 

1228
00:28:43,520 --> 00:28:45,750
c는 하위 트리의 모든 노드보다 크거나 같다는 것입니다.
이것이 이 보조정리가

1229
00:28:45,750 --> 00:28:45,760
이것이 이 보조정리가
 

1230
00:28:45,760 --> 00:28:47,110
이것이 이 보조정리가
말하는 바입니다.

1231
00:28:47,110 --> 00:28:47,120
말하는 바입니다.
 

1232
00:28:47,120 --> 00:28:50,710
말하는 바입니다.
이 보조정리는 귀납법으로 증명할 수 있지만, 사실 매우

1233
00:28:50,710 --> 00:28:50,720
이 보조정리는 귀납법으로 증명할 수 있지만, 사실 매우
 

1234
00:28:50,720 --> 00:28:55,190
이 보조정리는 귀납법으로 증명할 수 있지만, 사실 매우
간단합니다.

1235
00:28:55,190 --> 00:28:55,200

 

1236
00:28:55,200 --> 00:28:57,269

두 노드 i와 j가 있고 j가

1237
00:28:57,269 --> 00:28:57,279
두 노드 i와 j가 있고 j가
 

1238
00:28:57,279 --> 00:28:58,630
두 노드 i와 j가 있고 j가
하위 트리에 있다면

1239
00:28:58,630 --> 00:29:01,510
하위 트리에 있다면
 

1240
00:29:01,510 --> 00:29:01,520

 

1241
00:29:01,520 --> 00:29:01,909


1242
00:29:01,909 --> 00:29:01,919

 

1243
00:29:01,919 --> 00:29:05,350

i에서 j로 향하는 하향 경로가 있다는 뜻입니다. 하향 경로를 따라 이동하는 모든 간선에 대해

1244
00:29:05,350 --> 00:29:07,430
i에서 j로 향하는 하향 경로가 있다는 뜻입니다. 하향 경로를 따라 이동하는 모든 간선에 대해
 

1245
00:29:07,430 --> 00:29:07,440

 

1246
00:29:07,440 --> 00:29:10,389

자식 노드가

1247
00:29:10,389 --> 00:29:11,990
자식 노드가
 

1248
00:29:11,990 --> 00:29:12,000

 

1249
00:29:12,000 --> 00:29:13,669

부모 노드보다 작거나 같으므로, i는 j보다 크거나 같고, j는

1250
00:29:13,669 --> 00:29:14,870
부모 노드보다 작거나 같으므로, i는 j보다 크거나 같고, j는
 

1251
00:29:14,870 --> 00:29:15,830

 

1252
00:29:15,830 --> 00:29:15,840

 

1253
00:29:15,840 --> 00:29:17,430

j보다 크거나 같습니다.

1254
00:29:17,430 --> 00:29:17,440
j보다 크거나 같습니다.
 

1255
00:29:17,440 --> 00:29:20,710
j보다 크거나 같습니다.
따라서 '작거나 같음'의 전이성에 의해

1256
00:29:20,710 --> 00:29:21,669
따라서 '작거나 같음'의 전이성에 의해
 

1257
00:29:21,669 --> 00:29:21,679

 

1258
00:29:21,679 --> 00:29:23,590

i는 j보다 크거나 같다는 것을 알 수 있습니다. 즉,

1259
00:29:23,590 --> 00:29:25,510
i는 j보다 크거나 같다는 것을 알 수 있습니다. 즉,
 

1260
00:29:25,510 --> 00:29:25,520

 

1261
00:29:25,520 --> 00:29:27,830

i의 키는 j의 키보다 크거나 같습니다. 이것이 바로 이 보조정리의 의미입니다.

1262
00:29:27,830 --> 00:29:28,789
i의 키는 j의 키보다 크거나 같습니다. 이것이 바로 이 보조정리의 의미입니다.
 

1263
00:29:28,789 --> 00:29:28,799

 

1264
00:29:28,799 --> 00:29:30,710

우리는 i를 인덱스라고 부르고,

1265
00:29:30,710 --> 00:29:30,720
우리는 i를 인덱스라고 부르고,
 

1266
00:29:30,720 --> 00:29:32,549
우리는 i를 인덱스라고 부르고,
이것을

1267
00:29:32,549 --> 00:29:32,559
이것을
 

1268
00:29:32,559 --> 00:29:36,149
이것을
i의 q라고 부릅니다. 이것은 인덱스 j

1269
00:29:36,149 --> 00:29:36,159
i의 q라고 부릅니다. 이것은 인덱스 j
 

1270
00:29:36,159 --> 00:29:39,510
i의 q라고 부릅니다. 이것은 인덱스 j
의 q입니다.

1271
00:29:39,510 --> 00:29:43,430

 

1272
00:29:43,430 --> 00:29:43,440

 

1273
00:29:43,440 --> 00:29:46,549

트리에서 키를 구성하는 매우 다른 방법이지만,

1274
00:29:46,549 --> 00:29:46,559
트리에서 키를 구성하는 매우 다른 방법이지만,
 

1275
00:29:46,559 --> 00:29:49,190
트리에서 키를 구성하는 매우 다른 방법이지만,
예상할 수 있듯이 우선

1276
00:29:49,190 --> 00:29:49,200
예상할 수 있듯이 우선
 

1277
00:29:49,200 --> 00:29:50,710
예상할 수 있듯이 우선
순위 큐에 적합합니다.

1278
00:29:50,710 --> 00:29:50,720
순위 큐에 적합합니다.
 

1279
00:29:50,720 --> 00:29:52,549
순위 큐에 적합합니다.
우선순위 큐는

1280
00:29:52,549 --> 00:29:52,559
우선순위 큐는
 

1281
00:29:52,559 --> 00:29:54,310
우선순위 큐는
가장 큰 요소를 찾기만 하면 되기 때문입니다. 그런

1282
00:29:54,310 --> 00:29:54,320
가장 큰 요소를 찾기만 하면 되기 때문입니다. 그런
 

1283
00:29:54,320 --> 00:29:55,909
가장 큰 요소를 찾기만 하면 되기 때문입니다. 그런
다음 해당 요소를 삭제해야 하는데, 이는 더

1284
00:29:55,909 --> 00:29:55,919
다음 해당 요소를 삭제해야 하는데, 이는 더
 

1285
00:29:55,919 --> 00:29:57,110
다음 해당 요소를 삭제해야 하는데, 이는 더
어렵습니다. 루트 노드를 삭제하는 것이 직관적으로

1286
00:29:57,110 --> 00:29:57,120
어렵습니다. 루트 노드를 삭제하는 것이 직관적으로
 

1287
00:29:57,120 --> 00:29:59,110
어렵습니다. 루트 노드를 삭제하는 것이 직관적으로
가장 어렵기 때문입니다.

1288
00:29:59,110 --> 00:29:59,120
가장 어렵기 때문입니다.
 

1289
00:29:59,120 --> 00:30:00,789
가장 어렵기 때문입니다.
직관적으로 리프 노드를

1290
00:30:00,789 --> 00:30:00,799
직관적으로 리프 노드를
 

1291
00:30:00,799 --> 00:30:03,430
직관적으로 리프 노드를
삭제하는 것이 더 좋겠지만,

1292
00:30:03,430 --> 00:30:03,440
삭제하는 것이 더 좋겠지만,
 

1293
00:30:03,440 --> 00:30:05,190
삭제하는 것이 더 좋겠지만,
리프 노드를 삭제

1294
00:30:05,190 --> 00:30:05,200
리프 노드를 삭제
 

1295
00:30:05,200 --> 00:30:06,950
리프 노드를 삭제
하면서 완전 이진 트리를 유지하는 것은

1296
00:30:06,950 --> 00:30:06,960
하면서 완전 이진 트리를 유지하는 것은
 

1297
00:30:06,960 --> 00:30:08,310
하면서 완전 이진 트리를 유지하는 것은
실제로 어렵습니다.

1298
00:30:08,310 --> 00:30:08,320
실제로 어렵습니다.
 

1299
00:30:08,320 --> 00:30:10,870
실제로 어렵습니다.
h를 삭제하면 더 이상

1300
00:30:10,870 --> 00:30:10,880
h를 삭제하면 더 이상
 

1301
00:30:10,880 --> 00:30:12,149
h를 삭제하면 더 이상
이진 트리처럼 보이지 않거나

1302
00:30:12,149 --> 00:30:12,159
이진 트리처럼 보이지 않거나
 

1303
00:30:12,159 --> 00:30:13,269
이진 트리처럼 보이지 않거나
완전 이진 트리처럼 보이지 않습니다. 왼쪽 정렬이 되어 있지

1304
00:30:13,269 --> 00:30:13,279
완전 이진 트리처럼 보이지 않습니다. 왼쪽 정렬이 되어 있지
 

1305
00:30:13,279 --> 00:30:14,549
완전 이진 트리처럼 보이지 않습니다. 왼쪽 정렬이 되어 있지
않기 때문입니다.

1306
00:30:14,549 --> 00:30:14,559
않기 때문입니다.
 

1307
00:30:14,559 --> 00:30:16,389
않기 때문입니다.

1308
00:30:16,389 --> 00:30:16,399

 

1309
00:30:16,399 --> 00:30:17,990

마찬가지로 f를 삭제하는 것도

1310
00:30:17,990 --> 00:30:18,000
마찬가지로 f를 삭제하는 것도
 

1311
00:30:18,000 --> 00:30:20,149
마찬가지로 f를 삭제하는 것도
좋지 않습니다. 이제 여기에 네 개의 노드가 남지 않기 때문입니다.

1312
00:30:20,149 --> 00:30:21,830
좋지 않습니다. 이제 여기에 네 개의 노드가 남지 않기 때문입니다.
 

1313
00:30:21,830 --> 00:30:21,840

 

1314
00:30:21,840 --> 00:30:24,470

삭제하기 쉬운 노드는 j입니다. j를

1315
00:30:24,470 --> 00:30:24,480
삭제하기 쉬운 노드는 j입니다. j를
 

1316
00:30:24,480 --> 00:30:26,070
삭제하기 쉬운 노드는 j입니다. j를
제거해도 여전히

1317
00:30:26,070 --> 00:30:26,080
제거해도 여전히
 

1318
00:30:26,080 --> 00:30:28,870
제거해도 여전히
완전 트리가 유지됩니다.

1319
00:30:28,870 --> 00:30:28,880
완전 트리가 유지됩니다.
 

1320
00:30:28,880 --> 00:30:31,990
완전 트리가 유지됩니다.
배열의 마지막 위치, 즉 마지막 리프 노드가

1321
00:30:31,990 --> 00:30:32,000
배열의 마지막 위치, 즉 마지막 리프 노드가
 

1322
00:30:32,000 --> 00:30:33,029
배열의 마지막 위치, 즉 마지막 리프 노드가
삭제하기 쉽습니다.

1323
00:30:33,029 --> 00:30:33,039
삭제하기 쉽습니다.
 

1324
00:30:33,039 --> 00:30:34,470
삭제하기 쉽습니다.
배열은 마지막 항목을 삭제하는 데 유리하기 때문입니다.

1325
00:30:34,470 --> 00:30:36,230
배열은 마지막 항목을 삭제하는 데 유리하기 때문입니다.
 

1326
00:30:36,230 --> 00:30:36,240

 

1327
00:30:36,240 --> 00:30:38,630

하지만 제가 여기서 설정한 방식은 찾기 쉽게 되어 있습니다.

1328
00:30:38,630 --> 00:30:40,549
하지만 제가 여기서 설정한 방식은 찾기 쉽게 되어 있습니다.
 

1329
00:30:40,549 --> 00:30:40,559

 

1330
00:30:40,559 --> 00:30:41,510

루트에 있는

1331
00:30:41,510 --> 00:30:43,990
루트에 있는
 

1332
00:30:43,990 --> 00:30:44,000

 

1333
00:30:44,000 --> 00:30:45,750

키를 삭제하는 건 귀찮은 일이라서, 어떻게든 그 키를 마지막 리프 노드의

1334
00:30:45,750 --> 00:30:45,760
키를 삭제하는 건 귀찮은 일이라서, 어떻게든 그 키를 마지막 리프 노드의
 

1335
00:30:45,760 --> 00:30:48,710
키를 삭제하는 건 귀찮은 일이라서, 어떻게든 그 키를 마지막 리프 노드의
마지막 위치로 옮기고 싶어요.

1336
00:30:48,710 --> 00:30:50,389
마지막 위치로 옮기고 싶어요.
 

1337
00:30:50,389 --> 00:30:50,399

 

1338
00:30:50,399 --> 00:30:51,750

왜냐하면 마지막 리프 노드가 삭제하기 가장 쉽기 때문이죠.

1339
00:30:51,750 --> 00:30:51,760
왜냐하면 마지막 리프 노드가 삭제하기 가장 쉽기 때문이죠.
 

1340
00:30:51,760 --> 00:30:53,430
왜냐하면 마지막 리프 노드가 삭제하기 가장 쉽기 때문이죠.

1341
00:30:53,430 --> 00:30:54,950

 

1342
00:30:54,950 --> 00:30:57,269

 

1343
00:30:57,269 --> 00:30:57,279

 

1344
00:30:57,279 --> 00:30:59,509

네, 바로 그게 우리가 삭제 알고리즘에서 할 일입니다. 먼저 삽입부터 해볼게요. 삽입은 조금 더 간단하고 방금

1345
00:30:59,509 --> 00:31:05,430
네, 바로 그게 우리가 삭제 알고리즘에서 할 일입니다. 먼저 삽입부터 해볼게요. 삽입은 조금 더 간단하고 방금
 

1346
00:31:05,430 --> 00:31:07,080

 

1347
00:31:07,080 --> 00:31:07,090

 

1348
00:31:07,090 --> 00:31:09,750


1349
00:31:09,750 --> 00:31:09,760

 

1350
00:31:09,760 --> 00:31:11,830

설명한 것과 대칭적인 것 같아요. [박수]

1351
00:31:11,830 --> 00:31:11,840
설명한 것과 대칭적인 것 같아요. [박수]
 

1352
00:31:11,840 --> 00:31:13,509
설명한 것과 대칭적인 것 같아요. [박수]
키

1353
00:31:13,509 --> 00:31:13,519
키
 

1354
00:31:13,519 --> 00:31:16,549
키
또는 특정 키를 가진 항목 x를 삽입하고 싶다고 가정해 봅시다.

1355
00:31:16,549 --> 00:31:19,990
또는 특정 키를 가진 항목 x를 삽입하고 싶다고 가정해 봅시다.
 

1356
00:31:19,990 --> 00:31:20,000

 

1357
00:31:20,000 --> 00:31:22,149

배열에서 새 항목을 추가하려면 항상 끝에 추가해야 합니다.

1358
00:31:22,149 --> 00:31:23,430
배열에서 새 항목을 추가하려면 항상 끝에 추가해야 합니다.
 

1359
00:31:23,430 --> 00:31:24,870

 

1360
00:31:24,870 --> 00:31:24,880

 

1361
00:31:24,880 --> 00:31:26,630

이것을 '

1362
00:31:26,630 --> 00:31:26,640
이것을 '
 

1363
00:31:26,640 --> 00:31:33,909
이것을 '
마지막 삽입'이라고 하는데,

1364
00:31:33,909 --> 00:31:33,919

 

1365
00:31:33,919 --> 00:31:37,190

이는

1366
00:31:37,190 --> 00:31:37,200
이는
 

1367
00:31:37,200 --> 00:31:37,830
이는

1368
00:31:37,830 --> 00:31:41,029

 

1369
00:31:41,029 --> 00:31:41,039

 

1370
00:31:41,039 --> 00:31:43,669

이진 트리의 맨 마지막 레벨에 항목 x를 포함하는 노드를 추가하는 것과 같습니다.

1371
00:31:43,669 --> 00:31:44,789
이진 트리의 맨 마지막 레벨에 항목 x를 포함하는 노드를 추가하는 것과 같습니다.
 

1372
00:31:44,789 --> 00:31:46,070

 

1373
00:31:46,070 --> 00:31:46,080

 

1374
00:31:46,080 --> 00:31:47,990

기존 노드들의 오른쪽에 추가되거나 새로운 레벨을 시작하지만,

1375
00:31:47,990 --> 00:31:48,000
기존 노드들의 오른쪽에 추가되거나 새로운 레벨을 시작하지만,
 

1376
00:31:48,000 --> 00:31:49,350
기존 노드들의 오른쪽에 추가되거나 새로운 레벨을 시작하지만,
항상 마지막 리프 노드가 됩니다.

1377
00:31:49,350 --> 00:31:49,360
항상 마지막 리프 노드가 됩니다.
 

1378
00:31:49,360 --> 00:31:51,509
항상 마지막 리프 노드가 됩니다.
삽입 후에는

1379
00:31:51,509 --> 00:31:52,710
삽입 후에는
 

1380
00:31:52,710 --> 00:31:52,720

 

1381
00:31:52,720 --> 00:31:57,029

q-1 크기의 위치에 있게 됩니다. 하지만

1382
00:31:57,029 --> 00:31:57,039

 

1383
00:31:57,039 --> 00:31:59,669

이것만으로는 충분하지 않을 것 같네요.

1384
00:31:59,669 --> 00:32:01,430
이것만으로는 충분하지 않을 것 같네요.
 

1385
00:32:01,430 --> 00:32:01,440

 

1386
00:32:01,440 --> 00:32:03,190

리프 노드에 임의의 항목을 삽입하면 이제 최대 힙 속성을 만족하지 못할 수 있습니다. 만족하는지

1387
00:32:03,190 --> 00:32:04,630
리프 노드에 임의의 항목을 삽입하면 이제 최대 힙 속성을 만족하지 못할 수 있습니다. 만족하는지
 

1388
00:32:04,630 --> 00:32:04,640

 

1389
00:32:04,640 --> 00:32:06,630

확인하고 만족하지

1390
00:32:06,630 --> 00:32:06,640
확인하고 만족하지
 

1391
00:32:06,640 --> 00:32:07,909
확인하고 만족하지
않으면 수정하는

1392
00:32:07,909 --> 00:32:07,919
않으면 수정하는
 

1393
00:32:07,919 --> 00:32:10,630
않으면 수정하는
방법을 알고 있지만, 이번에는

1394
00:32:10,630 --> 00:32:10,640
방법을 알고 있지만, 이번에는
 

1395
00:32:10,640 --> 00:32:11,269
방법을 알고 있지만, 이번에는

1396
00:32:11,269 --> 00:32:20,149

 

1397
00:32:20,149 --> 00:32:20,159

 

1398
00:32:20,159 --> 00:32:21,669

회전조차 필요하지 않습니다.

1399
00:32:21,669 --> 00:32:21,679
회전조차 필요하지 않습니다.
 

1400
00:32:21,679 --> 00:32:23,990
회전조차 필요하지 않습니다.
멋지죠!

1401
00:32:23,990 --> 00:32:24,000
멋지죠!
 

1402
00:32:24,000 --> 00:32:25,350
멋지죠!
그래서 '

1403
00:32:25,350 --> 00:32:25,360
그래서 '
 

1404
00:32:25,360 --> 00:32:29,029
그래서 '
최대 힙화(max heapify up)'라는 연산을 정의할 겁니다. 이 연산은 노드를

1405
00:32:29,029 --> 00:32:29,039
최대 힙화(max heapify up)'라는 연산을 정의할 겁니다. 이 연산은 노드를
 

1406
00:32:29,039 --> 00:32:30,789
최대 힙화(max heapify up)'라는 연산을 정의할 겁니다. 이 연산은 노드를
최대 힙에 더 가깝게 만들어 줍니다. 값 i의 크기는

1407
00:32:30,789 --> 00:32:30,799
최대 힙에 더 가깝게 만들어 줍니다. 값 i의 크기는
 

1408
00:32:30,799 --> 00:32:32,950
최대 힙에 더 가깝게 만들어 줍니다. 값 i의 크기는

1409
00:32:32,950 --> 00:32:32,960

 

1410
00:32:32,960 --> 00:32:36,310

q에서 1을 뺀 값으로 시작하지만

1411
00:32:36,310 --> 00:32:36,320
q에서 1을 뺀 값으로 시작하지만
 

1412
00:32:36,320 --> 00:32:38,070
q에서 1을 뺀 값으로 시작하지만

1413
00:32:38,070 --> 00:32:40,830

 

1414
00:32:40,830 --> 00:32:40,840

 

1415
00:32:40,840 --> 00:32:42,789

재귀적으로 작동합니다. 즉, 방금

1416
00:32:42,789 --> 00:32:44,630
재귀적으로 작동합니다. 즉, 방금
 

1417
00:32:44,630 --> 00:32:48,230

 

1418
00:32:48,230 --> 00:32:49,590

 

1419
00:32:49,590 --> 00:32:49,600

 

1420
00:32:49,600 --> 00:32:51,750

삽입된 노드 i를 살펴보고 어떤 부분에서 속성을 위반하는지 확인합니다. 우선

1421
00:32:51,750 --> 00:32:51,760
삽입된 노드 i를 살펴보고 어떤 부분에서 속성을 위반하는지 확인합니다. 우선
 

1422
00:32:51,760 --> 00:32:56,870
삽입된 노드 i를 살펴보고 어떤 부분에서 속성을 위반하는지 확인합니다. 우선
부모 노드와의 관계를 살펴봅니다.

1423
00:32:56,870 --> 00:32:56,880
부모 노드와의 관계를 살펴봅니다.
 

1424
00:32:56,880 --> 00:32:58,950
부모 노드와의 관계를 살펴봅니다.
어떤 키를 삽입했는지 모르기 때문입니다.

1425
00:32:58,950 --> 00:32:58,960
어떤 키를 삽입했는지 모르기 때문입니다.
 

1426
00:32:58,960 --> 00:33:01,029
어떤 키를 삽입했는지 모르기 때문입니다.
부모 노드보다 작으면 문제가 없지만, 크면

1427
00:33:01,029 --> 00:33:01,990
부모 노드보다 작으면 문제가 없지만, 크면
 

1428
00:33:01,990 --> 00:33:04,230

 

1429
00:33:04,230 --> 00:33:04,240

 

1430
00:33:04,240 --> 00:33:05,029

문제가 발생하므로

1431
00:33:05,029 --> 00:33:05,039
문제가 발생하므로
 

1432
00:33:05,039 --> 00:33:08,830
문제가 발생하므로
수정해야 합니다.

1433
00:33:08,830 --> 00:33:08,840
수정해야 합니다.
 

1434
00:33:08,840 --> 00:33:13,750
수정해야 합니다.

1435
00:33:13,750 --> 00:33:13,760

 

1436
00:33:13,760 --> 00:33:18,230

부모 노드의 항목 키가 i의 키보다 작으면 수정합니다.

1437
00:33:18,230 --> 00:33:22,230

 

1438
00:33:22,230 --> 00:33:25,750

 

1439
00:33:25,750 --> 00:33:25,760

 

1440
00:33:25,760 --> 00:33:27,590

아, 맞다. 모든 곳에 'key'라고 쓰는 걸 잊었네요. '

1441
00:33:27,590 --> 00:33:27,600
아, 맞다. 모든 곳에 'key'라고 쓰는 걸 잊었네요. '
 

1442
00:33:27,600 --> 00:33:31,029
아, 맞다. 모든 곳에 'key'라고 쓰는 걸 잊었네요. '
key'라고 써야 하는데. 'key'라고 써야 합니다.

1443
00:33:31,029 --> 00:33:31,039
key'라고 써야 하는데. 'key'라고 써야 합니다.
 

1444
00:33:31,039 --> 00:33:34,230
key'라고 써야 하는데. 'key'라고 써야 합니다.
i의 q는 항목이니까요.

1445
00:33:34,230 --> 00:33:34,240
i의 q는 항목이니까요.
 

1446
00:33:34,240 --> 00:33:38,230
i의 q는 항목이니까요.
핵심은 바로 이것입니다.

1447
00:33:38,230 --> 00:33:38,240
핵심은 바로 이것입니다.
 

1448
00:33:38,240 --> 00:33:40,230
핵심은 바로 이것입니다.
부모 노드가

1449
00:33:40,230 --> 00:33:40,240
부모 노드가
 

1450
00:33:40,240 --> 00:33:41,269
부모 노드가
자식 노드보다 작은 경우인데,

1451
00:33:41,269 --> 00:33:41,279
자식 노드보다 작은 경우인데,
 

1452
00:33:41,279 --> 00:33:42,950
자식 노드보다 작은 경우인데,
우리는 부모 노드가 항상

1453
00:33:42,950 --> 00:33:42,960
우리는 부모 노드가 항상
 

1454
00:33:42,960 --> 00:33:45,029
우리는 부모 노드가 항상
자식 노드보다 크거나 같아야 한다고

1455
00:33:45,029 --> 00:33:49,269
자식 노드보다 크거나 같아야 한다고
 

1456
00:33:49,269 --> 00:33:53,509

 

1457
00:33:53,509 --> 00:33:58,630

 

1458
00:33:58,630 --> 00:34:03,830

 

1459
00:34:03,830 --> 00:34:06,070

 

1460
00:34:06,070 --> 00:34:06,080

 

1461
00:34:06,080 --> 00:34:07,669

생각합니다. 그렇다면 어떻게 해야 할까요? 부모 노드를 바꿔 보겠습니다. i의 부모 노드인 q를 i의 q와 바꾸면 됩니다. 이제 순서가 맞았습니다. 자, 이제

1462
00:34:07,669 --> 00:34:08,550
생각합니다. 그렇다면 어떻게 해야 할까요? 부모 노드를 바꿔 보겠습니다. i의 부모 노드인 q를 i의 q와 바꾸면 됩니다. 이제 순서가 맞았습니다. 자, 이제
 

1463
00:34:08,550 --> 00:34:08,560

 

1464
00:34:08,560 --> 00:34:12,470

해당 노드의 다른 자식 노드와 그 부모 노드는 어떻게 해야 할지 생각해 봐야 합니다.

1465
00:34:12,470 --> 00:34:12,480
해당 노드의 다른 자식 노드와 그 부모 노드는 어떻게 해야 할지 생각해 봐야 합니다.
 

1466
00:34:12,480 --> 00:34:15,669
해당 노드의 다른 자식 노드와 그 부모 노드는 어떻게 해야 할지 생각해 봐야 합니다.
여기 숫자가 몇 개 있습니다.

1467
00:34:15,669 --> 00:34:15,679
여기 숫자가 몇 개 있습니다.
 

1468
00:34:15,679 --> 00:34:19,349
여기 숫자가 몇 개 있습니다.
이게 5

1469
00:34:19,349 --> 00:34:19,359
이게 5
 

1470
00:34:19,359 --> 00:34:22,950
이게 5
이고 이게 10이라고 가정해 보겠습니다. 이 그림에서 이전에 무엇을 알고 있었을까요?

1471
00:34:22,950 --> 00:34:24,869
이고 이게 10이라고 가정해 보겠습니다. 이 그림에서 이전에 무엇을 알고 있었을까요?
 

1472
00:34:24,869 --> 00:34:24,879

 

1473
00:34:24,879 --> 00:34:28,149

10은

1474
00:34:28,149 --> 00:34:28,159
10은
 

1475
00:34:28,159 --> 00:34:29,750
10은
새로 삽입된 항목입니다.

1476
00:34:29,750 --> 00:34:31,109
새로 삽입된 항목입니다.
 

1477
00:34:31,109 --> 00:34:31,119

 

1478
00:34:31,119 --> 00:34:32,230


1479
00:34:32,230 --> 00:34:32,240

 

1480
00:34:32,240 --> 00:34:34,310

처음 삽입했을 때 규칙을 위반했을 가능성이 있는 유일한 항목입니다.

1481
00:34:34,310 --> 00:34:36,310
처음 삽입했을 때 규칙을 위반했을 가능성이 있는 유일한 항목입니다.
 

1482
00:34:36,310 --> 00:34:36,320

 

1483
00:34:36,320 --> 00:34:38,790

10을 이동하기 전에는 왼쪽 서브트리의 모든 항목이

1484
00:34:38,790 --> 00:34:40,069
10을 이동하기 전에는 왼쪽 서브트리의 모든 항목이
 

1485
00:34:40,069 --> 00:34:40,079

 

1486
00:34:40,079 --> 00:34:42,950

5 이하이고

1487
00:34:42,950 --> 00:34:42,960
5 이하이고
 

1488
00:34:42,960 --> 00:34:44,149
5 이하이고
위쪽의 모든 항목은

1489
00:34:44,149 --> 00:34:44,159
위쪽의 모든 항목은
 

1490
00:34:44,159 --> 00:34:47,510
위쪽의 모든 항목은
5 이상이라는 것을 알고 있었습니다.

1491
00:34:47,510 --> 00:34:47,520
5 이상이라는 것을 알고 있었습니다.
 

1492
00:34:47,520 --> 00:34:49,750
5 이상이라는 것을 알고 있었습니다.
또한, 방금 삽입한 노드 10을 제외하고는 여기 있는 노드들이 실제로 5 이하라는 것도 알고 있었습니다.

1493
00:34:49,750 --> 00:34:51,109
또한, 방금 삽입한 노드 10을 제외하고는 여기 있는 노드들이 실제로 5 이하라는 것도 알고 있었습니다.
 

1494
00:34:51,109 --> 00:34:51,990

 

1495
00:34:51,990 --> 00:34:55,430

 

1496
00:34:55,430 --> 00:34:55,440

 

1497
00:34:55,440 --> 00:34:57,910

이것은 올바른 힙 구조였습니다. 즉, 5는

1498
00:34:57,910 --> 00:34:59,190
이것은 올바른 힙 구조였습니다. 즉, 5는
 

1499
00:34:59,190 --> 00:34:59,200

 

1500
00:34:59,200 --> 00:35:01,030

조상 체인에서 그 위에 있는 항목들을 구분하는 기준이었습니다.

1501
00:35:01,030 --> 00:35:01,040
조상 체인에서 그 위에 있는 항목들을 구분하는 기준이었습니다.
 

1502
00:35:01,040 --> 00:35:02,630
조상 체인에서 그 위에 있는 항목들을 구분하는 기준이었습니다.
5 이상이고,

1503
00:35:02,630 --> 00:35:03,589
5 이상이고,
 

1504
00:35:03,589 --> 00:35:03,599

 

1505
00:35:03,599 --> 00:35:05,990

하위 트리의 항목들은 5 이하입니다. 자, 이제

1506
00:35:05,990 --> 00:35:08,870
하위 트리의 항목들은 5 이하입니다. 자, 이제
 

1507
00:35:08,870 --> 00:35:15,190

 

1508
00:35:15,190 --> 00:35:15,200

 

1509
00:35:15,200 --> 00:35:18,870

5와 10을 교환하고 나면,

1510
00:35:18,870 --> 00:35:18,880
5와 10을 교환하고 나면,
 

1511
00:35:18,880 --> 00:35:21,910
5와 10을 교환하고 나면,
10은 여기, 5는 여기가 됩니다. 이제

1512
00:35:21,910 --> 00:35:21,920
10은 여기, 5는 여기가 됩니다. 이제
 

1513
00:35:21,920 --> 00:35:24,150
10은 여기, 5는 여기가 됩니다. 이제
알겠죠? 이 간선은

1514
00:35:24,150 --> 00:35:24,160
알겠죠? 이 간선은
 

1515
00:35:24,160 --> 00:35:25,430
알겠죠? 이 간선은
10이 5보다 크거나 같으므로 조건을 만족합니다.

1516
00:35:25,430 --> 00:35:25,440
10이 5보다 크거나 같으므로 조건을 만족합니다.
 

1517
00:35:25,440 --> 00:35:27,430
10이 5보다 크거나 같으므로 조건을 만족합니다.
또한, 이 간선도 원래 조건을 만족했는데, 부모 노드의 크기만 키웠기 때문에 만족합니다. 이제 이

1518
00:35:27,430 --> 00:35:28,950
또한, 이 간선도 원래 조건을 만족했는데, 부모 노드의 크기만 키웠기 때문에 만족합니다. 이제 이
 

1519
00:35:28,950 --> 00:35:31,109

 

1520
00:35:31,109 --> 00:35:31,119

 

1521
00:35:31,119 --> 00:35:34,470

간선은 문제가 있을 수 있으므로

1522
00:35:34,470 --> 00:35:39,030
간선은 문제가 있을 수 있으므로
 

1523
00:35:39,030 --> 00:35:39,040

 

1524
00:35:39,040 --> 00:35:44,870

부모 노드에 대해 재귀 호출을 해야 합니다.

1525
00:35:44,870 --> 00:35:44,880
부모 노드에 대해 재귀 호출을 해야 합니다.
 

1526
00:35:44,880 --> 00:35:47,349
부모 노드에 대해 재귀 호출을 해야 합니다.
하지만 이게 전부입니다. 이렇게 하나의

1527
00:35:47,349 --> 00:35:47,359
하지만 이게 전부입니다. 이렇게 하나의
 

1528
00:35:47,359 --> 00:35:49,190
하지만 이게 전부입니다. 이렇게 하나의
간선을 수정했습니다. 처음에는

1529
00:35:49,190 --> 00:35:49,200
간선을 수정했습니다. 처음에는
 

1530
00:35:49,200 --> 00:35:50,630
간선을 수정했습니다. 처음에는
리프 노드에서 이 작업이 이루어지지만, 일반적으로

1531
00:35:50,630 --> 00:35:50,640
리프 노드에서 이 작업이 이루어지지만, 일반적으로
 

1532
00:35:50,640 --> 00:35:53,349
리프 노드에서 이 작업이 이루어지지만, 일반적으로
우리가 삽입한 항목

1533
00:35:53,349 --> 00:35:53,359
우리가 삽입한 항목
 

1534
00:35:53,359 --> 00:35:54,630
우리가 삽입한 항목
x는

1535
00:35:54,630 --> 00:35:54,640
x는
 

1536
00:35:54,640 --> 00:35:56,470
x는
마지막 리프 노드에서 시작하여 위로 올라가면서 루트 노드까지 도달할 수도 있습니다.

1537
00:35:56,470 --> 00:35:57,990
마지막 리프 노드에서 시작하여 위로 올라가면서 루트 노드까지 도달할 수도 있습니다.
 

1538
00:35:57,990 --> 00:35:59,270

 

1539
00:35:59,270 --> 00:35:59,280

 

1540
00:35:59,280 --> 00:36:01,510

새로운 최대값을 삽입하면 루트 노드까지 올라갈 수도 있지만,

1541
00:36:01,510 --> 00:36:01,520
새로운 최대값을 삽입하면 루트 노드까지 올라갈 수도 있지만,
 

1542
00:36:01,520 --> 00:36:03,829
새로운 최대값을 삽입하면 루트 노드까지 올라갈 수도 있지만,
각 단계에서 1씩 증가합니다. 따라서

1543
00:36:03,829 --> 00:36:03,839
각 단계에서 1씩 증가합니다. 따라서
 

1544
00:36:03,839 --> 00:36:06,710
각 단계에서 1씩 증가합니다. 따라서
이 모든 과정의 실행 시간은

1545
00:36:06,710 --> 00:36:06,720
이 모든 과정의 실행 시간은
 

1546
00:36:06,720 --> 00:36:12,310
이 모든 과정의 실행 시간은
트리의 높이, 즉 log n입니다.

1547
00:36:12,310 --> 00:36:12,320
트리의 높이, 즉 log n입니다.
 

1548
00:36:12,320 --> 00:36:13,750
트리의 높이, 즉 log n입니다.
그리고 오류가 발생할 가능성이 있는 항목은 하나뿐이므로,

1549
00:36:13,750 --> 00:36:15,109
그리고 오류가 발생할 가능성이 있는 항목은 하나뿐이므로,
 

1550
00:36:15,109 --> 00:36:15,119

 

1551
00:36:15,119 --> 00:36:17,109

이동이 멈추더라도 조건을

1552
00:36:17,109 --> 00:36:17,119
이동이 멈추더라도 조건을
 

1553
00:36:17,119 --> 00:36:19,829
이동이 멈추더라도 조건을
만족하는지 확인만 하면 됩니다.  루트에 도달하면 maxi 속성을

1554
00:36:19,829 --> 00:36:21,430
만족하는지 확인만 하면 됩니다.  루트에 도달하면 maxi 속성을
 

1555
00:36:21,430 --> 00:36:21,440

 

1556
00:36:21,440 --> 00:36:23,510

만족하는지 확인할 수 있습니다.

1557
00:36:23,510 --> 00:36:23,520
만족하는지 확인할 수 있습니다.
 

1558
00:36:23,520 --> 00:36:24,870
만족하는지 확인할 수 있습니다.
제가 여기에 적지 않은 기본 사례가 있는데,

1559
00:36:24,870 --> 00:36:25,670
제가 여기에 적지 않은 기본 사례가 있는데,
 

1560
00:36:25,670 --> 00:36:25,680

 

1561
00:36:25,680 --> 00:36:28,150

i가 0이면 루트에 도달한 것이므로 작업이

1562
00:36:28,150 --> 00:36:28,160
i가 0이면 루트에 도달한 것이므로 작업이
 

1563
00:36:28,160 --> 00:36:29,990
i가 0이면 루트에 도달한 것이므로 작업이
완료된 것입니다.

1564
00:36:29,990 --> 00:36:30,000
완료된 것입니다.
 

1565
00:36:30,000 --> 00:36:32,069
완료된 것입니다.
그리고 귀납법으로 이것이 옳다는 것을 증명할 수 있습니다.

1566
00:36:32,069 --> 00:36:34,470
그리고 귀납법으로 이것이 옳다는 것을 증명할 수 있습니다.
 

1567
00:36:34,470 --> 00:36:35,750

 

1568
00:36:35,750 --> 00:36:35,760

 

1569
00:36:35,760 --> 00:36:37,589

처음에 잘못된 위치에 있는 항목이 하나 있는데, 그것을

1570
00:36:37,589 --> 00:36:37,599
처음에 잘못된 위치에 있는 항목이 하나 있는데, 그것을
 

1571
00:36:37,599 --> 00:36:39,030
처음에 잘못된 위치에 있는 항목이 하나 있는데, 그것을
올바른 위치로 옮기는 것입니다. 여러 위치가 있을

1572
00:36:39,030 --> 00:36:39,040
올바른 위치로 옮기는 것입니다. 여러 위치가 있을
 

1573
00:36:39,040 --> 00:36:40,630
올바른 위치로 옮기는 것입니다. 여러 위치가 있을
수 있지만,

1574
00:36:40,630 --> 00:36:40,640
수 있지만,
 

1575
00:36:40,640 --> 00:36:43,030
수 있지만,
우리는 그것을 고유한 조상 위치로 옮길 것입니다. 이것이

1576
00:36:43,030 --> 00:36:45,910
우리는 그것을 고유한 조상 위치로 옮길 것입니다. 이것이
 

1577
00:36:45,910 --> 00:36:45,920

 

1578
00:36:45,920 --> 00:36:48,470

maxi 속성을 만족합니다. 따라서

1579
00:36:48,470 --> 00:36:48,480
maxi 속성을 만족합니다. 따라서
 

1580
00:36:48,480 --> 00:36:50,069
maxi 속성을 만족합니다. 따라서
삽입과

1581
00:36:50,069 --> 00:36:50,079
삽입과
 

1582
00:36:50,079 --> 00:36:53,270
삽입과
삭제는

1583
00:36:53,270 --> 00:36:53,280
삭제는
 

1584
00:36:53,280 --> 00:37:01,829
삭제는
거의 동일합니다.

1585
00:37:01,829 --> 00:37:13,750

 

1586
00:37:13,750 --> 00:37:13,760

 

1587
00:37:13,760 --> 00:37:17,270

삭제, 즉 max가 아니라 min입니다. 감사합니다.

1588
00:37:17,270 --> 00:37:17,280

 

1589
00:37:17,280 --> 00:37:18,710

물론 max

1590
00:37:18,710 --> 00:37:18,720
물론 max
 

1591
00:37:18,720 --> 00:37:20,310
물론 max
대신 min에 대해서도 이 모든 것을 정의할 수 있습니다. 모든 것은

1592
00:37:20,310 --> 00:37:20,320
대신 min에 대해서도 이 모든 것을 정의할 수 있습니다. 모든 것은
 

1593
00:37:20,320 --> 00:37:21,190
대신 min에 대해서도 이 모든 것을 정의할 수 있습니다. 모든 것은
동일하게 작동합니다. 다만

1594
00:37:21,190 --> 00:37:22,950
동일하게 작동합니다. 다만
 

1595
00:37:22,950 --> 00:37:22,960

 

1596
00:37:22,960 --> 00:37:24,230

어떤 것을 사용하는지 기억하기가 어려울 뿐입니다. 음,

1597
00:37:24,230 --> 00:37:24,240
어떤 것을 사용하는지 기억하기가 어려울 뿐입니다. 음,
 

1598
00:37:24,240 --> 00:37:27,030
어떤 것을 사용하는지 기억하기가 어려울 뿐입니다. 음,
바꾸지 마세요. max

1599
00:37:27,030 --> 00:37:27,040
바꾸지 마세요. max
 

1600
00:37:27,040 --> 00:37:28,630
바꾸지 마세요. max
힙으로 delete min을 할 수 없고,

1601
00:37:28,630 --> 00:37:28,640
힙으로 delete min을 할 수 없고,
 

1602
00:37:28,640 --> 00:37:31,030
힙으로 delete min을 할 수 없고,
mini 힙으로 delete max를 할 수 없습니다. 하지만

1603
00:37:31,030 --> 00:37:31,040
mini 힙으로 delete max를 할 수 없습니다. 하지만
 

1604
00:37:31,040 --> 00:37:32,630
mini 힙으로 delete max를 할 수 없습니다. 하지만
min 힙으로 delete min을 할 수는 있습니다.

1605
00:37:32,630 --> 00:37:32,640
min 힙으로 delete min을 할 수는 있습니다.
 

1606
00:37:32,640 --> 00:37:35,109
min 힙으로 delete min을 할 수는 있습니다.
좋습니다.

1607
00:37:35,109 --> 00:37:35,119
좋습니다.
 

1608
00:37:35,119 --> 00:37:38,310
좋습니다.
제가 말했듯이,

1609
00:37:38,310 --> 00:37:38,320
제가 말했듯이,
 

1610
00:37:38,320 --> 00:37:40,150
제가 말했듯이,
우리가 실제로 삭제하는 방법을 아는 유일한 노드는

1611
00:37:40,150 --> 00:37:40,160
우리가 실제로 삭제하는 방법을 아는 유일한 노드는
 

1612
00:37:40,160 --> 00:37:41,990
우리가 실제로 삭제하는 방법을 아는 유일한 노드는
마지막 리프 노드, 즉 마지막

1613
00:37:41,990 --> 00:37:42,000
마지막 리프 노드, 즉 마지막
 

1614
00:37:42,000 --> 00:37:43,750
마지막 리프 노드, 즉 마지막
레벨의 노드입니다.  배열의 끝을 삭제하는 이유는

1615
00:37:43,750 --> 00:37:43,760
레벨의 노드입니다.  배열의 끝을 삭제하는 이유는
 

1616
00:37:43,760 --> 00:37:45,589
레벨의 노드입니다.  배열의 끝을 삭제하는 이유는
배열에서 효율적으로 삭제할 수 있는 부분이기 때문입니다. 우리가

1617
00:37:45,589 --> 00:37:45,599
배열에서 효율적으로 삭제할 수 있는 부분이기 때문입니다. 우리가
 

1618
00:37:45,599 --> 00:37:46,950
배열에서 효율적으로 삭제할 수 있는 부분이기 때문입니다. 우리가

1619
00:37:46,950 --> 00:37:46,960

 

1620
00:37:46,960 --> 00:37:49,030

삭제해야 할 것은

1621
00:37:49,030 --> 00:37:49,040
삭제해야 할 것은
 

1622
00:37:49,040 --> 00:37:49,990
삭제해야 할 것은
루트 항목인데, 루트 항목은

1623
00:37:49,990 --> 00:37:50,000
루트 항목인데, 루트 항목은
 

1624
00:37:50,000 --> 00:37:51,990
루트 항목인데, 루트 항목은
항상 배열

1625
00:37:51,990 --> 00:37:52,000
항상 배열
 

1626
00:37:52,000 --> 00:37:53,349
항상 배열
의 첫 번째 위치에 있는 최대값이기 때문입니다.

1627
00:37:53,349 --> 00:37:53,359
의 첫 번째 위치에 있는 최대값이기 때문입니다.
 

1628
00:37:53,359 --> 00:37:54,230
의 첫 번째 위치에 있는 최대값이기 때문입니다.

1629
00:37:54,230 --> 00:37:54,240

 

1630
00:37:54,240 --> 00:37:57,670

그래서 어떻게 할까요? 평소처럼 두 항목을 교환합니다.

1631
00:37:57,670 --> 00:37:57,680
그래서 어떻게 할까요? 평소처럼 두 항목을 교환합니다.
 

1632
00:37:57,680 --> 00:38:00,230
그래서 어떻게 할까요? 평소처럼 두 항목을 교환합니다.

1633
00:38:00,230 --> 00:38:00,240

 

1634
00:38:00,240 --> 00:38:02,069

힙의 장점은

1635
00:38:02,069 --> 00:38:02,079
힙의 장점은
 

1636
00:38:02,079 --> 00:38:03,750
힙의 장점은
회전을 할 필요 없이 교환만 하면 된다는 점입니다. 이는

1637
00:38:03,750 --> 00:38:05,270
회전을 할 필요 없이 교환만 하면 된다는 점입니다. 이는
 

1638
00:38:05,270 --> 00:38:05,280

 

1639
00:38:05,280 --> 00:38:06,710

트리, 특히 이진 트리에서 해야 했던 것과 같은 방식입니다. 아,

1640
00:38:06,710 --> 00:38:10,710
트리, 특히 이진 트리에서 해야 했던 것과 같은 방식입니다. 아,
 

1641
00:38:10,710 --> 00:38:10,720

 

1642
00:38:10,720 --> 00:38:13,829

0번째

1643
00:38:13,829 --> 00:38:13,839
0번째
 

1644
00:38:13,839 --> 00:38:18,710
0번째
항목의 q와 마지막 항목의 q를 교환하는 거죠.

1645
00:38:18,710 --> 00:38:18,720
항목의 q와 마지막 항목의 q를 교환하는 거죠.
 

1646
00:38:18,720 --> 00:38:21,109
항목의 q와 마지막 항목의 q를 교환하는 거죠.
좋습니다. 이제 마지막 항목이

1647
00:38:21,109 --> 00:38:21,119
좋습니다. 이제 마지막 항목이
 

1648
00:38:21,119 --> 00:38:22,630
좋습니다. 이제 마지막 항목이
삭제될 것입니다.

1649
00:38:22,630 --> 00:38:24,630
삭제될 것입니다.
 

1650
00:38:24,630 --> 00:38:24,640

 

1651
00:38:24,640 --> 00:38:27,990

파이썬에서는 `delete last` 또는 `pop`을 사용하면 됩니다. 그러면

1652
00:38:27,990 --> 00:38:31,349

 

1653
00:38:31,349 --> 00:38:31,359

 

1654
00:38:31,359 --> 00:38:32,230

최대값이 삭제됩니다.

1655
00:38:32,230 --> 00:38:32,240
최대값이 삭제됩니다.
 

1656
00:38:32,240 --> 00:38:34,710
최대값이 삭제됩니다.
물론 삽입할 때처럼

1657
00:38:34,710 --> 00:38:34,720
물론 삽입할 때처럼
 

1658
00:38:34,720 --> 00:38:36,069
물론 삽입할 때처럼
최대값 속성이 잘못될 수도 있습니다.

1659
00:38:36,069 --> 00:38:40,069
최대값 속성이 잘못될 수도 있습니다.
 

1660
00:38:40,069 --> 00:38:40,079

 

1661
00:38:40,079 --> 00:38:41,829

삽입할 때는 마지막 리프 노드를 추가했지만,

1662
00:38:41,829 --> 00:38:41,839
삽입할 때는 마지막 리프 노드를 추가했지만,
 

1663
00:38:41,839 --> 00:38:43,349
삽입할 때는 마지막 리프 노드를 추가했지만,

1664
00:38:43,349 --> 00:38:43,359

 

1665
00:38:43,359 --> 00:38:45,270

이번에는

1666
00:38:45,270 --> 00:38:45,280
이번에는
 

1667
00:38:45,280 --> 00:38:46,470
이번에는
마지막 리프 노드를 다른 노드와 교환하는 것입니다. 제가

1668
00:38:46,470 --> 00:38:46,480
마지막 리프 노드를 다른 노드와 교환하는 것입니다. 제가
 

1669
00:38:46,480 --> 00:38:48,310
마지막 리프 노드를 다른 노드와 교환하는 것입니다. 제가
잘못된 그림을 가리키고 있었네요.

1670
00:38:48,310 --> 00:38:48,320
잘못된 그림을 가리키고 있었네요.
 

1671
00:38:48,320 --> 00:38:50,470
잘못된 그림을 가리키고 있었네요.
다시 이 트리로 돌아가 보겠습니다.

1672
00:38:50,470 --> 00:38:50,480
다시 이 트리로 돌아가 보겠습니다.
 

1673
00:38:50,480 --> 00:38:53,510
다시 이 트리로 돌아가 보겠습니다.
우리는 j번째 항목과 a번째 항목을 교환했습니다.

1674
00:38:53,510 --> 00:38:55,750
우리는 j번째 항목과 a번째 항목을 교환했습니다.
 

1675
00:38:55,750 --> 00:38:57,270

 

1676
00:38:57,270 --> 00:38:57,280

 

1677
00:38:57,280 --> 00:38:59,910

이제 문제는 루트 노드가 삭제되었을 때, 루트 노드의

1678
00:38:59,910 --> 00:38:59,920
이제 문제는 루트 노드가 삭제되었을 때, 루트 노드의
 

1679
00:38:59,920 --> 00:39:00,310
이제 문제는 루트 노드가 삭제되었을 때, 루트 노드의

1680
00:39:00,310 --> 00:39:00,320

 

1681
00:39:00,320 --> 00:39:02,710

키가 매우 작아졌다는 것입니다. 왜냐하면 현재 여기에 있는 키는 이전에 여기에 있던 값과 같기 때문입니다.

1682
00:39:02,710 --> 00:39:03,670
키가 매우 작아졌다는 것입니다. 왜냐하면 현재 여기에 있는 키는 이전에 여기에 있던 값과 같기 때문입니다.
 

1683
00:39:03,670 --> 00:39:05,349

 

1684
00:39:05,349 --> 00:39:05,359

 

1685
00:39:05,359 --> 00:39:06,950

트리의 맨 아래쪽에 위치해 있으므로 직관적으로

1686
00:39:06,950 --> 00:39:06,960
트리의 맨 아래쪽에 위치해 있으므로 직관적으로
 

1687
00:39:06,960 --> 00:39:08,390
트리의 맨 아래쪽에 위치해 있으므로 직관적으로
작은 값입니다.

1688
00:39:08,390 --> 00:39:08,400
작은 값입니다.
 

1689
00:39:08,400 --> 00:39:10,150
작은 값입니다.
이것이 최대

1690
00:39:10,150 --> 00:39:10,160
이것이 최대
 

1691
00:39:10,160 --> 00:39:11,829
이것이 최대
값이라고 가정해 보겠습니다. 루트에 작은 값을 넣었으니 이제

1692
00:39:11,829 --> 00:39:11,839
값이라고 가정해 보겠습니다. 루트에 작은 값을 넣었으니 이제
 

1693
00:39:11,839 --> 00:39:12,390
값이라고 가정해 보겠습니다. 루트에 작은 값을 넣었으니 이제

1694
00:39:12,390 --> 00:39:12,400

 

1695
00:39:12,400 --> 00:39:15,990

어떻게 할까요? 힙화 다운(heapify down)을 수행합니다.

1696
00:39:15,990 --> 00:39:16,000
어떻게 할까요? 힙화 다운(heapify down)을 수행합니다.
 

1697
00:39:16,000 --> 00:39:18,150
어떻게 할까요? 힙화 다운(heapify down)을 수행합니다.
해당 항목을 가져와

1698
00:39:18,150 --> 00:39:19,670
해당 항목을 가져와
 

1699
00:39:19,670 --> 00:39:19,680

 

1700
00:39:19,680 --> 00:39:22,390

트리의 아래쪽으로 밀어 넣어

1701
00:39:22,390 --> 00:39:22,400
트리의 아래쪽으로 밀어 넣어
 

1702
00:39:22,400 --> 00:39:24,550
트리의 아래쪽으로 밀어 넣어
최대값이 충족될 때까지 반복합니다.

1703
00:39:24,550 --> 00:39:24,560
최대값이 충족될 때까지 반복합니다.
 

1704
00:39:24,560 --> 00:39:28,390
최대값이 충족될 때까지 반복합니다.
이것이 바로 최대 힙화 다운(max

1705
00:39:28,390 --> 00:39:28,400
이것이 바로 최대 힙화 다운(max
 

1706
00:39:28,400 --> 00:39:32,630
이것이 바로 최대 힙화 다운(max
keepify down)입니다.

1707
00:39:32,630 --> 00:39:32,640
keepify down)입니다.
 

1708
00:39:32,640 --> 00:39:36,550
keepify down)입니다.
루트인 0번째 위치에서 시작합니다. 최대 힙화 다운은

1709
00:39:36,550 --> 00:39:42,870

 

1710
00:39:42,870 --> 00:39:42,880

 

1711
00:39:42,880 --> 00:39:45,750

재귀 알고리즘이므로 초기

1712
00:39:45,750 --> 00:39:45,760
재귀 알고리즘이므로 초기
 

1713
00:39:45,760 --> 00:39:47,829
재귀 알고리즘이므로 초기
위치 i에서 시작합니다.

1714
00:39:47,829 --> 00:39:47,839
위치 i에서 시작합니다.
 

1715
00:39:47,839 --> 00:39:50,150
위치 i에서 시작합니다.
처음에는 루트입니다.

1716
00:39:50,150 --> 00:39:50,870
처음에는 루트입니다.
 

1717
00:39:50,870 --> 00:39:50,880

 

1718
00:39:50,880 --> 00:39:54,829

위치 i와 그 두 자식을 살펴봅니다. 예를 들어,

1719
00:39:54,829 --> 00:39:54,839
위치 i와 그 두 자식을 살펴봅니다. 예를 들어,
 

1720
00:39:54,839 --> 00:39:57,190
위치 i와 그 두 자식을 살펴봅니다. 예를 들어,

1721
00:39:57,190 --> 00:39:59,270

 

1722
00:39:59,270 --> 00:39:59,280

 

1723
00:39:59,280 --> 00:40:01,030

여기에 0과 같은 아주 작은 값을 넣었다고 가정해 보겠습니다.

1724
00:40:01,030 --> 00:40:01,040
여기에 0과 같은 아주 작은 값을 넣었다고 가정해 보겠습니다.
 

1725
00:40:01,040 --> 00:40:03,030
여기에 0과 같은 아주 작은 값을 넣었다고 가정해 보겠습니다.
자식이 5

1726
00:40:03,030 --> 00:40:03,040
자식이 5
 

1727
00:40:03,040 --> 00:40:04,710
자식이 5
와 10이라고 할 수 있습니다.

1728
00:40:04,710 --> 00:40:04,720
와 10이라고 할 수 있습니다.
 

1729
00:40:04,720 --> 00:40:07,430
와 10이라고 할 수 있습니다.
순서를 바꿔서 좀

1730
00:40:07,430 --> 00:40:07,440
순서를 바꿔서 좀
 

1731
00:40:07,440 --> 00:40:08,230
순서를 바꿔서 좀
더 일반적인 트리처럼 보일 수도 있습니다.

1732
00:40:08,230 --> 00:40:10,950
더 일반적인 트리처럼 보일 수도 있습니다.
 

1733
00:40:10,950 --> 00:40:10,960

 

1734
00:40:10,960 --> 00:40:12,150

마이너 서치 트리는 아니지만

1735
00:40:12,150 --> 00:40:12,160
마이너 서치 트리는 아니지만
 

1736
00:40:12,160 --> 00:40:13,910
마이너 서치 트리는 아니지만
상대적인 순서는 알 수 없습니다. 하지만

1737
00:40:13,910 --> 00:40:15,829
상대적인 순서는 알 수 없습니다. 하지만
 

1738
00:40:15,829 --> 00:40:16,390

 

1739
00:40:16,390 --> 00:40:16,400

 

1740
00:40:16,400 --> 00:40:19,349

어떤 순서로든 하나는 다른 하나보다 크거나 같습니다.

1741
00:40:19,349 --> 00:40:19,359
어떤 순서로든 하나는 다른 하나보다 크거나 같습니다.
 

1742
00:40:19,359 --> 00:40:20,950
어떤 순서로든 하나는 다른 하나보다 크거나 같습니다.
이 문제를 해결하기 위해 무엇을 할까요?

1743
00:40:20,950 --> 00:40:25,270
이 문제를 해결하기 위해 무엇을 할까요?
 

1744
00:40:25,270 --> 00:40:25,280

 

1745
00:40:25,280 --> 00:40:28,390

네, 순서를 바꾸고 싶습니다.

1746
00:40:28,390 --> 00:40:28,400
네, 순서를 바꾸고 싶습니다.
 

1747
00:40:28,400 --> 00:40:29,910
네, 순서를 바꾸고 싶습니다.
0은 분명히 잘못된 위치에 있습니다.

1748
00:40:29,910 --> 00:40:29,920
0은 분명히 잘못된 위치에 있습니다.
 

1749
00:40:29,920 --> 00:40:31,750
0은 분명히 잘못된 위치에 있습니다.
트리의 더 아래쪽으로 이동해야 합니다.

1750
00:40:31,750 --> 00:40:31,760
트리의 더 아래쪽으로 이동해야 합니다.
 

1751
00:40:31,760 --> 00:40:34,069
트리의 더 아래쪽으로 이동해야 합니다.
0을 5와 바꾸거나 0을 10과 바꿀 수 있습니다.

1752
00:40:34,069 --> 00:40:38,870
0을 5와 바꾸거나 0을 10과 바꿀 수 있습니다.
 

1753
00:40:38,870 --> 00:40:38,880

 

1754
00:40:38,880 --> 00:40:42,230

5를 사용해서 그림을 그릴 수도 있지만,

1755
00:40:42,230 --> 00:40:46,150
5를 사용해서 그림을 그릴 수도 있지만,
 

1756
00:40:46,150 --> 00:40:46,160

 

1757
00:40:46,160 --> 00:40:48,309

y10이 제대로 작동하지 않을 것입니다. 더 큰 노드를 사용해서 바꾸는 것이 좋습니다.

1758
00:40:48,309 --> 00:40:48,319
y10이 제대로 작동하지 않을 것입니다. 더 큰 노드를 사용해서 바꾸는 것이 좋습니다.
 

1759
00:40:48,319 --> 00:40:50,870
y10이 제대로 작동하지 않을 것입니다. 더 큰 노드를 사용해서 바꾸는 것이 좋습니다.
그러면 이 간선이 제대로 작동하고,

1760
00:40:50,870 --> 00:40:50,880
그러면 이 간선이 제대로 작동하고,
 

1761
00:40:50,880 --> 00:40:52,870
그러면 이 간선이 제대로 작동하고,
이 간선도 제대로 작동할 것입니다. 만약

1762
00:40:52,870 --> 00:40:52,880
이 간선도 제대로 작동할 것입니다. 만약
 

1763
00:40:52,880 --> 00:40:55,270
이 간선도 제대로 작동할 것입니다. 만약
5를 위에 있는 노드로 바꾸면 510

1764
00:40:55,270 --> 00:40:55,280
5를 위에 있는 노드로 바꾸면 510
 

1765
00:40:55,280 --> 00:40:56,710
5를 위에 있는 노드로 바꾸면 510
간선이 제대로 작동하지 않아

1766
00:40:56,710 --> 00:40:56,720
간선이 제대로 작동하지 않아
 

1767
00:40:56,720 --> 00:40:58,309
간선이 제대로 작동하지 않아
최대 속성을 만족시키지 못할 것입니다. 따라서

1768
00:40:58,309 --> 00:40:58,319
최대 속성을 만족시키지 못할 것입니다. 따라서
 

1769
00:40:58,319 --> 00:41:00,150
최대 속성을 만족시키지 못할 것입니다. 따라서
한 번의 교환으로

1770
00:41:00,150 --> 00:41:00,160
한 번의 교환으로
 

1771
00:41:00,160 --> 00:41:03,270
한 번의 교환으로
최대 속성을 해결할 수 있습니다. 다만, 0은 자식 노드들과의 관계가

1772
00:41:03,270 --> 00:41:03,280
최대 속성을 해결할 수 있습니다. 다만, 0은 자식 노드들과의 관계가
 

1773
00:41:03,280 --> 00:41:05,829
최대 속성을 해결할 수 있습니다. 다만, 0은 자식 노드들과의 관계가
좋지 않을 수 있습니다. 0은

1774
00:41:05,829 --> 00:41:05,839
좋지 않을 수 있습니다. 0은
 

1775
00:41:05,839 --> 00:41:07,670
좋지 않을 수 있습니다. 0은
잘못된 위치에 있었기

1776
00:41:07,670 --> 00:41:07,680
잘못된 위치에 있었기
 

1777
00:41:07,680 --> 00:41:08,230
잘못된 위치에 있었기

1778
00:41:08,230 --> 00:41:08,240

 

1779
00:41:08,240 --> 00:41:10,069

때문에 더 아래로 이동해야 할 수도 있습니다.

1780
00:41:10,069 --> 00:41:10,079
때문에 더 아래로 이동해야 할 수도 있습니다.
 

1781
00:41:10,079 --> 00:41:11,430
때문에 더 아래로 이동해야 할 수도 있습니다.
하지만 5는 그대로 유지되므로 문제가 없습니다.

1782
00:41:11,430 --> 00:41:13,510
하지만 5는 그대로 유지되므로 문제가 없습니다.
 

1783
00:41:13,510 --> 00:41:13,520

 

1784
00:41:13,520 --> 00:41:16,550

이 서브트리의 모든 노드는 제대로 작동합니다. 그렇다면

1785
00:41:16,550 --> 00:41:16,560
이 서브트리의 모든 노드는 제대로 작동합니다. 그렇다면
 

1786
00:41:16,560 --> 00:41:18,950
이 서브트리의 모든 노드는 제대로 작동합니다. 그렇다면
부모 노드는 어떨까요? 생각해 보면,

1787
00:41:18,950 --> 00:41:20,069
부모 노드는 어떨까요? 생각해 보면,
 

1788
00:41:20,069 --> 00:41:22,069

 

1789
00:41:22,069 --> 00:41:22,079

 

1790
00:41:22,079 --> 00:41:24,470

0을 추가하기 전, 또는

1791
00:41:24,470 --> 00:41:24,480
0을 추가하기 전, 또는
 

1792
00:41:24,480 --> 00:41:25,750
0을 추가하기 전, 또는
0을 너무 높은 위치에 두기 전에는

1793
00:41:25,750 --> 00:41:25,760
0을 너무 높은 위치에 두기 전에는
 

1794
00:41:25,760 --> 00:41:27,670
0을 너무 높은 위치에 두기 전에는
모든 노드가 올바른 힙 구조를 가지고 있었습니다. 따라서 이 모든 노드는

1795
00:41:27,670 --> 00:41:27,680
모든 노드가 올바른 힙 구조를 가지고 있었습니다. 따라서 이 모든 노드는
 

1796
00:41:27,680 --> 00:41:29,589
모든 노드가 올바른 힙 구조를 가지고 있었습니다. 따라서 이 모든 노드는
10 이상일 것이고,

1797
00:41:29,589 --> 00:41:29,599
10 이상일 것이고,
 

1798
00:41:29,599 --> 00:41:33,750
10 이상일 것이고,
조상 경로의

1799
00:41:33,750 --> 00:41:33,760
조상 경로의
 

1800
00:41:33,760 --> 00:41:35,349
조상 경로의
모든 노드는

1801
00:41:35,349 --> 00:41:35,359
모든 노드는
 

1802
00:41:35,359 --> 00:41:36,870
모든 노드는
이전에는 10 이하,

1803
00:41:36,870 --> 00:41:36,880
이전에는 10 이하,
 

1804
00:41:36,880 --> 00:41:38,870
이전에는 10 이하,
5 이하일 것입니다. 따라서 부모 노드는 여전히

1805
00:41:38,870 --> 00:41:38,880
5 이하일 것입니다. 따라서 부모 노드는 여전히
 

1806
00:41:38,880 --> 00:41:41,349
5 이하일 것입니다. 따라서 부모 노드는 여전히
유효합니다.

1807
00:41:41,349 --> 00:41:41,359

 

1808
00:41:41,359 --> 00:41:44,230

이 트리는 행복해 보이지만,

1809
00:41:44,230 --> 00:41:44,240
이 트리는 행복해 보이지만,
 

1810
00:41:44,240 --> 00:41:45,910
이 트리는 행복해 보이지만,
아직 행복하지 않을 수도 있습니다. 0이 더 많으면 더 아래로

1811
00:41:45,910 --> 00:41:45,920
아직 행복하지 않을 수도 있습니다. 0이 더 많으면 더 아래로
 

1812
00:41:45,920 --> 00:41:47,270
아직 행복하지 않을 수도 있습니다. 0이 더 많으면 더 아래로
밀어 넣어야 할 수도 있죠.

1813
00:41:47,270 --> 00:41:47,280
밀어 넣어야 할 수도 있죠.
 

1814
00:41:47,280 --> 00:41:50,550
밀어 넣어야 할 수도 있죠.
그게 바로 재귀 호출입니다. 자,

1815
00:41:50,550 --> 00:41:50,560
그게 바로 재귀 호출입니다. 자,
 

1816
00:41:50,560 --> 00:41:50,870
그게 바로 재귀 호출입니다. 자,

1817
00:41:50,870 --> 00:41:50,880

 

1818
00:41:50,880 --> 00:41:53,450


1819
00:41:53,450 --> 00:41:53,460

 

1820
00:41:53,460 --> 00:42:00,829


1821
00:42:00,829 --> 00:42:00,839

 

1822
00:42:00,839 --> 00:42:05,990

여기서 확인해 보겠습니다. [박수]

1823
00:42:05,990 --> 00:42:06,000

 

1824
00:42:06,000 --> 00:42:08,150

기본 사례가 있는데, i가 리프 노드라면

1825
00:42:08,150 --> 00:42:09,589
기본 사례가 있는데, i가 리프 노드라면
 

1826
00:42:09,589 --> 00:42:09,599

 

1827
00:42:09,599 --> 00:42:13,750

아래에 아무것도 없기 때문에 끝입니다.

1828
00:42:13,750 --> 00:42:13,760
아래에 아무것도 없기 때문에 끝입니다.
 

1829
00:42:13,760 --> 00:42:16,870
아래에 아무것도 없기 때문에 끝입니다.
i에서 자식이 없으므로 최대화 속성을 만족합니다.

1830
00:42:16,870 --> 00:42:18,630
i에서 자식이 없으므로 최대화 속성을 만족합니다.
 

1831
00:42:18,630 --> 00:42:18,640

 

1832
00:42:18,640 --> 00:42:22,790

그렇지 않다면, 왼쪽 리프 노드를 살펴보겠습니다. 왼쪽이 아니라 왼쪽입니다.

1833
00:42:22,790 --> 00:42:26,710
그렇지 않다면, 왼쪽 리프 노드를 살펴보겠습니다. 왼쪽이 아니라 왼쪽입니다.
 

1834
00:42:26,710 --> 00:42:28,870

 

1835
00:42:28,870 --> 00:42:28,880

 

1836
00:42:28,880 --> 00:42:31,030

i의 오른쪽 자식 노드 두 개 중 하나가 없을 수도 있으니

1837
00:42:31,030 --> 00:42:31,040
i의 오른쪽 자식 노드 두 개 중 하나가 없을 수도 있으니
 

1838
00:42:31,040 --> 00:42:31,829
i의 오른쪽 자식 노드 두 개 중 하나가 없을 수도 있으니
무시합니다.

1839
00:42:31,829 --> 00:42:31,839
무시합니다.
 

1840
00:42:31,839 --> 00:42:35,910
무시합니다.
하지만 존재하는 두 자식 노드 중에서

1841
00:42:35,910 --> 00:42:39,349
하지만 존재하는 두 자식 노드 중에서
 

1842
00:42:39,349 --> 00:42:39,359

 

1843
00:42:39,359 --> 00:42:42,390

키 값 q가 가장 큰 노드를 찾습니다.

1844
00:42:42,390 --> 00:42:46,069
키 값 q가 가장 큰 노드를 찾습니다.
 

1845
00:42:46,069 --> 00:42:46,079

 

1846
00:42:46,079 --> 00:42:49,030

예시에서는 10이었습니다.

1847
00:42:49,030 --> 00:42:49,040
예시에서는 10이었습니다.
 

1848
00:42:49,040 --> 00:42:50,069
예시에서는 10이었습니다.
만약

1849
00:42:50,069 --> 00:42:50,079
만약
 

1850
00:42:50,079 --> 00:42:52,309
만약
이 항목들이 순서대로 정렬되어 있지 않다면, 즉 '보다 큼'을

1851
00:42:52,309 --> 00:42:52,319
이 항목들이 순서대로 정렬되어 있지 않다면, 즉 '보다 큼'을
 

1852
00:42:52,319 --> 00:42:54,309
이 항목들이 순서대로 정렬되어 있지 않다면, 즉 '보다 큼'을
만족하지 못하면 '보다 작음'을

1853
00:42:54,309 --> 00:42:54,319
만족하지 못하면 '보다 작음'을
 

1854
00:42:54,319 --> 00:42:56,950
만족하지 못하면 '보다 작음'을
만족해야 합니다.

1855
00:42:56,950 --> 00:42:58,550
만족해야 합니다.
 

1856
00:42:58,550 --> 00:43:00,470

 

1857
00:43:00,470 --> 00:43:00,480

 

1858
00:43:00,480 --> 00:43:02,069


1859
00:43:02,069 --> 00:43:02,079

 

1860
00:43:02,079 --> 00:43:06,309

여기서 '보다 작음'은 최대화 속성의 반대입니다. 최대화 속성이 위반되면

1861
00:43:06,309 --> 00:43:10,470
여기서 '보다 작음'은 최대화 속성의 반대입니다. 최대화 속성이 위반되면
 

1862
00:43:10,470 --> 00:43:10,480

 

1863
00:43:10,480 --> 00:43:15,030

i의 q와 j의 q를 교환하여 수정하고 j에 대해 재귀 호출을 합니다.

1864
00:43:15,030 --> 00:43:21,270

 

1865
00:43:21,270 --> 00:43:21,280

 

1866
00:43:21,280 --> 00:43:24,870

j에 대해 최대화 힙화 다운을 호출합니다. 끝입니다. 꽤

1867
00:43:24,870 --> 00:43:24,880
j에 대해 최대화 힙화 다운을 호출합니다. 끝입니다. 꽤
 

1868
00:43:24,880 --> 00:43:27,109
j에 대해 최대화 힙화 다운을 호출합니다. 끝입니다. 꽤
대칭적이죠. 삽입은

1869
00:43:27,109 --> 00:43:28,309
대칭적이죠. 삽입은
 

1870
00:43:28,309 --> 00:43:28,319

 

1871
00:43:28,319 --> 00:43:29,589

부모 노드가 하나뿐이므로 조금 더 간단했습니다.

1872
00:43:29,589 --> 00:43:29,599
부모 노드가 하나뿐이므로 조금 더 간단했습니다.
 

1873
00:43:29,599 --> 00:43:31,589
부모 노드가 하나뿐이므로 조금 더 간단했습니다.
삭제는  최소값은 아래로 밀어 넣는 과정이기 때문에

1874
00:43:31,589 --> 00:43:31,599
삭제는  최소값은 아래로 밀어 넣는 과정이기 때문에
 

1875
00:43:31,599 --> 00:43:33,109
삭제는  최소값은 아래로 밀어 넣는 과정이기 때문에
두 자식 노드 중

1876
00:43:33,109 --> 00:43:33,119
두 자식 노드 중
 

1877
00:43:33,119 --> 00:43:35,270
두 자식 노드 중
하나를 선택해야 하지만, 더 큰 노드를 선택하는 것이 분명합니다.

1878
00:43:35,270 --> 00:43:36,390
하나를 선택해야 하지만, 더 큰 노드를 선택하는 것이 분명합니다.
 

1879
00:43:36,390 --> 00:43:36,400

 

1880
00:43:36,400 --> 00:43:38,230

이 알고리즘 전체

1881
00:43:38,230 --> 00:43:38,240
이 알고리즘 전체
 

1882
00:43:38,240 --> 00:43:40,309
이 알고리즘 전체
과정은 트리의 높이(log n)의 h배 시간이 걸립니다.

1883
00:43:40,309 --> 00:43:42,309
과정은 트리의 높이(log n)의 h배 시간이 걸립니다.
 

1884
00:43:42,309 --> 00:43:42,319

 

1885
00:43:42,319 --> 00:43:44,150

노드가 마치 거품처럼 아래로 밀려 내려가다가

1886
00:43:44,150 --> 00:43:44,160
노드가 마치 거품처럼 아래로 밀려 내려가다가
 

1887
00:43:44,160 --> 00:43:45,510
노드가 마치 거품처럼 아래로 밀려 내려가다가
어느 지점에서 멈추기 때문입니다.

1888
00:43:45,510 --> 00:43:45,520
어느 지점에서 멈추기 때문입니다.
 

1889
00:43:45,520 --> 00:43:46,390
어느 지점에서 멈추기 때문입니다.
멈추는 지점에서 최대성(maxi property)이 만족되었음을 알 수 있습니다.

1890
00:43:46,390 --> 00:43:48,870
멈추는 지점에서 최대성(maxi property)이 만족되었음을 알 수 있습니다.
 

1891
00:43:48,870 --> 00:43:50,550

 

1892
00:43:50,550 --> 00:43:50,560

 

1893
00:43:50,560 --> 00:43:52,390

귀납적으로 확인해 보면 다른 최대성들도 모두

1894
00:43:52,390 --> 00:43:52,400
귀납적으로 확인해 보면 다른 최대성들도 모두
 

1895
00:43:52,400 --> 00:43:54,069
귀납적으로 확인해 보면 다른 최대성들도 모두
만족되었음을 알 수 있습니다.

1896
00:43:54,069 --> 00:43:54,079
만족되었음을 알 수 있습니다.
 

1897
00:43:54,079 --> 00:43:57,349
만족되었음을 알 수 있습니다.
이전에도 만족되었으니까요.

1898
00:43:57,349 --> 00:43:57,359
이전에도 만족되었으니까요.
 

1899
00:43:57,359 --> 00:43:59,670
이전에도 만족되었으니까요.
거의 강제적인 상황이죠.

1900
00:43:59,670 --> 00:43:59,680
거의 강제적인 상황이죠.
 

1901
00:43:59,680 --> 00:44:00,950
거의 강제적인 상황이죠.
놀라운 점은

1902
00:44:00,950 --> 00:44:02,309
놀라운 점은
 

1903
00:44:02,309 --> 00:44:02,319

 

1904
00:44:02,319 --> 00:44:04,630

최대성을 만족하는 완전 이진 트리를 유지할 수 있다는 것입니다.

1905
00:44:04,630 --> 00:44:04,640
최대성을 만족하는 완전 이진 트리를 유지할 수 있다는 것입니다.
 

1906
00:44:04,640 --> 00:44:05,589
최대성을 만족하는 완전 이진 트리를 유지할 수 있다는 것입니다.

1907
00:44:05,589 --> 00:44:05,599

 

1908
00:44:05,599 --> 00:44:07,670

하지만 일단 최대성 조건을 알게 되면 알고리즘은 사실상 불가능해집니다.

1909
00:44:07,670 --> 00:44:09,190
하지만 일단 최대성 조건을 알게 되면 알고리즘은 사실상 불가능해집니다.
 

1910
00:44:09,190 --> 00:44:09,200

 

1911
00:44:09,200 --> 00:44:10,710

배열을 사용해야 하기 때문에

1912
00:44:10,710 --> 00:44:10,720
배열을 사용해야 하기 때문에
 

1913
00:44:10,720 --> 00:44:12,470
배열을 사용해야 하기 때문에
마지막 항목을 삽입하고 삭제하는 것밖에 할 수 없습니다. 따라서

1914
00:44:12,470 --> 00:44:13,990
마지막 항목을 삽입하고 삭제하는 것밖에 할 수 없습니다. 따라서
 

1915
00:44:13,990 --> 00:44:15,910

 

1916
00:44:15,910 --> 00:44:15,920

 

1917
00:44:15,920 --> 00:44:17,990

이를 위해서는 배열 안팎으로 요소를 교환해야 합니다.

1918
00:44:17,990 --> 00:44:18,000
이를 위해서는 배열 안팎으로 요소를 교환해야 합니다.
 

1919
00:44:18,000 --> 00:44:19,990
이를 위해서는 배열 안팎으로 요소를 교환해야 합니다.
나머지는 각 요소가 최대성을 만족하는지 확인하는 과정입니다. 좋습니다.

1920
00:44:19,990 --> 00:44:21,430
나머지는 각 요소가 최대성을 만족하는지 확인하는 과정입니다. 좋습니다.
 

1921
00:44:21,430 --> 00:44:24,950

 

1922
00:44:24,950 --> 00:44:28,950

 

1923
00:44:28,950 --> 00:44:28,960

 

1924
00:44:28,960 --> 00:44:31,349

거의 다 됐지만, 우리가

1925
00:44:31,349 --> 00:44:31,359
거의 다 됐지만, 우리가
 

1926
00:44:31,359 --> 00:44:32,069
거의 다 됐지만, 우리가
원했던 것과는 조금 다릅니다.

1927
00:44:32,069 --> 00:44:32,079
원했던 것과는 조금 다릅니다.
 

1928
00:44:32,079 --> 00:44:35,270
원했던 것과는 조금 다릅니다.
이제 힙에서 최대값을 찾기 위해 삽입과

1929
00:44:35,270 --> 00:44:35,280
이제 힙에서 최대값을 찾기 위해 삽입과
 

1930
00:44:35,280 --> 00:44:36,309
이제 힙에서 최대값을 찾기 위해 삽입과
삭제에 각각 log n과 log n의 상각 시간이 걸립니다. 아직

1931
00:44:36,309 --> 00:44:36,319
삭제에 각각 log n과 log n의 상각 시간이 걸립니다. 아직
 

1932
00:44:36,319 --> 00:44:40,630
삭제에 각각 log n과 log n의 상각 시간이 걸립니다. 아직
선형 확장에 대해서는 다루지 않았습니다.

1933
00:44:40,630 --> 00:44:40,640
선형 확장에 대해서는 다루지 않았습니다.
 

1934
00:44:40,640 --> 00:44:41,190
선형 확장에 대해서는 다루지 않았습니다.

1935
00:44:41,190 --> 00:44:41,200

 

1936
00:44:41,200 --> 00:44:44,230

현재로서는 삽입 시 n log n의 시간이 걸립니다.  n

1937
00:44:44,230 --> 00:44:44,240
현재로서는 삽입 시 n log n의 시간이 걸립니다.  n
 

1938
00:44:44,240 --> 00:44:44,950
현재로서는 삽입 시 n log n의 시간이 걸립니다.  n
번 반복하는

1939
00:44:44,950 --> 00:44:46,550
번 반복하는
 

1940
00:44:46,550 --> 00:44:46,560

 

1941
00:44:46,560 --> 00:44:49,030

알고리즘을 생각해 봤는데, 아직 이 알고리즘을 제자리 정렬로 만드는 방법을 다루지 않았으니 각각 간단히 설명해 드리겠습니다. 먼저 제자리 정렬부터 시작해 보겠습니다.

1942
00:44:49,030 --> 00:44:52,870
알고리즘을 생각해 봤는데, 아직 이 알고리즘을 제자리 정렬로 만드는 방법을 다루지 않았으니 각각 간단히 설명해 드리겠습니다. 먼저 제자리 정렬부터 시작해 보겠습니다.
 

1943
00:44:52,870 --> 00:44:56,390

 

1944
00:44:56,390 --> 00:44:56,400

 

1945
00:44:56,400 --> 00:44:59,430


1946
00:44:59,430 --> 00:44:59,440

 

1947
00:44:59,440 --> 00:45:01,430

이 알고리즘을 제자리 정렬로 만들려면 어떻게 해야 할까요?

1948
00:45:01,430 --> 00:45:02,950
이 알고리즘을 제자리 정렬로 만들려면 어떻게 해야 할까요?
 

1949
00:45:02,950 --> 00:45:06,470

 

1950
00:45:06,470 --> 00:45:06,480

 

1951
00:45:06,480 --> 00:45:09,990

저는 제자리 정렬을 원

1952
00:45:09,990 --> 00:45:16,470
저는 제자리 정렬을 원
 

1953
00:45:16,470 --> 00:45:16,480

 

1954
00:45:16,480 --> 00:45:20,470

하지만,

1955
00:45:20,470 --> 00:45:20,480
하지만,
 

1956
00:45:20,480 --> 00:45:22,390
하지만,
배열의 크기를 늘리거나 줄이는 과정은 필요 없다고 생각합니다. 즉, 우선순위 큐 정렬처럼

1957
00:45:22,390 --> 00:45:22,400
배열의 크기를 늘리거나 줄이는 과정은 필요 없다고 생각합니다. 즉, 우선순위 큐 정렬처럼
 

1958
00:45:22,400 --> 00:45:36,309
배열의 크기를 늘리거나 줄이는 과정은 필요 없다고 생각합니다. 즉, 우선순위 큐 정렬처럼
처음부터 배열 자체를 그대로 사용하고 싶습니다.

1959
00:45:36,309 --> 00:45:36,319

 

1960
00:45:36,319 --> 00:45:41,910

이것이 바로 제자리 정렬입니다. 자, 이제

1961
00:45:41,910 --> 00:45:43,349

 

1962
00:45:43,349 --> 00:45:45,349

 

1963
00:45:45,349 --> 00:45:45,359

 

1964
00:45:45,359 --> 00:45:48,150

정렬할 배열이 있다고 가정해

1965
00:45:48,150 --> 00:45:49,270
정렬할 배열이 있다고 가정해
 

1966
00:45:49,270 --> 00:45:53,510

 

1967
00:45:53,510 --> 00:45:55,430

 

1968
00:45:55,430 --> 00:45:57,030

 

1969
00:45:57,030 --> 00:45:58,870

 

1970
00:45:58,870 --> 00:46:00,550

 

1971
00:46:00,550 --> 00:46:00,560

 

1972
00:46:00,560 --> 00:46:03,750

보겠습니다. 이 배열이 우선순위 큐 정렬의 입력이 됩니다. 처음에는 비어 있는 우선순위 큐를 만들고, 그 다음 항목을 하나씩 삽입해 나가겠습니다. 예를 들어,

1973
00:46:03,750 --> 00:46:04,950
보겠습니다. 이 배열이 우선순위 큐 정렬의 입력이 됩니다. 처음에는 비어 있는 우선순위 큐를 만들고, 그 다음 항목을 하나씩 삽입해 나가겠습니다. 예를 들어,
 

1974
00:46:04,950 --> 00:46:04,960

 

1975
00:46:04,960 --> 00:46:09,190

q는 a의 접두사라고 하고, 이 접두사가 붙은 부분 배열에 저장한다고 가정해 보겠습니다.

1976
00:46:09,190 --> 00:46:10,470
q는 a의 접두사라고 하고, 이 접두사가 붙은 부분 배열에 저장한다고 가정해 보겠습니다.
 

1977
00:46:10,470 --> 00:46:12,230

 

1978
00:46:12,230 --> 00:46:15,750

 

1979
00:46:15,750 --> 00:46:15,760

 

1980
00:46:15,760 --> 00:46:17,109

새로운 항목을 어떻게 삽입할까요?

1981
00:46:17,109 --> 00:46:20,390
새로운 항목을 어떻게 삽입할까요?
 

1982
00:46:20,390 --> 00:46:23,750

 

1983
00:46:23,750 --> 00:46:23,760

 

1984
00:46:23,760 --> 00:46:28,950

q의 크기를 증가시키면 됩니다. 즉, q의 크기를 증가시킨 다음,

1985
00:46:28,950 --> 00:46:28,960
q의 크기를 증가시키면 됩니다. 즉, q의 크기를 증가시킨 다음,
 

1986
00:46:28,960 --> 00:46:30,550
q의 크기를 증가시키면 됩니다. 즉, q의 크기를 증가시킨 다음,
다음 항목을 가져옵니다.

1987
00:46:30,550 --> 00:46:30,560
다음 항목을 가져옵니다.
 

1988
00:46:30,560 --> 00:46:32,230
다음 항목을 가져옵니다.
a에서 요소를 가져와 이 큐에 삽입합니다.

1989
00:46:32,230 --> 00:46:33,270
a에서 요소를 가져와 이 큐에 삽입합니다.
 

1990
00:46:33,270 --> 00:46:33,280

 

1991
00:46:33,280 --> 00:46:35,910

삽입 코드를 살펴보면, 가장 먼저

1992
00:46:35,910 --> 00:46:35,920
삽입 코드를 살펴보면, 가장 먼저
 

1993
00:46:35,920 --> 00:46:37,270
삽입 코드를 살펴보면, 가장 먼저

1994
00:46:37,270 --> 00:46:37,280

 

1995
00:46:37,280 --> 00:46:38,950

하고 싶었던 것은

1996
00:46:38,950 --> 00:46:38,960
하고 싶었던 것은
 

1997
00:46:38,960 --> 00:46:40,630
하고 싶었던 것은
배열의 끝에 항목을 추가하는 것이었습니다. 그래서

1998
00:46:40,630 --> 00:46:41,990
배열의 끝에 항목을 추가하는 것이었습니다. 그래서
 

1999
00:46:41,990 --> 00:46:42,000

 

2000
00:46:42,000 --> 00:46:44,309

실제 작업 없이 개념적인 작업만으로 이를 수행했습니다. 즉,

2001
00:46:44,309 --> 00:46:44,319
실제 작업 없이 개념적인 작업만으로 이를 수행했습니다. 즉,
 

2002
00:46:44,319 --> 00:46:46,150
실제 작업 없이 개념적인 작업만으로 이를 수행했습니다. 즉,
q가 하나 더 커졌다고 말하는 것입니다.

2003
00:46:46,150 --> 00:46:46,160
q가 하나 더 커졌다고 말하는 것입니다.
 

2004
00:46:46,160 --> 00:46:49,270
q가 하나 더 커졌다고 말하는 것입니다.
이제 배열의 끝에 항목이 추가되었으므로 더 이상

2005
00:46:49,270 --> 00:46:49,280
이제 배열의 끝에 항목이 추가되었으므로 더 이상
 

2006
00:46:49,280 --> 00:46:51,910
이제 배열의 끝에 항목이 추가되었으므로 더 이상
상각이 발생하지 않습니다. 실제로

2007
00:46:51,910 --> 00:46:52,390
상각이 발생하지 않습니다. 실제로
 

2008
00:46:52,390 --> 00:46:52,400

 

2009
00:46:52,400 --> 00:46:53,670

배열의 크기를 조정하는 것이 아니라,

2010
00:46:53,670 --> 00:46:53,680
배열의 크기를 조정하는 것이 아니라,
 

2011
00:46:53,680 --> 00:46:55,829
배열의 크기를 조정하는 것이 아니라,
q가 접두사보다 조금 더 커졌다고 말하는 것뿐입니다. 이는 a

2012
00:46:55,829 --> 00:46:56,950
q가 접두사보다 조금 더 커졌다고 말하는 것뿐입니다. 이는 a
 

2013
00:46:56,950 --> 00:46:56,960

 

2014
00:46:56,960 --> 00:46:59,430

의 다음 항목을 흡수하는 것과 유사합니다.

2015
00:46:59,430 --> 00:46:59,440
의 다음 항목을 흡수하는 것과 유사합니다.
 

2016
00:46:59,440 --> 00:47:01,270
의 다음 항목을 흡수하는 것과 유사합니다.

2017
00:47:01,270 --> 00:47:01,280

 

2018
00:47:01,280 --> 00:47:05,109

delete max는

2019
00:47:05,109 --> 00:47:05,119

 

2020
00:47:05,119 --> 00:47:08,069

마지막에

2021
00:47:08,069 --> 00:47:08,079
마지막에
 

2022
00:47:08,079 --> 00:47:10,870
마지막에
q의 크기를 하나 줄입니다.

2023
00:47:10,870 --> 00:47:10,880
q의 크기를 하나 줄입니다.
 

2024
00:47:10,880 --> 00:47:14,069
q의 크기를 하나 줄입니다.
왜냐하면

2025
00:47:14,069 --> 00:47:14,079
왜냐하면
 

2026
00:47:14,079 --> 00:47:16,870
왜냐하면
delete max 연산의 마지막, 정확히는

2027
00:47:16,870 --> 00:47:16,880
delete max 연산의 마지막, 정확히는
 

2028
00:47:16,880 --> 00:47:19,349
delete max 연산의 마지막, 정확히는
마지막이 아니지만 거의 마지막에

2029
00:47:19,349 --> 00:47:19,359
마지막이 아니지만 거의 마지막에
 

2030
00:47:19,359 --> 00:47:21,990
마지막이 아니지만 거의 마지막에
배열의 마지막 항목을 삭제했기 때문입니다.

2031
00:47:21,990 --> 00:47:22,000
배열의 마지막 항목을 삭제했기 때문입니다.
 

2032
00:47:22,000 --> 00:47:23,670
배열의 마지막 항목을 삭제했기 때문입니다.
따라서 delete last를 decrement로 대체하면

2033
00:47:23,670 --> 00:47:23,680
따라서 delete last를 decrement로 대체하면
 

2034
00:47:23,680 --> 00:47:23,990
따라서 delete last를 decrement로 대체하면

2035
00:47:23,990 --> 00:47:26,230

 

2036
00:47:26,230 --> 00:47:26,240

 

2037
00:47:26,240 --> 00:47:27,270

큐의 크기가

2038
00:47:27,270 --> 00:47:27,280
큐의 크기가
 

2039
00:47:27,280 --> 00:47:30,549
큐의 크기가
하나 줄어듭니다. 이는 마지막 항목을 삭제하는 것과 정확히 동일한 효과를 내지만,

2040
00:47:30,549 --> 00:47:32,390
하나 줄어듭니다. 이는 마지막 항목을 삭제하는 것과 정확히 동일한 효과를 내지만,
 

2041
00:47:32,390 --> 00:47:32,400

 

2042
00:47:32,400 --> 00:47:34,470

최악의 경우 상각이 발생하지 않고 상수 시간으로 처리됩니다.

2043
00:47:34,470 --> 00:47:34,480
최악의 경우 상각이 발생하지 않고 상수 시간으로 처리됩니다.
 

2044
00:47:34,480 --> 00:47:36,630
최악의 경우 상각이 발생하지 않고 상수 시간으로 처리됩니다.
결과적으로

2045
00:47:36,630 --> 00:47:36,640
결과적으로
 

2046
00:47:36,640 --> 00:47:37,990
결과적으로
동적 배열을 실제로 구축하는 것이 아니라

2047
00:47:37,990 --> 00:47:38,000
동적 배열을 실제로 구축하는 것이 아니라
 

2048
00:47:38,000 --> 00:47:40,230
동적 배열을 실제로 구축하는 것이 아니라
a의 일부를 사용하여 구현합니다. 따라서

2049
00:47:40,230 --> 00:47:41,430
a의 일부를 사용하여 구현합니다. 따라서
 

2050
00:47:41,430 --> 00:47:41,440

 

2051
00:47:41,440 --> 00:47:42,950

모든 요소를 ​​흡수하게 됩니다.

2052
00:47:42,950 --> 00:47:42,960
모든 요소를 ​​흡수하게 됩니다.
 

2053
00:47:42,960 --> 00:47:44,470
모든 요소를 ​​흡수하게 됩니다.
우선순위 큐에 항목을 넣은 다음 하나씩 제거하기 시작합니다.

2054
00:47:44,470 --> 00:47:45,589
우선순위 큐에 항목을 넣은 다음 하나씩 제거하기 시작합니다.
 

2055
00:47:45,589 --> 00:47:47,990

 

2056
00:47:47,990 --> 00:47:48,000

 

2057
00:47:48,000 --> 00:47:48,710

가장 큰

2058
00:47:48,710 --> 00:47:48,720
가장 큰
 

2059
00:47:48,720 --> 00:47:51,030
가장 큰
키 항목을 먼저 제거하고 여기에 놓습니다.

2060
00:47:51,030 --> 00:47:51,040
키 항목을 먼저 제거하고 여기에 놓습니다.
 

2061
00:47:51,040 --> 00:47:52,630
키 항목을 먼저 제거하고 여기에 놓습니다.
그다음 큰 항목, 그다음 큰 항목 순으로 배치합니다. 가장 작은

2062
00:47:52,630 --> 00:47:52,640
그다음 큰 항목, 그다음 큰 항목 순으로 배치합니다. 가장 작은
 

2063
00:47:52,640 --> 00:47:54,309
그다음 큰 항목, 그다음 큰 항목 순으로 배치합니다. 가장 작은
항목은

2064
00:47:54,309 --> 00:47:54,319
항목은
 

2065
00:47:54,319 --> 00:47:54,950
항목은
여기에 놓이게 되고, 이렇게 하면

2066
00:47:54,950 --> 00:47:54,960
여기에 놓이게 되고, 이렇게 하면
 

2067
00:47:54,960 --> 00:47:56,710
여기에 놓이게 되고, 이렇게 하면
정렬이 완료됩니다.

2068
00:47:56,710 --> 00:47:56,720
정렬이 완료됩니다.
 

2069
00:47:56,720 --> 00:47:58,790
정렬이 완료됩니다.
제가 최소 힙 대신 최대 힙을 사용한 이유는,

2070
00:47:58,790 --> 00:47:58,800
제가 최소 힙 대신 최대 힙을 사용한 이유는,
 

2071
00:47:58,800 --> 00:47:59,990
제가 최소 힙 대신 최대 힙을 사용한 이유는,

2072
00:47:59,990 --> 00:48:03,349

 

2073
00:48:03,349 --> 00:48:05,109

 

2074
00:48:05,109 --> 00:48:05,119

 

2075
00:48:05,119 --> 00:48:06,710

항상 끝에서 항목을 제거하고 가장 큰 항목을

2076
00:48:06,710 --> 00:48:06,720
항상 끝에서 항목을 제거하고 가장 큰 항목을
 

2077
00:48:06,720 --> 00:48:07,190
항상 끝에서 항목을 제거하고 가장 큰 항목을

2078
00:48:07,190 --> 00:48:07,200

 

2079
00:48:07,200 --> 00:48:11,109

먼저 삭제하기 때문에 최종적으로 가장 큰 항목이 맨 끝에 오도록 상향 정렬된 배열을 만들기 위해서입니다. 이것이 바로

2080
00:48:11,109 --> 00:48:11,119
먼저 삭제하기 때문에 최종적으로 가장 큰 항목이 맨 끝에 오도록 상향 정렬된 배열을 만들기 위해서입니다. 이것이 바로
 

2081
00:48:11,119 --> 00:48:15,030
먼저 삭제하기 때문에 최종적으로 가장 큰 항목이 맨 끝에 오도록 상향 정렬된 배열을 만들기 위해서입니다. 이것이 바로
일반적으로 힙 정렬이라고 불리는 것입니다.

2082
00:48:15,030 --> 00:48:15,040

 

2083
00:48:15,040 --> 00:48:17,270

이와 같은 방식을

2084
00:48:17,270 --> 00:48:17,280
이와 같은 방식을
 

2085
00:48:17,280 --> 00:48:18,950
이와 같은 방식을
삽입 정렬과 선택 정렬에도 적용할 수 있으며,

2086
00:48:18,950 --> 00:48:20,790
삽입 정렬과 선택 정렬에도 적용할 수 있으며,
 

2087
00:48:20,790 --> 00:48:20,800

 

2088
00:48:20,800 --> 00:48:21,270


2089
00:48:21,270 --> 00:48:23,190

 

2090
00:48:23,190 --> 00:48:24,870

 

2091
00:48:24,870 --> 00:48:24,880

 

2092
00:48:24,880 --> 00:48:27,910

배열의 앞부분에서 작동하는 삽입 정렬과 선택 정렬 알고리즘을 얻을 수 있습니다. 좋습니다.

2093
00:48:27,910 --> 00:48:27,920
배열의 앞부분에서 작동하는 삽입 정렬과 선택 정렬 알고리즘을 얻을 수 있습니다. 좋습니다.
 

2094
00:48:27,920 --> 00:48:30,549
배열의 앞부분에서 작동하는 삽입 정렬과 선택 정렬 알고리즘을 얻을 수 있습니다. 좋습니다.
이제

2095
00:48:30,549 --> 00:48:30,559
이제
 

2096
00:48:30,559 --> 00:48:31,910
이제
n log n 시간 복잡도를 갖는

2097
00:48:31,910 --> 00:48:31,920
n log n 시간 복잡도를 갖는
 

2098
00:48:31,920 --> 00:48:34,309
n log n 시간 복잡도를 갖는
정렬 알고리즘을 구현했습니다. 이것이 바로

2099
00:48:34,309 --> 00:48:34,319
정렬 알고리즘을 구현했습니다. 이것이 바로
 

2100
00:48:34,319 --> 00:48:35,510
정렬 알고리즘을 구현했습니다. 이것이 바로
우리의 주요 목표였던 제자리 정렬입니다.

2101
00:48:35,510 --> 00:48:35,520
우리의 주요 목표였던 제자리 정렬입니다.
 

2102
00:48:35,520 --> 00:48:41,510
우리의 주요 목표였던 제자리 정렬입니다.
잠깐 언급하자면,

2103
00:48:41,510 --> 00:48:45,990

 

2104
00:48:45,990 --> 00:48:46,000

 

2105
00:48:46,000 --> 00:48:49,109

영리한 방법을 사용하면 선형 시간 복잡도로 힙을 구축할 수 있습니다. 항목을 한 번에 하나씩 삽입하는 것은

2106
00:48:49,109 --> 00:48:50,230
영리한 방법을 사용하면 선형 시간 복잡도로 힙을 구축할 수 있습니다. 항목을 한 번에 하나씩 삽입하는 것은
 

2107
00:48:50,230 --> 00:48:51,349

 

2108
00:48:51,349 --> 00:48:51,359

 

2109
00:48:51,359 --> 00:48:53,589

배열을 아래로 삽입하는 것과 같습니다.

2110
00:48:53,589 --> 00:48:53,599
배열을 아래로 삽입하는 것과 같습니다.
 

2111
00:48:53,599 --> 00:48:55,190
배열을 아래로 삽입하는 것과 같습니다.
항목을 삽입할 때마다 트리를 위로 탐색해야 합니다. 따라서

2112
00:48:55,190 --> 00:48:59,430
항목을 삽입할 때마다 트리를 위로 탐색해야 합니다. 따라서
 

2113
00:48:59,430 --> 00:48:59,440

 

2114
00:48:59,440 --> 00:49:04,069

각 노드의 깊이의 합이라고 하면

2115
00:49:04,069 --> 00:49:04,079

 

2116
00:49:04,079 --> 00:49:08,069

n log n이 됩니다. 즉, i에 대한

2117
00:49:08,069 --> 00:49:08,079

 

2118
00:49:08,079 --> 00:49:11,990

log i의 합이므로

2119
00:49:11,990 --> 00:49:12,000
log i의 합이므로
 

2120
00:49:12,000 --> 00:49:15,190
log i의 합이므로
n log n, 즉

2121
00:49:15,190 --> 00:49:15,200
n log n, 즉
 

2122
00:49:15,200 --> 00:49:18,230
n log n, 즉
log n 팩토리얼이 됩니다. 여기서 중요한 팁은

2123
00:49:18,230 --> 00:49:18,240
log n 팩토리얼이 됩니다. 여기서 중요한 팁은
 

2124
00:49:18,240 --> 00:49:20,710
log n 팩토리얼이 됩니다. 여기서 중요한 팁은
모든

2125
00:49:20,710 --> 00:49:20,720
모든
 

2126
00:49:20,720 --> 00:49:22,230
모든
항목을 한 번에 더하고 아무것도 힙화하지 않은

2127
00:49:22,230 --> 00:49:22,240
항목을 한 번에 더하고 아무것도 힙화하지 않은
 

2128
00:49:22,240 --> 00:49:22,950
항목을 한 번에 더하고 아무것도 힙화하지 않은

2129
00:49:22,950 --> 00:49:22,960

 

2130
00:49:22,960 --> 00:49:25,349

다음 아래에서 위로 힙화하거나 아래로 힙화하는 것입니다. 여기서는 위로

2131
00:49:25,349 --> 00:49:25,359
다음 아래에서 위로 힙화하거나 아래로 힙화하는 것입니다. 여기서는 위로
 

2132
00:49:25,359 --> 00:49:26,150
다음 아래에서 위로 힙화하거나 아래로 힙화하는 것입니다. 여기서는 위로

2133
00:49:26,150 --> 00:49:28,630

 

2134
00:49:28,630 --> 00:49:28,640

 

2135
00:49:28,640 --> 00:49:29,349

힙화하고 있지만,

2136
00:49:29,349 --> 00:49:29,359
힙화하고 있지만,
 

2137
00:49:29,359 --> 00:49:35,030
힙화하고 있지만,
이제 아래로 힙화해 보겠습니다.

2138
00:49:35,030 --> 00:49:35,040

 

2139
00:49:35,040 --> 00:49:37,430

놀랍게도 이것이 더 좋습니다. 왜냐하면

2140
00:49:37,430 --> 00:49:37,440
놀랍게도 이것이 더 좋습니다. 왜냐하면
 

2141
00:49:37,440 --> 00:49:39,349
놀랍게도 이것이 더 좋습니다. 왜냐하면
이것은 노드 높이의 합이고

2142
00:49:39,349 --> 00:49:39,359
이것은 노드 높이의 합이고
 

2143
00:49:39,359 --> 00:49:42,069
이것은 노드 높이의 합이고

2144
00:49:42,069 --> 00:49:42,079

 

2145
00:49:42,079 --> 00:49:44,069

선형적인 관계를 가지기 때문입니다. 직관적으로는

2146
00:49:44,069 --> 00:49:45,270
선형적인 관계를 가지기 때문입니다. 직관적으로는
 

2147
00:49:45,270 --> 00:49:45,280

 

2148
00:49:45,280 --> 00:49:48,309

깊이의 경우 0이고

2149
00:49:48,309 --> 00:49:48,319
깊이의 경우 0이고
 

2150
00:49:48,319 --> 00:49:49,589
깊이의 경우 0이고
log n입니다. 리프 노드가 엄청나게 많기 때문에

2151
00:49:49,589 --> 00:49:51,349
log n입니다. 리프 노드가 엄청나게 많기 때문에
 

2152
00:49:51,349 --> 00:49:51,359

 

2153
00:49:51,359 --> 00:49:52,549

리프 레벨에서는

2154
00:49:52,549 --> 00:49:52,559
리프 레벨에서는
 

2155
00:49:52,559 --> 00:49:54,309
리프 레벨에서는
n log n을 지불하는 것을 볼 수 있습니다. 리프 노드가

2156
00:49:54,309 --> 00:49:54,319
n log n을 지불하는 것을 볼 수 있습니다. 리프 노드가
 

2157
00:49:54,319 --> 00:49:56,150
n log n을 지불하는 것을 볼 수 있습니다. 리프 노드가
n개 있고

2158
00:49:56,150 --> 00:49:56,160
n개 있고
 

2159
00:49:56,160 --> 00:49:57,430
n개 있고
각 노드의 비용이 log n이기 때문입니다. 하지만

2160
00:49:57,430 --> 00:49:57,440
각 노드의 비용이 log n이기 때문입니다. 하지만
 

2161
00:49:57,440 --> 00:49:59,190
각 노드의 비용이 log n이기 때문입니다. 하지만
리프 레벨에서는 일정한 비용을 지불합니다.

2162
00:49:59,190 --> 00:50:00,870
리프 레벨에서는 일정한 비용을 지불합니다.
 

2163
00:50:00,870 --> 00:50:00,880

 

2164
00:50:00,880 --> 00:50:03,589

리프 노드의 높이는 1이고, 루트 노드의

2165
00:50:03,589 --> 00:50:03,599
리프 노드의 높이는 1이고, 루트 노드의
 

2166
00:50:03,599 --> 00:50:05,430
리프 노드의 높이는 1이고, 루트 노드의
높이는 log n입니다.

2167
00:50:05,430 --> 00:50:05,440
높이는 log n입니다.
 

2168
00:50:05,440 --> 00:50:05,670
높이는 log n입니다.

2169
00:50:05,670 --> 00:50:05,680

 

2170
00:50:05,680 --> 00:50:08,470

이제 더 잘 이해했습니다. 많은 노드에 대해 적은 비용을 지불하고 있으며, 기하

2171
00:50:08,470 --> 00:50:09,349
이제 더 잘 이해했습니다. 많은 노드에 대해 적은 비용을 지불하고 있으며, 기하
 

2172
00:50:09,349 --> 00:50:11,190

 

2173
00:50:11,190 --> 00:50:11,200

 

2174
00:50:11,200 --> 00:50:13,030

급수적인 관계는 아니지만

2175
00:50:13,030 --> 00:50:13,040
급수적인 관계는 아니지만
 

2176
00:50:13,040 --> 00:50:13,510
급수적인 관계는 아니지만

2177
00:50:13,510 --> 00:50:13,520

 

2178
00:50:13,520 --> 00:50:16,230

다음과 같은 관계가 성립합니다.  선형적인 방식이기 때문에

2179
00:50:16,230 --> 00:50:16,240
다음과 같은 관계가 성립합니다.  선형적인 방식이기 때문에
 

2180
00:50:16,240 --> 00:50:17,670
다음과 같은 관계가 성립합니다.  선형적인 방식이기 때문에
선형적인 힙 구축이 가능합니다.

2181
00:50:17,670 --> 00:50:20,630
선형적인 힙 구축이 가능합니다.
 

2182
00:50:20,630 --> 00:50:20,640

 

2183
00:50:20,640 --> 00:50:21,910

시퀀스

2184
00:50:21,910 --> 00:50:21,920
시퀀스
 

2185
00:50:21,920 --> 00:50:24,710
시퀀스
AVL 트리에 대한 질문으로 돌아가서, 임의의 순서로 항목을 저장하고 최대값으로 증강하는 시퀀스 AVL 트리를 사용하면 제자리 생성(in-place) 부분을 제외하고

2186
00:50:24,710 --> 00:50:24,720
AVL 트리에 대한 질문으로 돌아가서, 임의의 순서로 항목을 저장하고 최대값으로 증강하는 시퀀스 AVL 트리를 사용하면 제자리 생성(in-place) 부분을 제외하고
 

2187
00:50:24,720 --> 00:50:26,150
AVL 트리에 대한 질문으로 돌아가서, 임의의 순서로 항목을 저장하고 최대값으로 증강하는 시퀀스 AVL 트리를 사용하면 제자리 생성(in-place) 부분을 제외하고
힙과 동일한 모든 제약 조건을 얻을 수 있습니다. 다소

2188
00:50:26,150 --> 00:50:28,150
힙과 동일한 모든 제약 조건을 얻을 수 있습니다. 다소
 

2189
00:50:28,150 --> 00:50:30,150

 

2190
00:50:30,150 --> 00:50:32,470

 

2191
00:50:32,470 --> 00:50:33,910

 

2192
00:50:33,910 --> 00:50:33,920

 

2193
00:50:33,920 --> 00:50:36,950

기발한 아이디어이지만,

2194
00:50:36,950 --> 00:50:36,960
기발한 아이디어이지만,
 

2195
00:50:36,960 --> 00:50:38,470
기발한 아이디어이지만,
선형적인 구축 시간을 제공합니다.

2196
00:50:38,470 --> 00:50:40,309
선형적인 구축 시간을 제공합니다.
 

2197
00:50:40,309 --> 00:50:40,319

 

2198
00:50:40,319 --> 00:50:52,800

노트에 다른 흥미로운 내용도 있지만, 여기서 마치겠습니다.

