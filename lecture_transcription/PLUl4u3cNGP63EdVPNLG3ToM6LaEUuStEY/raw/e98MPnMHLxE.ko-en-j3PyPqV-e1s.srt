1
00:00:00,000 --> 00:00:01,964
[삐걱거리는 소리]

2
00:00:01,964 --> 00:00:03,928
[바스락거리는 소리]

3
00:00:03,928 --> 00:00:06,383
[딸깍거리는 소리]

4
00:00:12,780 --> 00:00:14,130
제이슨 쿠: 좋습니다.

5
00:00:14,130 --> 00:00:16,020
여러분, 환영합니다.

6
00:00:16,020 --> 00:00:17,580
퀴즈 준비되셨나요?

7
00:00:17,580 --> 00:00:18,540
청중: 아니요.

8
00:00:18,540 --> 00:00:19,710
제이슨 쿠: 다음 주에 퀴즈 있어요.

9
00:00:19,710 --> 00:00:20,280
예.

10
00:00:20,280 --> 00:00:22,530


11
00:00:22,530 --> 00:00:23,790
다음 주에 퀴즈가 있다는 걸 아시니까 다들 여기 계시길 바랍니다.

12
00:00:23,790 --> 00:00:24,300
좋아요.

13
00:00:24,300 --> 00:00:26,250
그럼 이 퀴즈는 무엇에 관한 것일까요?

14
00:00:26,250 --> 00:00:27,870


15
00:00:27,870 --> 00:00:29,430
물론 지금까지 이 수업에서 이야기했던 내용과 관련된 거예요.

16
00:00:29,430 --> 00:00:31,080
이 수업은 무엇에 관한 수업인가요?

17
00:00:31,080 --> 00:00:34,090

제 첫 강의를 기억하는 분 계신가요?

18
00:00:34,090 --> 00:00:35,160
이 수업은 무엇에 관한 수업인가요?

19
00:00:35,160 --> 00:00:37,243

이 수업에서 여러분을 평가하려는 것은 무엇일까요?

20
00:00:37,243 --> 00:00:38,160
대상: 알고리즘.

21
00:00:38,160 --> 00:00:39,035
제이슨 쿠: 알고리즘.

22
00:00:39,035 --> 00:00:39,780
엄청난.

23
00:00:39,780 --> 00:00:40,655
또한 데이터 구조도 포함됩니다.

24
00:00:40,655 --> 00:00:41,155
오른쪽?

25
00:00:41,155 --> 00:00:42,750
이것이 바로
이 내용의 첫 번째 부분입니다.

26
00:00:42,750 --> 00:00:45,870
하지만 사실 이 시험의 목적은 여러분이
계산 문제를 해결하도록 하는 것입니다.

27
00:00:45,870 --> 00:00:47,790
그게 첫 번째예요.  실제로 문제를 해결했다는 것을

28
00:00:47,790 --> 00:00:52,000
다른 사람에게 설득력 있게 제시할 수 있어야 합니다
.

29
00:00:52,000 --> 00:00:52,500
오른쪽?

30
00:00:52,500 --> 00:00:53,280
맞습니다.

31
00:00:53,280 --> 00:00:54,000
오른쪽?

32
00:00:54,000 --> 00:00:56,010
당신이
다른 것들보다 더 나은 것,

33
00:00:56,010 --> 00:00:56,910
효율적인 것을 선택했다는 뜻입니다.

34
00:00:56,910 --> 00:00:57,690
오른쪽?

35
00:00:57,690 --> 00:01:00,240
그리고
그런 것들을 다른 사람들에게 전달할 수 있다는 거죠.

36
00:01:00,240 --> 00:01:00,750
오른쪽?

37
00:01:00,750 --> 00:01:04,890
제가
여러분이 마음속에 새기도록 노력하는 네 가지 핵심 원칙이 바로 이것들입니다.

38
00:01:04,890 --> 00:01:06,960
그래서
저희 퀴즈는 바로 그런 점들을 기준으로

39
00:01:06,960 --> 00:01:08,870
여러분을 평가하려고 합니다.

40
00:01:08,870 --> 00:01:09,470
좋아요.

41
00:01:09,470 --> 00:01:15,570
그래서 학기

42
00:01:15,570 --> 00:01:17,280
초에 우리가

43
00:01:17,280 --> 00:01:21,010
다루는
계산 모델과 같은 몇 가지 세부적인 사항들을 제외하면,

44
00:01:21,010 --> 00:01:21,510
오른쪽?

45
00:01:21,510 --> 00:01:26,620
우리의 모델과 점근적 거동.

46
00:01:26,620 --> 00:01:31,500
비대칭-- 대칭--

47
00:01:31,500 --> 00:01:33,900
맞습니까?

48
00:01:33,900 --> 00:01:37,470
재발하는 거죠?

49
00:01:37,470 --> 00:01:39,990
이러한
기초적인 내용들을 제외하고, 우리는 곧바로

50
00:01:39,990 --> 00:01:42,720
알고리즘에 대해 깊이 파고듭니다.

51
00:01:42,720 --> 00:01:43,830
오른쪽?

52
00:01:43,830 --> 00:01:48,060
이것들은 거의
정의에 가까운 것들입니다.

53
00:01:48,060 --> 00:01:49,920
우리는 이런 것들에 그다지 의존하지 않습니다
.

54
00:01:49,920 --> 00:01:52,213
우리는 이런
것들에 늘 의존하고 있잖아요.

55
00:01:52,213 --> 00:01:53,880
하지만 그건
우리가

56
00:01:53,880 --> 00:01:54,930
사물에 대해 이야기할 때 사용하는 일종의 수학이죠.

57
00:01:54,930 --> 00:01:55,440
오른쪽?  우리가

58
00:01:55,440 --> 00:01:57,180


59
00:01:57,180 --> 00:01:58,860
추론할 수 없다면, 즉 이러한 작업이

60
00:01:58,860 --> 00:02:01,260


61
00:02:01,260 --> 00:02:02,730
실제 컴퓨터에서 수행되지 않는다는 것을 추상화할 수 없다면, 이 작업에 얼마나 시간이 걸리는지 어떻게 알 수 있겠습니까?

62
00:02:02,730 --> 00:02:04,650
이건 마치 우리
마음속에 있는 것, 컴퓨터 안에 있는 것과 같아요.

63
00:02:04,650 --> 00:02:06,483
그리고 우리는

64
00:02:06,483 --> 00:02:09,300


65
00:02:09,300 --> 00:02:12,237
이 마법 같은
컴퓨터가 수행할 수 있는 상수 시간 연산 횟수를 기준으로 이러한 것들을 추론하고 있는데,

66
00:02:12,237 --> 00:02:14,070
이는 특정 가정 하에서 여러분이 가지고 있는 거의 모든 컴퓨터를 상당히 잘
나타내는 지표입니다

67
00:02:14,070 --> 00:02:16,990

.

68
00:02:16,990 --> 00:02:17,490
오른쪽?

69
00:02:17,490 --> 00:02:20,430
저희는... 그러니까, 저희가 선생님께 여쭤본
문제 유형이 그렇게 많지는 않았어요

70
00:02:20,430 --> 00:02:23,790
.

71
00:02:23,790 --> 00:02:27,497
이러한 것들은,
특히, 대개

72
00:02:27,497 --> 00:02:28,830
다른 문제의 일부였습니다.

73
00:02:28,830 --> 00:02:29,340
오른쪽?

74
00:02:29,340 --> 00:02:33,000

이 게임의 재생 시간을 설명해야 했어요.

75
00:02:33,000 --> 00:02:34,975
그리고
점화식을 풀어야 했을 수도 있습니다.

76
00:02:34,975 --> 00:02:36,600
그리고 여러분은
마스터 정리를 활용할 수도 있습니다.

77
00:02:36,600 --> 00:02:37,380
그런 종류의 것들.

78
00:02:37,380 --> 00:02:37,880
오른쪽?

79
00:02:37,880 --> 00:02:39,780
아니면 당신은 항상 점근법을 사용하죠
.

80
00:02:39,780 --> 00:02:41,820
또는
우리 모델에서는

81
00:02:41,820 --> 00:02:44,550

정수의 크기를 얼마나 크게

82
00:02:44,550 --> 00:02:47,530
저장하고
상수 시간 안에 연산을 수행할 수 있는지가 중요하다는 점을 기억해야 합니다.

83
00:02:47,530 --> 00:02:48,030
오른쪽?

84
00:02:48,030 --> 00:02:50,190
그러니까 코딩 문제 마지막에 나왔던 p-set
3번 문제에서

85
00:02:50,190 --> 00:02:54,410


86
00:02:54,410 --> 00:02:56,370
해시 함수를 사용해야 했잖아요.

87
00:02:56,370 --> 00:02:59,070
그리고 여러분은
그러한 내용들이

88
00:02:59,070 --> 00:03:02,070
일정한
단어 수 안에 담겨야 하고, 따라서

89
00:03:02,070 --> 00:03:03,390
일정한 시간 안에 완료될 수 있다는 것을 주장해야 합니다.

90
00:03:03,390 --> 00:03:06,090
많은 분들이
정규화 과정이 기하

91
00:03:06,090 --> 00:03:11,620

급수적으로 큰 값으로 매핑되는 것을 발견했습니다.

92
00:03:11,620 --> 00:03:14,530
그러니까 아마
소수의 곱셈 같은 걸 하는 경우일지도 모르겠네요

93
00:03:14,530 --> 00:03:15,030
.

94
00:03:15,030 --> 00:03:17,560
그건
좋은 표현이 아닐 겁니다.

95
00:03:17,560 --> 00:03:18,060
좋아요.

96
00:03:18,060 --> 00:03:21,930
이런 문제들이 발생하긴 하지만,

97
00:03:21,930 --> 00:03:23,070
우리가 해결하는 문제의 핵심은 아닙니다.  이 수업

98
00:03:23,070 --> 00:03:24,720
의 주요 목표는 무엇이며,

99
00:03:24,720 --> 00:03:27,240

이 수업에서 계산 문제를 어떻게 해결하나요?  학기 초

100
00:03:27,240 --> 00:03:30,600
에 두 가지 방법을 알려드렸습니다
.

101
00:03:30,600 --> 00:03:33,750
여러분, 기억하시나요?

102
00:03:33,750 --> 00:03:45,270
우리는
계산

103
00:03:45,270 --> 00:03:45,770
문제를 해결할 수 있습니다.

104
00:03:51,548 --> 00:03:52,340
하나는 어려운 방법이다.

105
00:03:52,340 --> 00:03:53,930
하나는 쉬운 방법입니다.

106
00:03:53,930 --> 00:03:54,890
청중: 무력.

107
00:03:54,890 --> 00:03:55,520
제이슨 쿠: 무력으로요.

108
00:03:55,520 --> 00:03:56,020
좋아요.

109
00:03:56,020 --> 00:03:58,910
그러니까 당신은
저에게 자신

110
00:03:58,910 --> 00:04:00,440
만의 알고리즘을 만드는 기술을 설명하고 있는 거군요.

111
00:04:00,440 --> 00:04:01,160
오른쪽?

112
00:04:01,160 --> 00:04:05,840
저는 새 알고리즘을 처음부터 설계할 수 있습니다
.  그렇게 할

113
00:04:05,840 --> 00:04:07,690
수 있는 한 가지 방법은
무차별 대입을 하는 것입니다.

114
00:04:07,690 --> 00:04:08,190
오른쪽?

115
00:04:08,190 --> 00:04:10,910
가능한 모든
출력값을 살펴보고 어떤 것이 올바른지 확인하십시오.

116
00:04:10,910 --> 00:04:11,780
오른쪽?

117
00:04:11,780 --> 00:04:14,192
아니면 '
분할 통치' 같은 전략으로 단순화할 수도 있겠죠

118
00:04:14,192 --> 00:04:15,150
.  자신

119
00:04:15,150 --> 00:04:16,490


120
00:04:16,490 --> 00:04:17,615
만의 알고리즘을 만드는 건 일반적으로 어려운 일입니다.

121
00:04:17,615 --> 00:04:18,860
오른쪽?

122
00:04:18,860 --> 00:04:21,380
그래서
이 수업에서 그걸 자주 시키지 않는 거예요.

123
00:04:21,380 --> 00:04:22,580
046 같은 종류의 일이죠.

124
00:04:22,580 --> 00:04:23,080
오른쪽?

125
00:04:23,080 --> 00:04:31,100
우선 가장 먼저 할 수 있는 일은
새로운 알고리즘을 처음부터 설계하는 것입니다

126
00:04:31,100 --> 00:04:33,410
.

127
00:04:33,410 --> 00:04:35,190
보통은 처음부터 만드는 건 아니에요.

128
00:04:35,190 --> 00:04:35,690
오른쪽?

129
00:04:35,690 --> 00:04:38,360
보통은 여러분이 들어봤을 법한
알고리즘적 설계

130
00:04:38,360 --> 00:04:40,940
패러다임으로 축소해서 생각하게 됩니다
.

131
00:04:40,940 --> 00:04:44,480

046 수업과 이번

132
00:04:44,480 --> 00:04:46,490
학기 말에 동적 프로그래밍에 대해 이야기할 때 이 내용을 훨씬 더 자세히 다룰 것입니다
.

133
00:04:46,490 --> 00:04:48,980
하지만 일반적으로 그렇게 하기는
어렵습니다.

134
00:04:48,980 --> 00:04:50,270
오른쪽?

135
00:04:50,270 --> 00:04:52,400
당신은
재귀 알고리즘을 생각해내려고 하는군요.

136
00:04:52,400 --> 00:04:53,060
오른쪽?

137
00:04:53,060 --> 00:04:55,280
당신은
그것이 옳다는 것을 증명하려고 하는 것 같은데,

138
00:04:55,280 --> 00:04:57,440
이 모든 세부적인 사항들은
사실 우리가

139
00:04:57,440 --> 00:04:59,270

수업 시간 내내 강의에서

140
00:04:59,270 --> 00:05:02,330

알고리즘을 보여드린 것들입니다.

141
00:05:02,330 --> 00:05:05,300
하지만 저희는
여러분이 그런 알고리즘을 직접 만들 거라고 기대하는 건 아닙니다.

142
00:05:05,300 --> 00:05:08,660
우리는 당신이
대부분의 시간에 무엇을 하기를 기대합니까?

143
00:05:08,660 --> 00:05:09,710
응?

144
00:05:09,710 --> 00:05:12,810
이를 해결 방법을 이미 알려드린 문제로 단순화하기 위해서입니다
.

145
00:05:12,810 --> 00:05:13,310
오른쪽?

146
00:05:19,940 --> 00:05:21,830
제가
여기서 '무언가'라고 말하겠지만, 사실

147
00:05:21,830 --> 00:05:25,250
제가 의미하는 바는
우리가 여러분에게 가르쳐 드린 알고리즘을,

148
00:05:25,250 --> 00:05:28,790
기본적으로 여기서, 이미

149
00:05:28,790 --> 00:05:31,940
알려진 것으로 축소한 것을 말하는 것입니다.

150
00:05:31,940 --> 00:05:36,440
일반적으로 이는
문제가 있거나

151
00:05:36,440 --> 00:05:38,540
저희가 제공한 인터페이스에 오류가 있음을 의미합니다.

152
00:05:38,540 --> 00:05:41,720
일반적으로, 우리는

153
00:05:41,720 --> 00:05:43,770
그
문제나 인터페이스를 해결하는 다양한 방법을 보여드렸습니다.

154
00:05:43,770 --> 00:05:44,270
오른쪽?

155
00:05:44,270 --> 00:05:48,770
지금까지 우리는 여러분에게
물건을 정리하는 여러 가지 방법을 보여드렸습니다.

156
00:05:48,770 --> 00:05:51,050
그리고 우리는

157
00:05:51,050 --> 00:05:53,840
시퀀스와 세트 인터페이스를 구현하는 다양한 방법을 보여드렸습니다.

158
00:05:53,840 --> 00:05:55,340
기억하다?

159
00:05:55,340 --> 00:05:59,690
그리고

160
00:05:59,690 --> 00:06:03,710
저희가 여러분께 요청드리는 문제 유형은 종종

161
00:06:03,710 --> 00:06:05,040
저희가 했던 작업 중 일부를 블랙박스처럼 활용하는 것입니다.

162
00:06:05,040 --> 00:06:08,340
하지만 프로그래머이자
컴퓨터 과학자로서, 당신은

163
00:06:08,340 --> 00:06:12,350
언제 무엇을
사용해야 하는지 저에게 알려줘야 합니다.

164
00:06:12,350 --> 00:06:12,850
오른쪽?

165
00:06:12,850 --> 00:06:13,310
응?

166
00:06:13,310 --> 00:06:15,980
청중:
블랙박스처럼 사용한다는 게 정확히 무슨 뜻인가요?

167
00:06:15,980 --> 00:06:16,970
제이슨 쿠: 블랙박스로 사용하세요.

168
00:06:16,970 --> 00:06:17,470
정확히.

169
00:06:17,470 --> 00:06:18,230
오른쪽.

170
00:06:18,230 --> 00:06:20,690
이건
제가 자주 쓰는 표현이고,

171
00:06:20,690 --> 00:06:21,920
컴퓨터 과학 분야에 종사하는 많은 사람들이 쓰는 표현이기도 합니다.

172
00:06:21,920 --> 00:06:26,030
기본적으로
코드에 라이브러리를 가져오는 것입니다.

173
00:06:26,030 --> 00:06:26,990
오른쪽?

174
00:06:26,990 --> 00:06:27,810
내가 가진 건 뭐지?

175
00:06:27,810 --> 00:06:29,120
저는 API를 가지고 있습니다.

176
00:06:29,120 --> 00:06:31,520
저는
그 코드와 상호작용할 수 있는 방법을 가지고 있습니다.  사실

177
00:06:31,520 --> 00:06:32,960


178
00:06:32,960 --> 00:06:35,990
그 도서관 안에서 무슨 일이 벌어지고 있는지는 저도 잘 몰라요.

179
00:06:35,990 --> 00:06:37,670
저는 그것을 블랙박스로 사용하고 있습니다.  제게는

180
00:06:37,670 --> 00:06:38,990
불투명하게 느껴집니다.  저는

181
00:06:38,990 --> 00:06:40,640
내부를 들여다볼 수 없습니다.

182
00:06:40,640 --> 00:06:43,550
사실
코드 내용을 들여다볼 수는 있겠지만, 그러지

183
00:06:43,550 --> 00:06:44,750
않을 겁니다.

184
00:06:44,750 --> 00:06:46,760

제가 이 제품을 유용하게 생각하는 이유는,

185
00:06:46,760 --> 00:06:49,460


186
00:06:49,460 --> 00:06:52,150

말씀하신 대로 작동할 것이라고 믿을 수 있는 유용한 API를 제공하기 때문입니다

187
00:06:52,150 --> 00:06:53,150
.

188
00:06:53,150 --> 00:06:53,690
오른쪽?

189
00:06:53,690 --> 00:06:56,000
그래서

190
00:06:56,000 --> 00:06:58,490

사실 좀 두서없이 얘기해 볼게요. 정말

191
00:06:58,490 --> 00:07:02,100
좋은 질문이거든요.

192
00:07:02,100 --> 00:07:08,330
그래서

193
00:07:08,330 --> 00:07:11,630

이 수업에서 다루는 문제 유형은 크게 세 가지라고 생각합니다.

194
00:07:11,630 --> 00:07:13,790

문제에서 이런 내용을 보셨을 수도 있습니다.

195
00:07:13,790 --> 00:07:14,690
오른쪽?

196
00:07:14,690 --> 00:07:18,650
저는 이것들을 세 가지 범주로 나누는 것을 좋아합니다

197
00:07:18,650 --> 00:07:19,230
.

198
00:07:19,230 --> 00:07:24,380
첫째는

199
00:07:24,380 --> 00:07:26,630

우리가 알고 있는 데이터 구조나 알고리즘의 내부 작동 방식을 이해해야 한다는 것입니다.

200
00:07:26,630 --> 00:07:29,810

내부를 들여다볼 수 있어야 하는데, 예를 들어

201
00:07:29,810 --> 00:07:32,900
균형
이진 검색 트리(

202
00:07:32,900 --> 00:07:34,460
AVL 트리)의 노드가 주어졌을 때

203
00:07:34,460 --> 00:07:35,870
어떻게 회전을 할 수 있을까요?

204
00:07:35,870 --> 00:07:36,530
오른쪽?

205
00:07:36,530 --> 00:07:38,660
삽입은 어떻게 하나요?

206
00:07:38,660 --> 00:07:43,370
아니면 이진 힙의 구조에 관한 것일 수도 있는데, 예를 들어

207
00:07:43,370 --> 00:07:46,250


208
00:07:46,250 --> 00:07:49,700
최대 이진 힙에서 상위 k개 요소는 어디에 있는지 같은 것 말입니다.
이는 여러분이 제시한 문제 세트에 포함되어 있습니다.

209
00:07:49,700 --> 00:07:54,830
그러한 작업을 위해서는
데이터 구조를 블랙박스 방식으로 분석하지 않아야 합니다

210
00:07:54,830 --> 00:07:55,430
.

211
00:07:55,430 --> 00:07:56,630
하얀 상자입니다.

212
00:07:56,630 --> 00:07:57,170
오른쪽?

213
00:07:57,170 --> 00:07:59,940

그 질문에 답하려면 안에 무엇이 들어있는지 알아야 해요.

214
00:07:59,940 --> 00:08:00,440
오른쪽?

215
00:08:00,440 --> 00:08:02,240
저는
그 데이터 구조의 내부 구조에 대해 알아야 합니다

216
00:08:02,240 --> 00:08:02,740
.

217
00:08:02,740 --> 00:08:03,740
오른쪽?

218
00:08:03,740 --> 00:08:06,463
그리고 데이터 구조의 내부 구조는

219
00:08:06,463 --> 00:08:08,630
알 필요가 없는 경우도 있습니다

220
00:08:08,630 --> 00:08:09,950
.

221
00:08:09,950 --> 00:08:14,450
저는
API에 대한 지식을 활용하여

222
00:08:14,450 --> 00:08:17,150

필요한 문제에 적용해 볼 수 있습니다.  저는 그걸

223
00:08:17,150 --> 00:08:20,020

환원형 문제라고 부릅니다.

224
00:08:20,020 --> 00:08:22,880
이것이 바로
우리가

225
00:08:22,880 --> 00:08:25,280
강의에서 여러분께 제시했던 핵심 내용이 작동하는 방식입니다.  핵심 내용을

226
00:08:25,280 --> 00:08:28,580
이렇게 적용하면 되는 건가요
?

227
00:08:28,580 --> 00:08:31,940
그리고
그 두 가지보다 더 어려운 것이 있는데,

228
00:08:31,940 --> 00:08:34,788
제가 보기엔 일종의
수정 작업 같은 겁니다. (

229
00:08:34,788 --> 00:08:36,080
딱히 좋은 이름은 아니지만요.)

230
00:08:36,080 --> 00:08:38,100

이것들은 오늘 아침에 생각해낸 것들이에요.

231
00:08:38,100 --> 00:08:40,440
하지만

232
00:08:40,440 --> 00:08:44,400
여기서 말하고자 하는 것은 문제를 해결하려면
API가 무엇인지,

233
00:08:44,400 --> 00:08:46,515
그리고 내부에서 무슨 일이 일어나는지 알아야 할 필요가 있을 수 있다는 점입니다

234
00:08:46,515 --> 00:08:47,640
.  분할 정복 알고리즘을

235
00:08:47,640 --> 00:08:51,660
적용하는 것과 같은 것들 말이죠
.

236
00:08:51,660 --> 00:08:56,970
아니면, 한쪽 끝에 여유 공간이 있는
동적 배열을 사용하는 대신

237
00:08:56,970 --> 00:08:58,950

, 중간

238
00:08:58,950 --> 00:09:01,560
에 여유 공간을 넣는 식으로 바꿔야 할지도 모르겠네요
.

239
00:09:01,560 --> 00:09:02,060
오른쪽?

240
00:09:02,060 --> 00:09:04,800
저는
핵심 자료에서 나온 내용을 각색하고 있습니다.

241
00:09:04,800 --> 00:09:05,850
거의 비슷해요.

242
00:09:05,850 --> 00:09:07,350
하지만
어떤 식으로든 수정해야 해요.

243
00:09:07,350 --> 00:09:08,490
증강현실 맞죠?

244
00:09:08,490 --> 00:09:12,570

제가 이전에 드렸을지도 모르는 기본 AVL 트리에

245
00:09:12,570 --> 00:09:15,480

노드에 다른 속성을 추가해야 하는데,

246
00:09:15,480 --> 00:09:18,870

그걸 어떻게 유지 관리해야 하는지 알려주셔야 합니다.

247
00:09:18,870 --> 00:09:21,880
하위 트리의
속성을 자식 트리로부터 어떻게 계산할 수 있을까요?

248
00:09:21,880 --> 00:09:23,500
이해가 되시나요?

249
00:09:23,500 --> 00:09:26,490
이것이 더
어려운 부분입니다.

250
00:09:26,490 --> 00:09:27,000
오른쪽?  시험에서 나오는 문제

251
00:09:27,000 --> 00:09:29,530

중 어떤

252
00:09:29,530 --> 00:09:31,750
문제가

253
00:09:31,750 --> 00:09:34,050
[알아들을 수 없는 부분] 아래에 있는지 파악할 수 있다면,

254
00:09:34,050 --> 00:09:36,930
어떤 방법을 사용해야 할지 개념화하는 데 도움이 될 수 있을 겁니다.

255
00:09:36,930 --> 00:09:38,860
축소 유형의 문제의 경우—

256
00:09:38,860 --> 00:09:41,310

이 부분은 잠시 후에 설명하겠습니다—

257
00:09:41,310 --> 00:09:43,950
많은 경우

258
00:09:43,950 --> 00:09:50,910

알고리즘

259
00:09:50,910 --> 00:09:52,980
이나 데이터 구조보다는 문제 또는 인터페이스로 축소하는 것이 유용합니다.

260
00:09:52,980 --> 00:09:56,070
그게 무슨 뜻인가요?

261
00:09:56,070 --> 00:10:01,620
만약 제가 정렬로 환원해서 문제를 해결할 수 있다면
,

262
00:10:01,620 --> 00:10:03,720

그 알고리즘이 옳다고 주장할 수 있습니다.

263
00:10:03,720 --> 00:10:05,680
저는 정렬 과정을 마치
블랙박스처럼 사용합니다.

264
00:10:05,680 --> 00:10:07,560
효율적이지 않을 수도 있습니다.  제가

265
00:10:07,560 --> 00:10:11,640
선택한 정렬
알고리즘은

266
00:10:11,640 --> 00:10:12,505
효율성에 영향을 미칩니다.

267
00:10:12,505 --> 00:10:14,130
하지만 정확성 측면에서는
상관없습니다.

268
00:10:14,130 --> 00:10:15,000
오른쪽?

269
00:10:15,000 --> 00:10:18,420
데이터 구조 문제의 경우,
저는

270
00:10:18,420 --> 00:10:22,410
집합
데이터 구조 두 개와 순차

271
00:10:22,410 --> 00:10:24,840
데이터 구조 하나 또는 그와 비슷한 것을 사용하는 것으로 문제를 단순화할 수 있을 것 같습니다
.

272
00:10:24,840 --> 00:10:30,930
하지만 그것을
그런 것들로 줄이면 정확할 것입니다.

273
00:10:30,930 --> 00:10:36,300
저는
이러한 인터페이스를 기준으로 연산들을 정의할 수 있습니다.

274
00:10:36,300 --> 00:10:38,100


275
00:10:38,100 --> 00:10:39,100
러닝타임에 대해 이야기하기 전까지는 그 선택을 할 필요가 없어요.

276
00:10:39,100 --> 00:10:39,600
오른쪽?

277
00:10:39,600 --> 00:10:40,950
제가 효율성에 대해 이야기하기 전까지는요.

278
00:10:40,950 --> 00:10:44,820

퀴즈에서 점수를 얻는 방법은 간단합니다.

279
00:10:44,820 --> 00:10:48,390

알고리즘이 틀렸

280
00:10:48,390 --> 00:10:50,340
거나
정답에 매우 근접한 답이더라도 점수를 드릴 수 없습니다.

281
00:10:50,340 --> 00:10:51,990
오른쪽?

282
00:10:51,990 --> 00:10:53,790


283
00:10:53,790 --> 00:10:57,840

제출하신 알고리즘이 효율적이고,

284
00:10:57,840 --> 00:11:00,570

정확성, 실행

285
00:11:00,570 --> 00:11:02,430
시간 등과 같은 사항에 대해 논리적으로 설명하지 않으면 만점을 드릴 수 없습니다.

286
00:11:02,430 --> 00:11:07,260
당신의 알고리즘은
정확하고 효율적일 수 있지만,

287
00:11:07,260 --> 00:11:10,090

실행 시간을 잘못 분석했기

288
00:11:10,090 --> 00:11:11,700
때문에 그 부분에서
감점합니다.

289
00:11:11,700 --> 00:11:15,450
대부분의 경우
여러분은

290
00:11:15,450 --> 00:11:17,790
비효율적인 알고리즘을 제시할 뿐입니다.

291
00:11:17,790 --> 00:11:19,500
그런 다음
실행 시간을

292
00:11:19,500 --> 00:11:22,050

우리가 제시한 목표 실행 시간인 것처럼 분석합니다.

293
00:11:22,050 --> 00:11:22,650
오른쪽?

294
00:11:22,650 --> 00:11:24,310
그건 두 가지 면에서 좋지 않아요.

295
00:11:24,310 --> 00:11:24,970
오른쪽?

296
00:11:24,970 --> 00:11:25,470
좋아요.

297
00:11:25,470 --> 00:11:27,220
그러니
이런 함정에 빠지지 않도록 주의하세요.

298
00:11:27,220 --> 00:11:27,720
좋아요.  퀴즈를 볼 때 유용한

299
00:11:27,720 --> 00:11:30,060
몇 가지 일반적인 시험
전략입니다

300
00:11:30,060 --> 00:11:31,840
.  시험 시작 전에

301
00:11:31,840 --> 00:11:35,250

전체 문제를 꼼꼼히 읽어보시기를 강력히 권합니다.

302
00:11:35,250 --> 00:11:38,760

문제 중에는 쉬운 것도 있고 어려운 것도 있을 테니까요

303
00:11:38,760 --> 00:11:40,780

.

304
00:11:40,780 --> 00:11:44,100
그리고

305
00:11:44,100 --> 00:11:49,050
여러분 모두가 그렇듯이, 여기서 최대한 많은 점수를 얻으려고 노력한다면
,

306
00:11:49,050 --> 00:11:53,160


307
00:11:53,160 --> 00:11:55,530
어떤 문제가
가장 쉬운지 알아보기 위해 먼저 문제를 한 바퀴 풀어보는 것이 유용합니다.

308
00:11:55,530 --> 00:11:58,440
그런 다음 자신이

309
00:11:58,440 --> 00:11:59,790
자신 있는 순서대로 문제를 해결하면 됩니다.

310
00:11:59,790 --> 00:12:05,370
실제로
이 수업의 첫 번째 퀴즈 평균 점수는 대략

311
00:12:05,370 --> 00:12:09,180

60점에서 80점 사이입니다.

312
00:12:09,180 --> 00:12:11,970
80점을 받은 적은 없는 것 같지만,

313
00:12:11,970 --> 00:12:15,210
100점은 아니죠.

314
00:12:15,210 --> 00:12:21,690
따라서 모든 문제를 풀지만 점수가 좋지 않은 것보다 50% 정도의
문제를 잘 푸는 것이

315
00:12:21,690 --> 00:12:24,510

시간 관리나 여러 면에서 더 나을 겁니다.

316
00:12:24,510 --> 00:12:28,290


317
00:12:28,290 --> 00:12:30,390


318
00:12:30,390 --> 00:12:33,840


319
00:12:33,840 --> 00:12:35,880

컴퓨터 과학에서는 정답에

320
00:12:35,880 --> 00:12:39,690
상당히 근접해야
점수를 얻을 수 있거든요.

321
00:12:39,690 --> 00:12:40,410
오른쪽?

322
00:12:40,410 --> 00:12:43,960
기본적으로 거의
정확해야 합니다. 그렇지 않으면 점수를 받지 못합니다.

323
00:12:43,960 --> 00:12:46,590

문제 채점 방식을 보셨다면 아시겠지만,

324
00:12:46,590 --> 00:12:48,510
가끔
문제

325
00:12:48,510 --> 00:12:50,310
채점자들이 실수를 하기도 합니다.

326
00:12:50,310 --> 00:12:56,110
때로는
틀린 답에도 점수를 주기도 합니다.

327
00:12:56,110 --> 00:12:56,610
오른쪽?

328
00:12:56,610 --> 00:12:59,730


329
00:12:59,730 --> 00:13:02,370
여러분이 저희에게 제시한 문제들과
저희가 제시한 해결책들을 다시 한번 살펴보는 것은 전적으로 여러분의 몫입니다.

330
00:13:02,370 --> 00:13:06,090
저희는 여러분을 위해 좋은 해결책을 마련하는 데 많은 시간을 투자했습니다
.  해당 재료가 적합한지

331
00:13:06,090 --> 00:13:09,460
확인해야 합니다
.

332
00:13:09,460 --> 00:13:12,330

시험이 끝나고 나서 "

333
00:13:12,330 --> 00:13:16,440
아, 저도
문제 풀이에 똑같은 내용을 썼어요."라고 말하지 마세요.

334
00:13:16,440 --> 00:13:19,050
정답으로 표시되었는데
여러분들이 틀렸다고 표시했네요.  네

335
00:13:19,050 --> 00:13:20,370
, 그렇죠.

336
00:13:20,370 --> 00:13:21,780
직원들은 과제 채점자들

337
00:13:21,780 --> 00:13:25,050
보다 알고리즘에 대해 조금 더 잘 알고 있습니다
.

338
00:13:25,050 --> 00:13:26,950
그리고 우리는 여러분의 시험지를 채점합니다.

339
00:13:26,950 --> 00:13:29,190
그래서 유감스럽게도
그건 변명이 될 수 없습니다.

340
00:13:29,190 --> 00:13:31,020

내용을 숙지하는 것은 당신의 몫입니다.  네

341
00:13:31,020 --> 00:13:31,800
?

342
00:13:31,800 --> 00:13:33,780
청중: 그럼 시험
문제들은 대부분

343
00:13:33,780 --> 00:13:36,180
여러
부분으로 나뉘어 있어서,

344
00:13:36,180 --> 00:13:37,740


345
00:13:37,740 --> 00:13:39,553
앞부분
몇 개를 잘 이해하고 풀어야

346
00:13:39,553 --> 00:13:41,470

나머지 부분에서 부분 점수라도 받을 수 있는 건가요?

347
00:13:41,470 --> 00:13:42,765
아니면 [알아들을 수 없는 부분] 같은 건가요?

348
00:13:42,765 --> 00:13:43,390
제이슨 쿠: 네.

349
00:13:43,390 --> 00:13:48,400
그래서 문제
는, 질문들이

350
00:13:48,400 --> 00:13:53,020
서로 쌓여가면서

351
00:13:53,020 --> 00:13:54,670
첫 부분을 놓치면 마치 벽에 부딪히는 것처럼 되는 것인지 여부입니다.

352
00:13:54,670 --> 00:13:56,750
저희는
그런 식으로 시험을 설계하지 않으려고 노력합니다.

353
00:13:56,750 --> 00:13:57,250
좋아요.  이미 게시된

354
00:13:57,250 --> 00:13:59,770

연습 시험을 직접 확인해 보실 수 있습니다

355
00:13:59,770 --> 00:14:02,500
.

356
00:14:02,500 --> 00:14:04,900
우리의 문제는 대개
자체적으로 해결되는 경향이 있습니다.

357
00:14:04,900 --> 00:14:07,450
그리고 여러
부분으로 구성되어 있는 경우, 각 부분은

358
00:14:07,450 --> 00:14:10,300
대개 독립적입니다.

359
00:14:10,300 --> 00:14:13,420
일반적으로 B를 정확하게 수행하기
위해 A를 정확하게 수행할 필요는 없습니다

360
00:14:13,420 --> 00:14:14,710
.

361
00:14:14,710 --> 00:14:16,090
괜찮은?

362
00:14:16,090 --> 00:14:18,730
그리고 저희 문제집도 그런 방식으로
작성하려고 노력합니다.

363
00:14:18,730 --> 00:14:23,163
지난 코딩
문제 4번에서는

364
00:14:23,163 --> 00:14:24,580


365
00:14:24,580 --> 00:14:26,830
이러한 데이터 구조를 설계해야 했습니다.

366
00:14:26,830 --> 00:14:29,410
하지만 C는
그걸 사실상 블랙박스처럼 사용해서

367
00:14:29,410 --> 00:14:31,360

문제를 해결하라고 했습니다.

368
00:14:31,360 --> 00:14:32,380
오른쪽?

369
00:14:32,380 --> 00:14:34,000
그러니까 사실 따로
보여주실 필요는 없어요.

370
00:14:34,000 --> 00:14:36,970
저희가 이미 인터페이스를 제공해 드렸으니까요.

371
00:14:36,970 --> 00:14:38,680

해당 인터페이스를 사용하면

372
00:14:38,680 --> 00:14:42,550


373
00:14:42,550 --> 00:14:45,610
자료
구조 문제를 정확하게 풀지 않아도 C 언어 알고리즘 문제에 대한 답을 얻을 수 있습니다.

374
00:14:45,610 --> 00:14:47,300
이해가 되시나요?

375
00:14:47,300 --> 00:14:49,180
사실, 제 기억으로는
알고리즘 문제가 더

376
00:14:49,180 --> 00:14:52,150
쉬웠던 것 같아요
.

377
00:14:52,150 --> 00:14:52,780
응?

378
00:14:52,780 --> 00:14:54,460
청중:
시험에 코드를 작성해야 하나요?

379
00:14:54,460 --> 00:14:56,460
제이슨 쿠:
시험에서 코드를 작성해야 하나요?  저는

380
00:14:59,170 --> 00:15:04,360

코드를 작성해야 하는 시험을 본 적이 없습니다.

381
00:15:04,360 --> 00:15:07,660
저는
코드를 읽어야 하는 시험을 본 적이 있습니다.

382
00:15:07,660 --> 00:15:08,170
좋아요?

383
00:15:08,170 --> 00:15:11,410
그러니까 의사 코드든 파이썬이든 상관없어요.

384
00:15:11,410 --> 00:15:13,330
파이썬은
이 수업의 필수 과목이니까요. 그래서

385
00:15:13,330 --> 00:15:15,370

저희가

386
00:15:15,370 --> 00:15:16,930

파이썬 코드 조각을 드리고 여러분이 그 내용을

387
00:15:16,930 --> 00:15:21,370

이해할 수 있어야 하는 건 당연한 일이에요.

388
00:15:21,370 --> 00:15:22,870
응?

389
00:15:22,870 --> 00:15:24,640
청중:

390
00:15:24,640 --> 00:15:27,310
수정 사항
[알아들을 수 없는 부분]에 상각을 언급하셨는데,

391
00:15:27,310 --> 00:15:31,305
그렇다면
상각된 [알아들을 수 없는 부분]을 사용한다는 뜻인가요?

392
00:15:31,305 --> 00:15:31,930
제이슨 쿠: 네.

393
00:15:31,930 --> 00:15:34,330
제가 여기서 말하려는 것은,

394
00:15:34,330 --> 00:15:37,720
감가상각은 분명히
여기나 여기

395
00:15:37,720 --> 00:15:39,460
같은 곳에 나타난다는 것입니다.

396
00:15:39,460 --> 00:15:41,590
종종
동적 배열,

397
00:15:41,590 --> 00:15:44,440
바이너리 힙 또는
해시 테이블을 사용하는 경우, 이러한 동적 연산의 실행 시간에

398
00:15:44,440 --> 00:15:47,710
상각 비용이 포함될 수 있습니다

399
00:15:47,710 --> 00:15:49,090
.

400
00:15:49,090 --> 00:15:51,040
여기서 제가 말하는
상각이란, 예를 들어

401
00:15:51,040 --> 00:15:53,950


402
00:15:53,950 --> 00:15:57,940

동적 배열에서처럼

403
00:15:57,940 --> 00:16:00,100

끝에 공간을 추가하는 대신

404
00:16:00,100 --> 00:16:02,020

중간

405
00:16:02,020 --> 00:16:04,580
이나 시작 부분 등에 공간을 추가하는 방식을 일반화해 달라는 것입니다
.

406
00:16:04,580 --> 00:16:08,050
그리고 여러분은 일종의
상각 분석을 해야 할 겁니다.

407
00:16:08,050 --> 00:16:13,940
자, 종종
이렇게 할 필요가 없는 경우가 있습니다. 예를 들어,

408
00:16:13,940 --> 00:16:16,900


409
00:16:16,900 --> 00:16:19,990
우리가
상각 분석을 하고

410
00:16:19,990 --> 00:16:22,150
양방향 큐를 만드는 문제에 대해 이야기했을 때,

411
00:16:24,630 --> 00:16:26,830
실제로

412
00:16:26,830 --> 00:16:31,090
두 개의 동적 배열을 사용하는 것으로 문제를 해결할 수 있었습니다.

413
00:16:31,090 --> 00:16:32,020
오른쪽?

414
00:16:32,020 --> 00:16:37,540
그러니까

415
00:16:37,540 --> 00:16:39,280
물건을 사용하는 것으로 줄일 수 있는 방법은 여러 가지가 있습니다.

416
00:16:39,280 --> 00:16:41,500
하지만 마지막에
추가적인 회계 처리를 해야 할 수도 있습니다

417
00:16:41,500 --> 00:16:42,430
.

418
00:16:42,430 --> 00:16:46,750
하지만 이것이 의미하는 바는
이것들이 단순히

419
00:16:46,750 --> 00:16:48,400

블랙박스처럼 사용되는 것이 아니라는 점입니다.

420
00:16:48,400 --> 00:16:51,650
당신은
우리가 드린 상자들을 뭔가 바꾸고 있군요.

421
00:16:51,650 --> 00:16:52,150
오른쪽?

422
00:16:52,150 --> 00:16:53,560
이해가 되시나요?

423
00:16:53,560 --> 00:16:54,340
응?

424
00:16:54,340 --> 00:16:56,980
청중: 만약

425
00:16:56,980 --> 00:17:00,610
O(log n)
시간 복잡도로 어떤 작업을 수행하는 알고리즘을 작성하라고 하는데, 우리가 떠올릴 수 있는 알고리즘은

426
00:17:00,610 --> 00:17:03,060


427
00:17:03,060 --> 00:17:03,968
최종 시간 복잡도가 O(n)인 비효율적인 알고리즘뿐이라면 어떨까요?

428
00:17:03,968 --> 00:17:04,510
제이슨 쿠: 알겠습니다.

429
00:17:04,510 --> 00:17:06,470
청중: 그럼
그런 글을 쓰는 게 무슨 의미가 있나요?

430
00:17:06,470 --> 00:17:07,095
제이슨 쿠: 물론이죠.

431
00:17:07,095 --> 00:17:11,589
그럼 잠시 다른 이야기로
넘어가 볼까요?

432
00:17:11,589 --> 00:17:19,430
사실, 저는 곧
당신의 질문에 답변해 드리겠습니다.

433
00:17:19,430 --> 00:17:20,329
좋아요.

434
00:17:20,329 --> 00:17:22,339
하지만 그 이야기는 잠시 후에 하겠습니다
.

435
00:17:22,339 --> 00:17:23,750
좋아요?  5분 안에

436
00:17:23,750 --> 00:17:26,960
제가 그 질문에 답하지 못하면

437
00:17:26,960 --> 00:17:27,619
알려주세요.

438
00:17:27,619 --> 00:17:28,730
좋아요?

439
00:17:28,730 --> 00:17:30,500
그래서 시험 문제를
풀 때

440
00:17:30,500 --> 00:17:33,260

, 저는 먼저

441
00:17:33,260 --> 00:17:35,730

문제에 대해 몇 가지 질문을 던져보려고 합니다.

442
00:17:35,730 --> 00:17:36,230
좋아요.

443
00:17:36,230 --> 00:17:38,360

어떤 걸 사용할지 결정하는 데 도움이 될 거예요.

444
00:17:38,360 --> 00:17:39,260
오른쪽?

445
00:17:39,260 --> 00:17:41,600

당신이 제시한 문제 유형과는 다릅니다.

446
00:17:41,600 --> 00:17:43,610
여러분의 문제 풀이 방식은
기본적으로

447
00:17:43,610 --> 00:17:47,150

그 주 강의에서 다룬 내용을 활용하는 것입니다.

448
00:17:47,150 --> 00:17:49,280
퀴즈에는

449
00:17:49,280 --> 00:17:51,030
여러분이 다룬 8개의 강의 내용이 출제됩니다.

450
00:17:51,030 --> 00:17:52,940
그래서 이 문제는

451
00:17:52,940 --> 00:17:56,030
여러분에게 좀 더 어려울 겁니다. 왜냐하면
8개의 강의 자료 중 어떤 것이

452
00:17:56,030 --> 00:17:57,950

이 문제에 적용될지 알 수 없기 때문입니다.

453
00:17:57,950 --> 00:18:00,020

사실 그 두 가지가 복합적으로 작용한 결과일 수도 있습니다.

454
00:18:00,020 --> 00:18:03,260
그래서 저는
여러분이

455
00:18:03,260 --> 00:18:04,290
그 질문에 더 빨리 답할 수 있는 방법을 알려드리려고 합니다.

456
00:18:04,290 --> 00:18:04,790
좋아요?

457
00:18:04,790 --> 00:18:07,578
그렇다면 이것은
기계적인 감속

458
00:18:07,578 --> 00:18:08,870
문제인가요, 아니면 수정 문제인가요?

459
00:18:08,870 --> 00:18:11,433
그건 제가 이 문제의

460
00:18:11,433 --> 00:18:12,350
난이도를 가늠하는 데 도움이 될 거예요.

461
00:18:12,350 --> 00:18:14,240
당신은 그 질문에
답할 수 없을지도 모릅니다.

462
00:18:14,240 --> 00:18:17,000
하지만
어떤 종류의 문제인지 감을 잡는 데는 도움이 될 수 있습니다.

463
00:18:17,000 --> 00:18:20,840
이 문제는 데이터 구조 정렬과 관련된 문제인가요
?

464
00:18:20,840 --> 00:18:22,460
오른쪽?

465
00:18:22,460 --> 00:18:24,860
데이터 구조에 관한 질문이라면
, 순차적 연산을

466
00:18:24,860 --> 00:18:26,780
지원해야 하는지

467
00:18:26,780 --> 00:18:30,620
아니면
외부적인 순서 정보를 저장해야 하는지 궁금합니다.

468
00:18:30,620 --> 00:18:34,970
아니면 내가
사물 자체에 관심을 갖는 걸까요?

469
00:18:34,970 --> 00:18:37,850
저는 그것들이
무엇인지를 기준으로 찾아보려고 합니다.

470
00:18:37,850 --> 00:18:39,110
아니면 둘 다일까요?

471
00:18:39,110 --> 00:18:40,580
아니면 여러 가지가 복합적으로 작용하는 걸까요?

472
00:18:40,580 --> 00:18:42,920
만약 제가 쿼리를 통해 처리하고 싶은
다양한 유형의 키가 많다면

473
00:18:42,920 --> 00:18:44,900

,

474
00:18:44,900 --> 00:18:48,080
적어도 두 가지
유형의 데이터 구조를 사용해야 할 수도 있습니다.

475
00:18:48,080 --> 00:18:48,588
오른쪽?

476
00:18:48,588 --> 00:18:50,630

이런 것들을 얽히게 하면 굉장히 복잡해질 수 있어요.

477
00:18:50,630 --> 00:18:52,790
하지만 이를 '

478
00:18:52,790 --> 00:18:59,150

이러한 이름들에 대해 이런 종류의 작업을 해야 한다'는 관점에서 설명해 보겠습니다.

479
00:18:59,150 --> 00:19:01,550
그러면 '아, 저기에는
특정 데이터 구조가 필요하겠구나'라고 생각할 수 있죠.  그 방법을

480
00:19:01,550 --> 00:19:03,530
어떻게
실행할지는 나중에 생각해 볼게요.

481
00:19:03,530 --> 00:19:04,490
해시 테이블을 사용해야 할까요?

482
00:19:04,490 --> 00:19:05,657
정렬된 배열을 사용해야 할까요?

483
00:19:05,657 --> 00:19:07,550
AVL 트리를 사용해야 할까요?

484
00:19:07,550 --> 00:19:11,780
하지만 먼저 '

485
00:19:11,780 --> 00:19:15,200
여기에는 특정 데이터 구조가 필요하다'라는 추상적인 수준에서 생각해 보면

486
00:19:15,200 --> 00:19:17,150
정확성과 효율성을 구분하는 데 도움이 될 수 있습니다.

487
00:19:17,150 --> 00:19:18,530
이해가 되시나요?

488
00:19:18,530 --> 00:19:19,610
좋아요.

489
00:19:19,610 --> 00:19:23,480
막히셨다면, 이
질문을 참고하세요.

490
00:19:23,480 --> 00:19:27,590
막히면 비효율적이긴 하지만
올바른 알고리즘을 적어보세요

491
00:19:27,590 --> 00:19:29,540
.  비효율적이지만 올바른 알고리즘에

492
00:19:29,540 --> 00:19:32,000
대해서는 점수를 드릴 수 있습니다

493
00:19:32,000 --> 00:19:32,600
.

494
00:19:32,600 --> 00:19:34,050
적어도
알고리즘 자체는 올바르네요.

495
00:19:34,050 --> 00:19:35,510
그건 다른 것들보다 낫죠.

496
00:19:35,510 --> 00:19:36,470
오른쪽?

497
00:19:36,470 --> 00:19:41,150
만약
시간이 지수적으로 증가한다면, 얻을 수 있는 점수는

498
00:19:41,150 --> 00:19:44,570
10% 또는 20%로 제한될 수도 있습니다
.

499
00:19:44,570 --> 00:19:47,300
하지만 로그 인자라면

500
00:19:47,300 --> 00:19:50,360
더 나쁘고, 선형 인자라면 더 나쁩니다.

501
00:19:50,360 --> 00:19:52,070
어쩌면 괜찮을지도 몰라.

502
00:19:52,070 --> 00:19:56,270
자료구조 문제에서
어떤 연산이 n차 시간 복잡도를 갖는다면

503
00:19:56,270 --> 00:19:59,405
, 그 연산으로는
많은 점수를 얻기 어려울 겁니다.

504
00:19:59,405 --> 00:20:01,280
왜냐하면
자료구조의 핵심은

505
00:20:01,280 --> 00:20:04,520
그
연산들을 빠르게 수행하는 것이기 때문입니다.

506
00:20:04,520 --> 00:20:08,570
하지만 문제가 해결되면
점수를 얻을 수 있을 거예요.

507
00:20:08,570 --> 00:20:10,190
0점을 받지는 않을 거예요.

508
00:20:10,190 --> 00:20:11,000
응?

509
00:20:11,000 --> 00:20:12,458
청중: "이거

510
00:20:12,458 --> 00:20:14,250
얼마나 빨리
만들 수 있어요?" 같은 질문이 나올까요?  최대한

511
00:20:14,250 --> 00:20:15,350
빨리 만들어 주세요.

512
00:20:15,350 --> 00:20:15,975
제이슨 쿠: 네.

513
00:20:15,975 --> 00:20:19,590
그래서 우리는 종종
효율적인 알고리즘을 달라고 요청합니다.

514
00:20:19,590 --> 00:20:20,090
좋아요.  음

515
00:20:20,090 --> 00:20:22,820
, 이게
효율적인지는 잘 모르겠네요.

516
00:20:22,820 --> 00:20:25,170
음, 그건
달리기 기록이 빠를수록

517
00:20:25,170 --> 00:20:26,540
더 많은 점수를 얻게 된다는 뜻이에요.

518
00:20:26,540 --> 00:20:27,110
좋아요?

519
00:20:27,110 --> 00:20:31,580
그런 질문에서는
주로 효율적인 방법을 찾는 것이 중요한데,

520
00:20:34,370 --> 00:20:37,850
일반적으로
데이터 구조 측면에서 효율적인 방법을 제시하지는 않습니다.

521
00:20:37,850 --> 00:20:40,850
왜냐하면
데이터 구조 문제는

522
00:20:40,850 --> 00:20:44,270

구현 시

523
00:20:44,270 --> 00:20:47,180
데이터 구조
연산이 빨라야 한다는 점이 중요하기 때문입니다.

524
00:20:47,180 --> 00:20:50,090
그리고 저희는 그 속도가
얼마나 빠른지 알려드리고 싶습니다.

525
00:20:50,090 --> 00:20:50,630
오른쪽?  일반적으로

526
00:20:50,630 --> 00:20:57,200
데이터 구조 관련 질문에서는

527
00:20:57,200 --> 00:20:59,960


528
00:20:59,960 --> 00:21:01,430
이러한 여러 연산의 실행 시간 사이에 상충 관계가 존재합니다.

529
00:21:01,430 --> 00:21:04,170
그리고
그들이 서로 어떻게 관계를 맺는지도 정말 중요합니다.

530
00:21:04,170 --> 00:21:05,750
그래서 데이터
구조 문제의 경우, 핵심은

531
00:21:05,750 --> 00:21:08,790

실행 시간을 구하는 것입니다.

532
00:21:08,790 --> 00:21:09,290
좋아요?

533
00:21:09,290 --> 00:21:13,310
알고리즘 문제에서,
여러분에게 한 가지 작업을

534
00:21:13,310 --> 00:21:15,590

최대한 빠르게 수행하도록 요청하고,

535
00:21:15,590 --> 00:21:16,610
선형 시간 복잡도를 달성하도록 노력하십시오.

536
00:21:16,610 --> 00:21:17,110
오른쪽?

537
00:21:17,110 --> 00:21:20,570
대부분의 경우 데이터에서 원하는 항목을 찾기 위해 전체 입력값을 읽어야 한다면
선형 시간보다 더 나은 성능을 얻기는 어렵습니다

538
00:21:20,570 --> 00:21:23,660


539
00:21:23,660 --> 00:21:26,180

.

540
00:21:26,180 --> 00:21:28,880

선형 시간 알고리즘이 생각나지 않으면

541
00:21:28,880 --> 00:21:31,940
n 제곱 알고리즘
이나 n log n 알고리즘을 생각해 보세요.

542
00:21:31,940 --> 00:21:32,750
오른쪽?

543
00:21:32,750 --> 00:21:36,950
아마
지금 여러분이 그걸 생각하기엔 좀 어려울지도 모르겠네요.

544
00:21:36,950 --> 00:21:40,987
하지만 제가 말씀드리고 싶은 건, 일단
올바른 알고리즘부터 시작한

545
00:21:40,987 --> 00:21:42,320
다음 최적화를 시도해 보라는 겁니다.  더

546
00:21:42,320 --> 00:21:44,000

나은 데이터 구조를 사용하면

547
00:21:44,000 --> 00:21:45,083
효율성을 높일 수 있을지도 모릅니다.

548
00:21:45,083 --> 00:21:46,920
이해가 되시나요?

549
00:21:46,920 --> 00:21:48,900
다른 질문 있으신가요?

550
00:21:48,900 --> 00:21:50,150
좋아요.  계속해서

551
00:21:50,150 --> 00:21:52,260
.

552
00:21:52,260 --> 00:21:52,760
좋아요.

553
00:21:52,760 --> 00:21:55,490
단점은 다음과 같습니다.

554
00:21:55,490 --> 00:21:56,270
좋아요.

555
00:21:56,270 --> 00:22:00,410
만약 당신이 다음
세 가지 중 하나라도 하고 있다면, 잠시 멈춰 생각해 보세요

556
00:22:00,410 --> 00:22:01,257
.

557
00:22:01,257 --> 00:22:02,840
아마
뭔가 잘못하고 계신 것 같아요.

558
00:22:02,840 --> 00:22:04,070
좋아요?

559
00:22:04,070 --> 00:22:08,060
그러니
소수,

560
00:22:08,060 --> 00:22:10,430
유리수, 아니면 실수 중 무엇을 계산하려는 것인지 스스로에게 질문해 보세요.

561
00:22:10,430 --> 00:22:11,900

그런 것들을 저장할 수는 없어요. 아니

562
00:22:11,900 --> 00:22:15,060
, 소수점은
유한한 정밀도로 저장할 수 있어요.

563
00:22:15,060 --> 00:22:16,710
하지만
유한 정밀도를 사용해야 한다면,

564
00:22:16,710 --> 00:22:21,255
차라리 숫자에
고정된 정밀도를 곱하고

565
00:22:21,255 --> 00:22:22,380
정수를 처리하는 것이 낫습니다.

566
00:22:22,380 --> 00:22:23,340
오른쪽?

567
00:22:23,340 --> 00:22:24,810


568
00:22:24,810 --> 00:22:25,980
이 수업에서는 정수를 다루는 방법만 가르쳐 드렸습니다.

569
00:22:25,980 --> 00:22:26,490
오른쪽?

570
00:22:26,490 --> 00:22:30,180
우리는 아직

571
00:22:30,180 --> 00:22:32,440
유리수와 실수에 대한 효율적인 계산 방법을 보여드리지도 않았습니다.  분수의

572
00:22:32,440 --> 00:22:36,060

분모와 분자가 있다면

573
00:22:36,060 --> 00:22:39,150
,

574
00:22:39,150 --> 00:22:41,430


575
00:22:41,430 --> 00:22:43,140
교차 곱셈을 통해 일정한 시간 안에 두 분수를 비교할 수 있다고 말씀드렸습니다.

576
00:22:43,140 --> 00:22:49,770
하지만 만약 제가 임의의 정밀도
로 나눗셈을 하려고 한다면

577
00:22:49,770 --> 00:22:54,550
, 문제가 발생합니다.
왜냐하면

578
00:22:54,550 --> 00:22:56,550
제
컴퓨터에서 유한한

579
00:22:56,550 --> 00:22:59,850
소수점 자릿수로 표현할 수조차 없기 때문입니다
.

580
00:23:02,670 --> 00:23:05,350

모든 결과에 기수 정렬을 사용하려고 한다면

581
00:23:05,350 --> 00:23:07,620
아마 잘못된 접근 방식일 것입니다.  저희가 퀴즈를 출제할 때 노력하는

582
00:23:07,620 --> 00:23:11,700
것 중 하나는 단순히

583
00:23:11,700 --> 00:23:15,210

문제를 무작위로 내는 것이 아니라는 점입니다.

584
00:23:15,210 --> 00:23:17,010
우리는 아마도

585
00:23:17,010 --> 00:23:19,740
어떤 식으로든 그 내용을 포괄하는 문제를 만들고 있는 것 같습니다.

586
00:23:19,740 --> 00:23:22,350
우리는 당신의
모든 능력을 시험해보고 싶습니다.

587
00:23:22,350 --> 00:23:26,670
따라서 시험에서
같은 표현을

588
00:23:26,670 --> 00:23:29,640
네다섯 번씩 사용하게 된다면
,

589
00:23:29,640 --> 00:23:33,300

너무 자주 사용하고 있다는 신호일 수 있습니다.

590
00:23:33,300 --> 00:23:34,342
항상 그런 것은 아닙니다.

591
00:23:34,342 --> 00:23:34,842
오른쪽?

592
00:23:34,842 --> 00:23:36,360
해싱이
매우 유용할 때가 있어서, 항상

593
00:23:36,360 --> 00:23:38,140
사용하고 싶을 때도 있습니다
.

594
00:23:38,140 --> 00:23:41,940
하지만 특히,
모두가 적절하지 않은

595
00:23:41,940 --> 00:23:45,090
상황에서도 기수 정렬을 사용하려고 합니다
.

596
00:23:45,090 --> 00:23:48,300
그리고 사람들이 좋아하는 이유는
시간이 순차적으로 흘러가기 때문입니다.

597
00:23:48,300 --> 00:23:49,140
오른쪽?

598
00:23:49,140 --> 00:23:55,080
하지만
기수 정렬이

599
00:23:55,080 --> 00:23:57,840
적용될 수 있는 문제에 병합 정렬을 작성하면, 비록 효율적이지는 않지만 올바른 방법이기 때문에 점수를 얻을 수 있을 것입니다

600
00:23:57,840 --> 00:24:01,080
.

601
00:24:01,080 --> 00:24:03,370
그리고 효율성은
로그 인자만큼 비효율적입니다.

602
00:24:03,370 --> 00:24:04,530
오른쪽?  정수 크기에 제한이 없는

603
00:24:04,530 --> 00:24:08,790

상황에서 비교 연산을 통해 정렬을 수행하려고 할 때, 즉

604
00:24:08,790 --> 00:24:11,340


605
00:24:11,340 --> 00:24:13,770


606
00:24:13,770 --> 00:24:15,330

정수 크기에 제한이 없다면

607
00:24:15,330 --> 00:24:19,380

엄청난 시간이 소요될 수 있습니다.

608
00:24:19,380 --> 00:24:21,870
그래서 저는 그것이

609
00:24:21,870 --> 00:24:26,095

기하급수적인 시간이 걸릴 수 있기 때문에 그것이 옳다고 생각조차 하지 않을 수도 있습니다.

610
00:24:26,095 --> 00:24:26,970
글쎄요, 저도 잘 모르겠어요.

611
00:24:26,970 --> 00:24:28,512

내 단어 크기가 얼마나 되는지 모르겠어요.

612
00:24:28,512 --> 00:24:30,850
그것은 임의로 나빠질 수 있다.

613
00:24:30,850 --> 00:24:32,340
좋아요.

614
00:24:32,340 --> 00:24:34,170
그리고 만약 이진

615
00:24:34,170 --> 00:24:37,470
트리에
서브트리 속성이 아닌 것, 즉 두 자식 트리의 속성

616
00:24:37,470 --> 00:24:40,350

확장을 통해 계산할 수 없는 것을 추가하려고 한다면,

617
00:24:41,730 --> 00:24:43,050
뭔가 잘못된 것입니다.

618
00:24:43,050 --> 00:24:48,240
매 시험마다
학생들의 30% 정도가 전체 트리

619
00:24:48,240 --> 00:24:58,410
에서 내 인덱스만큼 증강하거나,

620
00:24:58,410 --> 00:25:00,150
재미있는 예시로

621
00:25:00,150 --> 00:25:03,195

왼쪽 서브트리의 크기, 즉

622
00:25:07,090 --> 00:25:09,610

왼쪽 서브트리에 있는 노드 수만큼 증강하라고 답합니다.

623
00:25:09,610 --> 00:25:10,390
어떻게 해야 할까요?

624
00:25:14,010 --> 00:25:17,920

교대 근무

625
00:25:17,920 --> 00:25:20,420
같은 걸 고려하면 어떻게 유지해야 할지 잘 모르겠어요.  어디 보자

626
00:25:20,420 --> 00:25:21,700
.

627
00:25:21,700 --> 00:25:24,910


628
00:25:24,910 --> 00:25:30,430
왼쪽 트리의 확장을 추적하려면, 전체 트리를

629
00:25:30,430 --> 00:25:33,310
로그 스케일로 탐색하여 각 트리에

630
00:25:33,310 --> 00:25:35,260
얼마나 많은
요소가 있는지 파악해야 합니다.

631
00:25:35,260 --> 00:25:37,540
그러니까 그건 상수 시간으로 유지 관리하기 어려운 거죠
.

632
00:25:37,540 --> 00:25:39,910

왼쪽 서브트리의 특정 항목을 확장하고 싶다면, 해당

633
00:25:39,910 --> 00:25:42,910
항목 자체를 확장한 다음

634
00:25:42,910 --> 00:25:45,250
왼쪽 서브트리와
그 확장된 내용을 확인하면 됩니다.

635
00:25:45,250 --> 00:25:46,720
이해가 되시나요?

636
00:25:46,720 --> 00:25:47,252
응?

637
00:25:47,252 --> 00:25:49,460
청중: 예를 들어,
서브트리를 추가하고, 그 위에

638
00:25:49,460 --> 00:25:52,030
또 다른
서브트리를 추가한 다음,

639
00:25:52,030 --> 00:25:52,240
그걸 사용하면 어떨까요?

640
00:25:52,240 --> 00:25:53,240
제이슨 쿠: 네, 그렇게 할 수 있습니다.

641
00:25:53,240 --> 00:25:53,920
관객: --그것도
여전히 해당되나요--

642
00:25:53,920 --> 00:25:54,670
제이슨 쿠: 네, 그렇게 하셔도 됩니다.

643
00:25:54,670 --> 00:25:55,010
응.

644
00:25:55,010 --> 00:25:56,552
따라서

645
00:25:56,552 --> 00:25:58,750
서브트리 크기를 증가시키면 상수 시간 내에 이를 수행할 수 있습니다.

646
00:25:58,750 --> 00:25:59,470
오른쪽?

647
00:25:59,470 --> 00:26:01,360
청중: 그리고
[알아들을 수 없는 부분]에 또 다른 확장 기능을 추가해 주세요.

648
00:26:01,360 --> 00:26:03,943
제이슨 쿠:
확장 기능을 추가하면

649
00:26:03,943 --> 00:26:06,580

왼쪽 하위 트리를 살펴볼 수 있습니다

650
00:26:06,580 --> 00:26:07,350
.

651
00:26:07,350 --> 00:26:08,473
응.

652
00:26:08,473 --> 00:26:09,640
다시 저장할 이유가 없습니다.

653
00:26:09,640 --> 00:26:10,140
오른쪽?  그냥

654
00:26:10,140 --> 00:26:12,070
한 가지만 꾸준히 하세요.

655
00:26:12,070 --> 00:26:13,570
왼쪽을 보세요.

656
00:26:13,570 --> 00:26:14,410
좋아요.  그러지 마세요

657
00:26:14,410 --> 00:26:15,830
.

658
00:26:15,830 --> 00:26:16,450
좋아요.  그건

659
00:26:16,450 --> 00:26:19,310
멋지네요.  저도 그렇게 뒤처지지는

660
00:26:19,310 --> 00:26:20,740
않아요.

661
00:26:20,740 --> 00:26:25,540
이것들이 제가
문제를 푸는 데 도움이 되는 팁입니다.

662
00:26:25,540 --> 00:26:26,830
아, 한 페이지 더 있네요.

663
00:26:26,830 --> 00:26:27,330
응?

664
00:26:27,330 --> 00:26:29,270
청중: 그러니까
증강을 정의할 때,

665
00:26:29,270 --> 00:26:32,470
[알아들을 수 없는 부분] 공식을 만들고
그것이 [알아들을 수 없는 부분]이라고 주장하는 거죠...

666
00:26:32,470 --> 00:26:33,220
제이슨 쿠: 맞습니다.

667
00:26:33,220 --> 00:26:33,720
오른쪽.

668
00:26:33,720 --> 00:26:41,320
그러니까 핵심은, 표준적인 것들로 축소할 수
없는 증강을 제공한다면, 그 증강은… 잠시 후에

669
00:26:41,320 --> 00:26:43,210

표준적인 것들로

670
00:26:43,210 --> 00:26:45,460
축소할 수 있는 것에 대해 이야기해 보겠습니다.

671
00:26:45,460 --> 00:26:49,390
만약 당신이 "
세트 AVL

672
00:26:49,390 --> 00:26:52,990
트리나 시퀀스 AVL 트리를 사용하겠다"라고 말한다면,

673
00:26:52,990 --> 00:26:55,130
예를 들어
강의 말미에

674
00:26:55,130 --> 00:26:59,530
우리는
시퀀스 AVL 트리를

675
00:26:59,530 --> 00:27:02,260
수정하여

676
00:27:02,260 --> 00:27:05,650

이진 힙과 동일한 실행 시간으로 우선순위 큐 연산을 지원하는 방법에 대해 이야기했습니다.

677
00:27:05,650 --> 00:27:06,190
오른쪽?

678
00:27:06,190 --> 00:27:10,150
그리고 그건 우리가
서브트리의 최댓값, 즉

679
00:27:10,150 --> 00:27:12,490
내 서브트리의 최댓값을 저장한다는 뜻이었어요.

680
00:27:12,490 --> 00:27:14,800
오른쪽?

681
00:27:14,800 --> 00:27:16,660
그래서 이는

682
00:27:16,660 --> 00:27:20,960

시퀀스 AVL 트리에 이미 적용된 것과는 다른 확장입니다.

683
00:27:20,960 --> 00:27:25,400

시퀀스 AVL 트리에 대한 증강은 무엇인가요?

684
00:27:25,400 --> 00:27:26,320
대상 고객: 규모.

685
00:27:26,320 --> 00:27:27,444
제이슨 쿠: 크기.

686
00:27:27,444 --> 00:27:29,038
청중: 카운트.

687
00:27:29,038 --> 00:27:31,330
제이슨 쿠: 그러니까 counts는

688
00:27:31,330 --> 00:27:32,080
내 서브트리에 있는 노드의 개수와 같은 의미입니다.

689
00:27:32,080 --> 00:27:32,590
그리고?

690
00:27:32,590 --> 00:27:33,100
대상: 키.

691
00:27:33,100 --> 00:27:33,808
제이슨 쿠: 키.

692
00:27:33,808 --> 00:27:35,410
네, AVL 트리이기 때문입니다.

693
00:27:35,410 --> 00:27:36,730
오른쪽?

694
00:27:36,730 --> 00:27:40,690
그러니까 만약 제가
서브트리에서 최댓값으로 확장을 한다면,

695
00:27:40,690 --> 00:27:43,210
그건 제 표준 인터페이스의 일부가 아닙니다
.

696
00:27:43,210 --> 00:27:44,595
그러니까 그걸 저한테 말해줘야 해요.

697
00:27:44,595 --> 00:27:45,970

전에 해본 적이 있지만,

698
00:27:45,970 --> 00:27:47,710
당신에게는 아주 쉬울 거예요.  그냥 제가 가진

699
00:27:47,710 --> 00:27:49,930

최대치만큼 증강하고 있다고 말해주세요.

700
00:27:49,930 --> 00:27:53,260
최대값은
나와

701
00:27:53,260 --> 00:27:55,300
내 왼쪽 및 오른쪽
서브트리가 존재하는 경우, 이들 중 최댓값으로 계산할 수 있습니다.

702
00:27:55,300 --> 00:27:55,840
완료.

703
00:27:55,840 --> 00:27:56,620
오른쪽?

704
00:27:56,620 --> 00:27:58,270
하지만 그냥 그렇게 하세요.

705
00:27:58,270 --> 00:27:59,560
저에게 알려주셔야 해요.

706
00:27:59,560 --> 00:28:01,270
그리고 그 과정은
일정한 시간이 걸리기 때문에

707
00:28:01,270 --> 00:28:05,450

제가 제 일을 하는 동안 일정한 시간을 유지할 수 있도록 해야 합니다.

708
00:28:05,450 --> 00:28:07,840
이해가 되시나요?

709
00:28:07,840 --> 00:28:08,560
좋아요.

710
00:28:08,560 --> 00:28:11,470
마지막으로,
특히

711
00:28:11,470 --> 00:28:14,380
자료
구조 문제에 있어서는 인터페이스 관점에서 먼저

712
00:28:14,380 --> 00:28:17,380


713
00:28:17,380 --> 00:28:23,000
문제를 풀어보는 접근 방식을 추천합니다

714
00:28:23,000 --> 00:28:24,250
.

715
00:28:24,250 --> 00:28:27,370
그러면 적어도
정확한 결과를 얻을 수 있으니까요.

716
00:28:27,370 --> 00:28:31,210
그런 다음 해당 인터페이스를 구현하는 데 사용할
알고리즘이나 데이터 구조를 선택합니다

717
00:28:31,210 --> 00:28:35,140

.

718
00:28:35,140 --> 00:28:37,280
하나는
올바른 알고리즘으로 이어집니다.

719
00:28:37,280 --> 00:28:39,070
다른 하나는 효율성을 위한 것입니다.

720
00:28:39,070 --> 00:28:42,070
이들을 분리하면
문제 해결에 도움이 될 수 있습니다.

721
00:28:42,070 --> 00:28:45,290
도움이 되지 않으면 하지 마세요.

722
00:28:45,290 --> 00:28:48,310
만약 당신이 "
특정 데이터 구조를 보면

723
00:28:48,310 --> 00:28:53,710
해시
테이블을 사용할 것 같다"라고 생각한다면, 그것도 괜찮을 겁니다.

724
00:28:53,710 --> 00:28:55,900
하지만
최악의 경우를 가정한 시간 범위를 찾는다면,

725
00:28:55,900 --> 00:28:57,300
아마 즐거운 일은 아닐 겁니다.

726
00:28:57,300 --> 00:28:58,990
그러니까 제가

727
00:29:02,090 --> 00:29:07,300
제안하는 건,
이런 것들을 분리해서 먼저 문제

728
00:29:07,300 --> 00:29:08,980
해결에 집중하고

729
00:29:08,980 --> 00:29:10,240
나중에 최적화하는 겁니다.

730
00:29:10,240 --> 00:29:10,960
응?

731
00:29:10,960 --> 00:29:12,510
청중:
최악의 경우 예상 소요

732
00:29:12,510 --> 00:29:13,030
시간에 대해 질문드립니다.

733
00:29:13,030 --> 00:29:13,750
제이슨 쿠: 음흠.

734
00:29:13,750 --> 00:29:15,140
청중: 그럼 해시 테이블의 경우를 예로 들어볼까요?

735
00:29:15,140 --> 00:29:15,580
제이슨 쿠: 음흠.

736
00:29:15,580 --> 00:29:16,705
청중: 그건
예상했던 코드잖아요.

737
00:29:16,705 --> 00:29:17,920
제이슨 쿠: 음흠.

738
00:29:17,920 --> 00:29:20,227
청중: 그건
최악의 경우 O/n이라는 뜻이기도 하네요.

739
00:29:20,227 --> 00:29:21,310
그렇다면 당신은 --엄밀히 말하면

740
00:29:21,310 --> 00:29:22,643
제이슨 쿠: 그건 그런 의미가 아니에요.  바로 그

741
00:29:22,643 --> 00:29:24,160
거예요.

742
00:29:24,160 --> 00:29:26,770
그러니까,

743
00:29:26,770 --> 00:29:30,130
예상 시간 복잡도가 상수인 데이터 구조가 있을 수 있지만,
최악의 경우 시간 복잡도는

744
00:29:30,130 --> 00:29:31,400
n log n이 될 수 있다는 거죠.  단지

745
00:29:31,400 --> 00:29:34,720

해시 테이블의 경우

746
00:29:34,720 --> 00:29:37,990
최악의 경우
연산 속도가 선형적이라는 사실일 뿐입니다.

747
00:29:37,990 --> 00:29:41,740
하지만 만약 우리가
미리 이런 질문을 받았다면,

748
00:29:41,740 --> 00:29:45,190
예를 들어

749
00:29:45,190 --> 00:29:51,040
해시 테이블에서 어떤 작업을 상수
예상 시간 내에 수행하고, 조회를 하고,

750
00:29:51,040 --> 00:29:56,020
AVL 트리에서
노드의 이전 노드를 쿼리하는 등의 작업을

751
00:29:56,020 --> 00:29:58,030


752
00:29:58,030 --> 00:30:03,850
O log n 시간 내에 수행한다고 가정했을 때,
최악의 경우 실행

753
00:30:03,850 --> 00:30:04,420
시간은 얼마일까요?

754
00:30:04,420 --> 00:30:05,320
청중: n의 O.

755
00:30:05,320 --> 00:30:07,090
제이슨 쿠: O of n.

756
00:30:07,090 --> 00:30:09,977

이 제품의 예상 작동 시간은 얼마나 되나요?

757
00:30:09,977 --> 00:30:11,440
청중: 로그 번호

758
00:30:11,440 --> 00:30:12,610
제이슨 쿠: 로그 n.

759
00:30:12,610 --> 00:30:14,050
예상 로그 n.

760
00:30:14,050 --> 00:30:15,920

최악의 경우 더

761
00:30:15,920 --> 00:30:16,712
높을 수도 있기 때문입니다.

762
00:30:16,712 --> 00:30:18,810
이해가 되시나요?

763
00:30:18,810 --> 00:30:19,310
좋아요.

764
00:30:23,960 --> 00:30:25,370
--그래, 괜찮아.

765
00:30:25,370 --> 00:30:29,030
두 번째 항목은
데이터 구조

766
00:30:29,030 --> 00:30:29,680
문제를 설정하는 것에 불과합니다.

767
00:30:29,680 --> 00:30:31,175
여러 가지 요소들이 복합적으로 작용합니다.

768
00:30:31,175 --> 00:30:33,050


769
00:30:33,050 --> 00:30:35,810
이번 수업 마지막에 자료구조 문제 두 개를 풀겠습니다.  사용하고 있는

770
00:30:35,810 --> 00:30:41,120
모든 데이터
구조와 각 구조에

771
00:30:41,120 --> 00:30:42,620
저장되는 내용을 설명하십시오.

772
00:30:42,620 --> 00:30:44,510
만약
특정 데이터 구조를 저장하고 있다면,

773
00:30:44,510 --> 00:30:47,150

저장된 요소들이 어떤

774
00:30:47,150 --> 00:30:49,340
키로 연결되어 있는지 알려주는 것이 좋습니다.

775
00:30:49,340 --> 00:30:51,170
일반적으로
우리가 저장하는 데이터에는

776
00:30:51,170 --> 00:30:53,450
많은
정보가 담겨 있습니다. 그런데 만약 "

777
00:30:53,450 --> 00:30:57,920

피자 토핑을 모두

778
00:30:57,920 --> 00:31:01,323
set 데이터 구조에 저장하고 있어요"라고만 말하고 그 외에는 아무것도
알려주지 않는다면, 저는 그 데이터 구조의 의미론을 모르기 때문에

779
00:31:01,323 --> 00:31:02,990
무슨 말인지 전혀 이해할 수 없습니다

780
00:31:02,990 --> 00:31:04,940


781
00:31:04,940 --> 00:31:05,523
.

782
00:31:05,523 --> 00:31:06,830
무엇에 초점을 맞추고 있나요?

783
00:31:06,830 --> 00:31:09,260

음, 잘 모르겠네요.

784
00:31:09,260 --> 00:31:14,140
y 같은 건 잘 모르겠어요
.

785
00:31:14,140 --> 00:31:14,930
좋아요.

786
00:31:14,930 --> 00:31:16,140
그리고 불변량이 존재합니다.

787
00:31:16,140 --> 00:31:18,920
이러한
데이터 구조 문제를 어떻게 설정하는지, 제가

788
00:31:18,920 --> 00:31:22,880
보통
해결책을 작성할 때 사용하는 방식은 특정 시점에서 해당 데이터 구조가

789
00:31:22,880 --> 00:31:28,250
어떤 상태일 수 있는지를 설정하는 것입니다

790
00:31:28,250 --> 00:31:29,600
.

791
00:31:29,600 --> 00:31:31,880
제가 말씀드리자면,
이 데이터 구조는 키가 k 미만인

792
00:31:31,880 --> 00:31:35,090
모든 항목을 저장합니다

793
00:31:35,090 --> 00:31:37,340

.

794
00:31:37,340 --> 00:31:41,600
그리고 이것은 어쩌고저쩌고를 기준으로 항목들의 외적 순서를 저장합니다

795
00:31:41,600 --> 00:31:45,320

.

796
00:31:45,320 --> 00:31:46,100
좋아요.

797
00:31:46,100 --> 00:31:50,450
그러니까 사실, 제가
그들이 무엇을 저장하는지 그런 식으로 명시하는 것은 제가 유지 관리하려는

798
00:31:50,450 --> 00:31:53,690

이러한 데이터 구조에 일종의 불변 조건을 부과하는 것과 같습니다

799
00:31:53,690 --> 00:31:56,480

.

800
00:31:56,480 --> 00:31:59,150
하지만
이것이 옳다는 것을 증명하기 위해 제가 해야 할 일은 수술 전에

801
00:31:59,150 --> 00:32:04,280

그러한 불변 조건들이 성립했다는 가정에 근거한 것입니다

802
00:32:04,280 --> 00:32:07,820
.

803
00:32:07,820 --> 00:32:09,920
그러면 해당
연산이 올바른지 여부를 연산 전후에

804
00:32:09,920 --> 00:32:15,620
모든 불변 조건이
유지되는지를 통해 증명할 수 있습니다

805
00:32:15,620 --> 00:32:16,920
.

806
00:32:16,920 --> 00:32:19,610
그게 바로 제가
이 주장이 옳다는 것을 증명하는 방식입니다.

807
00:32:19,610 --> 00:32:22,100
그리고 제가 쿼리를 실행하거나

808
00:32:22,100 --> 00:32:25,280
이 데이터 구조에 대한 조회를 할 때,
이러한 불변 조건들을 신뢰할 수 있습니다.

809
00:32:25,280 --> 00:32:27,460
저는 그런
것들이 괜찮고 잘

810
00:32:27,460 --> 00:32:29,780

관리되어 왔다는 것을 알고 있기 때문에, 그것들을 바탕으로

811
00:32:29,780 --> 00:32:32,420


812
00:32:32,420 --> 00:32:34,250
이 항목의 최대 k 값이 무엇인지 찾아볼 수 있습니다.

813
00:32:34,250 --> 00:32:35,408
이해가 되시나요?

814
00:32:35,408 --> 00:32:36,950
이 내용이 너무
추상적으로 느껴진다면, 잠시 후

815
00:32:36,950 --> 00:32:40,650
좀 더
구체적으로 설명해 드리겠습니다.

816
00:32:40,650 --> 00:32:44,060
그런 다음
모든 작업을 실행합니다.

817
00:32:44,060 --> 00:32:45,950


818
00:32:45,950 --> 00:32:50,570
퀴즈에서 우리가 얼마나 많은 풀이를 읽어봤는지 당신은 상상도 못 할 거예요.
우리가

819
00:32:50,570 --> 00:32:55,400
세 가지 연산을 구현하라고 했는데,
당신은 그중 하나도 언급하지 않았잖아요.

820
00:32:55,400 --> 00:32:57,260
그리고 대개 가장
쉬운 방법이죠.  마치

821
00:32:57,260 --> 00:32:59,990

데이터 구조에 삽입된 것과 같습니다.  아니

822
00:32:59,990 --> 00:33:02,330

, 그냥 그렇게 말해 버려.  해당 수술을 언급하지

823
00:33:02,330 --> 00:33:05,630
않으시면 포인트를 드릴 수 없습니다
.

824
00:33:05,630 --> 00:33:07,480
이해가 되시나요?

825
00:33:07,480 --> 00:33:10,520
그러면 저희

826
00:33:10,520 --> 00:33:12,740
채점자들이 더 높은 점수를 드릴 수 있도록 도움이 될 거예요.  꼭 그렇지는 않지만,

827
00:33:12,740 --> 00:33:17,840

풀이 과정이

828
00:33:17,840 --> 00:33:21,200
잘 정리되어 있고, 각 부분에 라벨이 잘 붙어 있는 등 보기 좋게 구성되어 있다면,

829
00:33:21,200 --> 00:33:24,760
저희가
풀이를 더 잘 이해하고

830
00:33:24,760 --> 00:33:26,510

더 높은 점수를 드릴 수 있을 겁니다.

831
00:33:26,510 --> 00:33:30,510
이 수업의 일부는
소통에 관한 것임을 명심하세요.

832
00:33:30,510 --> 00:33:37,040
당신이 제시한 내용이 맞더라도 우리가
당신이 무슨 말을 하는지 알아들을 수 없다면,

833
00:33:37,040 --> 00:33:38,035
그것은 틀린 것입니다.

834
00:33:42,020 --> 00:33:44,280
좋아요.

835
00:33:44,280 --> 00:33:44,780
괜찮은.  자, 그럼

836
00:33:44,780 --> 00:33:48,470
이제 질문 시간입니다. 질문 있으신가요
?

837
00:33:48,470 --> 00:33:49,242
응.

838
00:33:49,242 --> 00:33:51,020
청중:
불변량에 대한 질문입니다.

839
00:33:51,020 --> 00:33:52,760


840
00:33:52,760 --> 00:33:54,135

수업 시간에 이전에 논의했던 데이터 구조 중 하나로, 불변 조건이

841
00:33:54,135 --> 00:33:55,750
무엇인지 명시하는 데 사용되는

842
00:33:55,750 --> 00:33:57,243
AVL 트리 규칙과 같은 것이 있습니다.

843
00:33:57,243 --> 00:33:57,910
제이슨 쿠: 맞습니다.

844
00:33:57,910 --> 00:33:59,950
그러니까
일반적인 것들에 대해 이야기하자면,

845
00:33:59,950 --> 00:34:04,240

지금 일반적인 것들이 무엇인지에 대해 이야기해 보려고 했던 거죠.

846
00:34:04,240 --> 00:34:07,330
그러면
다시 논쟁하거나 재진술할 필요가 없습니다.

847
00:34:07,330 --> 00:34:10,600
즉,

848
00:34:10,600 --> 00:34:14,962
집합 및 순서
인터페이스가

849
00:34:14,962 --> 00:34:16,420
그렇게 정의되어 있으므로 이러한
것들이 올바르다고 말할 수 있습니다. 거의 그렇게 할 수 있습니다. 기본적으로 왜

850
00:34:16,420 --> 00:34:22,000


851
00:34:22,000 --> 00:34:25,719

그것이 올바른지 우리를 설득하려는 것입니다.

852
00:34:25,719 --> 00:34:28,600


853
00:34:28,600 --> 00:34:32,710
이러한 데이터
구조 유형 문제에서 집합 또는 순차 데이터 구조를 올바르게 사용하고 있다면, 특이한 방식으로

854
00:34:32,710 --> 00:34:38,239
사용하지 않는 한 일반적으로 앞에서

855
00:34:38,239 --> 00:34:41,080


856
00:34:41,080 --> 00:34:43,790

제시한 집합 및 순차 데이터 구조의 속성에 의존하면 됩니다.  당신이

857
00:34:43,790 --> 00:34:48,070

정확성에 대해 고민했다는 점을 언급해 주셨으면 합니다.

858
00:34:48,070 --> 00:34:54,790
이러한 데이터 구조가
올바른 이유는 다음과 같습니다.  그 내용을 한 문장으로 적고,

859
00:34:54,790 --> 00:34:58,840


860
00:34:58,840 --> 00:35:01,480


861
00:35:01,480 --> 00:35:03,460

데이터 구조의 불변성을

862
00:35:03,460 --> 00:35:04,960
상위 수준에서 유지하고 있다는 점을 논리적으로 설명하세요.

863
00:35:04,960 --> 00:35:08,590

이 데이터 구조는 어떤 종류의 데이터를 저장하나요?  쿼리 작업을 수행하기 위해 전역 데이터 구조

864
00:35:08,590 --> 00:35:14,320
의 어떤 부분을

865
00:35:14,320 --> 00:35:16,900
활용하고 있습니까
?  데이터 구조를 수정하는

866
00:35:16,900 --> 00:35:22,000

동적 연산 후에도 여전히 만족되는 불변 조건

867
00:35:22,000 --> 00:35:25,210

들이

868
00:35:25,210 --> 00:35:29,830
그대로 유지된다는 것을 설득력 있게 보여줄 수 있다면, 그것으로 충분합니다

869
00:35:29,830 --> 00:35:32,770

.

870
00:35:32,770 --> 00:35:36,160
이러한 불변 조건은

871
00:35:36,160 --> 00:35:39,670
집합
및 순차 데이터 구조의 정의 때문에 충족됩니다.

872
00:35:39,670 --> 00:35:42,550
대부분의 경우
깊이 생각할 필요가 없습니다.

873
00:35:42,550 --> 00:35:45,310


874
00:35:45,310 --> 00:35:48,850
우리가 환원
문제를 푸는 이유는 여러분이 그 답이 옳다는 것을 증명하기 위해

875
00:35:48,850 --> 00:35:51,490
많은 노력을 기울이지 않아도 되도록 하기 위함입니다

876
00:35:51,490 --> 00:35:52,480
.

877
00:35:52,480 --> 00:35:54,610
저희는 아주
멋진 검은색 상자들을 가지고 있습니다.

878
00:35:54,610 --> 00:35:55,480
그들의 말이 맞습니다.

879
00:35:55,480 --> 00:35:57,970
우리는 그것들이
옳다는 것을 증명했으니,

880
00:35:57,970 --> 00:36:01,480
당신은
그 작업을 다시 할 필요가 없습니다.  자,

881
00:36:01,480 --> 00:36:07,420
이제

882
00:36:07,420 --> 00:36:09,610
이 수업에서 제가 중요하게 생각하는 핵심 내용을 살펴보겠습니다.  이 수업

883
00:36:09,610 --> 00:36:11,350
의 첫 부분은
, 수업 초반에

884
00:36:11,350 --> 00:36:16,960

다뤘던 수학적 도구들을 제외하고는,

885
00:36:16,960 --> 00:36:18,460


886
00:36:18,460 --> 00:36:21,670
주로
자료 구조와 관련된 문제들을 해결하는 데 중점을 둡니다.

887
00:36:21,670 --> 00:36:24,310
우리는

888
00:36:24,310 --> 00:36:27,070
정렬된 배열이

889
00:36:27,070 --> 00:36:28,720
실제로 매우 유용한 데이터 구조라는 점을 들어 정렬 문제를 제기했습니다.

890
00:36:28,720 --> 00:36:31,030
하지만 그런 것들을 어떻게 정리해야 할까요?  네

891
00:36:31,030 --> 00:36:35,350
, 저희는 그 방법을
여러 가지 보여드렸습니다.

892
00:36:35,350 --> 00:36:37,900
그리고 이게 바로 그 멋진 테이블입니다.

893
00:36:37,900 --> 00:36:40,540
많은 것들.

894
00:36:40,540 --> 00:36:42,500
왜 이렇게
많은 정렬 알고리즘을 보여드리는 걸까요?

895
00:36:42,500 --> 00:36:45,694

알고리즘 하나만 드리면 안 될까요?

896
00:36:45,694 --> 00:36:46,790
흠?

897
00:36:46,790 --> 00:36:47,290
응?

898
00:36:47,290 --> 00:36:49,270
관객: --실행 시간.

899
00:36:49,270 --> 00:36:50,830
제이슨 쿠: 실행 시간이 다릅니다.

900
00:36:50,830 --> 00:36:51,850
청중: 상황에 따라 더 적합 --다른

901
00:36:51,850 --> 00:36:52,915
제이슨 쿠: 상황에 따라 더 적합
.

902
00:36:52,915 --> 00:36:53,260
청중: 네.

903
00:36:53,260 --> 00:36:55,107
그들 각자는
개별적인 강점을 가지고 있으며,

904
00:36:55,107 --> 00:36:55,940
그렇게 할 때 더 나은 성과를 냅니다.

905
00:36:55,940 --> 00:36:56,565
제이슨 쿠: 네.

906
00:36:56,565 --> 00:37:00,820

이 표를 보시면 아시겠지만,

907
00:37:00,820 --> 00:37:05,260

이 항목들 중 어느 것도 전체가 파란색으로 표시된 경우는 없습니다.

908
00:37:05,260 --> 00:37:07,720
그래서 어떤 것들은
상황에 따라 더 적합한 경우가 있습니다.

909
00:37:07,720 --> 00:37:12,250
그리고 실제로, 이 댓글들은 이러한 방식이 더 나을 수 있는
몇 가지 특별한 경우를 나열하고 있습니다

910
00:37:12,250 --> 00:37:14,200
.

911
00:37:14,200 --> 00:37:17,920
실제로 이
극도로 파란색인 것은 마치

912
00:37:17,920 --> 00:37:20,710

시간이 선형적으로 흐를 수도 있다는 것을 암시하는 것 같습니다.

913
00:37:20,710 --> 00:37:22,270
그게 더 낫네요.

914
00:37:22,270 --> 00:37:26,470
하지만 어떤 경우에는 이것이
다른 모든 것보다 더 나쁠 수 있습니다.

915
00:37:26,470 --> 00:37:31,570
그러니 이 파란색에 조금 주의하세요
.

916
00:37:31,570 --> 00:37:35,620
일반적으로 저희는
여러분이 이 차트에서 더 아래쪽에 위치하도록 도와드리려고 합니다

917
00:37:35,620 --> 00:37:37,900
.

918
00:37:37,900 --> 00:37:45,100
일반적으로
병합 정렬이나 AVL 정렬 같은

919
00:37:45,100 --> 00:37:48,580
것들은 점근
적 복잡도나

920
00:37:48,580 --> 00:37:51,460

정렬 과정 자체와 상호작용하는 방식 면에서 거의 동일합니다

921
00:37:51,460 --> 00:37:53,110
.

922
00:37:53,110 --> 00:37:54,910
하지만

923
00:37:54,910 --> 00:37:58,900
삽입 정렬
이나 선택 정렬을 사용할 수 있는 특별한 경우가 있습니다. 사실

924
00:37:58,900 --> 00:38:01,450

삽입 정렬에 대해서는 잘 모르겠습니다.

925
00:38:01,450 --> 00:38:07,750

이틀 전 발표 시간에

926
00:38:07,750 --> 00:38:11,350
여러분들이 서로 k개 이내의 거리에 있는 요소들로 이루어진 k-근접 배열을
어떻게 처리하는지 보여주셨던 것 같아요

927
00:38:11,350 --> 00:38:14,890


928
00:38:14,890 --> 00:38:16,450
.

929
00:38:16,450 --> 00:38:18,643
삽입 정렬은 실제로
n 곱하기 k의 시간 복잡도로 실행되므로,

930
00:38:18,643 --> 00:38:20,560
k가 작으면 매우
효율적이며 거의

931
00:38:20,560 --> 00:38:22,390
선형적인 실행 시간을 보입니다.

932
00:38:22,390 --> 00:38:24,640
하지만 실제로 이진 힙을 사용하면
훨씬 더 나은 결과를 얻을 수 있습니다.

933
00:38:24,640 --> 00:38:28,270

수업 시간에 배웠듯이, 이진 힙을 사용하면 힙을 계속

934
00:38:28,270 --> 00:38:32,470

유지하면서 최대값을 찾아 n log k까지 줄일 수 있습니다

935
00:38:32,470 --> 00:38:37,840

.

936
00:38:37,840 --> 00:38:40,780
그래서 삽입 정렬은
그다지 좋은 방법이 아닐 수도 있습니다.

937
00:38:40,780 --> 00:38:43,840
하지만 선택 정렬의
핵심은

938
00:38:43,840 --> 00:38:50,290

읽기 속도는 저렴

939
00:38:50,290 --> 00:38:54,120
하지만 쓰기 속도는
비싼 경우, 선택 정렬이

940
00:38:54,120 --> 00:38:56,670
실제로 꽤
잘 작동한다는 것입니다. 왜냐하면 제가 가진 것은...

941
00:38:56,670 --> 00:38:57,540
죄송합니다.

942
00:38:57,540 --> 00:39:00,450
읽는 건 싸지만, 내가
쓰는 건 비싸다.

943
00:39:00,450 --> 00:39:02,675
선택 정렬은
선형적인 횟수의 교환을 수행합니다.  아래를 내려다보고

944
00:39:02,675 --> 00:39:04,800
,
최대치를 찾아내고, 그것을 교체하고, 계속

945
00:39:04,800 --> 00:39:06,240
나아가게 하는 것입니다.

946
00:39:06,240 --> 00:39:08,460
그래서 그런 경우에는
실제로

947
00:39:08,460 --> 00:39:11,770

우리가 가진 다른 알고리즘들보다 그 방법이 더 낫습니다.

948
00:39:11,770 --> 00:39:12,270
응?

949
00:39:12,270 --> 00:39:13,464
청중: 저것들 분류하기...

950
00:39:13,464 --> 00:39:14,220
제이슨 쿠: 음흠.

951
00:39:14,220 --> 00:39:17,130
청중: --시간, 최악의
상황이 예상됩니다.

952
00:39:17,130 --> 00:39:19,350
제이슨 쿠: 이건 최악의 경우입니다.

953
00:39:21,090 --> 00:39:24,330


954
00:39:24,330 --> 00:39:27,360
화요일 강의에서 이 결론에 도달하기까지 여러 가지 복잡한 과정이 있어서 설명하기가 좀 어렵습니다.

955
00:39:27,360 --> 00:39:28,920
기본적으로 저희는

956
00:39:28,920 --> 00:39:31,920

배열을 힙, 즉

957
00:39:31,920 --> 00:39:34,020
이진 트리처럼 생각하는 방법을 보여드렸습니다.

958
00:39:34,020 --> 00:39:35,220
완전 이진 트리.

959
00:39:35,220 --> 00:39:36,720
이건 AVL 트리가 아니에요. 아니,

960
00:39:36,720 --> 00:39:40,380
AVL
트리이긴 한데, AVL 트리는

961
00:39:40,380 --> 00:39:43,190
완전한 트리보다 약하거든요.

962
00:39:43,190 --> 00:39:46,470
높이 균형은
완전한 균형보다 약한 속성입니다.

963
00:39:46,470 --> 00:39:50,580
우리가 '완전함'이라는 용어를 사용하는 이유는
그것이

964
00:39:50,580 --> 00:39:54,270
여러 노드에 대해 고유하기 때문입니다.

965
00:39:54,270 --> 00:39:57,963
이렇게 하면 길이가 고정된 배열 하나를 주면

966
00:39:57,963 --> 00:39:59,880
어떤 트리를 말씀하시는 건지 정확히 알 수 있습니다.

967
00:39:59,880 --> 00:40:03,547
왜냐하면 일대일
대응 관계가 있기 때문입니다.

968
00:40:03,547 --> 00:40:10,350
만약
제가 어떤 나무를 말하는 건지 모호한 부분이 있었다면,

969
00:40:10,350 --> 00:40:13,290
저는 그렇게 하지 않았을 겁니다
. 그런 식으로 하면 제대로 작동하지 않을 테니까요.

970
00:40:13,290 --> 00:40:17,130
힙 정렬은

971
00:40:17,130 --> 00:40:20,010
배열과 이진 트리 사이의 대응 관계를 이용하는 것입니다.

972
00:40:20,010 --> 00:40:22,470
그리고 나서

973
00:40:22,470 --> 00:40:26,940
이 기능은
마지막 단계에서만 작업을 수행하는 기능을 제공합니다.

974
00:40:26,940 --> 00:40:30,330
그리고
제자리 최적화는

975
00:40:30,330 --> 00:40:32,970

실제로 배열에서 요소를 꺼내거나

976
00:40:32,970 --> 00:40:34,920

배열의 맨 뒤에 추가하는 대신, 배열

977
00:40:34,920 --> 00:40:39,660

의 부분 집합을 힙으로 생각하고

978
00:40:39,660 --> 00:40:45,960
항상
최대값을 배열의 끝으로 보내는 방식입니다.

979
00:40:45,960 --> 00:40:49,020
그냥 내버려두고
내 더미를 더

980
00:40:49,020 --> 00:40:51,660
작은 부분집합으로 생각하면 된다.

981
00:40:51,660 --> 00:40:55,095
그렇게 해서 우리는
실제로 감가상각을 전혀 하지 않고 그것을 얻게 된 겁니다

982
00:40:55,095 --> 00:40:58,950
.

983
00:40:58,950 --> 00:41:01,440
시간 제한의 경우,
사실상

984
00:41:01,440 --> 00:41:04,950


985
00:41:04,950 --> 00:41:05,940
이와 유사한 동적 배열 버전의 상각 방식을 사용하면 가능합니다.

986
00:41:05,940 --> 00:41:07,530
시간 제한은
그것에 의존하지 않습니다.

987
00:41:07,530 --> 00:41:12,720
인플레이스 방식은 모든 키가
하나의 배열 내에 유지된다는 전제에 기반합니다.

988
00:41:12,720 --> 00:41:14,250
이해가 되시나요?

989
00:41:14,250 --> 00:41:17,080
여러 개의
상각 연산을 수행하므로

990
00:41:17,080 --> 00:41:19,530
실제로
최악의 경우 n log n을 달성하게 됩니다.

991
00:41:19,530 --> 00:41:20,280
응?

992
00:41:20,280 --> 00:41:22,632
청중:
우리가 배운 것들이…

993
00:41:22,632 --> 00:41:23,340
제이슨 쿠: 네.

994
00:41:23,340 --> 00:41:24,550
관객: --별로--

995
00:41:24,550 --> 00:41:25,440
제이슨 쿠: 음흠.

996
00:41:25,440 --> 00:41:26,815
청중: 대체로 더 나은 편입니다
.

997
00:41:26,815 --> 00:41:29,594
그러니까 대부분의 알고리즘이
우리가 원하는 것보다 더 나은 성능을 보인다고 가정해 봅시다.

998
00:41:29,594 --> 00:41:31,210
제이슨 쿠: 네.

999
00:41:31,210 --> 00:41:32,430
청중: --더 빠르게.

1000
00:41:32,430 --> 00:41:35,460

특히

1001
00:41:35,460 --> 00:41:37,620
이러한 [알아들을 수 없는 부분]
삽입 및 선택 기능에서는 사람들이 자주 사용하지 않을 것 같습니다.

1002
00:41:37,620 --> 00:41:38,537
제이슨 쿠: 네, 맞습니다.

1003
00:41:38,537 --> 00:41:40,920
물론 특별한
경우에는 유용

1004
00:41:40,920 --> 00:41:45,690
하지만, 일반적으로는 대부분의 상황에서
이러한

1005
00:41:45,690 --> 00:41:48,600
일반적인 데이터 구조가 더 낫습니다

1006
00:41:48,600 --> 00:41:49,710
.

1007
00:41:49,710 --> 00:41:52,140
제 말은,
다른 요소들이 도움이 되는 경우도 있으니 완전히 무시할

1008
00:41:52,140 --> 00:41:54,210
필요는 없지만,

1009
00:41:54,210 --> 00:41:58,200
일반적으로는

1010
00:41:58,200 --> 00:41:58,800
이 차트에서 하한선을 목표로 하는 게 좋다는 거죠.

1011
00:41:58,800 --> 00:42:01,383
청중: 제 말은,
만약 제가 선택 정렬을

1012
00:42:01,383 --> 00:42:03,780
제외한 모든 기능을 사용하고 있는데 바인딩이 없다면...

1013
00:42:03,780 --> 00:42:05,910
제이슨 쿠: 시험에서 모든 기능을 다 테스트하기에는
너무 많은 기능이 있습니다

1014
00:42:05,910 --> 00:42:09,030

.

1015
00:42:09,030 --> 00:42:12,300
그러니 모든 내용이 다 포함되지 않았다고 해서 걱정하지 마세요
.

1016
00:42:12,300 --> 00:42:15,360

시험에 같은 내용이 18번이나 나온다면 걱정할 만한 일이죠.

1017
00:42:15,360 --> 00:42:17,020
좋은 징조는 아니에요.

1018
00:42:17,020 --> 00:42:17,520
좋아요.

1019
00:42:17,520 --> 00:42:20,970
기수 정렬의 경우,

1020
00:42:20,970 --> 00:42:23,430
선형 시간 복잡도를 얻는 상황이 있습니다.

1021
00:42:23,430 --> 00:42:25,380

다항식 제한이 있을 때 그렇습니다.  정수의 크기가 다항식 제한이 없는

1022
00:42:25,380 --> 00:42:28,770


1023
00:42:28,770 --> 00:42:31,680
경우에도 기수 정렬을 사용하고 싶은 경우가 있을까요

1024
00:42:31,680 --> 00:42:32,565
?

1025
00:42:37,708 --> 00:42:39,750
청중: 음,
다항식 제한이 없다면 시간이

1026
00:42:39,750 --> 00:42:41,790

정말 오래 걸릴 수 있겠네요.

1027
00:42:41,790 --> 00:42:43,210
제이슨 쿠: 물론이죠.

1028
00:42:43,210 --> 00:42:49,990
그런데 --이게
n log n보다 더 나빠진다는 건 언제쯤 나오는 거죠?  u가 다항식적으로 제한될 때,

1029
00:42:52,960 --> 00:42:55,270
이는 확실히
n log n보다 낫습니다

1030
00:42:55,270 --> 00:42:58,330
.

1031
00:42:58,330 --> 00:43:00,540
선형적이기 때문입니다.

1032
00:43:00,540 --> 00:43:01,390
응?

1033
00:43:01,390 --> 00:43:03,520
청중: [알아들을 수 없는 말]
n에서 n까지.

1034
00:43:03,520 --> 00:43:05,370
제이슨 쿠: n에서 n까지.

1035
00:43:05,370 --> 00:43:05,870
좋아요.

1036
00:43:05,870 --> 00:43:09,490
그래서 여기에 n을 넣으면
, 여기에

1037
00:43:09,490 --> 00:43:12,310
n이라는 인수가 나옵니다
.

1038
00:43:12,310 --> 00:43:15,080
그러면
실행 시간이 제곱에 비례하게 되는데,

1039
00:43:15,080 --> 00:43:17,710
이는 그다지 좋지 않습니다.

1040
00:43:17,710 --> 00:43:22,750
하지만 이것이
언제 n log n보다 더 나아질까요?

1041
00:43:22,750 --> 00:43:24,010
응?

1042
00:43:24,010 --> 00:43:27,757
청중: n 대 c,
왜냐하면 n 대 c보다 작기 때문입니다.

1043
00:43:27,757 --> 00:43:29,590
제이슨 쿠: n 제곱은 c 제곱이니까
확실히

1044
00:43:29,590 --> 00:43:31,025
선형적인 시간이 되겠네요.

1045
00:43:31,025 --> 00:43:32,150
이것이 말하려는 바가 바로 그것입니다.

1046
00:43:32,150 --> 00:43:35,710
하지만 만약 u가 어떤 c에 대해 n의 c제곱 log n이라면, 우리는 실제로
n log n보다 더 나은 결과를 얻을 수 있습니다

1047
00:43:35,710 --> 00:43:43,150

.

1048
00:43:43,150 --> 00:43:48,610
만약 그것이
n의 c제곱 log log n과 같다면,

1049
00:43:48,610 --> 00:43:50,070
그것은 log n보다 작습니다.

1050
00:43:50,070 --> 00:43:52,360
그러니까 저게 더 나은 알고리즘이죠.

1051
00:43:52,360 --> 00:43:53,590
저건 더 빠른 알고리즘이에요.  우리가

1052
00:43:53,590 --> 00:43:58,600
왜
이런 식으로 썼는지 이제 알겠어요?  이는

1053
00:43:58,600 --> 00:44:02,140
우리가
당신에게 더 정확한 정보를 제공하기 위한 것입니다. 당신이

1054
00:44:02,140 --> 00:44:05,680

여기서 'u'가 무엇을 의미하는지 이해하는 것이,

1055
00:44:05,680 --> 00:44:09,040
이 일이
때때로 선형 시간으로 진행된다는 사실을 이해하는 것보다 더 중요합니다.

1056
00:44:09,040 --> 00:44:12,740
우리는
그것이 선형 시간으로 실행되는 시점을 알고 싶습니다.

1057
00:44:12,740 --> 00:44:13,900
이해가 되시나요?

1058
00:44:13,900 --> 00:44:16,755
또는
병합 정렬보다 실행 속도가 빠를 때.

1059
00:44:16,755 --> 00:44:19,850
이해가 되시나요?

1060
00:44:19,850 --> 00:44:20,350
좋아요.  이게 바로

1061
00:44:20,350 --> 00:44:21,505
정렬입니다.

1062
00:44:24,160 --> 00:44:26,320
우리는 순차형
데이터 구조를 가지고 있습니다.

1063
00:44:26,320 --> 00:44:28,870
우리는 연결 리스트,
동적 배열,

1064
00:44:28,870 --> 00:44:30,070
시퀀스 AVL을 가지고 있습니다.

1065
00:44:30,070 --> 00:44:32,310
시퀀스 AVL은 훌륭합니다.

1066
00:44:32,310 --> 00:44:34,030
왜
아무도 이걸 가르치지 않는지 모르겠어요.

1067
00:44:34,030 --> 00:44:35,290
그들은 훌륭해요.  아마도

1068
00:44:35,290 --> 00:44:38,230

실제로

1069
00:44:38,230 --> 00:44:40,930
그다지 유용하지 않아서 가르치지 않는 거겠죠.  코딩에서

1070
00:44:40,930 --> 00:44:45,760

중간에 삽입하는 구문은 실제로 많이 사용하지 않습니다

1071
00:44:45,760 --> 00:44:46,660
.

1072
00:44:46,660 --> 00:44:50,140
그러니까 보통은 데이터를 끝으로
옮기고

1073
00:44:50,140 --> 00:44:53,045

거기서 동적인 연산을 수행하는 방식으로 해결할 수 있어요. 이렇게 하면

1074
00:44:53,045 --> 00:44:55,420


1075
00:44:55,420 --> 00:44:57,490

자체적인 데이터 구조를 만들 필요 없이 파이썬에 내장된 리스트를

1076
00:44:57,490 --> 00:45:02,230
활용할 수 있죠

1077
00:45:02,230 --> 00:45:04,120
.

1078
00:45:04,120 --> 00:45:06,190
하지만 이는
이론적인 흥미를 불러일으키는데,

1079
00:45:06,190 --> 00:45:08,530


1080
00:45:08,530 --> 00:45:12,970

이 수열의 중간에 삽입해야 할 경우 이러한 균형 잡힌 경계를 얻을 수 있기 때문입니다.

1081
00:45:12,970 --> 00:45:18,400
자, 여러분 중 일부는 저를 보면서 이런
질문을 했을지도 모릅니다. "

1082
00:45:18,400 --> 00:45:24,490
제이슨,

1083
00:45:24,490 --> 00:45:27,760

연결 리스트의 끝 부분에 대한 연산은

1084
00:45:27,760 --> 00:45:30,220
왜 선형 시간 복잡도를 가지는 거죠?"

1085
00:45:30,220 --> 00:45:34,030
강의에서
우리가 여러분에게 무엇을 제시했기 때문인가요?

1086
00:45:36,890 --> 00:45:39,620
단일 연결 리스트.  다음 단계로 넘어가는 방향을 알려주는

1087
00:45:39,620 --> 00:45:42,412
단서일 뿐이었어요
.

1088
00:45:42,412 --> 00:45:44,870
만약
다음 항목을 가리키는 포인터와

1089
00:45:44,870 --> 00:45:49,130
맨 위를 가리키는 포인터만 있다면,
끝을 찾으려면

1090
00:45:49,130 --> 00:45:52,430

리스트를 처음부터 끝까지 쭉 내려가야 합니다.  자,

1091
00:45:52,430 --> 00:45:57,500
이제 제가 포인터를
꼬리에 고정해 둔다고 가정해 봅시다. 그러면 꼬리

1092
00:45:57,500 --> 00:46:01,340
와 n1을 찾는 것은 괜찮지만, 꼬리를 제거하는 데는
여전히 선형 시간이 걸립니다.

1093
00:46:01,340 --> 00:46:04,610
왜냐하면
제 앞에 무엇이 있었는지 알 수 없기 때문입니다.

1094
00:46:04,610 --> 00:46:08,420
그래서
p-set 뭐시기, 1, 2,

1095
00:46:08,420 --> 00:46:11,810
기억이 잘 안 나지만,

1096
00:46:11,810 --> 00:46:14,190
이전
리스트를 가리키는 포인터를 저장해서 이중 연결 리스트를 만들었던 겁니다.  좋죠

1097
00:46:14,190 --> 00:46:15,110
, 그렇죠?

1098
00:46:15,110 --> 00:46:19,130
실제로 이 표를 확장하면

1099
00:46:19,130 --> 00:46:22,400

이중 연결 리스트를 참조하여

1100
00:46:22,400 --> 00:46:24,940
상수 시간 안에 이 값을 얻을 수 있습니다.

1101
00:46:24,940 --> 00:46:26,550
이해가 되시나요?

1102
00:46:26,550 --> 00:46:30,860
그리고 이것도
여전히 선형적인 시간입니다.

1103
00:46:30,860 --> 00:46:32,000
좋아요.

1104
00:46:32,000 --> 00:46:34,200
하지만 이건
여전히 선형적인 시간입니다.

1105
00:46:34,200 --> 00:46:36,650
저희는 실제로

1106
00:46:36,650 --> 00:46:38,540
고정상각 방식으로 이 작업을 수행하는 방법도 보여드렸습니다.

1107
00:46:38,540 --> 00:46:40,100
여러분, 그거 기억하세요?

1108
00:46:40,100 --> 00:46:45,080
그건 문제 풀이
세션 2였나요, 아니면 1이었나요?

1109
00:46:45,080 --> 00:46:46,670
기억이 안 나요.

1110
00:46:46,670 --> 00:46:50,360
우리가 얘기하던 건
상각되는 것들이었어요.

1111
00:46:50,360 --> 00:46:52,100
우리는
실제로 동적 배열의 개념을

1112
00:46:52,100 --> 00:46:58,160
사용하여 이 두 가지를 모두 하나의 상각 방식으로 구현했습니다
.

1113
00:46:58,160 --> 00:47:00,470
그리고 나서 우리는 실제로
한 번 더 그 일을 해냈고, 그 결과 양쪽 모두에게

1114
00:47:00,470 --> 00:47:02,390
좋은 결과를 얻었습니다
.

1115
00:47:02,390 --> 00:47:04,970
저게 뭐였지?  혹시

1116
00:47:04,970 --> 00:47:06,380
기억하는 사람 있나요?

1117
00:47:06,380 --> 00:47:08,430
우리는 문제 풀이 3차에 갔었죠

1118
00:47:08,430 --> 00:47:08,930
?

1119
00:47:08,930 --> 00:47:09,972
관객: 오.  제가

1120
00:47:09,972 --> 00:47:11,180
틀렸을지도 모르겠네요, 이건…

1121
00:47:11,180 --> 00:47:11,420
제이슨 쿠: 알겠습니다.

1122
00:47:11,420 --> 00:47:12,670
청중: --문제 해결 세션 3.

1123
00:47:12,670 --> 00:47:14,510
하지만 q dq 같은 거요?

1124
00:47:14,510 --> 00:47:17,330
제이슨 쿠: 그러니까 q dq,
그것들은

1125
00:47:17,330 --> 00:47:20,210
양쪽 끝이 있는 것들에 대해 이야기하는 거죠.

1126
00:47:20,210 --> 00:47:23,750
그것들은 특정한 방식으로 구현되는데
, 실제로 그것이 바로

1127
00:47:23,750 --> 00:47:24,680
이러한 것들 중 하나입니다.

1128
00:47:24,680 --> 00:47:28,880
제 생각엔
파이썬으로 작성된 이 코드인 것 같습니다.

1129
00:47:28,880 --> 00:47:32,330
하지만 우리는
다른 데이터 구조를 사용하여

1130
00:47:32,330 --> 00:47:35,810

정말 좋은 결과를 얻었습니다.

1131
00:47:35,810 --> 00:47:38,960

팝업, 추가,

1132
00:47:38,960 --> 00:47:41,820
시작 및 종료
동적 작업이 정말 훌륭했습니다.

1133
00:47:41,820 --> 00:47:44,240
여러분,
3차 세션 기억하시는 분 계신가요?

1134
00:47:47,635 --> 00:47:49,090
청중: [잘 안 들림]

1135
00:47:49,090 --> 00:47:52,000
청중: 그거
동적 배열 아니에요? [잘 안 들림]

1136
00:47:52,000 --> 00:47:54,790
제이슨 쿠: 바로 그거였어요.

1137
00:47:54,790 --> 00:47:55,480
좋아요.

1138
00:47:55,480 --> 00:47:57,700

예상 범위 내에 있는 하나를 얻었습니다.

1139
00:47:57,700 --> 00:48:00,640
도움이 되셨나요?

1140
00:48:00,640 --> 00:48:01,270
무엇?

1141
00:48:01,270 --> 00:48:04,120
누군가 그렇게 말하는 걸 들었어요.

1142
00:48:04,120 --> 00:48:04,770
해시 테이블.

1143
00:48:04,770 --> 00:48:05,270
응.

1144
00:48:05,270 --> 00:48:09,100
그러니까 기본적으로 당신이 한 일은
, 대신에, 이건

1145
00:48:09,100 --> 00:48:10,150
순서와 관련된 문제예요.

1146
00:48:10,150 --> 00:48:13,300
이것들은 열쇠가 없어요.

1147
00:48:13,300 --> 00:48:16,270
하지만 저는 각 항목을 꽂아 넣으면서

1148
00:48:16,270 --> 00:48:20,727

그 항목의 색인을 나타내는 키를 통해 각 항목에 공감할 수 있었습니다.

1149
00:48:20,727 --> 00:48:22,310

그런 식으로 해시 테이블을 사용할 수도 있겠죠.

1150
00:48:22,310 --> 00:48:26,890

첫 번째 것을 제거하려면 약간의 어려움이 있었습니다.

1151
00:48:30,130 --> 00:48:34,510
사실,
제 모든 인덱스가

1152
00:48:34,510 --> 00:48:35,710
이제 다 바뀌었어요.

1153
00:48:35,710 --> 00:48:39,280
하지만
내 객체에서 가장 작은 인덱스가 무엇인지 저장해 두면,

1154
00:48:39,280 --> 00:48:42,160


1155
00:48:42,160 --> 00:48:45,890

앞부분을 수정했을 때 그 인덱스가 무엇이어야 하는지 계산할 수 있으므로 아무 문제 없습니다.

1156
00:48:45,890 --> 00:48:46,390
좋아요.

1157
00:48:46,390 --> 00:48:48,730
그래서 저희는

1158
00:48:48,730 --> 00:48:51,190


1159
00:48:51,190 --> 00:48:53,570
이 장치의 앞부분과 뒷부분에서 일정한 시간을 유지하는 세 가지 방법을 보여드렸습니다.

1160
00:48:53,570 --> 00:48:57,190
그러니까 실제로 그것은

1161
00:48:57,190 --> 00:48:59,050
분해할 수 있는 표준 재료라고 생각할 수 있습니다.

1162
00:48:59,050 --> 00:49:00,790


1163
00:49:00,790 --> 00:49:02,720

이 차트에는 나와 있지 않지만,

1164
00:49:02,720 --> 00:49:05,290

이 문제 풀이 과정을 시청하시는 분들에게는 도움이 될 만한 예외적인 사항입니다.

1165
00:49:05,290 --> 00:49:05,950
응?

1166
00:49:05,950 --> 00:49:08,890
청중: 그렇다면 해시 테이블은
집합 데이터 구조 아닌가요?

1167
00:49:08,890 --> 00:49:09,850
제이슨 쿠: 그렇습니다.

1168
00:49:09,850 --> 00:49:12,800
하지만 우리는 그것을 순차적인 데이터 구조를 구현하는 데 사용했습니다
.

1169
00:49:12,800 --> 00:49:15,730


1170
00:49:15,730 --> 00:49:18,550

더 자세한 내용을 알고 싶으시면 해당 문제 해결 세션을 참고하시기 바랍니다.

1171
00:49:18,550 --> 00:49:21,090

순차적 데이터 구조에 대해 질문 있으신가요?

1172
00:49:21,090 --> 00:49:21,743
응?

1173
00:49:21,743 --> 00:49:22,630
청중: 나--

1174
00:49:22,630 --> 00:49:23,890
JASON KU: 네, 어허.

1175
00:49:23,890 --> 00:49:25,420
청중:
우리가 그래야 할까요, 아니면… 네.

1176
00:49:25,420 --> 00:49:28,930

우리가 받은 표들을 검증해 볼 수 있어야 할까요?

1177
00:49:28,930 --> 00:49:32,310
제이슨 쿠: 그러니까 제가

1178
00:49:32,310 --> 00:49:36,550

빈 표를 드린다면, 여러분이 그 표를

1179
00:49:36,550 --> 00:49:37,960
채워 넣을 수 있기를 바랍니다.  저는

1180
00:49:37,960 --> 00:49:40,300

여러분이

1181
00:49:40,300 --> 00:49:43,090
이러한 것들이 어떻게 구현되는지 그만큼 잘 알기를 바랍니다.

1182
00:49:43,090 --> 00:49:46,120

그건 시험에 나오지 않을 거예요.

1183
00:49:46,120 --> 00:49:47,650
그건 재미없는
질문이네요.

1184
00:49:47,650 --> 00:49:49,480
청중: 하지만 그걸
아는 게 중요하지 않나요?

1185
00:49:49,480 --> 00:49:50,105
제이슨 쿠: 네.  제 생각에는

1186
00:49:50,105 --> 00:49:53,350

, 예를 들어

1187
00:49:53,350 --> 00:49:56,110

AVL 트리를 사용한다면

1188
00:49:56,110 --> 00:49:58,360
연산 시간은 일반적으로
log n이 될 거라고 생각하는 게 좋을 것 같아요.

1189
00:49:58,360 --> 00:50:00,340
그건 정말 유용한
기능이에요.

1190
00:50:00,340 --> 00:50:03,850
해시 테이블을 사용한다면,
딕셔너리 방식의 연산, 즉

1191
00:50:03,850 --> 00:50:07,030
검색, 삽입,
삭제 작업이 매우 빠르죠.  해시 테이블에서

1192
00:50:07,030 --> 00:50:11,620
순서 관련 작업을 하는 것은
좋지 않습니다. 모든 데이터를 하나하나 살펴봐야 하기

1193
00:50:11,620 --> 00:50:14,110
때문에 작업이 어렵습니다

1194
00:50:14,110 --> 00:50:16,150
.

1195
00:50:16,150 --> 00:50:19,870

정렬된 배열에 대한 동적 연산이 좋지 않다는 것을 알고 있습니다.

1196
00:50:19,870 --> 00:50:26,680
또는 이 점을 알고 있다면,

1197
00:50:26,680 --> 00:50:29,720

이 표에서 연결 리스트와 동적 배열이라고 할 때 무엇을 의미하는지 생각해 봐야 합니다.

1198
00:50:29,720 --> 00:50:30,220
왜냐하면... (

1199
00:50:30,220 --> 00:50:31,360
대상: 단일 연결 리스트)

1200
00:50:31,360 --> 00:50:32,360
제이슨 쿠: 네, 맞아요.

1201
00:50:32,360 --> 00:50:34,060

여기서 단일 연결을 의미하는 이유는

1202
00:50:34,060 --> 00:50:36,340

강의에서 여러분께 그렇게 설명드렸기 때문입니다.  그래서

1203
00:50:36,340 --> 00:50:37,930


1204
00:50:37,930 --> 00:50:39,370
저희가 여러분께서 간소화해주시길 바라는 표준적인 사항들은 바로 이러한 것들입니다.

1205
00:50:39,370 --> 00:50:39,520
응?

1206
00:50:39,520 --> 00:50:41,437
청중: --수정된
표준 세 가지는

1207
00:50:41,437 --> 00:50:43,330
이중 연결 리스트,
양방향 연결 리스트입니다--

1208
00:50:43,330 --> 00:50:43,955
제이슨 쿠: 네.

1209
00:50:43,955 --> 00:50:46,236
기본적으로 여러분은 다음과 같은 옵션을

1210
00:50:46,236 --> 00:50:49,390

사용하고 싶을 것입니다. 왜냐하면

1211
00:50:49,390 --> 00:50:53,710

지속적인 인덱싱이 가능하기 때문입니다.

1212
00:50:53,710 --> 00:50:57,580
그리고 양쪽 모두 꽤
괜찮았어요.

1213
00:50:57,580 --> 00:51:00,490
하지만
양방향 Q가 필요한 경우, 이런 방식으로 진행하면

1214
00:51:00,490 --> 00:51:04,720

두 개의 동적 배열을 서로 맞대어 사용하는 것으로 간소화할 수도 있습니다

1215
00:51:04,720 --> 00:51:06,440

.

1216
00:51:06,440 --> 00:51:07,607
그래서 여러 가지 방법이 있지만,

1217
00:51:07,607 --> 00:51:09,940
저희가 이미 보여드린 방법은 네 가지 정도밖에 안 되기 때문에 그걸
표준적인 방법으로 제시하지는 않겠습니다

1218
00:51:09,940 --> 00:51:12,460


1219
00:51:12,460 --> 00:51:13,750
.

1220
00:51:13,750 --> 00:51:14,930
그럼 하나를 선택하세요.

1221
00:51:14,930 --> 00:51:15,430
좋아요.

1222
00:51:15,430 --> 00:51:16,030
응?

1223
00:51:16,030 --> 00:51:18,910
청중:
시험 시간을 절약하기 위해,

1224
00:51:18,910 --> 00:51:21,860
예를 들어 AVL
시퀀스를 사용하는 작업이

1225
00:51:21,860 --> 00:51:23,978
log n 시간이 걸린다고 말하고 싶을 때, 이렇게 표현해 보겠습니다.  "

1226
00:51:23,978 --> 00:51:26,020

이것은

1227
00:51:26,020 --> 00:51:28,228
AVL 시퀀스이기 때문에
시간이 더 오래 걸립니다."와 같은 문장을 꼭 해야 할까요?

1228
00:51:28,228 --> 00:51:30,880
아니면 그냥
우리가 아는 테이블에 대해 "뭐랄까"라고 말해도 될까요?

1229
00:51:30,880 --> 00:51:33,106
제이슨 쿠: 아니, 그렇지 않아.

1230
00:51:33,106 --> 00:51:35,560
만약 당신이
데이터를 순차 AVL에 저장한다고 말하고, 그 데이터에

1231
00:51:38,260 --> 00:51:40,900

대해 어떤 작업을 하는지, 그리고 그 작업에 얼마나

1232
00:51:40,900 --> 00:51:42,580

시간이 걸리는지 등을 설명한다면, "순차 AVL이기 때문에 시간이 좀 걸린다"라고 굳이

1233
00:51:42,580 --> 00:51:45,760
말할 필요가 없습니다.

1234
00:51:45,760 --> 00:51:47,770
왜냐하면 이미
순차 AVL이라고 알려주셨기 때문입니다.

1235
00:51:47,770 --> 00:51:50,140
제 생각엔 당신이

1236
00:51:50,140 --> 00:51:52,910
컨닝 페이퍼에 표를 적어놓고
그걸 찾아봤을 것 같아요.

1237
00:51:52,910 --> 00:51:54,550
괜찮은.

1238
00:51:54,550 --> 00:51:55,870
이와 관련해서 다른 질문 있으신가요?

1239
00:51:55,870 --> 00:51:56,470
아니요. 네

1240
00:51:56,470 --> 00:51:57,130
?

1241
00:51:57,130 --> 00:51:59,680
청중:
이중 연결 리스트가

1242
00:51:59,680 --> 00:52:02,968

[알아들을 수 없는 부분]에 삽입을 제대로 수행하는지 확인해 주세요.

1243
00:52:02,968 --> 00:52:04,820
변경 사항은 그것뿐인가요?

1244
00:52:04,820 --> 00:52:05,735
제이슨 쿠: 네.

1245
00:52:05,735 --> 00:52:10,550
이중 연결 리스트 덕분에
이 사람은 일정한 시간을 갖게 되었습니다.

1246
00:52:10,550 --> 00:52:13,010
사실
여기에는

1247
00:52:13,010 --> 00:52:14,270
삽입, 삭제, 그리고

1248
00:52:14,270 --> 00:52:17,300

찾기 이렇게 두 가지 작업이 있습니다.  꼬리 포인터

1249
00:52:17,300 --> 00:52:19,100
만 저장하면 상수

1250
00:52:19,100 --> 00:52:22,130

시간 복잡도로 정의됩니다.

1251
00:52:22,130 --> 00:52:25,190
하지만
동적 객체를 일정한 시간으로 만들지는 못합니다.

1252
00:52:25,190 --> 00:52:27,800

각 노드에 이전 포인터 값도 저장해야 합니다.

1253
00:52:27,800 --> 00:52:29,220
이해가 되시나요?

1254
00:52:29,220 --> 00:52:31,880
좋아요.

1255
00:52:31,880 --> 00:52:36,120
마지막으로, 아니 어쩌면
마지막에서 두 번째로, 데이터 구조를 설정해 보겠습니다.

1256
00:52:36,120 --> 00:52:38,030

이런 것들이 조금 더 있습니다.  이제 얼마 남지 않았습니다

1257
00:52:38,030 --> 00:52:39,170
.  네, 그렇습니다

1258
00:52:42,150 --> 00:52:44,510
.

1259
00:52:44,510 --> 00:52:47,600
정렬된 배열이 있어서
검색은 잘 되지만, 동적인 검색은 불가능합니다.

1260
00:52:51,320 --> 00:52:55,010
우리는 검색 성능이 상당히 좋고 동적인 AVL 트리를 설정했습니다

1261
00:52:55,010 --> 00:52:57,380
.

1262
00:52:57,380 --> 00:53:02,878
다시 말하지만, 두 데이터 구조 모두 기본적으로 정렬 작업을 수행하기 때문에
구축 과정에서 n log n의 오버헤드가 발생합니다

1263
00:53:02,878 --> 00:53:05,420


1264
00:53:05,420 --> 00:53:07,260
.

1265
00:53:07,260 --> 00:53:12,080
하지만 만약 제가

1266
00:53:12,080 --> 00:53:13,520


1267
00:53:13,520 --> 00:53:16,370

정렬된 배열에 대한 구체적인 질문이 아니라, 이론적인 질문을 하는 거라면,

1268
00:53:16,370 --> 00:53:19,880
이
데이터 구조와 저 데이터

1269
00:53:19,880 --> 00:53:21,440
구조 중에서 어떤 것을
선택하시겠습니까?

1270
00:53:25,620 --> 00:53:27,620
글쎄요, 잘
모르겠네요. 왜냐하면 이 제품은 이 부분만

1271
00:53:27,620 --> 00:53:32,510

빼고는 모든 면에서 더 나은 것 같거든요.

1272
00:53:32,510 --> 00:53:35,245
그런데
이 값을 일정한 시간으로 만드는 방법을 아시는 분 계신가요

1273
00:53:35,245 --> 00:53:37,400
?

1274
00:53:37,400 --> 00:53:38,420
증가.

1275
00:53:38,420 --> 00:53:43,040

서브트리에 최댓값이나 최솟값을 저장하면 될 것 같습니다.

1276
00:53:43,040 --> 00:53:45,790
그리고 저는 이것을 저것
보다 훨씬 더 좋게 만들 수 있습니다.

1277
00:53:45,790 --> 00:53:47,807
이론적인
문제라면, 아마

1278
00:53:47,807 --> 00:53:48,890
이 방법을 사용하면 될 겁니다.  이러한 연산에는

1279
00:53:51,410 --> 00:53:54,320
해시 테이블이나
직접 접근 배열이

1280
00:53:54,320 --> 00:53:56,600
훨씬 더 적합합니다
.  정말

1281
00:53:56,600 --> 00:53:57,830
좋네요.

1282
00:53:57,830 --> 00:53:59,750
하지만 그들은 이런 것들을 잘 못해요.

1283
00:53:59,750 --> 00:54:02,720
그러니 이것들이 필요하다면
사용하지 마세요.

1284
00:54:02,720 --> 00:54:05,480
그리고 실제 코딩,
특히 파이썬이

1285
00:54:05,480 --> 00:54:08,360
아닌 다른 언어로 코딩할 때
, 즉 해시 테이블이

1286
00:54:08,360 --> 00:54:10,070
자동으로 제공되지 않는 언어
, 예를 들어

1287
00:54:10,070 --> 00:54:14,450

MIT의 마이크로컨트롤러 연구실에서 C 언어로

1288
00:54:14,450 --> 00:54:18,170

6115 수업을 듣거나

1289
00:54:18,170 --> 00:54:21,290
어셈블리 언어를 다룰 때,
보통은

1290
00:54:21,290 --> 00:54:23,600
직접 접근 방식을 사용하게 됩니다.

1291
00:54:23,600 --> 00:54:26,180
왜냐하면 그것이 기계어

1292
00:54:26,180 --> 00:54:27,740
에서

1293
00:54:27,740 --> 00:54:30,510
실제로
상수 시간 내에 이 부분에 접근하는 데 필요한 점프를 제공하기 때문입니다.

1294
00:54:30,510 --> 00:54:32,960
일반적으로

1295
00:54:33,950 --> 00:54:35,870

데이터 구조에 넣는 키를 직접 제어할 수 있다면, 이러한

1296
00:54:35,870 --> 00:54:38,515


1297
00:54:38,515 --> 00:54:39,890
키를
해시 함수에 넣어 조회하는 오버헤드를 피하는 것이 좋습니다

1298
00:54:39,890 --> 00:54:40,940
.

1299
00:54:40,940 --> 00:54:44,990

배열에 요소들을 저장하기만 하면 됩니다.

1300
00:54:44,990 --> 00:54:47,960


1301
00:54:47,960 --> 00:54:49,880

키를 제어할 수 없거나 키가

1302
00:54:49,880 --> 00:54:52,767
문자열 같은 형태일 때 해시 테이블을 사용합니다.  바로 이런 경우에

1303
00:54:52,767 --> 00:54:54,350

해시 테이블을 사용하는 겁니다.  일반적으로

1304
00:54:54,350 --> 00:54:58,215


1305
00:54:58,215 --> 00:54:59,840


1306
00:54:59,840 --> 00:55:02,690
최악의 경우 성능 범위를 요구하는 경우가 아니라면 해시 테이블도 충분히 좋은 선택입니다.

1307
00:55:02,690 --> 00:55:05,738
그리고 우리는
데이터

1308
00:55:05,738 --> 00:55:06,530
구조 문제를 다룰 때 이 방법을 사용할 것입니다.

1309
00:55:06,530 --> 00:55:12,050
만약 우리가

1310
00:55:12,050 --> 00:55:13,760
최악의 경우를
예상하거나 상각하는 등의

1311
00:55:13,760 --> 00:55:15,177
어떤 기준도 고려하지 않는 상황을 제시한다면
, 우리는 단지

1312
00:55:15,177 --> 00:55:19,760

어떤 기준을 달성했는지 명시해 달라고 요청할 것입니다.  데이터 구조에 대한

1313
00:55:19,760 --> 00:55:22,310
분석을 제대로 했다면 문제없습니다

1314
00:55:22,310 --> 00:55:25,430

.

1315
00:55:25,430 --> 00:55:27,930
하지만 만약 우리가 당신에게
최악의 상황을 대비하라고 말한다면,

1316
00:55:27,930 --> 00:55:29,930
나는 당신을 때려눕힐 겁니다.

1317
00:55:29,930 --> 00:55:32,930
그럼 경계값을 알려주세요.

1318
00:55:32,930 --> 00:55:36,710

이 경우에는 해시 테이블을 사용하지 마세요.

1319
00:55:36,710 --> 00:55:38,330
이해가 되시나요?

1320
00:55:38,330 --> 00:55:40,640
좋아요.

1321
00:55:40,640 --> 00:55:43,872
마지막으로, 앞서 이야기했던 우선순위
큐가 있습니다.  이 부분에 대해서는 자세히

1322
00:55:43,872 --> 00:55:45,830
다루지 않겠습니다
.

1323
00:55:45,830 --> 00:55:49,760
기본적으로 기존
기능에 이걸 추가하는 것일 뿐입니다.

1324
00:55:49,760 --> 00:55:52,400
하지만 실제로는, 상각 없이 이러한 경계값이 필요하다면,

1325
00:55:55,190 --> 00:55:59,153

최대 또는 최소 증강을 사용하는 순차 AVL 트리(

1326
00:55:59,153 --> 00:56:01,820
이 목록에는 없지만, 아마도 이 부분에
대해서는 자세히 다루지 않았기 때문에 언급하지 않았습니다)를 통해 이러한 모든

1327
00:56:04,490 --> 00:56:07,850
경계값을

1328
00:56:07,850 --> 00:56:10,980
얻을 수 있습니다.

1329
00:56:10,980 --> 00:56:11,480
괜찮은.  이게 바로

1330
00:56:11,480 --> 00:56:13,700


1331
00:56:13,700 --> 00:56:15,913
수업에서 다룬 내용의 전부입니다.

1332
00:56:15,913 --> 00:56:18,330
남은 시간 동안

1333
00:56:18,330 --> 00:56:19,460
자료구조 문제 몇 가지를 풀어보겠습니다.

1334
00:56:19,460 --> 00:56:23,030
저는 아니에요. 퀴즈에는
다양한 유형의 문제가 출제될 거예요.

1335
00:56:23,030 --> 00:56:27,980


1336
00:56:27,980 --> 00:56:30,530

지난 학기에 드렸던 연습 퀴즈에도 그런 문제들이 있었잖아요.  앞쪽에는

1337
00:56:30,530 --> 00:56:33,500
제가 기계공학 유형이라고 부르는 질문들이 몇 개 있습니다

1338
00:56:33,500 --> 00:56:35,300
.

1339
00:56:35,300 --> 00:56:37,940
그러면 보통

1340
00:56:37,940 --> 00:56:40,490

정렬 알고리즘

1341
00:56:40,490 --> 00:56:41,720
이나 데이터 구조를 사용하는 것으로 축소되는 유형의 문제가 나옵니다.

1342
00:56:41,720 --> 00:56:43,850
그리고 보통
후자의 경우는

1343
00:56:43,850 --> 00:56:46,790

추가적인 작업, 예를 들어

1344
00:56:46,790 --> 00:56:50,070
보강이나
분할 정복

1345
00:56:50,070 --> 00:56:51,920
같은 작업을 해야 하는 경우입니다.

1346
00:56:51,920 --> 00:56:53,480
좋아요.

1347
00:56:53,480 --> 00:56:55,460
그럼 남은 시간 동안

1348
00:56:55,460 --> 00:56:59,390

이 문제들 중 몇 가지를 풀어보도록 하겠습니다.

1349
00:56:59,390 --> 00:57:04,520
이 문제들은
2019년 봄 시험에 나온 것들입니다.

1350
00:57:04,520 --> 00:57:09,260
그리고 사실, 지금 우리 학과 조교를 맡고 있는 조교 중 한 명은

1351
00:57:09,260 --> 00:57:12,020

2019년 봄 학기에도 우리 학과 조교를 맡았었어요.

1352
00:57:12,020 --> 00:57:13,970

2번 문제, 그러니까

1353
00:57:13,970 --> 00:57:16,370
비 오는 날 연구
과제를 채점했는데,

1354
00:57:16,370 --> 00:57:18,590
아무도 제대로 풀지 못해서 저를 엄청 싫어했죠.

1355
00:57:18,590 --> 00:57:19,520
괜찮은.

1356
00:57:19,520 --> 00:57:23,120
그럼,
이 문제들을 해결해 보도록 하겠습니다.

1357
00:57:23,120 --> 00:57:28,730
자, 1번 문제는
식당에 관한 겁니다.

1358
00:57:28,730 --> 00:57:31,880
네, 식당이요.

1359
00:57:31,880 --> 00:57:32,748
괜찮은.

1360
00:57:32,748 --> 00:57:34,040
그래서 기본적으로 무슨 일이 벌어지고 있는 거죠?

1361
00:57:34,040 --> 00:57:38,150
인기 레스토랑인
크리미널 시푸드.

1362
00:57:38,150 --> 00:57:39,830
참고 자료가 뭔가요?

1363
00:57:39,830 --> 00:57:40,580
합법적인 해산물.

1364
00:57:40,580 --> 00:57:41,750
네, 정반대입니다.

1365
00:57:41,750 --> 00:57:44,360
예약은 받지 않지만,
대기자 명단을 운영하여 대기 기간이 긴

1366
00:57:44,360 --> 00:57:47,010
고객일수록

1367
00:57:47,010 --> 00:57:48,590
우선적으로 자리를 안내합니다.

1368
00:57:48,590 --> 00:57:50,830
때때로 손님들은
다른 곳에서 식사를 하기로 결정하기

1369
00:57:50,830 --> 00:57:53,030
때문에, 식당은
대기자 명단에서 그들을 제외해야 합니다.

1370
00:57:53,030 --> 00:57:54,620
좋아요.

1371
00:57:54,620 --> 00:57:57,710
고객의 이름이 다르다고 가정해 보겠습니다
.

1372
00:57:57,710 --> 00:58:00,320

대기자 명단에 두 고객이

1373
00:58:00,320 --> 00:58:01,880
정확히 같은 시간에 추가되는 경우는 없습니다.

1374
00:58:01,880 --> 00:58:04,550
그래서

1375
00:58:04,550 --> 00:58:06,060
대기자 명단에 사람들이 추가되는 순서가 정해져 있습니다.

1376
00:58:06,060 --> 00:58:07,430
이해가 되시나요?  Criminals Seafood가 대기자 명단을 관리하는 데

1377
00:58:07,430 --> 00:58:09,770
도움이 되는 데이터베이스를 설계하십시오. 이 데이터베이스는

1378
00:58:09,770 --> 00:58:11,510

다음

1379
00:58:11,510 --> 00:58:13,460
작업을 모두
일정한 시간 내에 지원해야 합니다.

1380
00:58:13,460 --> 00:58:18,590
좋습니다. 여기서는
실행 시간을 맨 위로 끌어올렸습니다.

1381
00:58:18,590 --> 00:58:20,090
그리고 그건… 아, 죄송합니다.

1382
00:58:20,090 --> 00:58:21,692
여기에 빌드를 추가했습니다.

1383
00:58:21,692 --> 00:58:23,150
제 생각엔 그것도
여전히 일정한 시간인 것 같아요.

1384
00:58:23,150 --> 00:58:23,840
괜찮아요, 알겠어요.

1385
00:58:23,840 --> 00:58:24,680
관객: 저 시간 있어요...

1386
00:58:24,680 --> 00:58:25,305
제이슨 쿠: 네.

1387
00:58:25,305 --> 00:58:29,450
각 실행
시간 작업이 최악의 경우,

1388
00:58:29,450 --> 00:58:30,480
상각된 경우, 또는 예상되는 경우인지 명시하십시오.

1389
00:58:30,480 --> 00:58:33,260
그러니까, 그
문구를 보면 '좋아,

1390
00:58:33,260 --> 00:58:37,580

원한다면 해시 테이블을 사용해도 되겠구나'라고 생각하는 거죠.

1391
00:58:37,580 --> 00:58:39,860

만약 제가 이 기능을 사용한다면, 해당 작업이

1392
00:58:39,860 --> 00:58:44,900

발생할 때 예상 작업인지 상각 작업인지 명확하게 표시해야 합니다.

1393
00:58:44,900 --> 00:58:46,580
어떤 작업이 예상되나요?

1394
00:58:46,580 --> 00:58:47,840
기본적으로 전부 다요.

1395
00:58:47,840 --> 00:58:49,490
어떤 사업활동이 상각 대상인가요?  데이터 구조의

1396
00:58:49,490 --> 00:58:52,790
내용을 변경하는 것들
, 즉 삽입과

1397
00:58:52,790 --> 00:58:54,260
삭제입니다.

1398
00:58:54,260 --> 00:58:54,890
좋아요.

1399
00:58:54,890 --> 00:58:58,370
그래서 우리는
빈 구조물을 만드는 몇 가지 작업을 진행하고 있습니다.  대기자 명단에

1400
00:58:58,370 --> 00:59:02,330
이름을 추가합니다. 즉, 이 이름(
x)을 대기자 명단 맨 뒤에 추가하는 것입니다.

1401
00:59:02,330 --> 00:59:03,530
내가 x에 대해 뭘 알겠어?  이 수업에서 우리가 세운 가정에 따르면,

1402
00:59:03,530 --> 00:59:06,350
나는 이름에 대해 무엇을 알고 있을까요

1403
00:59:06,350 --> 00:59:06,980
?

1404
00:59:06,980 --> 00:59:08,690
청중: 그들은 독특하기
때문에 중요한 역할을 할 수 있습니다.

1405
00:59:08,690 --> 00:59:10,648
제이슨 쿠: 그것들은 독특하기
때문에 중요한 역할을 할 수 있습니다.

1406
00:59:10,648 --> 00:59:14,540
그리고 우리의 가정에 따르면 그것들은
일정한 단어 수 안에 들어맞습니다

1407
00:59:14,540 --> 00:59:15,780
.

1408
00:59:15,780 --> 00:59:17,920
그래서 두 개를 비교하는 데 걸리는 시간은 짧고,

1409
00:59:17,920 --> 00:59:19,700
하나를 해싱하는 데 걸리는 시간은
상수 시간입니다.

1410
00:59:19,700 --> 00:59:21,950

이러한 입력값들은

1411
00:59:21,950 --> 00:59:23,150
문자열이라고 가정합니다.

1412
00:59:23,150 --> 00:59:26,060
그리고 제가
길이 제한을 따로 정해드리지 않았으니, 아마

1413
00:59:26,060 --> 00:59:29,690

걱정하실 필요는 없을 거예요.

1414
00:59:29,690 --> 00:59:33,110
좋아요, 이름을 삭제해 주세요.  벌써부터

1415
00:59:33,110 --> 00:59:35,720


1416
00:59:35,720 --> 00:59:39,230

이름으로 물건을 찾을 수 있어야 할 것 같은 기분이 들어요.

1417
00:59:39,230 --> 00:59:40,400
좋아요.

1418
00:59:40,400 --> 00:59:43,220
그리고 나서
다음 사람을 자리에 앉히세요.

1419
00:59:43,220 --> 00:59:44,610
이해가 되시나요?

1420
00:59:44,610 --> 00:59:47,360
그렇다면
여기서 유지 관리해야 할 것들은 어떤 것들이 있을까요?  제겐

1421
00:59:47,360 --> 00:59:49,850
사람들이 있어요.

1422
00:59:49,850 --> 00:59:53,090
그들에게는 이름이 있고, 그들이 온
장소와

1423
00:59:53,090 --> 00:59:55,340
시간이 있습니다.

1424
00:59:55,340 --> 00:59:56,555
하지만 저는 그 시간을 알 수 있을까요?

1425
00:59:59,880 --> 01:00:01,020
아니요.

1426
01:00:01,020 --> 01:00:02,820
저는 어디에서도 시간을 부여받은 적이 없어요.

1427
01:00:02,820 --> 01:00:05,710
그건
제 작업 입력값에 포함되어 있지 않습니다.

1428
01:00:05,710 --> 01:00:08,560
그러니까 제가 제
시간에 키보드를 칠 수 있을 것 같지는 않네요.

1429
01:00:08,560 --> 01:00:09,270
이해가 되시나요?

1430
01:00:09,270 --> 01:00:12,000

시대에 있어서 중요한 것은 무엇일까요?

1431
01:00:12,000 --> 01:00:12,547
주문.

1432
01:00:12,547 --> 01:00:13,880
청중: 그리고 당신은 그걸 부여받았죠.

1433
01:00:13,880 --> 01:00:14,505
제이슨 쿠: 네.

1434
01:00:14,505 --> 01:00:17,670
기본적으로
저는

1435
01:00:17,670 --> 01:00:20,160

이 사람들에 대한 순서를 유지하려고 노력합니다.

1436
01:00:20,160 --> 01:00:23,797
앞쪽과 뒤쪽이 있고,
가운데에 사람들이 있어요.

1437
01:00:23,797 --> 01:00:25,880
그리고 저는
그 순서가 그대로 유지되도록 하고 싶어요.

1438
01:00:25,880 --> 01:00:27,880
그렇지 않으면 사람들이
저한테 화를 낼 거예요.

1439
01:00:27,880 --> 01:00:31,390
왜냐하면, 아, 그들이
저보다 늦게 여기 왔고 저는...

1440
01:00:31,390 --> 01:00:32,970
네.

1441
01:00:32,970 --> 01:00:34,720
당신도 그런 상황을 겪어봤을 거예요.

1442
01:00:34,720 --> 01:00:35,280
좋아요.

1443
01:00:35,280 --> 01:00:38,220
그래서 우리는 이러한 것들에 대해
일종의 순서, 즉

1444
01:00:38,220 --> 01:00:41,550
외적인 질서를 유지하려고 노력하고 있습니다
.

1445
01:00:41,550 --> 01:00:44,250
하지만 저는 이 시스템을 바꾸고

1446
01:00:44,250 --> 01:00:47,640
싶기 때문에 사람들의 이름을 검색할 수 있어야 합니다
.

1447
01:00:47,640 --> 01:00:51,000
이 문제가

1448
01:00:51,000 --> 01:00:54,990
이번 학기 과제에서 나왔던 다른 문제와 비슷하게 들리지 않나요?

1449
01:00:54,990 --> 01:00:58,600
네, 문제가 있었던 것 같아요. (

1450
01:00:58,600 --> 01:00:59,640
관객: 채팅창)

1451
01:00:59,640 --> 01:01:00,900
제이슨 쿠: 채팅.

1452
01:01:00,900 --> 01:01:03,090
순서를 저장해야 했습니다.

1453
01:01:03,090 --> 01:01:06,120
하지만 여러분은
사전을 찾아봐야 하는 경우도 있었잖아요.

1454
01:01:06,120 --> 01:01:11,670

그 상황의 좋은 점은 찾아봐야 할

1455
01:01:11,670 --> 01:01:14,940
정보들이

1456
01:01:14,940 --> 01:01:16,530
고정되어 있었다는 것입니다.

1457
01:01:16,530 --> 01:01:18,870
그렇다면 이를 위한
사전, 즉

1458
01:01:18,870 --> 01:01:22,320
집합 데이터 구조로는 무엇을 사용할 수 있을까요?  혹시

1459
01:01:22,320 --> 01:01:25,290
기억하는 사람 있나요?

1460
01:01:25,290 --> 01:01:26,970

정렬된 배열을 사용하면 됩니다.

1461
01:01:26,970 --> 01:01:28,770

정적 배열이기 때문에 이러한 요소들이

1462
01:01:28,770 --> 01:01:32,010
항상 업데이트되는 것은 아니므로,
저는

1463
01:01:32,010 --> 01:01:34,290
정적 배열을 사용해도 괜찮다고 생각했습니다.

1464
01:01:34,290 --> 01:01:39,450
여기서는

1465
01:01:39,450 --> 01:01:41,610
최악의 경우를 가정한 로그 시간으로 조회 시간을 계산했습니다.

1466
01:01:41,610 --> 01:01:43,200
여기서 저는
일정한 시간을 요구하고 있습니다.

1467
01:01:45,600 --> 01:01:47,100
정렬된 배열로는 안 되고
,

1468
01:01:47,100 --> 01:01:49,638
AVL을 설정하는 것도 안 되는데
, 그럼 뭘 사용해야 할까요?

1469
01:01:49,638 --> 01:01:50,430
청중: 동적 --

1470
01:01:50,430 --> 01:01:52,650
제이슨 쿠: 동적
배열 또는 해시 테이블.

1471
01:01:52,650 --> 01:01:55,980
동적 배열은 키의 크기에 대한 정확한 수치적 제한이
없기 때문에 그다지 좋지 않을 수 있습니다. 단지

1472
01:01:55,980 --> 01:01:58,590

키들이

1473
01:01:58,590 --> 01:02:01,260

단어 단위로 배열될 수 있다는 것만 알고 있을 뿐입니다.

1474
01:02:01,260 --> 01:02:03,900
그래서 저는 실제로
직접 접근 배열을 만들 수 없습니다.

1475
01:02:03,900 --> 01:02:05,125
왜냐하면 그 단어들은

1476
01:02:05,125 --> 01:02:07,000

상수 개수의 단어에는 맞지만,

1477
01:02:07,000 --> 01:02:09,390

그 단어들의 정수 표현이

1478
01:02:09,390 --> 01:02:11,820
다항식 제한을 받는지 알 수 없기 때문입니다.

1479
01:02:11,820 --> 01:02:13,200
이해가 되시나요?

1480
01:02:13,200 --> 01:02:16,043
그래서 저는
이 경우에 해싱을 사용하고 싶습니다.

1481
01:02:16,043 --> 01:02:17,460
그렇다면 제가
유지하고 싶은 것은 무엇일까요?  고객 정보를

1482
01:02:17,460 --> 01:02:30,180
순차적인 데이터 구조로 유지하고 싶습니다
.

1483
01:02:30,180 --> 01:02:31,620
고객들.  그 안에

1484
01:02:31,620 --> 01:02:33,060
U가 어딘가에 있나요?

1485
01:02:33,060 --> 01:02:33,560
아니요.

1486
01:02:33,560 --> 01:02:34,620
이게 맞죠, 그렇죠?

1487
01:02:34,620 --> 01:02:35,120
좋아요.

1488
01:02:35,120 --> 01:02:41,170
그리고 집합 매핑입니다.  저는

1489
01:02:41,170 --> 01:02:42,780
보통 이런 식으로 합니다.

1490
01:02:42,780 --> 01:02:46,380

뭔가에 초점을 맞춘 세트라고 말하고 싶어요.

1491
01:02:46,380 --> 01:02:49,020
세트라면
키만 있으면 돼요.

1492
01:02:49,020 --> 01:02:51,150
그게
거기에 있는지 없는지 알아볼 수 있어요.

1493
01:02:51,150 --> 01:02:55,140
하지만 실제로
다른 것에 매핑할 때는, 예를 들어

1494
01:02:55,140 --> 01:03:00,120
키 '스페이스'를
다른 것, 보통

1495
01:03:00,120 --> 01:03:02,010

저장하는 항목이나

1496
01:03:02,010 --> 01:03:04,380

저장하는 항목의 속성에 매핑한다고 말합니다.

1497
01:03:04,380 --> 01:03:05,620
이해가 되시나요?

1498
01:03:05,620 --> 01:03:06,120
좋아요.

1499
01:03:06,120 --> 01:03:09,140
그럼 매핑, 여기서 뭘 매핑해야 하죠?

1500
01:03:09,140 --> 01:03:09,640
이름들.  토--

1501
01:03:13,380 --> 01:03:15,348
오.

1502
01:03:15,348 --> 01:03:16,320
무엇에 대해서요?

1503
01:03:16,320 --> 01:03:18,438
지도를 만들고 싶나요?

1504
01:03:18,438 --> 01:03:20,558
청중: 시간에 대해서--

1505
01:03:20,558 --> 01:03:21,350
제이슨 쿠: 네, 시간입니다.

1506
01:03:21,350 --> 01:03:23,690
그들이 들어온 시간.

1507
01:03:23,690 --> 01:03:24,921
내가 그걸 하고 싶을까?

1508
01:03:24,921 --> 01:03:27,350
청중: 네,
정확히 입장 시간을 기준으로 순서를 알 수는 없지만,

1509
01:03:27,350 --> 01:03:29,517

고객들의 순서를 보면

1510
01:03:29,517 --> 01:03:30,895
다음에 누가 올지 알 수 있을 거예요.

1511
01:03:30,895 --> 01:03:31,520
제이슨 쿠: 네.

1512
01:03:31,520 --> 01:03:35,570

해당 시퀀스에서 현재 위치에 저장하고 싶습니다.

1513
01:03:35,570 --> 01:03:38,450
그래서
시퀀스에서 해당 위치가 어디인지 인덱스를 저장해 두면 필요할 때 쉽게

1514
01:03:38,450 --> 01:03:39,620
찾아볼 수 있습니다.

1515
01:03:39,620 --> 01:03:43,177
그건… 그렇죠?

1516
01:03:43,177 --> 01:03:43,760
그게...?

1517
01:03:43,760 --> 01:03:45,560
청중: 저는
지표가 바뀌는 줄 알았어요.

1518
01:03:45,560 --> 01:03:46,185
제이슨 쿠: 네.  항목을 추가하거나 삭제할

1519
01:03:46,185 --> 01:03:48,380
때마다 인덱스가 변경됩니다
.

1520
01:03:48,380 --> 01:03:49,550
관객: [잘 안 들림]

1521
01:03:49,550 --> 01:03:50,390
제이슨 쿠: 아, 네.

1522
01:03:50,390 --> 01:03:53,270
포인터를 저장합니다.

1523
01:03:53,270 --> 01:04:00,740
순서대로 배치할 위치를 가리키는 포인터입니다.

1524
01:04:00,740 --> 01:04:04,520
자, 이렇게
말하는 게 좀 이상하게 들릴 수도 있는데,

1525
01:04:04,520 --> 01:04:09,500
왜냐하면
제가 이 과정을 어떻게 표현했는지 아직 말씀드리지 않았기 때문입니다.

1526
01:04:09,500 --> 01:04:13,790
하지만 개념적으로
말하자면, 저는 이것이 현재 어디에 있는지를 나타내는 포인터를 이 어딘가에 그리고 있는 것입니다.

1527
01:04:13,790 --> 01:04:15,470


1528
01:04:15,470 --> 01:04:19,700

자세한 내용은 나중에 다루겠습니다.

1529
01:04:19,700 --> 01:04:22,580
하지만 일반적으로 저는 이것을
연결된 데이터 구조라고 부릅니다.

1530
01:04:22,580 --> 01:04:26,780
왜냐하면
두 데이터 구조를 연결하여 한 데이터 구조에서

1531
01:04:26,780 --> 01:04:30,380
쿼리를 수행하면 다른 데이터 구조에서 해당 데이터가
어디에 있는지 알 수 있기 때문입니다

1532
01:04:30,380 --> 01:04:31,970
.

1533
01:04:31,970 --> 01:04:36,140
아니면 다른 쪽에서 쿼리를 실행하는 것과 같은 거죠
.

1534
01:04:36,140 --> 01:04:39,990
자, 이제 다들 제가
왜 이런 것들을 골랐는지 이해하시겠죠?

1535
01:04:39,990 --> 01:04:41,240
이 문제에 어떻게 접근했을까요?

1536
01:04:41,240 --> 01:04:42,020
응?

1537
01:04:42,020 --> 01:04:46,430
청중:
포인터가

1538
01:04:46,430 --> 01:04:49,820
인덱스만 저장하는 문제를 어떻게 해결하는지 잘 모르겠습니다.

1539
01:04:49,820 --> 01:04:53,880
사람이
순서상 어느 위치에 있는지는

1540
01:04:53,880 --> 01:04:55,260
시간이 지남에 따라 변할 것입니다.

1541
01:04:55,260 --> 01:04:55,560
제이슨 쿠: 음흠.

1542
01:04:55,560 --> 01:04:57,852
청중:
포인터가 업데이트된다고 가정할 때, 그 결과가

1543
01:04:57,852 --> 01:04:58,570
달라질까요?

1544
01:04:58,570 --> 01:04:59,340
제이슨 쿠: 네, 알겠습니다.

1545
01:04:59,340 --> 01:05:03,850
그러니까 매번,

1546
01:05:03,850 --> 01:05:05,190
그러니까 제가

1547
01:05:05,190 --> 01:05:07,410
이
시퀀스를 연결 리스트에 저장한다고 가정해 볼게요. 왜냐하면 저는 이 리스트

1548
01:05:07,410 --> 01:05:09,120


1549
01:05:09,120 --> 01:05:11,162


1550
01:05:11,162 --> 01:05:12,860
중간에서 요소를 삽입하고 삭제해야 한다는 것을 알고 있기 때문입니다.

1551
01:05:12,860 --> 01:05:13,840
이해가 되시나요?

1552
01:05:13,840 --> 01:05:14,340
괜찮은.

1553
01:05:14,340 --> 01:05:16,920
그래서 저는
이것이

1554
01:05:16,920 --> 01:05:19,050
연결 리스트가 될 것이라고 말씀드리겠습니다.

1555
01:05:19,050 --> 01:05:21,165
이제 제겐 연결된 리스트가 생겼습니다.

1556
01:05:24,930 --> 01:05:30,900
그러니까 제가 이렇게 말한다면,
제 집합의 데이터 구조는,

1557
01:05:32,520 --> 01:05:36,272
또는
연결 리스트에서 그 집합이 어디에

1558
01:05:36,272 --> 01:05:41,980
저장되는지, 예를 들어
k 위치에 저장된다고 해봅시다.

1559
01:05:41,980 --> 01:05:43,620
시원한.  자,

1560
01:05:43,620 --> 01:05:51,750
이제 이 사람을 자리에 앉히면

1561
01:05:51,750 --> 01:05:54,180
모든 지표가 달라집니다.

1562
01:05:54,180 --> 01:05:57,870
따라서
이 집합 데이터 구조에 저장된 인덱스를 업데이트하려면 모든 인덱스를 하나하나

1563
01:05:57,870 --> 01:06:00,545
변경해야 합니다
.

1564
01:06:00,545 --> 01:06:01,170
청중: 네.

1565
01:06:01,170 --> 01:06:02,100
제이슨 쿠: 이해가 되시나요?

1566
01:06:02,100 --> 01:06:04,000
청중: 네, 맞아요. 이게 훨씬
더 말이 되네요.

1567
01:06:04,000 --> 01:06:04,625
제이슨 쿠: 네.

1568
01:06:04,625 --> 01:06:07,290
그러니까 제가 정말로 원하는 건
여기에 숫자를 저장하는 게 아니라,

1569
01:06:07,290 --> 01:06:09,330


1570
01:06:09,330 --> 01:06:12,540
이 객체를 담고 있는 노드를 가리키는 포인터를 저장하는 겁니다.
왜냐하면 그 객체가

1571
01:06:12,540 --> 01:06:16,380

제 데이터 구조에서 벗어나지 않는 한 노드는 변하지 않기 때문입니다.

1572
01:06:16,380 --> 01:06:20,340
노드, 즉 메모리에서 이 객체의 주소는

1573
01:06:20,340 --> 01:06:22,500


1574
01:06:22,500 --> 01:06:25,110
항목과 다음
포인터를 담는 작은 컨테이너일 뿐입니다. 그리고 실제로

1575
01:06:25,110 --> 01:06:28,900

여기서는 이전 포인터가 필요합니다.

1576
01:06:28,900 --> 01:06:31,800

이중 연결 리스트가 필요할 겁니다.

1577
01:06:31,800 --> 01:06:34,440
우리가
무언가를 제거할 때는

1578
01:06:34,440 --> 01:06:36,750


1579
01:06:36,750 --> 01:06:38,820
끊임없이 다시 붙여야 하기 때문에,

1580
01:06:38,820 --> 01:06:42,720
앞에 있는 것과 뒤에 있는 것이 무엇인지 알아야 합니다
.

1581
01:06:42,720 --> 01:06:43,395
응?

1582
01:06:43,395 --> 01:06:44,470
아니요?

1583
01:06:44,470 --> 01:06:44,970
괜찮은.

1584
01:06:44,970 --> 01:06:47,230
여기 링크 목록이 있습니다.

1585
01:06:47,230 --> 01:06:49,500
우리는 이미
해시 테이블을 사용하는 방안을 고려해 볼 수 있다고 언급했습니다.  네

1586
01:06:54,030 --> 01:06:56,850
, 좋습니다.

1587
01:06:56,850 --> 01:07:00,690
기본적으로 이 정도면

1588
01:07:00,690 --> 01:07:03,500
제 데이터 구조는 이렇고,
불변 조건은 이렇다고 말하기에 충분합니다.

1589
01:07:03,500 --> 01:07:04,500
불변량은 무엇인가요?

1590
01:07:04,500 --> 01:07:07,230
모든 고객 정보를 저장하고 있습니다.

1591
01:07:07,230 --> 01:07:08,220
그건 불변량이에요.

1592
01:07:08,220 --> 01:07:10,860
제 말은, 아주
강력한 불변량은 아니지만...

1593
01:07:10,860 --> 01:07:13,260
네, 제가 그렇게 말해야 할 것 같네요.  고객 정보를

1594
01:07:13,260 --> 01:07:15,090
모두 저장하는 이유는 나중에

1595
01:07:15,090 --> 01:07:17,730


1596
01:07:17,730 --> 01:07:19,770
쿼리를 실행할 때 해당 정보가 유지되도록 해야 하기 때문입니다.

1597
01:07:19,770 --> 01:07:24,450
그리고 여기서는
매핑 이름을 포인터로 설정합니다.

1598
01:07:24,450 --> 01:07:26,940
이 물건의 위치.

1599
01:07:26,940 --> 01:07:29,520
그리고 제가 어떤 것들을 제거할 때,

1600
01:07:29,520 --> 01:07:31,620
그 불변 조건이 그대로 유지되는지 확인해야 합니다.  제 시스템에 있는

1601
01:07:31,620 --> 01:07:33,810
모든
고객 이름을

1602
01:07:33,810 --> 01:07:37,560

해당 노드에 매핑하는 작업이 아직 진행 중입니다.

1603
01:07:37,560 --> 01:07:39,810
그러니 무언가가
떠나면

1604
01:07:39,810 --> 01:07:43,320

이 두 가지 모두 업데이트되었는지 확인해야 합니다.

1605
01:07:43,320 --> 01:07:44,320
이해가 되시나요?

1606
01:07:44,320 --> 01:07:44,820
좋아요.

1607
01:07:44,820 --> 01:07:47,790
그렇다면 이러한 운영을 어떻게 유지해야 할까요
?

1608
01:07:47,790 --> 01:07:50,400
빌드를 진행하면

1609
01:07:50,400 --> 01:07:53,910

이러한 구성 요소들이 모두 비어 있는 상태로 설정됩니다.  그렇게

1610
01:07:53,910 --> 01:07:56,010
말하는 게 더 쉽죠.

1611
01:07:56,010 --> 01:07:59,610
저는 빈 연결
리스트와 고객 정보를 담은 이중 연결 리스트를 만들고

1612
01:07:59,610 --> 01:08:04,080
, 현재는 아무것도 없는 것에 아무것도

1613
01:08:04,080 --> 01:08:07,740
매핑하는 해시 테이블인 집합을 만듭니다
.

1614
01:08:07,740 --> 01:08:08,430
좋아요.  자, 이게 바로

1615
01:08:08,430 --> 01:08:10,410
빌드입니다.

1616
01:08:10,410 --> 01:08:13,080
제가 정확하게 말씀드리려고

1617
01:08:13,080 --> 01:08:18,870
그 내용을 적어 놓겠습니다. 연산 과정을 무시하지
말라고 했기 때문입니다.

1618
01:08:18,870 --> 01:08:21,510

그렇지 않으면

1619
01:08:21,510 --> 01:08:23,850
점수를 드릴 수 없습니다.

1620
01:08:23,850 --> 01:08:24,957
다음 거 말이야, 그렇지?

1621
01:08:24,957 --> 01:08:27,374
청중: 비움으로써, 즉
빈 연결 리스트를 만듦으로써...

1622
01:08:27,374 --> 01:08:28,109
제이슨 쿠: 음흠.

1623
01:08:28,109 --> 01:08:30,460
청중: --
머리랑 꼬리만 있는 것 같고,

1624
01:08:30,460 --> 01:08:32,652
사실은 아무것도 없는데, 그냥
존재한다는 거죠?

1625
01:08:32,652 --> 01:08:33,569
제이슨 쿠: 네, 맞아요.

1626
01:08:33,569 --> 01:08:35,880
그것은
우리가 기억 속에 저장하는 어떤 것입니다.

1627
01:08:35,880 --> 01:08:38,500

머리와 꼬리를 가리키는 포인터가 있습니다.

1628
01:08:38,500 --> 01:08:40,140
현재로서는 없습니다.

1629
01:08:40,140 --> 01:08:42,630
하지만 우리는 거기에 몇 가지를 더 추가할 것입니다.

1630
01:08:42,630 --> 01:08:43,380
좋아요.

1631
01:08:43,380 --> 01:08:45,870
두 번째는 이름을 추가하는 것입니다.

1632
01:08:50,910 --> 01:08:52,170
우리가 할 말은 무엇일까요?  분산성을 유지할 수

1633
01:08:52,170 --> 01:08:54,060

있도록 이 데이터 구조를 업데이트해야 합니다

1634
01:08:54,060 --> 01:08:56,580
.

1635
01:08:56,580 --> 01:09:00,779
저는 어쩔 수 없이 그
중 하나부터 시작해요.  어느 순간 '

1636
01:09:00,779 --> 01:09:03,300

아,

1637
01:09:03,300 --> 01:09:05,850

다른 걸 먼저 업데이트했어야 했는데'라는 생각이 들어요.

1638
01:09:05,850 --> 01:09:07,560
그래서 때로는 잘 될 때도 있고 안 될 때도 있죠.

1639
01:09:07,560 --> 01:09:08,720
나는 여기서 무엇을 하고 싶은가?

1640
01:09:08,720 --> 01:09:12,930
글쎄요, 이 부분이 전체
순서에서 어디에 해당하는지는 전혀 모르겠습니다.

1641
01:09:12,930 --> 01:09:16,470
그래서 저는
먼저 여기를 방문해야 해요.

1642
01:09:16,470 --> 01:09:17,760
아, 죄송합니다.

1643
01:09:17,760 --> 01:09:21,240
남자를 영입하는 건
어느 쪽이든 괜찮아요.

1644
01:09:21,240 --> 01:09:23,770
나도 알아.
그는 어디로 갈까?

1645
01:09:23,770 --> 01:09:25,420
목록의 끝입니다.

1646
01:09:25,420 --> 01:09:27,840
그래서 그냥 거기에 붙여 놓는 거예요.

1647
01:09:27,840 --> 01:09:36,689
그러므로 수열의 끝에 x를 더하세요.

1648
01:09:36,689 --> 01:09:41,370
그래서 제가 마음에 드는
비법을 하나 생각해냈습니다.

1649
01:09:41,370 --> 01:09:43,950
순서, 설정.

1650
01:09:43,950 --> 01:09:44,460
좋아요.

1651
01:09:44,460 --> 01:09:46,830
이 경우에는
시퀀스가 ​​하나, 세트가 하나만 있습니다.

1652
01:09:46,830 --> 01:09:50,388
그래서 그것들을 순차
와 세트라고 부르는 건 아마 괜찮을 겁니다.

1653
01:09:50,388 --> 01:09:51,930
나는
더 큰 것을 혼란스럽게 하지 않을 것이고,

1654
01:09:51,930 --> 01:09:54,480
나 자신을 혼란스럽게 하지도 않을 것이다.

1655
01:09:54,480 --> 01:09:56,970
하지만
이런 것들이 두 개 이상 있을 때,

1656
01:09:56,970 --> 01:10:01,470
또는 시간이 부족한 시험에서 간결하게 표현하기 위해

1657
01:10:01,470 --> 01:10:03,690
이러한 것들에 이름을 붙이는 것이 좋습니다.

1658
01:10:03,690 --> 01:10:08,580
이것이
C와 M의 수열이라고 가정해 봅시다. 저는 모르겠습니다.

1659
01:10:08,580 --> 01:10:12,240
여기 고객이 보이고,
여기 지도가 보이니, 아마도 그럴 것 같네요.  모르겠습니다

1660
01:10:12,240 --> 01:10:13,350
.

1661
01:10:13,350 --> 01:10:15,720
하지만
편지를 보내주시면 저희가

1662
01:10:15,720 --> 01:10:17,970
훨씬 더 명확하게 이해할 수 있고,
당신도

1663
01:10:17,970 --> 01:10:19,980
이러한 사항들을 더 정확하게 언급할 수 있을 겁니다.

1664
01:10:19,980 --> 01:10:25,930
C 단계가 끝났습니다.

1665
01:10:25,930 --> 01:10:27,940
그다음에는 무엇을 해야 할까요?

1666
01:10:27,940 --> 01:10:30,730
내가 이 사람을 고쳐줬어, 이 사람 실력 좋더라.

1667
01:10:30,730 --> 01:10:32,570
이제 이 녀석을 고쳐야겠어.

1668
01:10:32,570 --> 01:10:37,600
그래서 저는 x를 집합에 추가하고, 방금 전에 왔던
노드로 다시 매핑합니다

1669
01:10:37,600 --> 01:10:39,160
.  임시 변수

1670
01:10:39,160 --> 01:10:41,560
에 저장할 수 있습니다
.

1671
01:10:41,560 --> 01:10:59,030
m에 x를 추가하여
n 노드 v를 v로 가리키도록 합니다. 완료.

1672
01:10:59,030 --> 01:11:00,490
시원한?

1673
01:11:00,490 --> 01:11:08,050
그래서 C 끝에 x를 붙여서
v라는 노드를 만들었어요.

1674
01:11:08,050 --> 01:11:11,410

나중에 참조할 수 있도록 레이블도 붙여 놨습니다.

1675
01:11:11,410 --> 01:11:15,610
코드로 표현한다면, 저는 아마
그 노드가 무엇이었는지 기억할 수 있을 겁니다.

1676
01:11:15,610 --> 01:11:19,750
M에 해당 노드를 가리키는 x를 추가하면

1677
01:11:19,750 --> 01:11:21,370
이제
불변식이 유지됩니다.

1678
01:11:21,370 --> 01:11:21,880
엄청난.

1679
01:11:21,880 --> 01:11:24,470
관객: 아마도 [잘 안 들림].

1680
01:11:24,470 --> 01:11:28,370
제이슨 쿠: 키 x를 추가하세요.

1681
01:11:28,370 --> 01:11:35,360
또는 x의 키가 해당 노드를 가리키도록 M에 x를 추가합니다
.

1682
01:11:35,360 --> 01:11:36,330
이해가 되시나요?

1683
01:11:36,330 --> 01:11:38,750
거기에는 미묘한 차이가 있어요.

1684
01:11:38,750 --> 01:11:43,100
3 3, 우리는 제거해야 합니다. 이름은

1685
01:11:43,100 --> 01:11:45,230
기억나지 않지만
, 아무튼요.

1686
01:11:45,230 --> 01:11:46,760
좋아요.

1687
01:11:46,760 --> 01:11:48,590
그러므로 여기서 우리가 해야 할 일은 질서를 지키는 것입니다

1688
01:11:48,590 --> 01:11:49,490
.  순서상

1689
01:11:49,490 --> 01:11:53,175
어디에 있는지는 모르겠지만,

1690
01:11:53,175 --> 01:11:54,800

세트에서 찾아보고

1691
01:11:54,800 --> 01:11:57,920

세트에서 제거한 다음, 그것이 가리키는 것을

1692
01:11:57,920 --> 01:12:00,170
확인하고

1693
01:12:00,170 --> 01:12:02,180
순서에서도 제거하겠습니다.

1694
01:12:02,180 --> 01:12:03,930

시간이 좀 부족해서 전부 다 적지는

1695
01:12:03,930 --> 01:12:05,597
못하겠어요
.

1696
01:12:05,597 --> 01:12:07,160
여러분은
그게 무슨 뜻인지 알잖아요.

1697
01:12:07,160 --> 01:12:08,780
여기서는

1698
01:12:08,780 --> 01:12:12,740
이중 연결 리스트라는 점을 이용하여
요소들을 다시 연결할 수 있도록 하고 있습니다.

1699
01:12:12,740 --> 01:12:16,260

세 가지 요점을 다 말씀해 주실 필요는 없어요.

1700
01:12:16,260 --> 01:12:20,840
이전 요점부터 다음 요점까지, 그러니까 제가 다음에 해야 할 일의 순서 같은 거요.

1701
01:12:20,840 --> 01:12:21,375
그렇죠?  포인터를

1702
01:12:21,375 --> 01:12:23,000

다시 연결하는 방법은

1703
01:12:23,000 --> 01:12:27,110

이미 1번 문제에서 다뤘으니 굳이 다시 알려주실 필요 없어요

1704
01:12:27,110 --> 01:12:27,878
.

1705
01:12:27,878 --> 01:12:30,420
청중: 일반적으로,

1706
01:12:30,420 --> 01:12:32,342

이중 연결 리스트를 사용하지 않는 상황에서는 어떻게 해야 할까요?

1707
01:12:32,342 --> 01:12:33,050
제이슨 쿠: 네.

1708
01:12:33,050 --> 01:12:34,040
대상:
연결 리스트 하나만으로는

1709
01:12:34,040 --> 01:12:35,420

이중 연결 리스트보다

1710
01:12:35,420 --> 01:12:37,220

문제를 항상 해결할 수 있을 것 같은 경우.

1711
01:12:37,220 --> 01:12:37,845
제이슨 쿠: 네.  이론적인 문제에서 이중

1712
01:12:37,845 --> 01:12:40,430
연결 리스트는 단일 연결 리스트보다
거의 항상 더 우수합니다

1713
01:12:40,430 --> 01:12:42,380

.  네

1714
01:12:42,380 --> 01:12:47,540
, 그러니 마음껏 사용하세요.

1715
01:12:47,540 --> 01:12:48,680
좋아요.

1716
01:12:48,680 --> 01:12:50,420
그리고 마지막으로 자리에 앉으세요.

1717
01:12:55,090 --> 01:12:59,890
그건 그냥
시퀀스의 앞부분을 가져와서

1718
01:12:59,890 --> 01:13:03,760
제거하고
머리 부분을 바꾸는 건데,

1719
01:13:03,760 --> 01:13:06,880

먼저 삭제할 수도 있다는 건 이해해요.

1720
01:13:06,880 --> 01:13:09,350
당신은
우리가 이전에 사용했던 인터페이스로 축소하고 있습니다.

1721
01:13:09,350 --> 01:13:12,490

순서상 첫 번째 항목을 삭제하고 있습니다.

1722
01:13:12,490 --> 01:13:14,870
하지만 지금 우리는 한 가지 상황에 직면해 있습니다.

1723
01:13:14,870 --> 01:13:16,360
첫 번째 사람을 삭제했어요.

1724
01:13:16,360 --> 01:13:19,150

첫 번째 남자가 누군지 어떻게 알 수 있죠?

1725
01:13:19,150 --> 01:13:21,320
네,
거기에 이름을 저장하고 있어요.

1726
01:13:21,320 --> 01:13:23,180
저는
이 고객들의 이름을 저장하고 있습니다.

1727
01:13:23,180 --> 01:13:27,220
그래서 누가 맨 앞에 있는지 알 수 있고
, 이 데이터 구조에서

1728
01:13:27,220 --> 01:13:29,813

해당 항목을 제거하면 됩니다.

1729
01:13:29,813 --> 01:13:30,730
이해가 되시나요?

1730
01:13:30,730 --> 01:13:34,270
이제 나는
그가 어디로 가는지 더 이상 신경 쓸 필요가 없으니까요.

1731
01:13:34,270 --> 01:13:38,500
사실,
저는

1732
01:13:38,500 --> 01:13:40,790
이 데이터 구조를 업데이트하지 않을 수도 있습니다.

1733
01:13:40,790 --> 01:13:43,360
하지만 그렇게 하면,
제 달리기 시간은

1734
01:13:43,360 --> 01:13:45,010
여전히 ​​선형 시간이 되잖아요.

1735
01:13:45,010 --> 01:13:46,900

공간에 대한 제한은 두지 않겠습니다.  아직

1736
01:13:46,900 --> 01:13:50,440
시간이 일정하지 않아서 죄송합니다.

1737
01:13:50,440 --> 01:13:53,320
그러니까 실제로 그 명단에서 고객을
삭제할 필요는 없지만,

1738
01:13:53,320 --> 01:13:56,440
만약 그 고객이
다시 돌아와서

1739
01:13:56,440 --> 01:14:00,565
대기자 명단에 다시 이름을 올리고 싶어 한다면
고려해야 할 사항들이 있습니다.

1740
01:14:03,710 --> 01:14:04,210
좋아요.

1741
01:14:04,210 --> 01:14:07,130
그래서 그 질문은 바로 그거예요.

1742
01:14:07,130 --> 01:14:11,500
다음 질문은 마지막
10분 정도 남았습니다.

1743
01:14:11,500 --> 01:14:12,790
라니 리서치.

1744
01:14:12,790 --> 01:14:20,260
이는
사람들이 악몽에서나 겪을 법한 문제입니다.  네

1745
01:14:20,260 --> 01:14:25,330
, 그러니까 기본적으로 우리는
미더 완을 갖게 된 거죠.

1746
01:14:25,330 --> 01:14:26,680
그는 기상캐스터입니다.

1747
01:14:26,680 --> 01:14:30,850

전 세계 강우량을 연구하는 과학자.

1748
01:14:30,850 --> 01:14:34,450
그리고 그는 온
사방에 센서를 잔뜩 설치해 놨어요.

1749
01:14:34,450 --> 01:14:37,540
그리고 각각은 강우량을 나타내는

1750
01:14:37,540 --> 01:14:39,910


1751
01:14:39,910 --> 01:14:43,150
정수 r, l,
t의 세 자리 숫자로 이루어진 측정값을 클라우드 등에 게시할 수 있습니다

1752
01:14:43,150 --> 01:14:46,690

.

1753
01:14:46,690 --> 01:14:51,470
위도,
다시 정수입니다.  그리고 한 번에.

1754
01:14:51,470 --> 01:14:53,150
우리가
처리해야 할 일은 세 가지입니다.

1755
01:14:53,150 --> 01:14:53,650
왝.

1756
01:14:56,478 --> 01:14:57,520
하지만 그것들은 모두 정수입니다.

1757
01:14:57,520 --> 01:14:59,830
그리고 "
아, 제이슨,

1758
01:14:59,830 --> 01:15:03,260
위도는 생각보다 작잖아."라고 말하지 마세요.

1759
01:15:03,260 --> 01:15:06,370
그러므로 이
정수들은 작고

1760
01:15:06,370 --> 01:15:09,010
이러한 작업들은
일정한 시간이 걸린다고 가정할 수 있습니다.  저는

1761
01:15:09,010 --> 01:15:11,530


1762
01:15:11,530 --> 01:15:13,600
이 정수들을 측정하는 해상도를 구체적으로 명시하지 않겠습니다.

1763
01:15:13,600 --> 01:15:16,630
그리고 저는 제가 측정한 횟수와 해당 해상도 사이의 상한선을 제시하지 않았기

1764
01:15:16,630 --> 01:15:18,790


1765
01:15:18,790 --> 01:15:20,000
때문에 그런 논쟁은 하지 않습니다.

1766
01:15:20,000 --> 01:15:21,130
좋아요.  특정 시점 이후

1767
01:15:21,130 --> 01:15:24,880

특정 위도에서의 최대 강우량은 해당 시점

1768
01:15:24,880 --> 01:15:29,650


1769
01:15:29,650 --> 01:15:33,520


1770
01:15:33,520 --> 01:15:35,820
이상 또는
같은 시점에 해당 위도에서 측정된 모든 강우량 중 최대값입니다.

1771
01:15:35,820 --> 01:15:37,270
이해가 되시나요?

1772
01:15:37,270 --> 01:15:39,940

해당 위도에 측정값이 없으면 0입니다.

1773
01:15:39,940 --> 01:15:40,690
좋아요.  정해진

1774
01:15:40,690 --> 01:15:44,380
시간 이후에 득점하거나, 정해진
시간 전에 득점하거나, 또는 어떤 상황이든 상관없이.

1775
01:15:44,380 --> 01:15:50,110

상수 시간 내에 구축할 수 있는 데이터베이스를 설명하십시오.  이건

1776
01:15:50,110 --> 01:15:51,100
빈 칸이에요. 지난 봄에 우리가 이 부분을 제대로 관리하지 못해서

1777
01:15:51,100 --> 01:15:53,020
제가 추가한 거예요

1778
01:15:53,020 --> 01:15:55,810
.

1779
01:15:55,810 --> 01:15:57,250
데이터를 기록하세요.

1780
01:15:57,250 --> 01:15:58,810
저희는 당신에게 세 쌍둥이를 드립니다.

1781
01:15:58,810 --> 01:16:02,170
그리고 나서, 데이터가
정확하려면,

1782
01:16:02,170 --> 01:16:05,092
저는
그 정보를 계속 유지해야 합니다.

1783
01:16:05,092 --> 01:16:07,810
이런 종류의
업데이트에 대해서는, 저는 솔직히 이게 옳다고

1784
01:16:07,810 --> 01:16:11,470
주장하기가 정말 어렵습니다
.

1785
01:16:11,470 --> 01:16:12,670
왜냐하면 저는 그냥

1786
01:16:12,670 --> 01:16:15,130

데이터베이스에 데이터를 입력하기만 하면 되니까요. 데이터베이스는

1787
01:16:15,130 --> 01:16:17,890

저에게 아무것도 반환할 필요가 없어요.  여기서 정확성과 관련하여

1788
01:16:17,890 --> 01:16:20,980
중요한 점은

1789
01:16:20,980 --> 01:16:24,255
최대 강우량이 제가

1790
01:16:24,255 --> 01:16:25,880

원하는 시간 범위 내에서 정확한 정보를 제공한다는 것입니다.

1791
01:16:25,880 --> 01:16:28,030
그리고 최대 강우량은 특정 위도에서 t 이후의
최대 강우량을 다시 나타냅니다

1792
01:16:28,030 --> 01:16:31,960

.

1793
01:16:31,960 --> 01:16:33,790
그래서 우리에게는 세 가지가 있습니다.  네

1794
01:16:33,790 --> 01:16:34,466
?

1795
01:16:34,466 --> 01:16:35,924
청중:

1796
01:16:35,924 --> 01:16:39,290
측정값을 반환할 필요가 전혀 없다는 점을 고려할 때,
[알아들을 수 없는 부분]은

1797
01:16:39,290 --> 01:16:40,413
그 기록을 가지고 있습니까?

1798
01:16:40,413 --> 01:16:42,080
제이슨 쿠: 기본적으로

1799
01:16:42,080 --> 01:16:44,600


1800
01:16:44,600 --> 01:16:46,880
우리가
하는 일은

1801
01:16:46,880 --> 01:16:49,340
R 값만 반환하는 것이기 때문에 모든 정보를 저장할 필요가 없을 가능성이 있습니다.

1802
01:16:49,340 --> 01:16:52,670

위도

1803
01:16:52,670 --> 01:16:54,380
나 시간을 전혀 저장할 필요가 없을 수도 있습니다.

1804
01:16:54,380 --> 01:16:56,360

세 쌍둥이를 보관할 필요조차 없습니다.

1805
01:16:56,360 --> 01:17:00,980
지금 제가 문의하는 정보는
위도와 시간입니다.

1806
01:17:00,980 --> 01:17:03,518
그러니 어딘가에 저장해야겠지만,

1807
01:17:03,518 --> 01:17:05,060

압축할 수도 있을 것 같아요.

1808
01:17:05,060 --> 01:17:11,540
특히, 많은 것들을
같은 위도에 저장할 수 있습니다.

1809
01:17:11,540 --> 01:17:13,610
그게 바로 이
질문의 핵심입니다.

1810
01:17:13,610 --> 01:17:15,500
그래서 우리는, 그러니까, 위도 정보는

1811
01:17:15,500 --> 01:17:18,120

한 번만 저장하면 될 수도 있다는 거죠.

1812
01:17:18,120 --> 01:17:19,560
이해가 되시나요?

1813
01:17:19,560 --> 01:17:20,060
좋아요.  저는

1814
01:17:20,060 --> 01:17:21,770


1815
01:17:21,770 --> 01:17:25,140

이 문제에 대한 해결책을 먼저 말씀드리고 싶기 때문에 질문은 나중에 받겠습니다.

1816
01:17:25,140 --> 01:17:25,640
괜찮은.

1817
01:17:25,640 --> 01:17:28,030
그렇다면 우리는 무엇을 해야 할까요?

1818
01:17:28,030 --> 01:17:29,870
우리는
항목을 추가할 수 있어야 합니다.

1819
01:17:29,870 --> 01:17:31,110
그리고 저는 돌아가고 싶습니다.

1820
01:17:31,110 --> 01:17:34,125
그러니까, 저는
뭔가를 조회해야 하고, 그

1821
01:17:34,125 --> 01:17:35,750
다음에
뭔가를 반환해야 할 겁니다.

1822
01:17:35,750 --> 01:17:40,828
그러므로
시간 t 이후 위도 l에서의 최대 강우량을 반환하십시오.

1823
01:17:40,828 --> 01:17:42,620

특정 쿼리에서 내가 중요하게 생각하는 것은 무엇인가?

1824
01:17:42,620 --> 01:17:48,860
저는
위도 l에 있는 모든 것들에만 관심이 있습니다.

1825
01:17:48,860 --> 01:17:52,700
사실
그렇게 흥미로운 내용은 아니지만, L 하나당

1826
01:17:52,700 --> 01:17:55,850

여러 개의 데이터 구조를

1827
01:17:55,850 --> 01:17:59,120
연결할 수 있으면 좋겠어요.
이해가 되시나요?

1828
01:17:59,120 --> 01:18:05,210
그렇다면
각 L 항목에서 하나씩 빨리 찾으려면 어떻게 해야 할까요?

1829
01:18:05,210 --> 01:18:06,210
사전에 등재하세요.

1830
01:18:06,210 --> 01:18:07,370
제 시간 제한은 어떻게 되나요?

1831
01:18:07,370 --> 01:18:08,650
최악의 경우 로그 n.

1832
01:18:08,650 --> 01:18:11,430
그렇다면
해당 데이터 구조를 표현하기 위해 어떤 데이터 구조를 사용해야 할까요?

1833
01:18:11,430 --> 01:18:12,710
AVL 세트.

1834
01:18:12,710 --> 01:18:17,180
그래서
먼저

1835
01:18:20,840 --> 01:18:33,500
위도를 매핑하는 AVL(예: L) 세트를 만들게 되는데

1836
01:18:33,500 --> 01:18:36,903
, 이제
데이터 구조가 더 많아졌습니다.  위도가 같은 여러

1837
01:18:36,903 --> 01:18:38,570

항목들을

1838
01:18:38,570 --> 01:18:41,710

다른 데이터 구조에 저장하고 싶습니다.  아마도

1839
01:18:41,710 --> 01:18:45,230


1840
01:18:45,230 --> 01:18:47,340

그 모든 측정값의 강우 시간에 시간을 저장하는 것들이겠죠.

1841
01:18:47,340 --> 01:18:49,510
응?

1842
01:18:49,510 --> 01:18:50,122
응.

1843
01:18:50,122 --> 01:18:51,080
대상: 해시 테이블.

1844
01:18:51,080 --> 01:18:52,038
제이슨 쿠: 해시 테이블입니다.

1845
01:18:52,038 --> 01:18:53,810
좋아요, 그럼 같은 위도에 있는 것들에 대해 어떤 종류
의 쿼리를

1846
01:18:53,810 --> 01:18:57,030
실행하고 싶을까요
?

1847
01:18:57,030 --> 01:18:59,030
청중:
시간을 알아두시는 게 좋을 거예요.

1848
01:18:59,030 --> 01:19:00,905
제이슨 쿠: 저는
시간 정보도 얻고 싶지만, 그보다

1849
01:19:00,905 --> 01:19:04,520
더 중요한 건
정렬된 쿼리를 실행하는 것입니다.

1850
01:19:04,520 --> 01:19:08,300
저는 특정 시간보다 더 빨리 그 물건들이 필요해요
.

1851
01:19:08,300 --> 01:19:09,077
더 큰, 죄송합니다.

1852
01:19:09,077 --> 01:19:10,160
관객: 그러니까 정말…

1853
01:19:10,160 --> 01:19:11,302
제이슨 쿠: 잠깐만요.

1854
01:19:11,302 --> 01:19:13,260
관객:
시간 안내용 AVL

1855
01:19:13,260 --> 01:19:15,060
과 비 오는 날 안내용 AVL을 틀어주실 수 있을까요?

1856
01:19:15,060 --> 01:19:15,620
제이슨 쿠: 알겠습니다.

1857
01:19:15,620 --> 01:19:18,290

비 오는 날 AVL이 필요할까요?

1858
01:19:18,290 --> 01:19:22,348
그러니까, 하늘을 올려다보며
빗줄기를 바라보는 거죠.

1859
01:19:22,348 --> 01:19:22,890
청중: 아니요.

1860
01:19:22,890 --> 01:19:23,862
제이슨 쿠: 아니요.

1861
01:19:23,862 --> 01:19:25,820
그래서 저는 위도 l을 특정 값에 매핑하는

1862
01:19:25,820 --> 01:19:37,370
시간 정렬 AVL에 이 값들을 저장할 겁니다.

1863
01:19:37,370 --> 01:19:39,860
이
데이터 구조를 시간 데이터

1864
01:19:39,860 --> 01:19:40,520
구조라고 부르겠습니다.  제 생각엔

1865
01:19:40,520 --> 01:19:43,430
t of l인 것 같아요.

1866
01:19:43,430 --> 01:19:44,990
그건 마치
재발하는 것처럼 보여서

1867
01:19:44,990 --> 01:19:46,280

지금 좀 신경 쓰이긴

1868
01:19:46,280 --> 01:19:47,590
하지만, 딱히 다른 방법이 없네요
.

1869
01:19:47,590 --> 01:19:48,090
괜찮은.

1870
01:19:48,090 --> 01:19:51,680
따라서 이제 이러한
시간 데이터 구조 각각은 강우량 측정값에

1871
01:19:51,680 --> 01:20:08,840
시간을 매핑하는 AVL 집합입니다
.

1872
01:20:08,840 --> 01:20:10,160
괜찮은.

1873
01:20:10,160 --> 01:20:11,450
그러니까

1874
01:20:11,450 --> 01:20:15,060
제 쿼리가 "최대 강우량을 반환해 주세요"였다면...

1875
01:20:15,060 --> 01:20:15,560
죄송합니다.

1876
01:20:15,560 --> 01:20:22,820

위도 l과 시간 t를 가진 지점의 강우량을 반환하면, 거의 다 끝난 셈이죠

1877
01:20:22,820 --> 01:20:24,350
.

1878
01:20:24,350 --> 01:20:27,500
당신은
그 문의에 어떻게 답변해야 할지 알겠죠.

1879
01:20:27,500 --> 01:20:29,270
데이터를 삽입하려면 두

1880
01:20:29,270 --> 01:20:32,450
데이터 구조 모두에 삽입한 다음 조회하면 됩니다
.  여기서

1881
01:20:32,450 --> 01:20:34,880
한 가지 복잡한 점은
제가

1882
01:20:34,880 --> 01:20:39,740

특정 시점의 강우량을 묻는 것이 아니라는 것입니다.

1883
01:20:39,740 --> 01:20:44,180

이번 시기 최대 강우량이 얼마인지 알고 싶습니다.

1884
01:20:44,180 --> 01:20:45,200
좋아요.

1885
01:20:45,200 --> 01:20:49,040

전역 최대값을 알고 싶다면 max heap이 유용합니다.

1886
01:20:49,040 --> 01:20:54,200
하지만 여기서는
특정 범위 내의 최댓값을 알고 싶습니다.  자, 그럼 이제부터

1887
01:20:56,180 --> 01:20:57,860

질문하실 수 있어요.

1888
01:20:57,860 --> 01:21:00,350

시간이 얼마 남지 않았거든요.

1889
01:21:00,350 --> 01:21:03,810
그래서 어떻게 해야 할지 아이디어 있는 사람 있나요

1890
01:21:03,810 --> 01:21:04,310
?

1891
01:21:04,310 --> 01:21:06,723
청중:
AVL을 최대치로 증폭시켜 주시겠어요?

1892
01:21:06,723 --> 01:21:07,265
제이슨 쿠: 알겠습니다.

1893
01:21:07,265 --> 01:21:08,710
청중: 그럼
해당 아이를 살펴보고

1894
01:21:08,710 --> 01:21:10,700

그 시점에서 최대치를 확인하면 되는 건가요?

1895
01:21:10,700 --> 01:21:11,408
제이슨 쿠: 아, 알겠습니다.

1896
01:21:11,408 --> 01:21:12,920
그러니까
동료분이 말씀하시는 건,

1897
01:21:12,920 --> 01:21:18,110

서브트리에서 최대 r 값을 추가하면 그 값을

1898
01:21:18,110 --> 01:21:21,800
이용해서
이 쿼리를 해결할 수 있을지도 모른다는 거죠.

1899
01:21:21,800 --> 01:21:24,410
우리가 시간 t를 기준으로 정렬되어 있기 때문에,

1900
01:21:24,410 --> 01:21:28,190


1901
01:21:28,190 --> 01:21:30,980
제 쿼리에 포함될 모든 것, 즉 특정 노드에서

1902
01:21:30,980 --> 01:21:35,210


1903
01:21:35,210 --> 01:21:41,700
제 시간이 t보다 크면
, 오른쪽에 있는 모든 항목

1904
01:21:41,700 --> 01:21:43,260


1905
01:21:43,260 --> 01:21:48,870
도 그 t보다 크다는 훌륭한 단조 속성이 있습니다. 이는
제 데이터 구조의 순서

1906
01:21:48,870 --> 01:21:51,690
, 즉
시간을 기준으로 정렬되어 있기 때문입니다.

1907
01:21:51,690 --> 01:21:54,240
그래서
만약 제가

1908
01:21:54,240 --> 01:21:56,520
오른쪽
서브트리를 살펴본다면,

1909
01:21:56,520 --> 01:21:59,910


1910
01:21:59,910 --> 01:22:01,980
그 서브트리의 최댓값만으로는 이 모든 곳에서 작업을 수행할 수 없을 가능성이 있습니다.

1911
01:22:01,980 --> 01:22:15,000
그러니까, 그건 예를 들어
서브트리 최대 r로 증강된 아이디어라고 할 수 있겠네요.  아마

1912
01:22:15,000 --> 01:22:17,290

이것에도 이름을 붙여주고 싶을 거예요.

1913
01:22:17,290 --> 01:22:24,840
그러니까 v max처럼, 여기서 v는
내 시스템의 노드입니다.

1914
01:22:24,840 --> 01:22:28,530
그리고 저는
이것을 어떻게 뒷받침할 수 있는지, 즉 하위 요소들로부터 어떻게 계산할 수 있는지를 보여드리고 싶습니다

1915
01:22:28,530 --> 01:22:29,980
.

1916
01:22:29,980 --> 01:22:33,690
그렇다면
이 쿼리를 실제로 어떻게 지원할 수 있을까요?

1917
01:22:33,690 --> 01:22:37,380
재귀적인 관점에서 생각해 볼 수 있겠네요.

1918
01:22:37,380 --> 01:22:39,400
제게는 몇 가지 사건이 있습니다.

1919
01:22:39,400 --> 01:22:44,190
만약 제가 여기서 v 위치에 있다면,

1920
01:22:44,190 --> 01:22:52,200

주어진 노드의 최대 강우량을

1921
01:22:52,200 --> 01:22:52,770
t로 하한값을 갖는 재귀 함수를 정의하고 싶습니다.

1922
01:22:55,920 --> 01:22:59,190
제가 여기 있다면
두 가지 경우가 있습니다.

1923
01:22:59,190 --> 01:23:03,885
내 시간(t)이 더 크
거나 작거나, 내 범위 안에 있거나

1924
01:23:03,885 --> 01:23:06,690
범위를 벗어나거나 둘 중 하나입니다.

1925
01:23:06,690 --> 01:23:08,850
내
능력 밖의 일이라면 어떻게 해야 하나요?

1926
01:23:08,850 --> 01:23:12,120
시간 제한보다 낮습니다.

1927
01:23:12,120 --> 01:23:16,140

이 노드에서 이 함수를 재귀적으로 호출하면 됩니다.

1928
01:23:16,140 --> 01:23:19,290


1929
01:23:19,290 --> 01:23:23,460

내가 소중히 여기는 모든 것이 여기에 있을 거라는 걸 알기 때문이야.

1930
01:23:23,460 --> 01:23:26,400
그리고 그건
트리를 따라 내려가는 재귀 호출 한 번에 불과합니다.

1931
01:23:26,400 --> 01:23:29,490
따라서 트리를 따라
재귀 호출을 한 번만 하도록 제한하면 매번 아래쪽으로 내려가게 됩니다

1932
01:23:29,490 --> 01:23:32,490

.

1933
01:23:32,490 --> 01:23:34,920
이 작업은
로그 시간 복잡도로 걸릴 것입니다.  자,

1934
01:23:34,920 --> 01:23:37,740
이게 첫 번째 경우,
쉬운 경우입니다.

1935
01:23:37,740 --> 01:23:41,220
이 객체는 범위 내에 없으므로 오른쪽에 있는
객체를 재귀적으로 반환합니다

1936
01:23:41,220 --> 01:23:42,133
.

1937
01:23:42,133 --> 01:23:43,050
다른 사건은 뭔가요?

1938
01:23:43,050 --> 01:23:46,440
저는 제 사정권 안에 있어요.  자,

1939
01:23:46,440 --> 01:23:51,240
이제 저는 돌아가서
양쪽 모두를 재귀적으로 호출할 수 있겠네요.

1940
01:23:51,240 --> 01:23:53,640
이
봉우리가 바로 그것을 말해주고 있기 때문입니다.

1941
01:23:53,640 --> 01:23:55,020
우리 지역의 최대 강우량은 언제인가요?

1942
01:23:55,020 --> 01:23:57,720
하지만 만약 제가 그렇게 한다면, 즉
여기서 재귀적으로 호출하고

1943
01:23:57,720 --> 01:24:00,750
여기서도 재귀적으로 호출한다면,
선형 시간 복잡도가 걸릴 수 있습니다.

1944
01:24:00,750 --> 01:24:03,600
저는
제 트리의 모든 노드를 건드릴 수도 있습니다.

1945
01:24:03,600 --> 01:24:05,300
그렇다면 저는 왜
이런 증강현실 작업을 했을까요?

1946
01:24:05,300 --> 01:24:07,800
그래서 저는
이 노드에서 작업을 할 필요가 없습니다.

1947
01:24:07,800 --> 01:24:12,780

이 하위 트리의 최대 강우량을 반환한

1948
01:24:12,780 --> 01:24:15,090
다음 이쪽에서 재귀 호출을 수행합니다.

1949
01:24:15,090 --> 01:24:18,060
그래서 저는
이쪽에서 계속 작업을 진행했고, 아래쪽에

1950
01:24:18,060 --> 01:24:19,750
재귀 호출을 하나 했는데, 이 호출을 통해 트리의 맨

1951
01:24:19,750 --> 01:24:21,750

아래까지 내려갈 수도 있지만 괜찮습니다.

1952
01:24:21,750 --> 01:24:24,863

트리의 맨 아래까지 내려가도 상관없으니까요.

1953
01:24:24,863 --> 01:24:25,780
이해가 되시나요?

1954
01:24:25,780 --> 01:24:29,850
만약 두 개의
하위 트리 중 하나라도 없으면, 저는 끝난 겁니다.

1955
01:24:29,850 --> 01:24:31,420
언제든지.

1956
01:24:31,420 --> 01:24:33,660


1957
01:24:33,660 --> 01:24:40,500
재귀 호출을 해야 할 노드가 없으므로,
이 서브트리의 최댓값과 제 값,

1958
01:24:40,500 --> 01:24:43,860
그리고 재귀 호출의
반환 값을 모두 취합니다.

1959
01:24:43,860 --> 01:24:47,070
세 값을 비교하여
최댓값을 반환합니다.

1960
01:24:47,070 --> 01:24:48,280
이해가 되시나요?

1961
01:24:48,280 --> 01:24:48,780
좋아요.  이것이 바로

1962
01:24:48,780 --> 01:24:52,380
우리가
단측 범위 쿼리라고 부르는 것입니다.

1963
01:24:52,380 --> 01:24:58,260
제가 아직 살펴보지 못한 문제 풀이
세션 4에서,

1964
01:24:58,260 --> 01:25:02,100


1965
01:25:02,100 --> 01:25:05,610

두 값 사이의 모든 값 중 최댓값을 알아야 하는 양방향 범위 쿼리 방법을 보여줍니다

1966
01:25:05,610 --> 01:25:07,170
.

1967
01:25:07,170 --> 01:25:09,930
하지만

1968
01:25:09,930 --> 01:25:13,560


1969
01:25:13,560 --> 01:25:18,210

양쪽에서 재귀 호출을 하지 않아도 되도록 함수 확장을 사용하는 재귀 함수를 찾는 것은 사실 이보다 더 어렵지 않습니다.

1970
01:25:18,210 --> 01:25:19,740
이해가 되시나요?

1971
01:25:19,740 --> 01:25:21,000
좋아요.  오늘은 여기까지입니다.

1972
01:25:21,000 --> 01:25:25,830

질문은 나중에 받겠습니다.  와주셔서

1973
01:25:25,830 --> 01:25:27,740
감사합니다.

