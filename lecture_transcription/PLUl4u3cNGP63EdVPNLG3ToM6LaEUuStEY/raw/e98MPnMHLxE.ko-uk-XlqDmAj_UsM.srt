1
00:00:00,000 --> 00:00:01,964
[끽끽거리는 소리]

2
00:00:01,964 --> 00:00:03,927
[속삭임]

3
00:00:03,927 --> 00:00:06,383
[딸깍 하는 소리]

4
00:00:12,779 --> 00:00:14,129
제이슨 쿠: 알겠습니다.

5
00:00:14,130 --> 00:00:16,018
여러분 모두 환영합니다.

6
00:00:16,018 --> 00:00:17,579
퀴즈 준비되셨나요?

7
00:00:17,579 --> 00:00:18,539
청중: 없음.

8
00:00:18,539 --> 00:00:19,710
제이슨 쿠: 다음 주에 시험이 있어요.

9
00:00:19,710 --> 00:00:20,280
예

10
00:00:20,280 --> 00:00:22,530
여러분 모두에게 희망을 드립니다
여기서는, 아시다시피,

11
00:00:22,530 --> 00:00:23,790
다음 주에 퀴즈가 있을 거예요.

12
00:00:23,789 --> 00:00:24,300
좋은.

13
00:00:24,300 --> 00:00:26,250
그렇다면 이 퀴즈는 무엇에 관한 것일까요?  물론,

14
00:00:26,250 --> 00:00:27,870
이것이 바로
우리가 무슨 얘기를 하고 있었죠?

15
00:00:27,870 --> 00:00:29,429
이번 수업에서.

16
00:00:29,429 --> 00:00:31,079
이 수업은 무엇에 관한 수업인가요?

17
00:00:31,079 --> 00:00:34,089
혹시 기억하는 사람 있나요?
제 첫 강의요?

18
00:00:34,090 --> 00:00:35,160
이 수업은 무엇에 관한 수업인가요?

19
00:00:35,159 --> 00:00:37,242
우리가 하려는 일은 무엇일까요?
이번 수업에서 당신을 시험하려는 건가요?

20
00:00:37,243 --> 00:00:38,160
대상: 알고리즘.

21
00:00:38,159 --> 00:00:39,034
제이슨 쿠: 알고리즘.

22
00:00:39,034 --> 00:00:39,779
아주

23
00:00:39,780 --> 00:00:40,655
또한 데이터 구조도 포함됩니다.

24
00:00:40,655 --> 00:00:41,155
오른쪽?

25
00:00:41,155 --> 00:00:42,750
첫 번째는 다음과 같습니다.
이것의 일부입니다.

26
00:00:42,750 --> 00:00:45,869
하지만 사실 그건 당신을 만들기 위한 거예요
계산 문제를 해결합니다.

27
00:00:45,869 --> 00:00:47,789
이것이 첫 번째입니다.

28
00:00:47,789 --> 00:00:52,000
다른 사람과 논쟁하는 방법을 알아라.
정말 해결하셨군요.

29
00:00:52,000 --> 00:00:52,500
오른쪽?

30
00:00:52,500 --> 00:00:53,280
좋아요.

31
00:00:53,280 --> 00:00:54,000
오른쪽?

32
00:00:54,000 --> 00:00:56,009
무엇을 선택하셨나요?
다른 것들보다 낫다,

33
00:00:56,009 --> 00:00:56,909
그것이 효과적이라는 것입니다.

34
00:00:56,909 --> 00:00:57,689
오른쪽?

35
00:00:57,689 --> 00:01:00,239
그럼 어떤 내용을 보도할 수 있나요?
이런 것들을 다른 사람들에게.

36
00:01:00,240 --> 00:01:00,750
오른쪽?

37
00:01:00,750 --> 00:01:04,890
제가 가장 중요하게 생각하는 네 가지는 바로 이것들입니다.
당신이 배우도록 만들어요.

38
00:01:04,890 --> 00:01:06,959
그래서
우리의 테스트

39
00:01:06,959 --> 00:01:08,869
그들은 당신을 평가하려고 할 것입니다.

40
00:01:08,870 --> 00:01:09,469
좋은.

41
00:01:09,469 --> 00:01:15,569
그러므로, 일부를 제외하고는
사소한 것들,

42
00:01:15,569 --> 00:01:17,279
우리가 하는 일
학기 초,

43
00:01:17,280 --> 00:01:21,010
우리에 대해 이야기하는 것처럼
컴퓨팅 모델.

44
00:01:21,010 --> 00:01:21,510
오른쪽?

45
00:01:21,510 --> 00:01:26,620
우리의 모델과 점근적 거동.

46
00:01:26,620 --> 00:01:31,500
비대칭 - 심오함.

47
00:01:31,500 --> 00:01:33,900
맞습니까?

48
00:01:33,900 --> 00:01:37,469
재발이죠, 그렇죠?

49
00:01:37,469 --> 00:01:39,989
게다가
그러한 토대 위에서 우리는

50
00:01:39,989 --> 00:01:42,719
그럼 바로 알고리즘에 대해 알아보겠습니다.

51
00:01:42,719 --> 00:01:43,829
오른쪽?

52
00:01:43,829 --> 00:01:48,060
그것
거의 정의에 가깝다.

53
00:01:48,060 --> 00:01:49,920
우리는 이것들에 그다지 의존하지 않습니다.
것들.

54
00:01:49,920 --> 00:01:52,213
우리는 항상 이런 것들에 의존하고 있잖아요.
것들.

55
00:01:52,212 --> 00:01:53,878
하지만 이건 좀...
우리가 수학

56
00:01:53,878 --> 00:01:54,929
우리는 예전에 이런저런 이야기를 나누곤 했어요.

57
00:01:54,930 --> 00:01:55,440
오른쪽?

58
00:01:55,439 --> 00:01:57,179
우리가 어떻게 말할 수 있을까요?
얼마나 걸리나요?

59
00:01:57,180 --> 00:01:58,860
논쟁할 수 없다면, 받아들이세요.

60
00:01:58,859 --> 00:02:01,260
우리는 이런 식으로 추상화할 수 있습니다.
이 자료를 구할 수 없다는 것입니다.

61
00:02:01,260 --> 00:02:02,730
실제 컴퓨터에서.

62
00:02:02,730 --> 00:02:04,650
우리 상황과 같아요
컴퓨터 속의 의식.

63
00:02:04,650 --> 00:02:06,483
그리고 우리는 생각하고 있습니다
이것들에 관해서

64
00:02:06,483 --> 00:02:09,300
수량을 기준으로
상수 시간 연산, 즉

65
00:02:09,300 --> 00:02:12,237
이 마법의 컴퓨터를 가질 수 있습니다.

66
00:02:12,236 --> 00:02:14,069
꽤 괜찮네요
어떤 프레젠테이션이든

67
00:02:14,069 --> 00:02:16,989
당신이 가진 컴퓨터
특정 가정 하에.

68
00:02:16,990 --> 00:02:17,490
오른쪽?

69
00:02:17,490 --> 00:02:20,430
우리는... 그러니까, 뭐요?

70
00:02:20,430 --> 00:02:23,790
우리는 당신과 논의해야 할 골칫거리가 많지 않았습니다.

71
00:02:23,789 --> 00:02:27,496
이런 것들,
특히, 보통

72
00:02:27,497 --> 00:02:28,829
그것들은 또 다른 문제의 일부였다.

73
00:02:28,829 --> 00:02:29,340
오른쪽?

74
00:02:29,340 --> 00:02:33,000
설명을 해주셨어야 합니다.
이 제품의 작동 시간.

75
00:02:33,000 --> 00:02:34,974
그리고 당신도 아마 그럴 겁니다.
재시험 여부를 결정해야 했다.

76
00:02:34,974 --> 00:02:36,599
그리고 어쩌면 당신은
주요 정리를 사용하세요.

77
00:02:36,599 --> 00:02:37,379
그런 것들 말이죠.

78
00:02:37,379 --> 00:02:37,879
오른쪽?

79
00:02:37,879 --> 00:02:39,780
또는 당신
당신은 점근법을 항상 사용하죠.

80
00:02:39,780 --> 00:02:41,819
아니면 필요하신가요?
우리 모델에서 기억해야 할 것은,

81
00:02:41,819 --> 00:02:44,549
아, 그건 어떤 의미가 있군요.
정말 큰 정수네요

82
00:02:44,550 --> 00:02:47,530
저는 데이터를 저장하고 산술 연산을 수행할 수 있습니다.
일정한 시간으로.

83
00:02:47,530 --> 00:02:48,030
오른쪽?

84
00:02:48,030 --> 00:02:50,189
그래서 그 질문에 대한 답은 p-set입니다.
3, 당신이 가졌던 것

85
00:02:50,189 --> 00:02:54,409
끝에서
코딩 질문,

86
00:02:54,409 --> 00:02:56,370
당신은 문제를 해결하고 싶어했죠.

87
00:02:56,370 --> 00:02:59,069
그리고 당신은 청구해야 합니다.
이것들이 잘 맞는다

88
00:02:59,069 --> 00:03:02,069
일정한 양으로
그것을 만들기 위한 단어들

89
00:03:02,069 --> 00:03:03,389
일정한 시간 안에 완료될 수 있습니다.

90
00:03:03,389 --> 00:03:06,089
여러분 중 많은 분들이,
성인 반열에 오르는 것을 발견했습니다

91
00:03:06,090 --> 00:03:11,620
주로 표시되는
기하급수적으로 큰 것들.

92
00:03:11,620 --> 00:03:14,530
그러므로 곱셈이 가능할 수도 있다
소수의 곱 또는 그 비슷한 것

93
00:03:14,530 --> 00:03:15,030
비슷한.

94
00:03:15,030 --> 00:03:17,560
그리고 그건 아닐 거예요
훌륭한 발표였습니다.

95
00:03:17,560 --> 00:03:18,060
좋은.

96
00:03:18,060 --> 00:03:21,930
그래서 이런 일들이 나타나지만,
그것들은 주요 주제가 아닙니다.

97
00:03:21,930 --> 00:03:23,069
우리가 해결하는 문제들.  ~에

98
00:03:23,069 --> 00:03:24,719
왜 초점이...

99
00:03:24,719 --> 00:03:27,240
계산 문제를 어떻게 해결할까요?
이번 수업 과제는 무엇인가요?

100
00:03:27,240 --> 00:03:30,600
제가 두 가지 방법을 알려드렸습니다.
학기 초.

101
00:03:30,599 --> 00:03:33,750
여러분, 기억나세요?

102
00:03:33,750 --> 00:03:45,270
우리는 결정할 수 있다 - 어떻게 결정할지
계산적인-- 계산적인

103
00:03:45,270 --> 00:03:45,770
문제.

104
00:03:51,548 --> 00:03:52,340
험난한 길 하나.

105
00:03:52,340 --> 00:03:53,930
한 가지 간단한 방법.

106
00:03:53,930 --> 00:03:54,890
청중: 무력.

107
00:03:54,889 --> 00:03:55,519
제이슨 쿠: 무력으로요.

108
00:03:55,520 --> 00:03:56,020
좋은.

109
00:03:56,020 --> 00:03:58,909
그러니까, 당신은 설명하고 계신다는 말씀이시군요.
나에게 기술을

110
00:03:58,909 --> 00:04:00,439
나만의 알고리즘을 만들어 보세요.

111
00:04:00,439 --> 00:04:01,159
오른쪽?

112
00:04:01,159 --> 00:04:05,840
저는 제 새로운 디자인을 만들 수 있어요.
알고리즘을 처음부터 개발했습니다.

113
00:04:05,840 --> 00:04:07,689
제가 할 수 있는 한 가지 방법은
이렇게 하는 것은 무차별 대입에 불과합니다.

114
00:04:07,689 --> 00:04:08,189
오른쪽?

115
00:04:08,189 --> 00:04:10,909
모든 가능성을 살펴보세요
결과를 보고 어떤 방법이 효과적인지 확인해 보세요.

116
00:04:10,909 --> 00:04:11,780
오른쪽?

117
00:04:11,780 --> 00:04:14,192
또는 다음과 같이 간략하게 표현할 수도 있습니다.
"분할 통치"처럼

118
00:04:14,192 --> 00:04:15,150
뭐 그런 거죠.

119
00:04:15,150 --> 00:04:16,490
일반적으로 이것은
하기 어렵다 —

120
00:04:16,490 --> 00:04:17,615
자신만의 알고리즘을 만들어 보세요.

121
00:04:17,615 --> 00:04:18,860
오른쪽?

122
00:04:18,860 --> 00:04:21,379
그러므로 이번 수업에서는 여러분에게 다음을 요구하지 않습니다.
엄청 많네요.

123
00:04:21,379 --> 00:04:22,579
046 같은 번호일 거예요.

124
00:04:22,579 --> 00:04:23,079
오른쪽?

125
00:04:23,079 --> 00:04:31,099
자, 그럼 가장 먼저 할 수 있는 일은 다음과 같습니다.
새로운 알고리즘을 작성하는 것입니다.

126
00:04:31,100 --> 00:04:33,409
처음부터.

127
00:04:33,409 --> 00:04:35,189
보통은 완전히 처음부터 만드는 건 아니에요.

128
00:04:35,189 --> 00:04:35,689
오른쪽?

129
00:04:35,689 --> 00:04:38,360
보통은 다음과 같이 됩니다.
알고리즘 설계 패러다임 중 일부,

130
00:04:38,360 --> 00:04:40,939
아마 들어보셨을 겁니다.

131
00:04:40,939 --> 00:04:44,480
앞으로 이 주제에 대해 훨씬 더 많이 이야기하게 될 거예요.
046에서 그리고 이것의 끝에서

132
00:04:44,480 --> 00:04:46,490
이번 학기, 우리가 언제 이야기할까요?
동적 프로그래밍.

133
00:04:46,490 --> 00:04:48,980
하지만 일반적으로는 그렇습니다.
그건 어려운 일이에요.

134
00:04:48,980 --> 00:04:50,270
오른쪽?

135
00:04:50,269 --> 00:04:52,399
당신은 시도하고 있습니다
재귀 알고리즘을 고안해내세요.

136
00:04:52,399 --> 00:04:53,060
오른쪽?

137
00:04:53,060 --> 00:04:55,280
당신은 증명하려고 하는군요,
무엇이 옳은가?

138
00:04:55,279 --> 00:04:57,439
이 모든 사소한 것들—
사실 우리는 그렇습니다.

139
00:04:57,439 --> 00:04:59,269
~ 내내
강의 수업,

140
00:04:59,269 --> 00:05:02,329
보여줬다
당신 알고리즘.

141
00:05:02,329 --> 00:05:05,300
하지만 우리는 그렇게 예상하지 않습니다.
여러분은 이러한 알고리즘을 만들게 될 것입니다.

142
00:05:05,300 --> 00:05:08,660
우리가 당신에게 기대하는 것
대부분 그렇습니다.

143
00:05:08,660 --> 00:05:09,710
예?

144
00:05:09,709 --> 00:05:12,810
이를 다음과 같은 문제로 축소하기 위해
우리는 해결 방법을 보여드렸습니다.

145
00:05:12,810 --> 00:05:13,310
오른쪽?

146
00:05:19,939 --> 00:05:21,829
제가 말씀드리겠습니다
여기 뭔가 있긴 한데, 정말로

147
00:05:21,829 --> 00:05:25,250
제 말은 그 알고리즘을 말하는 겁니다.
우리가 너에게 가르쳤어-

148
00:05:25,250 --> 00:05:28,790
본질적으로 여기에 컴파일됨
이미 알려진 것에 대하여 --

149
00:05:28,790 --> 00:05:31,939
이미 알려진 것에 대하여.

150
00:05:31,939 --> 00:05:36,439
이는 대개 다음과 같은 의미입니다.
문제 또는 인터페이스,

151
00:05:36,439 --> 00:05:38,540
저희가 여러분께 제공해 드린 것입니다.

152
00:05:38,540 --> 00:05:41,720
그리고 전반적으로 우리는 보여주었습니다.
여러 가지 방법이 있습니다.

153
00:05:41,720 --> 00:05:43,770
이것을 해결하다
문제 또는 인터페이스.

154
00:05:43,769 --> 00:05:44,269
오른쪽?

155
00:05:44,269 --> 00:05:48,769
그래서, 우리는 여러분께 많은 것을 보여드렸습니다.
사물을 분류하는 방법.

156
00:05:48,769 --> 00:05:51,049
그리고 우리는 여러분에게 많은 것을 보여드렸습니다.
실행 방법

157
00:05:51,050 --> 00:05:53,840
시퀀스 및 인터페이스 설정.

158
00:05:53,839 --> 00:05:55,339
기억나세요?

159
00:05:55,339 --> 00:05:59,689
그리고 종종
문제의 유형,

160
00:05:59,689 --> 00:06:03,709
저희가 해결해 주시기를 요청드리는 사항입니다.
그냥 블랙박스로 사용하기 위한 것일 뿐입니다.

161
00:06:03,709 --> 00:06:05,039
우리가 했던 일들 중 일부입니다.

162
00:06:05,040 --> 00:06:08,340
하지만 당신은 프로그래머로서,
컴퓨터 과학자로서,

163
00:06:08,339 --> 00:06:12,349
언제쯤인지 알려주셔야 해요
남은 걸 활용해야겠어.

164
00:06:12,350 --> 00:06:12,850
오른쪽?

165
00:06:12,850 --> 00:06:13,310
예?

166
00:06:13,310 --> 00:06:15,980
청중: 무슨 말씀이신지 설명해 주시겠어요?
블랙박스처럼 사용한다는 말씀이신가요?

167
00:06:15,980 --> 00:06:16,970
제이슨 쿠: 블랙박스처럼 사용하세요.

168
00:06:16,970 --> 00:06:17,470
정확히.

169
00:06:17,470 --> 00:06:18,230
오른쪽.

170
00:06:18,230 --> 00:06:20,689
자, 이것은 다음과 같은 문구입니다.
저도 사용하고 있고, 많은 사람들이 사용하고 있습니다.

171
00:06:20,689 --> 00:06:21,920
컴퓨터 과학에서 사용되는 개념입니다.

172
00:06:21,920 --> 00:06:26,030
기본적으로, 당신은 수입하고 있는 것입니다.
라이브러리를 코드에 통합하세요.

173
00:06:26,029 --> 00:06:26,989
오른쪽?

174
00:06:26,990 --> 00:06:27,810
내가 가진 건 뭐지?  안에

175
00:06:27,810 --> 00:06:29,120
저는 API를 가지고 있습니다.  안에

176
00:06:29,120 --> 00:06:31,519
제겐 방법이 있어요.
이 코드와의 상호 작용.

177
00:06:31,519 --> 00:06:32,959
저는 사실 잘 모르겠어요.
나는 그것을 알고 있다

178
00:06:32,959 --> 00:06:35,989
이 도서관 안에서 진행됩니다.

179
00:06:35,990 --> 00:06:37,670
저는 그것을 블랙박스처럼 사용합니다.

180
00:06:37,670 --> 00:06:38,990
제게는 불투명하게 느껴집니다.

181
00:06:38,990 --> 00:06:40,639
안을 들여다볼 수 없어요.

182
00:06:40,639 --> 00:06:43,550
사실 저는 할 수 있어요
내부를 들여다보고, 그들의 코드가 무엇인지 알아보세요.

183
00:06:43,550 --> 00:06:44,750
하지만 저는 그러지 않을 거예요.

184
00:06:44,750 --> 00:06:46,759
이 제품의 기능은 무엇인가요?
제게 유용한 점은 그것이

185
00:06:46,759 --> 00:06:49,459
이것을 가지고 있다
내가 가진 유용한 API

186
00:06:49,459 --> 00:06:52,149
나는 그것을 성취할 것이라고 믿는다
네가 내게 말한 것

187
00:06:52,149 --> 00:06:53,149
.

188
00:06:53,149 --> 00:06:53,689
오른쪽?

189
00:06:53,689 --> 00:06:56,000
그래서 그런 게 좀 있는데...

190
00:06:56,000 --> 00:06:58,490
살짝 뛰어볼게요.
여기,

191
00:06:58,490 --> 00:07:02,100
그건 정말 좋은 질문이니까요.

192
00:07:02,100 --> 00:07:08,330
그래서, 제 생각에는 세 가지가 있는 것 같습니다.
다양한 유형의 문제들,

193
00:07:08,329 --> 00:07:11,629
우리가 얘기하는 건 어떤 것들인가요?
이번 수업에서 여러분께 드리는 내용입니다.

194
00:07:11,629 --> 00:07:13,790
어쩌면 당신은 봤을지도 몰라요
작업 세트에 포함되어 있습니다.

195
00:07:13,790 --> 00:07:14,689
오른쪽?

196
00:07:14,689 --> 00:07:18,649
저는 그것들을 다음과 같이 분류하는 것을 좋아합니다.
세 가지 다른 범주

197
00:07:18,649 --> 00:07:19,229
.

198
00:07:19,230 --> 00:07:24,379
먼저, 이해하셔야 합니다.
내부

199
00:07:24,379 --> 00:07:26,629
데이터 구조,
우리가 알고 있는 알고리즘.

200
00:07:26,629 --> 00:07:29,810
직접 확인해 보실 수 있을 겁니다.
안쪽은, 음, 잘 모르겠네요.

201
00:07:29,810 --> 00:07:32,899
균형 상태에 노드를 갖는 것
이진 검색 트리 —

202
00:07:32,899 --> 00:07:34,459
AVL 트리 —

203
00:07:34,459 --> 00:07:35,870
어떻게 하면 로테이션을 수행할 수 있나요?

204
00:07:35,870 --> 00:07:36,530
오른쪽?

205
00:07:36,529 --> 00:07:38,659
삽입물을 만드는 방법은 무엇인가요?

206
00:07:38,659 --> 00:07:43,370
또는 뭐 그런 거
이것의 구조는 --

207
00:07:43,370 --> 00:07:46,250
이진 힙--
k 상위는 어디에 있나요?

208
00:07:46,250 --> 00:07:49,699
최대 이진 힙에 있는 것들,
그것은 당신의 임무에 포함되어 있습니다.

209
00:07:49,699 --> 00:07:54,829
이것들은 내게 요구되는 것들입니다
이 검은 상자들이 아닙니다

210
00:07:54,829 --> 00:07:55,430
데이터 구조.

211
00:07:55,430 --> 00:07:56,629
이것은 흰색 상자입니다.

212
00:07:56,629 --> 00:07:57,170
오른쪽?

213
00:07:57,170 --> 00:07:59,939
안에 뭐가 들어있는지 알아야 해요.
이것이 이 질문에 대한 답입니다.

214
00:07:59,939 --> 00:08:00,439
오른쪽?

215
00:08:00,439 --> 00:08:02,240
나는 ~에 대해 알아야 한다
이것의 내부 요소

216
00:08:02,240 --> 00:08:02,740
데이터 구조.

217
00:08:02,740 --> 00:08:03,740
오른쪽?

218
00:08:03,740 --> 00:08:06,463
그리고 다른 유형들도 있습니다.
문제, 여기가 어디지? 아,

219
00:08:06,463 --> 00:08:08,629
난 그걸 알 필요 없어.

220
00:08:08,629 --> 00:08:09,949
이것은 내부 데이터 구조입니다.

221
00:08:09,949 --> 00:08:14,449
저는 그냥 함께 일할 수 있어요
API 지식

222
00:08:14,449 --> 00:08:17,149
그리고 그것을 연결해 보세요
내가 필요로 하는 문제.

223
00:08:17,149 --> 00:08:20,019
제가 그렇게 부르는 겁니다.
환원형 문제입니다.

224
00:08:20,019 --> 00:08:22,879
기본적인 작동 방식은 다음과 같습니다.
우리가 제시한 자료

225
00:08:22,879 --> 00:08:25,279
강의에 참석하고 있나요?

226
00:08:25,279 --> 00:08:28,579
제가 적용하는 방법은 다음과 같습니다.
이 기본 재료 말인가요?

227
00:08:28,579 --> 00:08:31,939
그리고 그보다 더 어렵습니다
이 두 가지 모두,

228
00:08:31,939 --> 00:08:34,788
내가 부를 수 있는 것
수정 유형 -

229
00:08:34,788 --> 00:08:36,080
이름들이 그다지 좋지 않네요.

230
00:08:36,080 --> 00:08:38,100
제가 생각해낸 것은
이건 오늘 아침이에요.

231
00:08:38,100 --> 00:08:40,440
하지만 여기서 그들은 노력하고 있습니다.
이해하다,

232
00:08:40,440 --> 00:08:44,400
당신에게 가능한 것은 무엇입니까?
API가 무엇인지 알아야 합니다.

233
00:08:44,399 --> 00:08:46,514
그리고 당신은 그것을 알아야 합니다
내부에서 일어나는 일은

234
00:08:46,514 --> 00:08:47,639
문제에 답할 기회.

235
00:08:47,639 --> 00:08:51,659
적응 같은 것들
"분할 정복" 알고리즘.

236
00:08:51,659 --> 00:08:56,969
또는 대신에
동적 배열을 사용하여

237
00:08:56,970 --> 00:08:58,950
여유 공간이 있습니다
한쪽 끝에는, 어쩌면 나일지도 몰라

238
00:08:58,950 --> 00:09:01,560
추가 공간을 확보해야 할 것입니다.
중간쯤이나 그런 곳에요.

239
00:09:01,559 --> 00:09:02,059
오른쪽?

240
00:09:02,059 --> 00:09:04,799
나는 적응한다
주요 자료에서 가져온 것이었습니다.

241
00:09:04,799 --> 00:09:05,849
꽤 비슷하네요.

242
00:09:05,850 --> 00:09:07,350
하지만 저는 가지고 있습니다
어떻게든 바꿔야겠어.

243
00:09:07,350 --> 00:09:08,490
인상 폭이 정확한가요?

244
00:09:08,490 --> 00:09:12,570
나는 가져가야 해
제가 볼 수 있는 유사한 AVL 트리

245
00:09:12,570 --> 00:09:15,480
당신에게 드리고, 더하기 위해
노드에 대한 기타 속성,

246
00:09:15,480 --> 00:09:18,870
그리고 당신은 내게 말해야 해요.
어떻게 지원할 수 있을까요?

247
00:09:18,870 --> 00:09:21,879
이것을 어떻게 계산할 수 있을까요?
하위 트리의 속성은 자식 요소로부터 어떻게 결정됩니까?

248
00:09:21,879 --> 00:09:23,500
이해가 되시나요?

249
00:09:23,500 --> 00:09:26,490
그래서 이것은
가장 어려운 것.

250
00:09:26,490 --> 00:09:27,000
오른쪽?

251
00:09:27,000 --> 00:09:29,529
만약 당신이 판단할 수 있다면,
이들 중 어느 것

252
00:09:29,529 --> 00:09:31,750
당신이 겪고 있는 문제
당신은 시험을 고려하고 있습니다.

253
00:09:31,750 --> 00:09:34,049
[알아들을 수 없는 부분] 그들 아래에,
이게 도움이 될지도 몰라요

254
00:09:34,049 --> 00:09:36,929
무엇을 사용해야 할지 이해했습니다.

255
00:09:36,929 --> 00:09:38,859
감소 유형 문제의 경우 -

256
00:09:38,860 --> 00:09:41,310
저는 ~에 대해 이야기하려고 합니다.
이건 1초 안에 일어날 일입니다.

257
00:09:41,309 --> 00:09:43,949
하지만 여러 번
그 문제를 제기하는 것은 유익하다.

258
00:09:43,950 --> 00:09:50,910
문제 또는 인터페이스에 대해,
알고리즘이 아닙니다

259
00:09:50,909 --> 00:09:52,980
또는 데이터 구조.

260
00:09:52,980 --> 00:09:56,070
이것은 무슨 뜻인가요?

261
00:09:56,070 --> 00:10:01,620
내가 그 문제를 해결할 수 있다면,
정렬하기 전에 요약을 말합니다.

262
00:10:01,620 --> 00:10:03,720
제가 장담할 수 있습니다.
이 알고리즘은 정확합니다.

263
00:10:03,720 --> 00:10:05,680
저는 정렬 기능만 사용합니다.
마치 블랙박스처럼.

264
00:10:05,679 --> 00:10:07,559
하지만 이 방법은 효과가 없을 수도 있습니다.

265
00:10:07,559 --> 00:10:11,639
내가 선택한
정렬 알고리즘이 중요합니다

266
00:10:11,639 --> 00:10:12,504
효율성을 위해서.

267
00:10:12,504 --> 00:10:14,129
하지만 정확성을 기하기 위해
상관없어요.

268
00:10:14,129 --> 00:10:15,000
오른쪽?

269
00:10:15,000 --> 00:10:18,419
데이터 구조 문제에 대해
나는 할 수 있다

270
00:10:18,419 --> 00:10:22,409
두 가지를 사용하는 것으로 줄입니다
데이터 구조를 설정하고

271
00:10:22,409 --> 00:10:24,839
시퀀스 데이터 구조 또는
뭐 그런 거죠.

272
00:10:24,840 --> 00:10:30,930
하지만 내가 그렇게 한다면 옳을 것이다
제가 핵심을 몇 가지로 요약해 드리겠습니다.

273
00:10:30,929 --> 00:10:36,299
저는 작업을 식별할 수 있습니다.
이러한 인터페이스 측면에서 말입니다.

274
00:10:36,299 --> 00:10:38,099
저는 그걸 할 필요가 없어요.
이 선택은 내가

275
00:10:38,100 --> 00:10:39,100
근무 시간에 대해 이야기해 봅시다.

276
00:10:39,100 --> 00:10:39,600
오른쪽?

277
00:10:39,600 --> 00:10:40,950
효율성에 대해 이야기하는 건 아닙니다.

278
00:10:40,950 --> 00:10:44,820
그리고 게임의 이름은
퀴즈에서 점수를 얻기 위해-

279
00:10:44,820 --> 00:10:48,390
점수를 드릴 수 없습니다
잘못된 알고리즘 때문에

280
00:10:48,389 --> 00:10:50,340
또는 ~와 같은 것
거의 정확합니다.

281
00:10:50,340 --> 00:10:51,990
오른쪽?

282
00:10:51,990 --> 00:10:53,789
그리고 저희는 제공해 드릴 수 없습니다.
만점을 받았습니다.

283
00:10:53,789 --> 00:10:57,839
만약 올바른 알고리즘이라면,
귀하께서 제공해주시는 정보는 효과적이지 않습니다.

284
00:10:57,840 --> 00:11:00,570
그리고 만약 당신이 그런 것들에 대해 논쟁하지 않는다면,
정확성 측면에서,

285
00:11:00,570 --> 00:11:02,430
근무 시간 등

286
00:11:02,429 --> 00:11:07,259
당신의 알고리즘은 다음과 같을 수 있습니다.
정확하고 효과적인,

287
00:11:07,259 --> 00:11:10,090
하지만 당신은
실행 시간을 잘못 분석했습니다.

288
00:11:10,090 --> 00:11:11,700
그래서 우리는 당신을 축하합니다
그에게 점수를 줘야겠네요.

289
00:11:11,700 --> 00:11:15,450
또는 대부분
당신이 우리에게 제공하는 것

290
00:11:15,450 --> 00:11:17,790
비효율적인 알고리즘.

291
00:11:17,789 --> 00:11:19,500
그런 다음 분석합니다.
근무 시간

292
00:11:19,500 --> 00:11:22,049
마치 그것이 과녁인 것처럼
우리가 알려드린 근무 시간.

293
00:11:22,049 --> 00:11:22,649
오른쪽?

294
00:11:22,649 --> 00:11:24,309
이건 양쪽 모두에게 나쁜 일입니다.

295
00:11:24,309 --> 00:11:24,969
오른쪽?

296
00:11:24,970 --> 00:11:25,470
좋은.

297
00:11:25,470 --> 00:11:27,220
그러니 잡히지 않도록 조심하세요.
이러한 함정에 빠지다.

298
00:11:27,220 --> 00:11:27,720
좋은.

299
00:11:27,720 --> 00:11:30,060
그래서 일반적인 몇 가지
시험에 합격하기 위한 전략

300
00:11:30,059 --> 00:11:31,839
퀴즈를 검토하고 계십니다.

301
00:11:31,840 --> 00:11:35,250
저는 진심으로 강력히 권해드립니다.
시험지 전체를 읽으세요

302
00:11:35,250 --> 00:11:38,759
시작하기 전에, 왜냐하면
몇 가지 작업

303
00:11:38,759 --> 00:11:40,779
~을 위한 것입니다
당신은 다른 사람들보다 더 쉽습니다.

304
00:11:40,779 --> 00:11:44,100
그리고 만약 당신이 시도한다면
점수를 최대화하세요

305
00:11:44,100 --> 00:11:49,050
저도 여러분과 마찬가지로 여기에 있습니다.
당신이 이걸 하려고 노력하고 있다는 걸 확신해요.

306
00:11:49,049 --> 00:11:53,159
처음에는 유용함
문제를 겪어내다

307
00:11:53,159 --> 00:11:55,529
어떤 것들인지 확인하기 위해
당신에게 가장 쉬운 방법으로.

308
00:11:55,529 --> 00:11:58,439
그러면 당신은 도전할 수 있습니다.
그 순서대로,

309
00:11:58,440 --> 00:11:59,790
당신이 확신하는 것.

310
00:11:59,789 --> 00:12:05,370
사실 평균적으로는,
예를 들어, 이번 수업 퀴즈에서처럼,

311
00:12:05,370 --> 00:12:09,179
보통 변동이 심하지만, 저는 그렇지 않아요.
네, 60에서 80 사이일 거예요.

312
00:12:09,179 --> 00:12:11,969
저는 그가 80세였다고 생각하지 않아요.

313
00:12:11,970 --> 00:12:15,210
하지만 100%는 아니에요.

314
00:12:15,210 --> 00:12:21,690
그러니까 50% 완료됐네요.
문제가 발생할 가능성이 높습니다.

315
00:12:21,690 --> 00:12:24,510
당신에게 더 좋을 것입니다
시간 관리 관점에서

316
00:12:24,509 --> 00:12:28,289
그리고 이와 유사한 것들,
모든 걸 다 하는 것보다...

317
00:12:28,289 --> 00:12:30,389
모든 것을 해결하려고 노력하세요
문제점이 아니라

318
00:12:30,389 --> 00:12:33,840
어떤 상황에든 대처하기 위해
그 점들--

319
00:12:33,840 --> 00:12:35,879
당신은 반드시,
컴퓨터 과학,

320
00:12:35,879 --> 00:12:39,689
충분히 가까이 있어야 합니다
정답을 맞추면 점수를 얻습니다.

321
00:12:39,690 --> 00:12:40,410
오른쪽?

322
00:12:40,409 --> 00:12:43,959
사실, 거의 그래야 합니다.
맞아요, 그렇지 않으면 이해하지 못할 거예요.

323
00:12:43,960 --> 00:12:46,590
그들이 어떻게 평가받는지 보셨다면…
당신의 과제 설정 --

324
00:12:46,590 --> 00:12:48,509
때때로
우리의 과제 세트 평가자들

325
00:12:48,509 --> 00:12:50,309
실수하다.

326
00:12:50,309 --> 00:12:56,109
가끔씩 포인트를 얻을 수 있어요
잘못된 결정 때문에.

327
00:12:56,110 --> 00:12:56,610
오른쪽?

328
00:12:56,610 --> 00:12:59,730
당신은 반드시
문제들을 살펴보세요.

329
00:12:59,730 --> 00:13:02,370
당신께서 우리에게 주신 것과 우리의
저희가 제공해 드린 해결책입니다.

330
00:13:02,370 --> 00:13:06,090
우리는 글을 쓰는 데 많은 시간을 보냈습니다.
훌륭한 결정입니다.

331
00:13:06,090 --> 00:13:09,460
반드시 확인해야 할 사항은 다음과 같습니다.
어떤 재질인가요?

332
00:13:09,460 --> 00:13:12,330
우리에게 가까이 오지 마세요.
시험이 끝날 때

333
00:13:12,330 --> 00:13:16,440
그리고 "아, 내가 그렇게 말했었지"라고 하지 마세요.
즉, 문제를 해결하는 것입니다.

334
00:13:16,440 --> 00:13:19,050
이것은 올바르게 표시되었습니다.
너희들이 잘못 표시했잖아.

335
00:13:19,049 --> 00:13:20,370
네, 그렇습니다.

336
00:13:20,370 --> 00:13:21,779
직원들은 알고 있다
조금 더

337
00:13:21,779 --> 00:13:25,049
당신 것보다 알고리즘에 대해 더 자세히 알아보세요.
여러분의 과제를 평가하는 사람들.

338
00:13:25,049 --> 00:13:26,949
그리고 우리는 여러분의 시험지를 채점합니다.

339
00:13:26,950 --> 00:13:29,190
그러므로 유감스럽게도,
이것은 변명이 될 수 없습니다.

340
00:13:29,190 --> 00:13:31,020
당신은 반드시
해당 내용을 숙지하십시오.

341
00:13:31,019 --> 00:13:31,799
예?

342
00:13:31,799 --> 00:13:33,779
청중: 그래서,
대부분의 작업

343
00:13:33,779 --> 00:13:36,179
시험은 여러 가지로 구성됩니다.
부분

344
00:13:36,179 --> 00:13:37,739
우리는 필요하다
잘 이해하기

345
00:13:37,740 --> 00:13:39,552
그리고 실행
처음 몇 부분은

346
00:13:39,552 --> 00:13:41,470
부분적인 것이라도 받다
다른 부분에 대한 크레딧은 어떻게 되나요?

347
00:13:41,470 --> 00:13:42,764
아니면 [알아들을 수 없는 부분] 같은 건가요?

348
00:13:42,764 --> 00:13:43,389
제이슨 쿠: 네.

349
00:13:43,389 --> 00:13:48,399
그래서 질문은 이것입니다.
질문이 무엇인지 여부입니다.

350
00:13:48,399 --> 00:13:53,019
서로 겹쳐 쌓아 올린,
그러면 결국 벽 옆에 서게 되는 거죠.

351
00:13:53,019 --> 00:13:54,669
첫 번째 부분을 놓치셨나요?

352
00:13:54,669 --> 00:13:56,750
우리는 만들지 않으려고 노력합니다
이런 식으로 시험을 봅니다.

353
00:13:56,750 --> 00:13:57,250
좋은.

354
00:13:57,250 --> 00:13:59,769
당신은 할 수 있습니다
실기 시험을 살펴보세요.

355
00:13:59,769 --> 00:14:02,500
이미 출판되었습니다.

356
00:14:02,500 --> 00:14:04,899
일반적으로 우리의 문제는 다음과 같습니다.
스스로에게 갇혀버렸다.

357
00:14:04,899 --> 00:14:07,449
그리고 만약 그것들이 여러 개로 구성되어 있다면
부품들, 그것들

358
00:14:07,450 --> 00:14:10,300
대개 독립적이다.

359
00:14:10,299 --> 00:14:13,419
보통은 그럴 필요가 없습니다.
작업 A를 정확하게 수행하여,

360
00:14:13,419 --> 00:14:14,709
B. 작업을 정확하게 완료하기 위해.

361
00:14:14,710 --> 00:14:16,090
좋은?

362
00:14:16,090 --> 00:14:18,730
그게 전부입니다.
우리의 업무를 설명하려고 합니다.

363
00:14:18,730 --> 00:14:23,163
마지막으로
코딩 질문 및 4개

364
00:14:23,163 --> 00:14:24,580
당신은 그런 문제를 겪었군요.
당신이

365
00:14:24,580 --> 00:14:26,830
이러한 데이터 구조를 개발해야 했습니다.

366
00:14:26,830 --> 00:14:29,410
하지만 C는 사용하라고 말했습니다.
마치 블랙박스 같아요.

367
00:14:29,409 --> 00:14:31,360
그리고
문제를 해결하세요.

368
00:14:31,360 --> 00:14:32,379
오른쪽?

369
00:14:32,379 --> 00:14:34,000
그래서 당신은 정말로
보여줄 필요 없음 –

370
00:14:34,000 --> 00:14:36,970
저희가 이 인터페이스를 제공해 드렸습니다.

371
00:14:36,970 --> 00:14:38,680
간단히 사용하시면 됩니다
이 인터페이스는 다음과 같은 것을 갖도록

372
00:14:38,679 --> 00:14:42,549
C라고 답할 가능성,
알고리즘에 관한 질문들,

373
00:14:42,549 --> 00:14:45,609
결정조차 하지 않고
정확히 말하면 질문은 데이터 구조에 관한 것입니다.

374
00:14:45,610 --> 00:14:47,300
이해가 되시나요?

375
00:14:47,299 --> 00:14:49,179
실제로
알고리즘에 관한 질문

376
00:14:49,179 --> 00:14:52,149
그게 더 쉬웠어요, 저는.
제가 기억하는 한 그렇습니다.

377
00:14:52,149 --> 00:14:52,779
예?

378
00:14:52,779 --> 00:14:54,459
청중: 우리는 반드시
시험에서 코드를 작성해야 하나요?

379
00:14:54,460 --> 00:14:56,460
제이슨 쿠: 당신은 해야 합니다
시험에서 코드를 작성해야 하나요?

380
00:14:59,169 --> 00:15:04,360
저는 그런 시험을 본 적이 없습니다.
코드를 작성해야 했습니다.  안에

381
00:15:04,360 --> 00:15:07,659
저는 시험을 치렀습니다.
코드를 읽어야 합니다.

382
00:15:07,659 --> 00:15:08,169
좋은?

383
00:15:08,169 --> 00:15:11,409
그러니까, 의사 코드든 파이썬이든 상관없다는 거죠.

384
00:15:11,409 --> 00:15:13,329
파이썬은
이 수업의 필수 조건입니다.

385
00:15:13,330 --> 00:15:15,370
아주 당연하게도,
우리가 당신에게 주는 것

386
00:15:15,370 --> 00:15:16,929
작은 조각들
파이썬 코드, 그리고 당신은

387
00:15:16,929 --> 00:15:21,370
할 수 있어야 합니다
무슨 일이 일어나고 있는지 이해하세요.

388
00:15:21,370 --> 00:15:22,870
예?

389
00:15:22,870 --> 00:15:24,639
청중: 당신
표시된 감가상각

390
00:15:24,639 --> 00:15:27,309
수정 중
[없어서는 안될].

391
00:15:27,309 --> 00:15:31,304
이것은 우리가 사용한다는 것을 의미합니까?
감가상각됨 [분해 불가]??

392
00:15:31,304 --> 00:15:31,929
제이슨 쿠: 네.

393
00:15:31,929 --> 00:15:34,329
제가 여기서 말하려는 것은...

394
00:15:34,330 --> 00:15:37,720
물론 감가상각이죠.
여기 또는 여기에 나타납니다.

395
00:15:37,720 --> 00:15:39,460
그런 것들.

396
00:15:39,460 --> 00:15:41,590
종종, 만약 내가
저는 동적 배열을 사용합니다.

397
00:15:41,590 --> 00:15:44,440
만약 제가 바이너리 힙을 사용한다면,
해시 테이블을 사용한다면,

398
00:15:44,440 --> 00:15:47,710
감가상각이 나타납니다
런타임 시점

399
00:15:47,710 --> 00:15:49,090
이러한 동적 작업들.

400
00:15:49,090 --> 00:15:51,040
무슨 뜻일까요?
감가상각 대상 -

401
00:15:51,039 --> 00:15:53,949
제 말은, 제가 당신에게 묻는다면 말이죠,
요약하자면 다음과 같습니다.

402
00:15:53,950 --> 00:15:57,940
예를 들어 우리가 했던 일은 다음과 같습니다.
동적 배열은 대신에

403
00:15:57,940 --> 00:16:00,100
추가
끝에 공백

404
00:16:00,100 --> 00:16:02,019
저는 추가 사항을 하나 더 추가합니다.
가운데 공간

405
00:16:02,019 --> 00:16:04,579
처음에도 또는
뭐 그런 거죠.

406
00:16:04,580 --> 00:16:08,050
그리고 당신은 돈을 써야 합니다
일종의 감가상각 분석.

407
00:16:08,049 --> 00:16:13,939
지금은 종종
이럴 필요는 없습니다...

408
00:16:13,940 --> 00:16:16,900
우리가 ~에 대해 이야기했을 때
문제가

409
00:16:16,899 --> 00:16:19,990
우리는 직접 만들었어요
상각 분석

410
00:16:19,990 --> 00:16:22,149
그리고 2층짜리 건물을 만들었습니다.

411
00:16:22,149 --> 00:16:24,629
제 말은 이중 대기열을 말하는 겁니다.

412
00:16:24,629 --> 00:16:26,830
실제로 가능합니다
줄여서 해결하세요

413
00:16:26,830 --> 00:16:31,090
두 개의 동적 배열이 사용됩니다.

414
00:16:31,090 --> 00:16:32,019
오른쪽?

415
00:16:32,019 --> 00:16:37,539
그래서, 많은 것들이 있습니다.
당신이 사용하는 방식

416
00:16:37,539 --> 00:16:39,279
물건 사용량을 줄일 수 있습니다.

417
00:16:39,279 --> 00:16:41,500
하지만 결국에는 돈을 써야 할 수도 있습니다.
추가 회계

418
00:16:41,500 --> 00:16:42,429
.

419
00:16:42,429 --> 00:16:46,750
하지만 이는 다음을 의미합니다.
게다가...

420
00:16:46,750 --> 00:16:48,399
당신은 사용하지 않습니다
블랙박스 같은 것들.

421
00:16:48,399 --> 00:16:51,649
당신은 무언가를 바꾸고 있습니다
저희가 드린 상자 안에 있습니다.

422
00:16:51,649 --> 00:16:52,149
오른쪽?

423
00:16:52,149 --> 00:16:53,559
그럴듯하네요.

424
00:16:53,559 --> 00:16:54,339
예?

425
00:16:54,340 --> 00:16:56,980
청중: 만약 당신이 우리에게 말한다면
수행하는 알고리즘을 작성하세요

426
00:16:56,980 --> 00:17:00,610
대략 O(log n) 정도
시간이 흐르고, 우리는 오직 생각할 수밖에 없다.

427
00:17:00,610 --> 00:17:03,060
그 알고리즘에 대해
효과가 없는 것, 예를 들면

428
00:17:03,059 --> 00:17:03,967
유한 시간 내에 O(n)입니다.

429
00:17:03,967 --> 00:17:04,509
제이슨 쿠: 알겠습니다.

430
00:17:04,509 --> 00:17:06,470
청중: 그럼 이제…
이 글을 쓰는 목적이 뭐죠?

431
00:17:06,470 --> 00:17:07,095
제이슨 쿠: 물론이죠.

432
00:17:07,095 --> 00:17:11,588
자, 그럼 시작해 볼까요?
잠시 다음으로 넘어가죠.

433
00:17:11,588 --> 00:17:19,429
사실 저는... 저는 그렇게 할 거예요
곧 질문에 답변드리겠습니다.

434
00:17:19,430 --> 00:17:20,328
좋은.

435
00:17:20,328 --> 00:17:22,338
하지만 저는 다음으로 넘어가겠습니다.
그 전에 잠시 후에요.

436
00:17:22,338 --> 00:17:23,750
좋은?

437
00:17:23,750 --> 00:17:26,960
내가 이 질문에 답하지 않으면
5분 안에 주세요.

438
00:17:26,960 --> 00:17:27,618
알다.

439
00:17:27,617 --> 00:17:28,730
좋은?

440
00:17:28,730 --> 00:17:30,500
우선,
내가 다가갈 때

441
00:17:30,500 --> 00:17:33,259
문제점
시험, 저는 시도해 볼 수 있어요

442
00:17:33,259 --> 00:17:35,730
몇 가지 질문을 해보세요
그 문제에 관해서 말씀드리자면,

443
00:17:35,730 --> 00:17:36,230
좋은.

444
00:17:36,230 --> 00:17:38,360
이것이 저에게 도움이 될 것입니다.
무엇을 사용할지 결정하세요.

445
00:17:38,359 --> 00:17:39,259
오른쪽?

446
00:17:39,259 --> 00:17:41,599
그 외에는
당신의 문제들.

447
00:17:41,599 --> 00:17:43,609
당신의 문제는
왜냐하면

448
00:17:43,609 --> 00:17:47,149
우리가 이야기했던 것을 활용하세요
그 주 강의에서요.

449
00:17:47,150 --> 00:17:49,280
퀴즈에서 여러분은 다음과 같은 문제를 풀 수 있습니다.
여덟 강의,

450
00:17:49,279 --> 00:17:51,029
당신이 말씀하셨던 것 말이에요.

451
00:17:51,029 --> 00:17:52,940
그래서 당신에게는 더 어려울 겁니다.

452
00:17:52,940 --> 00:17:56,029
당신이 하지 않기 때문에 하는 것입니다
여덟 강의 중 어느 강의인지 아시나요?

453
00:17:56,029 --> 00:17:57,950
재료는 다음과 같습니다.
이 문제에 적용됩니다.

454
00:17:57,950 --> 00:18:00,019
사실 그럴 수도 있습니다.
그들의 조합.

455
00:18:00,019 --> 00:18:03,259
그래서 저는 주려고 노력합니다.
당신의 방법

456
00:18:03,259 --> 00:18:04,289
이 질문에 빨리 답해주세요.

457
00:18:04,289 --> 00:18:04,789
좋은?

458
00:18:04,789 --> 00:18:07,577
그래서 이것은
기계적 감속

459
00:18:07,577 --> 00:18:08,869
수정 관련 문제인가요?

460
00:18:08,869 --> 00:18:11,432
이것은 도움이 될 뿐입니다.
내가 결정하도록

461
00:18:11,432 --> 00:18:12,349
그것의 복잡성 수준.

462
00:18:12,349 --> 00:18:14,240
어쩌면 당신은 그렇지 않을지도 몰라요
당신은 대답할 수 있습니다.

463
00:18:14,240 --> 00:18:17,000
하지만 이렇게 하면 이해하실 수 있을 겁니다.
이 문제는 무엇인가요?

464
00:18:17,000 --> 00:18:20,839
이것은 다음과 같은 경우에 문제가 됩니다.
데이터 구조는 둘 다 정렬하나요?

465
00:18:20,839 --> 00:18:22,459
오른쪽?

466
00:18:22,460 --> 00:18:24,860
우리가 ~에 대해 이야기하고 있다면
데이터 구조, 또는

467
00:18:24,859 --> 00:18:26,779
저는 도움이 필요해요.
순차 유형 연산

468
00:18:26,779 --> 00:18:30,619
저축해야 하나요?
어떤 것에 관한 외부 질서?

469
00:18:30,619 --> 00:18:34,969
아니면 그건 나에게 중요한 문제일까요?
어떤 물건들 말인가요?

470
00:18:34,970 --> 00:18:37,850
저는 무언가를 찾으려고 노력하고 있어요.
있는 그대로.

471
00:18:37,849 --> 00:18:39,109
아니면 둘 다일까요?

472
00:18:39,109 --> 00:18:40,579
아니면 여러 가지가 복합적으로 작용하는 걸까요?

473
00:18:40,579 --> 00:18:42,919
만약 내가 많이 가지고 있다면
다양한 종류의 키,

474
00:18:42,920 --> 00:18:44,900
내가 필요로 할지도 모르는 것
요청하시면, 제가 도와드리겠습니다.

475
00:18:44,900 --> 00:18:48,080
최소 두 개를 사용해야 할 것입니다.
정립된 데이터 구조 유형.

476
00:18:48,079 --> 00:18:48,587
오른쪽?

477
00:18:48,587 --> 00:18:50,629
당신은 아주 할 수 있습니다
이런 것들을 복잡하게 생각하지 마세요.

478
00:18:50,630 --> 00:18:52,790
하지만 우리가 그것에 대해 이야기한다면
좋아요, 그럼 제가 할게요.

479
00:18:52,789 --> 00:18:59,149
해야 할 일입니다
이러한 이름들에 대한 그러한 작업.

480
00:18:59,150 --> 00:19:01,550
그러면 '아, 나한테 필요한 게 있구나'라고 생각할지도 몰라요.
데이터 구조들의 집합.  나중에

481
00:19:01,549 --> 00:19:03,529
어떻게 할지 생각해 보겠습니다.
이를 실행하기 위해.  또는

482
00:19:03,529 --> 00:19:04,490
해시 테이블을 사용하는 것이 가치가 있을까요?

483
00:19:04,490 --> 00:19:05,656
정렬된 배열을 사용해야 할까요?

484
00:19:05,656 --> 00:19:07,549
AVL 트리를 사용해야 할까요?

485
00:19:07,549 --> 00:19:11,779
하지만 먼저 생각해 봅시다
추상적인 차원에서, 제게는

486
00:19:11,779 --> 00:19:15,200
일련의 데이터 구조가 필요합니다.
나눌 수 있습니다

487
00:19:15,200 --> 00:19:17,150
정확성을 통한 효율성.

488
00:19:17,150 --> 00:19:18,530
이해가 되시나요?

489
00:19:18,529 --> 00:19:19,609
좋은.

490
00:19:19,609 --> 00:19:23,479
막히셨다면, 다음을 참고하세요.
당신의 질문입니다.

491
00:19:23,480 --> 00:19:27,589
막히셨다면,
올바른 알고리즘을 적으세요.

492
00:19:27,589 --> 00:19:29,539
효과가 없습니다.

493
00:19:29,539 --> 00:19:32,000
다음과 같은 경우 포인트를 드릴 수 있습니다.
옳은

494
00:19:32,000 --> 00:19:32,599
비효율적인 알고리즘.

495
00:19:32,599 --> 00:19:34,049
적어도 이것만큼은
올바른 알고리즘입니다.

496
00:19:34,049 --> 00:19:35,509
이것은 다른 것들보다 낫다.

497
00:19:35,509 --> 00:19:36,470
오른쪽?

498
00:19:36,470 --> 00:19:41,150
자, 만약 이것이
지수적 시간, 당신

499
00:19:41,150 --> 00:19:44,570
10%로 제한될 수 있습니다.
또는 점수의 20%.

500
00:19:44,569 --> 00:19:47,299
하지만 만약 그것이 로그 인자라면-

501
00:19:47,299 --> 00:19:50,359
더 나쁘거나, 선형 요인이 더 나쁩니다.

502
00:19:50,359 --> 00:19:52,069
어쩌면 그게 정상일지도 몰라.

503
00:19:52,069 --> 00:19:56,269
데이터 구조 문제에 관해서 말씀드리자면,
어떤 연산이 n번째 순서로 수행된다면

504
00:19:56,269 --> 00:19:59,404
때로는 그렇지 않을 수도 있습니다.
많은 점수를 얻게 될 거예요.

505
00:19:59,404 --> 00:20:01,279
왜냐하면 핵심은 바로 그것이기 때문입니다
데이터 구조란 바로 이것입니다.

506
00:20:01,279 --> 00:20:04,519
이것들을 만들기 위해
신속하게 작업을 진행합니다.

507
00:20:04,519 --> 00:20:08,569
하지만 만약 그것이 문제를 해결한다면,
점수를 얻게 될 겁니다.

508
00:20:08,569 --> 00:20:10,189
0점을 받지는 않을 겁니다.

509
00:20:10,190 --> 00:20:11,000
예?

510
00:20:11,000 --> 00:20:12,458
청중: 입니다
우리는 질문을 받을 것입니다.

511
00:20:12,458 --> 00:20:14,250
예를 들어, 얼마나 빠른지
이거 할 수 있어요?

512
00:20:14,250 --> 00:20:15,349
가능한 한 빨리 이 일을 하십시오.

513
00:20:15,349 --> 00:20:15,974
제이슨 쿠: 네.

514
00:20:15,974 --> 00:20:19,589
그래서 우리는 흔히 이렇게 말합니다.
효율적인 알고리즘을 제시해 주세요.

515
00:20:19,589 --> 00:20:20,089
좋은.

516
00:20:20,089 --> 00:20:22,819
음, 뭐라고 해야 할지 모르겠네요.
효과가 있나요, 없나요?

517
00:20:22,819 --> 00:20:25,169
음, 그건 그냥 그런 뜻이에요.
더 빠른 가동 시간

518
00:20:25,170 --> 00:20:26,539
더 많은 점수를 얻게 해 줄 것입니다.

519
00:20:26,539 --> 00:20:27,109
좋은?

520
00:20:27,109 --> 00:20:31,579
그러므로 그러한 문제에 있어서는
주로

521
00:20:31,579 --> 00:20:34,369
이 게임을 해보려고 노력 중이에요.

522
00:20:34,369 --> 00:20:37,849
일반적으로 우리는 효과적인 방법을 소개합니다.
이 게임은 특정 관점에서 진행되는 게임이 아닙니다.

523
00:20:37,849 --> 00:20:40,849
데이터 구조는 일반적으로 다음과 같은 이유로 사용됩니다.
데이터 구조 문제 --

524
00:20:40,849 --> 00:20:44,269
~에
구현 방식이 중요합니다.

525
00:20:44,269 --> 00:20:47,180
이 데이터가 구조화되도록
작업이 신속하게 진행되어야 합니다.

526
00:20:47,180 --> 00:20:50,090
그리고 우리는 말하고 싶습니다
얼마나 빠른지 아세요?

527
00:20:50,089 --> 00:20:50,629
오른쪽?

528
00:20:50,630 --> 00:20:57,200
따라서 일반적으로 데이터 구조 문제는 다음과 같습니다.

529
00:20:57,200 --> 00:20:59,960
대개 타협이 이루어집니다.
실행 시간 사이

530
00:20:59,960 --> 00:21:01,430
이러한 다양한 작전들.

531
00:21:01,430 --> 00:21:04,170
그리고 그것이 어떻게 되는지는 매우 중요합니다.
그것들은 서로 관련이 있습니다.

532
00:21:04,170 --> 00:21:05,750
그래서,
데이터 구조 관련 문제점

533
00:21:05,750 --> 00:21:08,789
얻는 것에 관한 것입니다
근무 시간.

534
00:21:08,789 --> 00:21:09,289
좋은?

535
00:21:09,289 --> 00:21:13,309
알고리즘의 문제점을 고려할 때,
우리가 당신에게 한 가지를 부탁하는 경우,

536
00:21:13,309 --> 00:21:15,589
그리고 우리는 이것을 하려고 노력하고 있습니다.
가능한 한 빨리,

537
00:21:15,589 --> 00:21:16,609
선형적인 시간을 얻으려고 노력하세요.

538
00:21:16,609 --> 00:21:17,109
오른쪽?  안에

539
00:21:17,109 --> 00:21:20,569
대부분의 경우 불가능합니다
선형 시간보다 더 나은 결과를 달성합니다.

540
00:21:20,569 --> 00:21:23,659
읽어야 한다면
모든 입력값은 어느 시점에서든 사용됩니다.

541
00:21:23,660 --> 00:21:26,180
내가 찾고 싶다면
데이터 속의 것들.

542
00:21:26,180 --> 00:21:28,880
만약 하나도 생각나지 않는다면
선형 시간 알고리즘,

543
00:21:28,880 --> 00:21:31,940
n 제곱을 생각해 보세요
또는 n log n.

544
00:21:31,940 --> 00:21:32,750
오른쪽?

545
00:21:32,750 --> 00:21:36,950
아마도,
지금으로서는 여러분이 생각하기에 조금 어려울 수도 있겠네요.

546
00:21:36,950 --> 00:21:40,987
하지만 그래서 제가 시작하라고 하는 겁니다.
어떤 올바른 알고리즘에서든,

547
00:21:40,987 --> 00:21:42,320
그러면 최적화할 수 있을지도 모릅니다.

548
00:21:42,319 --> 00:21:44,000
어쩌면 당신이 사용할 수 있을지도 모릅니다
더 나은 데이터 구조,

549
00:21:44,000 --> 00:21:45,083
더욱 효과적으로 만들기 위해서입니다.

550
00:21:45,083 --> 00:21:46,920
이해가 되시나요?

551
00:21:46,920 --> 00:21:48,900
더 궁금한 점 있으신가요?

552
00:21:48,900 --> 00:21:50,150
좋은.

553
00:21:50,150 --> 00:21:52,259
오른쪽으로 이동합니다.

554
00:21:52,259 --> 00:21:52,759
좋은.

555
00:21:52,759 --> 00:21:55,490
단점은 다음과 같습니다.

556
00:21:55,490 --> 00:21:56,269
좋은.

557
00:21:56,269 --> 00:22:00,410
만약 당신이 하나를 한다면
이 세 가지 중,

558
00:22:00,410 --> 00:22:01,257
한 발짝 물러서세요.

559
00:22:01,257 --> 00:22:02,840
아마 그럴 겁니다.
뭔가 잘못됐어요.

560
00:22:02,839 --> 00:22:04,069
좋은?

561
00:22:04,069 --> 00:22:08,059
그러니 스스로에게 물어보세요.
소수점을 계산하려고 하시는 건가요?

562
00:22:08,059 --> 00:22:10,429
유리수 또는 실수.

563
00:22:10,430 --> 00:22:11,900
저장할 수 없어요.
이것들은...

564
00:22:11,900 --> 00:22:15,060
제 말은, 저는 소수점을 저장할 수 있다는 뜻입니다.
유한한 정밀도로.

565
00:22:15,059 --> 00:22:16,710
하지만 사용하신다면
최고의 정확성,

566
00:22:16,710 --> 00:22:21,255
또한 여러분의 것을 여러 배로 늘릴 수도 있습니다.
이 고정 정밀도로 숫자를

567
00:22:21,255 --> 00:22:22,380
정수를 다룹니다.

568
00:22:22,380 --> 00:22:23,340
오른쪽?

569
00:22:23,339 --> 00:22:24,809
우리는 가르쳤을 뿐이야
일하는 방법을 알려주세요

570
00:22:24,809 --> 00:22:25,980
이 클래스에는 정수가 포함됩니다.

571
00:22:25,980 --> 00:22:26,490
오른쪽?

572
00:22:26,490 --> 00:22:30,180
우린 당신에게 보여주지도 않았어요.
효율적으로 계산하는 방법

573
00:22:30,180 --> 00:22:32,440
유리수와 실수.

574
00:22:32,440 --> 00:22:36,059
우리는 당신에게 만약 당신이 가지고 있다면 그렇게 말했잖아요
분모와 분자

575
00:22:36,059 --> 00:22:39,149
분수, 나는 할 수 있다
두 분수를 취하세요

576
00:22:39,150 --> 00:22:41,430
그리고 그것들을 비교해 보세요
일정한 시간 동안,

577
00:22:41,430 --> 00:22:43,140
교차 곱셈을 수행함으로써.

578
00:22:43,140 --> 00:22:49,770
하지만 내가 정말 노력한다면
임의의 값으로 이 나눗셈을 수행하십시오.

579
00:22:49,769 --> 00:22:54,549
정확도가 아닙니다.
저한테는 잘 어울려요. 왜냐하면 전 아무것도 할 수 없거든요.

580
00:22:54,549 --> 00:22:56,549
직접 발표하세요
유한한 수량의 컴퓨터

581
00:22:56,549 --> 00:22:59,849
소수점
이러한 것들 중 일부입니다.

582
00:23:02,670 --> 00:23:05,350
만약 당신이 사용하려고 한다면
각 답변에 대해 기수 정렬,

583
00:23:05,349 --> 00:23:07,619
이건 아마 틀렸을 겁니다.

584
00:23:07,619 --> 00:23:11,699
우리가 가진 것 중 하나는
저희는 테스트에서 다음과 같은 작업을 시도합니다.

585
00:23:11,700 --> 00:23:15,210
우리는 당신에게 단순히 주는 것만이 아닙니다.
여러 가지 무작위 작업들.

586
00:23:15,210 --> 00:23:17,009
우리는 아마도
우리는 다음과 같은 작업을 생성합니다.

587
00:23:17,009 --> 00:23:19,740
어떤 식으로든 그 자료를 가리세요.

588
00:23:19,740 --> 00:23:22,349
우리는 당신을 확인하고 싶습니다.
모든 면에서.

589
00:23:22,349 --> 00:23:26,669
그래서 만약 당신이 그것을 발견한다면
당신은 같은 것을 사용합니다

590
00:23:26,670 --> 00:23:29,640
네다섯 번
시험에서, 이것은

591
00:23:29,640 --> 00:23:33,300
당신이 ~라는 신호일 수도 있습니다
이 표현을 너무 자주 사용하고 있어요.

592
00:23:33,299 --> 00:23:34,341
하지만 항상 그런 것은 아닙니다.

593
00:23:34,342 --> 00:23:34,842
오른쪽?

594
00:23:34,842 --> 00:23:36,360
때때로 해싱
매우 유용합니다.

595
00:23:36,359 --> 00:23:38,139
그러니까 사용하고 싶으신 건가요?
그를 끊임없이.

596
00:23:38,140 --> 00:23:41,940
하지만 특히,
모두가 노력하고 있어요

597
00:23:41,940 --> 00:23:45,090
기수 정렬을 사용할 때
이는 부적절합니다.

598
00:23:45,089 --> 00:23:48,299
그리고 그들은 사랑합니다. 왜냐하면
그는 선형적인 시간을 이해합니다.

599
00:23:48,299 --> 00:23:49,139
오른쪽?

600
00:23:49,140 --> 00:23:55,080
하지만 병합 정렬을 작성하면 다음과 같습니다.
기수 정렬이 적용될 수 있는 것

601
00:23:55,079 --> 00:23:57,839
그러면 점수를 얻게 될 것입니다.
그것은 맞지만, 그렇지 않기 때문입니다.

602
00:23:57,839 --> 00:24:01,079
효과적으로.

603
00:24:01,079 --> 00:24:03,369
그리고 그것은 효과가 없습니다.
로그 인자에 의해.

604
00:24:03,369 --> 00:24:04,529
오른쪽?

605
00:24:04,529 --> 00:24:08,789
사용하려고 하면
상황에 따른 기수 정렬,

606
00:24:08,789 --> 00:24:11,339
비교가 있을 때
답변, 그리고 당신은 가지고 있지 않습니다

607
00:24:11,339 --> 00:24:13,769
정수에 대한 제한 사항,
만약 내가 가지고 있지 않다면

608
00:24:13,769 --> 00:24:15,329
크기 제한
정수,

609
00:24:15,329 --> 00:24:19,379
그러면 시간이 걸릴 수 있습니다.
엄청나게 많은 시간.

610
00:24:19,380 --> 00:24:21,870
그래서 저는 할 수 있어요
절대 생각조차 하지 마세요

611
00:24:21,869 --> 00:24:26,094
그것은 맞기 때문입니다.
지수적 시간일 수도 있습니다.

612
00:24:26,095 --> 00:24:26,970
글쎄요, 저도 잘 모르겠어요.

613
00:24:26,970 --> 00:24:28,511
얼마나 될지는 모르겠어요
내 단어의 큰 크기.

614
00:24:28,511 --> 00:24:30,849
이는 여러 가지 나쁜 결과를 초래할 수 있습니다.

615
00:24:30,849 --> 00:24:32,339
좋은.

616
00:24:32,339 --> 00:24:34,169
그리고 만약 당신이
보충하려고 노력 중

617
00:24:34,170 --> 00:24:37,470
이진 트리 같은 거,
이는 하위 트리의 속성이 아닙니다.

618
00:24:37,470 --> 00:24:40,350
불가능한 것
덧셈으로부터 계산하세요

619
00:24:40,349 --> 00:24:41,730
그것의 두 하위 요소,

620
00:24:41,730 --> 00:24:43,049
당신은 나쁜 짓을 하고 있어요.  ~에

621
00:24:43,049 --> 00:24:48,240
모든 시험
학생의 30%

622
00:24:48,240 --> 00:24:58,410
그들은 "내 지수만큼 증가한다"라고 말합니다.
전체 나무 보기" 또는 "부분 확대"

623
00:24:58,410 --> 00:25:00,150
흥미로운 점이 하나 있는데요.

624
00:25:00,150 --> 00:25:03,195
크기 증가
내 왼쪽 하위 트리 - 에

625
00:25:07,089 --> 00:25:09,609
노드 수
내 왼쪽 서브트리에 있습니다.

626
00:25:09,609 --> 00:25:10,389
어떻게 하면 될까요...?

627
00:25:14,009 --> 00:25:17,920
제가 어떻게 도울 수 있을지 잘 모르겠습니다.
이는 회전을 통해 이루어지므로

628
00:25:17,920 --> 00:25:20,420
뭐 그런 거죠.

629
00:25:20,420 --> 00:25:21,700
한번 살펴볼까요?

630
00:25:21,700 --> 00:25:24,910
그래서 내가 할 수 있도록
증가 추세를 추적하세요

631
00:25:24,910 --> 00:25:30,430
내 왼쪽 나무에서
내 왼쪽 나무의 증가,

632
00:25:30,430 --> 00:25:33,310
저는 로그 테스트를 통과해야 합니다.
길 전체를 따라 걷는 것,

633
00:25:33,309 --> 00:25:35,259
얼마나 많은지 결정하기 위해
그것은 거기에 있었다.

634
00:25:35,259 --> 00:25:37,539
그러므로 이는 지지할 수 없습니다.
일정한 시간으로.

635
00:25:37,539 --> 00:25:39,909
확장하고 싶다면
왼쪽 하위 트리에 있는 무언가,

636
00:25:39,910 --> 00:25:42,910
그냥 추가하세요
그 자체를 보세요.

637
00:25:42,910 --> 00:25:45,250
왼쪽 하위 트리에서 그리고
확장된 부분을 보세요.

638
00:25:45,250 --> 00:25:46,720
이해가 되시나요?

639
00:25:46,720 --> 00:25:47,251
예?

640
00:25:47,251 --> 00:25:49,460
청중: 만약 당신이, 예를 들어,
서브트리를 추가하여 보완했습니다.

641
00:25:49,460 --> 00:25:52,029
그리고 나서 다시 추가했습니다.
[필수적인] 하위 트리, 그리고 나서

642
00:25:52,029 --> 00:25:52,240
이걸 사용했어요...

643
00:25:52,240 --> 00:25:53,240
제이슨 쿠: 그렇게 할 수도 있죠.

644
00:25:53,240 --> 00:25:53,920
청중:
--여전히 그렇게 여겨지고 있습니다...

645
00:25:53,920 --> 00:25:54,670
제이슨 쿠: 넌 할 수 있어.

646
00:25:54,670 --> 00:25:55,009
예

647
00:25:55,009 --> 00:25:56,551
그래서 당신은 이것을 할 수 있습니다.
일정한 시간 동안,

648
00:25:56,551 --> 00:25:58,750
서브트리의 크기를 늘림으로써.

649
00:25:58,750 --> 00:25:59,470
오른쪽?

650
00:25:59,470 --> 00:26:01,360
관객: 그럼 하나 더 해주세요
[식별 불가능]에서의 확장.

651
00:26:01,359 --> 00:26:03,942
제이슨 쿠: 하나 더 드셔도 됩니다.
확장, 왜냐하면 그러면 당신은

652
00:26:03,942 --> 00:26:06,579
그냥 보기만 할 수도 있지만…
왼쪽 서브트리를 살펴보세요.

653
00:26:06,579 --> 00:26:07,349
제발.

654
00:26:07,349 --> 00:26:08,472
예

655
00:26:08,472 --> 00:26:09,639
그걸 다시 보관할 이유가 없어요.

656
00:26:09,640 --> 00:26:10,140
오른쪽?

657
00:26:10,140 --> 00:26:12,070
일정한 시간 동안 한 번만 하면 됩니다.

658
00:26:12,069 --> 00:26:13,569
왼쪽을 보세요.

659
00:26:13,569 --> 00:26:14,409
좋은.

660
00:26:14,410 --> 00:26:15,830
이러지 마세요.

661
00:26:15,829 --> 00:26:16,449
좋은.

662
00:26:16,450 --> 00:26:19,309
음... 멋지네요.

663
00:26:19,309 --> 00:26:20,740
저도 그렇게 뒤처지지는 않아요.

664
00:26:20,740 --> 00:26:25,539
제가 드리는 팁은 다음과 같습니다.
문제 해결.

665
00:26:25,539 --> 00:26:26,829
아, 페이지가 하나 더 있네요.

666
00:26:26,829 --> 00:26:27,329
예?

667
00:26:27,329 --> 00:26:29,269
청중: 그럼 언제
증가량을 계산하세요.

668
00:26:29,269 --> 00:26:32,470
[필수] 공식을 따르세요.
그것이 [필수적]이라고 주장합니다.

669
00:26:32,470 --> 00:26:33,220
제이슨 쿠: 맞습니다.

670
00:26:33,220 --> 00:26:33,720
오른쪽.

671
00:26:33,720 --> 00:26:41,319
그러니까 요점은, 만약 당신이 제공한다면
확장 기능이 아닌...

672
00:26:41,319 --> 00:26:43,210
우리는 이야기할 거예요
우리의 일반적인 것들에 관해서 말하자면,

673
00:26:43,210 --> 00:26:45,460
순식간에 자를 수 있어요.

674
00:26:45,460 --> 00:26:49,390
만약 당신이 "나는"이라고 말한다면
세트로 주세요.

675
00:26:49,390 --> 00:26:52,990
AVL 트리 또는 순차적 AVL 트리.

676
00:26:52,990 --> 00:26:55,130
예를 들어,
강의가 끝날 때

677
00:26:55,130 --> 00:26:59,530
우리는 어떻게에 대해 이야기했어요
순차적인 AVL 트리를 수정할 수 있습니다.

678
00:26:59,529 --> 00:27:02,259
~을 위한
우선순위 지원

679
00:27:02,259 --> 00:27:05,650
동일한 작업에 대한 큐 작업
실행 시간뿐만 아니라 바이너리 힙도 마찬가지입니다.

680
00:27:05,650 --> 00:27:06,190
오른쪽?

681
00:27:06,190 --> 00:27:10,150
그리고 그게 바로 우리가 원했던 것입니다.
우리는 서브트리의 최댓값을 저장합니다.

682
00:27:10,150 --> 00:27:12,490
내 서브트리에서 가장 큰 항목입니다.

683
00:27:12,490 --> 00:27:14,799
오른쪽?

684
00:27:14,799 --> 00:27:16,659
자, 이것이 바로
또 다른 확장 기능,

685
00:27:16,660 --> 00:27:20,960
이미 추가된 것보다
AVL 서열 트리에서.

686
00:27:20,960 --> 00:27:25,400
확장 기능이란 무엇인가요?
AVL 시퀀스 트리에서요?

687
00:27:25,400 --> 00:27:26,320
대상 고객: 규모.

688
00:27:26,319 --> 00:27:27,443
제이슨 쿠: 크기.

689
00:27:27,443 --> 00:27:29,038
청중: 카운트.

690
00:27:29,038 --> 00:27:31,329
제이슨 쿠: 그러니까, 양이란 무엇인가?
노드 수와 동일

691
00:27:31,329 --> 00:27:32,079
내 하위 트리에 있습니다.

692
00:27:32,079 --> 00:27:32,589
그리고?

693
00:27:32,589 --> 00:27:33,099
대상: 키.

694
00:27:33,099 --> 00:27:33,807
제이슨 쿠: 키.

695
00:27:33,807 --> 00:27:35,410
맞습니다. AVL 트리이기 때문입니다.

696
00:27:35,410 --> 00:27:36,730
오른쪽?

697
00:27:36,730 --> 00:27:40,690
그래서 만약 제가 증가시킨다면
하위 트리의 최대값에 대해,

698
00:27:40,690 --> 00:27:43,210
이건 내 일부가 아니야
표준 인터페이스.

699
00:27:43,210 --> 00:27:44,595
그러니까 당신은 내게 이것을 말해줘야 해요.

700
00:27:44,595 --> 00:27:45,970
우리가 그렇다는 사실에도 불구하고
전에 해본 적이 있어요.

701
00:27:45,970 --> 00:27:47,710
이건 당신에게 아주 쉬운 일일 겁니다.

702
00:27:47,710 --> 00:27:49,930
그냥 내가
최대치를 늘리고 있어요.

703
00:27:49,930 --> 00:27:53,259
최대값을 계산할 수 있습니다.
가능한 한 우리 사이에

704
00:27:53,259 --> 00:27:55,299
그리고 내 왼쪽과 오른쪽
하위 트리(존재하는 경우).

705
00:27:55,299 --> 00:27:55,839
완료.

706
00:27:55,839 --> 00:27:56,619
오른쪽?

707
00:27:56,619 --> 00:27:58,269
그냥 해보세요.

708
00:27:58,269 --> 00:27:59,559
내게 말해줘야 해,

709
00:27:59,559 --> 00:28:01,269
그리고 이것은 다음을 필요로 합니다
일정한 시간이므로, 그것은

710
00:28:01,269 --> 00:28:05,450
일정한 상태로 유지될 수 있다
제가 볼일을 보는 동안요.

711
00:28:05,450 --> 00:28:07,840
이해가 되시나요?

712
00:28:07,839 --> 00:28:08,559
좋은.

713
00:28:08,559 --> 00:28:11,470
그리고 마지막으로,
특히 저는 그렇게 생각합니다

714
00:28:11,470 --> 00:28:14,380
~의
데이터 구조 문제, I

715
00:28:14,380 --> 00:28:17,380
제가 제안드리고 싶은 것은...
이러한 문제에 접근하기 위해서는,

716
00:28:17,380 --> 00:28:23,000
먼저 이러한 문제들을 해결하는 것
인터페이스 측면에서

717
00:28:23,000 --> 00:28:24,250
.

718
00:28:24,250 --> 00:28:27,369
그러면 적어도 당신은
뭔가를 제대로 해내세요.

719
00:28:27,369 --> 00:28:31,209
그런 다음 선택하세요
알고리즘 또는 데이터 구조,

720
00:28:31,210 --> 00:28:35,140
구현하는 데 사용하는 것
이러한 인터페이스들.

721
00:28:35,140 --> 00:28:37,280
하나가 당신을 인도할 것입니다
올바른 알고리즘입니다.

722
00:28:37,279 --> 00:28:39,069
또 다른 이유는 효율성을 위해서입니다.

723
00:28:39,069 --> 00:28:42,069
그것들을 분리하면 도움이 될 수 있습니다.
당신이 문제 해결에 도움을 줄 수 있습니다.

724
00:28:42,069 --> 00:28:45,289
도움이 되지 않으면 하지 마세요.

725
00:28:45,289 --> 00:28:48,309
원하신다면, 제가 매번
기존 데이터 구조가 보입니다.

726
00:28:48,309 --> 00:28:53,710
저는 아마 해시를 사용할 것 같습니다.
테이블이요, 아마 괜찮을 거예요.

727
00:28:53,710 --> 00:28:55,900
하지만 우리가 찾고 있는 것이 있다면
최악의 경우 예상 소요 기간

728
00:28:55,900 --> 00:28:57,300
이건 아마 재미없을 거예요.

729
00:28:57,299 --> 00:28:58,990
그래서 당신은 그냥...

730
00:29:02,089 --> 00:29:07,299
공유하시는 걸 추천드려요.
이러한 것들, 그래서 첫째로

731
00:29:07,299 --> 00:29:08,980
문제 해결에 집중
문제점,

732
00:29:08,980 --> 00:29:10,240
그런 다음 최적화합니다.

733
00:29:10,240 --> 00:29:10,960
예?

734
00:29:10,960 --> 00:29:12,509
청중: 질문 하나만 드릴게요.
~의

735
00:29:12,509 --> 00:29:13,029
최악의 경우 예상 소요 기간입니다.

736
00:29:13,029 --> 00:29:13,750
제이슨 쿠: 음음음.

737
00:29:13,750 --> 00:29:15,140
청중: 그럼, 해시 테이블에 대해서 말씀해 주시겠어요?

738
00:29:15,140 --> 00:29:15,580
제이슨 쿠: 음음음.

739
00:29:15,579 --> 00:29:16,704
청중: 이것을 고려할 때
예상 코드.

740
00:29:16,704 --> 00:29:17,919
제이슨 쿠: 음음음.

741
00:29:17,920 --> 00:29:20,227
청중: 이것은 또한 다음을 의미합니다.
최악의 경우 이는 n의 O입니다.

742
00:29:20,227 --> 00:29:21,310
그러니까 기술적으로는 가능하죠.

743
00:29:21,309 --> 00:29:22,643
제이슨 쿠: 그렇다고 해서 꼭 그렇다는 건 아니잖아요.

744
00:29:22,643 --> 00:29:24,160
그게 다예요.

745
00:29:24,160 --> 00:29:26,769
그러니까, 당신은 그렇게 할 수도 있었다는 거죠.
데이터 구조,

746
00:29:26,769 --> 00:29:30,129
예상 소요 시간이 일정한 경우,
하지만 이는 최악의 경우에 발생하는 한계입니다.

747
00:29:30,130 --> 00:29:31,400
n log n입니다.

748
00:29:31,400 --> 00:29:34,720
딱 하나뿐이에요.
해시 테이블의 경우

749
00:29:34,720 --> 00:29:37,990
이것들이 최악이야
연산은 선형적으로 진행됩니다.

750
00:29:37,990 --> 00:29:41,740
하지만 만약 내가… 만약 우리가…
질문은 미리 여기에 남겨주세요.

751
00:29:41,740 --> 00:29:45,190
만약 제가 일할 시간이 있다면,
내가 뭔가를 했다는 것

752
00:29:45,190 --> 00:29:51,039
상수에 대한 해시 테이블
예상 시간을 검색해 봤습니다.

753
00:29:51,039 --> 00:29:56,019
그리고 나서 저는 AVL 트리를 요청했습니다.
이전 노드의 경우

754
00:29:56,019 --> 00:29:58,029
또는 뭐 그런 것
비슷했고, 저도 그랬어요.

755
00:29:58,029 --> 00:30:03,849
이는 O log n 시간 내에 발생합니다.
최악의 경우 운영 시간은 얼마입니까?

756
00:30:03,849 --> 00:30:04,419
?

757
00:30:04,420 --> 00:30:05,320
관객: 오.

758
00:30:05,319 --> 00:30:07,089
제이슨 쿠: 아, 선생님.

759
00:30:07,089 --> 00:30:09,976
무엇이 기대되는가?
이 제품의 작동 시간은 얼마나 되나요?

760
00:30:09,977 --> 00:30:11,440
대상 독자: 잡지 n.

761
00:30:11,440 --> 00:30:12,610
제이슨 쿠: 매거진 n.

762
00:30:12,609 --> 00:30:14,049
예상 저널 번호

763
00:30:14,049 --> 00:30:15,919
가능하기 때문입니다.
만약 상황이 더 나빠진다면?

764
00:30:15,920 --> 00:30:16,711
더 높을 수도 있습니다.

765
00:30:16,711 --> 00:30:18,809
이해가 되시나요?

766
00:30:18,809 --> 00:30:19,309
좋은.

767
00:30:23,960 --> 00:30:25,370
--정말 맛있어요.

768
00:30:25,369 --> 00:30:29,029
두 번째 항목은 간단합니다.
데이터 구조 설정 문제

769
00:30:29,029 --> 00:30:29,680
.

770
00:30:29,680 --> 00:30:31,174
여러 가지 변수가 많습니다.  이번 세션이 끝날 때

771
00:30:31,174 --> 00:30:33,049
우리가 해결하겠습니다
두 가지 데이터 구조에 문제가 있습니다.

772
00:30:33,049 --> 00:30:35,809
.

773
00:30:35,809 --> 00:30:41,119
모두 설명하세요
사용하는 데이터 구조,

774
00:30:41,119 --> 00:30:42,619
그들이 저장하는 내용까지 포함해서 말입니다.

775
00:30:42,619 --> 00:30:44,509
저장하시면
특정 데이터 구조,

776
00:30:44,509 --> 00:30:47,150
거기에 뭐가 붙어 있는지 말해줘.
당신은 계속

777
00:30:47,150 --> 00:30:49,340
.

778
00:30:49,339 --> 00:30:51,169
보통은 그렇습니다
우리가 간직하는 것,

779
00:30:51,170 --> 00:30:53,450
많은 것을 포함하고 있습니다
정보, 그리고 만약 당신이 그냥

780
00:30:53,450 --> 00:30:57,920
당신은 내가 모든 것을 간직하고 있다고 말하죠.
내 피자 토핑

781
00:30:57,920 --> 00:31:01,323
데이터 세트에서,
그게 당신이 내게 말해줄 수 있는 전부인가요?

782
00:31:01,323 --> 00:31:02,990
나는 무엇을 해야 할지 모르겠어
이 문제에 대해 어떻게 생각하세요?

783
00:31:02,990 --> 00:31:04,940
어떤 건지 모르겠어요
당신의 의미론

784
00:31:04,940 --> 00:31:05,523
데이터 구조.

785
00:31:05,522 --> 00:31:06,829
어디에 부착되어 있나요?

786
00:31:06,829 --> 00:31:09,259
솔직히 말씀드리자면,
오, 시작됐네요.

787
00:31:09,259 --> 00:31:14,140
저는 "y"라는 글자를 몰라요.
뭐 그런 거죠.

788
00:31:14,140 --> 00:31:14,930
좋은.

789
00:31:14,930 --> 00:31:16,140
그리고 불변량이 존재합니다.

790
00:31:16,140 --> 00:31:18,920
이것들을 어떻게 설정하나요?
데이터 구조 관련 문제점, 예를 들어

791
00:31:18,920 --> 00:31:22,880
저는 보통 다음과 같은 상황에서 문제를 해결합니다.
저는 해결책을 작성합니다.

792
00:31:22,880 --> 00:31:28,250
나는 무엇의 상태를 확립한다
이 데이터 구조일 수도 있습니다.

793
00:31:28,250 --> 00:31:29,599
어떤 경우에는 그렇습니다.

794
00:31:29,599 --> 00:31:31,879
저는 이렇게 말하겠습니다.
이 데이터 구조

795
00:31:31,880 --> 00:31:35,090
모두 저장
--k보다 작은 것들

796
00:31:35,089 --> 00:31:37,339
키가 보다 작음
크, 어쩌고저쩌고.

797
00:31:37,339 --> 00:31:41,599
그리고 여기에 저장됩니다.
외부 주문

798
00:31:41,599 --> 00:31:45,319
요소를 기반으로 함
어쩌고저쩌고.

799
00:31:45,319 --> 00:31:46,099
좋은.

800
00:31:46,099 --> 00:31:50,449
사실 제가 지적하고 싶은 것은,
그들이 이런 식으로 저장한다는 것입니다.

801
00:31:50,450 --> 00:31:53,690
실제로 위압적이다
이것들에 대한 특정 불변량

802
00:31:53,690 --> 00:31:56,480
내가 사용하는 데이터 구조
저는 지지하고 싶습니다.

803
00:31:56,480 --> 00:31:59,150
하지만 그것을 증명하기 위해 제가 해야 할 일은...
이것이 옳다는 것, 바로 그것이다.

804
00:31:59,150 --> 00:32:04,280
이는 다음과 같은 가정에 근거합니다.
이러한 불변 조건들이 충족되었다는 것

805
00:32:04,279 --> 00:32:07,819
수술 전에.

806
00:32:07,819 --> 00:32:09,919
그럼 제가 그걸 증명할 수 있습니다.
이 작업은 정확합니다.

807
00:32:09,920 --> 00:32:15,620
만약 이 모든 불변량들이
저장되었다가 그 후에

808
00:32:15,619 --> 00:32:16,919
수술 후.

809
00:32:16,920 --> 00:32:19,610
이로써 나는 증명한다.
이것이 옳다는 것입니다.

810
00:32:19,609 --> 00:32:22,099
그리고 제가 요청을 보내면,
저는 지금 검색을 하고 있습니다.

811
00:32:22,099 --> 00:32:25,279
이 데이터 구조에서, 저는
나는 이러한 불변 조건들을 믿을 수 있다.

812
00:32:25,279 --> 00:32:27,460
나는 이것들이
상황은 좋습니다.

813
00:32:27,460 --> 00:32:29,779
이런 것들
제공됩니다.

814
00:32:29,779 --> 00:32:32,420
그래서 저는 의지할 수 있습니다
그들이 찾도록

815
00:32:32,420 --> 00:32:34,250
이것의 가장 k적인 것.

816
00:32:34,250 --> 00:32:35,407
이해가 되시나요?

817
00:32:35,407 --> 00:32:36,949
만약 그것이 매우
추상적으로, 그런 다음 잠시 후에 우리는

818
00:32:36,950 --> 00:32:40,650
잠시 서 있자
더 구체적으로.

819
00:32:40,650 --> 00:32:44,060
그런 다음 실행합니다.
모든 작전.

820
00:32:44,059 --> 00:32:45,950
상상도 못 할 거예요.
해결책은 몇 개입니까?

821
00:32:45,950 --> 00:32:50,569
우리는 시험에서 읽었어요.
우리가 당신에게 드리는 것

822
00:32:50,569 --> 00:32:55,399
세 가지 작업을 수행합니다.
그리고 당신은 그 어떤 것도 언급하지 않았군요.

823
00:32:55,400 --> 00:32:57,259
그리고 보통 이것은
가장 쉬운 것.

824
00:32:57,259 --> 00:32:59,990
마치 삽입된 것 같아요
데이터 구조.

825
00:32:59,990 --> 00:33:02,329
마치,
자, 그냥 말해봐.

826
00:33:02,329 --> 00:33:05,629
다음과 같은 경우에는 포인트를 드릴 수 없습니다.
당신은 이 작전을 기억하지 못할 겁니다.

827
00:33:05,630 --> 00:33:07,480
이해가 되시나요?

828
00:33:07,480 --> 00:33:10,519
그리고 나서 이것이
도움이 될 것입니다 - 우리는 행복합니다

829
00:33:10,519 --> 00:33:12,740
반 친구들, 너희에게 더 많은 점수를 줄게.

830
00:33:12,740 --> 00:33:17,839
꼭 그렇지는 않지만, 만약
당신의 결정

831
00:33:17,839 --> 00:33:21,199
잘 정리되어 있고 표시도 잘 되어 있습니다.
등,

832
00:33:21,200 --> 00:33:24,759
그럼 우리는 할 수 있어요
당신의 결정을 더 잘 이해하겠습니다.

833
00:33:24,759 --> 00:33:26,509
그리고
더 많은 점수를 드리겠습니다.

834
00:33:26,509 --> 00:33:30,509
이 수업의 일부를 기억하세요
소통에 전념합니다.

835
00:33:30,509 --> 00:33:37,039
당신의 말이 맞다면, 하지만 우리는
우리는 당신이 무슨 말을 하는지 이해할 수 없습니다.

836
00:33:37,039 --> 00:33:38,034
그렇다면 그것은 틀린 것입니다.

837
00:33:42,019 --> 00:33:44,279
좋은.

838
00:33:44,279 --> 00:33:44,779
좋은

839
00:33:44,779 --> 00:33:48,470
그래서 우리는 가지고 있습니다
이와 관련하여 궁금한 점이 있으신가요?

840
00:33:48,470 --> 00:33:49,241
예

841
00:33:49,241 --> 00:33:51,019
청중: 단지
불변량에 관한 질문입니다.

842
00:33:51,019 --> 00:33:52,759
그래서, 그중 하나는
우리가 사용하는 데이터 구조

843
00:33:52,759 --> 00:33:54,134
논의된 내용
수업 전,

844
00:33:54,134 --> 00:33:55,750
무엇인지 결정하기 위해
불변량,

845
00:33:55,750 --> 00:33:57,242
예를 들어, AVL 트리 규칙이 있습니다.

846
00:33:57,242 --> 00:33:57,909
제이슨 쿠: 맞습니다.

847
00:33:57,910 --> 00:33:59,950
그래서, 만약 이것이
일반적인 것들, 우리는

848
00:33:59,950 --> 00:34:04,240
우리는 무엇에 대해 이야기하려고 했을까요?
이제는 흔한 일이죠.

849
00:34:04,240 --> 00:34:07,329
그렇다면 그럴 필요가 없습니다.
재확인 또는 --재진술

850
00:34:07,329 --> 00:34:10,599
그러니까, 당신은 할 수 있다는 거죠.
간단히 말해서 방법을 설명해 주세요.

851
00:34:10,599 --> 00:34:14,960
세트와 시퀀스 인터페이스 때문에
한정된

852
00:34:14,960 --> 00:34:16,420
따라서, 이것들은
모든 게 잘 되고 있어요.

853
00:34:16,420 --> 00:34:22,000
예를 들면 --거의 당신
일반적으로 가능합니다.

854
00:34:22,000 --> 00:34:25,719
당신은 설득하려고 노력하고 있습니다
이것이 왜 옳은지 설명해 주세요.

855
00:34:25,719 --> 00:34:28,599
구조를 올바르게 사용하면
데이터 세트 또는 시퀀스

856
00:34:28,599 --> 00:34:32,710
이 중에서
그렇다면 데이터 구조와 같은 문제는 어떨까요?

857
00:34:32,710 --> 00:34:38,239
사용하지 않으면
특이한 방식으로,

858
00:34:38,239 --> 00:34:41,079
보통은 그냥 하면 돼요
구조물의 속성에 의존한다

859
00:34:41,079 --> 00:34:43,789
데이터 세트 및 시퀀스,
우리가 당신에게 드린 것입니다.

860
00:34:43,789 --> 00:34:48,070
나는 당신이 그것을 기억해주길 바란다.
당신은 정확성에 대해 생각하고 있었군요.

861
00:34:48,070 --> 00:34:54,789
이 데이터 구조
맞습니다. 왜냐하면.

862
00:34:54,789 --> 00:34:58,840
다음 내용을 포함하는 문장을 쓰세요.
그렇게 말해지고 확언되었다.

863
00:34:58,840 --> 00:35:01,480
당신은 무엇입니까?
주로 지원

864
00:35:01,480 --> 00:35:03,460
당신의 불변성
데이터 구조

865
00:35:03,460 --> 00:35:04,960
최고 수준에서.

866
00:35:04,960 --> 00:35:08,590
어떤 것들
이 데이터 구조는 무엇을 저장합니까?  ~에

867
00:35:08,590 --> 00:35:14,320
무엇에 관한 것
전역 데이터 구조

868
00:35:14,320 --> 00:35:16,900
우리는 의존합니다
쿼리 작업을 수행하시겠습니까?

869
00:35:16,900 --> 00:35:22,000
당신이 설득하는 동안,
동적 수술 후

870
00:35:22,000 --> 00:35:25,210
수정 중
데이터 구조 이러한 불변식

871
00:35:25,210 --> 00:35:29,829
그대로 유지됩니다
그래도 만족한다면,

872
00:35:29,829 --> 00:35:32,769
그게 전부예요.
당신은 말해야 합니다.

873
00:35:32,769 --> 00:35:36,159
이러한 불변량
만족합니다.

874
00:35:36,159 --> 00:35:39,670
정의에 따르면
집합 및 순차 데이터 구조.

875
00:35:39,670 --> 00:35:42,550
대부분의 경우 그렇지 않습니다.
생각을 많이 해야 해요.

876
00:35:42,550 --> 00:35:45,310
묻기 위해,

877
00:35:45,309 --> 00:35:48,849
우리가 결정하는 이유
감소 작업이므로,

878
00:35:48,849 --> 00:35:51,489
많은 것이 필요하지 않습니다.
이것이 우리에게 증명될 수 있도록 노력해 주세요.

879
00:35:51,489 --> 00:35:52,479
오른쪽.  안에

880
00:35:52,480 --> 00:35:54,610
우리 수가 많아요
멋진 검은색 상자들.

881
00:35:54,610 --> 00:35:55,480
그들의 말이 맞습니다.

882
00:35:55,480 --> 00:35:57,969
저희는 여러분께 증명해 드렸습니다.
그들이 옳다는 것입니다.

883
00:35:57,969 --> 00:36:01,480
그래서 당신은
이 작업을 반복해야 합니다.

884
00:36:01,480 --> 00:36:07,420
자, 그럼 이제 하나씩 살펴보겠습니다.
제가 가장 좋아하는 주요 소재에 대해

885
00:36:07,420 --> 00:36:09,610
이번 수업에서 생각해 볼 점.

886
00:36:09,610 --> 00:36:11,349
파트 1
이 수업의,

887
00:36:11,349 --> 00:36:16,960
이러한 수학적 방법 외에도
우리가 개발한 도구들

888
00:36:16,960 --> 00:36:18,460
일찍
강의,

889
00:36:18,460 --> 00:36:21,670
주로 문제 해결에 전념합니다.
데이터 구조를 사용하여.

890
00:36:21,670 --> 00:36:24,309
그리고 우리는 이것을 동기 부여했습니다.
정렬 문제

891
00:36:24,309 --> 00:36:27,070
정렬된 배열이기 때문에
는 데이터 구조입니다.

892
00:36:27,070 --> 00:36:28,720
실제로 매우 유용합니다.

893
00:36:28,719 --> 00:36:31,029
하지만 이런 문제들을 어떻게 해결해야 할까요?

894
00:36:31,030 --> 00:36:35,350
자, 저희가 보여드렸잖아요.
이를 위한 몇 가지 방법이 있습니다.

895
00:36:35,349 --> 00:36:37,900
그리고 여기 저 아름다운 테이블이 있습니다.

896
00:36:37,900 --> 00:36:40,539
많은 것들이요.

897
00:36:40,539 --> 00:36:42,500
왜 이 내용을 보여드리는 걸까요?
정렬 알고리즘이 여러 개 있나요?

898
00:36:42,500 --> 00:36:45,693
그냥 주면 안 될까요?
알고리즘이 하나 있으신가요?

899
00:36:45,693 --> 00:36:46,789
흠?

900
00:36:46,789 --> 00:36:47,289
예?

901
00:36:47,289 --> 00:36:49,269
관객: --시간.

902
00:36:49,269 --> 00:36:50,829
제이슨 쿠: 근무 시간이 다릅니다.

903
00:36:50,829 --> 00:36:51,849
대상: 다양한 사람들에게 더 적합합니다.

904
00:36:51,849 --> 00:36:52,914
제이슨 쿠: ~에게 더 나은
다양한 시나리오.

905
00:36:52,914 --> 00:36:53,259
청중: 네.  안에

906
00:36:53,260 --> 00:36:55,107
그들 각자는 가지고 있다
개인별 점수,

907
00:36:55,106 --> 00:36:55,940
그렇다면 그들은 더 나은 사람들입니다.

908
00:36:55,940 --> 00:36:56,565
제이슨 쿠: 네.

909
00:36:56,565 --> 00:37:00,820
여러분은 다음과 같은 점을 알게 될 것입니다.
이 표

910
00:37:00,820 --> 00:37:05,260
이것들 중 어느 것도 파란색이 아닙니다.

911
00:37:05,260 --> 00:37:07,720
그러므로 그중 일부는 더 낫습니다.
다양한 시나리오에 따라.

912
00:37:07,719 --> 00:37:12,250
그리고 실제로, 이러한 댓글들은
다음과 같은 몇 가지 특별한 경우를 나열합니다.

913
00:37:12,250 --> 00:37:14,199
이러한 점들은 개선될 수 있습니다.

914
00:37:14,199 --> 00:37:17,919
사실, 이것은
울트라 블루 씽

915
00:37:17,920 --> 00:37:20,710
이것은 다음과 같이 말합니다.
시간은 선형적일 수 있습니다.

916
00:37:20,710 --> 00:37:22,269
그게 더 낫네요.

917
00:37:22,269 --> 00:37:26,469
하지만 어떤 경우에는 상황이 더 심각합니다.
그 외의 모든 것에 대해서는.

918
00:37:26,469 --> 00:37:31,569
그러니 조금 조심하세요.
이 파란색.

919
00:37:31,570 --> 00:37:35,620
일반적으로 우리는 생략하려고 노력합니다.
이 표 아래에 있는 당신,

920
00:37:35,619 --> 00:37:37,900
가능하다면요.

921
00:37:37,900 --> 00:37:45,099
일반적으로 어떻게,
예를 들어, 병합 정렬, AVL 정렬 등이 있습니다.

922
00:37:45,099 --> 00:37:48,579
사실 그것들은 똑같습니다
점근적 복잡성의 관점에서

923
00:37:48,579 --> 00:37:51,460
그리고 당신이 하는 방식
이것들과 상호작용하세요

924
00:37:51,460 --> 00:37:53,110
분류실.

925
00:37:53,110 --> 00:37:54,910
하지만 있습니다
특별한 경우

926
00:37:54,909 --> 00:37:58,899
삽입 정렬을 사용할 수 있습니다.
또는 선택, 정확히는 정렬입니다.

927
00:37:58,900 --> 00:38:01,450
저는 잘 모르겠습니다.
삽입 정렬.

928
00:38:01,449 --> 00:38:07,750
당신의
이틀 전에 낭송했어요...

929
00:38:07,750 --> 00:38:11,349
저는 당신이
그 방법을 보여주었다.

930
00:38:11,349 --> 00:38:14,889
k-근접 배열이 있는 경우,
사물이 위치한 곳은 더 이상 아닙니다.

931
00:38:14,889 --> 00:38:16,449
k보다 떨어져 있습니다.

932
00:38:16,449 --> 00:38:18,643
삽입 정렬은 실제로
k당 n번 실행됩니다.

933
00:38:18,643 --> 00:38:20,559
따라서 k가 작으면,
정말 좋네요.

934
00:38:20,559 --> 00:38:22,389
마치 선형적인 것 같아요.

935
00:38:22,389 --> 00:38:24,639
하지만 사실 당신은 할 수 있습니다
더 잘하기 위해

936
00:38:24,639 --> 00:38:28,269
이진 힙을 사용하면
낭송에서 보셨기를 바랍니다.

937
00:38:28,269 --> 00:38:32,469
여기서 이를 줄일 수 있습니다.
n log k, 유지

938
00:38:32,469 --> 00:38:37,839
통과 중에 쌓이고
이런 식으로 최댓값을 찾습니다.

939
00:38:37,840 --> 00:38:40,780
삽입 정렬이라고 하면,
아마 그다지 좋지 않을 거예요.

940
00:38:40,780 --> 00:38:43,840
하지만 선택 항목을 정렬하면,
게임 이름

941
00:38:43,840 --> 00:38:50,289
이런 식으로: 만약
내 독서는 저렴하다.

942
00:38:50,289 --> 00:38:54,119
하지만 기록
비싼, 정렬 선택

943
00:38:54,119 --> 00:38:56,670
실제로 꽤 잘 작동합니다.
알겠습니다. 제가 가진 게...

944
00:38:56,670 --> 00:38:57,539
죄송합니다.

945
00:38:57,539 --> 00:39:00,449
독서는 저렴하지만,
글쓰기는 비용이 많이 든다.

946
00:39:00,449 --> 00:39:02,674
선택 항목을 정렬합니다.
선형 치환 횟수.

947
00:39:02,675 --> 00:39:04,800
그것은 아래를 내려다보며 찾고 있다.
기껏해야 교체하는 것뿐입니다.

948
00:39:04,800 --> 00:39:06,240
그리고 계속하세요.

949
00:39:06,239 --> 00:39:08,459
따라서 그러한 경우에는
이것은 사실

950
00:39:08,460 --> 00:39:11,769
다른 어떤 것보다 낫다
우리가 가진 알고리즘들.

951
00:39:11,769 --> 00:39:12,269
예?

952
00:39:12,269 --> 00:39:13,463
관객: 이 더미는… 마치…

953
00:39:13,463 --> 00:39:14,219
제이슨 쿠: 음음음.

954
00:39:14,219 --> 00:39:17,129
청중: --시간,
최악의 시나리오가 예상됩니다.

955
00:39:17,130 --> 00:39:19,349
제이슨 쿠: 이건 최악의 시나리오입니다.

956
00:39:19,349 --> 00:39:21,089
그래서 좀 어렵네요.

957
00:39:21,090 --> 00:39:24,329
이사하는 사람들이 많았습니다.
이 한계에 도달하기 위한 부품

958
00:39:24,329 --> 00:39:27,360
화요일 강의에서.

959
00:39:27,360 --> 00:39:28,920
본질적으로 우리가
우리는 그렇게 했고, 여러분에게 보여드렸습니다.

960
00:39:28,920 --> 00:39:31,920
어떻게 고려해야 할까요?
배열을 힙으로 사용 -

961
00:39:31,920 --> 00:39:34,019
이진 트리와 같습니다.

962
00:39:34,019 --> 00:39:35,219
완전 이진 트리.

963
00:39:35,219 --> 00:39:36,719
이것은 AVL이 아닙니다.

964
00:39:36,719 --> 00:39:40,379
제 말은, 이것이
AVL 트리, 하지만 AVL 트리

965
00:39:40,380 --> 00:39:43,190
온전한 나무보다 약하다.

966
00:39:43,190 --> 00:39:46,470
높이 균형 감각이 약합니다.
완전한 것보다 더 나은 속성.

967
00:39:46,469 --> 00:39:50,579
우리가 사용하는 이유는 다음과 같습니다.
완료, 그게 다인가요?

968
00:39:50,579 --> 00:39:54,269
여러 노드에 고유합니다.

969
00:39:54,269 --> 00:39:57,963
그래서 제가 당신에게 하나를 드릴 때
고정 길이 배열,

970
00:39:57,963 --> 00:39:59,880
나는 그 나무가 어떤 나무인지 정확히 알고 있다.
당신은 이렇게 말합니다.

971
00:39:59,880 --> 00:40:03,547
왜냐하면
서로의 모습이 반영되어 있다.

972
00:40:03,547 --> 00:40:10,349
만약 어떤 부분에라도 모호한 점이 있었다면
제가 말하는 나무에 대해서 말씀드리자면,

973
00:40:10,349 --> 00:40:13,289
저는... 구매하겠습니다
절대 통하지 않을 겁니다.

974
00:40:13,289 --> 00:40:17,130
힙 정렬이 하는 일은 다음과 같습니다.
이것은 매치입니다

975
00:40:17,130 --> 00:40:20,010
배열과 이진 트리의 차이점.

976
00:40:20,010 --> 00:40:22,470
그리고 나서 그는 무엇을 했는가?
그렇습니다, 그것은 제공합니다

977
00:40:22,469 --> 00:40:26,939
이러한 작업들은 다음과 같이 보입니다.
모든 작업은 마지막에만 수행하십시오.

978
00:40:26,940 --> 00:40:30,329
그런 다음
현장 최적화

979
00:40:30,329 --> 00:40:32,969
그건, 음, 대신에
실제로 잡아당기거나 밀어 넣으세요

980
00:40:32,969 --> 00:40:34,919
그의 등에
배열의 일부, 나

981
00:40:34,920 --> 00:40:39,659
잠시 생각해 보겠습니다.
배열의 부분집합을 힙으로 구성합니다.

982
00:40:39,659 --> 00:40:45,960
그러면 항상 이런 식이죠
끝까지 최대한 많이 버리세요.

983
00:40:45,960 --> 00:40:49,019
그냥 두고 가는 것
그리고 나는 내 물건 더미에 대해 생각한다.

984
00:40:49,019 --> 00:40:51,659
더 작은 부분집합으로.

985
00:40:51,659 --> 00:40:55,094
우리는 이렇게 이해했습니다.
사실은 그렇지 않다

986
00:40:55,094 --> 00:40:58,949
감가상각은 취소되지 않았습니다.

987
00:40:58,949 --> 00:41:01,439
한정된 기간 동안, 시간
제한 사항

988
00:41:01,440 --> 00:41:04,950
이것을 상각된 버전을 사용하여 수행하십시오.
기본적으로 동적 배열

989
00:41:04,949 --> 00:41:05,939
.

990
00:41:05,940 --> 00:41:07,530
시간 제한
이것에 의존하지 않습니다.

991
00:41:07,530 --> 00:41:12,720
현장 운영은 열쇠에 의존합니다.
하나의 배열로 유지됩니다.

992
00:41:12,719 --> 00:41:14,250
이해가 되시나요?

993
00:41:14,250 --> 00:41:17,079
당신은 많은 일을 하고 있어요
상각된 운영,

994
00:41:17,079 --> 00:41:19,529
그러니까 그건 사실이에요
n log n의 최악의 경우에 도달합니다.

995
00:41:19,530 --> 00:41:20,280
예?

996
00:41:20,280 --> 00:41:22,632
청중: 그런 것 같네요
우리는 무엇을 배웠을까요...

997
00:41:22,632 --> 00:41:23,340
제이슨 쿠: 음음.

998
00:41:23,340 --> 00:41:24,550
청중: --그렇지는 않네요...

999
00:41:24,550 --> 00:41:25,440
제이슨 쿠: 음음.

1000
00:41:25,440 --> 00:41:26,815
청중: 그들,
대개 더 좋습니다.

1001
00:41:26,815 --> 00:41:29,594
자, 그럼 대부분의 알고리즘이 다음과 같다고 가정해 봅시다.
우리가 바라는 것보다 더 나은 모습일 것이다...

1002
00:41:29,594 --> 00:41:31,210
제이슨 쿠: 네.

1003
00:41:31,210 --> 00:41:32,429
청중: --더 빠르게.

1004
00:41:32,429 --> 00:41:35,460
사람들이
자주 사용되지 않을 것입니다, 특히

1005
00:41:35,460 --> 00:41:37,619
이 [알아들을 수 없는 부분]
삽입 및 선택.

1006
00:41:37,619 --> 00:41:38,536
제이슨 쿠: 네, 맞습니다.

1007
00:41:38,536 --> 00:41:40,919
그래서 특별한 것들이 있습니다.
좋은 경우라면,

1008
00:41:40,920 --> 00:41:45,690
하지만 제 말은 일반적인 의미로 하는 말입니다.
이것들이 최고입니다

1009
00:41:45,690 --> 00:41:48,599
일반적인 데이터 구조
대부분의 상황에서,

1010
00:41:48,599 --> 00:41:49,710
당신이 마주치는 것.

1011
00:41:49,710 --> 00:41:52,139
제 말은, 그런 경우가 있다는 거죠.
다른 것들은 다 좋아요.

1012
00:41:52,139 --> 00:41:54,210
그러니까 당신은 원하지 않는다는 거죠.
그들을 완전히 무시하세요.

1013
00:41:54,210 --> 00:41:58,199
하지만 전반적으로 보면, 네, 당신
결론이 나려고 노력 중

1014
00:41:58,199 --> 00:41:58,799
이 도표에서.

1015
00:41:58,800 --> 00:42:01,383
청중: 제 말은…
만약 --connected가 없다면, 예를 들어

1016
00:42:01,382 --> 00:42:03,779
저는 그것들을 모두 사용하지만, 그중에서 예외는 있습니다.
선택 항목별 정렬 --

1017
00:42:03,780 --> 00:42:05,910
제이슨 쿠: 그래서,
여기엔 물건이 너무 많아요.

1018
00:42:05,909 --> 00:42:09,029
우리가 확인할 수 있도록
그들 모두 시험에 나온다.

1019
00:42:09,030 --> 00:42:12,300
그러니 모르더라도 두려워하지 마세요.
모든 것이 포함됩니다.

1020
00:42:12,300 --> 00:42:15,360
걱정할 때
시험에서 어떤 내용이 18번 나온다.

1021
00:42:15,360 --> 00:42:17,019
이건 안 좋은 일이야.

1022
00:42:17,019 --> 00:42:17,519
좋은.

1023
00:42:17,519 --> 00:42:20,969
따라서, 진법별로 정렬하려면
그런 상황들이 있습니다.

1024
00:42:20,969 --> 00:42:23,429
선형 시간을 얻게 되면.

1025
00:42:23,429 --> 00:42:25,379
이때가 바로 당신이
다항식으로 제한됩니다.

1026
00:42:25,380 --> 00:42:28,769
그런 경우가 있나요?
내가 사용하고 싶을 때

1027
00:42:28,769 --> 00:42:31,679
내가 베이스별로 정렬할 때
다항식으로 제한되지 않음

1028
00:42:31,679 --> 00:42:32,565
정수로 나타내시겠어요?

1029
00:42:37,708 --> 00:42:39,750
청중: 음, 만약 당신이
다항식에 의해 제한되지 않음,

1030
00:42:39,750 --> 00:42:41,789
그러면 시간이 걸릴 수 있습니다.
시간이 꽤 많아요.

1031
00:42:41,789 --> 00:42:43,210
제이슨 쿠: 물론이죠.

1032
00:42:43,210 --> 00:42:49,990
하지만 예를 들어, 이것은 어디에 있습니까?
n log n보다 더 나빠지는 시점은 언제일까요?

1033
00:42:52,960 --> 00:42:55,269
이것은 확실히
n log n보다 더 좋다,

1034
00:42:55,269 --> 00:42:58,329
u가 다항식적으로 제한될 때.

1035
00:42:58,329 --> 00:43:00,539
선형적이기 때문입니다.

1036
00:43:00,539 --> 00:43:01,389
예?

1037
00:43:01,389 --> 00:43:03,519
청중: [알아들을 수 없음]
n에서 n으로.

1038
00:43:03,519 --> 00:43:05,369
제이슨 쿠: n 온 n.

1039
00:43:05,369 --> 00:43:05,869
좋은.

1040
00:43:05,869 --> 00:43:09,489
그래서 만약 제가 앞에 n을 붙이면
여기서, 나는

1041
00:43:09,489 --> 00:43:12,309
저는 n이라는 인수를 구할 것입니다.
이것이 여기서 나옵니다.

1042
00:43:12,309 --> 00:43:15,079
이것은 나에게
2차 함수 형태의 작업 시간,

1043
00:43:15,079 --> 00:43:17,710
그다지 좋지 않네요.

1044
00:43:17,710 --> 00:43:22,750
하지만 언제쯤 가능할까요?
n log n보다 더 나은가요?

1045
00:43:22,750 --> 00:43:24,010
예?

1046
00:43:24,010 --> 00:43:27,757
청중: n on c,
왜냐하면 그것은 n 곱하기 c보다 작기 때문입니다.

1047
00:43:27,757 --> 00:43:29,590
제이슨 쿠: n에서 c로--
네, 맞아요.

1048
00:43:29,590 --> 00:43:31,025
선형적인 시간을 알려줄 것입니다.

1049
00:43:31,025 --> 00:43:32,150
거기에 그렇게 쓰여 있어요.

1050
00:43:32,150 --> 00:43:35,710
하지만 실제로는 우리는 할 수 있습니다
n log n보다 더 나은 결과를 낸다.

1051
00:43:35,710 --> 00:43:43,150
만약 이 u가 n에서 c와 같다면,
어떤 c에 대해 log n을 곱합니다.

1052
00:43:43,150 --> 00:43:48,610
만약 --이것은 이것이와 같다면
n에서 c로의 로그 로그 n,

1053
00:43:48,610 --> 00:43:50,070
이는 log n보다 작습니다.

1054
00:43:50,070 --> 00:43:52,360
그래서 이것이 더 나은 알고리즘입니다.

1055
00:43:52,360 --> 00:43:53,590
이것은 더 빠른 알고리즘입니다.

1056
00:43:53,590 --> 00:43:58,600
여러분, 우리가 왜 그런 행동을 하는지 이해하시나요?
그렇게 쓰셨나요?

1057
00:43:58,599 --> 00:44:02,139
이는 저희가 제공할 수 있도록 하기 위함입니다.
보다 정확한 정보를 제공해 드리겠습니다.

1058
00:44:02,139 --> 00:44:05,679
당신에게 더 중요한 것은,
무슨 뜻이에요?

1059
00:44:05,679 --> 00:44:09,039
이것보다 더 중요한 것은
때로는 선형적인 시간 개념으로 작동합니다.

1060
00:44:09,039 --> 00:44:12,739
우리는 언제인지 알고 싶습니다
그것은 선형적인 시간으로 작동합니다.

1061
00:44:12,739 --> 00:44:13,899
이해가 되시나요?

1062
00:44:13,900 --> 00:44:16,755
혹은 더 빨리 작동할 때,
병합 정렬보다.

1063
00:44:16,755 --> 00:44:19,849
이해가 되시나요?

1064
00:44:19,849 --> 00:44:20,349
좋은.

1065
00:44:20,349 --> 00:44:21,505
자, 그럼 정렬해 볼까요?  안에

1066
00:44:24,159 --> 00:44:26,319
우리들이 있어요
순차적 데이터 구조.  안에

1067
00:44:26,320 --> 00:44:28,870
우리는 연결된 리스트를 가지고 있습니다.
저희는 동적 배열을 사용합니다.

1068
00:44:28,869 --> 00:44:30,069
저희는 AVL 시퀀스를 보유하고 있습니다.

1069
00:44:30,070 --> 00:44:32,309
AVL 시퀀스는 훌륭합니다.

1070
00:44:32,309 --> 00:44:34,029
이유는 모르겠어요.
아무도 이걸 가르치지 않아.

1071
00:44:34,030 --> 00:44:35,290
그들은 훌륭해요.

1072
00:44:35,289 --> 00:44:38,230
아마 이런 건 안 가르치나 봐요.
왜냐하면 그들은 실제로 그렇지 않기 때문입니다.

1073
00:44:38,230 --> 00:44:40,929
매우 유용합니다.

1074
00:44:40,929 --> 00:44:45,759
당신은 정말로 그렇지 않아요
가운데 삽입물을 자주 사용합니다.

1075
00:44:45,760 --> 00:44:46,660
코딩에서.

1076
00:44:46,659 --> 00:44:50,139
보통은 가능합니다.
이동하다

1077
00:44:50,139 --> 00:44:53,045
무언가를 끝내고 완료하다
동적 작업이 있습니다.

1078
00:44:53,045 --> 00:44:55,420
그리고 그건 정말 많은 게임이죠
당신은 게임을 하려고 하는군요, 그래서 당신은

1079
00:44:55,420 --> 00:44:57,490
만들 필요가 없습니다
자체 데이터 구조,

1080
00:44:57,489 --> 00:45:02,229
그리고 그냥 사용하시면 됩니다
파이썬 리스트는 다음과 같습니다...

1081
00:45:02,230 --> 00:45:04,119
마치 당신의 물건에 원래부터 있던 것처럼요.

1082
00:45:04,119 --> 00:45:06,190
하지만 그는 가지고 있다
이론적 관심,

1083
00:45:06,190 --> 00:45:08,530
그는 얻는다
그러한 균형 잡힌 경계,

1084
00:45:08,530 --> 00:45:12,970
삽입해야 하는 경우
이 시퀀스의 중간 부분입니다.

1085
00:45:12,969 --> 00:45:18,399
여러분 중 몇몇 분들이 저를 보고 계시네요.
그는 전에 그것을 가지고 있어요

1086
00:45:18,400 --> 00:45:24,490
그런 질문이 있었는데, 제이슨은...
연결 리스트 연산은 어떻게 수행되는가

1087
00:45:24,489 --> 00:45:27,759
~에
연결 리스트의 양 끝,

1088
00:45:27,760 --> 00:45:30,220
왜 이것은 선형 시간을 필요로 하는가?

1089
00:45:30,219 --> 00:45:34,029
강의에서 그 이유는
우리가 여러분께 무엇을 소개해 드렸을까요?

1090
00:45:36,889 --> 00:45:39,619
단일 연결 리스트.  안에

1091
00:45:39,619 --> 00:45:42,411
그건 그냥 지시사항이었어요.
다음으로.

1092
00:45:42,411 --> 00:45:44,869
그리고 만약 제가 포인터만 가지고 있다면
다음으로 할 일과 포인터

1093
00:45:44,869 --> 00:45:49,130
머리 위에, 그래서
끝을 찾으세요,

1094
00:45:49,130 --> 00:45:52,430
저는 가봐야 해요.
전체 목록입니다.

1095
00:45:52,429 --> 00:45:57,500
자, 제가 포인터를 들고 있다고 가정해 봅시다.
꼬리 부분에서 이것을 찾으세요.

1096
00:45:57,500 --> 00:46:01,340
n1은 괜찮지만 삭제하면
여전히 선형적인 시간이 걸립니다.

1097
00:46:01,340 --> 00:46:04,610
저는 모르기 때문입니다.
내 앞에 있던 것.

1098
00:46:04,610 --> 00:46:08,420
그래서
임의의 1, 2에 대한 p-세트,

1099
00:46:08,420 --> 00:46:11,809
난 기억이 안 나, 너
백 포인터를 저장했습니다

1100
00:46:11,809 --> 00:46:14,190
이전 것과 비교하면,
이중 연결 리스트를 드렸습니다.

1101
00:46:14,190 --> 00:46:15,110
네, 그렇죠?

1102
00:46:15,110 --> 00:46:19,130
실제로,
이 표를 확장하면

1103
00:46:19,130 --> 00:46:22,400
참고하실 수 있습니다.
여기에 이중 연결 리스트를 그리고 얻으세요

1104
00:46:22,400 --> 00:46:24,940
이것은 마치 일정한 시간과 같습니다.

1105
00:46:24,940 --> 00:46:26,550
이해가 되시나요?

1106
00:46:26,550 --> 00:46:30,860
그리고 이것은
시간은 여전히 ​​선형적이다.

1107
00:46:30,860 --> 00:46:32,000
좋은.

1108
00:46:32,000 --> 00:46:34,199
하지만 이것은
시간은 여전히 ​​선형적이다.

1109
00:46:34,199 --> 00:46:36,649
저희도 마찬가지입니다
어떻게 하는지 보여드렸잖아요

1110
00:46:36,650 --> 00:46:38,539
이를 위해 지속적인 감가상각을 적용하십시오.

1111
00:46:38,539 --> 00:46:40,099
여러분, 이거 기억나세요?

1112
00:46:40,099 --> 00:46:45,079
혼란스러운 시기였습니다.
2차 수업인가요, 1차 수업인가요?

1113
00:46:45,079 --> 00:46:46,670
기억이 안 나요.

1114
00:46:46,670 --> 00:46:50,360
저희가 말씀드리고 싶은 건 이게 전부입니다.
가치가 하락한 것들에 대해서.

1115
00:46:50,360 --> 00:46:52,099
우리는 받았습니다.
사실 둘 다 그랬다

1116
00:46:52,099 --> 00:46:58,159
감가상각
동적 배열 개념.

1117
00:46:58,159 --> 00:47:00,469
그리고 나서 우리는 실제로
또 그랬어.

1118
00:47:00,469 --> 00:47:02,389
좋은 것을 받았기 때문에
두 가지 의미.

1119
00:47:02,389 --> 00:47:04,969
저게 뭐였지?

1120
00:47:04,969 --> 00:47:06,379
혹시 기억하는 사람 있나요?

1121
00:47:06,380 --> 00:47:08,430
우리는 세 번째 문제 풀이 시간으로 넘어갔습니다.

1122
00:47:08,429 --> 00:47:08,929
예?

1123
00:47:08,929 --> 00:47:09,971
관객: 오.

1124
00:47:09,972 --> 00:47:11,180
어쩌면 제가 틀렸을지도 몰라요, 이건...

1125
00:47:11,179 --> 00:47:11,419
제이슨 쿠: 알겠습니다.

1126
00:47:11,420 --> 00:47:12,670
청중: --문제 해결 세션 3.

1127
00:47:12,670 --> 00:47:14,510
하지만 q dq 같은 건 어떻게 되는 거죠?

1128
00:47:14,510 --> 00:47:17,330
제이슨 쿠: 그래서, q dq,
그들은 말한다

1129
00:47:17,329 --> 00:47:20,210
두 가지에 관한 것입니다.

1130
00:47:20,210 --> 00:47:23,750
시행되고 있습니다
어떤 면에서 보면, 실제로는 무엇일까요?

1131
00:47:23,750 --> 00:47:24,679
이런 것들 중 하나.

1132
00:47:24,679 --> 00:47:28,879
사실, 제 생각에는
이것은 파이썬으로 작성되었습니다.

1133
00:47:28,880 --> 00:47:32,329
하지만 우리는 사용했었습니다
또 다른 데이터 구조,

1134
00:47:32,329 --> 00:47:35,809
무언가를 얻기 위해,
정말 잘하는 것은 무엇일까요?

1135
00:47:35,809 --> 00:47:38,960
그는 정말 훌륭한 수술을 받았어요.
덧셈과 뺄셈,

1136
00:47:38,960 --> 00:47:41,820
그리고 처음과 마지막도 마찬가지입니다.
동적 운영.

1137
00:47:41,820 --> 00:47:44,240
여러분, 누군가
3차 세션 기억나세요?

1138
00:47:47,635 --> 00:47:49,090
청중: [알아들을 수 없음]

1139
00:47:49,090 --> 00:47:52,000
청중: 저거 그렇지 않나요?
동적 배열 [분해 불가능]??

1140
00:47:52,000 --> 00:47:54,789
제이슨 쿠: 맞아요.

1141
00:47:54,789 --> 00:47:55,480
좋은.

1142
00:47:55,480 --> 00:47:57,699
우리는 그것을 얻었습니다
예상되는.

1143
00:47:57,699 --> 00:48:00,639
도움이 되셨나요?

1144
00:48:00,639 --> 00:48:01,269
무엇?

1145
00:48:01,269 --> 00:48:04,119
누군가 그렇게 말하는 걸 들었어요.

1146
00:48:04,119 --> 00:48:04,769
해시 테이블.

1147
00:48:04,769 --> 00:48:05,269
예

1148
00:48:05,269 --> 00:48:09,099
그러니까 기본적으로 당신이 원하는 건 뭐죠?
이것 대신에 그렇게 했습니다.

1149
00:48:09,099 --> 00:48:10,150
순서가 있었다.

1150
00:48:10,150 --> 00:48:13,300
이것들은 열쇠가 없어요.

1151
00:48:13,300 --> 00:48:16,269
하지만 저는 알아볼 수 있었습니다.
모든 과목,

1152
00:48:16,269 --> 00:48:20,726
키를 꽂았을 때,
이는 해당 지수를 나타냅니다.

1153
00:48:20,726 --> 00:48:22,309
그리고 저는 사용할 수 있습니다
이런 해시 테이블.

1154
00:48:22,309 --> 00:48:26,889
그런데 몇 가지 어려움이 발생했습니다.
만약 내가 첫 번째 것을 삭제한다면.

1155
00:48:30,130 --> 00:48:34,510
왜냐하면, 정말로…
내 모든 인덱스

1156
00:48:34,510 --> 00:48:35,710
이제는 달라졌습니다.

1157
00:48:35,710 --> 00:48:39,280
하지만 내가 계속한다면
내 분야에서 가장 작은 인덱스,

1158
00:48:39,280 --> 00:48:42,160
그럼 난 만사형통이야.
저는 계산할 수 있기 때문입니다.

1159
00:48:42,159 --> 00:48:45,889
이 인덱스는 무엇이어야 할까요?
제가 먼저 상황을 바꿔보겠습니다.

1160
00:48:45,889 --> 00:48:46,389
좋은.

1161
00:48:46,389 --> 00:48:48,730
그러므로,

1162
00:48:48,730 --> 00:48:51,190
우리는 여러분에게 세 가지 다른 방법을 보여드렸습니다.
전면의 일정한 시간

1163
00:48:51,190 --> 00:48:53,570
그리고 이것의 뒷면.

1164
00:48:53,570 --> 00:48:57,190
그러니까 사실 당신은 할 수 있어요
이것을 표준 자료로 간주하십시오.

1165
00:48:57,190 --> 00:48:59,050
그것을 줄일 수 있는 정도.

1166
00:48:59,050 --> 00:49:00,789
이것이 유일한 것입니다
예외적인 경우,

1167
00:49:00,789 --> 00:49:02,719
내가 보여주지 않는 것
이 도표에서,

1168
00:49:02,719 --> 00:49:05,289
하지만 당신이 그렇게 한다면 보너스죠.
이 세션 문제를 살펴보세요.

1169
00:49:05,289 --> 00:49:05,949
예?

1170
00:49:05,949 --> 00:49:08,889
청중: 그럼 해시 테이블도 마찬가지 아닌가요?
데이터 구조들의 집합인가요?

1171
00:49:08,889 --> 00:49:09,849
제이슨 쿠: 맞습니다.

1172
00:49:09,849 --> 00:49:12,799
하지만 우리는 그것을 구현하는 데 사용했습니다.
일관된 데이터 구조.

1173
00:49:12,800 --> 00:49:15,730
그래서 제가 여러분을 안내해 드리겠습니다.
이번 문제가 발생한 세션,

1174
00:49:15,730 --> 00:49:18,550
원하시면
그녀에 대해 더 알아보세요.

1175
00:49:18,550 --> 00:49:21,090
그래서 다음과 같은 질문이 있습니다.
순차적 데이터 구조?

1176
00:49:21,090 --> 00:49:21,742
예?

1177
00:49:21,742 --> 00:49:22,630
청중: 저는...

1178
00:49:22,630 --> 00:49:23,890
제이슨 쿠: 네, 네.

1179
00:49:23,889 --> 00:49:25,420
청중: 우리가 가지고 있나요?
우리는… 아니면… 네.

1180
00:49:25,420 --> 00:49:28,930
우리가 확인할 수 있을까요?
우리에게 주어진 테이블 말인가요?

1181
00:49:28,929 --> 00:49:32,309
제이슨 쿠: 그래서 저는 바라건대...

1182
00:49:32,309 --> 00:49:36,549
제가 당신에게 드린다면, 저는 그것이 당신에게 도움이 되기를 바랍니다.
빈 테이블, 당신

1183
00:49:36,550 --> 00:49:37,960
작성하셔도 됩니다.

1184
00:49:37,960 --> 00:49:40,300
이것이 제가 하는 방식입니다
나는 당신이 방법을 알기를 바랍니다.

1185
00:49:40,300 --> 00:49:43,090
이러한 것들이 현실화되고 있습니다.  안에

1186
00:49:43,090 --> 00:49:46,120
우리를
이 내용은 시험에 나오지 않습니다.

1187
00:49:46,119 --> 00:49:47,650
이건 지루해.
질문.

1188
00:49:47,650 --> 00:49:49,480
청중: 하지만 이것은
그걸 아는 게 중요한가요?

1189
00:49:49,480 --> 00:49:50,105
제이슨 쿠: 네.

1190
00:49:50,105 --> 00:49:53,349
저는… 그러면 좋을 것 같아요.
생각하게끔 하기 위해,

1191
00:49:53,349 --> 00:49:56,110
예를 들어, 제가 간다면
AVL 트리를 사용합니다.

1192
00:49:56,110 --> 00:49:58,360
일반적으로 운영은 다음과 같습니다.
로그 n이 될 것입니다.

1193
00:49:58,360 --> 00:50:00,340
이건 정말 유용하네요.
그 일, 또는 내가

1194
00:50:00,340 --> 00:50:03,850
저는 해시 테이블을 사용할 겁니다.
사전 유형 연산,

1195
00:50:03,849 --> 00:50:07,029
검색, 삽입 및
제거 작업이 빠릅니다.

1196
00:50:07,030 --> 00:50:11,620
주문 유형 작업을 수행합니다.
해시 테이블을 과도하게 사용하는 것은 좋지 않습니다.

1197
00:50:11,619 --> 00:50:14,109
이것은 하기 어렵습니다. 왜냐하면
나는 해야 해

1198
00:50:14,110 --> 00:50:16,150
당신의 물건들을 모두 살펴보세요.

1199
00:50:16,150 --> 00:50:19,869
동적 연산이 무엇인지 알아두세요
정렬된 배열 위에 접근하는 것은 좋지 않습니다.

1200
00:50:19,869 --> 00:50:26,679
혹은, 이 사실을 안다면... 당신은 그렇게 해야 합니다.
우리가 의미하는 바를 생각해 보자.

1201
00:50:26,679 --> 00:50:29,719
연결 리스트에 대해 이야기할 때
이 표에는 동적 배열이 있습니다.

1202
00:50:29,719 --> 00:50:30,219
왜냐하면...

1203
00:50:30,219 --> 00:50:31,359
대상: 단일 링크 사용자.

1204
00:50:31,360 --> 00:50:32,360
제이슨 쿠: 네, 맞아요.

1205
00:50:32,360 --> 00:50:34,059
우리는 의미합니다
여기서 연결됩니다.

1206
00:50:34,059 --> 00:50:36,340
왜냐하면 그게 바로 우리니까
강의에서 여러분께 제시된 내용입니다.

1207
00:50:36,340 --> 00:50:37,930
자, 이것이 바로
일반적인 것들,

1208
00:50:37,929 --> 00:50:39,369
줄여주시길 바랍니다.

1209
00:50:39,369 --> 00:50:39,519
예?

1210
00:50:39,519 --> 00:50:41,436
청중: --3개 수정됨
일반적인 것들은

1211
00:50:41,436 --> 00:50:43,329
이중 연결 리스트,
양방향 목록...

1212
00:50:43,329 --> 00:50:43,954
제이슨 쿠: 네.

1213
00:50:43,954 --> 00:50:46,235
기본적으로 가능합니다
당신이 가지고 있다고 가정해 보세요... 정확히

1214
00:50:46,235 --> 00:50:49,389
이것은 너야,
아마 사용하고 싶으실 겁니다.

1215
00:50:49,389 --> 00:50:53,710
왜냐하면 당신은 얻게 되니까요
상수 인덱싱.

1216
00:50:53,710 --> 00:50:57,579
그리고 그 후에는 충분합니다
양쪽 모두에게 좋은 일입니다.

1217
00:50:57,579 --> 00:51:00,489
하지만 만약 당신이 필요하다면
양쪽 끝이 있는 Q,

1218
00:51:00,489 --> 00:51:04,719
줄여서 다음과 같이 쓸 수도 있습니다.
서로 나란히 위치한 두 개의 동적 배열,

1219
00:51:04,719 --> 00:51:06,439
이 길을 걸을 때,
이 길을 걸을 때.

1220
00:51:06,440 --> 00:51:07,606
그래서 많은...

1221
00:51:07,606 --> 00:51:09,940
우리는 주지 않을 것이다
당신은 이것을 표준적인 방법으로 보고 있습니다.

1222
00:51:09,940 --> 00:51:12,460
왜냐하면 말 그대로 있기 때문입니다
우리가 보여드린 네 가지 방법은 다음과 같습니다.

1223
00:51:12,460 --> 00:51:13,750
어떻게 하는가

1224
00:51:13,750 --> 00:51:14,929
자, 그럼 하나를 선택하세요.

1225
00:51:14,929 --> 00:51:15,429
좋은.

1226
00:51:15,429 --> 00:51:16,029
예?

1227
00:51:16,030 --> 00:51:18,910
대상: ~의 이익을 위하여
시험 시간을 절약하기 위해,

1228
00:51:18,909 --> 00:51:21,859
예를 들어, 우리가 말하고 싶다면, 우리는 그렇게 합니다.
이것은 일관성이 있습니다

1229
00:51:21,860 --> 00:51:23,978
AVL 방식이며, log n 시간이 소요됩니다.

1230
00:51:23,978 --> 00:51:26,019
발음해야 하나요?
그러한 문장은, 왜냐하면 그것은

1231
00:51:26,019 --> 00:51:28,228
AVL 시퀀스는 다음과 같습니다.
시간이 더 걸리는 이유는?

1232
00:51:28,228 --> 00:51:30,880
아니면 그냥 '어떻게'라고 말할 수도 있겠죠.
우리가 아는 그 테이블을 위해서요?

1233
00:51:30,880 --> 00:51:33,106
제이슨 쿠: 아니, 그렇지 않아.

1234
00:51:33,106 --> 00:51:35,560
만약 당신이 내게 그렇게 말했다면
질서를 유지하다

1235
00:51:35,559 --> 00:51:38,259
AVL, 그리고 당신은 그냥 이렇게 말하죠-

1236
00:51:38,260 --> 00:51:40,900
당신은 기본적으로 그렇게 말하는 겁니다.
당신은 그것으로 무엇을 하든, 그리고 이렇게 말하겠죠.

1237
00:51:40,900 --> 00:51:42,579
그건 시간이 걸리잖아, 어쩌고저쩌고.
어쩌고저쩌고

1238
00:51:42,579 --> 00:51:45,759
말할 필요 없어요.
AVL 시퀀스이기 때문입니다.

1239
00:51:45,760 --> 00:51:47,770
이미 말씀하셨잖아요
이것이 AVL 시퀀스임을 알려드립니다.

1240
00:51:47,769 --> 00:51:50,139
저는 당신이,
아마도 도표를 그렸을 것이다.

1241
00:51:50,139 --> 00:51:52,909
요약본에
그리고 그것을 바라보았다.

1242
00:51:52,909 --> 00:51:54,549
좋은

1243
00:51:54,550 --> 00:51:55,870
이와 관련해서 더 궁금한 점이 있으신가요?

1244
00:51:55,869 --> 00:51:56,469
아니요.

1245
00:51:56,469 --> 00:51:57,129
예?

1246
00:51:57,130 --> 00:51:59,680
청중: 꼭 확인해 주세요.
이중 연결 리스트

1247
00:51:59,679 --> 00:52:02,967
삽입될 것입니다
[표시 불가].

1248
00:52:02,967 --> 00:52:04,819
이게 유일한 변경 사항인가요?

1249
00:52:04,820 --> 00:52:05,735
제이슨 쿠: 네.

1250
00:52:05,735 --> 00:52:10,550
이중 연결 리스트
이 남자에게 꾸준한 시간을 준다.

1251
00:52:10,550 --> 00:52:13,010
사실,
여기에는 두 가지 작업이 있습니다.

1252
00:52:13,010 --> 00:52:14,270
삽입, 삭제 및--

1253
00:52:14,269 --> 00:52:17,300
저는 그렇게 생각합니다.
여기에도 검색 기능이 있습니다.

1254
00:52:17,300 --> 00:52:19,100
내가 계속한다면
꼬리 포인터,

1255
00:52:19,099 --> 00:52:22,130
이것은 결정될 것입니다
일정한 시간으로.

1256
00:52:22,130 --> 00:52:25,190
하지만 그건 번역이 안 돼요
일정한 시간에 역동적으로 변화합니다.

1257
00:52:25,190 --> 00:52:27,800
이전 것들도 저장해야 해요
각 노드의 포인터.

1258
00:52:27,800 --> 00:52:29,220
이해가 되시나요?

1259
00:52:29,219 --> 00:52:31,879
좋은.

1260
00:52:31,880 --> 00:52:36,119
마지막으로, 아니, 제 생각에는,
마지막에서 두 번째 단계로 데이터 구조를 설정합니다.

1261
00:52:36,119 --> 00:52:38,029
이런 것들이 몇 개 더 있습니다.

1262
00:52:38,030 --> 00:52:39,170
그렇게 많지는 않아요.

1263
00:52:42,150 --> 00:52:44,510
네, 맞습니다.  안에

1264
00:52:44,510 --> 00:52:47,600
우리는 배열을 정렬했습니다.
잘 찾아내지만, 역동적이지는 않다.

1265
00:52:51,320 --> 00:52:55,010
우리는 AVL 트리를 구축했습니다.
좋은

1266
00:52:55,010 --> 00:52:57,380
발견하고 역동적입니다.

1267
00:52:57,380 --> 00:53:02,878
다시 말하면, n을 얻게 됩니다.
생성에 따른 log n개의 간접비용,

1268
00:53:02,878 --> 00:53:05,420
왜냐하면 본질적으로 당신이
이 둘을 가지고 무엇을 하세요

1269
00:53:05,420 --> 00:53:07,260
데이터 구조, 이것은 정렬입니다.

1270
00:53:07,260 --> 00:53:12,080
하지만 만약 내가
저는 이론적인 질문을 고려하고 있습니다.

1271
00:53:12,079 --> 00:53:13,519
마치 내가 묻지 않는 것처럼
너에게 무언가를

1272
00:53:13,519 --> 00:53:16,369
구체적으로 말하자면
정렬된 배열이 있는 경우

1273
00:53:16,369 --> 00:53:19,880
이것과 저것 중에서 선택해야 합니다.
데이터 구조와 이것

1274
00:53:19,880 --> 00:53:21,440
데이터 구조, 그중 어떤 것
선택하시겠습니까?

1275
00:53:25,619 --> 00:53:27,619
음, 저는 정확히는 아니에요.
나는 알고 있다. 왜냐하면

1276
00:53:27,619 --> 00:53:32,509
거의 이것이 최고인 것 같습니다.
이것만 빼고 다.

1277
00:53:32,510 --> 00:53:35,245
하지만 누군가 저에게 방법을 알려주실 수 있나요?
이것을 영구적인 시설물로 만드세요

1278
00:53:35,244 --> 00:53:37,400
?

1279
00:53:37,400 --> 00:53:38,420
증가.

1280
00:53:38,420 --> 00:53:43,039
그냥 마음속에 간직해 둘 수 있어요.
최대 또는 최소 서브트리.

1281
00:53:43,039 --> 00:53:45,789
그리고 저는 할 수 있습니다.
이것보다 훨씬 낫다.

1282
00:53:45,789 --> 00:53:47,806
이론적으로는 그렇습니다.
당신은 아마도

1283
00:53:47,806 --> 00:53:48,889
이것만 사용하고 싶어요.

1284
00:53:51,409 --> 00:53:54,319
다음은 해시 테이블입니다.
직접 접근 배열,

1285
00:53:54,320 --> 00:53:56,600
훨씬 더 좋은
이러한 작전들.

1286
00:53:56,599 --> 00:53:57,829
이건 훌륭해요

1287
00:53:57,829 --> 00:53:59,750
하지만 이것들은 형편없어요.

1288
00:53:59,750 --> 00:54:02,719
그러니 필요하시면,
사용하지 마세요.

1289
00:54:02,719 --> 00:54:05,480
그리고 실제 코딩에서는,
특히 당신이

1290
00:54:05,480 --> 00:54:08,360
당신은 익숙하지 않은 언어로 코딩하고 있습니다.
파이썬, 뭔가

1291
00:54:08,360 --> 00:54:10,070
자동으로 주지 않습니다
해시 테이블이 있습니다.

1292
00:54:10,070 --> 00:54:14,450
C 언어로 작업한다면
MIT의 마이크로컨트롤러 연구실

1293
00:54:14,449 --> 00:54:18,169
동의합니다
6115인가 뭐시기인가,

1294
00:54:18,170 --> 00:54:21,289
그리고 당신은 컬렉션을 만들고 있습니다.
보통 당신이 하는 일,

1295
00:54:21,289 --> 00:54:23,599
직접 접근 가능한 자료입니다.

1296
00:54:23,599 --> 00:54:26,179
왜냐하면 그렇기 때문입니다
깜짝 놀라게 해줍니다.

1297
00:54:26,179 --> 00:54:27,739
당신이 필요로 하는 것
기계어,

1298
00:54:27,739 --> 00:54:30,509
실제로 접근하려면
이것은 일정한 시간 동안 지속됩니다.

1299
00:54:30,510 --> 00:54:32,960
일반적으로, 만약 당신이
당신은 키를 제어할 수 있습니다.

1300
00:54:32,960 --> 00:54:33,949
당신이 놓는 것,

1301
00:54:33,949 --> 00:54:35,869
당신이 놓는 것
데이터 구조에서,

1302
00:54:35,869 --> 00:54:38,514
당신은 이것들을 원하지 않아요
간접비가 발생하고 있었습니다.

1303
00:54:38,514 --> 00:54:39,889
열쇠를 통해
해시 함수

1304
00:54:39,889 --> 00:54:40,940
이러한 것들을 찾기 위해.

1305
00:54:40,940 --> 00:54:44,990
그냥 저장하세요
배열에 있는 것들.

1306
00:54:44,989 --> 00:54:47,959
해시를 사용합니다.
테이블이 아닐 때

1307
00:54:47,960 --> 00:54:49,880
당신은 통제권을 가지고 있습니다
열쇠 또는 ​​당신의 열쇠

1308
00:54:49,880 --> 00:54:52,767
줄이나 그런 것과 비슷해요.

1309
00:54:52,766 --> 00:54:54,349
그때 당신이
해시 테이블을 사용하세요.

1310
00:54:54,349 --> 00:54:58,214
자, 이제 우리의 목적을 위해서 말이죠.
일반적으로 해시 테이블

1311
00:54:58,215 --> 00:54:59,840
마찬가지로 좋다
저희는 귀하께 구체적으로 명시해달라고 요청하지 않습니다.

1312
00:54:59,840 --> 00:55:02,690
최악의 경우 한계.

1313
00:55:02,690 --> 00:55:05,737
그리고 우리는 그렇게 할 것입니다.
우리가 ~에 대해 이야기할 때

1314
00:55:05,737 --> 00:55:06,529
데이터 구조의 문제점.

1315
00:55:06,530 --> 00:55:12,050
만약 우리가 당신에게 다음과 같은 상황을 제시한다면
우리는 당신의 성과가 예상된 것인지 아니면 상각된 것인지에 상관하지 않습니다.

1316
00:55:12,050 --> 00:55:13,760
최악의 시나리오

1317
00:55:13,760 --> 00:55:15,177
또는 ~에서 나온 것
이건, 우리가 방금

1318
00:55:15,177 --> 00:55:19,760
예를 들어, 구체적으로 명시해 주세요.
당신은 어떤 것을 성취하시겠습니까?

1319
00:55:19,760 --> 00:55:22,310
그리고 만약 당신이
정확하게 분석했습니다.

1320
00:55:22,309 --> 00:55:25,429
데이터 구조와 관련해서 말씀드리자면,
그럼 모든 게 괜찮습니다.

1321
00:55:25,429 --> 00:55:27,929
하지만 우리가 당신이 더 나아졌다고 말한다면
최악의 상황에 대비하여 행동하기 위해,

1322
00:55:27,929 --> 00:55:29,929
널 때릴 거야

1323
00:55:29,929 --> 00:55:32,929
그럼 다음 경계를 설정해 주세요.

1324
00:55:32,929 --> 00:55:36,710
이 경우에는 해시 테이블을 사용하지 마십시오.

1325
00:55:36,710 --> 00:55:38,329
이해가 되시나요?

1326
00:55:38,329 --> 00:55:40,639
좋은.

1327
00:55:40,639 --> 00:55:43,871
마지막으로, 우리에게는 우선순위가 있습니다.
우리가 얘기했던 줄서기 말이에요.

1328
00:55:43,871 --> 00:55:45,829
나는 합격하지 않을 거야.
이 때문에 많은 것이 그렇습니다.

1329
00:55:45,829 --> 00:55:49,759
본질적으로는 간단합니다.
이 점을 덧붙입니다.

1330
00:55:49,760 --> 00:55:52,400
하지만 사실 당신은 할 수 있습니다
이러한 모든 제한 사항을 적용하세요

1331
00:55:52,400 --> 00:55:55,190
설치된 AVL을 사용하여 --

1332
00:55:55,190 --> 00:55:59,153
즉, 순차적인 AVL 트리를 의미합니다.
최대 또는 최소 팽창으로,

1333
00:55:59,152 --> 00:56:01,819
이 목록에 없는 이유는 다음과 같습니다.
우리는 그 문제에 대해 이야기하지 않았어요.

1334
00:56:01,820 --> 00:56:04,490
하지만 부디 그렇게 하실 수 있기를 바랍니다.

1335
00:56:04,489 --> 00:56:07,849
이러한 제한 사항이 필요한 경우
감가상각 없이,

1336
00:56:07,849 --> 00:56:10,980
당신은 그것들을 이룰 수 있습니다.

1337
00:56:10,980 --> 00:56:11,480
좋은

1338
00:56:11,480 --> 00:56:13,699
그게 전부입니다.
우리가 이야기하고 있는 모든 것

1339
00:56:13,699 --> 00:56:15,913
수업 시간에 발언했습니다.

1340
00:56:15,913 --> 00:56:18,329
우리는 남은 돈을 쓸 거예요.
이제 두 사람을 작업할 시간입니다

1341
00:56:18,329 --> 00:56:19,460
데이터 구조 관련 문제.

1342
00:56:19,460 --> 00:56:23,030
저는... 많지 않아요
다양한 유형의 질문들

1343
00:56:23,030 --> 00:56:27,980
너
퀴즈에서 확인하실 수 있을 거예요.

1344
00:56:27,980 --> 00:56:30,530
우리가 준비한 실기 퀴즈
지난 학기에 나눠드린 것입니다.  앞으로

1345
00:56:30,530 --> 00:56:33,500
제가 문제라고 부르는 몇 가지 사항이 있습니다.
기계적 문제

1346
00:56:33,500 --> 00:56:35,300
.

1347
00:56:35,300 --> 00:56:37,940
그러면 일반적으로 몇몇
감소 유형 문제,

1348
00:56:37,940 --> 00:56:40,490
당신이 ~로 전락하는 곳
정렬 알고리즘을 사용하여

1349
00:56:40,489 --> 00:56:41,719
또는 일부 데이터 구조.

1350
00:56:41,719 --> 00:56:43,849
그리고 일반적으로,
마지막 것들은 다음과 같습니다.

1351
00:56:43,849 --> 00:56:46,789
해야 할 일들
뭔가 특별한 것,

1352
00:56:46,789 --> 00:56:50,070
예를 들어 일부 증가 또는
분할 통치

1353
00:56:50,070 --> 00:56:51,920
뭐 그런 거죠.

1354
00:56:51,920 --> 00:56:53,480
좋은.

1355
00:56:53,480 --> 00:56:55,460
그래서 우리는 갑니다
계속하고 소비하기 위해

1356
00:56:55,460 --> 00:56:59,389
나머지 시간은 작업에 할애합니다.
이러한 문제들 중 몇 가지입니다.

1357
00:56:59,389 --> 00:57:04,519
이것들은 봄에 찍은 것들이에요.
2019년 시험.

1358
00:57:04,519 --> 00:57:09,259
그리고 사실, 그중 하나는
현재 우리 기술 직원들이 수행하고 있는 기술 전문가,

1359
00:57:09,260 --> 00:57:12,020
또한 기술 전문가입니다.
2019년 봄에 우리에게는 그랬습니다. 여기요.

1360
00:57:12,019 --> 00:57:13,969
과제를 평가했습니다
2번,

1361
00:57:13,969 --> 00:57:16,369
비와 관련된 연구 문제
그리고 나를 몹시 싫어했어요.

1362
00:57:16,369 --> 00:57:18,589
아무도 제대로 하지 못했기 때문입니다.

1363
00:57:18,590 --> 00:57:19,519
좋은

1364
00:57:19,519 --> 00:57:23,119
자, 그럼 한번 해봅시다.
이러한 문제들을 해결하세요.

1365
00:57:23,119 --> 00:57:28,730
자, 문제 1
그 식당에 관해서 말씀드리자면...

1366
00:57:28,730 --> 00:57:31,880
레스토랑이요, 네, 괜찮아요.

1367
00:57:31,880 --> 00:57:32,748
좋은

1368
00:57:32,748 --> 00:57:34,039
그래서, 무슨 일이 벌어지고 있는 거죠?

1369
00:57:34,039 --> 00:57:38,150
인기 레스토랑
범죄 해산물.

1370
00:57:38,150 --> 00:57:39,829
링크는 무엇인가요?

1371
00:57:39,829 --> 00:57:40,579
합법적인 해산물.

1372
00:57:40,579 --> 00:57:41,750
네, 정반대입니다.

1373
00:57:41,750 --> 00:57:44,360
예약은 받지 않습니다.
하지만 대기자 명단을 운영하고 있습니다.

1374
00:57:44,360 --> 00:57:47,010
고객들이
대기자 명단에 더 오래 있었습니다.

1375
00:57:47,010 --> 00:57:48,590
그들은 더 일찍 자리에 앉는다.

1376
00:57:48,590 --> 00:57:50,829
때때로 고객이 결정합니다
다른 데 가서 드세요.

1377
00:57:50,829 --> 00:57:53,029
그러므로 식당은 제거해야 합니다.
대기자 명단에서 그들을 제외합니다.

1378
00:57:53,030 --> 00:57:54,620
좋은.

1379
00:57:54,619 --> 00:57:57,710
고객이 다음과 같다고 가정해 봅시다.
이름이 다릅니다.

1380
00:57:57,710 --> 00:58:00,320
고객은 모두 다릅니다.
대기자 명단에 추가되었습니다

1381
00:58:00,320 --> 00:58:01,880
동시에.

1382
00:58:01,880 --> 00:58:04,550
그래서, 특정한 것이 있습니다.
사람들이 순서대로

1383
00:58:04,550 --> 00:58:06,060
이 대기자 명단에 추가됩니다.

1384
00:58:06,059 --> 00:58:07,429
이해가 되시나요?

1385
00:58:07,429 --> 00:58:09,769
도움이 될 데이터베이스를 만드세요
범죄자 해산물 지원

1386
00:58:09,769 --> 00:58:11,509
대기자 명단
다음의 지원을 받아

1387
00:58:11,510 --> 00:58:13,460
각 작업
일정한 시간으로.

1388
00:58:13,460 --> 00:58:18,590
네, 업데이트했습니다.
최고위층까지 근무 시간.

1389
00:58:18,590 --> 00:58:20,090
그리고 이건… 아, 죄송합니다.

1390
00:58:20,090 --> 00:58:21,692
컬렉션을 여기에 추가했습니다.

1391
00:58:21,692 --> 00:58:23,150
제 생각엔 이건
시간은 여전히 ​​일정하다.

1392
00:58:23,150 --> 00:58:23,840
좋아요, 좋아요.

1393
00:58:23,840 --> 00:58:24,680
청중: 저는 시간이 있어요...

1394
00:58:24,679 --> 00:58:25,304
제이슨 쿠: 네.

1395
00:58:25,304 --> 00:58:29,449
해당 여부를 표시해 주십시오.
각 연산은 실행 시간 측면에서 가장 비효율적인가요?

1396
00:58:29,449 --> 00:58:30,480
상각된, 예상되는.

1397
00:58:30,480 --> 00:58:33,260
그러니 이것을 보게 되면
그 진술에 대해 당신은 이렇게 말합니다: 알겠습니다.

1398
00:58:33,260 --> 00:58:37,580
저는 사용할 수 있습니다.
원한다면 해시 테이블을 만들 수도 있습니다.

1399
00:58:37,579 --> 00:58:39,860
저는 그냥 필요해요
제가 하나를 사용한다면, 반드시 다음 사항을 확인해야 합니다.

1400
00:58:39,860 --> 00:58:44,900
저는 거래 내역을 '처리 중'으로 표시합니다.
그리고 비용이 발생할 때 상각됩니다.

1401
00:58:44,900 --> 00:58:46,579
어떤 작업이 예상되나요?

1402
00:58:46,579 --> 00:58:47,840
기본적으로 모두 다요.

1403
00:58:47,840 --> 00:58:49,490
어떤 사업활동이 상각 대상인가요?

1404
00:58:49,489 --> 00:58:52,789
변화한 사람들
데이터 구조, 삽입,

1405
00:58:52,789 --> 00:58:54,259
제거하다.

1406
00:58:54,260 --> 00:58:54,890
좋은.

1407
00:58:54,889 --> 00:58:58,369
그래서 우리는 여러 가지 작전을 수행하고 있습니다.
텅 빈 것을 만드는 것.

1408
00:58:58,369 --> 00:59:02,329
이름을 추가하여 이 이름이 다음과 같이 되도록 합니다.
대기자 명단 맨 끝에 x가 있습니다.

1409
00:59:02,329 --> 00:59:03,529
내가 x에 대해 뭘 알겠어?

1410
00:59:03,530 --> 00:59:06,350
내가 뭘 알겠어?
우리의 추측에 따른 이름

1411
00:59:06,349 --> 00:59:06,980
이 수업에서요?

1412
00:59:06,980 --> 00:59:08,690
청중: 그들은 독특해요.
그러므로 이것이 핵심일 수 있습니다.

1413
00:59:08,690 --> 00:59:10,648
제이슨 쿠: 그들은 독특해요.
그러므로 이것이 핵심일 수 있습니다.

1414
00:59:10,648 --> 00:59:14,539
그리고 그들은 잘 어울립니다.
일정한 단어 수

1415
00:59:14,539 --> 00:59:15,779
우리의 가정에 따르면.

1416
00:59:15,780 --> 00:59:17,920
그래서 비교할 수 있도록
그중 두 명은...

1417
00:59:17,920 --> 00:59:19,700
아니면 제가 하나 해시할 수도 있어요.
일정한 시간으로.

1418
00:59:19,699 --> 00:59:21,949
이것은 일종의 가정입니다.
우리는 이 입력 데이터를 가지고 무엇을 할까요?

1419
00:59:21,949 --> 00:59:23,149
이것들은 선입니다.

1420
00:59:23,150 --> 00:59:26,059
그리고 저는 그렇지 않아요
길이를 제한했습니다.

1421
00:59:26,059 --> 00:59:29,690
그러니 당신은 아마 그렇지 않을 겁니다.
걱정할 만한 일이죠.

1422
00:59:29,690 --> 00:59:33,110
이름을 삭제해도 괜찮습니다.

1423
00:59:33,110 --> 00:59:35,720
그래서 저는 이미
나는 필요하다고 느껴요

1424
00:59:35,719 --> 00:59:39,230
찾을 수 있도록
사물을 이름으로 부른다.

1425
00:59:39,230 --> 00:59:40,400
좋은.

1426
00:59:40,400 --> 00:59:43,220
그런 다음 심으세요.
다음 차례입니다.

1427
00:59:43,219 --> 00:59:44,609
이해가 되시나요?

1428
00:59:44,610 --> 00:59:47,360
그렇다면 그 항목들은 무엇일까요?
제가 여기서 도움이 필요한가요?  안에

1429
00:59:47,360 --> 00:59:49,849
제겐 사람들이 있어요.  안에

1430
00:59:49,849 --> 00:59:53,089
그들에게는 이름이 있습니다.
그런 곳들이 있습니다.

1431
00:59:53,090 --> 00:59:55,340
그들이 도착한 시간.

1432
00:59:55,340 --> 00:59:56,555
하지만 내가 시간을 알까?

1433
00:59:59,880 --> 01:00:01,019
아니요,

1434
01:00:01,019 --> 01:00:02,820
그들은 어디에서도 나에게 시간을 내주지 않아.

1435
01:00:02,820 --> 01:00:05,710
이는 입력 데이터에는 적용되지 않습니다.
제 업무를 위해서요.

1436
01:00:05,710 --> 01:00:08,559
그러니까 제가 그런 건 아니에요.
저는 시간 안에 키를 입력할 수 있을 거예요.

1437
01:00:08,559 --> 01:00:09,269
이해가 되시나요?

1438
01:00:09,269 --> 01:00:12,000
얼마나 중요한가요?
때때로요?

1439
01:00:12,000 --> 01:00:12,547
주문하다.

1440
01:00:12,547 --> 01:00:13,880
청중: 그리고 당신에게 이것이 주어졌습니다.

1441
01:00:13,880 --> 01:00:14,505
제이슨 쿠: 네.

1442
01:00:14,505 --> 01:00:17,670
본질적으로, 언제--
저는 주로

1443
01:00:17,670 --> 01:00:20,159
저는 지원하려고 노력합니다.
이 사람들에 대한 일관성이 부족하다.

1444
01:00:20,159 --> 01:00:23,797
앞면과 뒷면이 있습니다.
그리고 가운데에는 사람들이 있습니다.

1445
01:00:23,797 --> 01:00:25,880
그리고 저는 확실히 알고 싶습니다.
순서가 그대로 유지된다는 것입니다.

1446
01:00:25,880 --> 01:00:27,880
그렇지 않으면 사람들
그는 나에게 화를 낼 것이다.

1447
01:00:27,880 --> 01:00:31,390
네, 그들이 여기로 왔으니까요.
내 뒤에 있었는데, 내가...

1448
01:00:31,389 --> 01:00:32,969
예.

1449
01:00:32,969 --> 01:00:34,719
당신도 이런 상황에 처해 있었죠.

1450
01:00:34,719 --> 01:00:35,279
좋은.

1451
01:00:35,280 --> 01:00:38,220
그래서 저희는 지원하려고 노력합니다.
특정 순서,

1452
01:00:38,219 --> 01:00:41,549
외부 주문
이러한 것들에 있어서.

1453
01:00:41,550 --> 01:00:44,250
하지만 우리에게는 또한 필요합니다
사람들을 검색할 수 있습니다

1454
01:00:44,250 --> 01:00:47,639
그들의 이름으로 부르고 싶어서요.
이것을 바꾸세요.

1455
01:00:47,639 --> 01:00:51,000
어쩌면 이 이야기가 낯설지 않을지도 모릅니다.
우리가 겪었던 다른 문제 때문에

1456
01:00:51,000 --> 01:00:54,989
이번 학기 문제 풀이 과제는 어떤가요?

1457
01:00:54,989 --> 01:00:58,599
네, 그렇게 생각해요.
문제가 있었는데…

1458
01:00:58,599 --> 01:00:59,639
대상: 채팅.

1459
01:00:59,639 --> 01:01:00,900
제이슨 쿠: 채팅.

1460
01:01:00,900 --> 01:01:03,090
일관성을 유지해야 했습니다.

1461
01:01:03,090 --> 01:01:06,120
하지만 당신에게는 이 사전도 있었잖아요.
찾아야 했던 것이죠.

1462
01:01:06,119 --> 01:01:11,670
좋은 것
이러한 상황에서

1463
01:01:11,670 --> 01:01:14,940
그런 것들인가요?
당신이 주의를 기울여야 했던 것,

1464
01:01:14,940 --> 01:01:16,530
정적이었다.

1465
01:01:16,530 --> 01:01:18,870
그럼 제가 할 수 있는 일은 무엇일까요?
사전에서 사용하세요.

1466
01:01:18,869 --> 01:01:22,319
이 경우 제 데이터 세트 구조는 어떻게 되나요?

1467
01:01:22,320 --> 01:01:25,289
혹시 기억하는 사람 있나요?

1468
01:01:25,289 --> 01:01:26,969
간단히 사용하시면 됩니다
정렬된 배열.

1469
01:01:26,969 --> 01:01:28,769
그 때문에
정적인 것들, 이런 것들

1470
01:01:28,769 --> 01:01:32,009
항상 업데이트되는 것은 아닙니다.
그래서 저한테는 좋았어요.

1471
01:01:32,010 --> 01:01:34,290
정적 배열을 사용하면 됩니다.

1472
01:01:34,289 --> 01:01:39,449
여기... 그리고 우리는 제공했습니다
당신은 시간을 검색합니다.

1473
01:01:39,449 --> 01:01:41,609
최악의 경우 로그 함수적이었다.

1474
01:01:41,610 --> 01:01:43,200
제발, 여기 좀 봐주세요.
일정한 시간.

1475
01:01:45,599 --> 01:01:47,099
정렬된 배열이 아닙니다
자르려고요,

1476
01:01:47,099 --> 01:01:49,637
AVL 세트가 조립되지 않았습니다.
잘라냈으니, 이제 뭘 써야 하지?

1477
01:01:49,637 --> 01:01:50,429
청중: 역동적--

1478
01:01:50,429 --> 01:01:52,649
제이슨 쿠: 역동적
배열 또는 해시 테이블.

1479
01:01:52,650 --> 01:01:55,980
하지만 동적 배열은 그렇지 않을 수도 있습니다.
좋아요, 왜냐하면 저는 사실 그렇지 않거든요.

1480
01:01:55,980 --> 01:01:58,590
저는 수치적 제한이 있습니다.
이 열쇠들의 크기는,

1481
01:01:58,590 --> 01:02:01,260
난 그냥 그걸 알아.
그것들은 단어에 잘 어울린다.

1482
01:02:01,260 --> 01:02:03,900
그래서 저는 실제로 만들 수 없어요.
직접 접근 배열,

1483
01:02:03,900 --> 01:02:05,125
왜냐하면 이 단어들은-

1484
01:02:05,125 --> 01:02:07,000
비록 그들이 잘 어울리긴 하지만
일정한 단어 수,

1485
01:02:07,000 --> 01:02:09,389
나는 그것이 무엇인지 모르겠다
그들의 전체 프레젠테이션

1486
01:02:09,389 --> 01:02:11,819
다항식입니다.

1487
01:02:11,820 --> 01:02:13,200
이해가 되시나요?

1488
01:02:13,199 --> 01:02:16,042
그래서 저는 사용하고 싶습니다.
이 경우에는 해싱입니다.

1489
01:02:16,043 --> 01:02:17,460
그렇다면 나는 무엇일까요?
후원하고 싶으신가요?

1490
01:02:17,460 --> 01:02:30,179
저는 지지하고 싶습니다
클라이언트를 위한 순차 데이터 구조.

1491
01:02:30,179 --> 01:02:31,619
고객들.  또는

1492
01:02:31,619 --> 01:02:33,059
U가 어딘가에 있나요?

1493
01:02:33,059 --> 01:02:33,559
아니요.

1494
01:02:33,559 --> 01:02:34,619
그렇죠, 그렇죠?

1495
01:02:34,619 --> 01:02:35,119
좋은.

1496
01:02:35,119 --> 01:02:41,170
그리고 디스플레이 설정이 완료되었습니다.

1497
01:02:41,170 --> 01:02:42,780
저는 보통 이렇게 합니다.

1498
01:02:42,780 --> 01:02:46,380
마치 내가 그렇게 말하고 싶은 것처럼
세트가 어떤 것에 고정되어 있다.

1499
01:02:46,380 --> 01:02:49,019
세트라면,
그럼 저는 열쇠만 가지고 있어요.

1500
01:02:49,019 --> 01:02:51,150
제가 확인해 보겠습니다.
저것은 거기에 있나요, 없나요?

1501
01:02:51,150 --> 01:02:55,139
하지만 내가 정말로
나는 이것을 다른 것에 비추어 본다.

1502
01:02:55,139 --> 01:03:00,119
제가 말씀드리자면, 키와 스페이스를 일치시키세요.
다른 무언가에게, 보통은 ~에게

1503
01:03:00,119 --> 01:03:02,009
내가 가진 요소
나는 계속 가지고 있거나, 아니면 아마도

1504
01:03:02,010 --> 01:03:04,380
일부 재산
내가 간직하고 있는 물건들.

1505
01:03:04,380 --> 01:03:05,619
이해가 되시나요?

1506
01:03:05,619 --> 01:03:06,119
좋은.

1507
01:03:06,119 --> 01:03:09,139
그렇다면, 제가 여기서 매핑하는 것은 무엇일까요?

1508
01:03:09,139 --> 01:03:09,639
이름들.

1509
01:03:13,380 --> 01:03:15,347
아... 그래서.

1510
01:03:15,347 --> 01:03:16,320
무엇 때문에?

1511
01:03:16,320 --> 01:03:18,438
지도를 만들고 싶나요?

1512
01:03:18,438 --> 01:03:20,557
청중: 그때까지...

1513
01:03:20,557 --> 01:03:21,349
제이슨 쿠: 시간.

1514
01:03:21,349 --> 01:03:23,690
그들이 들어온 시간.

1515
01:03:23,690 --> 01:03:24,921
내가 이걸 하고 싶은 걸까?

1516
01:03:24,920 --> 01:03:27,349
청중: 글쎄요, 그럴 순 없죠.
그 시간을 정확히 지키면서 하기 위해

1517
01:03:27,349 --> 01:03:29,516
그들이 소개했지만,
고객 순서

1518
01:03:29,516 --> 01:03:30,894
다음에 표시될 내용을 보여줍니다.

1519
01:03:30,894 --> 01:03:31,519
제이슨 쿠: 네.

1520
01:03:31,519 --> 01:03:35,570
저는 그것을 지금 있는 자리에 그대로 두고 싶어요.
그렇습니다, 이 순서대로입니다.

1521
01:03:35,570 --> 01:03:38,450
그래서 저는 색인만 남겨두겠습니다.
순서대로라면,

1522
01:03:38,449 --> 01:03:39,619
그럼 제가 직접 찾아보면 되죠.

1523
01:03:39,619 --> 01:03:43,176
그거 맞는 말 같죠?

1524
01:03:43,177 --> 01:03:43,760
이것이 바로…

1525
01:03:43,760 --> 01:03:45,560
청중: 저는 그렇게 생각했어요.
지수가 변합니다.

1526
01:03:45,559 --> 01:03:46,184
제이슨 쿠: 네.

1527
01:03:46,184 --> 01:03:48,380
지수는 매번 바뀝니다.
저는 항목을 추가하거나 삭제합니다.

1528
01:03:48,380 --> 01:03:49,550
청중: [알아들을 수 없음]

1529
01:03:49,550 --> 01:03:50,390
제이슨 쿠: 아, 네.

1530
01:03:50,389 --> 01:03:53,269
색인을 유지하세요.

1531
01:03:53,269 --> 01:04:00,739
순서에서 위치를 지정하는 포인터입니다.

1532
01:04:00,739 --> 01:04:04,519
그것
좀 이상하게 들릴 수도 있지만,

1533
01:04:04,519 --> 01:04:09,500
내가 방법을 알려주지 않았으니까
저는 이 순서를 발표했습니다.

1534
01:04:09,500 --> 01:04:13,788
하지만 개념적으로는 가능합니다
제가 포인터를 그린다고 가정해 봅시다.

1535
01:04:13,788 --> 01:04:15,469
어떤 곳으로
이것은 다음을 나타냅니다.

1536
01:04:15,469 --> 01:04:19,699
어디에 있는지 알아볼게요.
자세한 내용은 추후에 알려드리겠습니다.

1537
01:04:19,699 --> 01:04:22,579
하지만 일반적으로 저는 그렇게 부릅니다.
연관된 데이터 구조,

1538
01:04:22,579 --> 01:04:26,779
제가 묶고 있기 때문입니다
두 가지 데이터 구조,

1539
01:04:26,779 --> 01:04:30,380
예를 들어, 한 곳에서 쿼리를 실행할 수 있도록 말입니다.
그리고 그것이 어디에 있는지 알아내세요.

1540
01:04:30,380 --> 01:04:31,970
그리고 다른 곳에서는요.

1541
01:04:31,969 --> 01:04:36,139
또는 요청하십시오
또 다른 비슷한 것.

1542
01:04:36,139 --> 01:04:39,989
모두가 이해하는 것 같네요.
나는 왜 이런 것들을 선택했을까?

1543
01:04:39,989 --> 01:04:41,239
저는 이 문제에 어떻게 접근했을까요?

1544
01:04:41,239 --> 01:04:42,019
예?

1545
01:04:42,019 --> 01:04:46,429
청중: 저는 방법을 모르겠어요.
포인터가 문제를 해결합니다

1546
01:04:46,429 --> 01:04:49,819
간단한 인덱스 저장.

1547
01:04:49,820 --> 01:04:53,880
그곳
그 사람은 순서대로 있는 사람입니다.

1548
01:04:53,880 --> 01:04:55,260
시간이 지나면서 변할 것입니다.

1549
01:04:55,260 --> 01:04:55,560
제이슨 쿠: 음음음.

1550
01:04:55,559 --> 01:04:57,851
청중: -- 다음과 같이 가정합니다
포인터가 업데이트되었습니다.

1551
01:04:57,851 --> 01:04:58,569
바뀔까요?

1552
01:04:58,570 --> 01:04:59,340
제이슨 쿠: 음... 알겠습니다.

1553
01:04:59,340 --> 01:05:03,850
매번 그렇다고 가정해 봅시다...

1554
01:05:03,849 --> 01:05:05,190
내가 계속...

1555
01:05:05,190 --> 01:05:07,409
내가 이걸 계속 가지고 있다고 가정해 보자.
연결 리스트의 순서,

1556
01:05:07,409 --> 01:05:09,119
예를 들어,
왜냐하면 저는 제가 필요한 게 뭔지 알고 있으니까요.

1557
01:05:09,119 --> 01:05:11,161
해야 할 것이다
항목을 삽입하고 삭제합니다.

1558
01:05:11,161 --> 01:05:12,859
이 일의 중간부터.

1559
01:05:12,860 --> 01:05:13,840
이해가 되시나요?

1560
01:05:13,840 --> 01:05:14,340
좋은

1561
01:05:14,340 --> 01:05:16,920
그러므로 나는 가겠습니다
이어서 이렇게 말하세요

1562
01:05:16,920 --> 01:05:19,050
연결 리스트가 생성될 것입니다.

1563
01:05:19,050 --> 01:05:21,163
이제 제겐 연결된 리스트가 생겼습니다.

1564
01:05:24,929 --> 01:05:30,899
그래서 제가 "알겠습니다"라고 말하면,
내 집합의 데이터 구조를 설정합니다.

1565
01:05:30,900 --> 01:05:32,519
저장된--

1566
01:05:32,519 --> 01:05:36,271
또는 저장된 위치
연결 리스트에서,

1567
01:05:36,271 --> 01:05:41,980
저장되었다고 가정해 봅시다.
k로 입력하면 되는 거죠?

1568
01:05:41,980 --> 01:05:43,619
가파르게

1569
01:05:43,619 --> 01:05:51,750
자, 만약 내가 이 남자를 감옥에 가둔다면,
나는 그를 그의 테이블에 앉히겠습니다.

1570
01:05:51,750 --> 01:05:54,179
모든 지표가 변경되었습니다.

1571
01:05:54,179 --> 01:05:57,869
그래서 업데이트하자면
이 집합 데이터 구조에 저장된 인덱스

1572
01:05:57,869 --> 01:06:00,545
저는 바꿔야 해요
그들 각각.

1573
01:06:00,545 --> 01:06:01,170
청중: 네.

1574
01:06:01,170 --> 01:06:02,099
제이슨 쿠: 이해가 되시나요?

1575
01:06:02,099 --> 01:06:04,000
청중: 네, 아니요, 그렇습니다.
훨씬 더 말이 되네요.

1576
01:06:04,000 --> 01:06:04,625
제이슨 쿠: 네.

1577
01:06:04,625 --> 01:06:07,288
그래서 제가 정말로 원하는 건
여기에 저장할 값은 숫자가 아닙니다.

1578
01:06:07,288 --> 01:06:09,329
그리고 실제 지수
노드로

1579
01:06:09,329 --> 01:06:12,538
이것을 포함하고 있습니다.
노드 때문에

1580
01:06:12,538 --> 01:06:16,380
이것이 변하더라도 변하지 않습니다
그 항목은 내 데이터 구조에서 사라지지 않았습니다.

1581
01:06:16,380 --> 01:06:20,340
노드, 이 주소
메모리에 있는 것들, 노드란...

1582
01:06:20,340 --> 01:06:22,500
작은
컨테이너

1583
01:06:22,500 --> 01:06:25,110
요소와 다음
포인터, 그리고 사실 우리는

1584
01:06:25,110 --> 01:06:28,900
여기에는 사전 지표가 필요할 것입니다.

1585
01:06:28,900 --> 01:06:31,800
우리는 필요할 것입니다
이중 목록.

1586
01:06:31,800 --> 01:06:34,440
우리가 하려는 일은
무언가를 삭제할 때 해야 할 일은 무엇일까요?

1587
01:06:34,440 --> 01:06:36,750
우리는 바느질을 해야 해요
이것이 돌아왔습니다

1588
01:06:36,750 --> 01:06:38,820
일정한 시간 동안,
그리고 이것은 우리가 반드시

1589
01:06:38,820 --> 01:06:42,720
무엇을 해야 할지 알기 위해
우리 자신과 우리 뒤에 있는 것들.

1590
01:06:42,719 --> 01:06:43,394
예?

1591
01:06:43,394 --> 01:06:44,469
아니요?

1592
01:06:44,469 --> 01:06:44,969
좋은

1593
01:06:44,969 --> 01:06:47,230
연결 리스트는 여기에 있습니다.

1594
01:06:47,230 --> 01:06:49,500
우리는 이미 이에 대해 이야기했습니다.
해시 테이블을 사용합니다.

1595
01:06:54,029 --> 01:06:56,850
네, 좋습니다.

1596
01:06:56,849 --> 01:07:00,690
이것
간단히 말해두겠습니다.

1597
01:07:00,690 --> 01:07:03,500
이것이 제 데이터 구조입니다.
이것들은 불변량입니다.

1598
01:07:03,500 --> 01:07:04,500
불변량이란 무엇인가요?

1599
01:07:04,500 --> 01:07:07,230
그는 모든 고객을 유지합니다.

1600
01:07:07,230 --> 01:07:08,219
이것은 불변량입니다.

1601
01:07:08,219 --> 01:07:10,859
제 말은, 그다지 좋지 않다는 거죠.
강력한 불변성이지만, 이것은...

1602
01:07:10,860 --> 01:07:13,260
네, 그러니까, 말해야겠어요.

1603
01:07:13,260 --> 01:07:15,090
나는 모두를 곁에 둔다.
고객이 필요하기 때문입니다.

1604
01:07:15,090 --> 01:07:17,730
확실히 하기 위해,
내가 그것들을 보관할 때

1605
01:07:17,730 --> 01:07:19,769
요청을 보내고 있습니다.

1606
01:07:19,769 --> 01:07:24,449
그런 다음 여기에 설치하세요.
포인터 표시 이름.

1607
01:07:24,449 --> 01:07:26,939
이 물건의 위치.

1608
01:07:26,940 --> 01:07:29,519
그리고 제가 뭔가를 삭제할 때,
저는 확인해야 합니다

1609
01:07:29,519 --> 01:07:31,619
불변량이 변하지 않는다는 것입니다.

1610
01:07:31,619 --> 01:07:33,809
그는 여전히 모든 것을 비교한다.
고객 이름

1611
01:07:33,809 --> 01:07:37,559
내 안에는
이 경우, 해당 노드에서 발생합니다.

1612
01:07:37,559 --> 01:07:39,809
그래서 무언가가 있을 때
나뭇잎이 떨어지니, 난 더 나아졌어.

1613
01:07:39,809 --> 01:07:43,320
둘 다 확실히 하세요
이러한 사항들이 업데이트되었습니다.

1614
01:07:43,320 --> 01:07:44,320
이해가 되시나요?

1615
01:07:44,320 --> 01:07:44,820
좋은.

1616
01:07:44,820 --> 01:07:47,788
그럼 제가 어떻게 지원할 수 있을까요?
이러한 작전들 말인가요?  안에

1617
01:07:47,788 --> 01:07:50,400
저희는 다음과 같은 컬렉션을 보유하고 있습니다.

1618
01:07:50,400 --> 01:07:53,910
조립은 간단합니다
이러한 것들이 없는.

1619
01:07:53,909 --> 01:07:56,009
말처럼 쉽진 않죠.

1620
01:07:56,010 --> 01:07:59,610
나는 빈 링크를 생성합니다
리스트, 이중 연결 리스트

1621
01:07:59,610 --> 01:08:04,079
고객 여러분께,
세트를 만들고 -

1622
01:08:04,079 --> 01:08:07,739
해시 테이블
지금 상황은 아무것도 반영하지 않습니다.

1623
01:08:07,739 --> 01:08:08,429
좋은.

1624
01:08:08,429 --> 01:08:10,409
이것은 컬렉션입니다.

1625
01:08:10,409 --> 01:08:13,079
정확하게 말씀드리겠습니다.
여기에서 그리고 사실

1626
01:08:13,079 --> 01:08:18,868
무언가를 적어두다,
내가 그러지 말라고 했잖아

1627
01:08:18,868 --> 01:08:21,510
무시하다
운영, 그렇지 않으면 저희는

1628
01:08:21,510 --> 01:08:23,850
그건 점수를 드릴 수 없어요.

1629
01:08:23,850 --> 01:08:24,957
다음은... 맞죠?

1630
01:08:24,957 --> 01:08:27,374
대상: 청소...
빈 연결 리스트를 생성하는 중...

1631
01:08:27,372 --> 01:08:28,108
제이슨 쿠: 음음.

1632
01:08:28,109 --> 01:08:30,460
청중: --간단해요
머리와 꼬리,

1633
01:08:30,460 --> 01:08:32,652
사실 그들은 존재하지 않습니다.
하지만, 분명히 존재한다고 하네요?

1634
01:08:32,652 --> 01:08:33,568
제이슨 쿠: 네, 맞습니다.

1635
01:08:33,568 --> 01:08:35,880
이것은 ~에 관한 것입니다.
우리가 간직하는 기억.

1636
01:08:35,880 --> 01:08:38,500
그것은 ~을 가리키는 포인터를 가지고 있습니다.
머리와 꼬리.

1637
01:08:38,500 --> 01:08:40,140
지금은 아무도 없습니다.

1638
01:08:40,140 --> 01:08:42,630
하지만 우리는 거기에 무언가를 덧붙일 것입니다.

1639
01:08:42,630 --> 01:08:43,380
좋은.

1640
01:08:43,380 --> 01:08:45,868
두 번째로, 제목을 추가하세요.

1641
01:08:50,908 --> 01:08:52,170
뭐라고 말해야 할까요?

1642
01:08:52,170 --> 01:08:54,059
이것을 업데이트해야 합니다
데이터 구조는 다음과 같습니다.

1643
01:08:54,059 --> 01:08:56,580
분산을 유지했습니다.

1644
01:08:56,578 --> 01:09:00,778
저는 필요해요 - 보통은
그중 하나부터 시작할게요.

1645
01:09:00,779 --> 01:09:03,300
나는 이제 그 지점에 도달했다
아, 정말,

1646
01:09:03,300 --> 01:09:05,850
~했어야 했다
다른 하나를 먼저 업데이트하세요.

1647
01:09:05,850 --> 01:09:07,559
그래서 때로는 잘 될 때도 있고 안 될 때도 있죠.

1648
01:09:07,559 --> 01:09:08,720
나는 여기서 무엇을 하고 싶은가?

1649
01:09:08,720 --> 01:09:12,930
글쎄요, 어디인지는 모르겠어요.
이 순서대로입니다.

1650
01:09:12,930 --> 01:09:16,470
제 생각에는 그런 것 같습니다.
먼저 여기에 도착해야 해요.

1651
01:09:16,470 --> 01:09:17,760
아, 죄송합니다.

1652
01:09:17,760 --> 01:09:21,238
남자를 추가함으로써, 나는
어떤 방법으로든 할 수 있어요.

1653
01:09:21,238 --> 01:09:23,769
나는 알아... 어디인지
그는 떠날 건가요?

1654
01:09:23,770 --> 01:09:25,420
목록 끝.

1655
01:09:25,420 --> 01:09:27,840
그럼 그냥 저기에 붙여 놓을게요.

1656
01:09:27,840 --> 01:09:36,689
그러므로 수열의 끝에 x를 더하세요.

1657
01:09:36,689 --> 01:09:41,368
그래서 저는 왔습니다
제가 좋아하는 트릭이에요.

1658
01:09:41,368 --> 01:09:43,948
순서, 설정.

1659
01:09:43,948 --> 01:09:44,460
좋은.

1660
01:09:44,460 --> 01:09:46,828
이 경우에는 제가 가진 것은 이것뿐입니다.
하나의 순열과 하나의 세트.

1661
01:09:46,828 --> 01:09:50,386
그러므로 그것들을 순열이라고 부른다
세트는 아마 괜찮을 겁니다.

1662
01:09:50,386 --> 01:09:51,930
저는 안 갈 거예요.
더 혼란스럽게 만들다,

1663
01:09:51,930 --> 01:09:54,480
나는 스스로를 혼란스럽게 만들고 싶지 않아.

1664
01:09:54,479 --> 01:09:56,969
하지만 제가 더 많이 가지게 되면
이것들 중 하나보다,

1665
01:09:56,970 --> 01:10:01,470
혹은 시험에서 간결함을 위해서라도,
시간이 제한되어 있는 상황에서,

1666
01:10:01,470 --> 01:10:03,690
이것들에 이름을 붙여주세요.

1667
01:10:03,689 --> 01:10:08,579
이 순서가 무엇인지 말해 주세요.
C와 M. 잘 모르겠네요.

1668
01:10:08,579 --> 01:10:12,239
여기 고객분이 계시네요.
여기 지도가 보이니 가능할 것 같네요.

1669
01:10:12,239 --> 01:10:13,349
모르겠습니다.

1670
01:10:13,350 --> 01:10:15,720
하지만 그냥 그들에게 주세요
편지, 그러면 우리는

1671
01:10:15,720 --> 01:10:17,970
우리는 당신을 더욱 명확하게 감시할 수 있을 것입니다.
그리고 참고하실 수 있습니다.

1672
01:10:17,970 --> 01:10:19,980
이러한 사항들에 대해 좀 더 구체적으로 말씀드리겠습니다.

1673
01:10:19,979 --> 01:10:25,929
그래서 S의 끝입니다.

1674
01:10:25,930 --> 01:10:27,940
그렇다면 우리는 어떻게 해야 할까요?

1675
01:10:27,939 --> 01:10:30,729
내가 이 사람을 고쳐주고 있어, 잘하고 있어.

1676
01:10:30,729 --> 01:10:32,568
이제 이 녀석을 고쳐야겠어.

1677
01:10:32,568 --> 01:10:37,599
그래서 저는 집합에 x를 추가합니다.
저는 그것을 해당 노드로 되돌려 보내고 있습니다.

1678
01:10:37,600 --> 01:10:39,160
그가 방금 떠나온 곳.

1679
01:10:39,159 --> 01:10:41,559
이것을 저장할 수 있습니다
임시 변수.

1680
01:10:41,559 --> 01:10:59,030
M에 x를 더하세요.
n 노드 v에서 v로. 좋습니다.

1681
01:10:59,029 --> 01:11:00,489
가파르게?

1682
01:11:00,489 --> 01:11:08,050
그래서 저는 끝에 x를 추가했습니다.
C에서 노드 v로. 저는 마치...

1683
01:11:08,050 --> 01:11:11,409
제가 표시해 둔 이유는 제가 할 수 있도록 하기 위해서입니다.
나중에 다시 참조하세요.

1684
01:11:11,409 --> 01:11:15,609
그리고 코드에서 아마도
나는 그 매듭이 어떤 종류였는지 기억할 것이다.

1685
01:11:15,609 --> 01:11:19,750
M에 x를 더하세요.
이 노드까지,

1686
01:11:19,750 --> 01:11:21,369
이제 저는 저장하겠습니다.
그것의 불변성.

1687
01:11:21,369 --> 01:11:21,880
아주

1688
01:11:21,880 --> 01:11:24,470
관객: 아마도 [잘 안 들림].

1689
01:11:24,470 --> 01:11:28,369
제이슨 쿠: x 키를 추가하세요.

1690
01:11:28,369 --> 01:11:35,359
또는 M에 x를 더하면 다음과 같습니다.
이 노드를 가리키는 키 x입니다.

1691
01:11:35,359 --> 01:11:36,329
이해가 되시나요?

1692
01:11:36,329 --> 01:11:38,750
여기에는 미묘한 차이가 있습니다.

1693
01:11:38,750 --> 01:11:43,100
3 3, 삭제가 있습니다.

1694
01:11:43,100 --> 01:11:45,230
기억이 안 나요.
이름이든 뭐든.

1695
01:11:45,229 --> 01:11:46,759
좋은.

1696
01:11:46,760 --> 01:11:48,590
그래서 우리는 해야 합니다...

1697
01:11:48,590 --> 01:11:49,489
질서가 중요하다.

1698
01:11:49,489 --> 01:11:53,175
나는 그것이 어디에 있는지 몰라요.
순서대로,

1699
01:11:53,175 --> 01:11:54,800
하지만 저는 찾아볼 거예요
이것은 세트에 포함되어 있습니다.

1700
01:11:54,800 --> 01:11:57,920
그리고 저는 갈 거예요
세트에서 제거하세요.

1701
01:11:57,920 --> 01:12:00,170
그리고 저는 모든 것을 시청할 것입니다.
이는 다음을 나타냅니다.

1702
01:12:00,170 --> 01:12:02,180
그리고 순서에서 그것을 제거하세요.

1703
01:12:02,180 --> 01:12:03,930
나
시간이 조금 부족하네요.

1704
01:12:03,930 --> 01:12:05,597
그래서 저는 그러지 않을 거예요
전부 적어두세요.

1705
01:12:05,596 --> 01:12:07,159
여러분, 이해하시죠?
이것은 무슨 뜻인가요?

1706
01:12:07,159 --> 01:12:08,779
여기서 우리는 사용합니다
이것이

1707
01:12:08,779 --> 01:12:12,739
이중 연결 리스트로
우리는 다시 연결될 수 있을 거예요.

1708
01:12:12,739 --> 01:12:16,260
굳이 말씀하실 필요 없어요.
제가 말씀드릴 점은 세 가지입니다.

1709
01:12:16,260 --> 01:12:20,840
내 이전 인덱스
다음 일에서 다음 일로----

1710
01:12:20,840 --> 01:12:21,375
예?

1711
01:12:21,375 --> 01:12:23,000
당신은 ~해서는 안 됩니다
키 바인딩을 다시 설정하는 방법을 알려주세요.

1712
01:12:23,000 --> 01:12:27,109
이러한 지표는 우리가
이미 문제 1에서 이 작업을 했습니다.

1713
01:12:27,109 --> 01:12:27,877
또는 다른 어떤 것.

1714
01:12:27,877 --> 01:12:30,420
청중: 일반적으로, 왜냐하면
당신은 다음과 같은 상황에 처해 있습니다.

1715
01:12:30,420 --> 01:12:32,341
당신은 사용하지 않습니다
이중 목록--

1716
01:12:32,341 --> 01:12:33,049
제이슨 쿠: 음음.

1717
01:12:33,050 --> 01:12:34,039
청중:
연결 리스트만

1718
01:12:34,039 --> 01:12:35,420
~보다 나을 것이다
더블,

1719
01:12:35,420 --> 01:12:37,220
왜냐하면 그는 그렇게 보이기 때문입니다
항상 문제를 해결합니다.

1720
01:12:37,220 --> 01:12:37,845
제이슨 쿠: 네.

1721
01:12:37,845 --> 01:12:40,430
이중 연결 리스트
거의 항상 더 낫다.

1722
01:12:40,430 --> 01:12:42,380
단일 연결보다
이론적인 문제들.

1723
01:12:42,380 --> 01:12:47,539
네, 이걸 사용하세요.

1724
01:12:47,539 --> 01:12:48,680
좋은.

1725
01:12:48,680 --> 01:12:50,420
그리고 마지막으로 그곳.

1726
01:12:55,090 --> 01:12:59,890
그냥 가져가세요.
시퀀스의 앞부분,

1727
01:12:59,890 --> 01:13:03,760
삭제하거나 변경하세요.
제목,

1728
01:13:03,760 --> 01:13:06,880
하지만 저는 당신이
먼저 삭제하셔도 됩니다.

1729
01:13:06,880 --> 01:13:09,350
당신은 다음과 같이 축소되었습니다.
우리가 가지고 있던 인터페이스.

1730
01:13:09,350 --> 01:13:12,490
먼저 삭제하세요
순서대로.

1731
01:13:12,489 --> 01:13:14,869
하지만 지금 우리는 한 가지 상황에 직면해 있습니다.

1732
01:13:14,869 --> 01:13:16,359
첫 번째 사람을 삭제했어요.

1733
01:13:16,359 --> 01:13:19,149
누구인지 알아내는 방법
첫 번째 사람 말인가요?

1734
01:13:19,149 --> 01:13:21,318
네, 제가 간직할게요.
거기에 이름이 적혀 있습니다.

1735
01:13:21,318 --> 01:13:23,179
저는 그 이름들을 보관합니다.
이 고객들.

1736
01:13:23,180 --> 01:13:27,220
그래서 나는 누가 누군지 알아요
앞에서, 저는 이것을 검토하고 있습니다.

1737
01:13:27,220 --> 01:13:29,813
데이터 구조 및
이 항목을 삭제하겠습니다.

1738
01:13:29,813 --> 01:13:30,730
이해가 되시나요?

1739
01:13:30,729 --> 01:13:34,269
이제 더 이상 필요하지 않기 때문입니다.
그가 가는 곳을 응원하기 위해서.

1740
01:13:34,270 --> 01:13:38,500
실제로
저는 도저히 그럴 수 없었어요.

1741
01:13:38,500 --> 01:13:40,789
이 데이터 세트 구조를 업데이트하세요.

1742
01:13:40,789 --> 01:13:43,359
하지만 만약 제가 이렇게 한다면,
음, 제 근무 시간은요.

1743
01:13:43,359 --> 01:13:45,009
시간은 여전히 ​​선형적으로 흐를 것입니다.

1744
01:13:45,010 --> 01:13:46,900
저는 당신을 제한하는 것이 아닙니다.
장소.

1745
01:13:46,899 --> 01:13:50,439
아직 시간 개념이 모호해서 죄송합니다.

1746
01:13:50,439 --> 01:13:53,318
그러니까 당신은 정말로 그렇지 않아요
이 삭제 작업을 해야 합니다.

1747
01:13:53,318 --> 01:13:56,439
하지만 만약 이 고객이
돌아올 것입니다

1748
01:13:56,439 --> 01:14:00,564
다시 대기자 명단에 오르고 싶어합니다.
고려해야 할 사항들이 있습니다.

1749
01:14:03,710 --> 01:14:04,210
좋은.

1750
01:14:04,210 --> 01:14:07,130
그래서, 그게 바로 질문입니다.

1751
01:14:07,130 --> 01:14:11,500
다음 질문은 대략 다음과 같습니다.
10분.

1752
01:14:11,500 --> 01:14:12,789
라니 리서치.

1753
01:14:12,789 --> 01:14:20,260
이것은 문제입니다.
사람들이 악몽을 꾸게 만들었던 것들.

1754
01:14:20,260 --> 01:14:25,329
네, 원칙적으로는 저희는 다음과 같은 것을 가지고 있습니다.
매더 밴이 있습니다.

1755
01:14:25,329 --> 01:14:26,680
그는 기상 예보관입니다.

1756
01:14:26,680 --> 01:14:30,850
연구하는 과학자
전 세계 강수량.

1757
01:14:30,850 --> 01:14:34,450
그리고 그는 가지고 있습니다
곳곳에 센서가 많이 설치되어 있습니다.

1758
01:14:34,449 --> 01:14:37,539
누구나 게시할 수 있습니다.
구름이나 뭐 그런 거

1759
01:14:37,539 --> 01:14:39,909
측정값
삼각형 모양을 하고 있다

1760
01:14:39,909 --> 01:14:43,149
정수 r, l
그리고 t, 여기서 r은

1761
01:14:43,149 --> 01:14:46,689
정수
강수량, 정수;

1762
01:14:46,689 --> 01:14:51,469
위도 역시 정수입니다.
;  그리고 즉시.  여기

1763
01:14:51,470 --> 01:14:53,150
우리는 세 가지를 결정해야 합니다.
.

1764
01:14:53,149 --> 01:14:53,649
부

1765
01:14:56,478 --> 01:14:57,520
하지만 그것들은 모두 정수입니다.

1766
01:14:57,520 --> 01:14:59,830
그리고 이렇게 말하지 마세요,
제이슨,

1767
01:14:59,829 --> 01:15:03,260
위도 범위가 상당히 작습니다.

1768
01:15:03,260 --> 01:15:06,369
그래서 저는 이것들이
정수는 작다.

1769
01:15:06,369 --> 01:15:09,010
그리고 이러한 것들
일정한 시간이 필요합니다.

1770
01:15:09,010 --> 01:15:11,530
나는 표시하지 않는다
당신은 해상도를 가지고 있습니다

1771
01:15:11,529 --> 01:15:13,599
나는 이 정수들을 측정한다.

1772
01:15:13,600 --> 01:15:16,630
그리고 저는 당신에게 아무런 제한도 두지 않았습니다.
해상도 사이

1773
01:15:16,630 --> 01:15:18,789
숫자에 비해
제가 가지고 있는 측정값은 다음과 같습니다.

1774
01:15:18,789 --> 01:15:20,000
그래서 저는 이런 게임을 안 해요.

1775
01:15:20,000 --> 01:15:21,130
좋은.

1776
01:15:21,130 --> 01:15:24,880
최대 강수량
이 위도에서

1777
01:15:24,880 --> 01:15:29,650
어느 시점부터
— 이것은 최대 강수량입니다

1778
01:15:29,649 --> 01:15:33,519
이것에 대한 모든 측정값
당시 측정된 위도

1779
01:15:33,520 --> 01:15:35,820
초과하거나
이 시간과 같습니다.

1780
01:15:35,818 --> 01:15:37,269
이해가 되시나요?

1781
01:15:37,270 --> 01:15:39,940
또는 0인 경우
이 위도에서는 측정값이 없습니다.

1782
01:15:39,939 --> 01:15:40,689
좋은.

1783
01:15:40,689 --> 01:15:44,379
시간이 만료된 후 득점하려면, 또는
세상 끝날까지, 아니면 뭐든 간에.

1784
01:15:44,380 --> 01:15:50,109
우리가 사용하는 데이터베이스에 대해 설명해 주세요.
우리는 끊임없이 창조할 수 있다.

1785
01:15:50,109 --> 01:15:51,099
비어 있습니다.

1786
01:15:51,100 --> 01:15:53,020
제가 추가했어요.
왜냐하면

1787
01:15:53,020 --> 01:15:55,809
우리는 지난 봄에 힘든 시간을 보냈습니다.

1788
01:15:55,809 --> 01:15:57,250
데이터 기록.

1789
01:15:57,250 --> 01:15:58,809
트리플을 드립니다.

1790
01:15:58,809 --> 01:16:02,170
그리고 나서… 데이터를 적어 두세요.
그래서 그것들이 정확하도록,

1791
01:16:02,170 --> 01:16:05,091
난 그걸 저장해야만 해.
이 정보.

1792
01:16:05,091 --> 01:16:07,809
이런 종류의 경우
새로운 소식이 없습니다...

1793
01:16:07,809 --> 01:16:11,470
뭐라고 답하기 정말 어렵네요.
이것이 맞다는 것입니다.

1794
01:16:11,470 --> 01:16:12,670
왜냐하면 저는 그냥...

1795
01:16:12,670 --> 01:16:15,130
이것도 넣어볼게요.
데이터베이스, 데이터베이스

1796
01:16:15,130 --> 01:16:17,890
해서는 안 된다
저는 돌려드릴 것이 없습니다.

1797
01:16:17,890 --> 01:16:20,980
그래서 중요한 것은
정확성에 관하여

1798
01:16:20,979 --> 01:16:24,254
최대 강우량은 다음과 같은 것을 의미합니다.
이것을 내게 주면, 이것은 내게 이런 결과를 가져다준다.

1799
01:16:24,255 --> 01:16:25,880
한정된 기간 동안,
제가 찾고 있는 것입니다.

1800
01:16:25,880 --> 01:16:28,029
그리고 강수량의 최고점
최대 강우량을 기록합니다

1801
01:16:28,029 --> 01:16:31,960
특정에
위도와 t.

1802
01:16:31,960 --> 01:16:33,789
그래서 세 가지가 있습니다.

1803
01:16:33,789 --> 01:16:34,466
예?

1804
01:16:34,466 --> 01:16:35,923
청중: 고려해 볼 때,
당신이 절대

1805
01:16:35,923 --> 01:16:39,289
측정값을 반환할 필요가 없습니다.
[알아들을 수 없는 부분]이 있나요?

1806
01:16:39,289 --> 01:16:40,412
이거 녹음 파일인가요?

1807
01:16:40,412 --> 01:16:42,079
제이슨 쿠:
어쩌면 당신은

1808
01:16:42,079 --> 01:16:44,600
보관할 필요가 없습니다
모든 정보,

1809
01:16:44,600 --> 01:16:46,880
왜냐하면 우리 모든 것
네, 저희가 그렇게 하는 이유는 여러분께 보답하기 위해서입니다.

1810
01:16:46,880 --> 01:16:49,340
아르 자형.

1811
01:16:49,340 --> 01:16:52,670
어쩌면 당신은 전혀 그렇지 않을지도 몰라요.
위도를 유지해야 합니다

1812
01:16:52,670 --> 01:16:54,380
이제 때가 된 걸까요?

1813
01:16:54,380 --> 01:16:56,359
당신은 그럴 필요조차 없습니다
트리플을 유지하세요.

1814
01:16:56,359 --> 01:17:00,979
지금 제가 정말로 묻고 싶은 건 이거예요.
위도와 시간에 관하여.

1815
01:17:00,979 --> 01:17:03,517
그래서 나는 해야 한다
그것들을 어딘가에 보관하기 위해,

1816
01:17:03,518 --> 01:17:05,059
하지만 저는 할 수 있어요
꽉 쥐어주세요.

1817
01:17:05,059 --> 01:17:11,539
특히, 많은 것들이 있을 수 있습니다.
일정한 위도를 유지하세요.

1818
01:17:11,539 --> 01:17:13,609
여기 뭔가 있어요
요청의 핵심 내용입니다.

1819
01:17:13,609 --> 01:17:15,500
그래서 저희는...

1820
01:17:15,500 --> 01:17:18,119
그러니까, 우리는 필요할지도 몰라요.
이 너비 값은 한 번만 저장하세요.

1821
01:17:18,119 --> 01:17:19,559
이해가 되시나요?

1822
01:17:19,559 --> 01:17:20,059
좋은.

1823
01:17:20,059 --> 01:17:21,770
기다리겠습니다.
질문

1824
01:17:21,770 --> 01:17:25,140
끝내고 싶어서
이 문제에 대한 해결책을 찾으세요.

1825
01:17:25,140 --> 01:17:25,640
좋은

1826
01:17:25,640 --> 01:17:28,030
그렇다면 우리가 해야 할 일은 무엇일까요?

1827
01:17:28,029 --> 01:17:29,869
우리는 할 수 있어야 합니다
무언가를 추가하다

1828
01:17:29,869 --> 01:17:31,109
그리고 저는 돌아오고 싶어요.

1829
01:17:31,109 --> 01:17:34,125
그러니 돌아와 줘, 필요할 거야.
무언가를 묻기 위해,

1830
01:17:34,125 --> 01:17:35,750
그리고 나서 나는
저는 무언가를 돌려드리겠습니다.

1831
01:17:35,750 --> 01:17:40,827
그러므로 강수량의 최고점을 다음과 같이 설정하십시오.
시간 t에서 위도 l.

1832
01:17:40,827 --> 01:17:42,620
제가 관심 있는 것은 무엇인가요?
특정 쿼리에서요?

1833
01:17:42,619 --> 01:17:48,859
저는 모든 사람에게만 관심이 있어요.
l에 있는 것들, 즉 위도 l에 있는 것들.

1834
01:17:48,859 --> 01:17:52,699
그러니까 사실은 그렇지 않다는 거죠.
정말 흥미로운 일이네요.

1835
01:17:52,699 --> 01:17:55,849
하지만 저는 가질 수 있기를 원해요.
여러 데이터 구조를 한 번에 하나씩 처리할 수 있습니다.

1836
01:17:55,850 --> 01:17:59,120
각 L과 연관되어 있습니다.
이해가 되시나요?

1837
01:17:59,119 --> 01:18:05,210
그럼 제가 어떻게 할 수 있을까요?
L에서 하나씩 빨리 찾을 수 있을까요?

1838
01:18:05,210 --> 01:18:06,210
이것을 사전에 쓰세요.

1839
01:18:06,210 --> 01:18:07,369
제 제한 시간은 얼마나 되나요?

1840
01:18:07,369 --> 01:18:08,648
최악의 경우 로그 n.

1841
01:18:08,648 --> 01:18:11,429
그렇다면 어떤 데이터 구조를 사용해야 할까요?
이 데이터 구조 집합에 대해서는 어떻게 생각하시나요?

1842
01:18:11,430 --> 01:18:12,710
AVL 세트.

1843
01:18:12,710 --> 01:18:17,180
그래서, 당신은
먼저 AVL 세트가 필요합니다.

1844
01:18:20,840 --> 01:18:33,500
L이라고 가정해 봅시다. 위도를 매핑하는 것은...

1845
01:18:33,500 --> 01:18:36,903
좋아요, 이제 우리는
더 많은 데이터 구조.

1846
01:18:36,903 --> 01:18:38,570
많이 저축하고 싶어요
그 물건들

1847
01:18:38,568 --> 01:18:41,710
같은 위도를 가지고 있다.
다른 데이터 구조에서.

1848
01:18:41,710 --> 01:18:45,230
아마 그럴 겁니다.
시간을 맞춰라

1849
01:18:45,229 --> 01:18:47,339
강수량에서
이 모든 측정값들.

1850
01:18:47,340 --> 01:18:49,510
예?

1851
01:18:49,510 --> 01:18:50,122
예

1852
01:18:50,122 --> 01:18:51,079
대상: 해시 테이블.

1853
01:18:51,079 --> 01:18:52,037
제이슨 쿠: 해시 테이블.

1854
01:18:52,037 --> 01:18:53,809
좋아요, 어떤 종류인가요?
나는 물었다

1855
01:18:53,809 --> 01:18:57,030
일을 위해 무엇을 할 것인가
같은 위도에 있나요?

1856
01:18:57,029 --> 01:18:59,029
청중: 당신
당신은 시간을 얻고 싶어합니다.

1857
01:18:59,029 --> 01:19:00,904
제이슨 쿠: 나
나는 시간을 알고 싶어요.

1858
01:19:00,904 --> 01:19:04,519
하지만 그보다 더 중요한 것은, 저는 그렇게 합니다.
정렬된 쿼리.

1859
01:19:04,520 --> 01:19:08,300
나는 물건이 덜 필요해.
특정 시간.

1860
01:19:08,300 --> 01:19:09,077
죄송합니다.

1861
01:19:09,077 --> 01:19:10,159
청중: 그래서, 이건 정말...

1862
01:19:10,159 --> 01:19:11,300
제이슨 쿠: 잠깐만요.

1863
01:19:11,300 --> 01:19:13,259
청중: 당신은 할 수 있어요
AVL 시간

1864
01:19:13,260 --> 01:19:15,059
그리고 비가 올 경우 AVL은 어떻게 되나요?

1865
01:19:15,059 --> 01:19:15,620
제이슨 쿠: 알겠습니다.

1866
01:19:15,619 --> 01:19:18,289
나에게 중요한 것
비가 올 경우 AVL은 어떻게 되나요?

1867
01:19:18,289 --> 01:19:22,347
그러니까, 보는 것에 대해서 말하자면...
비가 내리는 가운데.

1868
01:19:22,347 --> 01:19:22,890
청중: 없음.

1869
01:19:22,890 --> 01:19:23,862
제이슨 구: 아니요.

1870
01:19:23,862 --> 01:19:25,818
그럼 계속하겠습니다.
그리고 이것들을 간직하세요

1871
01:19:25,818 --> 01:19:37,369
AVL을 시간순으로 정렬하면
위도 l을 표시합니다...

1872
01:19:37,369 --> 01:19:39,859
나는 이것을 이렇게 부를 것이다.
데이터 구조 시간 데이터 구조

1873
01:19:39,859 --> 01:19:40,519
.

1874
01:19:40,520 --> 01:19:43,430
제 생각엔 t에 l이 들어간 철자일 것 같아요.

1875
01:19:43,430 --> 01:19:44,990
이것은
재발로서,

1876
01:19:44,989 --> 01:19:46,279
~ 전에
이게 지금 좀 거슬리네요.

1877
01:19:46,279 --> 01:19:47,590
하지만 저는 가지고 있지 않아요
이보다 더 좋을 순 없어.

1878
01:19:47,590 --> 01:19:48,090
좋은

1879
01:19:48,090 --> 01:19:51,680
그래서 이제 이들 각각
시간 데이터 구조

1880
01:19:51,680 --> 01:20:08,840
구성된 AVL 표시 시간입니다.
강우량을 측정하기 위해.

1881
01:20:08,840 --> 01:20:10,159
좋은

1882
01:20:10,159 --> 01:20:11,449
그래서 이것은...

1883
01:20:11,449 --> 01:20:15,059
제 요청이 '반환'이었다면,
최대 강우량...

1884
01:20:15,059 --> 01:20:15,559
죄송합니다.

1885
01:20:15,559 --> 01:20:22,820
강수량을 반환하세요
위도 l과 시간 t를 사용하여,

1886
01:20:22,818 --> 01:20:24,349
우리는 끝장날 것이다.

1887
01:20:24,350 --> 01:20:27,500
당신은 어떻게 하는지 알 것입니다
이 요청을 지지합니다.

1888
01:20:27,500 --> 01:20:29,270
물건을 넣으려면,
저는 물건들을 넣고 있어요.

1889
01:20:29,270 --> 01:20:32,450
두 데이터 구조 모두에
저는 그저 그것들을 찾고 있을 뿐입니다.

1890
01:20:32,449 --> 01:20:34,880
유일한 어려움
제가 그렇지 않다는 건 아닙니다.

1891
01:20:34,880 --> 01:20:39,739
나는 숫자가 무엇인지 물었다.
특정 시점의 강수량.

1892
01:20:39,739 --> 01:20:44,179
최댓값이 얼마인지 알고 싶습니다.
지금까지 내린 비.

1893
01:20:44,180 --> 01:20:45,200
좋은.

1894
01:20:45,199 --> 01:20:49,039
그래서, 만약 내가 최대 힙을 사용한다면 좋은 선택입니다.
저는 전역 최댓값을 알고 싶습니다.

1895
01:20:49,039 --> 01:20:54,199
하지만 여기서 제가 알고 싶은 건...
최대값은 특정 범위로 제한됩니다.

1896
01:20:54,199 --> 01:20:56,179
그래서 우리는--

1897
01:20:56,180 --> 01:20:57,860
장담할 수 있어
그 다음 질문은,

1898
01:20:57,859 --> 01:21:00,349
우리를
시간이 얼마 남지 않았습니다.

1899
01:21:00,350 --> 01:21:03,809
그래서, 혹시 어떻게 해야 할지 아시는 분 계신가요...?

1900
01:21:03,809 --> 01:21:04,309
예?

1901
01:21:04,309 --> 01:21:06,722
청중: 잠깐만요
최대값을 사용하여 AVL을 증가시키시겠습니까?

1902
01:21:06,722 --> 01:21:07,265
제이슨 쿠: 알겠습니다.

1903
01:21:07,265 --> 01:21:08,710
청중: 그리고 당신은 그냥
오른쪽 아이를 보세요.

1904
01:21:08,710 --> 01:21:10,699
그리고 나서 살펴보세요
현재 최대치인가요?

1905
01:21:10,699 --> 01:21:11,407
제이슨 쿠: 아, 알겠습니다.

1906
01:21:11,407 --> 01:21:12,920
그래서, 뭐
당신의 동료가 말합니다,

1907
01:21:12,920 --> 01:21:18,109
우리가 증가시킨다면
내 서브트리에서 최대 r,

1908
01:21:18,109 --> 01:21:21,799
어쩌면 우리는 이것을 사용할 수 있을지도 모릅니다.
이 쿼리를 정의하세요.

1909
01:21:21,800 --> 01:21:24,409
우리는 조직적이기 때문입니다
t의 경우, 우리는

1910
01:21:24,409 --> 01:21:28,189
우리는 너무나 아름답고 단조로운 것을 가지고 있다
모든 것을 포함하는 속성

1911
01:21:28,189 --> 01:21:30,979
제 문의 사항에 포함될 것입니다.

1912
01:21:30,979 --> 01:21:35,209
오른쪽에 모두
어느 시점부터-

1913
01:21:35,210 --> 01:21:41,699
내 시간이 t보다 높으면
특정 노드에서,

1914
01:21:41,699 --> 01:21:43,260
모든 것에서
오른쪽 서브트리

1915
01:21:43,260 --> 01:21:48,869
또한 이 위에도 t
내 데이터셋의 데이터 구조 순서 때문에

1916
01:21:48,869 --> 01:21:51,689
, 왜냐하면
저는 시간 순서대로 정리하는 편입니다.

1917
01:21:51,689 --> 01:21:54,239
어쩌면 그럴지도 모르죠.
내가 만약 그럴 확률

1918
01:21:54,239 --> 01:21:56,519
오른쪽을 보겠습니다.
하위 트리, 나는 할 수 없어

1919
01:21:56,520 --> 01:21:59,910
모든 일을 하기 위해
여기, 그냥 보고 있어요.

1920
01:21:59,909 --> 01:22:01,979
이 하위 트리의 최대값입니다.

1921
01:22:01,979 --> 01:22:15,000
이것이 바로 아이디어입니다.
예를 들어, 서브트리 최대 r로 보완됩니다.

1922
01:22:15,000 --> 01:22:17,289
어쩌면 당신은
이것에도 이름을 붙여주는 것이 좋을 거예요.

1923
01:22:17,289 --> 01:22:24,840
예를 들어, v max는 v —
이건 내 물건에 엉킨 매듭이야.

1924
01:22:24,840 --> 01:22:28,529
그리고 제가 그 방법을 보여드리겠습니다.
이것이 지원인가요? 어떻게 계산할 수 있나요?

1925
01:22:28,529 --> 01:22:29,979
이것은 그의 후손들을 위한 것입니다.

1926
01:22:29,979 --> 01:22:33,689
그렇다면 제가 실제로 어떻게 할 수 있을까요?
이 요청을 지지해 주세요.

1927
01:22:33,689 --> 01:22:37,379
나는 그것을 재귀적으로 생각할 수 있다.  안에

1928
01:22:37,380 --> 01:22:39,400
제게는 몇 가지 사건이 있습니다.

1929
01:22:39,398 --> 01:22:44,189
내가 v에 있다면, 나는 원한다
재귀 함수를 정의하세요.

1930
01:22:44,189 --> 01:22:52,199
이를 최대 강우량이라고 합니다.
이 노드에서 아래쪽

1931
01:22:52,199 --> 01:22:52,769
제한된 t.

1932
01:22:55,920 --> 01:22:59,190
그러니까, 제가 여기 있다면,
두 가지 경우가 있습니다.

1933
01:22:59,189 --> 01:23:03,884
또는 내 시간, 내 시간이 더 길다
또는 그보다 작은 크기는 제 예산 범위 내에 있습니다.

1934
01:23:03,885 --> 01:23:06,690
또는 내 능력 범위를 벗어납니다.

1935
01:23:06,689 --> 01:23:08,849
제 능력 밖의 일이라면
범위 내에서 어떻게 해야 할까요?

1936
01:23:08,850 --> 01:23:12,120
제 제한된 시간보다 부족합니다.

1937
01:23:12,119 --> 01:23:16,140
재귀적으로 호출하면 됩니다.
이 노드의 이 함수입니다.

1938
01:23:16,140 --> 01:23:19,289
나는 여기에 무엇이 있는지 알고 있기 때문이다.
모든 게 괜찮을 거예요

1939
01:23:19,289 --> 01:23:23,460
무엇이 나를 걱정하게 하는가?

1940
01:23:23,460 --> 01:23:26,398
그리고 이건 단지 하나일 뿐입니다.
트리를 통한 재귀 호출.

1941
01:23:26,398 --> 01:23:29,489
그래서 만약 제가 단지 ~에만 국한한다면
하나의 재귀 호출로

1942
01:23:29,489 --> 01:23:32,489
나무, 나는 항상
나는 매번 넘어져.

1943
01:23:32,489 --> 01:23:34,920
이것은 시간이 걸릴 것입니다
로그 시간.

1944
01:23:34,920 --> 01:23:37,739
자, 이것이 첫 번째 사례입니다.
이건 쉬운 사건입니다.

1945
01:23:37,739 --> 01:23:41,219
이건 사정거리 밖이야, 나
재귀적으로 어떤 것을 반환하다

1946
01:23:41,220 --> 01:23:42,132
오른쪽.

1947
01:23:42,132 --> 01:23:43,050
다른 사례는 무엇이 있나요?

1948
01:23:43,050 --> 01:23:46,440
저는 제 사정권 안에 있어요.

1949
01:23:46,439 --> 01:23:51,239
이제 돌아갈 수 있어요.
양쪽을 재귀적으로 호출합니다.

1950
01:23:51,239 --> 01:23:53,639
왜냐하면 바로
이 봉우리는 그 자체로 모든 것을 말해줍니다.

1951
01:23:53,640 --> 01:23:55,020
내 지역의 최대 강우량은 얼마인가요?

1952
01:23:55,020 --> 01:23:57,720
하지만 내가 이렇게 한다면, 만약 내가
여기서 재귀적으로 호출합니다

1953
01:23:57,720 --> 01:24:00,750
그리고 저는 여기서 그것을 재귀적으로 호출하고 있습니다.
이 과정은 선형적인 시간이 걸릴 수 있습니다.

1954
01:24:00,750 --> 01:24:03,600
나는 모든 사람을 만질 수 있어.
트리의 노드입니다.

1955
01:24:03,600 --> 01:24:05,300
그렇다면 나는 왜 그랬을까?
이것은 증가인가요?

1956
01:24:05,300 --> 01:24:07,800
그러므로 나는 필요하지 않다
이 노드에서 작업하세요.

1957
01:24:07,800 --> 01:24:12,779
최댓값만 반환합니다.
이 하위 나무의 강수량,

1958
01:24:12,779 --> 01:24:15,090
그리고 나서 이쪽에서 재귀 호출을 합니다.

1959
01:24:15,090 --> 01:24:18,059
그래서 저는 끊임없이
이쪽에서 작업했습니다.

1960
01:24:18,059 --> 01:24:19,750
재귀 함수 하나를 만들었어요.
여기서 도전해 보세요.

1961
01:24:19,750 --> 01:24:21,750
당신이 갈 수 있는 곳
바닥이지만 괜찮아요.

1962
01:24:21,750 --> 01:24:24,863
나는 갈 여유가 있다
나무의 아랫부분.

1963
01:24:24,863 --> 01:24:25,780
이해가 되시나요?

1964
01:24:25,779 --> 01:24:29,849
그리고 만약 제가 아무것도 가지고 있지 않다면
서브트리까지 정리하면 끝입니다.

1965
01:24:29,850 --> 01:24:31,420
언제든지.

1966
01:24:31,420 --> 01:24:33,659
저는 노드가 없습니다.
어떤 걸 사야 할까요?

1967
01:24:33,659 --> 01:24:40,500
재귀를 수행합니다.
나는 이 하위 트리의 최댓값을 직접 취한다

1968
01:24:40,500 --> 01:24:43,859
그리고 모든 재귀적
반환 값은 여기에 있습니다.

1969
01:24:43,859 --> 01:24:47,068
그리고 세 가지 값을 비교해 보면,
최대값을 반환합니다.

1970
01:24:47,068 --> 01:24:48,279
이해가 되시나요?

1971
01:24:48,279 --> 01:24:48,779
좋은.

1972
01:24:48,779 --> 01:24:52,380
그래서 우리는 이것을 이렇게 부릅니다.
단방향 범위 쿼리.

1973
01:24:52,380 --> 01:24:58,260
그래서… 제 생각에는,
제가 참여하지 못한 문제 해결 세션 4입니다.

1974
01:24:58,260 --> 01:25:02,100
그 방법을 보여줍니다
양방향 범위 쿼리의 경우,

1975
01:25:02,100 --> 01:25:05,610
내가 가장 알아야 할 정보는 무엇인가요?
그 둘 사이의 모든 것 중에서

1976
01:25:05,609 --> 01:25:07,170
것들.

1977
01:25:07,170 --> 01:25:09,930
하지만 사실 더 어렵지는 않습니다.

1978
01:25:09,930 --> 01:25:13,559
재귀 함수를 찾으세요.
덧셈을 이용하는,

1979
01:25:13,559 --> 01:25:18,210
그래서 당신이 직접 할 필요가 없도록
양쪽에서 재귀 호출이 발생합니다.

1980
01:25:18,210 --> 01:25:19,739
이해가 되시나요?

1981
01:25:19,739 --> 01:25:21,000
좋은.

1982
01:25:21,000 --> 01:25:25,829
오늘은 여기까지입니다.
그러면 질문에 답변할 수 있습니다.

1983
01:25:25,829 --> 01:25:27,739
와주셔서 감사합니다.

