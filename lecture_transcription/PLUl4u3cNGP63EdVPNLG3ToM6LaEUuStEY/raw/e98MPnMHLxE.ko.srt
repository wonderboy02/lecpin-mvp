1
00:00:12,880 --> 00:00:16,150

괜찮은.  모두 환영합니다.

2
00:00:16,150 --> 00:00:16,160
괜찮은.  모두 환영합니다.
 

3
00:00:16,160 --> 00:00:19,109
괜찮은.  모두 환영합니다.
퀴즈 준비되셨나요?  다음

4
00:00:19,109 --> 00:00:19,119
퀴즈 준비되셨나요?  다음
 

5
00:00:19,119 --> 00:00:21,510
퀴즈 준비되셨나요?  다음
주 퀴즈 있나요?  예.  다음 주에 퀴즈가 있다는 걸 아시니까 다들 여기 계시길 바라요

6
00:00:21,510 --> 00:00:23,189
주 퀴즈 있나요?  예.  다음 주에 퀴즈가 있다는 걸 아시니까 다들 여기 계시길 바라요
 

7
00:00:23,189 --> 00:00:23,199

 

8
00:00:23,199 --> 00:00:25,750

.  좋아요.  그렇다면 이 퀴즈는 무엇에

9
00:00:25,750 --> 00:00:25,760
.  좋아요.  그렇다면 이 퀴즈는 무엇에
 

10
00:00:25,760 --> 00:00:27,509
.  좋아요.  그렇다면 이 퀴즈는 무엇에
관한 것일까요?

11
00:00:27,509 --> 00:00:27,519
관한 것일까요?
 

12
00:00:27,519 --> 00:00:29,429
관한 것일까요?
물론, 지금까지 이 수업에서 이야기했던 내용과 관련된 거예요.

13
00:00:29,429 --> 00:00:29,439
물론, 지금까지 이 수업에서 이야기했던 내용과 관련된 거예요.
 

14
00:00:29,439 --> 00:00:31,589
물론, 지금까지 이 수업에서 이야기했던 내용과 관련된 거예요.
이 수업은 무엇에 관한 수업인가요?

15
00:00:31,589 --> 00:00:31,599
이 수업은 무엇에 관한 수업인가요?
 

16
00:00:31,599 --> 00:00:34,470
이 수업은 무엇에 관한 수업인가요?
제 첫 강의를 기억하는 분 계신가요?

17
00:00:34,470 --> 00:00:34,480
제 첫 강의를 기억하는 분 계신가요?
 

18
00:00:34,480 --> 00:00:35,990
제 첫 강의를 기억하는 분 계신가요?
이 수업은 무엇에 관한 수업인가요?

19
00:00:35,990 --> 00:00:36,000
이 수업은 무엇에 관한 수업인가요?
 

20
00:00:36,000 --> 00:00:38,229
이 수업은 무엇에 관한 수업인가요?
이 수업에서 여러분을 평가하려는 것은 무엇일까요?  알고리즘.

21
00:00:38,229 --> 00:00:38,239
이 수업에서 여러분을 평가하려는 것은 무엇일까요?  알고리즘.
 

22
00:00:38,239 --> 00:00:40,389
이 수업에서 여러분을 평가하려는 것은 무엇일까요?  알고리즘.
알고리즘.  엄청난.  그리고 데이터

23
00:00:40,389 --> 00:00:40,399
알고리즘.  엄청난.  그리고 데이터
 

24
00:00:40,399 --> 00:00:41,830
알고리즘.  엄청난.  그리고 데이터
구조도 있죠, 그렇죠?  이것이 바로

25
00:00:41,830 --> 00:00:41,840
구조도 있죠, 그렇죠?  이것이 바로
 

26
00:00:41,840 --> 00:00:44,310
구조도 있죠, 그렇죠?  이것이 바로
이 내용의 첫 번째 부분입니다.  하지만 사실, 그 목적은

27
00:00:44,310 --> 00:00:44,320
이 내용의 첫 번째 부분입니다.  하지만 사실, 그 목적은
 

28
00:00:44,320 --> 00:00:45,910
이 내용의 첫 번째 부분입니다.  하지만 사실, 그 목적은
여러분이 계산 문제를 풀도록 하기 위한 것입니다.

29
00:00:45,910 --> 00:00:45,920
여러분이 계산 문제를 풀도록 하기 위한 것입니다.
 

30
00:00:45,920 --> 00:00:48,630
여러분이 계산 문제를 풀도록 하기 위한 것입니다.
그게 첫 번째예요.

31
00:00:48,630 --> 00:00:48,640
그게 첫 번째예요.
 

32
00:00:48,640 --> 00:00:51,270
그게 첫 번째예요.
다른 사람에게 당신이 실제로

33
00:00:51,270 --> 00:00:51,280
다른 사람에게 당신이 실제로
 

34
00:00:51,280 --> 00:00:53,350
다른 사람에게 당신이 실제로
문제를 해결했다고 설득할 수 있어야 하잖아요, 그렇죠?  맞죠,

35
00:00:53,350 --> 00:00:53,360
문제를 해결했다고 설득할 수 있어야 하잖아요, 그렇죠?  맞죠,
 

36
00:00:53,360 --> 00:00:55,110
문제를 해결했다고 설득할 수 있어야 하잖아요, 그렇죠?  맞죠,
그렇죠?  당신이 선택한 것이

37
00:00:55,110 --> 00:00:55,120
그렇죠?  당신이 선택한 것이
 

38
00:00:55,120 --> 00:00:56,389
그렇죠?  당신이 선택한 것이
다른 것들보다 더 나은 것이고,

39
00:00:56,389 --> 00:00:56,399
다른 것들보다 더 나은 것이고,
 

40
00:00:56,399 --> 00:00:58,470
다른 것들보다 더 나은 것이고,
효율적이라는 뜻이겠죠?  그리고

41
00:00:58,470 --> 00:00:58,480
효율적이라는 뜻이겠죠?  그리고
 

42
00:00:58,480 --> 00:00:59,750
효율적이라는 뜻이겠죠?  그리고
그런 것들을 다른 사람들에게 전달할 수 있다는 거죠

43
00:00:59,750 --> 00:00:59,760
그런 것들을 다른 사람들에게 전달할 수 있다는 거죠
 

44
00:00:59,760 --> 00:01:01,910
그런 것들을 다른 사람들에게 전달할 수 있다는 거죠
, 그렇죠?

45
00:01:01,910 --> 00:01:01,920
, 그렇죠?
 

46
00:01:01,920 --> 00:01:04,149
, 그렇죠?
제가 여러분이 마음

47
00:01:04,149 --> 00:01:04,159
제가 여러분이 마음
 

48
00:01:04,159 --> 00:01:05,830
제가 여러분이 마음
속에 새기도록 노력하는 네 가지 핵심 원칙이 바로 이것들입니다.  그래서 저희

49
00:01:05,830 --> 00:01:05,840
속에 새기도록 노력하는 네 가지 핵심 원칙이 바로 이것들입니다.  그래서 저희
 

50
00:01:05,840 --> 00:01:08,149
속에 새기도록 노력하는 네 가지 핵심 원칙이 바로 이것들입니다.  그래서 저희
퀴즈는 바로 그런 점들을 기준으로 여러분을 평가하려고 합니다

51
00:01:08,149 --> 00:01:08,159
퀴즈는 바로 그런 점들을 기준으로 여러분을 평가하려고 합니다
 

52
00:01:08,159 --> 00:01:12,469
퀴즈는 바로 그런 점들을 기준으로 여러분을 평가하려고 합니다
.  좋아요?  그래서, 음,

53
00:01:12,469 --> 00:01:15,270
.  좋아요?  그래서, 음,
 

54
00:01:15,270 --> 00:01:15,280

 

55
00:01:15,280 --> 00:01:16,630

학기 초에 우리가 하는 계산

56
00:01:16,630 --> 00:01:16,640
학기 초에 우리가 하는 계산
 

57
00:01:16,640 --> 00:01:19,590
학기 초에 우리가 하는 계산
모델에 대한 이야기 ​​같은, 기계적인 세부적인 내용들을 제외하고

58
00:01:19,590 --> 00:01:19,600
모델에 대한 이야기 ​​같은, 기계적인 세부적인 내용들을 제외하고
 

59
00:01:19,600 --> 00:01:23,670
모델에 대한 이야기 ​​같은, 기계적인 세부적인 내용들을 제외하고
말이죠.  우리의 모델은 단순해석학

60
00:01:23,670 --> 00:01:27,270
말이죠.  우리의 모델은 단순해석학
 

61
00:01:27,270 --> 00:01:27,280

 

62
00:01:27,280 --> 00:01:29,429

처럼 비정형적입니다

63
00:01:29,429 --> 00:01:29,439
처럼 비정형적입니다
 

64
00:01:29,439 --> 00:01:31,429
처럼 비정형적입니다
.

65
00:01:31,429 --> 00:01:31,439
.
 

66
00:01:31,439 --> 00:01:33,350
.
맞습니까?

67
00:01:33,350 --> 00:01:33,360
맞습니까?
 

68
00:01:33,360 --> 00:01:37,429
맞습니까?
음, 재발 말이죠?

69
00:01:37,429 --> 00:01:37,439
음, 재발 말이죠?
 

70
00:01:37,439 --> 00:01:39,830
음, 재발 말이죠?
이런 기초적인 내용들을 제외하면, 우리는

71
00:01:39,830 --> 00:01:39,840
이런 기초적인 내용들을 제외하면, 우리는
 

72
00:01:39,840 --> 00:01:42,870
이런 기초적인 내용들을 제외하면, 우리는
바로 알고리즘으로 들어가죠,

73
00:01:42,870 --> 00:01:42,880
바로 알고리즘으로 들어가죠,
 

74
00:01:42,880 --> 00:01:46,789
바로 알고리즘으로 들어가죠,
그렇죠?  음, 이것들은 일종의 정의 같은 거예요

75
00:01:46,789 --> 00:01:46,799
그렇죠?  음, 이것들은 일종의 정의 같은 거예요
 

76
00:01:46,799 --> 00:01:48,550
그렇죠?  음, 이것들은 일종의 정의 같은 거예요
.  우리는

77
00:01:48,550 --> 00:01:48,560
.  우리는
 

78
00:01:48,560 --> 00:01:50,469
.  우리는
이런 것들에 그다지 의존하지 않습니다.  우리는

79
00:01:50,469 --> 00:01:50,479
이런 것들에 그다지 의존하지 않습니다.  우리는
 

80
00:01:50,479 --> 00:01:52,469
이런 것들에 그다지 의존하지 않습니다.  우리는
이런 것들에 항상 의존하지만, 이건

81
00:01:52,469 --> 00:01:52,479
이런 것들에 항상 의존하지만, 이건
 

82
00:01:52,479 --> 00:01:54,069
이런 것들에 항상 의존하지만, 이건
우리가

83
00:01:54,069 --> 00:01:54,079
우리가
 

84
00:01:54,079 --> 00:01:55,910
우리가
사물에 대해 이야기할 때 사용하는 수학 같은 거죠. 우리가 추론하고 추상화하지 않고서는

85
00:01:55,910 --> 00:01:55,920
사물에 대해 이야기할 때 사용하는 수학 같은 거죠. 우리가 추론하고 추상화하지 않고서는
 

86
00:01:55,920 --> 00:01:57,590
사물에 대해 이야기할 때 사용하는 수학 같은 거죠. 우리가 추론하고 추상화하지 않고서는
이런 작업에 얼마나 시간이 걸리는지 어떻게 알 수 있겠어요?

87
00:01:57,590 --> 00:01:59,670
이런 작업에 얼마나 시간이 걸리는지 어떻게 알 수 있겠어요?
 

88
00:01:59,670 --> 00:01:59,680

 

89
00:01:59,680 --> 00:02:01,990

이런 작업은 실제 컴퓨터에서 이루어지는 게 아니라,

90
00:02:01,990 --> 00:02:02,000
이런 작업은 실제 컴퓨터에서 이루어지는 게 아니라,
 

91
00:02:02,000 --> 00:02:04,230
이런 작업은 실제 컴퓨터에서 이루어지는 게 아니라,
우리 머릿속의 컴퓨터 안에서 이루어지는 거잖아요. 우리는 이 마법 같은

92
00:02:04,230 --> 00:02:05,510
우리 머릿속의 컴퓨터 안에서 이루어지는 거잖아요. 우리는 이 마법 같은
 

93
00:02:05,510 --> 00:02:07,510

 

94
00:02:07,510 --> 00:02:10,150

 

95
00:02:10,150 --> 00:02:10,160

 

96
00:02:10,160 --> 00:02:12,309

컴퓨터가 수행할 수 있는 상수 시간 연산 횟수를 기반으로 추론하는 거죠. 그러니까 이런 방식은

97
00:02:12,309 --> 00:02:13,830
컴퓨터가 수행할 수 있는 상수 시간 연산 횟수를 기반으로 추론하는 거죠. 그러니까 이런 방식은
 

98
00:02:13,830 --> 00:02:16,309

 

99
00:02:16,309 --> 00:02:16,319

 

100
00:02:16,319 --> 00:02:17,830

특정 가정 하에 우리가 가진 거의 모든 컴퓨터를 꽤 잘 나타내는 거라고 할 수 있죠. 그렇죠? 그러니까,

101
00:02:17,830 --> 00:02:19,190
특정 가정 하에 우리가 가진 거의 모든 컴퓨터를 꽤 잘 나타내는 거라고 할 수 있죠. 그렇죠? 그러니까,
 

102
00:02:19,190 --> 00:02:19,200

 

103
00:02:19,200 --> 00:02:21,589

문제 세트가 그렇게 많지는 않다는 거죠.  우리는 당신에게

104
00:02:21,589 --> 00:02:21,599
문제 세트가 그렇게 많지는 않다는 거죠.  우리는 당신에게
 

105
00:02:21,599 --> 00:02:23,350
문제 세트가 그렇게 많지는 않다는 거죠.  우리는 당신에게

106
00:02:23,350 --> 00:02:23,360

 

107
00:02:23,360 --> 00:02:27,030

이런 것들에 대해 구체적으로 이야기해 달라고 했었는데,

108
00:02:27,030 --> 00:02:27,040
이런 것들에 대해 구체적으로 이야기해 달라고 했었는데,
 

109
00:02:27,040 --> 00:02:28,550
이런 것들에 대해 구체적으로 이야기해 달라고 했었는데,
보통 이런 것들은 다른 문제의 일부였죠

110
00:02:28,550 --> 00:02:28,560
보통 이런 것들은 다른 문제의 일부였죠
 

111
00:02:28,560 --> 00:02:31,830
보통 이런 것들은 다른 문제의 일부였죠
, 그렇죠?

112
00:02:31,830 --> 00:02:31,840
, 그렇죠?
 

113
00:02:31,840 --> 00:02:33,350
, 그렇죠?
이 프로그램의 실행 시간을 설명해야 했고,

114
00:02:33,350 --> 00:02:33,360
이 프로그램의 실행 시간을 설명해야 했고,
 

115
00:02:33,360 --> 00:02:35,350
이 프로그램의 실행 시간을 설명해야 했고,
점화식을 풀어야 했을 수도 있고,

116
00:02:35,350 --> 00:02:35,360
점화식을 풀어야 했을 수도 있고,
 

117
00:02:35,360 --> 00:02:36,949
점화식을 풀어야 했을 수도 있고,
기본 정리 같은 걸 사용해야 했을 수도 있죠

118
00:02:36,949 --> 00:02:36,959
기본 정리 같은 걸 사용해야 했을 수도 있죠
 

119
00:02:36,959 --> 00:02:39,190
기본 정리 같은 걸 사용해야 했을 수도 있죠
, 그렇죠?  아니면 연산을 항상 사용하거나,

120
00:02:39,190 --> 00:02:41,190
, 그렇죠?  아니면 연산을 항상 사용하거나,
 

121
00:02:41,190 --> 00:02:41,200

 

122
00:02:41,200 --> 00:02:43,670

우리 모델에서 상수 시간 안에

123
00:02:43,670 --> 00:02:43,680
우리 모델에서 상수 시간 안에
 

124
00:02:43,680 --> 00:02:45,910
우리 모델에서 상수 시간 안에
저장하고 연산할 수 있는 정수의 크기가 중요하다는 것을 기억해야 할 수도 있죠

125
00:02:45,910 --> 00:02:45,920
저장하고 연산할 수 있는 정수의 크기가 중요하다는 것을 기억해야 할 수도 있죠
 

126
00:02:45,920 --> 00:02:48,070
저장하고 연산할 수 있는 정수의 크기가 중요하다는 것을 기억해야 할 수도 있죠
?

127
00:02:48,070 --> 00:02:48,080
?
 

128
00:02:48,080 --> 00:02:50,390
?
그러니까 코딩 문제 마지막에 나왔던 반려동물 3번 질문

129
00:02:50,390 --> 00:02:52,869
그러니까 코딩 문제 마지막에 나왔던 반려동물 3번 질문
 

130
00:02:52,869 --> 00:02:52,879

 

131
00:02:52,879 --> 00:02:56,229

말이죠?  어, 당신은 여러 가지를 정리하고 싶어하고,

132
00:02:56,229 --> 00:02:57,910
말이죠?  어, 당신은 여러 가지를 정리하고 싶어하고,
 

133
00:02:57,910 --> 00:02:57,920

 

134
00:02:57,920 --> 00:03:00,229

그 정리된 내용들이 일정한 단어 수 안에 들어가야 한다는 것을 주장해야 합니다

135
00:03:00,229 --> 00:03:02,710
그 정리된 내용들이 일정한 단어 수 안에 들어가야 한다는 것을 주장해야 합니다
 

136
00:03:02,710 --> 00:03:02,720

 

137
00:03:02,720 --> 00:03:05,110

. 그래야만 일정한 시간 안에 완료될 수 있으니까요.  많은 분들이

138
00:03:05,110 --> 00:03:05,120
. 그래야만 일정한 시간 안에 완료될 수 있으니까요.  많은 분들이
 

139
00:03:05,120 --> 00:03:07,670
. 그래야만 일정한 시간 안에 완료될 수 있으니까요.  많은 분들이
정규화 과정이 기하

140
00:03:07,670 --> 00:03:07,680
정규화 과정이 기하
 

141
00:03:07,680 --> 00:03:11,670
정규화 과정이 기하
급수적으로 큰 값으로 매핑되는 것을 발견했습니다.

142
00:03:11,670 --> 00:03:11,680
급수적으로 큰 값으로 매핑되는 것을 발견했습니다.
 

143
00:03:11,680 --> 00:03:13,750
급수적으로 큰 값으로 매핑되는 것을 발견했습니다.
그래서 소수의 곱셈 같은 것을 계산하는 것은

144
00:03:13,750 --> 00:03:15,430
그래서 소수의 곱셈 같은 것을 계산하는 것은
 

145
00:03:15,430 --> 00:03:15,440

 

146
00:03:15,440 --> 00:03:17,830

좋은 표현 방식이 아닐 수도 있습니다.

147
00:03:17,830 --> 00:03:17,840
좋은 표현 방식이 아닐 수도 있습니다.
 

148
00:03:17,840 --> 00:03:20,710
좋은 표현 방식이 아닐 수도 있습니다.
좋아요.  이런 것들이 발생하긴 하지만,

149
00:03:20,710 --> 00:03:22,229
좋아요.  이런 것들이 발생하긴 하지만,
 

150
00:03:22,229 --> 00:03:22,239

 

151
00:03:22,239 --> 00:03:23,830

우리가 해결하는 문제의 핵심은 아닙니다.  이 수업에서

152
00:03:23,830 --> 00:03:23,840
우리가 해결하는 문제의 핵심은 아닙니다.  이 수업에서
 

153
00:03:23,840 --> 00:03:25,589
우리가 해결하는 문제의 핵심은 아닙니다.  이 수업에서
우리가 계산 문제를 해결하는 방법에 대한 주요 초점은 무엇인가요

154
00:03:25,589 --> 00:03:25,599
우리가 계산 문제를 해결하는 방법에 대한 주요 초점은 무엇인가요
 

155
00:03:25,599 --> 00:03:27,430
우리가 계산 문제를 해결하는 방법에 대한 주요 초점은 무엇인가요
?

156
00:03:27,430 --> 00:03:29,589
?
 

157
00:03:29,589 --> 00:03:29,599

 

158
00:03:29,599 --> 00:03:31,110

학기 초에 두 가지 방법을 알려드렸잖아요.  여러분,

159
00:03:31,110 --> 00:03:31,120
학기 초에 두 가지 방법을 알려드렸잖아요.  여러분,
 

160
00:03:31,120 --> 00:03:33,670
학기 초에 두 가지 방법을 알려드렸잖아요.  여러분,

161
00:03:33,670 --> 00:03:33,680

 

162
00:03:33,680 --> 00:03:40,710

우리가 어떻게

163
00:03:40,710 --> 00:03:40,720

 

164
00:03:40,720 --> 00:03:45,589

계산

165
00:03:45,589 --> 00:03:45,599

 

166
00:03:45,599 --> 00:03:51,589

문제를 풀 수 있는지 기억하시나요?

167
00:03:51,589 --> 00:03:51,599

 

168
00:03:51,599 --> 00:03:54,470

하나는 어려운 길이고, 하나는 쉬운 길이다.

169
00:03:54,470 --> 00:03:54,480
하나는 어려운 길이고, 하나는 쉬운 길이다.
 

170
00:03:54,480 --> 00:03:57,110
하나는 어려운 길이고, 하나는 쉬운 길이다.
힘.  무차별 대입.  좋아요.  그러니까 당신은

171
00:03:57,110 --> 00:03:57,120
힘.  무차별 대입.  좋아요.  그러니까 당신은
 

172
00:03:57,120 --> 00:03:59,429
힘.  무차별 대입.  좋아요.  그러니까 당신은
저에게 자신만의 알고리즘을 만드는 기술을 설명하고 있는 거죠

173
00:03:59,429 --> 00:03:59,439
저에게 자신만의 알고리즘을 만드는 기술을 설명하고 있는 거죠
 

174
00:03:59,439 --> 00:04:03,030
저에게 자신만의 알고리즘을 만드는 기술을 설명하고 있는 거죠
?  아시다시피, 저는

175
00:04:03,030 --> 00:04:03,040
?  아시다시피, 저는
 

176
00:04:03,040 --> 00:04:05,429
?  아시다시피, 저는
새로운 알고리즘을 처음부터 직접 설계할 수 있습니다

177
00:04:05,429 --> 00:04:05,439
새로운 알고리즘을 처음부터 직접 설계할 수 있습니다
 

178
00:04:05,439 --> 00:04:07,190
새로운 알고리즘을 처음부터 직접 설계할 수 있습니다
.  그렇게 할 수 있는 한 가지 방법은

179
00:04:07,190 --> 00:04:07,200
.  그렇게 할 수 있는 한 가지 방법은
 

180
00:04:07,200 --> 00:04:08,949
.  그렇게 할 수 있는 한 가지 방법은
무차별 대입을 하는 거겠죠?

181
00:04:08,949 --> 00:04:08,959
무차별 대입을 하는 거겠죠?
 

182
00:04:08,959 --> 00:04:10,630
무차별 대입을 하는 거겠죠?
가능한 모든 출력값을 살펴보고 어떤 게 맞는지 확인해 보면 되잖아요

183
00:04:10,630 --> 00:04:10,640
가능한 모든 출력값을 살펴보고 어떤 게 맞는지 확인해 보면 되잖아요
 

184
00:04:10,640 --> 00:04:13,030
가능한 모든 출력값을 살펴보고 어떤 게 맞는지 확인해 보면 되잖아요
, 그렇죠?  아니면 '

185
00:04:13,030 --> 00:04:13,040
, 그렇죠?  아니면 '
 

186
00:04:13,040 --> 00:04:14,390
, 그렇죠?  아니면 '
분할 통치' 같은 전략으로 단순화할 수도 있겠죠

187
00:04:14,390 --> 00:04:14,400
분할 통치' 같은 전략으로 단순화할 수도 있겠죠
 

188
00:04:14,400 --> 00:04:15,910
분할 통치' 같은 전략으로 단순화할 수도 있겠죠
.  자신

189
00:04:15,910 --> 00:04:15,920
.  자신
 

190
00:04:15,920 --> 00:04:17,030
.  자신
만의 알고리즘을 만드는 건 일반적으로 어려운 일이죠

191
00:04:17,030 --> 00:04:17,040
만의 알고리즘을 만드는 건 일반적으로 어려운 일이죠
 

192
00:04:17,040 --> 00:04:19,509
만의 알고리즘을 만드는 건 일반적으로 어려운 일이죠
, 그렇죠?  그래서

193
00:04:19,509 --> 00:04:19,519
, 그렇죠?  그래서
 

194
00:04:19,519 --> 00:04:21,110
, 그렇죠?  그래서
이 수업에서 그걸 자주 시키지 않는 거죠,

195
00:04:21,110 --> 00:04:21,120
이 수업에서 그걸 자주 시키지 않는 거죠,
 

196
00:04:21,120 --> 00:04:23,030
이 수업에서 그걸 자주 시키지 않는 거죠,
그렇죠?  이건 046 같은 종류의 일이죠, 그렇죠?

197
00:04:23,030 --> 00:04:23,040
그렇죠?  이건 046 같은 종류의 일이죠, 그렇죠?
 

198
00:04:23,040 --> 00:04:26,150
그렇죠?  이건 046 같은 종류의 일이죠, 그렇죠?
우선 가장 먼저 할 수 있는 일은

199
00:04:26,150 --> 00:04:26,160
우선 가장 먼저 할 수 있는 일은
 

200
00:04:26,160 --> 00:04:28,710
우선 가장 먼저 할 수 있는 일은

201
00:04:28,710 --> 00:04:28,720

 

202
00:04:28,720 --> 00:04:30,310

새로운

203
00:04:30,310 --> 00:04:30,320
새로운
 

204
00:04:30,320 --> 00:04:32,790
새로운
알고리즘을 처음부터 설계하는 것입니다

205
00:04:32,790 --> 00:04:32,800
알고리즘을 처음부터 설계하는 것입니다
 

206
00:04:32,800 --> 00:04:35,430
알고리즘을 처음부터 설계하는 것입니다
.  보통은 처음부터 만드는 건 아니잖아요,

207
00:04:35,430 --> 00:04:35,440
.  보통은 처음부터 만드는 건 아니잖아요,
 

208
00:04:35,440 --> 00:04:37,030
.  보통은 처음부터 만드는 건 아니잖아요,
그렇죠?  보통은 여러분이 들어봤을 법한

209
00:04:37,030 --> 00:04:37,040
그렇죠?  보통은 여러분이 들어봤을 법한
 

210
00:04:37,040 --> 00:04:39,749
그렇죠?  보통은 여러분이 들어봤을 법한
알고리즘적 설계 패러다임으로 축소해서 생각하게 됩니다

211
00:04:39,749 --> 00:04:39,759
알고리즘적 설계 패러다임으로 축소해서 생각하게 됩니다
 

212
00:04:39,759 --> 00:04:41,749
알고리즘적 설계 패러다임으로 축소해서 생각하게 됩니다
.

213
00:04:41,749 --> 00:04:41,759
.
 

214
00:04:41,759 --> 00:04:44,310
.
046 수업과

215
00:04:44,310 --> 00:04:44,320
046 수업과
 

216
00:04:44,320 --> 00:04:45,749
046 수업과
이번 학기 말에 동적 프로그래밍에 대해 이야기할 때 이 주제에 대해 훨씬 더 자세히 다루겠지만

217
00:04:45,749 --> 00:04:45,759
이번 학기 말에 동적 프로그래밍에 대해 이야기할 때 이 주제에 대해 훨씬 더 자세히 다루겠지만
 

218
00:04:45,759 --> 00:04:48,310
이번 학기 말에 동적 프로그래밍에 대해 이야기할 때 이 주제에 대해 훨씬 더 자세히 다루겠지만
, 일반적으로 동적 프로그래밍은

219
00:04:48,310 --> 00:04:48,320
, 일반적으로 동적 프로그래밍은
 

220
00:04:48,320 --> 00:04:50,710
, 일반적으로 동적 프로그래밍은
구현하기 어려운 부분이죠?  B, 당신은

221
00:04:50,710 --> 00:04:50,720
구현하기 어려운 부분이죠?  B, 당신은
 

222
00:04:50,720 --> 00:04:51,749
구현하기 어려운 부분이죠?  B, 당신은
재귀

223
00:04:51,749 --> 00:04:51,759
재귀
 

224
00:04:51,759 --> 00:04:54,230
재귀
알고리즘을 생각해내려고 하는 거죠?  당신은 그것이

225
00:04:54,230 --> 00:04:54,240
알고리즘을 생각해내려고 하는 거죠?  당신은 그것이
 

226
00:04:54,240 --> 00:04:55,670
알고리즘을 생각해내려고 하는 거죠?  당신은 그것이
옳다는 것을 증명하려고 하는군요.  이 모든

227
00:04:55,670 --> 00:04:55,680
옳다는 것을 증명하려고 하는군요.  이 모든
 

228
00:04:55,680 --> 00:04:57,430
옳다는 것을 증명하려고 하는군요.  이 모든
자질적인 것들 말이죠.  저희는 수업 시간

229
00:04:57,430 --> 00:04:57,440
자질적인 것들 말이죠.  저희는 수업 시간
 

230
00:04:57,440 --> 00:04:59,590
자질적인 것들 말이죠.  저희는 수업 시간
내내 강의에서

231
00:04:59,590 --> 00:04:59,600
내내 강의에서
 

232
00:04:59,600 --> 00:05:02,629
내내 강의에서
알고리즘들을 보여드렸지만,

233
00:05:02,629 --> 00:05:02,639
알고리즘들을 보여드렸지만,
 

234
00:05:02,639 --> 00:05:04,550
알고리즘들을 보여드렸지만,
여러분이 직접 그 알고리즘들을 만들어내길 기대하는 것은 아닙니다

235
00:05:04,550 --> 00:05:04,560
여러분이 직접 그 알고리즘들을 만들어내길 기대하는 것은 아닙니다
 

236
00:05:04,560 --> 00:05:06,310
여러분이 직접 그 알고리즘들을 만들어내길 기대하는 것은 아닙니다
.  우리는

237
00:05:06,310 --> 00:05:06,320
.  우리는
 

238
00:05:06,320 --> 00:05:09,990
.  우리는
당신이 대부분의 시간에 무엇을 하기를 기대합니까?  응.  우리가

239
00:05:09,990 --> 00:05:12,230
당신이 대부분의 시간에 무엇을 하기를 기대합니까?  응.  우리가
 

240
00:05:12,230 --> 00:05:12,240

 

241
00:05:12,240 --> 00:05:19,909

해결 방법을 알려드린 문제로 단순화하는 거죠, 그렇죠?

242
00:05:19,909 --> 00:05:19,919

 

243
00:05:19,919 --> 00:05:21,830

제가 여기서 '무언가'라고 말하겠지만, 사실 제가

244
00:05:21,830 --> 00:05:21,840
제가 여기서 '무언가'라고 말하겠지만, 사실 제가
 

245
00:05:21,840 --> 00:05:23,510
제가 여기서 '무언가'라고 말하겠지만, 사실 제가
의미하는 바는 우리가

246
00:05:23,510 --> 00:05:23,520
의미하는 바는 우리가
 

247
00:05:23,520 --> 00:05:27,270
의미하는 바는 우리가
여러분에게 가르쳐 드린 알고리즘을 기본적으로 이미

248
00:05:27,270 --> 00:05:27,280
여러분에게 가르쳐 드린 알고리즘을 기본적으로 이미
 

249
00:05:27,280 --> 00:05:32,070
여러분에게 가르쳐 드린 알고리즘을 기본적으로 이미
알려진 것으로 환원하는 것입니다.  알려진 바에 따르면 아닙니다.  음,

250
00:05:32,070 --> 00:05:32,080
알려진 것으로 환원하는 것입니다.  알려진 바에 따르면 아닙니다.  음,
 

251
00:05:32,080 --> 00:05:34,870
알려진 것으로 환원하는 것입니다.  알려진 바에 따르면 아닙니다.  음,
보통 그런 경우는 문제가 있거나

252
00:05:34,870 --> 00:05:34,880
보통 그런 경우는 문제가 있거나
 

253
00:05:34,880 --> 00:05:37,270
보통 그런 경우는 문제가 있거나
인터페이스에 문제가 있다는 뜻이죠, 그렇죠?  우리가

254
00:05:37,270 --> 00:05:37,280
인터페이스에 문제가 있다는 뜻이죠, 그렇죠?  우리가
 

255
00:05:37,280 --> 00:05:40,310
인터페이스에 문제가 있다는 뜻이죠, 그렇죠?  우리가
당신에게 드린 것.  그리고 일반적으로, 우리는 그 문제를

256
00:05:40,310 --> 00:05:40,320
당신에게 드린 것.  그리고 일반적으로, 우리는 그 문제를
 

257
00:05:40,320 --> 00:05:42,070
당신에게 드린 것.  그리고 일반적으로, 우리는 그 문제를
해결하는 다양한 방법을 여러분께 보여드렸습니다

258
00:05:42,070 --> 00:05:42,080
해결하는 다양한 방법을 여러분께 보여드렸습니다
 

259
00:05:42,080 --> 00:05:43,909
해결하는 다양한 방법을 여러분께 보여드렸습니다
, 그렇죠?  인터페이스라고

260
00:05:43,909 --> 00:05:43,919
, 그렇죠?  인터페이스라고
 

261
00:05:43,919 --> 00:05:46,790
, 그렇죠?  인터페이스라고
할까요?  지금까지 우리는

262
00:05:46,790 --> 00:05:46,800
할까요?  지금까지 우리는
 

263
00:05:46,800 --> 00:05:49,350
할까요?  지금까지 우리는
사물을 올바르게 정렬하는 여러 가지 방법과

264
00:05:49,350 --> 00:05:51,189
사물을 올바르게 정렬하는 여러 가지 방법과
 

265
00:05:51,189 --> 00:05:51,199

 

266
00:05:51,199 --> 00:05:55,430

순서 및 설정 인터페이스를 구현하는 여러 가지 방법을 보여드렸습니다.  그리고 기억하세요, 저희가

267
00:05:55,430 --> 00:05:59,350
순서 및 설정 인터페이스를 구현하는 여러 가지 방법을 보여드렸습니다.  그리고 기억하세요, 저희가
 

268
00:05:59,350 --> 00:05:59,360

 

269
00:05:59,360 --> 00:06:01,270

여러분에게 요구하는 문제 유형은 종종

270
00:06:01,270 --> 00:06:04,150
여러분에게 요구하는 문제 유형은 종종
 

271
00:06:04,150 --> 00:06:04,160

 

272
00:06:04,160 --> 00:06:05,990

저희가 했던 몇 가지 작업을 블랙박스처럼 사용하는 것입니다. 하지만

273
00:06:05,990 --> 00:06:06,000
저희가 했던 몇 가지 작업을 블랙박스처럼 사용하는 것입니다. 하지만
 

274
00:06:06,000 --> 00:06:08,309
저희가 했던 몇 가지 작업을 블랙박스처럼 사용하는 것입니다. 하지만
프로그래머이자 컴퓨터 과학자로서 여러분은 제가

275
00:06:08,309 --> 00:06:08,319
프로그래머이자 컴퓨터 과학자로서 여러분은 제가
 

276
00:06:08,319 --> 00:06:10,870
프로그래머이자 컴퓨터 과학자로서 여러분은 제가
언제 무엇을 언제 사용해야 하는지 알려주셔야 합니다

277
00:06:10,870 --> 00:06:10,880
언제 무엇을 언제 사용해야 하는지 알려주셔야 합니다
 

278
00:06:10,880 --> 00:06:13,590
언제 무엇을 언제 사용해야 하는지 알려주셔야 합니다
.  오른쪽.  응.  "

279
00:06:13,590 --> 00:06:13,600
.  오른쪽.  응.  "
 

280
00:06:13,600 --> 00:06:15,350
.  오른쪽.  응.  "
블랙박스로 사용한다"는 말씀이 정확히 무엇을 의미하는지 설명해 주시겠습니까

281
00:06:15,350 --> 00:06:15,360
블랙박스로 사용한다"는 말씀이 정확히 무엇을 의미하는지 설명해 주시겠습니까
 

282
00:06:15,360 --> 00:06:17,670
블랙박스로 사용한다"는 말씀이 정확히 무엇을 의미하는지 설명해 주시겠습니까
?  블랙박스로 사용하세요.  정확히.  오른쪽.

283
00:06:17,670 --> 00:06:17,680
?  블랙박스로 사용하세요.  정확히.  오른쪽.
 

284
00:06:17,680 --> 00:06:20,309
?  블랙박스로 사용하세요.  정확히.  오른쪽.
음, 이건 제가 쓰는 표현이기도 하고

285
00:06:20,309 --> 00:06:20,319
음, 이건 제가 쓰는 표현이기도 하고
 

286
00:06:20,319 --> 00:06:21,990
음, 이건 제가 쓰는 표현이기도 하고
컴퓨터 과학 분야에 종사하는 많은 사람들이 쓰는 표현입니다.

287
00:06:21,990 --> 00:06:22,000
컴퓨터 과학 분야에 종사하는 많은 사람들이 쓰는 표현입니다.
 

288
00:06:22,000 --> 00:06:25,029
컴퓨터 과학 분야에 종사하는 많은 사람들이 쓰는 표현입니다.
기본적으로 라이브러리를

289
00:06:25,029 --> 00:06:25,039
기본적으로 라이브러리를
 

290
00:06:25,039 --> 00:06:27,909
기본적으로 라이브러리를
코드에 임포트하는 거죠, 그렇죠?  내가 가진 건 뭐지?  저는

291
00:06:27,909 --> 00:06:27,919
코드에 임포트하는 거죠, 그렇죠?  내가 가진 건 뭐지?  저는
 

292
00:06:27,919 --> 00:06:29,990
코드에 임포트하는 거죠, 그렇죠?  내가 가진 건 뭐지?  저는
일종의 API를 가지고 있습니다.  저는

293
00:06:29,990 --> 00:06:30,000
일종의 API를 가지고 있습니다.  저는
 

294
00:06:30,000 --> 00:06:31,909
일종의 API를 가지고 있습니다.  저는
그 코드와 상호작용할 수 있는 방법을 가지고 있습니다.  사실 저는

295
00:06:31,909 --> 00:06:34,150
그 코드와 상호작용할 수 있는 방법을 가지고 있습니다.  사실 저는
 

296
00:06:34,150 --> 00:06:34,160

 

297
00:06:34,160 --> 00:06:36,950

그 도서관 안에서 무슨 일이 벌어지고 있는지 전혀 몰라요, 그렇죠?  저는 그것을

298
00:06:36,950 --> 00:06:36,960
그 도서관 안에서 무슨 일이 벌어지고 있는지 전혀 몰라요, 그렇죠?  저는 그것을
 

299
00:06:36,960 --> 00:06:39,510
그 도서관 안에서 무슨 일이 벌어지고 있는지 전혀 몰라요, 그렇죠?  저는 그것을
블랙박스로 사용하고 있습니다.  제게는 불투명하게 느껴집니다.  제가 무슨 말을 하는지는 정확히 모르겠지만, 사실

300
00:06:39,510 --> 00:06:41,270
블랙박스로 사용하고 있습니다.  제게는 불투명하게 느껴집니다.  제가 무슨 말을 하는지는 정확히 모르겠지만, 사실
 

301
00:06:41,270 --> 00:06:41,280

 

302
00:06:41,280 --> 00:06:42,950

그들의 코드 내부를 들여다볼 수도 있을 겁니다.

303
00:06:42,950 --> 00:06:42,960
그들의 코드 내부를 들여다볼 수도 있을 겁니다.
 

304
00:06:42,960 --> 00:06:45,029
그들의 코드 내부를 들여다볼 수도 있을 겁니다.
하지만 그러지 않을 겁니다.

305
00:06:45,029 --> 00:06:45,039
하지만 그러지 않을 겁니다.
 

306
00:06:45,039 --> 00:06:47,189
하지만 그러지 않을 겁니다.
제가 이 프로그램을 유용하게 생각하는 이유는,

307
00:06:47,189 --> 00:06:50,390
제가 이 프로그램을 유용하게 생각하는 이유는,
 

308
00:06:50,390 --> 00:06:50,400

 

309
00:06:50,400 --> 00:06:52,629

말씀하신 대로 작동할 거라고 믿을 수 있는 유용한 API를 제공하기 때문입니다.

310
00:06:52,629 --> 00:06:52,639
말씀하신 대로 작동할 거라고 믿을 수 있는 유용한 API를 제공하기 때문입니다.
 

311
00:06:52,639 --> 00:06:54,870
말씀하신 대로 작동할 거라고 믿을 수 있는 유용한 API를 제공하기 때문입니다.
그렇죠?  그래서

312
00:06:54,870 --> 00:06:57,510
그렇죠?  그래서
 

313
00:06:57,510 --> 00:06:57,520

 

314
00:06:57,520 --> 00:06:59,350

사실 좀 왔다갔다 하면서 얘기해 볼게요. 정말

315
00:06:59,350 --> 00:06:59,360
사실 좀 왔다갔다 하면서 얘기해 볼게요. 정말
 

316
00:06:59,360 --> 00:07:03,909
사실 좀 왔다갔다 하면서 얘기해 볼게요. 정말
좋은 질문이거든요.  음, 그러니까

317
00:07:03,909 --> 00:07:06,390
좋은 질문이거든요.  음, 그러니까
 

318
00:07:06,390 --> 00:07:09,189

 

319
00:07:09,189 --> 00:07:09,199

 

320
00:07:09,199 --> 00:07:11,830

이 수업에서 다루는 문제 유형은 크게 세 가지로 나눌 수 있다고 생각해요.

321
00:07:11,830 --> 00:07:11,840
이 수업에서 다루는 문제 유형은 크게 세 가지로 나눌 수 있다고 생각해요.
 

322
00:07:11,840 --> 00:07:13,909
이 수업에서 다루는 문제 유형은 크게 세 가지로 나눌 수 있다고 생각해요.
문제 세트에서도 보셨을 거예요. 저는 문제를

323
00:07:13,909 --> 00:07:16,469
문제 세트에서도 보셨을 거예요. 저는 문제를
 

324
00:07:16,469 --> 00:07:16,479

 

325
00:07:16,479 --> 00:07:19,270

세 가지 범주로 분류하는 걸 좋아하는데, 첫 번째는

326
00:07:19,270 --> 00:07:22,950
세 가지 범주로 분류하는 걸 좋아하는데, 첫 번째는
 

327
00:07:22,950 --> 00:07:25,029

 

328
00:07:25,029 --> 00:07:25,039

 

329
00:07:25,039 --> 00:07:27,270

우리가 알고 있는 데이터 구조와 알고리즘의 내부를 이해해야 하는 문제예요. 예를 들어,

330
00:07:27,270 --> 00:07:29,830
우리가 알고 있는 데이터 구조와 알고리즘의 내부를 이해해야 하는 문제예요. 예를 들어,
 

331
00:07:29,830 --> 00:07:29,840

 

332
00:07:29,840 --> 00:07:32,710

균형 이진 검색

333
00:07:32,710 --> 00:07:32,720
균형 이진 검색
 

334
00:07:32,720 --> 00:07:35,270
균형 이진 검색
트리나 AVL 트리의 노드가 주어졌을 때, 그 내부를 살펴볼 수 있어야 하죠.  어떻게 하면 순환 근무를 할 수 있죠

335
00:07:35,270 --> 00:07:35,280
트리나 AVL 트리의 노드가 주어졌을 때, 그 내부를 살펴볼 수 있어야 하죠.  어떻게 하면 순환 근무를 할 수 있죠
 

336
00:07:35,280 --> 00:07:38,150
트리나 AVL 트리의 노드가 주어졌을 때, 그 내부를 살펴볼 수 있어야 하죠.  어떻게 하면 순환 근무를 할 수 있죠
?  아니면

337
00:07:38,150 --> 00:07:38,160
?  아니면
 

338
00:07:38,160 --> 00:07:41,990
?  아니면
삽입이나 뭐 그런 걸 어떻게 하는 거죠?

339
00:07:41,990 --> 00:07:42,000
삽입이나 뭐 그런 걸 어떻게 하는 거죠?
 

340
00:07:42,000 --> 00:07:45,029
삽입이나 뭐 그런 걸 어떻게 하는 거죠?
이진 힙 같은 구조

341
00:07:45,029 --> 00:07:45,039
이진 힙 같은 구조
 

342
00:07:45,039 --> 00:07:46,790
이진 힙 같은 구조
말이에요.  문제에서 다루는 최대 이진 힙에서 상위 k개 요소는 어디에 있나요

343
00:07:46,790 --> 00:07:48,550
말이에요.  문제에서 다루는 최대 이진 힙에서 상위 k개 요소는 어디에 있나요
 

344
00:07:48,550 --> 00:07:48,560

 

345
00:07:48,560 --> 00:07:51,909

?  그러기 위해서는

346
00:07:51,909 --> 00:07:51,919
?  그러기 위해서는
 

347
00:07:51,919 --> 00:07:54,869
?  그러기 위해서는
데이터 구조를 블랙박스화하지 않는 것이 매우 중요합니다

348
00:07:54,869 --> 00:07:54,879
데이터 구조를 블랙박스화하지 않는 것이 매우 중요합니다
 

349
00:07:54,879 --> 00:07:57,589
데이터 구조를 블랙박스화하지 않는 것이 매우 중요합니다
.  하얀 상자죠, 그렇죠?

350
00:07:57,589 --> 00:07:59,270
.  하얀 상자죠, 그렇죠?
 

351
00:07:59,270 --> 00:07:59,280

 

352
00:07:59,280 --> 00:08:00,869

그 질문에 답하려면 안에 뭐가 들어있는지 알아야 하잖아요, 그렇죠?  저는

353
00:08:00,869 --> 00:08:00,879
그 질문에 답하려면 안에 뭐가 들어있는지 알아야 하잖아요, 그렇죠?  저는
 

354
00:08:00,879 --> 00:08:02,390
그 질문에 답하려면 안에 뭐가 들어있는지 알아야 하잖아요, 그렇죠?  저는
그 데이터 구조의 내부 구조에 대해 알아야 하잖아요

355
00:08:02,390 --> 00:08:02,400
그 데이터 구조의 내부 구조에 대해 알아야 하잖아요
 

356
00:08:02,400 --> 00:08:04,469
그 데이터 구조의 내부 구조에 대해 알아야 하잖아요
, 그렇죠?  그리고 또 다른

357
00:08:04,469 --> 00:08:04,479
, 그렇죠?  그리고 또 다른
 

358
00:08:04,479 --> 00:08:06,710
, 그렇죠?  그리고 또 다른
유형의 문제들은, 예를 들어 "아,

359
00:08:06,710 --> 00:08:08,230
유형의 문제들은, 예를 들어 "아,
 

360
00:08:08,230 --> 00:08:08,240

 

361
00:08:08,240 --> 00:08:10,629

이 데이터 구조의 내부 구조는 알 필요가 없겠네"라고 생각할 수 있죠.

362
00:08:10,629 --> 00:08:10,639
이 데이터 구조의 내부 구조는 알 필요가 없겠네"라고 생각할 수 있죠.
 

363
00:08:10,639 --> 00:08:13,749
이 데이터 구조의 내부 구조는 알 필요가 없겠네"라고 생각할 수 있죠.
API에 대한 지식만 있으면 바로 작업할 수 있는 거죠

364
00:08:13,749 --> 00:08:13,759
API에 대한 지식만 있으면 바로 작업할 수 있는 거죠
 

365
00:08:13,759 --> 00:08:15,990
API에 대한 지식만 있으면 바로 작업할 수 있는 거죠
?  그리고

366
00:08:15,990 --> 00:08:16,000
?  그리고
 

367
00:08:16,000 --> 00:08:17,830
?  그리고
제가 필요로 하는 문제에 연결시켜 보려고 합니다.  그게 바로 제가

368
00:08:17,830 --> 00:08:17,840
제가 필요로 하는 문제에 연결시켜 보려고 합니다.  그게 바로 제가
 

369
00:08:17,840 --> 00:08:20,070
제가 필요로 하는 문제에 연결시켜 보려고 합니다.  그게 바로 제가
말하는 축소형 문제죠, 그렇죠?

370
00:08:20,070 --> 00:08:20,080
말하는 축소형 문제죠, 그렇죠?
 

371
00:08:20,080 --> 00:08:22,309
말하는 축소형 문제죠, 그렇죠?
이건 마치

372
00:08:22,309 --> 00:08:22,319
이건 마치
 

373
00:08:22,319 --> 00:08:24,790
이건 마치
우리가 강의에서 여러분에게 제시했던 핵심 내용이 어떻게 작동하는지와 같은 거죠,

374
00:08:24,790 --> 00:08:24,800
우리가 강의에서 여러분에게 제시했던 핵심 내용이 어떻게 작동하는지와 같은 거죠,
 

375
00:08:24,800 --> 00:08:26,710
우리가 강의에서 여러분에게 제시했던 핵심 내용이 어떻게 작동하는지와 같은 거죠,
그렇죠?  이건 마치

376
00:08:26,710 --> 00:08:26,720
그렇죠?  이건 마치
 

377
00:08:26,720 --> 00:08:30,070
그렇죠?  이건 마치
핵심 내용을 어떻게 적용하는 건지 묻는 것과 같죠?  그리고

378
00:08:30,070 --> 00:08:30,080
핵심 내용을 어떻게 적용하는 건지 묻는 것과 같죠?  그리고
 

379
00:08:30,080 --> 00:08:32,469
핵심 내용을 어떻게 적용하는 건지 묻는 것과 같죠?  그리고
그 두 가지보다 훨씬 더 어렵죠, 그렇죠?  제가 보기엔 일종의

380
00:08:32,469 --> 00:08:32,479
그 두 가지보다 훨씬 더 어렵죠, 그렇죠?  제가 보기엔 일종의
 

381
00:08:32,479 --> 00:08:34,790
그 두 가지보다 훨씬 더 어렵죠, 그렇죠?  제가 보기엔 일종의
수정형 전문가라고 할 수 있겠네요.  솔직히 말해서

382
00:08:34,790 --> 00:08:34,800
수정형 전문가라고 할 수 있겠네요.  솔직히 말해서
 

383
00:08:34,800 --> 00:08:36,230
수정형 전문가라고 할 수 있겠네요.  솔직히 말해서
, 이 이름들은 그다지 좋은 이름이 아니에요.

384
00:08:36,230 --> 00:08:36,240
, 이 이름들은 그다지 좋은 이름이 아니에요.
 

385
00:08:36,240 --> 00:08:38,230
, 이 이름들은 그다지 좋은 이름이 아니에요.
이거 내가 오늘 아침에 생각해낸 거야, 그렇지?

386
00:08:38,230 --> 00:08:38,240
이거 내가 오늘 아침에 생각해낸 거야, 그렇지?
 

387
00:08:38,240 --> 00:08:40,469
이거 내가 오늘 아침에 생각해낸 거야, 그렇지?
하지만

388
00:08:40,469 --> 00:08:40,479
하지만
 

389
00:08:40,479 --> 00:08:43,110
하지만
여기서 말하고자 하는 것은

390
00:08:43,110 --> 00:08:44,790
여기서 말하고자 하는 것은
 

391
00:08:44,790 --> 00:08:45,990

 

392
00:08:45,990 --> 00:08:46,000

 

393
00:08:46,000 --> 00:08:47,670

문제를 해결하려면 API가 무엇인지, 그리고 내부에서 무슨 일이 일어나는지 알아야 할 필요가 있다는 것입니다.   예를

394
00:08:47,670 --> 00:08:50,310
문제를 해결하려면 API가 무엇인지, 그리고 내부에서 무슨 일이 일어나는지 알아야 할 필요가 있다는 것입니다.   예를
 

395
00:08:50,310 --> 00:08:50,320

 

396
00:08:50,320 --> 00:08:53,590

들어, 분할 정복 알고리즘을 적용하는 것 같은 거죠?  아니면,

397
00:08:53,590 --> 00:08:56,230
들어, 분할 정복 알고리즘을 적용하는 것 같은 거죠?  아니면,
 

398
00:08:56,230 --> 00:08:56,240

 

399
00:08:56,240 --> 00:08:58,790

한쪽 끝에 여유 공간이 있는 동적 배열을 사용하는 대신

400
00:08:58,790 --> 00:08:58,800
한쪽 끝에 여유 공간이 있는 동적 배열을 사용하는 대신
 

401
00:08:58,800 --> 00:09:00,790
한쪽 끝에 여유 공간이 있는 동적 배열을 사용하는 대신
중간에 여유 공간을 넣는 식으로 해야 할지도 모르겠네요.

402
00:09:00,790 --> 00:09:02,230
중간에 여유 공간을 넣는 식으로 해야 할지도 모르겠네요.
 

403
00:09:02,230 --> 00:09:04,150

 

404
00:09:04,150 --> 00:09:04,160

 

405
00:09:04,160 --> 00:09:06,230

핵심 자료에서 가져온 걸 수정해야 하는데, 거의 비슷하지만

406
00:09:06,230 --> 00:09:06,240
핵심 자료에서 가져온 걸 수정해야 하는데, 거의 비슷하지만
 

407
00:09:06,240 --> 00:09:07,430
핵심 자료에서 가져온 걸 수정해야 하는데, 거의 비슷하지만
어떤 식으로든 보강해야 해요.

408
00:09:07,430 --> 00:09:09,750
어떤 식으로든 보강해야 해요.
 

409
00:09:09,750 --> 00:09:09,760

 

410
00:09:09,760 --> 00:09:12,790

제가 드렸을지도 모르는 기본 AVL 트리에

411
00:09:12,790 --> 00:09:14,630
제가 드렸을지도 모르는 기본 AVL 트리에
 

412
00:09:14,630 --> 00:09:14,640

 

413
00:09:14,640 --> 00:09:15,990

노드에 다른 속성을 추가해야 하는데,

414
00:09:15,990 --> 00:09:16,000
노드에 다른 속성을 추가해야 하는데,
 

415
00:09:16,000 --> 00:09:19,030
노드에 다른 속성을 추가해야 하는데,
그걸 어떻게 유지 관리해야 하는지, 자식 노드로부터 하위

416
00:09:19,030 --> 00:09:19,040
그걸 어떻게 유지 관리해야 하는지, 자식 노드로부터 하위
 

417
00:09:19,040 --> 00:09:20,949
그걸 어떻게 유지 관리해야 하는지, 자식 노드로부터 하위
트리 속성을 어떻게 계산해야 하는지 알려주세요

418
00:09:20,949 --> 00:09:20,959
트리 속성을 어떻게 계산해야 하는지 알려주세요
 

419
00:09:20,959 --> 00:09:23,190
트리 속성을 어떻게 계산해야 하는지 알려주세요
.  이해가 되시나요?

420
00:09:23,190 --> 00:09:23,200
.  이해가 되시나요?
 

421
00:09:23,200 --> 00:09:25,990
.  이해가 되시나요?
음, 그러니까 이게 좀 더 어려운 부분이죠

422
00:09:25,990 --> 00:09:26,000
음, 그러니까 이게 좀 더 어려운 부분이죠
 

423
00:09:26,000 --> 00:09:28,550
음, 그러니까 이게 좀 더 어려운 부분이죠
, 그렇죠?  시험에서 접하는 문제가 이 중 어떤 유형에 속하는지 파악할 수 있다면

424
00:09:28,550 --> 00:09:30,870
, 그렇죠?  시험에서 접하는 문제가 이 중 어떤 유형에 속하는지 파악할 수 있다면
 

425
00:09:30,870 --> 00:09:30,880

 

426
00:09:30,880 --> 00:09:33,590

,

427
00:09:33,590 --> 00:09:36,230
,
 

428
00:09:36,230 --> 00:09:36,240

 

429
00:09:36,240 --> 00:09:37,990

축소 유형 문제에 어떤 방법을 사용해야 할지 개념화하는 데 도움이 될 수 있을 겁니다

430
00:09:37,990 --> 00:09:38,000
축소 유형 문제에 어떤 방법을 사용해야 할지 개념화하는 데 도움이 될 수 있을 겁니다
 

431
00:09:38,000 --> 00:09:39,590
축소 유형 문제에 어떤 방법을 사용해야 할지 개념화하는 데 도움이 될 수 있을 겁니다
.  이 부분은 잠시 후에 다시 이야기하겠지만,

432
00:09:39,590 --> 00:09:42,389
.  이 부분은 잠시 후에 다시 이야기하겠지만,
 

433
00:09:42,389 --> 00:09:45,509

 

434
00:09:45,509 --> 00:09:48,790

 

435
00:09:48,790 --> 00:09:48,800

 

436
00:09:48,800 --> 00:09:52,150

알고리즘이나 데이터

437
00:09:52,150 --> 00:09:52,160
알고리즘이나 데이터
 

438
00:09:52,160 --> 00:09:56,150
알고리즘이나 데이터
구조보다는 문제나 인터페이스로 단순화하는 것이 유용한 경우가 많습니다.  그게 무슨 뜻인가요?

439
00:09:56,150 --> 00:09:58,949
구조보다는 문제나 인터페이스로 단순화하는 것이 유용한 경우가 많습니다.  그게 무슨 뜻인가요?
 

440
00:09:58,949 --> 00:09:58,959

 

441
00:09:58,959 --> 00:10:02,230

정렬로 환원해서 문제를 해결할 수 있을까요?  저는

442
00:10:02,230 --> 00:10:02,240
정렬로 환원해서 문제를 해결할 수 있을까요?  저는
 

443
00:10:02,240 --> 00:10:03,910
정렬로 환원해서 문제를 해결할 수 있을까요?  저는
그 알고리즘이 옳다고 주장할 수 있습니다.  저는

444
00:10:03,910 --> 00:10:03,920
그 알고리즘이 옳다고 주장할 수 있습니다.  저는
 

445
00:10:03,920 --> 00:10:05,990
그 알고리즘이 옳다고 주장할 수 있습니다.  저는
정렬 과정을 마치 블랙박스처럼 사용합니다.  아니요,

446
00:10:05,990 --> 00:10:06,000
정렬 과정을 마치 블랙박스처럼 사용합니다.  아니요,
 

447
00:10:06,000 --> 00:10:08,389
정렬 과정을 마치 블랙박스처럼 사용합니다.  아니요,
효율적이지 않을 수도 있겠죠?

448
00:10:08,389 --> 00:10:08,399
효율적이지 않을 수도 있겠죠?
 

449
00:10:08,399 --> 00:10:10,310
효율적이지 않을 수도 있겠죠?
제가 선택한 정렬 알고리즘은

450
00:10:10,310 --> 00:10:10,320
제가 선택한 정렬 알고리즘은
 

451
00:10:10,320 --> 00:10:12,790
제가 선택한 정렬 알고리즘은
효율성 측면에서는 중요하지만,

452
00:10:12,790 --> 00:10:12,800
효율성 측면에서는 중요하지만,
 

453
00:10:12,800 --> 00:10:15,269
효율성 측면에서는 중요하지만,
정확성 측면에서는 중요하지 않죠.

454
00:10:15,269 --> 00:10:15,279
정확성 측면에서는 중요하지 않죠.
 

455
00:10:15,279 --> 00:10:18,470
정확성 측면에서는 중요하지 않죠.
데이터 구조 문제라면

456
00:10:18,470 --> 00:10:18,480
데이터 구조 문제라면
 

457
00:10:18,480 --> 00:10:21,590
데이터 구조 문제라면
두 개의 집합 데이터 구조

458
00:10:21,590 --> 00:10:21,600
두 개의 집합 데이터 구조
 

459
00:10:21,600 --> 00:10:23,190
두 개의 집합 데이터 구조
와 하나의 순차 데이터 구조 같은 걸로 단순화할 수도 있잖아요. 그렇게 단순화해도

460
00:10:23,190 --> 00:10:27,670
와 하나의 순차 데이터 구조 같은 걸로 단순화할 수도 있잖아요. 그렇게 단순화해도
 

461
00:10:27,670 --> 00:10:27,680

 

462
00:10:27,680 --> 00:10:29,829

정확하고요.

463
00:10:29,829 --> 00:10:32,069
정확하고요.
 

464
00:10:32,069 --> 00:10:32,079

 

465
00:10:32,079 --> 00:10:34,470

그런 인터페이스를 이용해서 연산을 정의할 수 있으니까요.

466
00:10:34,470 --> 00:10:34,480
그런 인터페이스를 이용해서 연산을 정의할 수 있으니까요.
 

467
00:10:34,480 --> 00:10:36,310
그런 인터페이스를 이용해서 연산을 정의할 수 있으니까요.

468
00:10:36,310 --> 00:10:38,230

 

469
00:10:38,230 --> 00:10:38,240

 

470
00:10:38,240 --> 00:10:39,990

실행 시간을 고려하기 전까지는 굳이 알고리즘을 선택할 필요가 없죠.  제가

471
00:10:39,990 --> 00:10:42,069
실행 시간을 고려하기 전까지는 굳이 알고리즘을 선택할 필요가 없죠.  제가
 

472
00:10:42,069 --> 00:10:42,079

 

473
00:10:42,079 --> 00:10:45,110

퀴즈에서 점수를 얻는 방법, 즉 효율성에 대해 이야기하기 전까지는

474
00:10:45,110 --> 00:10:45,120
퀴즈에서 점수를 얻는 방법, 즉 효율성에 대해 이야기하기 전까지는
 

475
00:10:45,120 --> 00:10:46,550
퀴즈에서 점수를 얻는 방법, 즉 효율성에 대해 이야기하기 전까지는
틀린 알고리즘에 대해 점수를 드릴 수 없겠죠

476
00:10:46,550 --> 00:10:46,560
틀린 알고리즘에 대해 점수를 드릴 수 없겠죠
 

477
00:10:46,560 --> 00:10:49,110
틀린 알고리즘에 대해 점수를 드릴 수 없겠죠
?  아니면 거의

478
00:10:49,110 --> 00:10:49,120
?  아니면 거의
 

479
00:10:49,120 --> 00:10:52,470
?  아니면 거의
정확한 무언가겠죠?  그리고 제시해주신

480
00:10:52,470 --> 00:10:54,389
정확한 무언가겠죠?  그리고 제시해주신
 

481
00:10:54,389 --> 00:10:54,399

 

482
00:10:54,399 --> 00:10:55,829

알고리즘이

483
00:10:55,829 --> 00:10:55,839
알고리즘이
 

484
00:10:55,839 --> 00:10:59,110
알고리즘이
효율적이지 않으면 만점을 드릴 수 없습니다. 그렇죠?  그리고

485
00:10:59,110 --> 00:10:59,120
효율적이지 않으면 만점을 드릴 수 없습니다. 그렇죠?  그리고
 

486
00:10:59,120 --> 00:11:00,790
효율적이지 않으면 만점을 드릴 수 없습니다. 그렇죠?  그리고
정확성이나 실행 시간

487
00:11:00,790 --> 00:11:00,800
정확성이나 실행 시간
 

488
00:11:00,800 --> 00:11:02,710
정확성이나 실행 시간
같은 것들을 두고 논쟁을 벌여오셨죠, 그렇죠?  여러분의

489
00:11:02,710 --> 00:11:02,720
같은 것들을 두고 논쟁을 벌여오셨죠, 그렇죠?  여러분의
 

490
00:11:02,720 --> 00:11:06,710
같은 것들을 두고 논쟁을 벌여오셨죠, 그렇죠?  여러분의
알고리즘이 정확하고

491
00:11:06,710 --> 00:11:06,720
알고리즘이 정확하고
 

492
00:11:06,720 --> 00:11:08,389
알고리즘이 정확하고
효율적일지라도 실행

493
00:11:08,389 --> 00:11:08,399
효율적일지라도 실행
 

494
00:11:08,399 --> 00:11:11,030
효율적일지라도 실행
시간을 잘못 분석하면 감점됩니다.

495
00:11:11,030 --> 00:11:11,040
시간을 잘못 분석하면 감점됩니다.
 

496
00:11:11,040 --> 00:11:14,069
시간을 잘못 분석하면 감점됩니다.
또는 대부분의 경우

497
00:11:14,069 --> 00:11:15,590
또는 대부분의 경우
 

498
00:11:15,590 --> 00:11:15,600

 

499
00:11:15,600 --> 00:11:18,310

비효율적인 알고리즘을 제시하고는

500
00:11:18,310 --> 00:11:18,320
비효율적인 알고리즘을 제시하고는
 

501
00:11:18,320 --> 00:11:20,150
비효율적인 알고리즘을 제시하고는
마치

502
00:11:20,150 --> 00:11:20,160
마치
 

503
00:11:20,160 --> 00:11:22,150
마치
우리가 제시한 목표 실행 시간인 것처럼 분석하죠. 이는

504
00:11:22,150 --> 00:11:22,160
우리가 제시한 목표 실행 시간인 것처럼 분석하죠. 이는
 

505
00:11:22,160 --> 00:11:25,190
우리가 제시한 목표 실행 시간인 것처럼 분석하죠. 이는
두 가지 측면에서 좋지 않습니다.

506
00:11:25,190 --> 00:11:25,200
두 가지 측면에서 좋지 않습니다.
 

507
00:11:25,200 --> 00:11:27,509
두 가지 측면에서 좋지 않습니다.
그러니 이런 함정에 빠지지 않도록 주의하세요.

508
00:11:27,509 --> 00:11:29,350
그러니 이런 함정에 빠지지 않도록 주의하세요.
 

509
00:11:29,350 --> 00:11:30,949

 

510
00:11:30,949 --> 00:11:30,959

 

511
00:11:30,959 --> 00:11:31,750

시험을 치르기 전에 몇 가지 일반적인 전략을 말씀드리자면, 시험을

512
00:11:31,750 --> 00:11:34,069
시험을 치르기 전에 몇 가지 일반적인 전략을 말씀드리자면, 시험을
 

513
00:11:34,069 --> 00:11:35,750

 

514
00:11:35,750 --> 00:11:35,760

 

515
00:11:35,760 --> 00:11:38,389

시작하기 전에 전체 문제를 꼼꼼히 읽어보시기를 강력히 권합니다.  어떤

516
00:11:38,389 --> 00:11:38,399
시작하기 전에 전체 문제를 꼼꼼히 읽어보시기를 강력히 권합니다.  어떤
 

517
00:11:38,399 --> 00:11:39,910
시작하기 전에 전체 문제를 꼼꼼히 읽어보시기를 강력히 권합니다.  어떤
문제는

518
00:11:39,910 --> 00:11:39,920
문제는
 

519
00:11:39,920 --> 00:11:43,750
문제는
다른 문제보다 해결하기 쉬울 것이기 때문입니다.  그리고

520
00:11:43,750 --> 00:11:43,760
다른 문제보다 해결하기 쉬울 것이기 때문입니다.  그리고
 

521
00:11:43,760 --> 00:11:46,230
다른 문제보다 해결하기 쉬울 것이기 때문입니다.  그리고
여러분 모두가 그렇듯이, 여기서 최대한 많은 점수를 얻으려고 노력한다면,

522
00:11:46,230 --> 00:11:49,990
여러분 모두가 그렇듯이, 여기서 최대한 많은 점수를 얻으려고 노력한다면,
 

523
00:11:49,990 --> 00:11:50,000

 

524
00:11:50,000 --> 00:11:52,230

처음에

525
00:11:52,230 --> 00:11:52,240
처음에
 

526
00:11:52,240 --> 00:11:53,990
처음에
문제를 한 바퀴 돌아보고 어떤 문제가

527
00:11:53,990 --> 00:11:54,000
문제를 한 바퀴 돌아보고 어떤 문제가
 

528
00:11:54,000 --> 00:11:56,150
문제를 한 바퀴 돌아보고 어떤 문제가
가장 쉬운지 확인하는 것이 유용할 것입니다.  그런 다음 자신이

529
00:11:56,150 --> 00:11:58,790
가장 쉬운지 확인하는 것이 유용할 것입니다.  그런 다음 자신이
 

530
00:11:58,790 --> 00:11:58,800

 

531
00:11:58,800 --> 00:12:01,509

자신 있는 순서대로 문제를 해결하면 됩니다.  사실,

532
00:12:01,509 --> 00:12:01,519
자신 있는 순서대로 문제를 해결하면 됩니다.  사실,
 

533
00:12:01,519 --> 00:12:04,790
자신 있는 순서대로 문제를 해결하면 됩니다.  사실,
이 수업의 첫 번째 퀴즈 평균 점수는 대략

534
00:12:04,790 --> 00:12:07,750
이 수업의 첫 번째 퀴즈 평균 점수는 대략
 

535
00:12:07,750 --> 00:12:07,760

 

536
00:12:07,760 --> 00:12:09,670

60점에서 80점 사이인 것 같아요. 80점을 넘은 적은 없는 것 같지만, 어쨌든

537
00:12:09,670 --> 00:12:12,310
60점에서 80점 사이인 것 같아요. 80점을 넘은 적은 없는 것 같지만, 어쨌든
 

538
00:12:12,310 --> 00:12:12,320

 

539
00:12:12,320 --> 00:12:16,310

100점은 아니잖아요?  그러니까

540
00:12:16,310 --> 00:12:16,320
100점은 아니잖아요?  그러니까
 

541
00:12:16,320 --> 00:12:21,269
100점은 아니잖아요?  그러니까
문제의 50%만 잘 푸는 게

542
00:12:21,269 --> 00:12:23,350
문제의 50%만 잘 푸는 게
 

543
00:12:23,350 --> 00:12:23,360

 

544
00:12:23,360 --> 00:12:25,110

시간 관리나 그런 면에서 훨씬 나을

545
00:12:25,110 --> 00:12:27,829
시간 관리나 그런 면에서 훨씬 나을
 

546
00:12:27,829 --> 00:12:29,590

 

547
00:12:29,590 --> 00:12:32,389

 

548
00:12:32,389 --> 00:12:32,399

 

549
00:12:32,399 --> 00:12:34,949

거예요. 모든 문제를 다 풀려고 시도하지만 제대로 풀지 못하는 것보다는요.

550
00:12:34,949 --> 00:12:34,959
거예요. 모든 문제를 다 풀려고 시도하지만 제대로 풀지 못하는 것보다는요.
 

551
00:12:34,959 --> 00:12:36,470
거예요. 모든 문제를 다 풀려고 시도하지만 제대로 풀지 못하는 것보다는요.
컴퓨터 과학에서는 정답에

552
00:12:36,470 --> 00:12:36,480
컴퓨터 과학에서는 정답에
 

553
00:12:36,480 --> 00:12:38,470
컴퓨터 과학에서는 정답에
아주 가까워야 점수를 얻을 수 있거든요. 거의

554
00:12:38,470 --> 00:12:42,069
아주 가까워야 점수를 얻을 수 있거든요. 거의
 

555
00:12:42,069 --> 00:12:42,079

 

556
00:12:42,079 --> 00:12:45,030

정답에 가까워야만 점수를 받을 수 있어요. 채점 방식을 보셨다면 아시겠지만

557
00:12:45,030 --> 00:12:46,710
정답에 가까워야만 점수를 받을 수 있어요. 채점 방식을 보셨다면 아시겠지만
 

558
00:12:46,710 --> 00:12:46,720

 

559
00:12:46,720 --> 00:12:48,550

, 가끔

560
00:12:48,550 --> 00:12:48,560
, 가끔
 

561
00:12:48,560 --> 00:12:51,430
, 가끔
채점자들이 실수를 하기도 해요.  때로는

562
00:12:51,430 --> 00:12:54,629
채점자들이 실수를 하기도 해요.  때로는
 

563
00:12:54,629 --> 00:12:54,639

 

564
00:12:54,639 --> 00:12:57,110

틀린 답에도 점수를 주기도 하잖아요, 그렇죠?  여러분이 저희에게

565
00:12:57,110 --> 00:12:59,430
틀린 답에도 점수를 주기도 하잖아요, 그렇죠?  여러분이 저희에게
 

566
00:12:59,430 --> 00:12:59,440

 

567
00:12:59,440 --> 00:13:01,590

제시한 문제와

568
00:13:01,590 --> 00:13:01,600
제시한 문제와
 

569
00:13:01,600 --> 00:13:03,590
제시한 문제와
저희가 제시한 해결책을 다시 한번 살펴보는 것은 전적으로 여러분의 몫입니다.  저희는

570
00:13:03,590 --> 00:13:03,600
저희가 제시한 해결책을 다시 한번 살펴보는 것은 전적으로 여러분의 몫입니다.  저희는
 

571
00:13:03,600 --> 00:13:06,389
저희가 제시한 해결책을 다시 한번 살펴보는 것은 전적으로 여러분의 몫입니다.  저희는
여러분을 위해 좋은 해결책을 마련하는 데 많은 시간을 투자합니다.

572
00:13:06,389 --> 00:13:07,670
여러분을 위해 좋은 해결책을 마련하는 데 많은 시간을 투자합니다.
 

573
00:13:07,670 --> 00:13:07,680

 

574
00:13:07,680 --> 00:13:09,509

내용을 확실히 숙지해야 합니다.

575
00:13:09,509 --> 00:13:09,519
내용을 확실히 숙지해야 합니다.
 

576
00:13:09,519 --> 00:13:11,990
내용을 확실히 숙지해야 합니다.
시험이 끝난 후

577
00:13:11,990 --> 00:13:12,000
시험이 끝난 후
 

578
00:13:12,000 --> 00:13:15,509
시험이 끝난 후
"아, 제가

579
00:13:15,509 --> 00:13:15,519
"아, 제가
 

580
00:13:15,519 --> 00:13:17,509
"아, 제가
문제 풀이에 똑같은 내용을 썼는데 정답으로 채점됐는데

581
00:13:17,509 --> 00:13:17,519
문제 풀이에 똑같은 내용을 썼는데 정답으로 채점됐는데
 

582
00:13:17,519 --> 00:13:19,829
문제 풀이에 똑같은 내용을 썼는데 정답으로 채점됐는데
오답으로 채점됐어요."라고 말하며 우리에게 오지 마세요.  네,

583
00:13:19,829 --> 00:13:19,839
오답으로 채점됐어요."라고 말하며 우리에게 오지 마세요.  네,
 

584
00:13:19,839 --> 00:13:21,750
오답으로 채점됐어요."라고 말하며 우리에게 오지 마세요.  네,
맞습니다. 저희 직원들은 과제

585
00:13:21,750 --> 00:13:21,760
맞습니다. 저희 직원들은 과제
 

586
00:13:21,760 --> 00:13:24,310
맞습니다. 저희 직원들은 과제
채점자들보다 알고리즘에 대해 조금 더 잘 알고 있고,

587
00:13:24,310 --> 00:13:26,069
채점자들보다 알고리즘에 대해 조금 더 잘 알고 있고,
 

588
00:13:26,069 --> 00:13:26,079

 

589
00:13:26,079 --> 00:13:28,389

시험 채점도 저희가 합니다.  그래서 유감스럽게도 그건

590
00:13:28,389 --> 00:13:28,399
시험 채점도 저희가 합니다.  그래서 유감스럽게도 그건
 

591
00:13:28,399 --> 00:13:30,150
시험 채점도 저희가 합니다.  그래서 유감스럽게도 그건
변명이 될 수 없겠죠?  내용을 숙지하는 것은 당신의 몫입니다

592
00:13:30,150 --> 00:13:30,160
변명이 될 수 없겠죠?  내용을 숙지하는 것은 당신의 몫입니다
 

593
00:13:30,160 --> 00:13:33,430
변명이 될 수 없겠죠?  내용을 숙지하는 것은 당신의 몫입니다
.  네.

594
00:13:33,430 --> 00:13:33,440
.  네.
 

595
00:13:33,440 --> 00:13:35,110
.  네.
시험 문제 대부분이

596
00:13:35,110 --> 00:13:35,120
시험 문제 대부분이
 

597
00:13:35,120 --> 00:13:36,629
시험 문제 대부분이
여러 부분으로 나뉘어 있어서,

598
00:13:36,629 --> 00:13:38,230
여러 부분으로 나뉘어 있어서,
 

599
00:13:38,230 --> 00:13:38,240

 

600
00:13:38,240 --> 00:13:39,590

앞부분 몇 개를 잘 풀어야

601
00:13:39,590 --> 00:13:39,600
앞부분 몇 개를 잘 풀어야
 

602
00:13:39,600 --> 00:13:41,190
앞부분 몇 개를 잘 풀어야
나머지

603
00:13:41,190 --> 00:13:41,200
나머지
 

604
00:13:41,200 --> 00:13:44,069
나머지
부분에서 부분 점수라도 받을 수 있는 그런 유형인가요? 아니면 문제가 순차적으로 쌓여서

605
00:13:44,069 --> 00:13:48,470
부분에서 부분 점수라도 받을 수 있는 그런 유형인가요? 아니면 문제가 순차적으로 쌓여서
 

606
00:13:48,470 --> 00:13:51,829

 

607
00:13:51,829 --> 00:13:53,670

 

608
00:13:53,670 --> 00:13:53,680

 

609
00:13:53,680 --> 00:13:55,910

첫 부분을 틀리면 더 이상 진행할 수 없는 그런 유형인가요? 저희는 그런 식으로 시험을 설계하지 않으려고 노력합니다.

610
00:13:55,910 --> 00:13:57,910
첫 부분을 틀리면 더 이상 진행할 수 없는 그런 유형인가요? 저희는 그런 식으로 시험을 설계하지 않으려고 노력합니다.
 

611
00:13:57,910 --> 00:13:59,750

 

612
00:13:59,750 --> 00:13:59,760

 

613
00:13:59,760 --> 00:14:01,269

이미 게시된 연습 시험을 한번 살펴보셔도 좋습니다.

614
00:14:01,269 --> 00:14:01,279
이미 게시된 연습 시험을 한번 살펴보셔도 좋습니다.
 

615
00:14:01,279 --> 00:14:03,590
이미 게시된 연습 시험을 한번 살펴보셔도 좋습니다.
우리가 직면한 문제들은 대개

616
00:14:03,590 --> 00:14:03,600
우리가 직면한 문제들은 대개
 

617
00:14:03,600 --> 00:14:06,310
우리가 직면한 문제들은 대개
자체적으로 완결성을 지니고 있으며, 여러

618
00:14:06,310 --> 00:14:06,320
자체적으로 완결성을 지니고 있으며, 여러
 

619
00:14:06,320 --> 00:14:08,150
자체적으로 완결성을 지니고 있으며, 여러
부분으로 구성되어 있더라도 각 부분은 일반적으로

620
00:14:08,150 --> 00:14:08,160
부분으로 구성되어 있더라도 각 부분은 일반적으로
 

621
00:14:08,160 --> 00:14:09,670
부분으로 구성되어 있더라도 각 부분은 일반적으로
독립적입니다.

622
00:14:09,670 --> 00:14:09,680
독립적입니다.
 

623
00:14:09,680 --> 00:14:11,910
독립적입니다.
오른쪽?  일반적으로

624
00:14:11,910 --> 00:14:11,920
오른쪽?  일반적으로
 

625
00:14:11,920 --> 00:14:14,230
오른쪽?  일반적으로
B를 정확하게 수행하기 위해 A를 정확하게 수행할 필요는 없습니다

626
00:14:14,230 --> 00:14:14,240
B를 정확하게 수행하기 위해 A를 정확하게 수행할 필요는 없습니다
 

627
00:14:14,240 --> 00:14:16,790
B를 정확하게 수행하기 위해 A를 정확하게 수행할 필요는 없습니다
.  오른쪽?  그리고 저희 문제집도 그런 방식으로

628
00:14:16,790 --> 00:14:16,800
.  오른쪽?  그리고 저희 문제집도 그런 방식으로
 

629
00:14:16,800 --> 00:14:18,389
.  오른쪽?  그리고 저희 문제집도 그런 방식으로
작성하려고 노력합니다.

630
00:14:18,389 --> 00:14:18,399
작성하려고 노력합니다.
 

631
00:14:18,399 --> 00:14:21,670
작성하려고 노력합니다.
오른쪽?

632
00:14:21,670 --> 00:14:21,680
오른쪽?
 

633
00:14:21,680 --> 00:14:24,069
오른쪽?
P 세트 4에 대한 마지막 코딩 문제 맞죠?

634
00:14:24,069 --> 00:14:24,079
P 세트 4에 대한 마지막 코딩 문제 맞죠?
 

635
00:14:24,079 --> 00:14:25,430
P 세트 4에 대한 마지막 코딩 문제 맞죠?
데이터

636
00:14:25,430 --> 00:14:25,440
데이터
 

637
00:14:25,440 --> 00:14:28,629
데이터
구조를 설계해야 하는 문제가 있었잖아요, 그렇죠?  하지만 C는 그걸

638
00:14:28,629 --> 00:14:28,639
구조를 설계해야 하는 문제가 있었잖아요, 그렇죠?  하지만 C는 그걸
 

639
00:14:28,639 --> 00:14:30,949
구조를 설계해야 하는 문제가 있었잖아요, 그렇죠?  하지만 C는 그걸
사실상 블랙박스처럼 사용해서

640
00:14:30,949 --> 00:14:30,959
사실상 블랙박스처럼 사용해서
 

641
00:14:30,959 --> 00:14:33,269
사실상 블랙박스처럼 사용해서
문제를 해결하라고 했습니다.  오른쪽?  그러니까

642
00:14:33,269 --> 00:14:33,279
문제를 해결하라고 했습니다.  오른쪽?  그러니까
 

643
00:14:33,279 --> 00:14:35,509
문제를 해결하라고 했습니다.  오른쪽?  그러니까
저희가 이 인터페이스를 제공했다는 사실을 굳이 보여주실 필요는 없습니다

644
00:14:35,509 --> 00:14:35,519
저희가 이 인터페이스를 제공했다는 사실을 굳이 보여주실 필요는 없습니다
 

645
00:14:35,519 --> 00:14:37,990
저희가 이 인터페이스를 제공했다는 사실을 굳이 보여주실 필요는 없습니다
.  오른쪽?  해당 인터페이스를 사용하면

646
00:14:37,990 --> 00:14:40,790
.  오른쪽?  해당 인터페이스를 사용하면
 

647
00:14:40,790 --> 00:14:43,670

 

648
00:14:43,670 --> 00:14:43,680

 

649
00:14:43,680 --> 00:14:45,590

자료구조 문제를 정확하게 풀지 않고도 알고리즘 문제에 대한 C 언어 답을 맞힐 수 있습니다.

650
00:14:45,590 --> 00:14:45,600
자료구조 문제를 정확하게 풀지 않고도 알고리즘 문제에 대한 C 언어 답을 맞힐 수 있습니다.
 

651
00:14:45,600 --> 00:14:47,829
자료구조 문제를 정확하게 풀지 않고도 알고리즘 문제에 대한 C 언어 답을 맞힐 수 있습니다.
이해가 되시나요?  사실

652
00:14:47,829 --> 00:14:47,839
이해가 되시나요?  사실
 

653
00:14:47,839 --> 00:14:49,430
이해가 되시나요?  사실
알고리즘 문제 중에서 그게 제일

654
00:14:49,430 --> 00:14:49,440
알고리즘 문제 중에서 그게 제일
 

655
00:14:49,440 --> 00:14:51,590
알고리즘 문제 중에서 그게 제일
쉬운 문제였던 것 같아요

656
00:14:51,590 --> 00:14:51,600
쉬운 문제였던 것 같아요
 

657
00:14:51,600 --> 00:14:53,590
쉬운 문제였던 것 같아요
.  응.

658
00:14:53,590 --> 00:14:53,600
.  응.
 

659
00:14:53,600 --> 00:14:55,509
.  응.
시험에서 코드를 작성해야 하나요?  시험에서 코드를 작성해야 하나요

660
00:14:55,509 --> 00:14:55,519
시험에서 코드를 작성해야 하나요?  시험에서 코드를 작성해야 하나요
 

661
00:14:55,519 --> 00:14:59,430
시험에서 코드를 작성해야 하나요?  시험에서 코드를 작성해야 하나요
?  음, 저는

662
00:14:59,430 --> 00:15:01,829
?  음, 저는
 

663
00:15:01,829 --> 00:15:01,839

 

664
00:15:01,839 --> 00:15:05,750

코드를 작성해야 하는 시험을 본 적이 없어요.  저는

665
00:15:05,750 --> 00:15:05,760
코드를 작성해야 하는 시험을 본 적이 없어요.  저는
 

666
00:15:05,760 --> 00:15:08,949
코드를 작성해야 하는 시험을 본 적이 없어요.  저는
코드를 읽어야 하는 시험을 본 적이 있습니다.  좋아요.  그럼

667
00:15:08,949 --> 00:15:08,959
코드를 읽어야 하는 시험을 본 적이 있습니다.  좋아요.  그럼
 

668
00:15:08,959 --> 00:15:11,590
코드를 읽어야 하는 시험을 본 적이 있습니다.  좋아요.  그럼
의사 코드나 파이썬 코드를 사용하면 되겠죠?

669
00:15:11,590 --> 00:15:11,600
의사 코드나 파이썬 코드를 사용하면 되겠죠?
 

670
00:15:11,600 --> 00:15:13,350
의사 코드나 파이썬 코드를 사용하면 되겠죠?
파이썬은 이 수업의 필수 과목이므로,

671
00:15:13,350 --> 00:15:15,189
파이썬은 이 수업의 필수 과목이므로,
 

672
00:15:15,189 --> 00:15:15,199

 

673
00:15:15,199 --> 00:15:16,949

여러분에게 파이썬 코드 조각을 제공하고

674
00:15:16,949 --> 00:15:16,959
여러분에게 파이썬 코드 조각을 제공하고
 

675
00:15:16,959 --> 00:15:18,710
여러분에게 파이썬 코드 조각을 제공하고
여러분이 그 내용을 이해할 수 있어야 한다는 것은 당연한 일입니다

676
00:15:18,710 --> 00:15:18,720
여러분이 그 내용을 이해할 수 있어야 한다는 것은 당연한 일입니다
 

677
00:15:18,720 --> 00:15:21,430
여러분이 그 내용을 이해할 수 있어야 한다는 것은 당연한 일입니다
.

678
00:15:21,430 --> 00:15:21,440
.
 

679
00:15:21,440 --> 00:15:24,629
.
응.  음,

680
00:15:24,629 --> 00:15:24,639
응.  음,
 

681
00:15:24,639 --> 00:15:27,670
응.  음,
수정 메뉴 아래에 나열되어 있네요.  그러니까, 예를 들어

682
00:15:27,670 --> 00:15:27,680
수정 메뉴 아래에 나열되어 있네요.  그러니까, 예를 들어
 

683
00:15:27,680 --> 00:15:30,550
수정 메뉴 아래에 나열되어 있네요.  그러니까, 예를 들어
상각된 메모리를 사용하는 경우, 상각은

684
00:15:30,550 --> 00:15:35,269
상각된 메모리를 사용하는 경우, 상각은
 

685
00:15:35,269 --> 00:15:35,279

 

686
00:15:35,279 --> 00:15:37,750

분명히 이런 부분에 나타나죠. 예를 들어

687
00:15:37,750 --> 00:15:39,990
분명히 이런 부분에 나타나죠. 예를 들어
 

688
00:15:39,990 --> 00:15:40,000

 

689
00:15:40,000 --> 00:15:41,990

동적 배열이나 바이너리 힙,

690
00:15:41,990 --> 00:15:42,000
동적 배열이나 바이너리 힙,
 

691
00:15:42,000 --> 00:15:43,829
동적 배열이나 바이너리 힙,
해시 테이블을 사용할 때, 이러한 동적 연산에서 상각이

692
00:15:43,829 --> 00:15:45,670
해시 테이블을 사용할 때, 이러한 동적 연산에서 상각이
 

693
00:15:45,670 --> 00:15:45,680

 

694
00:15:45,680 --> 00:15:47,990

실행 시간에 영향을 미치는 거죠. 여기서 상각이라는 건, 예를 들어

695
00:15:47,990 --> 00:15:49,590
실행 시간에 영향을 미치는 거죠. 여기서 상각이라는 건, 예를 들어
 

696
00:15:49,590 --> 00:15:52,230

 

697
00:15:52,230 --> 00:15:54,069

 

698
00:15:54,069 --> 00:15:54,079

 

699
00:15:54,079 --> 00:15:56,470

동적 배열에서처럼 끝에

700
00:15:56,470 --> 00:15:56,480
동적 배열에서처럼 끝에
 

701
00:15:56,480 --> 00:15:59,430
동적 배열에서처럼 끝에
공간을 추가하는 대신

702
00:15:59,430 --> 00:16:01,430
공간을 추가하는 대신
 

703
00:16:01,430 --> 00:16:01,440

 

704
00:16:01,440 --> 00:16:03,910

중간이나 처음에 공간을 추가하는 방식을 일반화해 달라는 뜻인가요?

705
00:16:03,910 --> 00:16:03,920
중간이나 처음에 공간을 추가하는 방식을 일반화해 달라는 뜻인가요?
 

706
00:16:03,920 --> 00:16:05,269
중간이나 처음에 공간을 추가하는 방식을 일반화해 달라는 뜻인가요?
그리고 여러분은

707
00:16:05,269 --> 00:16:05,279
그리고 여러분은
 

708
00:16:05,279 --> 00:16:08,150
그리고 여러분은
일종의 상각 분석을 해야 할 겁니다.

709
00:16:08,150 --> 00:16:11,990
일종의 상각 분석을 해야 할 겁니다.
 

710
00:16:11,990 --> 00:16:12,000

 

711
00:16:12,000 --> 00:16:15,990

물론, 이렇게 할 필요가 없는 경우가 많죠?

712
00:16:15,990 --> 00:16:16,000
물론, 이렇게 할 필요가 없는 경우가 많죠?
 

713
00:16:16,000 --> 00:16:18,710
물론, 이렇게 할 필요가 없는 경우가 많죠?
우리가

714
00:16:18,710 --> 00:16:18,720
우리가
 

715
00:16:18,720 --> 00:16:20,550
우리가
상각 분석을 직접 수행하고

716
00:16:20,550 --> 00:16:20,560
상각 분석을 직접 수행하고
 

717
00:16:20,560 --> 00:16:23,269
상각 분석을 직접 수행하고
양단 증권을 만드는 문제에 대해 이야기했을 때 말이죠.  그러니까,

718
00:16:23,269 --> 00:16:23,279
양단 증권을 만드는 문제에 대해 이야기했을 때 말이죠.  그러니까,
 

719
00:16:23,279 --> 00:16:25,509
양단 증권을 만드는 문제에 대해 이야기했을 때 말이죠.  그러니까,
양방향 대기열을 말하는 거예요.

720
00:16:25,509 --> 00:16:25,519
양방향 대기열을 말하는 거예요.
 

721
00:16:25,519 --> 00:16:27,350
양방향 대기열을 말하는 거예요.
사실

722
00:16:27,350 --> 00:16:27,360
사실
 

723
00:16:27,360 --> 00:16:29,590
사실
두 개의

724
00:16:29,590 --> 00:16:29,600
두 개의
 

725
00:16:29,600 --> 00:16:32,870
두 개의
동적 배열을 사용하는 방식으로 해결할 수 있습니다.  오른쪽?  그러니까

726
00:16:32,870 --> 00:16:35,110
동적 배열을 사용하는 방식으로 해결할 수 있습니다.  오른쪽?  그러니까
 

727
00:16:35,110 --> 00:16:35,120

 

728
00:16:35,120 --> 00:16:37,269


729
00:16:37,269 --> 00:16:37,279

 

730
00:16:37,279 --> 00:16:39,670

사용량을 줄이는 방법은 여러 가지가 있지만,

731
00:16:39,670 --> 00:16:40,949
사용량을 줄이는 방법은 여러 가지가 있지만,
 

732
00:16:40,949 --> 00:16:40,959

 

733
00:16:40,959 --> 00:16:43,110

마지막에 추가적인 회계 처리가 필요할 수도 있습니다.  오른쪽?  하지만

734
00:16:43,110 --> 00:16:43,120
마지막에 추가적인 회계 처리가 필요할 수도 있습니다.  오른쪽?  하지만
 

735
00:16:43,120 --> 00:16:46,790
마지막에 추가적인 회계 처리가 필요할 수도 있습니다.  오른쪽?  하지만
이것이 의미하는 바는, 이것들을

736
00:16:46,790 --> 00:16:46,800
이것이 의미하는 바는, 이것들을
 

737
00:16:46,800 --> 00:16:48,470
이것이 의미하는 바는, 이것들을
블랙박스처럼 사용하지 않는다는 것입니다.

738
00:16:48,470 --> 00:16:48,480
블랙박스처럼 사용하지 않는다는 것입니다.
 

739
00:16:48,480 --> 00:16:50,310
블랙박스처럼 사용하지 않는다는 것입니다.
당신은

740
00:16:50,310 --> 00:16:50,320
당신은
 

741
00:16:50,320 --> 00:16:52,470
당신은
우리가 드린 상자들을 뭔가 바꾸고 있군요.  오른쪽?

742
00:16:52,470 --> 00:16:52,480
우리가 드린 상자들을 뭔가 바꾸고 있군요.  오른쪽?
 

743
00:16:52,480 --> 00:16:55,670
우리가 드린 상자들을 뭔가 바꾸고 있군요.  오른쪽?
이해가 되시나요?  네, 만약 저희에게

744
00:16:55,670 --> 00:16:57,509
이해가 되시나요?  네, 만약 저희에게
 

745
00:16:57,509 --> 00:16:57,519

 

746
00:16:57,519 --> 00:17:00,710

log n 시간 복잡도를 갖는 알고리즘을 작성하라고 하셨는데,

747
00:17:00,710 --> 00:17:02,069
log n 시간 복잡도를 갖는 알고리즘을 작성하라고 하셨는데,
 

748
00:17:02,069 --> 00:17:02,079

 

749
00:17:02,079 --> 00:17:04,789

비효율적인 end 시간 복잡도를 갖는 알고리즘밖에 떠오르지 않는다면요.  좋아요.  그렇다면

750
00:17:04,789 --> 00:17:04,799
비효율적인 end 시간 복잡도를 갖는 알고리즘밖에 떠오르지 않는다면요.  좋아요.  그렇다면
 

751
00:17:04,799 --> 00:17:06,949
비효율적인 end 시간 복잡도를 갖는 알고리즘밖에 떠오르지 않는다면요.  좋아요.  그렇다면
그런 글을 쓰는 게 무슨 의미가 있을까요?  확신하는.

752
00:17:06,949 --> 00:17:06,959
그런 글을 쓰는 게 무슨 의미가 있을까요?  확신하는.
 

753
00:17:06,959 --> 00:17:11,189
그런 글을 쓰는 게 무슨 의미가 있을까요?  확신하는.
그럼 잠시 다른 이야기로 넘어가 볼까요?

754
00:17:11,189 --> 00:17:11,199
그럼 잠시 다른 이야기로 넘어가 볼까요?
 

755
00:17:11,199 --> 00:17:16,470
그럼 잠시 다른 이야기로 넘어가 볼까요?
사실, 제가 곧

756
00:17:16,470 --> 00:17:16,480

 

757
00:17:16,480 --> 00:17:18,309

당신의 질문에 답변해 드리겠습니다

758
00:17:18,309 --> 00:17:18,319
당신의 질문에 답변해 드리겠습니다
 

759
00:17:18,319 --> 00:17:21,590
당신의 질문에 답변해 드리겠습니다
.  좋아요.  음, 하지만 그건 잠시 후에 얘기할게요

760
00:17:21,590 --> 00:17:21,600
.  좋아요.  음, 하지만 그건 잠시 후에 얘기할게요
 

761
00:17:21,600 --> 00:17:23,750
.  좋아요.  음, 하지만 그건 잠시 후에 얘기할게요
.  좋아요.  괜찮으시다면, 제가

762
00:17:23,750 --> 00:17:23,760
.  좋아요.  괜찮으시다면, 제가
 

763
00:17:23,760 --> 00:17:25,829
.  좋아요.  괜찮으시다면, 제가
5분 안에 그 질문에 답하지 못하더라도

764
00:17:25,829 --> 00:17:25,839
5분 안에 그 질문에 답하지 못하더라도
 

765
00:17:25,839 --> 00:17:28,710
5분 안에 그 질문에 답하지 못하더라도
알려주세요.  좋아요.  그래서

766
00:17:28,710 --> 00:17:30,470
알려주세요.  좋아요.  그래서
 

767
00:17:30,470 --> 00:17:30,480

 

768
00:17:30,480 --> 00:17:33,750

시험 문제를 풀 때 제가 제일 먼저 하는 일은

769
00:17:33,750 --> 00:17:33,760
시험 문제를 풀 때 제가 제일 먼저 하는 일은
 

770
00:17:33,760 --> 00:17:35,830
시험 문제를 풀 때 제가 제일 먼저 하는 일은
문제에 대해 몇 가지 질문을 던져보는 것입니다.

771
00:17:35,830 --> 00:17:35,840
문제에 대해 몇 가지 질문을 던져보는 것입니다.
 

772
00:17:35,840 --> 00:17:37,669
문제에 대해 몇 가지 질문을 던져보는 것입니다.
좋아요?  어떤 걸 사용할지 결정하는 데 도움이 되겠죠

773
00:17:37,669 --> 00:17:37,679
좋아요?  어떤 걸 사용할지 결정하는 데 도움이 되겠죠
 

774
00:17:37,679 --> 00:17:40,070
좋아요?  어떤 걸 사용할지 결정하는 데 도움이 되겠죠
?  여러분이

775
00:17:40,070 --> 00:17:40,080
?  여러분이
 

776
00:17:40,080 --> 00:17:42,950
?  여러분이
풀었던 문제들과는 다르죠, 그렇죠?  여러분의 문제 풀이에서

777
00:17:42,950 --> 00:17:42,960
풀었던 문제들과는 다르죠, 그렇죠?  여러분의 문제 풀이에서
 

778
00:17:42,960 --> 00:17:45,270
풀었던 문제들과는 다르죠, 그렇죠?  여러분의 문제 풀이에서
기본적으로 활용하는 것은

779
00:17:45,270 --> 00:17:45,280
기본적으로 활용하는 것은
 

780
00:17:45,280 --> 00:17:47,190
기본적으로 활용하는 것은
그 주 강의에서 다룬 내용이죠, 그렇죠?

781
00:17:47,190 --> 00:17:47,200
그 주 강의에서 다룬 내용이죠, 그렇죠?
 

782
00:17:47,200 --> 00:17:49,430
그 주 강의에서 다룬 내용이죠, 그렇죠?
퀴즈에서 여러분은 지금까지 다룬 8개의 강의 내용을 풀어야 합니다

783
00:17:49,430 --> 00:17:49,440
퀴즈에서 여러분은 지금까지 다룬 8개의 강의 내용을 풀어야 합니다
 

784
00:17:49,440 --> 00:17:51,990
퀴즈에서 여러분은 지금까지 다룬 8개의 강의 내용을 풀어야 합니다
.  그래서 이건

785
00:17:51,990 --> 00:17:52,000
.  그래서 이건
 

786
00:17:52,000 --> 00:17:53,430
.  그래서 이건
당신이 하기에 더 어려운 일이 될 거예요

787
00:17:53,430 --> 00:17:53,440
당신이 하기에 더 어려운 일이 될 거예요
 

788
00:17:53,440 --> 00:17:55,190
당신이 하기에 더 어려운 일이 될 거예요
, 그렇죠?

789
00:17:55,190 --> 00:17:55,200
, 그렇죠?
 

790
00:17:55,200 --> 00:17:57,029
, 그렇죠?
8개의 강의 자료 중 어떤 것이

791
00:17:57,029 --> 00:17:57,039
8개의 강의 자료 중 어떤 것이
 

792
00:17:57,039 --> 00:17:58,390
8개의 강의 자료 중 어떤 것이
이 문제에 적용될지 모르기 때문입니다.

793
00:17:58,390 --> 00:17:58,400
이 문제에 적용될지 모르기 때문입니다.
 

794
00:17:58,400 --> 00:17:59,750
이 문제에 적용될지 모르기 때문입니다.
사실 그 두 가지가 복합적으로 작용한 결과일 수도 있겠죠

795
00:17:59,750 --> 00:17:59,760
사실 그 두 가지가 복합적으로 작용한 결과일 수도 있겠죠
 

796
00:17:59,760 --> 00:18:01,750
사실 그 두 가지가 복합적으로 작용한 결과일 수도 있겠죠
?  그래서 저는 여러분이

797
00:18:01,750 --> 00:18:01,760
?  그래서 저는 여러분이
 

798
00:18:01,760 --> 00:18:04,390
?  그래서 저는 여러분이
그 질문에 더 빨리 답할 수 있는 방법을 알려드리려고 합니다.

799
00:18:04,390 --> 00:18:04,400
그 질문에 더 빨리 답할 수 있는 방법을 알려드리려고 합니다.
 

800
00:18:04,400 --> 00:18:07,350
그 질문에 더 빨리 답할 수 있는 방법을 알려드리려고 합니다.
좋아요?  음, 이건 기계적인

801
00:18:07,350 --> 00:18:07,360
좋아요?  음, 이건 기계적인
 

802
00:18:07,360 --> 00:18:08,950
좋아요?  음, 이건 기계적인
축소 유형 문제인가요, 아니면 수정 유형 문제인가요?

803
00:18:08,950 --> 00:18:08,960
축소 유형 문제인가요, 아니면 수정 유형 문제인가요?
 

804
00:18:08,960 --> 00:18:10,549
축소 유형 문제인가요, 아니면 수정 유형 문제인가요?
그건 제가 이 문제의 난이도를 가늠하는 데 도움이 될 거예요

805
00:18:10,549 --> 00:18:11,990
그건 제가 이 문제의 난이도를 가늠하는 데 도움이 될 거예요
 

806
00:18:11,990 --> 00:18:12,000

 

807
00:18:12,000 --> 00:18:13,270

.  당신은 아마 대답하지 못할 수도 있겠죠

808
00:18:13,270 --> 00:18:13,280
.  당신은 아마 대답하지 못할 수도 있겠죠
 

809
00:18:13,280 --> 00:18:15,430
.  당신은 아마 대답하지 못할 수도 있겠죠
?  하지만

810
00:18:15,430 --> 00:18:15,440
?  하지만
 

811
00:18:15,440 --> 00:18:17,590
?  하지만
어떤 종류의 문제인지 감을 잡는 데는 도움이 될 수 있습니다.  이 문제는

812
00:18:17,590 --> 00:18:17,600
어떤 종류의 문제인지 감을 잡는 데는 도움이 될 수 있습니다.  이 문제는
 

813
00:18:17,600 --> 00:18:19,750
어떤 종류의 문제인지 감을 잡는 데는 도움이 될 수 있습니다.  이 문제는
데이터 구조 정렬과 관련된 문제인가요

814
00:18:19,750 --> 00:18:19,760
데이터 구조 정렬과 관련된 문제인가요
 

815
00:18:19,760 --> 00:18:23,510
데이터 구조 정렬과 관련된 문제인가요
?  오른쪽.  데이터

816
00:18:23,510 --> 00:18:23,520
?  오른쪽.  데이터
 

817
00:18:23,520 --> 00:18:25,590
?  오른쪽.  데이터
구조에 관한 질문이라면,

818
00:18:25,590 --> 00:18:25,600
구조에 관한 질문이라면,
 

819
00:18:25,600 --> 00:18:27,430
구조에 관한 질문이라면,
순차 유형 연산을 지원해야 하나요?  그러니까

820
00:18:27,430 --> 00:18:27,440
순차 유형 연산을 지원해야 하나요?  그러니까
 

821
00:18:27,440 --> 00:18:30,549
순차 유형 연산을 지원해야 하나요?  그러니까
어떤 것에 대한 외부적인 순서를 저장해야 하는 건가요,

822
00:18:30,549 --> 00:18:30,559
어떤 것에 대한 외부적인 순서를 저장해야 하는 건가요,
 

823
00:18:30,559 --> 00:18:33,830
어떤 것에 대한 외부적인 순서를 저장해야 하는 건가요,
아니면

824
00:18:33,830 --> 00:18:33,840
아니면
 

825
00:18:33,840 --> 00:18:35,669
아니면
객체 자체가 무엇인지에 관심이 있는 건가요?  저는

826
00:18:35,669 --> 00:18:35,679
객체 자체가 무엇인지에 관심이 있는 건가요?  저는
 

827
00:18:35,679 --> 00:18:38,150
객체 자체가 무엇인지에 관심이 있는 건가요?  저는
그게 뭔지를 기준으로 찾아보려고 하는 거예요, 그렇죠?  아니면

828
00:18:38,150 --> 00:18:38,160
그게 뭔지를 기준으로 찾아보려고 하는 거예요, 그렇죠?  아니면
 

829
00:18:38,160 --> 00:18:40,390
그게 뭔지를 기준으로 찾아보려고 하는 거예요, 그렇죠?  아니면
둘 다일지도 몰라요.  아니면 여러 가지가 섞인 형태일 수도 있겠죠

830
00:18:40,390 --> 00:18:40,400
둘 다일지도 몰라요.  아니면 여러 가지가 섞인 형태일 수도 있겠죠
 

831
00:18:40,400 --> 00:18:42,150
둘 다일지도 몰라요.  아니면 여러 가지가 섞인 형태일 수도 있겠죠
?  만약 제가 여러

832
00:18:42,150 --> 00:18:42,160
?  만약 제가 여러
 

833
00:18:42,160 --> 00:18:43,830
?  만약 제가 여러
종류의 키를 가지고 있고, 그 키들을 기준으로 쿼리하고 싶다면 어떻게 해야 할까요

834
00:18:43,830 --> 00:18:43,840
종류의 키를 가지고 있고, 그 키들을 기준으로 쿼리하고 싶다면 어떻게 해야 할까요
 

835
00:18:43,840 --> 00:18:46,150
종류의 키를 가지고 있고, 그 키들을 기준으로 쿼리하고 싶다면 어떻게 해야 할까요
?  적어도

836
00:18:46,150 --> 00:18:46,160
?  적어도
 

837
00:18:46,160 --> 00:18:48,710
?  적어도
두 가지 유형의 데이터 구조를 사용해야 할 수도 있겠네요, 그렇죠?

838
00:18:48,710 --> 00:18:50,070
두 가지 유형의 데이터 구조를 사용해야 할 수도 있겠네요, 그렇죠?
 

839
00:18:50,070 --> 00:18:50,080

 

840
00:18:50,080 --> 00:18:52,390

이런 것들을 다루다 보면 굉장히 복잡해질 수 있지만,

841
00:18:52,390 --> 00:18:52,400
이런 것들을 다루다 보면 굉장히 복잡해질 수 있지만,
 

842
00:18:52,400 --> 00:18:53,909
이런 것들을 다루다 보면 굉장히 복잡해질 수 있지만,
간단히 말해서 "나는

843
00:18:53,909 --> 00:18:53,919
간단히 말해서 "나는
 

844
00:18:53,919 --> 00:18:59,190
간단히 말해서 "나는
이 이름들에 대해 이런 종류의 작업을 해야 해"라는 식으로 생각하면 됩니다.

845
00:18:59,190 --> 00:18:59,200
이 이름들에 대해 이런 종류의 작업을 해야 해"라는 식으로 생각하면 됩니다.
 

846
00:18:59,200 --> 00:19:00,950
이 이름들에 대해 이런 종류의 작업을 해야 해"라는 식으로 생각하면 됩니다.
그러면 '아, 저기에는 특정 데이터 구조가 필요하겠구나'라고 생각할 수 있죠

847
00:19:00,950 --> 00:19:00,960
그러면 '아, 저기에는 특정 데이터 구조가 필요하겠구나'라고 생각할 수 있죠
 

848
00:19:00,960 --> 00:19:02,470
그러면 '아, 저기에는 특정 데이터 구조가 필요하겠구나'라고 생각할 수 있죠
.  그 방법을 어떻게

849
00:19:02,470 --> 00:19:02,480
.  그 방법을 어떻게
 

850
00:19:02,480 --> 00:19:04,070
.  그 방법을 어떻게
실행할지는 나중에 생각해 볼게요.

851
00:19:04,070 --> 00:19:04,080
실행할지는 나중에 생각해 볼게요.
 

852
00:19:04,080 --> 00:19:05,590
실행할지는 나중에 생각해 볼게요.
해시 테이블을 사용해야 할까요?  정렬된 배열을 사용해야 할까요?

853
00:19:05,590 --> 00:19:05,600
해시 테이블을 사용해야 할까요?  정렬된 배열을 사용해야 할까요?
 

854
00:19:05,600 --> 00:19:08,390
해시 테이블을 사용해야 할까요?  정렬된 배열을 사용해야 할까요?
AVL 트리를 사용해야 할까요?  오른쪽?  하지만, 아시다시피

855
00:19:08,390 --> 00:19:08,400
AVL 트리를 사용해야 할까요?  오른쪽?  하지만, 아시다시피
 

856
00:19:08,400 --> 00:19:10,310
AVL 트리를 사용해야 할까요?  오른쪽?  하지만, 아시다시피
, 먼저

857
00:19:10,310 --> 00:19:10,320
, 먼저
 

858
00:19:10,320 --> 00:19:12,549
, 먼저
추상적인 수준에서 생각해 보면, 여기에는 일정한 데이터

859
00:19:12,549 --> 00:19:12,559
추상적인 수준에서 생각해 보면, 여기에는 일정한 데이터
 

860
00:19:12,559 --> 00:19:14,390
추상적인 수준에서 생각해 보면, 여기에는 일정한 데이터
구조가 필요하잖아요?

861
00:19:14,390 --> 00:19:14,400
구조가 필요하잖아요?
 

862
00:19:14,400 --> 00:19:16,630
구조가 필요하잖아요?
정확성과 효율성을 구분하는 데 도움이 될 수 있습니다

863
00:19:16,630 --> 00:19:16,640
정확성과 효율성을 구분하는 데 도움이 될 수 있습니다
 

864
00:19:16,640 --> 00:19:19,110
정확성과 효율성을 구분하는 데 도움이 될 수 있습니다
.  이해가 되시나요?  좋아요.

865
00:19:19,110 --> 00:19:19,120
.  이해가 되시나요?  좋아요.
 

866
00:19:19,120 --> 00:19:22,390
.  이해가 되시나요?  좋아요.
만약 막히셨다면, 이

867
00:19:22,390 --> 00:19:22,400
만약 막히셨다면, 이
 

868
00:19:22,400 --> 00:19:26,470
만약 막히셨다면, 이
질문이 도움이 될 겁니다.  막히면

869
00:19:26,470 --> 00:19:27,750
질문이 도움이 될 겁니다.  막히면
 

870
00:19:27,750 --> 00:19:27,760

 

871
00:19:27,760 --> 00:19:30,549

비효율적이지만 올바른 알고리즘을 적어보는 거죠, 그렇죠?  비효율적이지만

872
00:19:30,549 --> 00:19:30,559
비효율적이지만 올바른 알고리즘을 적어보는 거죠, 그렇죠?  비효율적이지만
 

873
00:19:30,559 --> 00:19:32,070
비효율적이지만 올바른 알고리즘을 적어보는 거죠, 그렇죠?  비효율적이지만
올바른 알고리즘에 대해서는 점수를 드릴 수 있습니다

874
00:19:32,070 --> 00:19:32,080
올바른 알고리즘에 대해서는 점수를 드릴 수 있습니다
 

875
00:19:32,080 --> 00:19:33,510
올바른 알고리즘에 대해서는 점수를 드릴 수 있습니다
.  적어도

876
00:19:33,510 --> 00:19:33,520
.  적어도
 

877
00:19:33,520 --> 00:19:35,110
.  적어도
알고리즘 자체는 맞잖아요, 그렇죠?  다른

878
00:19:35,110 --> 00:19:35,120
알고리즘 자체는 맞잖아요, 그렇죠?  다른
 

879
00:19:35,120 --> 00:19:38,230
알고리즘 자체는 맞잖아요, 그렇죠?  다른
것들보다 낫잖아요, 그렇죠?  만약

880
00:19:38,230 --> 00:19:38,240
것들보다 낫잖아요, 그렇죠?  만약
 

881
00:19:38,240 --> 00:19:40,950
것들보다 낫잖아요, 그렇죠?  만약
연산 시간이 지수적으로 증가한다면, 아마

882
00:19:40,950 --> 00:19:40,960
연산 시간이 지수적으로 증가한다면, 아마
 

883
00:19:40,960 --> 00:19:43,750
연산 시간이 지수적으로 증가한다면, 아마
10~20% 정도

884
00:19:43,750 --> 00:19:43,760
10~20% 정도
 

885
00:19:43,760 --> 00:19:45,750
10~20% 정도
의 점수밖에 얻지 못할 수도 있겠죠. 하지만

886
00:19:45,750 --> 00:19:45,760
의 점수밖에 얻지 못할 수도 있겠죠. 하지만
 

887
00:19:45,760 --> 00:19:49,510
의 점수밖에 얻지 못할 수도 있겠죠. 하지만
로그 함수나 선형 함수 정도로 느려진다면

888
00:19:49,510 --> 00:19:49,520
로그 함수나 선형 함수 정도로 느려진다면
 

889
00:19:49,520 --> 00:19:52,789
로그 함수나 선형 함수 정도로 느려진다면
괜찮을 수도 있습니다. 자료

890
00:19:52,789 --> 00:19:52,799
괜찮을 수도 있습니다. 자료
 

891
00:19:52,799 --> 00:19:54,630
괜찮을 수도 있습니다. 자료
구조 문제에서 어떤 연산

892
00:19:54,630 --> 00:19:54,640
구조 문제에서 어떤 연산
 

893
00:19:54,640 --> 00:19:58,549
구조 문제에서 어떤 연산
이든 n차 시간 복잡도를 가지면

894
00:19:58,549 --> 00:19:58,559
이든 n차 시간 복잡도를 가지면
 

895
00:19:58,559 --> 00:19:59,669
이든 n차 시간 복잡도를 가지면
점수를 많이 받기 어려울 겁니다.

896
00:19:59,669 --> 00:19:59,679
점수를 많이 받기 어려울 겁니다.
 

897
00:19:59,679 --> 00:20:01,029
점수를 많이 받기 어려울 겁니다.
자료구조의 핵심은

898
00:20:01,029 --> 00:20:01,039
자료구조의 핵심은
 

899
00:20:01,039 --> 00:20:02,470
자료구조의 핵심은
연산을

900
00:20:02,470 --> 00:20:02,480
연산을
 

901
00:20:02,480 --> 00:20:06,470
연산을
빠르게 만드는 것이니까요. 하지만 문제를 해결하는 데 성공한다면

902
00:20:06,470 --> 00:20:06,480
빠르게 만드는 것이니까요. 하지만 문제를 해결하는 데 성공한다면
 

903
00:20:06,480 --> 00:20:07,990
빠르게 만드는 것이니까요. 하지만 문제를 해결하는 데 성공한다면
, 어느 정도

904
00:20:07,990 --> 00:20:08,000
, 어느 정도
 

905
00:20:08,000 --> 00:20:10,950
, 어느 정도
점수는 얻을 수 있겠죠.  당신은 0점을 받지 않을 겁니다.  응.

906
00:20:10,950 --> 00:20:12,789
점수는 얻을 수 있겠죠.  당신은 0점을 받지 않을 겁니다.  응.
 

907
00:20:12,789 --> 00:20:12,799

 

908
00:20:12,799 --> 00:20:14,630

"이걸 얼마나 빨리 만들 수 있나요?

909
00:20:14,630 --> 00:20:14,640
"이걸 얼마나 빨리 만들 수 있나요?
 

910
00:20:14,640 --> 00:20:16,310
"이걸 얼마나 빨리 만들 수 있나요?
최대한 빨리 만들어 주세요." 같은 질문을 받을까요?  응.  그래서

911
00:20:16,310 --> 00:20:16,320
최대한 빨리 만들어 주세요." 같은 질문을 받을까요?  응.  그래서
 

912
00:20:16,320 --> 00:20:18,710
최대한 빨리 만들어 주세요." 같은 질문을 받을까요?  응.  그래서
우리는 종종 "효율적인

913
00:20:18,710 --> 00:20:18,720
우리는 종종 "효율적인
 

914
00:20:18,720 --> 00:20:21,590
우리는 종종 "효율적인
알고리즘을 주세요"라고 말합니다.  좋아요.  "와,

915
00:20:21,590 --> 00:20:21,600
알고리즘을 주세요"라고 말합니다.  좋아요.  "와,
 

916
00:20:21,600 --> 00:20:22,870
알고리즘을 주세요"라고 말합니다.  좋아요.  "와,
이게 효율적인지 아닌지 잘 모르겠네."라는 느낌이 들어요.

917
00:20:22,870 --> 00:20:22,880
이게 효율적인지 아닌지 잘 모르겠네."라는 느낌이 들어요.
 

918
00:20:22,880 --> 00:20:24,470
이게 효율적인지 아닌지 잘 모르겠네."라는 느낌이 들어요.
음, 그건

919
00:20:24,470 --> 00:20:24,480
음, 그건
 

920
00:20:24,480 --> 00:20:25,909
음, 그건
달리기 기록이 빠를수록 더 많은

921
00:20:25,909 --> 00:20:25,919
달리기 기록이 빠를수록 더 많은
 

922
00:20:25,919 --> 00:20:29,029
달리기 기록이 빠를수록 더 많은
점수를 얻게 된다는 뜻이에요.  좋아요.  그런 유형의 문제에서는 주로

923
00:20:29,029 --> 00:20:32,549
점수를 얻게 된다는 뜻이에요.  좋아요.  그런 유형의 문제에서는 주로
 

924
00:20:32,549 --> 00:20:35,510

 

925
00:20:35,510 --> 00:20:35,520

 

926
00:20:35,520 --> 00:20:37,909

효율적인 방법을 찾는 것이 중요합니다. 데이터

927
00:20:37,909 --> 00:20:37,919
효율적인 방법을 찾는 것이 중요합니다. 데이터
 

928
00:20:37,919 --> 00:20:39,990
효율적인 방법을 찾는 것이 중요합니다. 데이터
구조 문제에서는 구현 시 데이터 구조 연산의 속도가 중요하기 때문에, 얼마나 빠른지가 핵심입니다. 동적

929
00:20:39,990 --> 00:20:43,190
구조 문제에서는 구현 시 데이터 구조 연산의 속도가 중요하기 때문에, 얼마나 빠른지가 핵심입니다. 동적
 

930
00:20:43,190 --> 00:20:43,200

 

931
00:20:43,200 --> 00:20:45,750

데이터

932
00:20:45,750 --> 00:20:45,760
데이터
 

933
00:20:45,760 --> 00:20:47,830
데이터
구조 문제에서는

934
00:20:47,830 --> 00:20:50,630
구조 문제에서는
 

935
00:20:50,630 --> 00:20:53,990

 

936
00:20:53,990 --> 00:20:54,000

 

937
00:20:54,000 --> 00:20:56,390

일반적으로

938
00:20:56,390 --> 00:20:58,470
일반적으로
 

939
00:20:58,470 --> 00:20:58,480

 

940
00:20:58,480 --> 00:21:00,310

이러한 연산의 실행 시간과 실행 시간 사이에 상충 관계가 존재하며, 이 둘의 관계를 이해하는 것이 매우

941
00:21:00,310 --> 00:21:02,149
이러한 연산의 실행 시간과 실행 시간 사이에 상충 관계가 존재하며, 이 둘의 관계를 이해하는 것이 매우
 

942
00:21:02,149 --> 00:21:02,159

 

943
00:21:02,159 --> 00:21:03,990

중요합니다.

944
00:21:03,990 --> 00:21:04,000
중요합니다.
 

945
00:21:04,000 --> 00:21:06,149
중요합니다.
따라서 데이터 구조 문제에서는 실행 시간을 최적화하는 것이 핵심입니다. 반면

946
00:21:06,149 --> 00:21:07,830
따라서 데이터 구조 문제에서는 실행 시간을 최적화하는 것이 핵심입니다. 반면
 

947
00:21:07,830 --> 00:21:07,840

 

948
00:21:07,840 --> 00:21:10,630

알고리즘 문제에서는

949
00:21:10,630 --> 00:21:10,640
알고리즘 문제에서는
 

950
00:21:10,640 --> 00:21:12,950
알고리즘 문제에서는
하나의 작업을 최대한 빠르게 수행하도록 요구합니다. 즉, 선형 시간 복잡도를 목표로 하지만,

951
00:21:12,950 --> 00:21:14,549
하나의 작업을 최대한 빠르게 수행하도록 요구합니다. 즉, 선형 시간 복잡도를 목표로 하지만,
 

952
00:21:14,549 --> 00:21:16,710

 

953
00:21:16,710 --> 00:21:18,630

 

954
00:21:18,630 --> 00:21:21,510

 

955
00:21:21,510 --> 00:21:21,520

 

956
00:21:21,520 --> 00:21:23,270

입력 데이터를 모두 읽어야 하는 경우 선형 시간보다 더 나은 결과를 얻기는 어렵습니다. 예를 들어

957
00:21:23,270 --> 00:21:24,630
입력 데이터를 모두 읽어야 하는 경우 선형 시간보다 더 나은 결과를 얻기는 어렵습니다. 예를 들어
 

958
00:21:24,630 --> 00:21:24,640

 

959
00:21:24,640 --> 00:21:27,430

데이터에서 특정 요소를 찾는 경우처럼 말이죠.

960
00:21:27,430 --> 00:21:27,440
데이터에서 특정 요소를 찾는 경우처럼 말이죠.
 

961
00:21:27,440 --> 00:21:29,510
데이터에서 특정 요소를 찾는 경우처럼 말이죠.
선형 시간 알고리즘이 생각나지 않는다면,

962
00:21:29,510 --> 00:21:29,520
선형 시간 알고리즘이 생각나지 않는다면,
 

963
00:21:29,520 --> 00:21:31,270
선형 시간 알고리즘이 생각나지 않는다면,
n제곱 문제나 n개의

964
00:21:31,270 --> 00:21:31,280
n제곱 문제나 n개의
 

965
00:21:31,280 --> 00:21:33,990
n제곱 문제나 n개의
로그인 문제 같은 걸 생각해 보세요.  지금으로서는

966
00:21:33,990 --> 00:21:34,000
로그인 문제 같은 걸 생각해 보세요.  지금으로서는
 

967
00:21:34,000 --> 00:21:35,830
로그인 문제 같은 걸 생각해 보세요.  지금으로서는
여러분이 그걸 생각하기가 조금 어려울 수도 있겠죠

968
00:21:35,830 --> 00:21:35,840
여러분이 그걸 생각하기가 조금 어려울 수도 있겠죠
 

969
00:21:35,840 --> 00:21:38,390
여러분이 그걸 생각하기가 조금 어려울 수도 있겠죠
?  하지만 제가

970
00:21:38,390 --> 00:21:38,400
?  하지만 제가
 

971
00:21:38,400 --> 00:21:41,029
?  하지만 제가
말씀드리고 싶은 건, 일단 올바른 알고리즘부터 시작하고, 그 다음에

972
00:21:41,029 --> 00:21:41,039
말씀드리고 싶은 건, 일단 올바른 알고리즘부터 시작하고, 그 다음에
 

973
00:21:41,039 --> 00:21:42,549
말씀드리고 싶은 건, 일단 올바른 알고리즘부터 시작하고, 그 다음에
최적화를 하거나 더

974
00:21:42,549 --> 00:21:42,559
최적화를 하거나 더
 

975
00:21:42,559 --> 00:21:44,149
최적화를 하거나 더
나은 데이터 구조를 사용해서

976
00:21:44,149 --> 00:21:44,159
나은 데이터 구조를 사용해서
 

977
00:21:44,159 --> 00:21:45,430
나은 데이터 구조를 사용해서
효율성을 높이는 겁니다.

978
00:21:45,430 --> 00:21:45,440
효율성을 높이는 겁니다.
 

979
00:21:45,440 --> 00:21:48,870
효율성을 높이는 겁니다.
이해가 되시나요?  다른 질문 있으신가요?

980
00:21:48,870 --> 00:21:48,880
이해가 되시나요?  다른 질문 있으신가요?
 

981
00:21:48,880 --> 00:21:52,310
이해가 되시나요?  다른 질문 있으신가요?
좋아요.  자, 다음으로 넘어가죠.

982
00:21:52,310 --> 00:21:52,320
좋아요.  자, 다음으로 넘어가죠.
 

983
00:21:52,320 --> 00:21:55,510
좋아요.  자, 다음으로 넘어가죠.
좋아요.  단점도 있겠죠?

984
00:21:55,510 --> 00:21:55,520
좋아요.  단점도 있겠죠?
 

985
00:21:55,520 --> 00:21:57,830
좋아요.  단점도 있겠죠?
좋아요.  만약 당신이 다음

986
00:21:57,830 --> 00:21:57,840
좋아요.  만약 당신이 다음
 

987
00:21:57,840 --> 00:22:00,470
좋아요.  만약 당신이 다음
세 가지 중 하나라도 하고 있다면, 잠시 멈춰 생각해 보세요

988
00:22:00,470 --> 00:22:00,480
세 가지 중 하나라도 하고 있다면, 잠시 멈춰 생각해 보세요
 

989
00:22:00,480 --> 00:22:02,070
세 가지 중 하나라도 하고 있다면, 잠시 멈춰 생각해 보세요
.  아마

990
00:22:02,070 --> 00:22:02,080
.  아마
 

991
00:22:02,080 --> 00:22:04,710
.  아마
뭔가 잘못하고 계신 것 같아요.  좋아요?  그러므로

992
00:22:04,710 --> 00:22:06,789
뭔가 잘못하고 계신 것 같아요.  좋아요?  그러므로
 

993
00:22:06,789 --> 00:22:06,799

 

994
00:22:06,799 --> 00:22:10,710

소수, 유리수 또는 실수 중 어떤 것을 계산하려는 것인지 스스로에게 질문해 보세요.

995
00:22:10,710 --> 00:22:10,720
소수, 유리수 또는 실수 중 어떤 것을 계산하려는 것인지 스스로에게 질문해 보세요.
 

996
00:22:10,720 --> 00:22:12,630
소수, 유리수 또는 실수 중 어떤 것을 계산하려는 것인지 스스로에게 질문해 보세요.
그런 것들을 저장할 수는 없어요. 아니,

997
00:22:12,630 --> 00:22:12,640
그런 것들을 저장할 수는 없어요. 아니,
 

998
00:22:12,640 --> 00:22:14,789
그런 것들을 저장할 수는 없어요. 아니,
소수점은 유한한 정밀도로 저장할 수 있잖아요,

999
00:22:14,789 --> 00:22:14,799
소수점은 유한한 정밀도로 저장할 수 있잖아요,
 

1000
00:22:14,799 --> 00:22:16,230
소수점은 유한한 정밀도로 저장할 수 있잖아요,
그렇죠?  하지만 유한

1001
00:22:16,230 --> 00:22:16,240
그렇죠?  하지만 유한
 

1002
00:22:16,240 --> 00:22:18,630
그렇죠?  하지만 유한
정밀도를 사용한다면, 차라리

1003
00:22:18,630 --> 00:22:18,640
정밀도를 사용한다면, 차라리
 

1004
00:22:18,640 --> 00:22:20,710
정밀도를 사용한다면, 차라리
그 고정된

1005
00:22:20,710 --> 00:22:20,720
그 고정된
 

1006
00:22:20,720 --> 00:22:23,350
그 고정된
정밀도를 곱해서 반올림하고 정수로 처리하는 게 낫지 않을까요?

1007
00:22:23,350 --> 00:22:24,950
정밀도를 곱해서 반올림하고 정수로 처리하는 게 낫지 않을까요?
 

1008
00:22:24,950 --> 00:22:24,960

 

1009
00:22:24,960 --> 00:22:26,710

이 수업에서 여러분에게 정수를 다루는 방법만 가르쳐 드렸죠, 그렇죠?  우리는 아직

1010
00:22:26,710 --> 00:22:28,390
이 수업에서 여러분에게 정수를 다루는 방법만 가르쳐 드렸죠, 그렇죠?  우리는 아직
 

1011
00:22:28,390 --> 00:22:28,400

 

1012
00:22:28,400 --> 00:22:31,909

유리수와 실수에 대한 효율적인 계산 방법을 보여드리지도 않았습니다

1013
00:22:31,909 --> 00:22:31,919
유리수와 실수에 대한 효율적인 계산 방법을 보여드리지도 않았습니다
 

1014
00:22:31,919 --> 00:22:34,070
유리수와 실수에 대한 효율적인 계산 방법을 보여드리지도 않았습니다
.

1015
00:22:34,070 --> 00:22:34,080
.
 

1016
00:22:34,080 --> 00:22:36,390
.
분모와 분자가 있는 분수의 경우

1017
00:22:36,390 --> 00:22:36,400
분모와 분자가 있는 분수의 경우
 

1018
00:22:36,400 --> 00:22:39,510
분모와 분자가 있는 분수의 경우
, 교차 곱셈을

1019
00:22:39,510 --> 00:22:39,520
, 교차 곱셈을
 

1020
00:22:39,520 --> 00:22:41,669
, 교차 곱셈을
통해 일정한 시간 안에 두 분수를 비교할 수 있다고 말씀드렸습니다

1021
00:22:41,669 --> 00:22:41,679
통해 일정한 시간 안에 두 분수를 비교할 수 있다고 말씀드렸습니다
 

1022
00:22:41,679 --> 00:22:44,230
통해 일정한 시간 안에 두 분수를 비교할 수 있다고 말씀드렸습니다
.  하지만 만약 제가 임의의

1023
00:22:44,230 --> 00:22:48,310
.  하지만 만약 제가 임의의
 

1024
00:22:48,310 --> 00:22:48,320

 

1025
00:22:48,320 --> 00:22:51,110

정밀도로 나눗셈을 하려고 한다면, 그건 제대로 된 결과가 나오지

1026
00:22:51,110 --> 00:22:51,120
정밀도로 나눗셈을 하려고 한다면, 그건 제대로 된 결과가 나오지
 

1027
00:22:51,120 --> 00:22:54,310
정밀도로 나눗셈을 하려고 한다면, 그건 제대로 된 결과가 나오지
않겠죠?  왜냐하면

1028
00:22:54,310 --> 00:22:54,320
않겠죠?  왜냐하면
 

1029
00:22:54,320 --> 00:22:55,830
않겠죠?  왜냐하면
제 컴퓨터에서는 이런 값들을 유한한 소수점 자리까지 표현할 수조차 없기 때문이죠.

1030
00:22:55,830 --> 00:22:58,390
제 컴퓨터에서는 이런 값들을 유한한 소수점 자리까지 표현할 수조차 없기 때문이죠.
 

1031
00:22:58,390 --> 00:22:58,400

 

1032
00:22:58,400 --> 00:23:02,950

음,

1033
00:23:02,950 --> 00:23:04,390
음,
 

1034
00:23:04,390 --> 00:23:04,400

 

1035
00:23:04,400 --> 00:23:06,549

모든 결과에 대해 근호 정렬을 사용하려고 한다면 아마 잘못된 방법일 거예요,

1036
00:23:06,549 --> 00:23:06,559
모든 결과에 대해 근호 정렬을 사용하려고 한다면 아마 잘못된 방법일 거예요,
 

1037
00:23:06,559 --> 00:23:08,950
모든 결과에 대해 근호 정렬을 사용하려고 한다면 아마 잘못된 방법일 거예요,
그렇죠?  음, 저희가 퀴즈를 만들 때 시도하는 것 중 하나죠

1038
00:23:08,950 --> 00:23:08,960
그렇죠?  음, 저희가 퀴즈를 만들 때 시도하는 것 중 하나죠
 

1039
00:23:08,960 --> 00:23:11,990
그렇죠?  음, 저희가 퀴즈를 만들 때 시도하는 것 중 하나죠
, 그렇죠?  우리가 그냥 아무렇게나

1040
00:23:11,990 --> 00:23:12,000
, 그렇죠?  우리가 그냥 아무렇게나
 

1041
00:23:12,000 --> 00:23:13,909
, 그렇죠?  우리가 그냥 아무렇게나
문제를 내놓는 게 아니라는 거죠

1042
00:23:13,909 --> 00:23:13,919
문제를 내놓는 게 아니라는 거죠
 

1043
00:23:13,919 --> 00:23:16,470
문제를 내놓는 게 아니라는 거죠
?  우리는 아마도

1044
00:23:16,470 --> 00:23:16,480
?  우리는 아마도
 

1045
00:23:16,480 --> 00:23:18,710
?  우리는 아마도
어떤 식으로든 그 내용을 포괄하는 문제를 만들고 있는 것 같네요

1046
00:23:18,710 --> 00:23:18,720
어떤 식으로든 그 내용을 포괄하는 문제를 만들고 있는 것 같네요
 

1047
00:23:18,720 --> 00:23:21,029
어떤 식으로든 그 내용을 포괄하는 문제를 만들고 있는 것 같네요
, 그렇죠?  우리는 당신을 모든 면에서 시험해보고 싶잖아요

1048
00:23:21,029 --> 00:23:21,039
, 그렇죠?  우리는 당신을 모든 면에서 시험해보고 싶잖아요
 

1049
00:23:21,039 --> 00:23:24,310
, 그렇죠?  우리는 당신을 모든 면에서 시험해보고 싶잖아요
, 그렇죠?  그러니까

1050
00:23:24,310 --> 00:23:26,230
, 그렇죠?  그러니까
 

1051
00:23:26,230 --> 00:23:26,240

 

1052
00:23:26,240 --> 00:23:29,510

시험에서 같은 표현을 네다섯 번씩 쓰고 있다면, 너무

1053
00:23:29,510 --> 00:23:31,590
시험에서 같은 표현을 네다섯 번씩 쓰고 있다면, 너무
 

1054
00:23:31,590 --> 00:23:31,600

 

1055
00:23:31,600 --> 00:23:34,149

많이 쓰고 있다는 신호일 수 있어요.  항상 그런

1056
00:23:34,149 --> 00:23:34,159
많이 쓰고 있다는 신호일 수 있어요.  항상 그런
 

1057
00:23:34,159 --> 00:23:35,590
많이 쓰고 있다는 신호일 수 있어요.  항상 그런
건 아니잖아요, 그렇죠?  해싱이

1058
00:23:35,590 --> 00:23:35,600
건 아니잖아요, 그렇죠?  해싱이
 

1059
00:23:35,600 --> 00:23:37,270
건 아니잖아요, 그렇죠?  해싱이
정말 유용할 때가 있죠, 그렇죠?  그러니까 항상 사용하고 싶다는 거군요

1060
00:23:37,270 --> 00:23:37,280
정말 유용할 때가 있죠, 그렇죠?  그러니까 항상 사용하고 싶다는 거군요
 

1061
00:23:37,280 --> 00:23:39,270
정말 유용할 때가 있죠, 그렇죠?  그러니까 항상 사용하고 싶다는 거군요
.  하지만 특히,

1062
00:23:39,270 --> 00:23:39,280
.  하지만 특히,
 

1063
00:23:39,280 --> 00:23:41,029
.  하지만 특히,

1064
00:23:41,029 --> 00:23:41,039

 

1065
00:23:41,039 --> 00:23:43,190

다들 부적절한 상황에서도 급수 정렬을 사용하려고 하잖아요

1066
00:23:43,190 --> 00:23:43,200
다들 부적절한 상황에서도 급수 정렬을 사용하려고 하잖아요
 

1067
00:23:43,200 --> 00:23:46,070
다들 부적절한 상황에서도 급수 정렬을 사용하려고 하잖아요
, 그렇죠?  그리고 그들은 그걸

1068
00:23:46,070 --> 00:23:46,080
, 그렇죠?  그리고 그들은 그걸
 

1069
00:23:46,080 --> 00:23:47,909
, 그렇죠?  그리고 그들은 그걸
좋아하죠, 왜냐하면 시간이 순차적으로 흘러가니까요

1070
00:23:47,909 --> 00:23:47,919
좋아하죠, 왜냐하면 시간이 순차적으로 흘러가니까요
 

1071
00:23:47,919 --> 00:23:53,029
좋아하죠, 왜냐하면 시간이 순차적으로 흘러가니까요
, 그렇죠?  하지만 만약 당신이

1072
00:23:53,029 --> 00:23:53,039
, 그렇죠?  하지만 만약 당신이
 

1073
00:23:53,039 --> 00:23:54,789
, 그렇죠?  하지만 만약 당신이
급수 정렬이 적용될 수 있는 문제에 병합 정렬을 사용한다면

1074
00:23:54,789 --> 00:23:54,799
급수 정렬이 적용될 수 있는 문제에 병합 정렬을 사용한다면
 

1075
00:23:54,799 --> 00:23:56,630
급수 정렬이 적용될 수 있는 문제에 병합 정렬을 사용한다면
, 비록 효율적이지는 않지만 올바른 방법이기 때문에 점수를 얻게 되겠죠

1076
00:23:56,630 --> 00:23:59,029
, 비록 효율적이지는 않지만 올바른 방법이기 때문에 점수를 얻게 되겠죠
 

1077
00:23:59,029 --> 00:23:59,039

 

1078
00:23:59,039 --> 00:24:01,270

?  만약 그렇다면,

1079
00:24:01,270 --> 00:24:01,280
?  만약 그렇다면,
 

1080
00:24:01,280 --> 00:24:03,430
?  만약 그렇다면,
그것은 로그 인자만큼 비효율적이라는 뜻

1081
00:24:03,430 --> 00:24:03,440
그것은 로그 인자만큼 비효율적이라는 뜻
 

1082
00:24:03,440 --> 00:24:06,789
그것은 로그 인자만큼 비효율적이라는 뜻
이죠?  정수 범위에 제한이 없고 비교 연산이 필요한 상황에서 근호 정렬을 사용하려는 경우입니다

1083
00:24:06,789 --> 00:24:08,230
이죠?  정수 범위에 제한이 없고 비교 연산이 필요한 상황에서 근호 정렬을 사용하려는 경우입니다
 

1084
00:24:08,230 --> 00:24:10,149

 

1085
00:24:10,149 --> 00:24:11,909

 

1086
00:24:11,909 --> 00:24:11,919

 

1087
00:24:11,919 --> 00:24:14,470

.  정수 크기에 제한이 없다면

1088
00:24:14,470 --> 00:24:14,480
.  정수 크기에 제한이 없다면
 

1089
00:24:14,480 --> 00:24:16,390
.  정수 크기에 제한이 없다면
, 이 작업은

1090
00:24:16,390 --> 00:24:16,400
, 이 작업은
 

1091
00:24:16,400 --> 00:24:19,590
, 이 작업은
엄청나게 오랜 시간이 걸릴 수 있겠죠?  그래서

1092
00:24:19,590 --> 00:24:19,600
엄청나게 오랜 시간이 걸릴 수 있겠죠?  그래서
 

1093
00:24:19,600 --> 00:24:21,750
엄청나게 오랜 시간이 걸릴 수 있겠죠?  그래서
저는 그게 맞는 거라고 생각조차 안 할 것 같아요.

1094
00:24:21,750 --> 00:24:21,760
저는 그게 맞는 거라고 생각조차 안 할 것 같아요.
 

1095
00:24:21,760 --> 00:24:23,350
저는 그게 맞는 거라고 생각조차 안 할 것 같아요.
왜냐하면, 아시다시피,

1096
00:24:23,350 --> 00:24:23,360
왜냐하면, 아시다시피,
 

1097
00:24:23,360 --> 00:24:25,909
왜냐하면, 아시다시피,
시간이 기하급수적으로 늘어날 수도 있잖아요?  아니면, 제 말은,

1098
00:24:25,909 --> 00:24:27,190
시간이 기하급수적으로 늘어날 수도 있잖아요?  아니면, 제 말은,
 

1099
00:24:27,190 --> 00:24:27,200

 

1100
00:24:27,200 --> 00:24:28,710

제 단어 크기가 얼마나 되는지 잘 모르겠다는 뜻일 수도 있어요.  그것은

1101
00:24:28,710 --> 00:24:28,720
제 단어 크기가 얼마나 되는지 잘 모르겠다는 뜻일 수도 있어요.  그것은
 

1102
00:24:28,720 --> 00:24:32,710
제 단어 크기가 얼마나 되는지 잘 모르겠다는 뜻일 수도 있어요.  그것은
임의로 나빠질 수 있다.  좋아요.  그리고

1103
00:24:32,710 --> 00:24:32,720
임의로 나빠질 수 있다.  좋아요.  그리고
 

1104
00:24:32,720 --> 00:24:34,710
임의로 나빠질 수 있다.  좋아요.  그리고
만약 이진

1105
00:24:34,710 --> 00:24:34,720
만약 이진
 

1106
00:24:34,720 --> 00:24:36,630
만약 이진
트리에 서브트리

1107
00:24:36,630 --> 00:24:36,640
트리에 서브트리
 

1108
00:24:36,640 --> 00:24:38,390
트리에 서브트리
속성이 아닌 다른 속성을 추가하려고 한다면요?  두 자식 요소의

1109
00:24:38,390 --> 00:24:38,400
속성이 아닌 다른 속성을 추가하려고 한다면요?  두 자식 요소의
 

1110
00:24:38,400 --> 00:24:40,710
속성이 아닌 다른 속성을 추가하려고 한다면요?  두 자식 요소의
증분으로 계산할 수 없는 무언가라면

1111
00:24:40,710 --> 00:24:40,720
증분으로 계산할 수 없는 무언가라면
 

1112
00:24:40,720 --> 00:24:42,470
증분으로 계산할 수 없는 무언가라면
, 당신은 뭔가

1113
00:24:42,470 --> 00:24:42,480
, 당신은 뭔가
 

1114
00:24:42,480 --> 00:24:47,190
, 당신은 뭔가
잘못하고 있는 겁니다.  매 시험마다 학생들의 30% 정도가

1115
00:24:47,190 --> 00:24:52,390
잘못하고 있는 겁니다.  매 시험마다 학생들의 30% 정도가
 

1116
00:24:52,390 --> 00:24:52,400

 

1117
00:24:52,400 --> 00:24:54,950

전체 트리에서 내 인덱스만큼 증분한다는 답을 내놓죠,

1118
00:24:54,950 --> 00:24:54,960
전체 트리에서 내 인덱스만큼 증분한다는 답을 내놓죠,
 

1119
00:24:54,960 --> 00:24:58,390
전체 트리에서 내 인덱스만큼 증분한다는 답을 내놓죠,
그렇죠?  또는 "

1120
00:24:58,390 --> 00:24:58,400
그렇죠?  또는 "
 

1121
00:24:58,400 --> 00:25:01,190
그렇죠?  또는 "
여기 재밌는 게 하나 있어요."라고 덧붙일 수도 있겠네요.  어,

1122
00:25:01,190 --> 00:25:01,200
여기 재밌는 게 하나 있어요."라고 덧붙일 수도 있겠네요.  어,
 

1123
00:25:01,200 --> 00:25:06,070
여기 재밌는 게 하나 있어요."라고 덧붙일 수도 있겠네요.  어,
내 왼쪽 서브리의 크기를 늘리는 것들로요.

1124
00:25:06,070 --> 00:25:06,080

 

1125
00:25:06,080 --> 00:25:08,390

좋아요, 제

1126
00:25:08,390 --> 00:25:08,400
좋아요, 제
 

1127
00:25:08,400 --> 00:25:13,510
좋아요, 제
왼쪽 서브리의 노드 개수는 몇 개 정도 되나요?  어떻게 해야 할지 모르겠어요.

1128
00:25:13,510 --> 00:25:16,549

 

1129
00:25:16,549 --> 00:25:16,559

 

1130
00:25:16,559 --> 00:25:20,310

회전 같은 걸 하면서 그걸 유지할 수 있을지 잘 모르겠네요.  음,

1131
00:25:20,310 --> 00:25:23,350
회전 같은 걸 하면서 그걸 유지할 수 있을지 잘 모르겠네요.  음,
 

1132
00:25:23,350 --> 00:25:23,360

 

1133
00:25:23,360 --> 00:25:25,669

제 왼쪽 트리의 확장을 추적하려면 어떻게 해야 할까요

1134
00:25:25,669 --> 00:25:29,350
제 왼쪽 트리의 확장을 추적하려면 어떻게 해야 할까요
 

1135
00:25:29,350 --> 00:25:29,360

 

1136
00:25:29,360 --> 00:25:31,430

?  거기에

1137
00:25:31,430 --> 00:25:33,029
?  거기에
 

1138
00:25:33,029 --> 00:25:33,039

 

1139
00:25:33,039 --> 00:25:34,549

물건이 몇 개나 있었는지 알아내려면 마치 로그 함수처럼 쭉 내려가면서 계산해야 하는 거

1140
00:25:34,549 --> 00:25:34,559
물건이 몇 개나 있었는지 알아내려면 마치 로그 함수처럼 쭉 내려가면서 계산해야 하는 거
 

1141
00:25:34,559 --> 00:25:36,149
물건이 몇 개나 있었는지 알아내려면 마치 로그 함수처럼 쭉 내려가면서 계산해야 하는 거
아닌가요?  그러니까 그건

1142
00:25:36,149 --> 00:25:36,159
아닌가요?  그러니까 그건
 

1143
00:25:36,159 --> 00:25:37,750
아닌가요?  그러니까 그건
상수 시간으로 유지 관리하기 어려운 거죠.  만약

1144
00:25:37,750 --> 00:25:37,760
상수 시간으로 유지 관리하기 어려운 거죠.  만약
 

1145
00:25:37,760 --> 00:25:39,269
상수 시간으로 유지 관리하기 어려운 거죠.  만약
제가 왼쪽 서브리의 어떤 부분을 확장하고 싶다면

1146
00:25:39,269 --> 00:25:39,279
제가 왼쪽 서브리의 어떤 부분을 확장하고 싶다면
 

1147
00:25:39,279 --> 00:25:41,909
제가 왼쪽 서브리의 어떤 부분을 확장하고 싶다면
, 그 부분 자체를 확장

1148
00:25:41,909 --> 00:25:41,919
, 그 부분 자체를 확장
 

1149
00:25:41,919 --> 00:25:44,070
, 그 부분 자체를 확장
하고 왼쪽 서브리를 살펴본 다음

1150
00:25:44,070 --> 00:25:44,080
하고 왼쪽 서브리를 살펴본 다음
 

1151
00:25:44,080 --> 00:25:45,750
하고 왼쪽 서브리를 살펴본 다음
확장된 부분을 확인하면 됩니다.

1152
00:25:45,750 --> 00:25:45,760
확장된 부분을 확인하면 됩니다.
 

1153
00:25:45,760 --> 00:25:47,590
확장된 부분을 확인하면 됩니다.
이해가 되시나요?  응.

1154
00:25:47,590 --> 00:25:47,600
이해가 되시나요?  응.
 

1155
00:25:47,600 --> 00:25:49,269
이해가 되시나요?  응.
만약 서브

1156
00:25:49,269 --> 00:25:49,279
만약 서브
 

1157
00:25:49,279 --> 00:25:51,350
만약 서브
트리를 추가하고 다시 왼쪽

1158
00:25:51,350 --> 00:25:51,360
트리를 추가하고 다시 왼쪽
 

1159
00:25:51,360 --> 00:25:53,269
트리를 추가하고 다시 왼쪽
서브트리를 추가하여 확장한 다음 사용한다면,

1160
00:25:53,269 --> 00:25:53,279
서브트리를 추가하여 확장한 다음 사용한다면,
 

1161
00:25:53,279 --> 00:25:55,029
서브트리를 추가하여 확장한 다음 사용한다면,
여전히 그렇게 할 수 있다고 볼 수 있습니다.  응.

1162
00:25:55,029 --> 00:25:55,039
여전히 그렇게 할 수 있다고 볼 수 있습니다.  응.
 

1163
00:25:55,039 --> 00:25:56,710
여전히 그렇게 할 수 있다고 볼 수 있습니다.  응.
그러니까 서브리 크기를 늘려가면서 상수 시간 안에 처리할 수 있다는 거죠

1164
00:25:56,710 --> 00:25:56,720
그러니까 서브리 크기를 늘려가면서 상수 시간 안에 처리할 수 있다는 거죠
 

1165
00:25:56,720 --> 00:25:59,669
그러니까 서브리 크기를 늘려가면서 상수 시간 안에 처리할 수 있다는 거죠
?  응.

1166
00:25:59,669 --> 00:25:59,679
?  응.
 

1167
00:25:59,679 --> 00:26:01,269
?  응.
그런 다음 해당 부분에 또 다른 증강 기능을 추가하세요

1168
00:26:01,269 --> 00:26:01,279
그런 다음 해당 부분에 또 다른 증강 기능을 추가하세요
 

1169
00:26:01,279 --> 00:26:02,549
그런 다음 해당 부분에 또 다른 증강 기능을 추가하세요
.  다른

1170
00:26:02,549 --> 00:26:02,559
.  다른
 

1171
00:26:02,559 --> 00:26:03,830
.  다른
증강 시술을 받으실 수도 있습니다. 그러면

1172
00:26:03,830 --> 00:26:05,990
증강 시술을 받으실 수도 있습니다. 그러면
 

1173
00:26:05,990 --> 00:26:06,000

 

1174
00:26:06,000 --> 00:26:08,870

왼쪽 서브리만 보시면 되니까요.  응.

1175
00:26:08,870 --> 00:26:08,880
왼쪽 서브리만 보시면 되니까요.  응.
 

1176
00:26:08,880 --> 00:26:10,549
왼쪽 서브리만 보시면 되니까요.  응.
다시 저장할 이유가 없겠죠?

1177
00:26:10,549 --> 00:26:10,559
다시 저장할 이유가 없겠죠?
 

1178
00:26:10,559 --> 00:26:12,950
다시 저장할 이유가 없겠죠?
왼쪽을 계속해서 응시하는 거죠,

1179
00:26:12,950 --> 00:26:12,960
왼쪽을 계속해서 응시하는 거죠,
 

1180
00:26:12,960 --> 00:26:17,350
왼쪽을 계속해서 응시하는 거죠,
그렇죠?  좋아요.  그러지 마세요.  좋아요.

1181
00:26:17,350 --> 00:26:17,360
그렇죠?  좋아요.  그러지 마세요.  좋아요.
 

1182
00:26:17,360 --> 00:26:20,789
그렇죠?  좋아요.  그러지 마세요.  좋아요.
멋지네요.  저도 그렇게 뒤처지지는 않아요.

1183
00:26:20,789 --> 00:26:20,799
멋지네요.  저도 그렇게 뒤처지지는 않아요.
 

1184
00:26:20,799 --> 00:26:25,029
멋지네요.  저도 그렇게 뒤처지지는 않아요.
이것들이 제가 문제를 푸는 데 도움이 되는 팁입니다

1185
00:26:25,029 --> 00:26:25,039
이것들이 제가 문제를 푸는 데 도움이 되는 팁입니다
 

1186
00:26:25,039 --> 00:26:26,950
이것들이 제가 문제를 푸는 데 도움이 되는 팁입니다
.  아, 한 페이지 더 있네요.

1187
00:26:26,950 --> 00:26:26,960
.  아, 한 페이지 더 있네요.
 

1188
00:26:26,960 --> 00:26:29,750
.  아, 한 페이지 더 있네요.
응.  그러니까 마치

1189
00:26:29,750 --> 00:26:29,760
응.  그러니까 마치
 

1190
00:26:29,760 --> 00:26:31,669
응.  그러니까 마치
공식을 만들기 위해 증강을 정의하고, 그 공식이 정확하다고 주장하는 것과 같은 거죠

1191
00:26:31,669 --> 00:26:31,679
공식을 만들기 위해 증강을 정의하고, 그 공식이 정확하다고 주장하는 것과 같은 거죠
 

1192
00:26:31,679 --> 00:26:35,750
공식을 만들기 위해 증강을 정의하고, 그 공식이 정확하다고 주장하는 것과 같은 거죠
.  그러니까 핵심은,

1193
00:26:35,750 --> 00:26:39,029
.  그러니까 핵심은,
 

1194
00:26:39,029 --> 00:26:39,039

 

1195
00:26:39,039 --> 00:26:42,149

우리가 곧 이야기할

1196
00:26:42,149 --> 00:26:42,159
우리가 곧 이야기할
 

1197
00:26:42,159 --> 00:26:44,230
우리가 곧 이야기할
표준적인 것들처럼 간단하게 줄일 수 있는 게 아닌 증강을 제공한다는 거죠.

1198
00:26:44,230 --> 00:26:44,240
표준적인 것들처럼 간단하게 줄일 수 있는 게 아닌 증강을 제공한다는 거죠.
 

1199
00:26:44,240 --> 00:26:47,669
표준적인 것들처럼 간단하게 줄일 수 있는 게 아닌 증강을 제공한다는 거죠.
만약 제가

1200
00:26:47,669 --> 00:26:47,679
만약 제가
 

1201
00:26:47,679 --> 00:26:50,549
만약 제가
집합 AVL 트리

1202
00:26:50,549 --> 00:26:50,559
집합 AVL 트리
 

1203
00:26:50,559 --> 00:26:53,590
집합 AVL 트리
나 순차 AVL 트리를 예로 들자면, 예를 들어

1204
00:26:53,590 --> 00:26:53,600
나 순차 AVL 트리를 예로 들자면, 예를 들어
 

1205
00:26:53,600 --> 00:26:55,430
나 순차 AVL 트리를 예로 들자면, 예를 들어
강의 마지막 부분에서

1206
00:26:55,430 --> 00:26:55,440
강의 마지막 부분에서
 

1207
00:26:55,440 --> 00:26:58,549
강의 마지막 부분에서
순차 AVL 트리를

1208
00:26:58,549 --> 00:26:58,559
순차 AVL 트리를
 

1209
00:26:58,559 --> 00:27:02,390
순차 AVL 트리를
수정하여 이진 힙

1210
00:27:02,390 --> 00:27:02,400
수정하여 이진 힙
 

1211
00:27:02,400 --> 00:27:04,549
수정하여 이진 힙
과 동일한 실행 시간 내에 우선순위 Q 연산을 지원하는 방법에 대해 이야기했었죠

1212
00:27:04,549 --> 00:27:04,559
과 동일한 실행 시간 내에 우선순위 Q 연산을 지원하는 방법에 대해 이야기했었죠
 

1213
00:27:04,559 --> 00:27:07,669
과 동일한 실행 시간 내에 우선순위 Q 연산을 지원하는 방법에 대해 이야기했었죠
?  그건

1214
00:27:07,669 --> 00:27:07,679
?  그건
 

1215
00:27:07,679 --> 00:27:10,390
?  그건
우리가 서브리 맥스를 저장한다는 뜻이었죠, 그렇죠?

1216
00:27:10,390 --> 00:27:10,400
우리가 서브리 맥스를 저장한다는 뜻이었죠, 그렇죠?
 

1217
00:27:10,400 --> 00:27:15,029
우리가 서브리 맥스를 저장한다는 뜻이었죠, 그렇죠?
내 서브레딧에서 가장 인기 있는 항목이죠, 그렇죠?  어, 그러니까 그건

1218
00:27:15,029 --> 00:27:16,789
내 서브레딧에서 가장 인기 있는 항목이죠, 그렇죠?  어, 그러니까 그건
 

1219
00:27:16,789 --> 00:27:16,799

 

1220
00:27:16,799 --> 00:27:19,510

기존에 시퀀스

1221
00:27:19,510 --> 00:27:19,520
기존에 시퀀스
 

1222
00:27:19,520 --> 00:27:21,510
기존에 시퀀스
AVL 트리에 적용된 것과는 다른 확장 방식입니다.

1223
00:27:21,510 --> 00:27:21,520
AVL 트리에 적용된 것과는 다른 확장 방식입니다.
 

1224
00:27:21,520 --> 00:27:26,549
AVL 트리에 적용된 것과는 다른 확장 방식입니다.
시퀀스 AVL 트리에 대한 증강은 무엇인가요?

1225
00:27:26,549 --> 00:27:26,559

 

1226
00:27:26,559 --> 00:27:28,870

크기.

1227
00:27:28,870 --> 00:27:28,880
크기.
 

1228
00:27:28,880 --> 00:27:30,789
크기.
어, 그러니까 count는

1229
00:27:30,789 --> 00:27:30,799
어, 그러니까 count는
 

1230
00:27:30,799 --> 00:27:33,510
어, 그러니까 count는
서브리 안에 있는 노드의 개수와 높이를 나타내는 것과 같은 거죠

1231
00:27:33,510 --> 00:27:33,520
서브리 안에 있는 노드의 개수와 높이를 나타내는 것과 같은 거죠
 

1232
00:27:33,520 --> 00:27:36,390
서브리 안에 있는 노드의 개수와 높이를 나타내는 것과 같은 거죠
?  AVL 트리라서 그런 거죠?

1233
00:27:36,390 --> 00:27:36,400
?  AVL 트리라서 그런 거죠?
 

1234
00:27:36,400 --> 00:27:39,110
?  AVL 트리라서 그런 거죠?
음, 그러니까 만약 제가 서브트리에서 최댓값으로 확장을 한다면, 그건

1235
00:27:39,110 --> 00:27:39,120
음, 그러니까 만약 제가 서브트리에서 최댓값으로 확장을 한다면, 그건
 

1236
00:27:39,120 --> 00:27:40,710
음, 그러니까 만약 제가 서브트리에서 최댓값으로 확장을 한다면, 그건

1237
00:27:40,710 --> 00:27:40,720

 

1238
00:27:40,720 --> 00:27:43,190

제 표준 인터페이스에 포함되지 않는 부분이니까

1239
00:27:43,190 --> 00:27:43,200
제 표준 인터페이스에 포함되지 않는 부분이니까
 

1240
00:27:43,200 --> 00:27:45,029
제 표준 인터페이스에 포함되지 않는 부분이니까
알려주셔야 해요.

1241
00:27:45,029 --> 00:27:45,039
알려주셔야 해요.
 

1242
00:27:45,039 --> 00:27:46,390
알려주셔야 해요.
전에 해본 적이 있더라도

1243
00:27:46,390 --> 00:27:46,400
전에 해본 적이 있더라도
 

1244
00:27:46,400 --> 00:27:48,470
전에 해본 적이 있더라도
아주 쉽게 할 수 있을 거예요. 그냥

1245
00:27:48,470 --> 00:27:48,480
아주 쉽게 할 수 있을 거예요. 그냥
 

1246
00:27:48,480 --> 00:27:51,430
아주 쉽게 할 수 있을 거예요. 그냥
최댓값으로 확장한다는 건

1247
00:27:51,430 --> 00:27:51,440
최댓값으로 확장한다는 건
 

1248
00:27:51,440 --> 00:27:54,149
최댓값으로 확장한다는 건
저와 왼쪽 및 오른쪽

1249
00:27:54,149 --> 00:27:54,159
저와 왼쪽 및 오른쪽
 

1250
00:27:54,159 --> 00:27:57,110
저와 왼쪽 및 오른쪽
서브트리(존재한다면) 사이의 최댓값으로 계산할 수 있다는 거죠. 하지만 그냥 그렇게 하셔야 해요.

1251
00:27:57,110 --> 00:27:59,590
서브트리(존재한다면) 사이의 최댓값으로 계산할 수 있다는 거죠. 하지만 그냥 그렇게 하셔야 해요.
 

1252
00:27:59,590 --> 00:27:59,600

 

1253
00:27:59,600 --> 00:28:01,750

그리고 그건 상수 시간 안에 처리될 수 있으니까요.

1254
00:28:01,750 --> 00:28:01,760
그리고 그건 상수 시간 안에 처리될 수 있으니까요.
 

1255
00:28:01,760 --> 00:28:04,070
그리고 그건 상수 시간 안에 처리될 수 있으니까요.
제가 작업하는 동안에도 상수 시간 안에 유지될 수 있을 거예요. 이해되셨나요? 네.

1256
00:28:04,070 --> 00:28:07,909
제가 작업하는 동안에도 상수 시간 안에 유지될 수 있을 거예요. 이해되셨나요? 네.
 

1257
00:28:07,909 --> 00:28:07,919

 

1258
00:28:07,919 --> 00:28:10,870

음, 마지막으로,

1259
00:28:10,870 --> 00:28:10,880
음, 마지막으로,
 

1260
00:28:10,880 --> 00:28:12,630
음, 마지막으로,
특히 자료구조

1261
00:28:12,630 --> 00:28:12,640
특히 자료구조
 

1262
00:28:12,640 --> 00:28:16,389
특히 자료구조
문제에 있어서는 인터페이스 관점에서 먼저 문제를

1263
00:28:16,389 --> 00:28:16,399
문제에 있어서는 인터페이스 관점에서 먼저 문제를
 

1264
00:28:16,399 --> 00:28:19,350
문제에 있어서는 인터페이스 관점에서 먼저 문제를
풀어보는 접근 방식을 추천합니다.

1265
00:28:19,350 --> 00:28:21,269
풀어보는 접근 방식을 추천합니다.
 

1266
00:28:21,269 --> 00:28:21,279

 

1267
00:28:21,279 --> 00:28:22,950


1268
00:28:22,950 --> 00:28:22,960

 

1269
00:28:22,960 --> 00:28:25,110

그러면 적어도

1270
00:28:25,110 --> 00:28:25,120
그러면 적어도
 

1271
00:28:25,120 --> 00:28:27,750
그러면 적어도
맞는 결과를 얻을 수 있잖아요, 그렇죠?  그리고

1272
00:28:27,750 --> 00:28:27,760
맞는 결과를 얻을 수 있잖아요, 그렇죠?  그리고
 

1273
00:28:27,760 --> 00:28:30,710
맞는 결과를 얻을 수 있잖아요, 그렇죠?  그리고
나서 그 인터페이스를 구현하는 데 사용할 알고리즘이나 데이터 구조를 선택하는 거죠

1274
00:28:30,710 --> 00:28:32,549
나서 그 인터페이스를 구현하는 데 사용할 알고리즘이나 데이터 구조를 선택하는 거죠
 

1275
00:28:32,549 --> 00:28:32,559

 

1276
00:28:32,559 --> 00:28:35,590

, 그렇죠?  하나는

1277
00:28:35,590 --> 00:28:35,600
, 그렇죠?  하나는
 

1278
00:28:35,600 --> 00:28:37,430
, 그렇죠?  하나는
올바른 알고리즘을 찾는 데 도움이 되고,

1279
00:28:37,430 --> 00:28:37,440
올바른 알고리즘을 찾는 데 도움이 되고,
 

1280
00:28:37,440 --> 00:28:39,110
올바른 알고리즘을 찾는 데 도움이 되고,
다른 하나는 효율성을 위한 것입니다.  오른쪽?

1281
00:28:39,110 --> 00:28:39,120
다른 하나는 효율성을 위한 것입니다.  오른쪽?
 

1282
00:28:39,120 --> 00:28:41,110
다른 하나는 효율성을 위한 것입니다.  오른쪽?
이들을 분리하면 문제 해결에 도움이 될 수 있습니다

1283
00:28:41,110 --> 00:28:41,120
이들을 분리하면 문제 해결에 도움이 될 수 있습니다
 

1284
00:28:41,120 --> 00:28:43,190
이들을 분리하면 문제 해결에 도움이 될 수 있습니다
.

1285
00:28:43,190 --> 00:28:43,200
.
 

1286
00:28:43,200 --> 00:28:45,669
.
도움이 되지 않으면 하지 마세요.  오른쪽?  오른쪽.  만약

1287
00:28:45,669 --> 00:28:45,679
도움이 되지 않으면 하지 마세요.  오른쪽?  오른쪽.  만약
 

1288
00:28:45,679 --> 00:28:47,750
도움이 되지 않으면 하지 마세요.  오른쪽?  오른쪽.  만약
당신이 "특정 데이터 구조를 볼 때마다

1289
00:28:47,750 --> 00:28:49,750
당신이 "특정 데이터 구조를 볼 때마다
 

1290
00:28:49,750 --> 00:28:49,760

 

1291
00:28:49,760 --> 00:28:53,669

해시 테이블을 사용할 것 같다"라고 생각한다면, 그것도 괜찮겠죠?

1292
00:28:53,669 --> 00:28:53,679
해시 테이블을 사용할 것 같다"라고 생각한다면, 그것도 괜찮겠죠?
 

1293
00:28:53,679 --> 00:28:55,350
해시 테이블을 사용할 것 같다"라고 생각한다면, 그것도 괜찮겠죠?
하지만 최악의 경우를 고려한 시간

1294
00:28:55,350 --> 00:28:55,360
하지만 최악의 경우를 고려한 시간
 

1295
00:28:55,360 --> 00:28:57,350
하지만 최악의 경우를 고려한 시간
범위를 찾는다면, 그건 아마 적절하지 않겠죠?

1296
00:28:57,350 --> 00:28:57,360
범위를 찾는다면, 그건 아마 적절하지 않겠죠?
 

1297
00:28:57,360 --> 00:29:01,350
범위를 찾는다면, 그건 아마 적절하지 않겠죠?
그러니까 제가 제안하는 건,

1298
00:29:01,350 --> 00:29:04,470
그러니까 제가 제안하는 건,
 

1299
00:29:04,470 --> 00:29:04,480

 

1300
00:29:04,480 --> 00:29:07,350

이런 것들을 분리해서

1301
00:29:07,350 --> 00:29:07,360
이런 것들을 분리해서
 

1302
00:29:07,360 --> 00:29:08,950
이런 것들을 분리해서
먼저 문제 해결에 집중하고

1303
00:29:08,950 --> 00:29:08,960
먼저 문제 해결에 집중하고
 

1304
00:29:08,960 --> 00:29:11,350
먼저 문제 해결에 집중하고
나중에 최적화하는 겁니다.  응.

1305
00:29:11,350 --> 00:29:11,360
나중에 최적화하는 겁니다.  응.
 

1306
00:29:11,360 --> 00:29:13,110
나중에 최적화하는 겁니다.  응.
최악의 경우 예상 소요 시간에 대해 질문드립니다

1307
00:29:13,110 --> 00:29:13,120
최악의 경우 예상 소요 시간에 대해 질문드립니다
 

1308
00:29:13,120 --> 00:29:15,590
최악의 경우 예상 소요 시간에 대해 질문드립니다
.  음, 그러니까 우리 해시 테이블의 경우,

1309
00:29:15,590 --> 00:29:15,600
.  음, 그러니까 우리 해시 테이블의 경우,
 

1310
00:29:15,600 --> 00:29:18,230
.  음, 그러니까 우리 해시 테이블의 경우,
예상되는 값이 하나라는 것은

1311
00:29:18,230 --> 00:29:18,240
예상되는 값이 하나라는 것은
 

1312
00:29:18,240 --> 00:29:20,470
예상되는 값이 하나라는 것은
최악의 경우를 의미합니다.  그러니까

1313
00:29:20,470 --> 00:29:20,480
최악의 경우를 의미합니다.  그러니까
 

1314
00:29:20,480 --> 00:29:22,149
최악의 경우를 의미합니다.  그러니까
엄밀히 말하면 그게 꼭 맞다는 걸 의미하는 건 아니잖아요

1315
00:29:22,149 --> 00:29:22,159
엄밀히 말하면 그게 꼭 맞다는 걸 의미하는 건 아니잖아요
 

1316
00:29:22,159 --> 00:29:25,029
엄밀히 말하면 그게 꼭 맞다는 걸 의미하는 건 아니잖아요
?  그러니까

1317
00:29:25,029 --> 00:29:26,870
?  그러니까
 

1318
00:29:26,870 --> 00:29:26,880

 

1319
00:29:26,880 --> 00:29:29,350

예상 실행 시간이 상수 시간인 데이터 구조가 있을 수 있지만,

1320
00:29:29,350 --> 00:29:29,360
예상 실행 시간이 상수 시간인 데이터 구조가 있을 수 있지만,
 

1321
00:29:29,360 --> 00:29:31,669
예상 실행 시간이 상수 시간인 데이터 구조가 있을 수 있지만,
최악의 경우 실행 시간은 n log n이 될 수 있다는 거죠.

1322
00:29:31,669 --> 00:29:33,909
최악의 경우 실행 시간은 n log n이 될 수 있다는 거죠.
 

1323
00:29:33,909 --> 00:29:33,919

 

1324
00:29:33,919 --> 00:29:36,070

해시 테이블의 경우 최악의 연산은 선형 시간 복잡도를 갖는다는 사실이 우연히 밝혀진 것일 뿐입니다. 자,

1325
00:29:36,070 --> 00:29:39,350
해시 테이블의 경우 최악의 연산은 선형 시간 복잡도를 갖는다는 사실이 우연히 밝혀진 것일 뿐입니다. 자,
 

1326
00:29:39,350 --> 00:29:39,360

 

1327
00:29:39,360 --> 00:29:41,750

앞서 질문에서처럼,

1328
00:29:41,750 --> 00:29:44,630
앞서 질문에서처럼,
 

1329
00:29:44,630 --> 00:29:44,640

 

1330
00:29:44,640 --> 00:29:47,430

해시 테이블에서 어떤 작업을 수행했을 때 예상 실행 시간이 상수 시간이라고 가정해 봅시다. 예를 들어

1331
00:29:47,430 --> 00:29:50,149
해시 테이블에서 어떤 작업을 수행했을 때 예상 실행 시간이 상수 시간이라고 가정해 봅시다. 예를 들어
 

1332
00:29:50,149 --> 00:29:50,159

 

1333
00:29:50,159 --> 00:29:54,230

조회를 하거나, AV/VL

1334
00:29:54,230 --> 00:29:54,240
조회를 하거나, AV/VL
 

1335
00:29:54,240 --> 00:29:56,230
조회를 하거나, AV/VL
트리에서 노드의 이전 노드를 조회하는 데 O

1336
00:29:56,230 --> 00:29:59,350
트리에서 노드의 이전 노드를 조회하는 데 O
 

1337
00:29:59,350 --> 00:29:59,360

 

1338
00:29:59,360 --> 00:30:02,470

log N 시간이 걸린다고 해봅시다. 이 경우

1339
00:30:02,470 --> 00:30:02,480
log N 시간이 걸린다고 해봅시다. 이 경우
 

1340
00:30:02,480 --> 00:30:04,230
log N 시간이 걸린다고 해봅시다. 이 경우
최악의 실행 시간은 얼마일까요? 다시 말해,

1341
00:30:04,230 --> 00:30:04,240
최악의 실행 시간은 얼마일까요? 다시 말해,
 

1342
00:30:04,240 --> 00:30:08,549
최악의 실행 시간은 얼마일까요? 다시 말해,
예상

1343
00:30:08,549 --> 00:30:08,559
예상
 

1344
00:30:08,559 --> 00:30:11,510
예상
실행 시간은

1345
00:30:11,510 --> 00:30:11,520
실행 시간은
 

1346
00:30:11,520 --> 00:30:14,630
실행 시간은
log N = n log n이 되는 거죠.

1347
00:30:14,630 --> 00:30:14,640
log N = n log n이 되는 거죠.
 

1348
00:30:14,640 --> 00:30:16,070
log N = n log n이 되는 거죠.
최악의 경우 예상 실행 시간이

1349
00:30:16,070 --> 00:30:16,080
최악의 경우 예상 실행 시간이
 

1350
00:30:16,080 --> 00:30:19,029
최악의 경우 예상 실행 시간이
더 높을 수도 있으니까요. 이해되시죠? 네,

1351
00:30:19,029 --> 00:30:19,039
더 높을 수도 있으니까요. 이해되시죠? 네,
 

1352
00:30:19,039 --> 00:30:21,190
더 높을 수도 있으니까요. 이해되시죠? 네,

1353
00:30:21,190 --> 00:30:21,200

 

1354
00:30:21,200 --> 00:30:22,950


1355
00:30:22,950 --> 00:30:22,960

 

1356
00:30:22,960 --> 00:30:27,830

두 번째 질문은

1357
00:30:27,830 --> 00:30:27,840
두 번째 질문은
 

1358
00:30:27,840 --> 00:30:29,430
두 번째 질문은
데이터 구조 문제를 설정하는 것입니다.

1359
00:30:29,430 --> 00:30:29,440
데이터 구조 문제를 설정하는 것입니다.
 

1360
00:30:29,440 --> 00:30:31,190
데이터 구조 문제를 설정하는 것입니다.
여러 가지 요소가 복합적으로 작용하는데,

1361
00:30:31,190 --> 00:30:32,789
여러 가지 요소가 복합적으로 작용하는데,
 

1362
00:30:32,789 --> 00:30:32,799

 

1363
00:30:32,799 --> 00:30:35,990

이번 세션 마지막에 두 가지 데이터 구조 문제를 풀어볼 겁니다.

1364
00:30:35,990 --> 00:30:38,310
이번 세션 마지막에 두 가지 데이터 구조 문제를 풀어볼 겁니다.
 

1365
00:30:38,310 --> 00:30:38,320

 

1366
00:30:38,320 --> 00:30:41,190

여러분이 사용하는 모든 데이터 구조를 설명하고, 각각

1367
00:30:41,190 --> 00:30:41,200
여러분이 사용하는 모든 데이터 구조를 설명하고, 각각
 

1368
00:30:41,200 --> 00:30:42,789
여러분이 사용하는 모든 데이터 구조를 설명하고, 각각
무엇을 저장하는지 적어보세요. 만약

1369
00:30:42,789 --> 00:30:42,799
무엇을 저장하는지 적어보세요. 만약
 

1370
00:30:42,799 --> 00:30:44,789
무엇을 저장하는지 적어보세요. 만약
집합 데이터 구조를 사용한다면,

1371
00:30:44,789 --> 00:30:44,799
집합 데이터 구조를 사용한다면,
 

1372
00:30:44,799 --> 00:30:46,470
집합 데이터 구조를 사용한다면,
어떤 요소들을 저장하는지 자세히 설명해 주셔야 합니다.

1373
00:30:46,470 --> 00:30:46,480
어떤 요소들을 저장하는지 자세히 설명해 주셔야 합니다.
 

1374
00:30:46,480 --> 00:30:49,990
어떤 요소들을 저장하는지 자세히 설명해 주셔야 합니다.
저장된 데이터는 일반적으로 키를 기준으로 관리되며,

1375
00:30:49,990 --> 00:30:50,000
저장된 데이터는 일반적으로 키를 기준으로 관리되며,
 

1376
00:30:50,000 --> 00:30:51,750
저장된 데이터는 일반적으로 키를 기준으로 관리되며,
우리가 저장하는 데이터에는

1377
00:30:51,750 --> 00:30:51,760
우리가 저장하는 데이터에는
 

1378
00:30:51,760 --> 00:30:53,510
우리가 저장하는 데이터에는
많은 정보가 담겨 있습니다.  만약 당신이 "

1379
00:30:53,510 --> 00:30:56,310
많은 정보가 담겨 있습니다.  만약 당신이 "
 

1380
00:30:56,310 --> 00:30:56,320

 

1381
00:30:56,320 --> 00:30:59,750

피자 토핑을 전부 집합 데이터 구조에 저장하고 있어요."라고만 말하고 그게 전부라면

1382
00:30:59,750 --> 00:30:59,760
피자 토핑을 전부 집합 데이터 구조에 저장하고 있어요."라고만 말하고 그게 전부라면
 

1383
00:30:59,760 --> 00:31:01,990
피자 토핑을 전부 집합 데이터 구조에 저장하고 있어요."라고만 말하고 그게 전부라면
, 저는

1384
00:31:01,990 --> 00:31:02,000
, 저는
 

1385
00:31:02,000 --> 00:31:03,350
, 저는
당신이 말하는 게 무슨 뜻인지 전혀 모르겠어요. 왜냐하면

1386
00:31:03,350 --> 00:31:04,549
당신이 말하는 게 무슨 뜻인지 전혀 모르겠어요. 왜냐하면
 

1387
00:31:04,549 --> 00:31:04,559

 

1388
00:31:04,559 --> 00:31:05,990

집합 데이터 구조의 의미론을 모르기 때문이죠.  무엇에 초점을 맞추고 있나요

1389
00:31:05,990 --> 00:31:06,000
집합 데이터 구조의 의미론을 모르기 때문이죠.  무엇에 초점을 맞추고 있나요
 

1390
00:31:06,000 --> 00:31:08,230
집합 데이터 구조의 의미론을 모르기 때문이죠.  무엇에 초점을 맞추고 있나요
?  오른쪽?  음, 뭐라고 해야 할까요

1391
00:31:08,230 --> 00:31:08,240
?  오른쪽?  음, 뭐라고 해야 할까요
 

1392
00:31:08,240 --> 00:31:11,350
?  오른쪽?  음, 뭐라고 해야 할까요
, 현명함이나 그런 쪽에 초점을 맞춘 것 같네요

1393
00:31:11,350 --> 00:31:11,360
, 현명함이나 그런 쪽에 초점을 맞춘 것 같네요
 

1394
00:31:11,360 --> 00:31:14,230
, 현명함이나 그런 쪽에 초점을 맞춘 것 같네요
, 그렇죠?

1395
00:31:14,230 --> 00:31:14,240
, 그렇죠?
 

1396
00:31:14,240 --> 00:31:16,149
, 그렇죠?
좋아요.  그리고 그것들은 불변성이죠, 그렇죠?

1397
00:31:16,149 --> 00:31:16,159
좋아요.  그리고 그것들은 불변성이죠, 그렇죠?
 

1398
00:31:16,159 --> 00:31:18,070
좋아요.  그리고 그것들은 불변성이죠, 그렇죠?
이러한 데이터

1399
00:31:18,070 --> 00:31:18,080
이러한 데이터
 

1400
00:31:18,080 --> 00:31:20,710
이러한 데이터
구조 문제를 어떻게 설정하는지 설명하자면, 저는 보통

1401
00:31:20,710 --> 00:31:20,720
구조 문제를 어떻게 설정하는지 설명하자면, 저는 보통
 

1402
00:31:20,720 --> 00:31:23,350
구조 문제를 어떻게 설정하는지 설명하자면, 저는 보통
해결책을 작성할 때

1403
00:31:23,350 --> 00:31:27,350
해결책을 작성할 때
 

1404
00:31:27,350 --> 00:31:27,360

 

1405
00:31:27,360 --> 00:31:29,269

데이터 구조가 특정 시점에서 어떤 상태일 수 있는지를 정의합니다. 예를 들어,

1406
00:31:29,269 --> 00:31:29,279
데이터 구조가 특정 시점에서 어떤 상태일 수 있는지를 정의합니다. 예를 들어,
 

1407
00:31:29,279 --> 00:31:31,510
데이터 구조가 특정 시점에서 어떤 상태일 수 있는지를 정의합니다. 예를 들어,
이 데이터 구조는 키가 K보다 작은

1408
00:31:31,510 --> 00:31:31,520
이 데이터 구조는 키가 K보다 작은
 

1409
00:31:31,520 --> 00:31:33,430
이 데이터 구조는 키가 K보다 작은
모든 항목을 저장하고, 이 데이터 구조는

1410
00:31:33,430 --> 00:31:36,470
모든 항목을 저장하고, 이 데이터 구조는
 

1411
00:31:36,470 --> 00:31:39,509

 

1412
00:31:39,509 --> 00:31:39,519

 

1413
00:31:39,519 --> 00:31:43,669

항목들의 외재적 순서를 저장하는 식입니다. 이렇게

1414
00:31:43,669 --> 00:31:46,870
항목들의 외재적 순서를 저장하는 식입니다. 이렇게
 

1415
00:31:46,870 --> 00:31:46,880

 

1416
00:31:46,880 --> 00:31:49,190

저장하는 내용을 명시하는 것은

1417
00:31:49,190 --> 00:31:51,509
저장하는 내용을 명시하는 것은
 

1418
00:31:51,509 --> 00:31:53,750

 

1419
00:31:53,750 --> 00:31:53,760

 

1420
00:31:53,760 --> 00:31:55,430

제가 유지 관리하고자 하는 데이터 구조에 일종의 불변 조건을 부여하는 것과 같습니다.

1421
00:31:55,430 --> 00:31:55,440
제가 유지 관리하고자 하는 데이터 구조에 일종의 불변 조건을 부여하는 것과 같습니다.
 

1422
00:31:55,440 --> 00:31:57,990
제가 유지 관리하고자 하는 데이터 구조에 일종의 불변 조건을 부여하는 것과 같습니다.
하지만 제가

1423
00:31:57,990 --> 00:31:58,000
하지만 제가
 

1424
00:31:58,000 --> 00:32:00,789
하지만 제가
이 내용이 옳다는 것을 증명하려면,

1425
00:32:00,789 --> 00:32:03,750
이 내용이 옳다는 것을 증명하려면,
 

1426
00:32:03,750 --> 00:32:03,760

 

1427
00:32:03,760 --> 00:32:07,830

제 수술 전에 그러한 불변 조건들이 유지되었다는 가정을 바탕으로 해야 하는 거죠, 그렇죠?

1428
00:32:07,830 --> 00:32:07,840
제 수술 전에 그러한 불변 조건들이 유지되었다는 가정을 바탕으로 해야 하는 거죠, 그렇죠?
 

1429
00:32:07,840 --> 00:32:09,590
제 수술 전에 그러한 불변 조건들이 유지되었다는 가정을 바탕으로 해야 하는 거죠, 그렇죠?
그렇다면 연산 전후에 모든 불변 조건이 유지된다면 그 연산이 올바르다는 것을 증명할 수 있습니다. 제가

1430
00:32:09,590 --> 00:32:11,990
그렇다면 연산 전후에 모든 불변 조건이 유지된다면 그 연산이 올바르다는 것을 증명할 수 있습니다. 제가
 

1431
00:32:11,990 --> 00:32:15,590

 

1432
00:32:15,590 --> 00:32:17,509

 

1433
00:32:17,509 --> 00:32:17,519

 

1434
00:32:17,519 --> 00:32:19,269

이 데이터 구조의

1435
00:32:19,269 --> 00:32:19,279
이 데이터 구조의
 

1436
00:32:19,279 --> 00:32:21,029
이 데이터 구조의
정확성을 증명하는 방식이 바로 이런 겁니다. 그리고

1437
00:32:21,029 --> 00:32:21,039
정확성을 증명하는 방식이 바로 이런 겁니다. 그리고
 

1438
00:32:21,039 --> 00:32:22,870
정확성을 증명하는 방식이 바로 이런 겁니다. 그리고
데이터

1439
00:32:22,870 --> 00:32:22,880
데이터
 

1440
00:32:22,880 --> 00:32:25,350
데이터
구조에 대한 조회를 할 때, 저는 이러한 불변 조건에 의존할 수 있습니다. 즉, 이러한 조건들이 유지되어 왔다는 것을 알고 있기 때문에, 이 불변 조건을 바탕으로 '이 데이터 구조의

1441
00:32:25,350 --> 00:32:27,509
구조에 대한 조회를 할 때, 저는 이러한 불변 조건에 의존할 수 있습니다. 즉, 이러한 조건들이 유지되어 왔다는 것을 알고 있기 때문에, 이 불변 조건을 바탕으로 '이 데이터 구조의
 

1442
00:32:27,509 --> 00:32:30,070

 

1443
00:32:30,070 --> 00:32:32,470

 

1444
00:32:32,470 --> 00:32:32,480

 

1445
00:32:32,480 --> 00:32:34,710

최대 K 값은 얼마인가?'와 같은 정보를 조회할 수 있습니다. 이 설명이 추상적으로 이해가 되시나요? 잠시 후

1446
00:32:34,710 --> 00:32:37,110
최대 K 값은 얼마인가?'와 같은 정보를 조회할 수 있습니다. 이 설명이 추상적으로 이해가 되시나요? 잠시 후
 

1447
00:32:37,110 --> 00:32:37,120

 

1448
00:32:37,120 --> 00:32:39,830

좀 더 구체적으로 설명해 드리겠습니다

1449
00:32:39,830 --> 00:32:39,840
좀 더 구체적으로 설명해 드리겠습니다
 

1450
00:32:39,840 --> 00:32:43,029
좀 더 구체적으로 설명해 드리겠습니다
.  그리고 나서 모든 작업을 실행합니다

1451
00:32:43,029 --> 00:32:43,039
.  그리고 나서 모든 작업을 실행합니다
 

1452
00:32:43,039 --> 00:32:45,509
.  그리고 나서 모든 작업을 실행합니다
.

1453
00:32:45,509 --> 00:32:45,519
.
 

1454
00:32:45,519 --> 00:32:48,149
.
우리가 퀴즈에 얼마나 많은 풀이를 쓰고 읽는지 전혀 모르시겠죠

1455
00:32:48,149 --> 00:32:48,159
우리가 퀴즈에 얼마나 많은 풀이를 쓰고 읽는지 전혀 모르시겠죠
 

1456
00:32:48,159 --> 00:32:51,110
우리가 퀴즈에 얼마나 많은 풀이를 쓰고 읽는지 전혀 모르시겠죠
?  우리가

1457
00:32:51,110 --> 00:32:51,120
?  우리가
 

1458
00:32:51,120 --> 00:32:54,070
?  우리가
구현해야 할 세 가지 작업을 제시했는데, 그중

1459
00:32:54,070 --> 00:32:56,470
구현해야 할 세 가지 작업을 제시했는데, 그중
 

1460
00:32:56,470 --> 00:32:56,480

 

1461
00:32:56,480 --> 00:32:58,549

가장 쉬운 작업 하나조차 언급하지 않았군요.  마치

1462
00:32:58,549 --> 00:32:58,559
가장 쉬운 작업 하나조차 언급하지 않았군요.  마치
 

1463
00:32:58,559 --> 00:33:00,870
가장 쉬운 작업 하나조차 언급하지 않았군요.  마치
데이터 구조에 삽입하는 것과 같습니다.  그냥 솔직하게

1464
00:33:00,870 --> 00:33:00,880
데이터 구조에 삽입하는 것과 같습니다.  그냥 솔직하게
 

1465
00:33:00,880 --> 00:33:02,870
데이터 구조에 삽입하는 것과 같습니다.  그냥 솔직하게
말해버리면 되잖아, 그렇지?

1466
00:33:02,870 --> 00:33:02,880
말해버리면 되잖아, 그렇지?
 

1467
00:33:02,880 --> 00:33:04,389
말해버리면 되잖아, 그렇지?
해당 수술을 언급하지 않으시면 포인트를 드릴 수 없습니다

1468
00:33:04,389 --> 00:33:04,399
해당 수술을 언급하지 않으시면 포인트를 드릴 수 없습니다
 

1469
00:33:04,399 --> 00:33:07,669
해당 수술을 언급하지 않으시면 포인트를 드릴 수 없습니다
.  이해가 되시나요?  어, 그러면 저희처럼

1470
00:33:07,669 --> 00:33:10,630
.  이해가 되시나요?  어, 그러면 저희처럼
 

1471
00:33:10,630 --> 00:33:10,640

 

1472
00:33:10,640 --> 00:33:13,750

채점자들이 더 높은 점수를 줄 수 있도록 도와줄 거예요.  사실 그렇지 않죠

1473
00:33:13,750 --> 00:33:13,760
채점자들이 더 높은 점수를 줄 수 있도록 도와줄 거예요.  사실 그렇지 않죠
 

1474
00:33:13,760 --> 00:33:16,630
채점자들이 더 높은 점수를 줄 수 있도록 도와줄 거예요.  사실 그렇지 않죠
, 그렇죠?  하지만, 만약 여러분의

1475
00:33:16,630 --> 00:33:16,640
, 그렇죠?  하지만, 만약 여러분의
 

1476
00:33:16,640 --> 00:33:19,750
, 그렇죠?  하지만, 만약 여러분의
풀이가 잘 정리되어 있고 논리적으로 잘 구성되어 있다면

1477
00:33:19,750 --> 00:33:19,760
풀이가 잘 정리되어 있고 논리적으로 잘 구성되어 있다면
 

1478
00:33:19,760 --> 00:33:22,149
풀이가 잘 정리되어 있고 논리적으로 잘 구성되어 있다면
, 저희는

1479
00:33:22,149 --> 00:33:22,159
, 저희는
 

1480
00:33:22,159 --> 00:33:24,710
, 저희는
여러분의 풀이를

1481
00:33:24,710 --> 00:33:24,720
여러분의 풀이를
 

1482
00:33:24,720 --> 00:33:26,070
여러분의 풀이를
더 잘 이해하고

1483
00:33:26,070 --> 00:33:26,080
더 잘 이해하고
 

1484
00:33:26,080 --> 00:33:27,430
더 잘 이해하고
더 높은 점수를 드릴 수 있을 겁니다.  이 수업의 일부는

1485
00:33:27,430 --> 00:33:27,440
더 높은 점수를 드릴 수 있을 겁니다.  이 수업의 일부는
 

1486
00:33:27,440 --> 00:33:31,029
더 높은 점수를 드릴 수 있을 겁니다.  이 수업의 일부는
소통에 관한 것임을 명심하세요.  당신이 제시한

1487
00:33:31,029 --> 00:33:31,039
소통에 관한 것임을 명심하세요.  당신이 제시한
 

1488
00:33:31,039 --> 00:33:34,310
소통에 관한 것임을 명심하세요.  당신이 제시한
내용이 맞더라도,

1489
00:33:34,310 --> 00:33:34,320
내용이 맞더라도,
 

1490
00:33:34,320 --> 00:33:37,029
내용이 맞더라도,
우리가 당신이 무슨 말을 하는지 알아들을 수 없다면,

1491
00:33:37,029 --> 00:33:37,039
우리가 당신이 무슨 말을 하는지 알아들을 수 없다면,
 

1492
00:33:37,039 --> 00:33:40,630
우리가 당신이 무슨 말을 하는지 알아들을 수 없다면,
그것은 틀린 것입니다.  오른쪽.

1493
00:33:40,630 --> 00:33:40,640
그것은 틀린 것입니다.  오른쪽.
 

1494
00:33:40,640 --> 00:33:42,149
그것은 틀린 것입니다.  오른쪽.
오른쪽.

1495
00:33:42,149 --> 00:33:42,159
오른쪽.
 

1496
00:33:42,159 --> 00:33:44,389
오른쪽.
좋아요.

1497
00:33:44,389 --> 00:33:44,399
좋아요.
 

1498
00:33:44,399 --> 00:33:47,590
좋아요.
괜찮은.  자, 그럼 이제

1499
00:33:47,590 --> 00:33:47,600
괜찮은.  자, 그럼 이제
 

1500
00:33:47,600 --> 00:33:49,990
괜찮은.  자, 그럼 이제
질문 좀 드려도 될까요?  응.  분산에 관한 질문입니다

1501
00:33:49,990 --> 00:33:50,000
질문 좀 드려도 될까요?  응.  분산에 관한 질문입니다
 

1502
00:33:50,000 --> 00:33:52,070
질문 좀 드려도 될까요?  응.  분산에 관한 질문입니다
.  그렇다면

1503
00:33:52,070 --> 00:33:52,080
.  그렇다면
 

1504
00:33:52,080 --> 00:33:53,509
.  그렇다면
우리가 과거에 논의했던 데이터 구조에는 어떤 것들이 있을까요

1505
00:33:53,509 --> 00:33:53,519
우리가 과거에 논의했던 데이터 구조에는 어떤 것들이 있을까요
 

1506
00:33:53,519 --> 00:33:55,110
우리가 과거에 논의했던 데이터 구조에는 어떤 것들이 있을까요
?  당신은 여전히

1507
00:33:55,110 --> 00:33:55,120
?  당신은 여전히
 

1508
00:33:55,120 --> 00:33:58,230
?  당신은 여전히
그 나무의 변형 모양이 마음에 드시나요?  오른쪽.  그러니까

1509
00:33:58,230 --> 00:33:58,240
그 나무의 변형 모양이 마음에 드시나요?  오른쪽.  그러니까
 

1510
00:33:58,240 --> 00:34:00,230
그 나무의 변형 모양이 마음에 드시나요?  오른쪽.  그러니까
우리가

1511
00:34:00,230 --> 00:34:00,240
우리가
 

1512
00:34:00,240 --> 00:34:01,669
우리가
이야기할 표준적인 것들에 대해서라면, 지금 표준적인 것들이 무엇인지에 대해서만 이야기하면 됩니다.

1513
00:34:01,669 --> 00:34:05,509
이야기할 표준적인 것들에 대해서라면, 지금 표준적인 것들이 무엇인지에 대해서만 이야기하면 됩니다.
 

1514
00:34:05,509 --> 00:34:05,519

 

1515
00:34:05,519 --> 00:34:08,230

다시 논증하거나 모든 것을 다시 설명할 필요는 없습니다.

1516
00:34:08,230 --> 00:34:08,240
다시 논증하거나 모든 것을 다시 설명할 필요는 없습니다.
 

1517
00:34:08,240 --> 00:34:11,750
다시 논증하거나 모든 것을 다시 설명할 필요는 없습니다.
기본적으로 "

1518
00:34:11,750 --> 00:34:11,760
기본적으로 "
 

1519
00:34:11,760 --> 00:34:14,629
기본적으로 "
집합과 순차 인터페이스가

1520
00:34:14,629 --> 00:34:14,639
집합과 순차 인터페이스가
 

1521
00:34:14,639 --> 00:34:16,069
집합과 순차 인터페이스가
그렇게 정의되어 있기 때문에 이것들은 올바릅니다"라고 말할 수 있습니다.

1522
00:34:16,069 --> 00:34:16,079
그렇게 정의되어 있기 때문에 이것들은 올바릅니다"라고 말할 수 있습니다.
 

1523
00:34:16,079 --> 00:34:19,430
그렇게 정의되어 있기 때문에 이것들은 올바릅니다"라고 말할 수 있습니다.
거의 완벽에 가깝죠.

1524
00:34:19,430 --> 00:34:19,440
거의 완벽에 가깝죠.
 

1525
00:34:19,440 --> 00:34:21,349
거의 완벽에 가깝죠.
기본적으로

1526
00:34:21,349 --> 00:34:21,359
기본적으로
 

1527
00:34:21,359 --> 00:34:24,069
기본적으로
여러분은 왜

1528
00:34:24,069 --> 00:34:24,079
여러분은 왜
 

1529
00:34:24,079 --> 00:34:26,310
여러분은 왜
그것이 올바른지 알고 있다는 것을 우리를 설득하려고 하는 겁니다. 여러분이

1530
00:34:26,310 --> 00:34:28,149
그것이 올바른지 알고 있다는 것을 우리를 설득하려고 하는 겁니다. 여러분이
 

1531
00:34:28,149 --> 00:34:28,159

 

1532
00:34:28,159 --> 00:34:29,990

이러한 데이터 구조 유형 문제에서 집합 또는 순차 데이터 구조를 올바르게 사용한다면, 특이한

1533
00:34:29,990 --> 00:34:33,190
이러한 데이터 구조 유형 문제에서 집합 또는 순차 데이터 구조를 올바르게 사용한다면, 특이한
 

1534
00:34:33,190 --> 00:34:33,200

 

1535
00:34:33,200 --> 00:34:36,790

방식으로 사용하지 않는 한, 일반적으로

1536
00:34:36,790 --> 00:34:40,069
방식으로 사용하지 않는 한, 일반적으로
 

1537
00:34:40,069 --> 00:34:42,149

 

1538
00:34:42,149 --> 00:34:42,159

 

1539
00:34:42,159 --> 00:34:44,470

우리가 제공한 집합 및 순차 데이터 구조의 속성에 의존하면 됩니다. 하지만 여러분이

1540
00:34:44,470 --> 00:34:45,909
우리가 제공한 집합 및 순차 데이터 구조의 속성에 의존하면 됩니다. 하지만 여러분이
 

1541
00:34:45,909 --> 00:34:45,919

 

1542
00:34:45,919 --> 00:34:49,589

정확성에 대해 생각해 보았다는 것을 언급해 주셨으면 합니다. 예를 들어, "

1543
00:34:49,589 --> 00:34:49,599
정확성에 대해 생각해 보았다는 것을 언급해 주셨으면 합니다. 예를 들어, "
 

1544
00:34:49,599 --> 00:34:51,190
정확성에 대해 생각해 보았다는 것을 언급해 주셨으면 합니다. 예를 들어, "

1545
00:34:51,190 --> 00:34:51,200

 

1546
00:34:51,200 --> 00:34:53,990

이 데이터 구조는 올바릅니다.

1547
00:34:53,990 --> 00:34:56,230
이 데이터 구조는 올바릅니다.
 

1548
00:34:56,230 --> 00:35:00,470

 

1549
00:35:00,470 --> 00:35:02,230

 

1550
00:35:02,230 --> 00:35:04,230

 

1551
00:35:04,230 --> 00:35:04,240

 

1552
00:35:04,240 --> 00:35:06,390

왜냐하면..."과 같이 문장으로 설명하고, 상위 수준에서 데이터 구조의 불변성을 유지하고 있다는 것을 논증해 주세요.

1553
00:35:06,390 --> 00:35:06,400
왜냐하면..."과 같이 문장으로 설명하고, 상위 수준에서 데이터 구조의 불변성을 유지하고 있다는 것을 논증해 주세요.
 

1554
00:35:06,400 --> 00:35:08,870
왜냐하면..."과 같이 문장으로 설명하고, 상위 수준에서 데이터 구조의 불변성을 유지하고 있다는 것을 논증해 주세요.
이 데이터 구조는 어떤 종류의 데이터를 저장하나요?

1555
00:35:08,870 --> 00:35:12,870
이 데이터 구조는 어떤 종류의 데이터를 저장하나요?
 

1556
00:35:12,870 --> 00:35:12,880

 

1557
00:35:12,880 --> 00:35:15,910

우리는 쿼리 작업을 수행하기 위해 전역 데이터 구조의 어떤 부분에 의존하고 있습니까

1558
00:35:15,910 --> 00:35:15,920
우리는 쿼리 작업을 수행하기 위해 전역 데이터 구조의 어떤 부분에 의존하고 있습니까
 

1559
00:35:15,920 --> 00:35:17,670
우리는 쿼리 작업을 수행하기 위해 전역 데이터 구조의 어떤 부분에 의존하고 있습니까
?

1560
00:35:17,670 --> 00:35:21,030
?
 

1561
00:35:21,030 --> 00:35:21,040

 

1562
00:35:21,040 --> 00:35:23,109

동적 연산을 통해

1563
00:35:23,109 --> 00:35:23,119
동적 연산을 통해
 

1564
00:35:23,119 --> 00:35:25,349
동적 연산을 통해
데이터 구조를 수정한 후에도 해당 불변 조건들이

1565
00:35:25,349 --> 00:35:25,359
데이터 구조를 수정한 후에도 해당 불변 조건들이
 

1566
00:35:25,359 --> 00:35:27,589
데이터 구조를 수정한 후에도 해당 불변 조건들이
그대로 유지되고 여전히

1567
00:35:27,589 --> 00:35:27,599
그대로 유지되고 여전히
 

1568
00:35:27,599 --> 00:35:29,109
그대로 유지되고 여전히
만족된다는 것을 설득력 있게 보여줄 수 있다면, 그것으로 충분합니다.

1569
00:35:29,109 --> 00:35:31,030
만족된다는 것을 설득력 있게 보여줄 수 있다면, 그것으로 충분합니다.
 

1570
00:35:31,030 --> 00:35:31,040

 

1571
00:35:31,040 --> 00:35:34,310

이러한 불변 조건들은

1572
00:35:34,310 --> 00:35:37,430
이러한 불변 조건들은
 

1573
00:35:37,430 --> 00:35:37,440

 

1574
00:35:37,440 --> 00:35:39,109

집합과 순열 데이터 구조의 정의 때문에 만족되는 것이죠.

1575
00:35:39,109 --> 00:35:39,119
집합과 순열 데이터 구조의 정의 때문에 만족되는 것이죠.
 

1576
00:35:39,119 --> 00:35:40,870
집합과 순열 데이터 구조의 정의 때문에 만족되는 것이죠.
많은 경우, 이 문제는

1577
00:35:40,870 --> 00:35:40,880
많은 경우, 이 문제는
 

1578
00:35:40,880 --> 00:35:43,670
많은 경우, 이 문제는
깊이 생각할 필요가 없습니다. 우리가

1579
00:35:43,670 --> 00:35:43,680
깊이 생각할 필요가 없습니다. 우리가
 

1580
00:35:43,680 --> 00:35:45,990
깊이 생각할 필요가 없습니다. 우리가
묻는 것은

1581
00:35:45,990 --> 00:35:46,000
묻는 것은
 

1582
00:35:46,000 --> 00:35:48,710
묻는 것은
환원 문제를 푸는 이유가 아니니까요.  그래서

1583
00:35:48,710 --> 00:35:48,720
환원 문제를 푸는 이유가 아니니까요.  그래서
 

1584
00:35:48,720 --> 00:35:50,470
환원 문제를 푸는 이유가 아니니까요.  그래서
당신이

1585
00:35:50,470 --> 00:35:50,480
당신이
 

1586
00:35:50,480 --> 00:35:52,630
당신이
우리에게 그것이 옳다는 것을 증명하기 위해 많은 노력을 기울일 필요가 없도록 하려는 거죠?  저희는

1587
00:35:52,630 --> 00:35:52,640
우리에게 그것이 옳다는 것을 증명하기 위해 많은 노력을 기울일 필요가 없도록 하려는 거죠?  저희는
 

1588
00:35:52,640 --> 00:35:54,870
우리에게 그것이 옳다는 것을 증명하기 위해 많은 노력을 기울일 필요가 없도록 하려는 거죠?  저희는
아주 멋진 검은색 상자들을 가지고 있습니다.  그들의 말이

1589
00:35:54,870 --> 00:35:54,880
아주 멋진 검은색 상자들을 가지고 있습니다.  그들의 말이
 

1590
00:35:54,880 --> 00:35:57,030
아주 멋진 검은색 상자들을 가지고 있습니다.  그들의 말이
맞습니다.  우리는

1591
00:35:57,030 --> 00:35:57,040
맞습니다.  우리는
 

1592
00:35:57,040 --> 00:35:58,870
맞습니다.  우리는
그들의 주장이 옳다는 것을 증명해 보였습니다.  그래서

1593
00:35:58,870 --> 00:35:58,880
그들의 주장이 옳다는 것을 증명해 보였습니다.  그래서
 

1594
00:35:58,880 --> 00:36:02,230
그들의 주장이 옳다는 것을 증명해 보였습니다.  그래서
그 작업을 다시 할 필요가 없습니다.  좋아요?  자, 이제

1595
00:36:02,230 --> 00:36:04,950
그 작업을 다시 할 필요가 없습니다.  좋아요?  자, 이제
 

1596
00:36:04,950 --> 00:36:07,589

 

1597
00:36:07,589 --> 00:36:07,599

 

1598
00:36:07,599 --> 00:36:09,670

이 수업에서 제가 중요하게 생각하는 핵심 내용을 살펴보겠습니다.  이 수업

1599
00:36:09,670 --> 00:36:09,680
이 수업에서 제가 중요하게 생각하는 핵심 내용을 살펴보겠습니다.  이 수업
 

1600
00:36:09,680 --> 00:36:11,349
이 수업에서 제가 중요하게 생각하는 핵심 내용을 살펴보겠습니다.  이 수업
의 첫 부분은, 수업

1601
00:36:11,349 --> 00:36:14,710
의 첫 부분은, 수업
 

1602
00:36:14,710 --> 00:36:14,720

 

1603
00:36:14,720 --> 00:36:17,510

초반에 다뤘던 수학적 도구들을 제외하고는,

1604
00:36:17,510 --> 00:36:17,520
초반에 다뤘던 수학적 도구들을 제외하고는,
 

1605
00:36:17,520 --> 00:36:18,950
초반에 다뤘던 수학적 도구들을 제외하고는,
주로

1606
00:36:18,950 --> 00:36:18,960
주로
 

1607
00:36:18,960 --> 00:36:20,790
주로
자료 구조와 관련된 문제들을 해결하는 데 중점을 둡니다.

1608
00:36:20,790 --> 00:36:23,270
자료 구조와 관련된 문제들을 해결하는 데 중점을 둡니다.
 

1609
00:36:23,270 --> 00:36:23,280

 

1610
00:36:23,280 --> 00:36:25,829

정렬 문제를 다루게 된 계기는 정렬된 배열이 매우 유용한

1611
00:36:25,829 --> 00:36:25,839
정렬 문제를 다루게 된 계기는 정렬된 배열이 매우 유용한
 

1612
00:36:25,839 --> 00:36:27,430
정렬 문제를 다루게 된 계기는 정렬된 배열이 매우 유용한
자료 구조라는 점을 강조했기 때문입니다.

1613
00:36:27,430 --> 00:36:27,440
자료 구조라는 점을 강조했기 때문입니다.
 

1614
00:36:27,440 --> 00:36:29,670
자료 구조라는 점을 강조했기 때문입니다.
그렇다면 이러한 배열들을 어떻게 정렬할까요? 수업에서는

1615
00:36:29,670 --> 00:36:32,230
그렇다면 이러한 배열들을 어떻게 정렬할까요? 수업에서는
 

1616
00:36:32,230 --> 00:36:32,240

 

1617
00:36:32,240 --> 00:36:35,349

다양한 정렬 방법을 보여드렸고,

1618
00:36:35,349 --> 00:36:35,359
다양한 정렬 방법을 보여드렸고,
 

1619
00:36:35,359 --> 00:36:38,550
다양한 정렬 방법을 보여드렸고,
이 표에 많은

1620
00:36:38,550 --> 00:36:38,560
이 표에 많은
 

1621
00:36:38,560 --> 00:36:41,670
이 표에 많은
내용이 담겨 있습니다.  왜 이렇게 많은

1622
00:36:41,670 --> 00:36:41,680
내용이 담겨 있습니다.  왜 이렇게 많은
 

1623
00:36:41,680 --> 00:36:42,950
내용이 담겨 있습니다.  왜 이렇게 많은
정렬 알고리즘을 보여드리는 걸까요?

1624
00:36:42,950 --> 00:36:42,960
정렬 알고리즘을 보여드리는 걸까요?
 

1625
00:36:42,960 --> 00:36:45,829
정렬 알고리즘을 보여드리는 걸까요?
알고리즘 하나만 드리면 안 될까요?

1626
00:36:45,829 --> 00:36:45,839
알고리즘 하나만 드리면 안 될까요?
 

1627
00:36:45,839 --> 00:36:49,270
알고리즘 하나만 드리면 안 될까요?
H는

1628
00:36:49,270 --> 00:36:49,280

 

1629
00:36:49,280 --> 00:36:51,270

실행 시간이 다릅니다.  상황에 따라 더 나은 선택이 될 수 있습니다

1630
00:36:51,270 --> 00:36:51,280
실행 시간이 다릅니다.  상황에 따라 더 나은 선택이 될 수 있습니다
 

1631
00:36:51,280 --> 00:36:52,550
실행 시간이 다릅니다.  상황에 따라 더 나은 선택이 될 수 있습니다
.

1632
00:36:52,550 --> 00:36:52,560
.
 

1633
00:36:52,560 --> 00:36:54,069
.
상황에 따라 더 나은 선택이 있을 수 있습니다.  네, 각각 더 나은

1634
00:36:54,069 --> 00:36:54,079
상황에 따라 더 나은 선택이 있을 수 있습니다.  네, 각각 더 나은
 

1635
00:36:54,079 --> 00:36:55,670
상황에 따라 더 나은 선택이 있을 수 있습니다.  네, 각각 더 나은
개별적인 구성 요소를 가지고 있을 수 있습니다

1636
00:36:55,670 --> 00:36:55,680
개별적인 구성 요소를 가지고 있을 수 있습니다
 

1637
00:36:55,680 --> 00:36:58,630
개별적인 구성 요소를 가지고 있을 수 있습니다
.  네, 이

1638
00:36:58,630 --> 00:36:58,640
.  네, 이
 

1639
00:36:58,640 --> 00:37:02,069
.  네, 이
표를 보시면 아시겠지만,

1640
00:37:02,069 --> 00:37:02,079
표를 보시면 아시겠지만,
 

1641
00:37:02,079 --> 00:37:03,990
표를 보시면 아시겠지만,
이 항목들 중 어느 것도 파란색으로 완전히 표시된 경우는 없죠

1642
00:37:03,990 --> 00:37:04,000
이 항목들 중 어느 것도 파란색으로 완전히 표시된 경우는 없죠
 

1643
00:37:04,000 --> 00:37:06,790
이 항목들 중 어느 것도 파란색으로 완전히 표시된 경우는 없죠
?  그래서 어떤 것들은

1644
00:37:06,790 --> 00:37:06,800
?  그래서 어떤 것들은
 

1645
00:37:06,800 --> 00:37:08,630
?  그래서 어떤 것들은
상황에 따라 더 적합한 경우가 있습니다.  그리고 실제로 이러한

1646
00:37:08,630 --> 00:37:08,640
상황에 따라 더 적합한 경우가 있습니다.  그리고 실제로 이러한
 

1647
00:37:08,640 --> 00:37:11,990
상황에 따라 더 적합한 경우가 있습니다.  그리고 실제로 이러한
댓글들은 이러한 것들이 더 나을 수 있는 몇 가지 특별한 경우를 나열하고 있습니다

1648
00:37:11,990 --> 00:37:12,000
댓글들은 이러한 것들이 더 나을 수 있는 몇 가지 특별한 경우를 나열하고 있습니다
 

1649
00:37:12,000 --> 00:37:13,670
댓글들은 이러한 것들이 더 나을 수 있는 몇 가지 특별한 경우를 나열하고 있습니다
.

1650
00:37:13,670 --> 00:37:13,680
.
 

1651
00:37:13,680 --> 00:37:17,030
.
오른쪽?  실제로 이 초청색

1652
00:37:17,030 --> 00:37:17,040
오른쪽?  실제로 이 초청색
 

1653
00:37:17,040 --> 00:37:19,910
오른쪽?  실제로 이 초청색
물체는 이것이

1654
00:37:19,910 --> 00:37:19,920
물체는 이것이
 

1655
00:37:19,920 --> 00:37:22,630
물체는 이것이
선형적인 시간일 수 있다는 것을 말하고 있는 것 같습니다. 그게 더 낫습니다.  오른쪽?  하지만

1656
00:37:22,630 --> 00:37:22,640
선형적인 시간일 수 있다는 것을 말하고 있는 것 같습니다. 그게 더 낫습니다.  오른쪽?  하지만
 

1657
00:37:22,640 --> 00:37:24,470
선형적인 시간일 수 있다는 것을 말하고 있는 것 같습니다. 그게 더 낫습니다.  오른쪽?  하지만
어떤 경우에는 이것이

1658
00:37:24,470 --> 00:37:24,480
어떤 경우에는 이것이
 

1659
00:37:24,480 --> 00:37:28,310
어떤 경우에는 이것이
다른 모든 것보다 더 나쁠 수 있습니다.  오른쪽?  그러니 이 파란색에 조금 주의하세요

1660
00:37:28,310 --> 00:37:28,320
다른 모든 것보다 더 나쁠 수 있습니다.  오른쪽?  그러니 이 파란색에 조금 주의하세요
 

1661
00:37:28,320 --> 00:37:32,150
다른 모든 것보다 더 나쁠 수 있습니다.  오른쪽?  그러니 이 파란색에 조금 주의하세요
.  좋아요.  일반적으로

1662
00:37:32,150 --> 00:37:32,160
.  좋아요.  일반적으로
 

1663
00:37:32,160 --> 00:37:34,630
.  좋아요.  일반적으로
저희는 여러분이

1664
00:37:34,630 --> 00:37:34,640
저희는 여러분이
 

1665
00:37:34,640 --> 00:37:37,910
저희는 여러분이
이 차트에서 더 아래쪽에 위치하도록 도와드리려고 합니다.  오른쪽?

1666
00:37:37,910 --> 00:37:37,920
이 차트에서 더 아래쪽에 위치하도록 도와드리려고 합니다.  오른쪽?
 

1667
00:37:37,920 --> 00:37:40,710
이 차트에서 더 아래쪽에 위치하도록 도와드리려고 합니다.  오른쪽?
일반적으로

1668
00:37:40,710 --> 00:37:40,720
일반적으로
 

1669
00:37:40,720 --> 00:37:44,950
일반적으로
병합 정렬이나 AVL 정렬 같은

1670
00:37:44,950 --> 00:37:44,960
병합 정렬이나 AVL 정렬 같은
 

1671
00:37:44,960 --> 00:37:47,109
병합 정렬이나 AVL 정렬 같은
알고리즘은

1672
00:37:47,109 --> 00:37:47,119
알고리즘은
 

1673
00:37:47,119 --> 00:37:49,510
알고리즘은
수학적 복잡도나

1674
00:37:49,510 --> 00:37:51,270
수학적 복잡도나
 

1675
00:37:51,270 --> 00:37:51,280

 

1676
00:37:51,280 --> 00:37:54,150

알고리즘을 다루는 방식 면에서 거의 동일합니다.  하지만

1677
00:37:54,150 --> 00:37:54,160
알고리즘을 다루는 방식 면에서 거의 동일합니다.  하지만
 

1678
00:37:54,160 --> 00:37:57,349
알고리즘을 다루는 방식 면에서 거의 동일합니다.  하지만
삽입 정렬

1679
00:37:57,349 --> 00:37:57,359
삽입 정렬
 

1680
00:37:57,359 --> 00:37:59,349
삽입 정렬
이나 선택 정렬을 사용해야 하는 특별한 경우가 있습니다.  사실

1681
00:37:59,349 --> 00:37:59,359
이나 선택 정렬을 사용해야 하는 특별한 경우가 있습니다.  사실
 

1682
00:37:59,359 --> 00:38:02,790
이나 선택 정렬을 사용해야 하는 특별한 경우가 있습니다.  사실
삽입 정렬에 대해서는 잘 모르겠습니다.  제가 기억하기로,

1683
00:38:02,790 --> 00:38:05,990
삽입 정렬에 대해서는 잘 모르겠습니다.  제가 기억하기로,
 

1684
00:38:05,990 --> 00:38:06,000

 

1685
00:38:06,000 --> 00:38:09,750

이틀 전에 발표 시간에 여러분들이 서로 k개 이내의 거리에 있는 요소들로 이루어진

1686
00:38:09,750 --> 00:38:09,760
이틀 전에 발표 시간에 여러분들이 서로 k개 이내의 거리에 있는 요소들로 이루어진
 

1687
00:38:09,760 --> 00:38:12,790
이틀 전에 발표 시간에 여러분들이 서로 k개 이내의 거리에 있는 요소들로 이루어진
크소 배열을 어떻게 푸는지 보여주셨던 것 같아요

1688
00:38:12,790 --> 00:38:15,349
크소 배열을 어떻게 푸는지 보여주셨던 것 같아요
 

1689
00:38:15,349 --> 00:38:15,359

 

1690
00:38:15,359 --> 00:38:17,349

.  삽입 정렬은

1691
00:38:17,349 --> 00:38:17,359
.  삽입 정렬은
 

1692
00:38:17,359 --> 00:38:19,270
.  삽입 정렬은
실제로 n 곱하기 k의 시간 복잡도로 실행되므로 k가

1693
00:38:19,270 --> 00:38:19,280
실제로 n 곱하기 k의 시간 복잡도로 실행되므로 k가
 

1694
00:38:19,280 --> 00:38:21,190
실제로 n 곱하기 k의 시간 복잡도로 실행되므로 k가
작으면 매우 효율적입니다.  그건 마치

1695
00:38:21,190 --> 00:38:21,200
작으면 매우 효율적입니다.  그건 마치
 

1696
00:38:21,200 --> 00:38:22,870
작으면 매우 효율적입니다.  그건 마치
선형적인 것과 비슷하네요.  하지만

1697
00:38:22,870 --> 00:38:22,880
선형적인 것과 비슷하네요.  하지만
 

1698
00:38:22,880 --> 00:38:25,910
선형적인 것과 비슷하네요.  하지만
실제로 이진 힙을 사용하면 훨씬 더 나은 결과를 얻을 수 있습니다.

1699
00:38:25,910 --> 00:38:25,920
실제로 이진 힙을 사용하면 훨씬 더 나은 결과를 얻을 수 있습니다.
 

1700
00:38:25,920 --> 00:38:27,589
실제로 이진 힙을 사용하면 훨씬 더 나은 결과를 얻을 수 있습니다.
수업 시간에 보셨겠지만,

1701
00:38:27,589 --> 00:38:29,430
수업 시간에 보셨겠지만,
 

1702
00:38:29,430 --> 00:38:29,440

 

1703
00:38:29,440 --> 00:38:33,030

힙을 계속 유지하면서

1704
00:38:33,030 --> 00:38:33,040
힙을 계속 유지하면서
 

1705
00:38:33,040 --> 00:38:35,510
힙을 계속 유지하면서
최대값을 찾는

1706
00:38:35,510 --> 00:38:35,520
최대값을 찾는
 

1707
00:38:35,520 --> 00:38:39,589
최대값을 찾는
방식으로 계산하면 n log k까지 줄일 수 있습니다.  좋아요.  음, 삽입 정렬은

1708
00:38:39,589 --> 00:38:39,599
방식으로 계산하면 n log k까지 줄일 수 있습니다.  좋아요.  음, 삽입 정렬은
 

1709
00:38:39,599 --> 00:38:42,550
방식으로 계산하면 n log k까지 줄일 수 있습니다.  좋아요.  음, 삽입 정렬은
그다지 좋지 않을 수도 있지만, 선택 정렬은 다릅니다.

1710
00:38:42,550 --> 00:38:42,560
그다지 좋지 않을 수도 있지만, 선택 정렬은 다릅니다.
 

1711
00:38:42,560 --> 00:38:45,430
그다지 좋지 않을 수도 있지만, 선택 정렬은 다릅니다.
핵심은

1712
00:38:45,430 --> 00:38:45,440
핵심은
 

1713
00:38:45,440 --> 00:38:50,950
핵심은
읽기 비용이 저렴하고 읽기 비용이 비싼 경우에 선택

1714
00:38:50,950 --> 00:38:50,960
읽기 비용이 저렴하고 읽기 비용이 비싼 경우에 선택
 

1715
00:38:50,960 --> 00:38:54,150
읽기 비용이 저렴하고 읽기 비용이 비싼 경우에 선택
정렬이 매우

1716
00:38:54,150 --> 00:38:54,160
정렬이 매우
 

1717
00:38:54,160 --> 00:38:55,670
정렬이 매우
효율적이라는 것입니다. 왜냐하면 읽기 비용은 저렴하고 읽기 비용은 비싸기 때문에

1718
00:38:55,670 --> 00:38:57,990
효율적이라는 것입니다. 왜냐하면 읽기 비용은 저렴하고 읽기 비용은 비싸기 때문에
 

1719
00:38:57,990 --> 00:39:00,390

 

1720
00:39:00,390 --> 00:39:00,400

 

1721
00:39:00,400 --> 00:39:01,910

선택 정렬은 선형적인 스왑 횟수만 수행하기 때문입니다. 즉,

1722
00:39:01,910 --> 00:39:03,589
선택 정렬은 선형적인 스왑 횟수만 수행하기 때문입니다. 즉,
 

1723
00:39:03,589 --> 00:39:03,599

 

1724
00:39:03,599 --> 00:39:05,589

가장 저렴한 스왑을 찾아 삽입하고 계속 반복하는 방식입니다.

1725
00:39:05,589 --> 00:39:05,599
가장 저렴한 스왑을 찾아 삽입하고 계속 반복하는 방식입니다.
 

1726
00:39:05,599 --> 00:39:08,470
가장 저렴한 스왑을 찾아 삽입하고 계속 반복하는 방식입니다.
따라서 이러한 경우에는 선택 정렬이

1727
00:39:08,470 --> 00:39:08,480
따라서 이러한 경우에는 선택 정렬이
 

1728
00:39:08,480 --> 00:39:10,310
따라서 이러한 경우에는 선택 정렬이
다른

1729
00:39:10,310 --> 00:39:10,320
다른
 

1730
00:39:10,320 --> 00:39:13,030
다른
알고리즘들보다 훨씬 뛰어납니다.  응.  그는

1731
00:39:13,030 --> 00:39:13,040
알고리즘들보다 훨씬 뛰어납니다.  응.  그는
 

1732
00:39:13,040 --> 00:39:17,190
알고리즘들보다 훨씬 뛰어납니다.  응.  그는
최악의 경우를 대비해서 시간을 두고 기다리는 건가요, 아니면 예상되는 상황인가요?

1733
00:39:17,190 --> 00:39:17,200
최악의 경우를 대비해서 시간을 두고 기다리는 건가요, 아니면 예상되는 상황인가요?
 

1734
00:39:17,200 --> 00:39:20,310
최악의 경우를 대비해서 시간을 두고 기다리는 건가요, 아니면 예상되는 상황인가요?
이것은 최악의 경우입니다.  좋아요.

1735
00:39:20,310 --> 00:39:21,829
이것은 최악의 경우입니다.  좋아요.
 

1736
00:39:21,829 --> 00:39:24,550

 

1737
00:39:24,550 --> 00:39:24,560

 

1738
00:39:24,560 --> 00:39:27,430

화요일 강의에서 다룬 내용에 이르기까지 여러 가지 복잡한 과정이 있었기 때문에 한마디로 표현하기가 좀 어렵네요.  네,

1739
00:39:27,430 --> 00:39:27,440
화요일 강의에서 다룬 내용에 이르기까지 여러 가지 복잡한 과정이 있었기 때문에 한마디로 표현하기가 좀 어렵네요.  네,
 

1740
00:39:27,440 --> 00:39:29,190
화요일 강의에서 다룬 내용에 이르기까지 여러 가지 복잡한 과정이 있었기 때문에 한마디로 표현하기가 좀 어렵네요.  네,
기본적으로 저희는

1741
00:39:29,190 --> 00:39:29,200
기본적으로 저희는
 

1742
00:39:29,200 --> 00:39:32,310
기본적으로 저희는
배열을 힙, 즉

1743
00:39:32,310 --> 00:39:32,320
배열을 힙, 즉
 

1744
00:39:32,320 --> 00:39:34,950
배열을 힙, 즉
이진 트리처럼 생각하는 방법을 보여드렸습니다.  완전 이진

1745
00:39:34,950 --> 00:39:34,960
이진 트리처럼 생각하는 방법을 보여드렸습니다.  완전 이진
 

1746
00:39:34,960 --> 00:39:37,349
이진 트리처럼 생각하는 방법을 보여드렸습니다.  완전 이진
트리.  AVL이 아닙니다.  그러니까, 이건

1747
00:39:37,349 --> 00:39:37,359
트리.  AVL이 아닙니다.  그러니까, 이건
 

1748
00:39:37,359 --> 00:39:41,349
트리.  AVL이 아닙니다.  그러니까, 이건
AVL 트리인데, AVL 트리는

1749
00:39:41,349 --> 00:39:41,359
AVL 트리인데, AVL 트리는
 

1750
00:39:41,359 --> 00:39:43,510
AVL 트리인데, AVL 트리는
완전한 트리보다 약하잖아요, 그렇죠?  높이

1751
00:39:43,510 --> 00:39:43,520
완전한 트리보다 약하잖아요, 그렇죠?  높이
 

1752
00:39:43,520 --> 00:39:45,270
완전한 트리보다 약하잖아요, 그렇죠?  높이
균형은 완전한 균형보다 약한 속성 아닌가요

1753
00:39:45,270 --> 00:39:45,280
균형은 완전한 균형보다 약한 속성 아닌가요
 

1754
00:39:45,280 --> 00:39:47,910
균형은 완전한 균형보다 약한 속성 아닌가요
?

1755
00:39:47,910 --> 00:39:47,920
?
 

1756
00:39:47,920 --> 00:39:51,510
?
우리가 complete라는 용어를 사용하는 이유는

1757
00:39:51,510 --> 00:39:51,520
우리가 complete라는 용어를 사용하는 이유는
 

1758
00:39:51,520 --> 00:39:55,430
우리가 complete라는 용어를 사용하는 이유는
여러 노드에 대해 고유하기 때문이죠, 그렇죠?  그렇게 하면

1759
00:39:55,430 --> 00:39:57,430
여러 노드에 대해 고유하기 때문이죠, 그렇죠?  그렇게 하면
 

1760
00:39:57,430 --> 00:39:57,440

 

1761
00:39:57,440 --> 00:39:59,510

길이가 고정된 배열 하나를 드렸을 때, 그 안에 일대일 대응 관계가 있기 때문에 어떤 트리를 말씀하시는 건지 정확히 알 수 있죠

1762
00:39:59,510 --> 00:40:01,270
길이가 고정된 배열 하나를 드렸을 때, 그 안에 일대일 대응 관계가 있기 때문에 어떤 트리를 말씀하시는 건지 정확히 알 수 있죠
 

1763
00:40:01,270 --> 00:40:01,280

 

1764
00:40:01,280 --> 00:40:05,750

?  만약 제가

1765
00:40:05,750 --> 00:40:09,030
?  만약 제가
 

1766
00:40:09,030 --> 00:40:09,040

 

1767
00:40:09,040 --> 00:40:11,510

어떤 트리에 대해 이야기하고 있는지에 대한 모호함이 있었다면, 힙 정렬은

1768
00:40:11,510 --> 00:40:11,520
어떤 트리에 대해 이야기하고 있는지에 대한 모호함이 있었다면, 힙 정렬은
 

1769
00:40:11,520 --> 00:40:14,150
어떤 트리에 대해 이야기하고 있는지에 대한 모호함이 있었다면, 힙 정렬은
제대로 작동하지 않았을 겁니다.

1770
00:40:14,150 --> 00:40:14,160
제대로 작동하지 않았을 겁니다.
 

1771
00:40:14,160 --> 00:40:16,630
제대로 작동하지 않았을 겁니다.
힙 정렬은

1772
00:40:16,630 --> 00:40:16,640
힙 정렬은
 

1773
00:40:16,640 --> 00:40:18,630
힙 정렬은
배열과 이진 트리 사이의 대응 관계를 이용하여, 배열의 끝에서만

1774
00:40:18,630 --> 00:40:22,069
배열과 이진 트리 사이의 대응 관계를 이용하여, 배열의 끝에서만
 

1775
00:40:22,069 --> 00:40:24,150

 

1776
00:40:24,150 --> 00:40:24,160

 

1777
00:40:24,160 --> 00:40:27,190

연산을 수행하는 기능을 제공합니다. 그리고 제자리

1778
00:40:27,190 --> 00:40:27,200
연산을 수행하는 기능을 제공합니다. 그리고 제자리
 

1779
00:40:27,200 --> 00:40:30,470
연산을 수행하는 기능을 제공합니다. 그리고 제자리
최적화는

1780
00:40:30,470 --> 00:40:32,310
최적화는
 

1781
00:40:32,310 --> 00:40:32,320

 

1782
00:40:32,320 --> 00:40:34,710

배열에서 요소를 팝하거나 푸시하는 대신, 요소를 제자리에 두는 것입니다.

1783
00:40:34,710 --> 00:40:36,870
배열에서 요소를 팝하거나 푸시하는 대신, 요소를 제자리에 두는 것입니다.
 

1784
00:40:36,870 --> 00:40:36,880

 

1785
00:40:36,880 --> 00:40:41,589

배열의 부분집합을 힙으로 생각하고, 항상

1786
00:40:41,589 --> 00:40:41,599
배열의 부분집합을 힙으로 생각하고, 항상
 

1787
00:40:41,599 --> 00:40:44,230
배열의 부분집합을 힙으로 생각하고, 항상
최대값을 끝으로 보내는 방식으로 생각하면 되는 거죠

1788
00:40:44,230 --> 00:40:44,240
최대값을 끝으로 보내는 방식으로 생각하면 되는 거죠
 

1789
00:40:44,240 --> 00:40:48,069
최대값을 끝으로 보내는 방식으로 생각하면 되는 거죠
?  그냥 그걸 뒤에 두고

1790
00:40:48,069 --> 00:40:48,079
?  그냥 그걸 뒤에 두고
 

1791
00:40:48,079 --> 00:40:50,950
?  그냥 그걸 뒤에 두고
내 힙을 더 작은 부분집합으로 생각하면 되는 거죠

1792
00:40:50,950 --> 00:40:50,960
내 힙을 더 작은 부분집합으로 생각하면 되는 거죠
 

1793
00:40:50,960 --> 00:40:54,630
내 힙을 더 작은 부분집합으로 생각하면 되는 거죠
?  그렇게 해서 얻게 된 겁니다.

1794
00:40:54,630 --> 00:40:54,640
?  그렇게 해서 얻게 된 겁니다.
 

1795
00:40:54,640 --> 00:40:57,510
?  그렇게 해서 얻게 된 겁니다.
실제로 만기 상환을 위한 상각 방식을 사용하지 않았습니다

1796
00:40:57,510 --> 00:40:57,520
실제로 만기 상환을 위한 상각 방식을 사용하지 않았습니다
 

1797
00:40:57,520 --> 00:41:01,109
실제로 만기 상환을 위한 상각 방식을 사용하지 않았습니다
.

1798
00:41:01,109 --> 00:41:01,119
.
 

1799
00:41:01,119 --> 00:41:02,309
.
실제로 이와 유사한

1800
00:41:02,309 --> 00:41:02,319
실제로 이와 유사한
 

1801
00:41:02,319 --> 00:41:05,030
실제로 이와 유사한
동적 배열 버전(상각화된 버전)을 사용하면 이 작업을 수행할 수 있습니다

1802
00:41:05,030 --> 00:41:05,040
동적 배열 버전(상각화된 버전)을 사용하면 이 작업을 수행할 수 있습니다
 

1803
00:41:05,040 --> 00:41:06,790
동적 배열 버전(상각화된 버전)을 사용하면 이 작업을 수행할 수 있습니다
.  시간 제한은

1804
00:41:06,790 --> 00:41:06,800
.  시간 제한은
 

1805
00:41:06,800 --> 00:41:10,710
.  시간 제한은
그것에 의존하지 않습니다.  이 방식은

1806
00:41:10,710 --> 00:41:10,720
그것에 의존하지 않습니다.  이 방식은
 

1807
00:41:10,720 --> 00:41:12,710
그것에 의존하지 않습니다.  이 방식은
모든 키가 하나의 배열 내에 유지된다는 것을 전제로 합니다.

1808
00:41:12,710 --> 00:41:15,270
모든 키가 하나의 배열 내에 유지된다는 것을 전제로 합니다.
 

1809
00:41:15,270 --> 00:41:15,280

 

1810
00:41:15,280 --> 00:41:17,510

여러 개의 분할 상환 작업을 수행하여

1811
00:41:17,510 --> 00:41:17,520
여러 개의 분할 상환 작업을 수행하여
 

1812
00:41:17,520 --> 00:41:19,030
여러 개의 분할 상환 작업을 수행하여
최악의 경우

1813
00:41:19,030 --> 00:41:19,040
최악의 경우
 

1814
00:41:19,040 --> 00:41:21,990
최악의 경우
와 로그인 상황을 실제로 구현하는 것이 타당하다고 생각하시나요?  응.  오래전에

1815
00:41:21,990 --> 00:41:22,000
와 로그인 상황을 실제로 구현하는 것이 타당하다고 생각하시나요?  응.  오래전에
 

1816
00:41:22,000 --> 00:41:24,630
와 로그인 상황을 실제로 구현하는 것이 타당하다고 생각하시나요?  응.  오래전에
배운 것들이 아닐수록 더

1817
00:41:24,630 --> 00:41:24,640
배운 것들이 아닐수록 더
 

1818
00:41:24,640 --> 00:41:26,950
배운 것들이 아닐수록 더
나은 경향이 있는 것 같습니다.  그러니까

1819
00:41:26,950 --> 00:41:26,960
나은 경향이 있는 것 같습니다.  그러니까
 

1820
00:41:26,960 --> 00:41:28,710
나은 경향이 있는 것 같습니다.  그러니까
여러분이 원하는 대부분의 알고리즘이

1821
00:41:28,710 --> 00:41:31,270
여러분이 원하는 대부분의 알고리즘이
 

1822
00:41:31,270 --> 00:41:31,280

 

1823
00:41:31,280 --> 00:41:34,069

더 빠르다고 가정해 보세요.  음,

1824
00:41:34,069 --> 00:41:34,079
더 빠르다고 가정해 보세요.  음,
 

1825
00:41:34,079 --> 00:41:36,309
더 빠르다고 가정해 보세요.  음,
특히 시험에서는

1826
00:41:36,309 --> 00:41:36,319
특히 시험에서는
 

1827
00:41:36,319 --> 00:41:38,470
특히 시험에서는
삽입과 선택 연산을 그렇게 자주 사용하지는 않을 것 같네요. 그렇죠? 물론

1828
00:41:38,470 --> 00:41:38,480
삽입과 선택 연산을 그렇게 자주 사용하지는 않을 것 같네요. 그렇죠? 물론
 

1829
00:41:38,480 --> 00:41:39,829
삽입과 선택 연산을 그렇게 자주 사용하지는 않을 것 같네요. 그렇죠? 물론
특별한 경우에는

1830
00:41:39,829 --> 00:41:39,839
특별한 경우에는
 

1831
00:41:39,839 --> 00:41:43,910
특별한 경우에는
유용하지만,

1832
00:41:43,910 --> 00:41:43,920
유용하지만,
 

1833
00:41:43,920 --> 00:41:46,390
유용하지만,
일반적으로는

1834
00:41:46,390 --> 00:41:46,400
일반적으로는
 

1835
00:41:46,400 --> 00:41:48,710
일반적으로는
대부분의 상황에서 더 나은 일반적인 데이터 구조를 사용하는 게 좋잖아요

1836
00:41:48,710 --> 00:41:48,720
대부분의 상황에서 더 나은 일반적인 데이터 구조를 사용하는 게 좋잖아요
 

1837
00:41:48,720 --> 00:41:50,790
대부분의 상황에서 더 나은 일반적인 데이터 구조를 사용하는 게 좋잖아요
.  물론

1838
00:41:50,790 --> 00:41:50,800
.  물론
 

1839
00:41:50,800 --> 00:41:52,470
.  물론
다른 요소들이 도움이 되는 경우도 있어서

1840
00:41:52,470 --> 00:41:52,480
다른 요소들이 도움이 되는 경우도 있어서
 

1841
00:41:52,480 --> 00:41:53,990
다른 요소들이 도움이 되는 경우도 있어서
완전히 무시할 수는 없지만,

1842
00:41:53,990 --> 00:41:54,000
완전히 무시할 수는 없지만,
 

1843
00:41:54,000 --> 00:41:57,510
완전히 무시할 수는 없지만,
일반적으로는

1844
00:41:57,510 --> 00:41:57,520
일반적으로는
 

1845
00:41:57,520 --> 00:41:59,109
일반적으로는
이 차트에서 아래쪽에 위치하는 것이 좋겠죠.  제

1846
00:41:59,109 --> 00:41:59,119
이 차트에서 아래쪽에 위치하는 것이 좋겠죠.  제
 

1847
00:41:59,119 --> 00:42:00,950
이 차트에서 아래쪽에 위치하는 것이 좋겠죠.  제
말은, 만약 제가 시험을 전혀 치르지 않는다면,

1848
00:42:00,950 --> 00:42:02,870
말은, 만약 제가 시험을 전혀 치르지 않는다면,
 

1849
00:42:02,870 --> 00:42:02,880

 

1850
00:42:02,880 --> 00:42:05,349

선택 영역을 제외한 모든 영역을

1851
00:42:05,349 --> 00:42:06,950
선택 영역을 제외한 모든 영역을
 

1852
00:42:06,950 --> 00:42:06,960

 

1853
00:42:06,960 --> 00:42:10,150

시험에 담을 수 없을 거라는 뜻입니다. 시험 범위가 너무 넓어서 모든 영역을 다 테스트하는 건 불가능하거든요.  좋아요.  그러니

1854
00:42:10,150 --> 00:42:10,160
시험에 담을 수 없을 거라는 뜻입니다. 시험 범위가 너무 넓어서 모든 영역을 다 테스트하는 건 불가능하거든요.  좋아요.  그러니
 

1855
00:42:10,160 --> 00:42:12,390
시험에 담을 수 없을 거라는 뜻입니다. 시험 범위가 너무 넓어서 모든 영역을 다 테스트하는 건 불가능하거든요.  좋아요.  그러니
모든 내용이 다 포함되지 않았다고 해서 걱정하지 마세요.

1856
00:42:12,390 --> 00:42:14,710
모든 내용이 다 포함되지 않았다고 해서 걱정하지 마세요.
 

1857
00:42:14,710 --> 00:42:14,720

 

1858
00:42:14,720 --> 00:42:17,270

시험에 18번이나 나오는 내용이라면 걱정할 만하죠.  그건 좋지 않죠, 그렇죠?  음,

1859
00:42:17,270 --> 00:42:17,280
시험에 18번이나 나오는 내용이라면 걱정할 만하죠.  그건 좋지 않죠, 그렇죠?  음,
 

1860
00:42:17,280 --> 00:42:20,309
시험에 18번이나 나오는 내용이라면 걱정할 만하죠.  그건 좋지 않죠, 그렇죠?  음,
알겠습니다.  그래서 근사 정렬에는

1861
00:42:20,309 --> 00:42:20,319
알겠습니다.  그래서 근사 정렬에는
 

1862
00:42:20,319 --> 00:42:22,870
알겠습니다.  그래서 근사 정렬에는
선형

1863
00:42:22,870 --> 00:42:22,880
선형
 

1864
00:42:22,880 --> 00:42:24,550
선형
시간 복잡도를 갖는 경우가 있습니다. 바로 다항식 시간 복잡도를 만족할 때죠. 하지만

1865
00:42:24,550 --> 00:42:27,430
시간 복잡도를 갖는 경우가 있습니다. 바로 다항식 시간 복잡도를 만족할 때죠. 하지만
 

1866
00:42:27,430 --> 00:42:30,550

 

1867
00:42:30,550 --> 00:42:30,560

 

1868
00:42:30,560 --> 00:42:37,910

정수의 다항식 시간 복잡도를 만족하지 않는 경우에도 근사 정렬을 사용하면 시간이

1869
00:42:37,910 --> 00:42:39,750

 

1870
00:42:39,750 --> 00:42:39,760

 

1871
00:42:39,760 --> 00:42:41,750

매우 오래 걸릴 수 있습니다.

1872
00:42:41,750 --> 00:42:41,760
매우 오래 걸릴 수 있습니다.
 

1873
00:42:41,760 --> 00:42:46,150
매우 오래 걸릴 수 있습니다.
확신하는.  응.  하지만, 어,

1874
00:42:46,150 --> 00:42:46,160
확신하는.  응.  하지만, 어,
 

1875
00:42:46,160 --> 00:42:52,550
확신하는.  응.  하지만, 어,
이게 n 로그인보다 더 나쁠 거라는 건 확실하죠. 다항식적으로 제한될 때

1876
00:42:52,550 --> 00:42:52,560
이게 n 로그인보다 더 나쁠 거라는 건 확실하죠. 다항식적으로 제한될 때
 

1877
00:42:52,560 --> 00:42:54,390
이게 n 로그인보다 더 나쁠 거라는 건 확실하죠. 다항식적으로 제한될 때
n 로그인보다 확실히 낫잖아요.

1878
00:42:54,390 --> 00:42:58,309
n 로그인보다 확실히 낫잖아요.
 

1879
00:42:58,309 --> 00:42:58,319

 

1880
00:42:58,319 --> 00:43:00,550

왜냐하면 선형이니까요.

1881
00:43:00,550 --> 00:43:00,560
왜냐하면 선형이니까요.
 

1882
00:43:00,560 --> 00:43:02,069
왜냐하면 선형이니까요.
네, n

1883
00:43:02,069 --> 00:43:02,079
네, n
 

1884
00:43:02,079 --> 00:43:03,910
네, n

1885
00:43:03,910 --> 00:43:03,920

 

1886
00:43:03,920 --> 00:43:08,309

의 n승이요. 그래서 여기에 n의 n승을 넣으면

1887
00:43:08,309 --> 00:43:08,319
의 n승이요. 그래서 여기에 n의 n승을 넣으면
 

1888
00:43:08,319 --> 00:43:11,750
의 n승이요. 그래서 여기에 n의 n승을 넣으면
n 인자가 나와서

1889
00:43:11,750 --> 00:43:11,760
n 인자가 나와서
 

1890
00:43:11,760 --> 00:43:14,150
n 인자가 나와서
2차 실행

1891
00:43:14,150 --> 00:43:14,160
2차 실행
 

1892
00:43:14,160 --> 00:43:18,150
2차 실행
시간이 되는데, 이건 좋지 않죠.  좋아요.  하지만

1893
00:43:18,150 --> 00:43:18,160
시간이 되는데, 이건 좋지 않죠.  좋아요.  하지만
 

1894
00:43:18,160 --> 00:43:22,710
시간이 되는데, 이건 좋지 않죠.  좋아요.  하지만
이것이 n 로그인보다 나은 점은 언제쯤 나타날까요?

1895
00:43:22,710 --> 00:43:22,720
이것이 n 로그인보다 나은 점은 언제쯤 나타날까요?
 

1896
00:43:22,720 --> 00:43:26,150
이것이 n 로그인보다 나은 점은 언제쯤 나타날까요?
응.  어, n의 c제곱은 n의 c제곱보다 작습니다

1897
00:43:26,150 --> 00:43:26,160
응.  어, n의 c제곱은 n의 c제곱보다 작습니다
 

1898
00:43:26,160 --> 00:43:29,349
응.  어, n의 c제곱은 n의 c제곱보다 작습니다
.  어, c로.  그럼

1899
00:43:29,349 --> 00:43:29,359
.  어, c로.  그럼
 

1900
00:43:29,359 --> 00:43:31,030
.  어, c로.  그럼
확실히 선형적인 시간을 얻게 되겠죠?

1901
00:43:31,030 --> 00:43:31,040
확실히 선형적인 시간을 얻게 되겠죠?
 

1902
00:43:31,040 --> 00:43:32,550
확실히 선형적인 시간을 얻게 되겠죠?
이것이 말하려는 바가 바로 그것입니다.  하지만

1903
00:43:32,550 --> 00:43:32,560
이것이 말하려는 바가 바로 그것입니다.  하지만
 

1904
00:43:32,560 --> 00:43:37,030
이것이 말하려는 바가 바로 그것입니다.  하지만
만약

1905
00:43:37,030 --> 00:43:37,040
만약
 

1906
00:43:37,040 --> 00:43:42,150
만약
u가 n의 c * log n 제곱이라면, 우리는 실제로 n 로그인보다 더 나은 결과를 얻을 수 있지 않을까요?

1907
00:43:42,150 --> 00:43:42,160
u가 n의 c * log n 제곱이라면, 우리는 실제로 n 로그인보다 더 나은 결과를 얻을 수 있지 않을까요?
 

1908
00:43:42,160 --> 00:43:44,870
u가 n의 c * log n 제곱이라면, 우리는 실제로 n 로그인보다 더 나은 결과를 얻을 수 있지 않을까요?
C의 일부인 거죠, 그렇죠?  만약 그것이 마치

1909
00:43:44,870 --> 00:43:44,880
C의 일부인 거죠, 그렇죠?  만약 그것이 마치
 

1910
00:43:44,880 --> 00:43:48,630
C의 일부인 거죠, 그렇죠?  만약 그것이 마치
N이 C 로그 로그인 로그 N에 대한 것과 같다면, 맞죠?

1911
00:43:48,630 --> 00:43:48,640
N이 C 로그 로그인 로그 N에 대한 것과 같다면, 맞죠?
 

1912
00:43:48,640 --> 00:43:50,230
N이 C 로그 로그인 로그 N에 대한 것과 같다면, 맞죠?
로그인 화면보다 작죠, 그렇죠?  그러니까

1913
00:43:50,230 --> 00:43:50,240
로그인 화면보다 작죠, 그렇죠?  그러니까
 

1914
00:43:50,240 --> 00:43:52,550
로그인 화면보다 작죠, 그렇죠?  그러니까
그게 더 나은 알고리즘이라는 거죠?  저건

1915
00:43:52,550 --> 00:43:52,560
그게 더 나은 알고리즘이라는 거죠?  저건
 

1916
00:43:52,560 --> 00:43:56,069
그게 더 나은 알고리즘이라는 거죠?  저건
더 빠른 알고리즘이에요.  여러분, 우리가

1917
00:43:56,069 --> 00:43:56,079
더 빠른 알고리즘이에요.  여러분, 우리가
 

1918
00:43:56,079 --> 00:43:59,270
더 빠른 알고리즘이에요.  여러분, 우리가
이런 식으로 글을 쓴 이유가

1919
00:43:59,270 --> 00:43:59,280
이런 식으로 글을 쓴 이유가
 

1920
00:43:59,280 --> 00:44:01,750
이런 식으로 글을 쓴 이유가
더 정확한 범위를 제시하기 위해서라는 걸 이해하시겠습니까?  이게

1921
00:44:01,750 --> 00:44:01,760
더 정확한 범위를 제시하기 위해서라는 걸 이해하시겠습니까?  이게
 

1922
00:44:01,760 --> 00:44:03,670
더 정확한 범위를 제시하기 위해서라는 걸 이해하시겠습니까?  이게
당신이 이해해야 할 더 중요한 건,

1923
00:44:03,670 --> 00:44:06,069
당신이 이해해야 할 더 중요한 건,
 

1924
00:44:06,069 --> 00:44:06,079

 

1925
00:44:06,079 --> 00:44:08,069

이게 때때로 선형 시간으로 실행된다는 사실보다 여기서 U가 무엇을 의미하는지 이해하는 겁니다

1926
00:44:08,069 --> 00:44:08,079
이게 때때로 선형 시간으로 실행된다는 사실보다 여기서 U가 무엇을 의미하는지 이해하는 겁니다
 

1927
00:44:08,079 --> 00:44:11,109
이게 때때로 선형 시간으로 실행된다는 사실보다 여기서 U가 무엇을 의미하는지 이해하는 겁니다
, 그렇죠?  우리는 그것이

1928
00:44:11,109 --> 00:44:11,119
, 그렇죠?  우리는 그것이
 

1929
00:44:11,119 --> 00:44:13,270
, 그렇죠?  우리는 그것이
선형 시간으로 실행될 때 당신을 알고 싶어요, 그렇죠?

1930
00:44:13,270 --> 00:44:13,280
선형 시간으로 실행될 때 당신을 알고 싶어요, 그렇죠?
 

1931
00:44:13,280 --> 00:44:15,829
선형 시간으로 실행될 때 당신을 알고 싶어요, 그렇죠?
이해가 되시나요?  또는 병합 정렬보다 실행 속도가 빠를 때

1932
00:44:15,829 --> 00:44:15,839
이해가 되시나요?  또는 병합 정렬보다 실행 속도가 빠를 때
 

1933
00:44:15,839 --> 00:44:19,990
이해가 되시나요?  또는 병합 정렬보다 실행 속도가 빠를 때
.  이해가 되시나요?

1934
00:44:19,990 --> 00:44:20,000
.  이해가 되시나요?
 

1935
00:44:20,000 --> 00:44:23,109
.  이해가 되시나요?
좋아요.  이게 바로 정렬입니다.

1936
00:44:23,109 --> 00:44:23,119
좋아요.  이게 바로 정렬입니다.
 

1937
00:44:23,119 --> 00:44:25,670
좋아요.  이게 바로 정렬입니다.
음, 우리는 순차형 데이터 구조를 가지고 있죠

1938
00:44:25,670 --> 00:44:25,680
음, 우리는 순차형 데이터 구조를 가지고 있죠
 

1939
00:44:25,680 --> 00:44:27,750
음, 우리는 순차형 데이터 구조를 가지고 있죠
, 그렇죠?  우리는 연결 리스트,

1940
00:44:27,750 --> 00:44:27,760
, 그렇죠?  우리는 연결 리스트,
 

1941
00:44:27,760 --> 00:44:29,430
, 그렇죠?  우리는 연결 리스트,
동적 배열, 시퀀스

1942
00:44:29,430 --> 00:44:29,440
동적 배열, 시퀀스
 

1943
00:44:29,440 --> 00:44:32,710
동적 배열, 시퀀스
AVL을 가지고 있습니다.  시퀀스 AVL은 훌륭합니다.

1944
00:44:32,710 --> 00:44:32,720
AVL을 가지고 있습니다.  시퀀스 AVL은 훌륭합니다.
 

1945
00:44:32,720 --> 00:44:34,470
AVL을 가지고 있습니다.  시퀀스 AVL은 훌륭합니다.
왜 아무도 이걸 가르치지 않는지 모르겠어요.  그들은

1946
00:44:34,470 --> 00:44:34,480
왜 아무도 이걸 가르치지 않는지 모르겠어요.  그들은
 

1947
00:44:34,480 --> 00:44:36,710
왜 아무도 이걸 가르치지 않는지 모르겠어요.  그들은
훌륭해요.  아마도

1948
00:44:36,710 --> 00:44:36,720
훌륭해요.  아마도
 

1949
00:44:36,720 --> 00:44:38,790
훌륭해요.  아마도
실제로 그다지

1950
00:44:38,790 --> 00:44:38,800
실제로 그다지
 

1951
00:44:38,800 --> 00:44:41,990
실제로 그다지
유용하지 않아서 가르치지 않는 거겠죠?  코딩할 때

1952
00:44:41,990 --> 00:44:42,000
유용하지 않아서 가르치지 않는 거겠죠?  코딩할 때
 

1953
00:44:42,000 --> 00:44:45,510
유용하지 않아서 가르치지 않는 거겠죠?  코딩할 때
중간에 삽입하는 구문을 실제로 많이 사용하지는 않잖아요,

1954
00:44:45,510 --> 00:44:45,520
중간에 삽입하는 구문을 실제로 많이 사용하지는 않잖아요,
 

1955
00:44:45,520 --> 00:44:47,910
중간에 삽입하는 구문을 실제로 많이 사용하지는 않잖아요,
그렇죠?  그러니까

1956
00:44:47,910 --> 00:44:47,920
그렇죠?  그러니까
 

1957
00:44:47,920 --> 00:44:49,670
그렇죠?  그러니까
보통은

1958
00:44:49,670 --> 00:44:49,680
보통은
 

1959
00:44:49,680 --> 00:44:51,510
보통은
뭔가를 맨 끝으로 옮기고

1960
00:44:51,510 --> 00:44:51,520
뭔가를 맨 끝으로 옮기고
 

1961
00:44:51,520 --> 00:44:53,270
뭔가를 맨 끝으로 옮기고
거기서 동적 연산을 수행하면 해결할 수 있다는 거죠?  그리고

1962
00:44:53,270 --> 00:44:53,280
거기서 동적 연산을 수행하면 해결할 수 있다는 거죠?  그리고
 

1963
00:44:53,280 --> 00:44:54,790
거기서 동적 연산을 수행하면 해결할 수 있다는 거죠?  그리고
그게 바로 당신이 해보려고 하는 게임들 중 상당수입니다

1964
00:44:54,790 --> 00:44:54,800
그게 바로 당신이 해보려고 하는 게임들 중 상당수입니다
 

1965
00:44:54,800 --> 00:44:56,390
그게 바로 당신이 해보려고 하는 게임들 중 상당수입니다
.  그러니까 여러분은 자체적인 데이터 구조를 만들 필요 없이,

1966
00:44:56,390 --> 00:44:58,390
.  그러니까 여러분은 자체적인 데이터 구조를 만들 필요 없이,
 

1967
00:44:58,390 --> 00:44:58,400

 

1968
00:44:58,400 --> 00:45:02,550

여러분의 프로그램에 기본적으로 내장된 파이썬 리스트를 사용할 수 있다는 거죠

1969
00:45:02,550 --> 00:45:02,560
여러분의 프로그램에 기본적으로 내장된 파이썬 리스트를 사용할 수 있다는 거죠
 

1970
00:45:02,560 --> 00:45:04,870
여러분의 프로그램에 기본적으로 내장된 파이썬 리스트를 사용할 수 있다는 거죠
?  하지만 이론적으로는

1971
00:45:04,870 --> 00:45:06,710
?  하지만 이론적으로는
 

1972
00:45:06,710 --> 00:45:09,109

 

1973
00:45:09,109 --> 00:45:09,119

 

1974
00:45:09,119 --> 00:45:10,630

이 시퀀스 중간에 삽입해야 할 경우 이러한 종류의 균형 범위를 얻을 수 있기 때문에 이론적으로 흥미롭습니다

1975
00:45:10,630 --> 00:45:10,640
이 시퀀스 중간에 삽입해야 할 경우 이러한 종류의 균형 범위를 얻을 수 있기 때문에 이론적으로 흥미롭습니다
 

1976
00:45:10,640 --> 00:45:14,950
이 시퀀스 중간에 삽입해야 할 경우 이러한 종류의 균형 범위를 얻을 수 있기 때문에 이론적으로 흥미롭습니다
.  오른쪽?  자, 여러분 중 일부는

1977
00:45:14,950 --> 00:45:14,960
.  오른쪽?  자, 여러분 중 일부는
 

1978
00:45:14,960 --> 00:45:18,150
.  오른쪽?  자, 여러분 중 일부는
저를 보면서 전에 질문을 하셨죠? "

1979
00:45:18,150 --> 00:45:18,160
저를 보면서 전에 질문을 하셨죠? "
 

1980
00:45:18,160 --> 00:45:23,270
저를 보면서 전에 질문을 하셨죠? "
제이슨,

1981
00:45:23,270 --> 00:45:23,280
제이슨,
 

1982
00:45:23,280 --> 00:45:27,430
제이슨,
연결 리스트의 끝 부분에 대한 연산은

1983
00:45:27,430 --> 00:45:27,440
연결 리스트의 끝 부분에 대한 연산은
 

1984
00:45:27,440 --> 00:45:30,309
연결 리스트의 끝 부분에 대한 연산은
왜 선형 시간 복잡도를 가지는 거죠?" 같은 질문 말이에요.

1985
00:45:30,309 --> 00:45:30,319
왜 선형 시간 복잡도를 가지는 거죠?" 같은 질문 말이에요.
 

1986
00:45:30,319 --> 00:45:33,670
왜 선형 시간 복잡도를 가지는 거죠?" 같은 질문 말이에요.
강의에서 우리가 여러분에게 무엇을 제시했기 때문인가요

1987
00:45:33,670 --> 00:45:33,680
강의에서 우리가 여러분에게 무엇을 제시했기 때문인가요
 

1988
00:45:33,680 --> 00:45:37,030
강의에서 우리가 여러분에게 무엇을 제시했기 때문인가요
?

1989
00:45:37,030 --> 00:45:37,040

 

1990
00:45:37,040 --> 00:45:40,230

단일 연결 리스트 맞죠?  그건

1991
00:45:40,230 --> 00:45:40,240
단일 연결 리스트 맞죠?  그건
 

1992
00:45:40,240 --> 00:45:42,630
단일 연결 리스트 맞죠?  그건
다음 단계로 넘어가는 힌트만 준 거잖아요, 그렇죠?

1993
00:45:42,630 --> 00:45:42,640
다음 단계로 넘어가는 힌트만 준 거잖아요, 그렇죠?
 

1994
00:45:42,640 --> 00:45:43,990
다음 단계로 넘어가는 힌트만 준 거잖아요, 그렇죠?
만약 제가 다음

1995
00:45:43,990 --> 00:45:44,000
만약 제가 다음
 

1996
00:45:44,000 --> 00:45:46,470
만약 제가 다음
항목을 가리키는 포인터와 시작점을 가리키는 포인터만 가지고 있다면,

1997
00:45:46,470 --> 00:45:46,480
항목을 가리키는 포인터와 시작점을 가리키는 포인터만 가지고 있다면,
 

1998
00:45:46,480 --> 00:45:49,990
항목을 가리키는 포인터와 시작점을 가리키는 포인터만 가지고 있다면,
끝을 찾을 수 있겠죠?

1999
00:45:49,990 --> 00:45:50,000
끝을 찾을 수 있겠죠?
 

2000
00:45:50,000 --> 00:45:52,790
끝을 찾을 수 있겠죠?
목록의 맨 아래까지 쭉 따라가야 하는 거죠?  자, 제가

2001
00:45:52,790 --> 00:45:52,800
목록의 맨 아래까지 쭉 따라가야 하는 거죠?  자, 제가
 

2002
00:45:52,800 --> 00:45:56,470
목록의 맨 아래까지 쭉 따라가야 하는 거죠?  자, 제가
포인터를 꼬리 쪽으로 향하게 했다고 가정해 봅시다.

2003
00:45:56,470 --> 00:45:56,480
포인터를 꼬리 쪽으로 향하게 했다고 가정해 봅시다.
 

2004
00:45:56,480 --> 00:45:59,349
포인터를 꼬리 쪽으로 향하게 했다고 가정해 봅시다.
끝점을 찾는 건 괜찮지만,

2005
00:45:59,349 --> 00:45:59,359
끝점을 찾는 건 괜찮지만,
 

2006
00:45:59,359 --> 00:46:01,349
끝점을 찾는 건 괜찮지만,
그걸 제거하는 데는 여전히 선형 시간이 걸립니다. 왜냐하면

2007
00:46:01,349 --> 00:46:01,359
그걸 제거하는 데는 여전히 선형 시간이 걸립니다. 왜냐하면
 

2008
00:46:01,359 --> 00:46:04,069
그걸 제거하는 데는 여전히 선형 시간이 걸립니다. 왜냐하면
제 앞에 뭐가 있었는지 모르기 때문이죠. 그래서

2009
00:46:04,069 --> 00:46:04,079
제 앞에 뭐가 있었는지 모르기 때문이죠. 그래서
 

2010
00:46:04,079 --> 00:46:06,790
제 앞에 뭐가 있었는지 모르기 때문이죠. 그래서
펫셋

2011
00:46:06,790 --> 00:46:06,800
펫셋
 

2012
00:46:06,800 --> 00:46:10,390
펫셋
1, 2였던가요? 기억이 잘 안 나지만,

2013
00:46:10,390 --> 00:46:10,400
1, 2였던가요? 기억이 잘 안 나지만,
 

2014
00:46:10,400 --> 00:46:12,470
1, 2였던가요? 기억이 잘 안 나지만,
이전 객체에 대한 포인터를 저장해서

2015
00:46:12,470 --> 00:46:12,480
이전 객체에 대한 포인터를 저장해서
 

2016
00:46:12,480 --> 00:46:14,230
이전 객체에 대한 포인터를 저장해서
이중 연결 리스트를 만들었던 겁니다. 그렇죠?

2017
00:46:14,230 --> 00:46:14,240
이중 연결 리스트를 만들었던 겁니다. 그렇죠?
 

2018
00:46:14,240 --> 00:46:17,430
이중 연결 리스트를 만들었던 겁니다. 그렇죠?
그러니까 이 테이블을 확장하면

2019
00:46:17,430 --> 00:46:19,270
그러니까 이 테이블을 확장하면
 

2020
00:46:19,270 --> 00:46:21,670

 

2021
00:46:21,670 --> 00:46:21,680

 

2022
00:46:21,680 --> 00:46:24,870

여기서 이중 연결 리스트를 참조해서 상수 시간 안에 이 리스트를 얻을 수 있습니다.

2023
00:46:24,870 --> 00:46:24,880
여기서 이중 연결 리스트를 참조해서 상수 시간 안에 이 리스트를 얻을 수 있습니다.
 

2024
00:46:24,880 --> 00:46:26,630
여기서 이중 연결 리스트를 참조해서 상수 시간 안에 이 리스트를 얻을 수 있습니다.
이해가 되시나요?

2025
00:46:26,630 --> 00:46:26,640
이해가 되시나요?
 

2026
00:46:26,640 --> 00:46:30,069
이해가 되시나요?
그리고 이건 여전히 선형 시간이 걸리죠

2027
00:46:30,069 --> 00:46:30,079
그리고 이건 여전히 선형 시간이 걸리죠
 

2028
00:46:30,079 --> 00:46:32,870
그리고 이건 여전히 선형 시간이 걸리죠
?  좋아요.  하지만 이건 여전히

2029
00:46:32,870 --> 00:46:32,880
?  좋아요.  하지만 이건 여전히
 

2030
00:46:32,880 --> 00:46:35,190
?  좋아요.  하지만 이건 여전히
선형적인 시간이에요.  어, 저희는 실제로

2031
00:46:35,190 --> 00:46:35,200
선형적인 시간이에요.  어, 저희는 실제로
 

2032
00:46:35,200 --> 00:46:37,589
선형적인 시간이에요.  어, 저희는 실제로
고정 상각 방식으로 이 작업을 수행하는 방법도 보여드렸습니다

2033
00:46:37,589 --> 00:46:37,599
고정 상각 방식으로 이 작업을 수행하는 방법도 보여드렸습니다
 

2034
00:46:37,599 --> 00:46:40,069
고정 상각 방식으로 이 작업을 수행하는 방법도 보여드렸습니다
.  여러분, 그거 기억하세요?

2035
00:46:40,069 --> 00:46:40,079
.  여러분, 그거 기억하세요?
 

2036
00:46:40,079 --> 00:46:43,589
.  여러분, 그거 기억하세요?
그건 문제 풀이 수업

2037
00:46:43,589 --> 00:46:43,599
그건 문제 풀이 수업
 

2038
00:46:43,599 --> 00:46:46,710
그건 문제 풀이 수업
2회차나 1회차 때였어요.  잘 기억이 안 나는데,

2039
00:46:46,710 --> 00:46:46,720
2회차나 1회차 때였어요.  잘 기억이 안 나는데,
 

2040
00:46:46,720 --> 00:46:48,710
2회차나 1회차 때였어요.  잘 기억이 안 나는데,
우리가 얘기했던 게 뭐였더라? 감가

2041
00:46:48,710 --> 00:46:48,720
우리가 얘기했던 게 뭐였더라? 감가
 

2042
00:46:48,720 --> 00:46:51,270
우리가 얘기했던 게 뭐였더라? 감가
상각 관련 얘기였던 것 같은데, 맞지?  우리는

2043
00:46:51,270 --> 00:46:51,280
상각 관련 얘기였던 것 같은데, 맞지?  우리는
 

2044
00:46:51,280 --> 00:46:54,390
상각 관련 얘기였던 것 같은데, 맞지?  우리는
실제로

2045
00:46:54,390 --> 00:46:54,400
실제로
 

2046
00:46:54,400 --> 00:46:57,589
실제로
동적 배열의 개념을 사용하여 이 두 가지를 모두 하나의 상각 방식으로 처리했습니다.

2047
00:46:57,589 --> 00:46:57,599
동적 배열의 개념을 사용하여 이 두 가지를 모두 하나의 상각 방식으로 처리했습니다.
 

2048
00:46:57,599 --> 00:46:59,589
동적 배열의 개념을 사용하여 이 두 가지를 모두 하나의 상각 방식으로 처리했습니다.
오른쪽?  그리고 나서 우리는 실제로 한 번

2049
00:46:59,589 --> 00:46:59,599
오른쪽?  그리고 나서 우리는 실제로 한 번
 

2050
00:46:59,599 --> 00:47:01,270
오른쪽?  그리고 나서 우리는 실제로 한 번
더 시도해서

2051
00:47:01,270 --> 00:47:01,280
더 시도해서
 

2052
00:47:01,280 --> 00:47:05,190
더 시도해서
양쪽 끝이 모두 사용 가능한 좋은 결과를 얻었습니다.  저게 뭐였지?   혹시

2053
00:47:05,190 --> 00:47:05,200
양쪽 끝이 모두 사용 가능한 좋은 결과를 얻었습니다.  저게 뭐였지?   혹시
 

2054
00:47:05,200 --> 00:47:07,589
양쪽 끝이 모두 사용 가능한 좋은 결과를 얻었습니다.  저게 뭐였지?   혹시
기억하는 사람 있나요?  우리는

2055
00:47:07,589 --> 00:47:07,599
기억하는 사람 있나요?  우리는
 

2056
00:47:07,599 --> 00:47:10,630
기억하는 사람 있나요?  우리는
세 번째 문제 풀이 시간에 들어갔습니다.  응.  아, 제가

2057
00:47:10,630 --> 00:47:10,640
세 번째 문제 풀이 시간에 들어갔습니다.  응.  아, 제가
 

2058
00:47:10,640 --> 00:47:12,630
세 번째 문제 풀이 시간에 들어갔습니다.  응.  아, 제가
틀렸을지도 모르겠네요.  이건

2059
00:47:12,630 --> 00:47:12,640
틀렸을지도 모르겠네요.  이건
 

2060
00:47:12,640 --> 00:47:14,550
틀렸을지도 모르겠네요.  이건
Q와 비슷해요.

2061
00:47:14,550 --> 00:47:14,560
Q와 비슷해요.
 

2062
00:47:14,560 --> 00:47:17,589
Q와 비슷해요.
그러니까 QDQ는

2063
00:47:17,589 --> 00:47:17,599
그러니까 QDQ는
 

2064
00:47:17,599 --> 00:47:20,790
그러니까 QDQ는
양쪽 끝이 있는 것들을 말하는 거죠.  어, 그런 것들은

2065
00:47:20,790 --> 00:47:20,800
양쪽 끝이 있는 것들을 말하는 거죠.  어, 그런 것들은
 

2066
00:47:20,800 --> 00:47:23,270
양쪽 끝이 있는 것들을 말하는 거죠.  어, 그런 것들은
특정한 방식으로 구현되는데,

2067
00:47:23,270 --> 00:47:23,280
특정한 방식으로 구현되는데,
 

2068
00:47:23,280 --> 00:47:25,030
특정한 방식으로 구현되는데,
사실 이것들 중 하나가

2069
00:47:25,030 --> 00:47:25,040
사실 이것들 중 하나가
 

2070
00:47:25,040 --> 00:47:28,950
사실 이것들 중 하나가
파이썬으로 구현된 것 같아요.

2071
00:47:28,950 --> 00:47:28,960
파이썬으로 구현된 것 같아요.
 

2072
00:47:28,960 --> 00:47:31,750
파이썬으로 구현된 것 같아요.
그런데, 우리는

2073
00:47:31,750 --> 00:47:33,829
그런데, 우리는
 

2074
00:47:33,829 --> 00:47:37,190

 

2075
00:47:37,190 --> 00:47:37,200

 

2076
00:47:37,200 --> 00:47:40,790

팝(pop)과 어펜드(append) 같은

2077
00:47:40,790 --> 00:47:40,800
팝(pop)과 어펜드(append) 같은
 

2078
00:47:40,800 --> 00:47:43,109
팝(pop)과 어펜드(append) 같은
동적 연산을 잘 수행하는 다른 데이터 구조를 사용했죠. 혹시

2079
00:47:43,109 --> 00:47:43,119
동적 연산을 잘 수행하는 다른 데이터 구조를 사용했죠. 혹시
 

2080
00:47:43,119 --> 00:47:50,630
동적 연산을 잘 수행하는 다른 데이터 구조를 사용했죠. 혹시
세션 3번 문제 '

2081
00:47:50,630 --> 00:47:50,640

 

2082
00:47:50,640 --> 00:47:53,670

공간'을 기억하는 사람 있나요?  이게 바로 그거였죠,

2083
00:47:53,670 --> 00:47:53,680
공간'을 기억하는 사람 있나요?  이게 바로 그거였죠,
 

2084
00:47:53,680 --> 00:47:56,470
공간'을 기억하는 사람 있나요?  이게 바로 그거였죠,
그렇죠?  좋아요.

2085
00:47:56,470 --> 00:47:56,480
그렇죠?  좋아요.
 

2086
00:47:56,480 --> 00:48:00,710
그렇죠?  좋아요.
예상 범위 내에 있는 하나를 얻었습니다.  도움이 되셨나요?

2087
00:48:00,710 --> 00:48:00,720
예상 범위 내에 있는 하나를 얻었습니다.  도움이 되셨나요?
 

2088
00:48:00,720 --> 00:48:04,150
예상 범위 내에 있는 하나를 얻었습니다.  도움이 되셨나요?
정말?  누군가 그렇게 말하는 걸 들었어요.

2089
00:48:04,150 --> 00:48:04,160
정말?  누군가 그렇게 말하는 걸 들었어요.
 

2090
00:48:04,160 --> 00:48:06,390
정말?  누군가 그렇게 말하는 걸 들었어요.
해시 테이블.  응.  그러니까 기본적으로 당신이 한 일은

2091
00:48:06,390 --> 00:48:06,400
해시 테이블.  응.  그러니까 기본적으로 당신이 한 일은
 

2092
00:48:06,400 --> 00:48:09,349
해시 테이블.  응.  그러니까 기본적으로 당신이 한 일은
당신 대신에 당신이 한 일인데, 이건

2093
00:48:09,349 --> 00:48:09,359
당신 대신에 당신이 한 일인데, 이건
 

2094
00:48:09,359 --> 00:48:11,030
당신 대신에 당신이 한 일인데, 이건
순서 문제예요.  이것들은

2095
00:48:11,030 --> 00:48:11,040
순서 문제예요.  이것들은
 

2096
00:48:11,040 --> 00:48:14,950
순서 문제예요.  이것들은
열쇠가 없는 거죠, 그렇죠?  하지만

2097
00:48:14,950 --> 00:48:14,960
열쇠가 없는 거죠, 그렇죠?  하지만
 

2098
00:48:14,960 --> 00:48:18,630
열쇠가 없는 거죠, 그렇죠?  하지만
각 항목을 해당 항목의 색인에 꽂으면서 그 항목과 관련된 의미를 파악할 수 있었잖아요

2099
00:48:18,630 --> 00:48:18,640
각 항목을 해당 항목의 색인에 꽂으면서 그 항목과 관련된 의미를 파악할 수 있었잖아요
 

2100
00:48:18,640 --> 00:48:21,030
각 항목을 해당 항목의 색인에 꽂으면서 그 항목과 관련된 의미를 파악할 수 있었잖아요
?

2101
00:48:21,030 --> 00:48:21,040
?
 

2102
00:48:21,040 --> 00:48:22,470
?
그런 식으로 해시 테이블을 사용할 수도 있겠죠.

2103
00:48:22,470 --> 00:48:22,480
그런 식으로 해시 테이블을 사용할 수도 있겠죠.
 

2104
00:48:22,480 --> 00:48:25,589
그런 식으로 해시 테이블을 사용할 수도 있겠죠.
약간의 어려움이 있었죠, 그렇죠?  만약 제가

2105
00:48:25,589 --> 00:48:25,599
약간의 어려움이 있었죠, 그렇죠?  만약 제가
 

2106
00:48:25,599 --> 00:48:29,589
약간의 어려움이 있었죠, 그렇죠?  만약 제가
첫 번째 것을 제거한다면, 그렇죠?

2107
00:48:29,589 --> 00:48:29,599
첫 번째 것을 제거한다면, 그렇죠?
 

2108
00:48:29,599 --> 00:48:33,510
첫 번째 것을 제거한다면, 그렇죠?
맞아요, 왜냐하면

2109
00:48:33,510 --> 00:48:33,520
맞아요, 왜냐하면
 

2110
00:48:33,520 --> 00:48:35,349
맞아요, 왜냐하면
제 모든 지표들이 지금 어떻게 변했는지 궁금하거든요.

2111
00:48:35,349 --> 00:48:35,359
제 모든 지표들이 지금 어떻게 변했는지 궁금하거든요.
 

2112
00:48:35,359 --> 00:48:37,190
제 모든 지표들이 지금 어떻게 변했는지 궁금하거든요.
하지만

2113
00:48:37,190 --> 00:48:37,200
하지만
 

2114
00:48:37,200 --> 00:48:40,710
하지만
내 객체에서 가장 작은 인덱스가 무엇인지 저장해 두면,

2115
00:48:40,710 --> 00:48:42,390
내 객체에서 가장 작은 인덱스가 무엇인지 저장해 두면,
 

2116
00:48:42,390 --> 00:48:42,400

 

2117
00:48:42,400 --> 00:48:44,950

그 인덱스가 무엇이어야 하는지 계산할 수 있으므로 문제가 해결되는 것 아닌가요?  내가

2118
00:48:44,950 --> 00:48:44,960
그 인덱스가 무엇이어야 하는지 계산할 수 있으므로 문제가 해결되는 것 아닌가요?  내가
 

2119
00:48:44,960 --> 00:48:46,630
그 인덱스가 무엇이어야 하는지 계산할 수 있으므로 문제가 해결되는 것 아닌가요?  내가
앞에서 상황을 바꾸듯이.  좋아요.  그래서 저희는

2120
00:48:46,630 --> 00:48:48,950
앞에서 상황을 바꾸듯이.  좋아요.  그래서 저희는
 

2121
00:48:48,950 --> 00:48:50,790

 

2122
00:48:50,790 --> 00:48:50,800

 

2123
00:48:50,800 --> 00:48:53,829

이 장치의 앞부분과 뒷부분에서 일정한 시간을 유지하는 세 가지 방법을 보여드렸습니다.  그러니까

2124
00:48:53,829 --> 00:48:53,839
이 장치의 앞부분과 뒷부분에서 일정한 시간을 유지하는 세 가지 방법을 보여드렸습니다.  그러니까
 

2125
00:48:53,839 --> 00:48:56,309
이 장치의 앞부분과 뒷부분에서 일정한 시간을 유지하는 세 가지 방법을 보여드렸습니다.  그러니까
실제로 그것은

2126
00:48:56,309 --> 00:48:56,319
실제로 그것은
 

2127
00:48:56,319 --> 00:48:58,150
실제로 그것은
분해할 수 있는 표준 재료라고 생각할 수 있습니다

2128
00:48:58,150 --> 00:48:58,160
분해할 수 있는 표준 재료라고 생각할 수 있습니다
 

2129
00:48:58,160 --> 00:49:00,230
분해할 수 있는 표준 재료라고 생각할 수 있습니다
.  네, 이건

2130
00:49:00,230 --> 00:49:00,240
.  네, 이건
 

2131
00:49:00,240 --> 00:49:01,670
.  네, 이건
제가 이 차트에 보여주지 않은 몇 안 되는 예외 사항 중 하나인데

2132
00:49:01,670 --> 00:49:01,680
제가 이 차트에 보여주지 않은 몇 안 되는 예외 사항 중 하나인데
 

2133
00:49:01,680 --> 00:49:04,230
제가 이 차트에 보여주지 않은 몇 안 되는 예외 사항 중 하나인데
,

2134
00:49:04,230 --> 00:49:04,240
,
 

2135
00:49:04,240 --> 00:49:05,750
,
이 문제 풀이 세션을 시청하시는 분들에게는 보너스 같은 정보입니다.  응.  그러니까 so는

2136
00:49:05,750 --> 00:49:05,760
이 문제 풀이 세션을 시청하시는 분들에게는 보너스 같은 정보입니다.  응.  그러니까 so는
 

2137
00:49:05,760 --> 00:49:08,309
이 문제 풀이 세션을 시청하시는 분들에게는 보너스 같은 정보입니다.  응.  그러니까 so는
해시 테이블이 아니라 집합 데이터

2138
00:49:08,309 --> 00:49:08,319
해시 테이블이 아니라 집합 데이터
 

2139
00:49:08,319 --> 00:49:10,549
해시 테이블이 아니라 집합 데이터
구조입니다. 물론 맞는 말이긴 하지만, 우리는

2140
00:49:10,549 --> 00:49:10,559
구조입니다. 물론 맞는 말이긴 하지만, 우리는
 

2141
00:49:10,559 --> 00:49:12,309
구조입니다. 물론 맞는 말이긴 하지만, 우리는
그것을 시퀀스 데이터 구조를 구현하는 데 사용했습니다

2142
00:49:12,309 --> 00:49:12,319
그것을 시퀀스 데이터 구조를 구현하는 데 사용했습니다
 

2143
00:49:12,319 --> 00:49:14,870
그것을 시퀀스 데이터 구조를 구현하는 데 사용했습니다
.  더 자세히

2144
00:49:14,870 --> 00:49:14,880
.  더 자세히
 

2145
00:49:14,880 --> 00:49:16,390
.  더 자세히
알고 싶으시면 해당 문제 해결 세션을 참고하시기 바랍니다

2146
00:49:16,390 --> 00:49:16,400
알고 싶으시면 해당 문제 해결 세션을 참고하시기 바랍니다
 

2147
00:49:16,400 --> 00:49:20,069
알고 싶으시면 해당 문제 해결 세션을 참고하시기 바랍니다
.  좋아요.

2148
00:49:20,069 --> 00:49:20,079
.  좋아요.
 

2149
00:49:20,079 --> 00:49:22,390
.  좋아요.
시퀀스 데이터 구조에 대해 질문 있으신가요?  응.  음,

2150
00:49:22,390 --> 00:49:22,400
시퀀스 데이터 구조에 대해 질문 있으신가요?  응.  음,
 

2151
00:49:22,400 --> 00:49:25,190
시퀀스 데이터 구조에 대해 질문 있으신가요?  응.  음,
다른 질문이네요.  음, 우리가

2152
00:49:25,190 --> 00:49:27,670
다른 질문이네요.  음, 우리가
 

2153
00:49:27,670 --> 00:49:27,680

 

2154
00:49:27,680 --> 00:49:31,270

주어진 표를 증명할 수 있어야 할까요?  음, 그러니까 제가

2155
00:49:31,270 --> 00:49:31,280
주어진 표를 증명할 수 있어야 할까요?  음, 그러니까 제가
 

2156
00:49:31,280 --> 00:49:35,430
주어진 표를 증명할 수 있어야 할까요?  음, 그러니까 제가
빈

2157
00:49:35,430 --> 00:49:35,440
빈
 

2158
00:49:35,440 --> 00:49:37,349
빈
표를 드리면 여러분이 그걸 채워 넣으실 수 있을 거라고 기대하는 거죠

2159
00:49:37,349 --> 00:49:37,359
표를 드리면 여러분이 그걸 채워 넣으실 수 있을 거라고 기대하는 거죠
 

2160
00:49:37,359 --> 00:49:39,190
표를 드리면 여러분이 그걸 채워 넣으실 수 있을 거라고 기대하는 거죠
, 그렇죠?  저는 여러분이

2161
00:49:39,190 --> 00:49:39,200
, 그렇죠?  저는 여러분이
 

2162
00:49:39,200 --> 00:49:41,030
, 그렇죠?  저는 여러분이
이러한 것들이 어떻게

2163
00:49:41,030 --> 00:49:41,040
이러한 것들이 어떻게
 

2164
00:49:41,040 --> 00:49:43,190
이러한 것들이 어떻게
구현되는지 그만큼 잘 알기를 바랍니다.

2165
00:49:43,190 --> 00:49:43,200
구현되는지 그만큼 잘 알기를 바랍니다.
 

2166
00:49:43,200 --> 00:49:45,030
구현되는지 그만큼 잘 알기를 바랍니다.
그건 시험에 안 나오겠죠

2167
00:49:45,030 --> 00:49:45,040
그건 시험에 안 나오겠죠
 

2168
00:49:45,040 --> 00:49:47,109
그건 시험에 안 나오겠죠
?  좀 지루한

2169
00:49:47,109 --> 00:49:47,119
?  좀 지루한
 

2170
00:49:47,119 --> 00:49:49,589
?  좀 지루한
질문이긴 하지만, 알아두는 게 중요해요.

2171
00:49:49,589 --> 00:49:49,599
질문이긴 하지만, 알아두는 게 중요해요.
 

2172
00:49:49,599 --> 00:49:52,549
질문이긴 하지만, 알아두는 게 중요해요.
네, 저는

2173
00:49:52,549 --> 00:49:54,470
네, 저는
 

2174
00:49:54,470 --> 00:49:54,480

 

2175
00:49:54,480 --> 00:49:56,630

AVL 트리를 사용할 때

2176
00:49:56,630 --> 00:49:56,640
AVL 트리를 사용할 때
 

2177
00:49:56,640 --> 00:49:58,390
AVL 트리를 사용할 때
일반적으로 로그인 작업이 주를 이룰 거라고 생각하는 게 좋다고 봅니다.

2178
00:49:58,390 --> 00:50:00,150
일반적으로 로그인 작업이 주를 이룰 거라고 생각하는 게 좋다고 봅니다.
 

2179
00:50:00,150 --> 00:50:00,160

 

2180
00:50:00,160 --> 00:50:01,990

해시 테이블을 사용한다면 정말 유용한 기능이죠, 그렇죠?

2181
00:50:01,990 --> 00:50:02,000
해시 테이블을 사용한다면 정말 유용한 기능이죠, 그렇죠?
 

2182
00:50:02,000 --> 00:50:03,910
해시 테이블을 사용한다면 정말 유용한 기능이죠, 그렇죠?
딕셔너리 유형의 연산, 즉

2183
00:50:03,910 --> 00:50:03,920
딕셔너리 유형의 연산, 즉
 

2184
00:50:03,920 --> 00:50:05,750
딕셔너리 유형의 연산, 즉
검색, 삽입, 삭제는

2185
00:50:05,750 --> 00:50:05,760
검색, 삽입, 삭제는
 

2186
00:50:05,760 --> 00:50:08,870
검색, 삽입, 삭제는
빠르지만, 해시 구조의 해시에 대한 순서 지정 유형의 연산은 속도가 느립니다

2187
00:50:08,870 --> 00:50:08,880
빠르지만, 해시 구조의 해시에 대한 순서 지정 유형의 연산은 속도가 느립니다
 

2188
00:50:08,880 --> 00:50:11,990
빠르지만, 해시 구조의 해시에 대한 순서 지정 유형의 연산은 속도가 느립니다
.  그건

2189
00:50:11,990 --> 00:50:12,000
.  그건
 

2190
00:50:12,000 --> 00:50:13,910
.  그건
어려워요. 제

2191
00:50:13,910 --> 00:50:13,920
어려워요. 제
 

2192
00:50:13,920 --> 00:50:16,150
어려워요. 제
물건들을 전부 다 살펴봐야 하니까요.  음,

2193
00:50:16,150 --> 00:50:17,829
물건들을 전부 다 살펴봐야 하니까요.  음,
 

2194
00:50:17,829 --> 00:50:17,839

 

2195
00:50:17,839 --> 00:50:20,870

정렬된 배열에 대한 동적 연산이 좋지 않다는 것을 알고 계시죠?  또는,

2196
00:50:20,870 --> 00:50:24,470
정렬된 배열에 대한 동적 연산이 좋지 않다는 것을 알고 계시죠?  또는,
 

2197
00:50:24,470 --> 00:50:26,470

 

2198
00:50:26,470 --> 00:50:28,309

 

2199
00:50:28,309 --> 00:50:28,319

 

2200
00:50:28,319 --> 00:50:31,030

이 표에서 연결 리스트와 동적 배열이라고 할 때 우리가 무엇을 의미하는지 생각해 봐야 합니다. 왜냐하면

2201
00:50:31,030 --> 00:50:33,030
이 표에서 연결 리스트와 동적 배열이라고 할 때 우리가 무엇을 의미하는지 생각해 봐야 합니다. 왜냐하면
 

2202
00:50:33,030 --> 00:50:33,040

 

2203
00:50:33,040 --> 00:50:34,630

여기서 우리는 단일 연결 리스트를 의미하기 때문입니다.

2204
00:50:34,630 --> 00:50:34,640
여기서 우리는 단일 연결 리스트를 의미하기 때문입니다.
 

2205
00:50:34,640 --> 00:50:36,710
여기서 우리는 단일 연결 리스트를 의미하기 때문입니다.
강의에서 여러분께 설명드린 내용이 바로 그것이죠. 그래서

2206
00:50:36,710 --> 00:50:36,720
강의에서 여러분께 설명드린 내용이 바로 그것이죠. 그래서
 

2207
00:50:36,720 --> 00:50:38,230
강의에서 여러분께 설명드린 내용이 바로 그것이죠. 그래서
우리가

2208
00:50:38,230 --> 00:50:38,240
우리가
 

2209
00:50:38,240 --> 00:50:39,829
우리가
여러분이 간소화해야 할 표준적인 형태는 이중 연결

2210
00:50:39,829 --> 00:50:41,910
여러분이 간소화해야 할 표준적인 형태는 이중 연결
 

2211
00:50:41,910 --> 00:50:41,920

 

2212
00:50:41,920 --> 00:50:44,230

리스트와 양 끝 배열 세 가지입니다. 기본적으로 이중 연결 리스트가 있다고

2213
00:50:44,230 --> 00:50:44,240
리스트와 양 끝 배열 세 가지입니다. 기본적으로 이중 연결 리스트가 있다고
 

2214
00:50:44,240 --> 00:50:46,630
리스트와 양 끝 배열 세 가지입니다. 기본적으로 이중 연결 리스트가 있다고
가정하면, 아마도

2215
00:50:46,630 --> 00:50:46,640
가정하면, 아마도
 

2216
00:50:46,640 --> 00:50:49,270
가정하면, 아마도
여러분이 사용하고 싶어 할 것은 바로 이 양 끝 배열일 것입니다. 그렇죠

2217
00:50:49,270 --> 00:50:49,280
여러분이 사용하고 싶어 할 것은 바로 이 양 끝 배열일 것입니다. 그렇죠
 

2218
00:50:49,280 --> 00:50:51,589
여러분이 사용하고 싶어 할 것은 바로 이 양 끝 배열일 것입니다. 그렇죠
?

2219
00:50:51,589 --> 00:50:51,599
?
 

2220
00:50:51,599 --> 00:50:54,549
?
지속적인 인덱싱이 가능하니까요, 그렇죠?  그리고

2221
00:50:54,549 --> 00:50:54,559
지속적인 인덱싱이 가능하니까요, 그렇죠?  그리고
 

2222
00:50:54,559 --> 00:50:58,549
지속적인 인덱싱이 가능하니까요, 그렇죠?  그리고
양쪽 모두 꽤 괜찮았죠, 그렇죠?  하지만 아시

2223
00:50:58,549 --> 00:50:58,559
양쪽 모두 꽤 괜찮았죠, 그렇죠?  하지만 아시
 

2224
00:50:58,559 --> 00:51:00,549
양쪽 모두 꽤 괜찮았죠, 그렇죠?  하지만 아시
다시피, 양방향 큐가 필요한 경우

2225
00:51:00,549 --> 00:51:00,559
다시피, 양방향 큐가 필요한 경우
 

2226
00:51:00,559 --> 00:51:02,710
다시피, 양방향 큐가 필요한 경우
두 개의

2227
00:51:02,710 --> 00:51:02,720
두 개의
 

2228
00:51:02,720 --> 00:51:05,109
두 개의
동적 배열을 서로 맞대어 사용하는 방식으로 간소화할 수도 있습니다.  한 명은

2229
00:51:05,109 --> 00:51:05,119
동적 배열을 서로 맞대어 사용하는 방식으로 간소화할 수도 있습니다.  한 명은
 

2230
00:51:05,119 --> 00:51:06,710
동적 배열을 서로 맞대어 사용하는 방식으로 간소화할 수도 있습니다.  한 명은
이쪽으로, 한 명은 이쪽으로 갑니다.  그래서 방법은

2231
00:51:06,710 --> 00:51:06,720
이쪽으로, 한 명은 이쪽으로 갑니다.  그래서 방법은
 

2232
00:51:06,720 --> 00:51:08,309
이쪽으로, 한 명은 이쪽으로 갑니다.  그래서 방법은
여러 가지가 있습니다.  우리가 이미 보여드린 방법이 네 가지밖에 안 되기 때문에

2233
00:51:08,309 --> 00:51:08,319
여러 가지가 있습니다.  우리가 이미 보여드린 방법이 네 가지밖에 안 되기 때문에
 

2234
00:51:08,319 --> 00:51:09,990
여러 가지가 있습니다.  우리가 이미 보여드린 방법이 네 가지밖에 안 되기 때문에
그걸 표준 방법으로 알려드릴 수는 없어요.

2235
00:51:09,990 --> 00:51:11,670
그걸 표준 방법으로 알려드릴 수는 없어요.
 

2236
00:51:11,670 --> 00:51:13,750

 

2237
00:51:13,750 --> 00:51:13,760

 

2238
00:51:13,760 --> 00:51:16,390

그럼 하나를 선택하세요.  좋아요.  응.

2239
00:51:16,390 --> 00:51:16,400
그럼 하나를 선택하세요.  좋아요.  응.
 

2240
00:51:16,400 --> 00:51:18,630
그럼 하나를 선택하세요.  좋아요.  응.
시험 시간을 절약하기 위해, 예를 들어

2241
00:51:18,630 --> 00:51:20,870
시험 시간을 절약하기 위해, 예를 들어
 

2242
00:51:20,870 --> 00:51:20,880

 

2243
00:51:20,880 --> 00:51:23,190

시퀀스를 사용해서 어떤 작업을 하는데 시간이 오래 걸린다고 말할 때, "

2244
00:51:23,190 --> 00:51:24,870
시퀀스를 사용해서 어떤 작업을 하는데 시간이 오래 걸린다고 말할 때, "
 

2245
00:51:24,870 --> 00:51:25,990

 

2246
00:51:25,990 --> 00:51:26,000

 

2247
00:51:26,000 --> 00:51:27,829

시퀀스 AVL이라서 시간이 오래 걸립니다."와 같은 문장을 굳이 써야 할까요? 아니면 그냥 "표에 따르면 시간이 오래 걸립니다."라고만 쓰면 될까요? 그냥

2248
00:51:27,829 --> 00:51:29,829
시퀀스 AVL이라서 시간이 오래 걸립니다."와 같은 문장을 굳이 써야 할까요? 아니면 그냥 "표에 따르면 시간이 오래 걸립니다."라고만 쓰면 될까요? 그냥
 

2249
00:51:29,829 --> 00:51:33,270

 

2250
00:51:33,270 --> 00:51:34,790

 

2251
00:51:34,790 --> 00:51:34,800

 

2252
00:51:34,800 --> 00:51:37,109

시퀀스 AVL에 데이터를 저장한다고 말하고, 어떤 작업을 하는지,

2253
00:51:37,109 --> 00:51:39,670
시퀀스 AVL에 데이터를 저장한다고 말하고, 어떤 작업을 하는지,
 

2254
00:51:39,670 --> 00:51:39,680

 

2255
00:51:39,680 --> 00:51:41,910

그리고 그 작업이 얼마나

2256
00:51:41,910 --> 00:51:41,920
그리고 그 작업이 얼마나
 

2257
00:51:41,920 --> 00:51:43,750
그리고 그 작업이 얼마나
시간이 걸리는지 설명하면 됩니다. 굳이 "시퀀스 AVL이라서 시간이 오래 걸립니다."라고 쓸 필요가 없죠

2258
00:51:43,750 --> 00:51:43,760
시간이 걸리는지 설명하면 됩니다. 굳이 "시퀀스 AVL이라서 시간이 오래 걸립니다."라고 쓸 필요가 없죠
 

2259
00:51:43,760 --> 00:51:46,150
시간이 걸리는지 설명하면 됩니다. 굳이 "시퀀스 AVL이라서 시간이 오래 걸립니다."라고 쓸 필요가 없죠
?  이미

2260
00:51:46,150 --> 00:51:47,430
?  이미
 

2261
00:51:47,430 --> 00:51:47,440

 

2262
00:51:47,440 --> 00:51:49,750

바퀴의 연속이라고 말씀해 주셨잖아요.  제 생각엔 당신이

2263
00:51:49,750 --> 00:51:49,760
바퀴의 연속이라고 말씀해 주셨잖아요.  제 생각엔 당신이
 

2264
00:51:49,760 --> 00:51:51,109
바퀴의 연속이라고 말씀해 주셨잖아요.  제 생각엔 당신이
컨닝 페이퍼에 표를 적어놓고

2265
00:51:51,109 --> 00:51:51,119
컨닝 페이퍼에 표를 적어놓고
 

2266
00:51:51,119 --> 00:51:54,870
컨닝 페이퍼에 표를 적어놓고
그걸 찾아봤을 것 같아요.  좋아요.  괜찮은.

2267
00:51:54,870 --> 00:51:54,880
그걸 찾아봤을 것 같아요.  좋아요.  괜찮은.
 

2268
00:51:54,880 --> 00:51:57,349
그걸 찾아봤을 것 같아요.  좋아요.  괜찮은.
이와 관련해서 다른 질문 있으신가요?  아니요. 네.

2269
00:51:57,349 --> 00:51:57,359
이와 관련해서 다른 질문 있으신가요?  아니요. 네.
 

2270
00:51:57,359 --> 00:52:00,150
이와 관련해서 다른 질문 있으신가요?  아니요. 네.
이중 링크 목록이

2271
00:52:00,150 --> 00:52:00,160
이중 링크 목록이
 

2272
00:52:00,160 --> 00:52:03,270
이중 링크 목록이
삽입 시 모두 하나로 통합되는지 확인하기 위해서입니다.  그게

2273
00:52:03,270 --> 00:52:03,280
삽입 시 모두 하나로 통합되는지 확인하기 위해서입니다.  그게
 

2274
00:52:03,280 --> 00:52:06,549
삽입 시 모두 하나로 통합되는지 확인하기 위해서입니다.  그게
유일한 변화인가요?  예.  이중 링크

2275
00:52:06,549 --> 00:52:06,559
유일한 변화인가요?  예.  이중 링크
 

2276
00:52:06,559 --> 00:52:10,630
유일한 변화인가요?  예.  이중 링크
목록 덕분에 이 사람은 일정한 시간을 유지할 수 있습니다.

2277
00:52:10,630 --> 00:52:10,640
목록 덕분에 이 사람은 일정한 시간을 유지할 수 있습니다.
 

2278
00:52:10,640 --> 00:52:12,390
목록 덕분에 이 사람은 일정한 시간을 유지할 수 있습니다.
사실 여기에는 두 가지 작업이 있습니다

2279
00:52:12,390 --> 00:52:12,400
사실 여기에는 두 가지 작업이 있습니다
 

2280
00:52:12,400 --> 00:52:14,630
사실 여기에는 두 가지 작업이 있습니다
.  음, 삽입, 삭제, 그리고

2281
00:52:14,630 --> 00:52:14,640
.  음, 삽입, 삭제, 그리고
 

2282
00:52:14,640 --> 00:52:17,670
.  음, 삽입, 삭제, 그리고
여기에 찾기도 있죠.

2283
00:52:17,670 --> 00:52:17,680
여기에 찾기도 있죠.
 

2284
00:52:17,680 --> 00:52:19,510
여기에 찾기도 있죠.
꼬리 포인터만 저장하면

2285
00:52:19,510 --> 00:52:19,520
꼬리 포인터만 저장하면
 

2286
00:52:19,520 --> 00:52:22,549
꼬리 포인터만 저장하면
찾기 시간이 상수 시간이 되는데,

2287
00:52:22,549 --> 00:52:22,559
찾기 시간이 상수 시간이 되는데,
 

2288
00:52:22,559 --> 00:52:24,390
찾기 시간이 상수 시간이 되는데,
동적으로 찾는 건 상수

2289
00:52:24,390 --> 00:52:24,400
동적으로 찾는 건 상수
 

2290
00:52:24,400 --> 00:52:26,230
동적으로 찾는 건 상수
시간이 안 되죠. 각 노드마다 이전 포인터도 저장해야 해요.

2291
00:52:26,230 --> 00:52:28,069
시간이 안 되죠. 각 노드마다 이전 포인터도 저장해야 해요.
 

2292
00:52:28,069 --> 00:52:28,079

 

2293
00:52:28,079 --> 00:52:30,870

이해되시나요?

2294
00:52:30,870 --> 00:52:30,880
이해되시나요?
 

2295
00:52:30,880 --> 00:52:34,630
이해되시나요?
음, 마지막으로, 아니면 마지막에서 두 번째로,

2296
00:52:34,630 --> 00:52:34,640
음, 마지막으로, 아니면 마지막에서 두 번째로,
 

2297
00:52:34,640 --> 00:52:36,549
음, 마지막으로, 아니면 마지막에서 두 번째로,
세트 데이터 구조가 있는데요.

2298
00:52:36,549 --> 00:52:36,559
세트 데이터 구조가 있는데요.
 

2299
00:52:36,559 --> 00:52:40,470
세트 데이터 구조가 있는데요.
이런 구조가 몇 개 더 있긴 하지만 그렇게 많지는 않아요.

2300
00:52:40,470 --> 00:52:40,480
이런 구조가 몇 개 더 있긴 하지만 그렇게 많지는 않아요.
 

2301
00:52:40,480 --> 00:52:42,230
이런 구조가 몇 개 더 있긴 하지만 그렇게 많지는 않아요.

2302
00:52:42,230 --> 00:52:42,240

 

2303
00:52:42,240 --> 00:52:46,230

음, 정렬된 배열은

2304
00:52:46,230 --> 00:52:46,240
음, 정렬된 배열은
 

2305
00:52:46,240 --> 00:52:51,349
음, 정렬된 배열은
찾기는 잘 되지만 동적이 아니죠.

2306
00:52:51,349 --> 00:52:51,359

 

2307
00:52:51,359 --> 00:52:55,109

AVL 트리는 찾기도 꽤 잘 되고

2308
00:52:55,109 --> 00:52:55,119
AVL 트리는 찾기도 꽤 잘 되고
 

2309
00:52:55,119 --> 00:52:59,589
AVL 트리는 찾기도 꽤 잘 되고
동적이기도 해요. 그런데

2310
00:52:59,589 --> 00:52:59,599
동적이기도 해요. 그런데
 

2311
00:52:59,599 --> 00:53:03,750
동적이기도 해요. 그런데
구축하는 데 log n log 오버헤드가 발생하는데,

2312
00:53:03,750 --> 00:53:03,760
구축하는 데 log n log 오버헤드가 발생하는데,
 

2313
00:53:03,760 --> 00:53:04,950
구축하는 데 log n log 오버헤드가 발생하는데,
기본적으로 두

2314
00:53:04,950 --> 00:53:04,960
기본적으로 두
 

2315
00:53:04,960 --> 00:53:06,630
기본적으로 두
데이터 구조 모두 정렬을 하기 때문이죠.

2316
00:53:06,630 --> 00:53:06,640
데이터 구조 모두 정렬을 하기 때문이죠.
 

2317
00:53:06,640 --> 00:53:09,750
데이터 구조 모두 정렬을 하기 때문이죠.
하지만 이건 이론적인 질문이라고 생각하면...  제가

2318
00:53:09,750 --> 00:53:13,270
하지만 이건 이론적인 질문이라고 생각하면...  제가
 

2319
00:53:13,270 --> 00:53:13,280

 

2320
00:53:13,280 --> 00:53:14,790

특별히 정렬된

2321
00:53:14,790 --> 00:53:14,800
특별히 정렬된
 

2322
00:53:14,800 --> 00:53:17,030
특별히 정렬된
배열에 대해 묻는 건 아니잖아요.  오른쪽?

2323
00:53:17,030 --> 00:53:17,040
배열에 대해 묻는 건 아니잖아요.  오른쪽?
 

2324
00:53:17,040 --> 00:53:19,670
배열에 대해 묻는 건 아니잖아요.  오른쪽?
이 데이터 구조와 저

2325
00:53:19,670 --> 00:53:19,680
이 데이터 구조와 저
 

2326
00:53:19,680 --> 00:53:25,510
이 데이터 구조와 저
데이터 구조 중에서 선택해야 한다면 어떤 것을 선택하시겠습니까?

2327
00:53:25,510 --> 00:53:25,520

 

2328
00:53:25,520 --> 00:53:27,750

글쎄요, 잘 모르겠네요. 왜냐하면 이 녀석은

2329
00:53:27,750 --> 00:53:29,190
글쎄요, 잘 모르겠네요. 왜냐하면 이 녀석은
 

2330
00:53:29,190 --> 00:53:29,200

 

2331
00:53:29,200 --> 00:53:32,630

이것 하나만 빼고 모든 면에서 더 나은 것 같거든요, 그렇죠?

2332
00:53:32,630 --> 00:53:32,640
이것 하나만 빼고 모든 면에서 더 나은 것 같거든요, 그렇죠?
 

2333
00:53:32,640 --> 00:53:34,549
이것 하나만 빼고 모든 면에서 더 나은 것 같거든요, 그렇죠?
그런데 이 값을 일정한 시간으로 만드는 방법을 아시는 분 계신가요

2334
00:53:34,549 --> 00:53:34,559
그런데 이 값을 일정한 시간으로 만드는 방법을 아시는 분 계신가요
 

2335
00:53:34,559 --> 00:53:37,430
그런데 이 값을 일정한 시간으로 만드는 방법을 아시는 분 계신가요
?

2336
00:53:37,430 --> 00:53:37,440
?
 

2337
00:53:37,440 --> 00:53:39,030
?
증강현실 말이죠?

2338
00:53:39,030 --> 00:53:39,040
증강현실 말이죠?
 

2339
00:53:39,040 --> 00:53:43,030
증강현실 말이죠?
서브 트리에 최댓값이나 최솟값을 저장하면 되는 거죠?

2340
00:53:43,030 --> 00:53:43,040
서브 트리에 최댓값이나 최솟값을 저장하면 되는 거죠?
 

2341
00:53:43,040 --> 00:53:44,870
서브 트리에 최댓값이나 최솟값을 저장하면 되는 거죠?
그리고 저는 이걸 저것보다 훨씬 더 좋게 만들 수 있는 거죠

2342
00:53:44,870 --> 00:53:44,880
그리고 저는 이걸 저것보다 훨씬 더 좋게 만들 수 있는 거죠
 

2343
00:53:44,880 --> 00:53:46,710
그리고 저는 이걸 저것보다 훨씬 더 좋게 만들 수 있는 거죠
, 그렇죠?  이론

2344
00:53:46,710 --> 00:53:46,720
, 그렇죠?  이론
 

2345
00:53:46,720 --> 00:53:48,549
, 그렇죠?  이론
문제라면 아마 이 방법을 사용하는 게 가장 적절할 거예요

2346
00:53:48,549 --> 00:53:48,559
문제라면 아마 이 방법을 사용하는 게 가장 적절할 거예요
 

2347
00:53:48,559 --> 00:53:52,870
문제라면 아마 이 방법을 사용하는 게 가장 적절할 거예요
, 그렇죠?  어, 여기 해시 함수나 직접

2348
00:53:52,870 --> 00:53:52,880
, 그렇죠?  어, 여기 해시 함수나 직접
 

2349
00:53:52,880 --> 00:53:55,829
, 그렇죠?  어, 여기 해시 함수나 직접
접근 배열이 이런 연산에 훨씬 더 좋습니다

2350
00:53:55,829 --> 00:53:55,839
접근 배열이 이런 연산에 훨씬 더 좋습니다
 

2351
00:53:55,839 --> 00:53:58,309
접근 배열이 이런 연산에 훨씬 더 좋습니다
.  좋긴 한데, 걔네들은

2352
00:53:58,309 --> 00:53:58,319
.  좋긴 한데, 걔네들은
 

2353
00:53:58,319 --> 00:54:00,950
.  좋긴 한데, 걔네들은
이런 거 잘 못하잖아, 그렇지?  그러니까 이런 게 필요하면

2354
00:54:00,950 --> 00:54:00,960
이런 거 잘 못하잖아, 그렇지?  그러니까 이런 게 필요하면
 

2355
00:54:00,960 --> 00:54:03,670
이런 거 잘 못하잖아, 그렇지?  그러니까 이런 게 필요하면
사용하지 마세요, 알겠죠?  그리고 실제

2356
00:54:03,670 --> 00:54:03,680
사용하지 마세요, 알겠죠?  그리고 실제
 

2357
00:54:03,680 --> 00:54:05,589
사용하지 마세요, 알겠죠?  그리고 실제
코딩에서도 마찬가지죠, 그렇죠?  특히

2358
00:54:05,589 --> 00:54:05,599
코딩에서도 마찬가지죠, 그렇죠?  특히
 

2359
00:54:05,599 --> 00:54:07,670
코딩에서도 마찬가지죠, 그렇죠?  특히
파이썬이 아닌 다른 언어로 코딩하는 경우라면 더욱 그렇죠. 파이썬은

2360
00:54:07,670 --> 00:54:08,870
파이썬이 아닌 다른 언어로 코딩하는 경우라면 더욱 그렇죠. 파이썬은
 

2361
00:54:08,870 --> 00:54:08,880

 

2362
00:54:08,880 --> 00:54:10,390

해시 테이블을 자동으로 제공하지 않으니까요.  만약 당신이

2363
00:54:10,390 --> 00:54:13,750
해시 테이블을 자동으로 제공하지 않으니까요.  만약 당신이
 

2364
00:54:13,750 --> 00:54:13,760

 

2365
00:54:13,760 --> 00:54:17,430

MIT의 마이크로컨트롤러 연구실에서 C 언어를 배우고 있다면, 615번인가 하는 과목을 듣고 있겠죠

2366
00:54:17,430 --> 00:54:17,440
MIT의 마이크로컨트롤러 연구실에서 C 언어를 배우고 있다면, 615번인가 하는 과목을 듣고 있겠죠
 

2367
00:54:17,440 --> 00:54:18,630
MIT의 마이크로컨트롤러 연구실에서 C 언어를 배우고 있다면, 615번인가 하는 과목을 듣고 있겠죠
?  예를 들어, 당신은

2368
00:54:18,630 --> 00:54:18,640
?  예를 들어, 당신은
 

2369
00:54:18,640 --> 00:54:21,030
?  예를 들어, 당신은
조립 작업을 하고 있는 거죠?  보통은

2370
00:54:21,030 --> 00:54:21,040
조립 작업을 하고 있는 거죠?  보통은
 

2371
00:54:21,040 --> 00:54:23,750
조립 작업을 하고 있는 거죠?  보통은
직접 접근하는 방식을 사용하시잖아요, 그렇죠?

2372
00:54:23,750 --> 00:54:23,760
직접 접근하는 방식을 사용하시잖아요, 그렇죠?
 

2373
00:54:23,760 --> 00:54:26,390
직접 접근하는 방식을 사용하시잖아요, 그렇죠?
왜냐하면 그것이

2374
00:54:26,390 --> 00:54:26,400
왜냐하면 그것이
 

2375
00:54:26,400 --> 00:54:28,309
왜냐하면 그것이
기계어에서 실제로

2376
00:54:28,309 --> 00:54:28,319
기계어에서 실제로
 

2377
00:54:28,319 --> 00:54:30,630
기계어에서 실제로
여기에 접근하고 시간을 발생시키는 데 필요한 점프를 제공하기 때문입니다.

2378
00:54:30,630 --> 00:54:30,640
여기에 접근하고 시간을 발생시키는 데 필요한 점프를 제공하기 때문입니다.
 

2379
00:54:30,640 --> 00:54:32,230
여기에 접근하고 시간을 발생시키는 데 필요한 점프를 제공하기 때문입니다.
일반적으로

2380
00:54:32,230 --> 00:54:34,230
일반적으로
 

2381
00:54:34,230 --> 00:54:34,240

 

2382
00:54:34,240 --> 00:54:35,910

데이터 구조에 넣는 키를 직접 제어할 수 있는 경우에 해당합니다.

2383
00:54:35,910 --> 00:54:38,230
데이터 구조에 넣는 키를 직접 제어할 수 있는 경우에 해당합니다.
 

2384
00:54:38,230 --> 00:54:39,589

 

2385
00:54:39,589 --> 00:54:39,599

 

2386
00:54:39,599 --> 00:54:41,430

이러한 정보를 조회하기 위해 COM이 키를 해시 함수에 통과시키는 오버헤드를 원하지 않으실 겁니다.

2387
00:54:41,430 --> 00:54:41,440
이러한 정보를 조회하기 위해 COM이 키를 해시 함수에 통과시키는 오버헤드를 원하지 않으실 겁니다.
 

2388
00:54:41,440 --> 00:54:45,109
이러한 정보를 조회하기 위해 COM이 키를 해시 함수에 통과시키는 오버헤드를 원하지 않으실 겁니다.
배열에 저장하면 되는 거죠?

2389
00:54:45,109 --> 00:54:47,990
배열에 저장하면 되는 거죠?
 

2390
00:54:47,990 --> 00:54:48,000

 

2391
00:54:48,000 --> 00:54:49,910

키를 제어할 수 없거나 키가

2392
00:54:49,910 --> 00:54:49,920
키를 제어할 수 없거나 키가
 

2393
00:54:49,920 --> 00:54:52,790
키를 제어할 수 없거나 키가
문자열 같은 것일 때 해시 테이블을 사용하는 거죠?   바로 이런 경우에

2394
00:54:52,790 --> 00:54:52,800
문자열 같은 것일 때 해시 테이블을 사용하는 거죠?   바로 이런 경우에
 

2395
00:54:52,800 --> 00:54:54,470
문자열 같은 것일 때 해시 테이블을 사용하는 거죠?   바로 이런 경우에
해시 테이블을 사용하는 겁니다.   자,

2396
00:54:54,470 --> 00:54:54,480
해시 테이블을 사용하는 겁니다.   자,
 

2397
00:54:54,480 --> 00:54:57,829
해시 테이블을 사용하는 겁니다.   자,
일반적으로 우리의 목적상

2398
00:54:57,829 --> 00:54:57,839
일반적으로 우리의 목적상
 

2399
00:54:57,839 --> 00:54:59,430
일반적으로 우리의 목적상
해시 테이블도 충분히 좋은 성능을 보여줍니다.

2400
00:54:59,430 --> 00:54:59,440
해시 테이블도 충분히 좋은 성능을 보여줍니다.
 

2401
00:54:59,440 --> 00:55:02,710
해시 테이블도 충분히 좋은 성능을 보여줍니다.
최악의 경우 성능 한계를 요구하는 경우가 아니라면 말이죠. 만약 우리가

2402
00:55:02,710 --> 00:55:05,190
최악의 경우 성능 한계를 요구하는 경우가 아니라면 말이죠. 만약 우리가
 

2403
00:55:05,190 --> 00:55:05,200

 

2404
00:55:05,200 --> 00:55:06,630

자료 구조 문제를 다룰 때

2405
00:55:06,630 --> 00:55:09,510
자료 구조 문제를 다룰 때
 

2406
00:55:09,510 --> 00:55:09,520

 

2407
00:55:09,520 --> 00:55:12,710

최악의 경우,

2408
00:55:12,710 --> 00:55:12,720
최악의 경우,
 

2409
00:55:12,720 --> 00:55:14,230
최악의 경우,
기대값, 상각값 등 그 어떤 것도 중요하지 않은 상황이라면, 해시 테이블이 더 나을 수도 있습니다

2410
00:55:14,230 --> 00:55:14,240
기대값, 상각값 등 그 어떤 것도 중요하지 않은 상황이라면, 해시 테이블이 더 나을 수도 있습니다
 

2411
00:55:14,240 --> 00:55:16,230
기대값, 상각값 등 그 어떤 것도 중요하지 않은 상황이라면, 해시 테이블이 더 나을 수도 있습니다
.

2412
00:55:16,230 --> 00:55:16,240
.
 

2413
00:55:16,240 --> 00:55:20,069
.
어떤 목표를 달성했는지 꼭 명시해 주세요, 그렇죠?

2414
00:55:20,069 --> 00:55:21,829
어떤 목표를 달성했는지 꼭 명시해 주세요, 그렇죠?
 

2415
00:55:21,829 --> 00:55:21,839

 

2416
00:55:21,839 --> 00:55:23,270

데이터 구조에 대한 분석을 제대로 했다면

2417
00:55:23,270 --> 00:55:23,280
데이터 구조에 대한 분석을 제대로 했다면
 

2418
00:55:23,280 --> 00:55:26,069
데이터 구조에 대한 분석을 제대로 했다면
문제없겠죠?  하지만 만약 우리가

2419
00:55:26,069 --> 00:55:26,079
문제없겠죠?  하지만 만약 우리가
 

2420
00:55:26,079 --> 00:55:28,069
문제없겠죠?  하지만 만약 우리가
당신에게 최악의 상황을 대비하라고 한다면, 내가

2421
00:55:28,069 --> 00:55:28,079
당신에게 최악의 상황을 대비하라고 한다면, 내가
 

2422
00:55:28,079 --> 00:55:31,589
당신에게 최악의 상황을 대비하라고 한다면, 내가
당신을 때릴 거예요, 그렇죠?  그럼

2423
00:55:31,589 --> 00:55:31,599
당신을 때릴 거예요, 그렇죠?  그럼
 

2424
00:55:31,599 --> 00:55:33,829
당신을 때릴 거예요, 그렇죠?  그럼
경계선을 잡아주시겠어요?

2425
00:55:33,829 --> 00:55:33,839
경계선을 잡아주시겠어요?
 

2426
00:55:33,839 --> 00:55:36,630
경계선을 잡아주시겠어요?
그런 경우에는 해시 테이블을 사용하지 마세요.

2427
00:55:36,630 --> 00:55:36,640
그런 경우에는 해시 테이블을 사용하지 마세요.
 

2428
00:55:36,640 --> 00:55:41,670
그런 경우에는 해시 테이블을 사용하지 마세요.
이해가 되시나요?  좋아요.  마지막으로, 앞서

2429
00:55:41,670 --> 00:55:41,680
이해가 되시나요?  좋아요.  마지막으로, 앞서
 

2430
00:55:41,680 --> 00:55:43,510
이해가 되시나요?  좋아요.  마지막으로, 앞서
이야기했던 우선순위 신호가 있습니다

2431
00:55:43,510 --> 00:55:43,520
이야기했던 우선순위 신호가 있습니다
 

2432
00:55:43,520 --> 00:55:45,190
이야기했던 우선순위 신호가 있습니다
.  이 부분에 대해서는 자세히 다루지 않겠습니다

2433
00:55:45,190 --> 00:55:45,200
.  이 부분에 대해서는 자세히 다루지 않겠습니다
 

2434
00:55:45,200 --> 00:55:46,710
.  이 부분에 대해서는 자세히 다루지 않겠습니다
.  기본적으로 기존

2435
00:55:46,710 --> 00:55:46,720
.  기본적으로 기존
 

2436
00:55:46,720 --> 00:55:50,549
.  기본적으로 기존
기능에 이걸 추가하는 것일 뿐입니다.  하지만

2437
00:55:50,549 --> 00:55:50,559
기능에 이걸 추가하는 것일 뿐입니다.  하지만
 

2438
00:55:50,559 --> 00:55:52,069
기능에 이걸 추가하는 것일 뿐입니다.  하지만
실제로는, 이 목록에는 없지만

2439
00:55:52,069 --> 00:55:55,910
실제로는, 이 목록에는 없지만
 

2440
00:55:55,910 --> 00:55:55,920

 

2441
00:55:55,920 --> 00:55:59,190

최대 또는 최소 증강을 사용하는 시퀀스 AVL 트리를 통해 이러한 모든 경계를 얻을 수 있습니다.

2442
00:55:59,190 --> 00:56:00,950
최대 또는 최소 증강을 사용하는 시퀀스 AVL 트리를 통해 이러한 모든 경계를 얻을 수 있습니다.
 

2443
00:56:00,950 --> 00:56:02,470

 

2444
00:56:02,470 --> 00:56:04,789

 

2445
00:56:04,789 --> 00:56:07,030

 

2446
00:56:07,030 --> 00:56:07,040

 

2447
00:56:07,040 --> 00:56:09,109

상각 없이 이러한 경계가 필요한 경우

2448
00:56:09,109 --> 00:56:09,119
상각 없이 이러한 경계가 필요한 경우
 

2449
00:56:09,119 --> 00:56:11,990
상각 없이 이러한 경계가 필요한 경우
이를 달성할 수 있을 것입니다.  좋아요.  괜찮은.  자, 이것들이 바로

2450
00:56:11,990 --> 00:56:12,000
이를 달성할 수 있을 것입니다.  좋아요.  괜찮은.  자, 이것들이 바로
 

2451
00:56:12,000 --> 00:56:13,829
이를 달성할 수 있을 것입니다.  좋아요.  괜찮은.  자, 이것들이 바로
우리가

2452
00:56:13,829 --> 00:56:13,839
우리가
 

2453
00:56:13,839 --> 00:56:16,309
우리가
수업에서 다룬 모든 내용입니다.  좋아요, 남은

2454
00:56:16,309 --> 00:56:16,319
수업에서 다룬 모든 내용입니다.  좋아요, 남은
 

2455
00:56:16,319 --> 00:56:17,589
수업에서 다룬 모든 내용입니다.  좋아요, 남은
시간 동안

2456
00:56:17,589 --> 00:56:17,599
시간 동안
 

2457
00:56:17,599 --> 00:56:19,109
시간 동안
자료구조

2458
00:56:19,109 --> 00:56:19,119
자료구조
 

2459
00:56:19,119 --> 00:56:21,510
자료구조
문제 몇 가지를 풀어보도록 하겠습니다.  아니요,

2460
00:56:21,510 --> 00:56:22,950
문제 몇 가지를 풀어보도록 하겠습니다.  아니요,
 

2461
00:56:22,950 --> 00:56:22,960

 

2462
00:56:22,960 --> 00:56:25,990

사실

2463
00:56:25,990 --> 00:56:26,000
사실
 

2464
00:56:26,000 --> 00:56:28,950
사실
퀴즈, 그러니까

2465
00:56:28,950 --> 00:56:28,960
퀴즈, 그러니까
 

2466
00:56:28,960 --> 00:56:31,190
퀴즈, 그러니까
지난 학기에 드렸던 연습 퀴즈에는 여러 가지 유형의 문제가 나올 거예요.  앞쪽 오른쪽에는

2467
00:56:31,190 --> 00:56:31,200
지난 학기에 드렸던 연습 퀴즈에는 여러 가지 유형의 문제가 나올 거예요.  앞쪽 오른쪽에는
 

2468
00:56:31,200 --> 00:56:33,349
지난 학기에 드렸던 연습 퀴즈에는 여러 가지 유형의 문제가 나올 거예요.  앞쪽 오른쪽에는
제가 '기계적인 유형'이라고 부르는 문제들이 몇 개 있고, 그 다음에는

2469
00:56:33,349 --> 00:56:36,230
제가 '기계적인 유형'이라고 부르는 문제들이 몇 개 있고, 그 다음에는
 

2470
00:56:36,230 --> 00:56:38,549

 

2471
00:56:38,549 --> 00:56:38,559

 

2472
00:56:38,559 --> 00:56:39,990

정렬

2473
00:56:39,990 --> 00:56:40,000
정렬
 

2474
00:56:40,000 --> 00:56:41,910
정렬
알고리즘이나 자료 구조를 사용해서 문제를 단순화하는 유형의 문제들이 있습니다.

2475
00:56:41,910 --> 00:56:41,920
알고리즘이나 자료 구조를 사용해서 문제를 단순화하는 유형의 문제들이 있습니다.
 

2476
00:56:41,920 --> 00:56:44,230
알고리즘이나 자료 구조를 사용해서 문제를 단순화하는 유형의 문제들이 있습니다.
그리고 맨 뒤쪽에는

2477
00:56:44,230 --> 00:56:45,829
그리고 맨 뒤쪽에는
 

2478
00:56:45,829 --> 00:56:47,190

 

2479
00:56:47,190 --> 00:56:47,200

 

2480
00:56:47,200 --> 00:56:49,670

증강이나 분할

2481
00:56:49,670 --> 00:56:49,680
증강이나 분할
 

2482
00:56:49,680 --> 00:56:51,990
증강이나 분할
정복 같은 추가적인 작업을 해야 하는 문제들이 있습니다. 자,

2483
00:56:51,990 --> 00:56:52,000
정복 같은 추가적인 작업을 해야 하는 문제들이 있습니다. 자,
 

2484
00:56:52,000 --> 00:56:55,270
정복 같은 추가적인 작업을 해야 하는 문제들이 있습니다. 자,
그럼 남은 시간 동안

2485
00:56:55,270 --> 00:56:56,950
그럼 남은 시간 동안
 

2486
00:56:56,950 --> 00:56:56,960

 

2487
00:56:56,960 --> 00:56:59,829

이 문제들 중 몇 개를 풀어보도록 하겠습니다. 이 문제들은

2488
00:56:59,829 --> 00:56:59,839
이 문제들 중 몇 개를 풀어보도록 하겠습니다. 이 문제들은
 

2489
00:56:59,839 --> 00:57:04,789
이 문제들 중 몇 개를 풀어보도록 하겠습니다. 이 문제들은
2019년 봄 시험에 출제되었던 문제들입니다.  어,

2490
00:57:04,789 --> 00:57:04,799
2019년 봄 시험에 출제되었던 문제들입니다.  어,
 

2491
00:57:04,799 --> 00:57:08,470
2019년 봄 시험에 출제되었던 문제들입니다.  어,
그리고 사실 지금 우리 TA를 맡고 있는 조교 중 한 명이

2492
00:57:08,470 --> 00:57:11,030
그리고 사실 지금 우리 TA를 맡고 있는 조교 중 한 명이
 

2493
00:57:11,030 --> 00:57:11,040

 

2494
00:57:11,040 --> 00:57:13,750

2019년 봄 학기에도 우리 TA였는데, 그때 2번 문제, 그러니까

2495
00:57:13,750 --> 00:57:13,760
2019년 봄 학기에도 우리 TA였는데, 그때 2번 문제, 그러니까
 

2496
00:57:13,760 --> 00:57:15,829
2019년 봄 학기에도 우리 TA였는데, 그때 2번 문제, 그러니까
비 오는 날 연구 과제를 채점하면서

2497
00:57:15,829 --> 00:57:15,839
비 오는 날 연구 과제를 채점하면서
 

2498
00:57:15,839 --> 00:57:18,630
비 오는 날 연구 과제를 채점하면서
저를 엄청 싫어했어요. 왜냐하면 아무도 제대로 풀지 않았거든요.  자, 그럼

2499
00:57:18,630 --> 00:57:21,750
저를 엄청 싫어했어요. 왜냐하면 아무도 제대로 풀지 않았거든요.  자, 그럼
 

2500
00:57:21,750 --> 00:57:21,760

 

2501
00:57:21,760 --> 00:57:23,190

이 문제들을 풀어보도록 하겠습니다.

2502
00:57:23,190 --> 00:57:23,200
이 문제들을 풀어보도록 하겠습니다.
 

2503
00:57:23,200 --> 00:57:28,710
이 문제들을 풀어보도록 하겠습니다.
첫 번째 문제는 식당

2504
00:57:28,710 --> 00:57:28,720
첫 번째 문제는 식당
 

2505
00:57:28,720 --> 00:57:31,910
첫 번째 문제는 식당
매장에 관한 것입니다.  예.  좋아요.

2506
00:57:31,910 --> 00:57:31,920
매장에 관한 것입니다.  예.  좋아요.
 

2507
00:57:31,920 --> 00:57:33,589
매장에 관한 것입니다.  예.  좋아요.
괜찮은.  음, 그러니까 지금 무슨 일이 벌어지고 있는 거죠

2508
00:57:33,589 --> 00:57:33,599
괜찮은.  음, 그러니까 지금 무슨 일이 벌어지고 있는 거죠
 

2509
00:57:33,599 --> 00:57:35,270
괜찮은.  음, 그러니까 지금 무슨 일이 벌어지고 있는 거죠
?  어, 유명한 레스토랑인데,

2510
00:57:35,270 --> 00:57:35,280
?  어, 유명한 레스토랑인데,
 

2511
00:57:35,280 --> 00:57:38,150
?  어, 유명한 레스토랑인데,
해산물이 정말 맛있어요.

2512
00:57:38,150 --> 00:57:38,160
해산물이 정말 맛있어요.
 

2513
00:57:38,160 --> 00:57:40,710
해산물이 정말 맛있어요.
참고 자료가 뭔가요?  합법적인 해산물.

2514
00:57:40,710 --> 00:57:40,720
참고 자료가 뭔가요?  합법적인 해산물.
 

2515
00:57:40,720 --> 00:57:42,470
참고 자료가 뭔가요?  합법적인 해산물.
예.  반대.  예약은 받지 않지만

2516
00:57:42,470 --> 00:57:42,480
예.  반대.  예약은 받지 않지만
 

2517
00:57:42,480 --> 00:57:44,309
예.  반대.  예약은 받지 않지만
대기자 명단을 운영하며,

2518
00:57:44,309 --> 00:57:46,309
대기자 명단을 운영하며,
 

2519
00:57:46,309 --> 00:57:46,319

 

2520
00:57:46,319 --> 00:57:48,630

대기 기간이 긴 고객일수록 우선적으로 자리에 앉을 수 있습니다.  음,

2521
00:57:48,630 --> 00:57:48,640
대기 기간이 긴 고객일수록 우선적으로 자리에 앉을 수 있습니다.  음,
 

2522
00:57:48,640 --> 00:57:50,069
대기 기간이 긴 고객일수록 우선적으로 자리에 앉을 수 있습니다.  음,
때때로 손님들이 다른 곳에서 식사를 하기로 결정하는 경우가 있는데,

2523
00:57:50,069 --> 00:57:50,079
때때로 손님들이 다른 곳에서 식사를 하기로 결정하는 경우가 있는데,
 

2524
00:57:50,079 --> 00:57:51,750
때때로 손님들이 다른 곳에서 식사를 하기로 결정하는 경우가 있는데,
그럴 경우 식당 측에서는

2525
00:57:51,750 --> 00:57:51,760
그럴 경우 식당 측에서는
 

2526
00:57:51,760 --> 00:57:54,150
그럴 경우 식당 측에서는
그들을 체중 측정 명단에서 제외해야 합니다.  좋아요.

2527
00:57:54,150 --> 00:57:54,160
그들을 체중 측정 명단에서 제외해야 합니다.  좋아요.
 

2528
00:57:54,160 --> 00:57:56,950
그들을 체중 측정 명단에서 제외해야 합니다.  좋아요.
고객의

2529
00:57:56,950 --> 00:57:56,960
고객의
 

2530
00:57:56,960 --> 00:57:59,270
고객의
이름이 다를 수 있다고 가정해 봅시다.  어떤 고객도

2531
00:57:59,270 --> 00:57:59,280
이름이 다를 수 있다고 가정해 봅시다.  어떤 고객도
 

2532
00:57:59,280 --> 00:58:00,950
이름이 다를 수 있다고 가정해 봅시다.  어떤 고객도
정확히 같은 시간에 무게 목록에 추가되지 않습니다

2533
00:58:00,950 --> 00:58:00,960
정확히 같은 시간에 무게 목록에 추가되지 않습니다
 

2534
00:58:00,960 --> 00:58:02,950
정확히 같은 시간에 무게 목록에 추가되지 않습니다
.  오른쪽?  그러니까

2535
00:58:02,950 --> 00:58:04,789
.  오른쪽?  그러니까
 

2536
00:58:04,789 --> 00:58:04,799

 

2537
00:58:04,799 --> 00:58:06,150

이 체중 목록에 사람들이 추가되는 순서 같은 게 있다는 거죠.  오른쪽?

2538
00:58:06,150 --> 00:58:06,160
이 체중 목록에 사람들이 추가되는 순서 같은 게 있다는 거죠.  오른쪽?
 

2539
00:58:06,160 --> 00:58:08,470
이 체중 목록에 사람들이 추가되는 순서 같은 게 있다는 거죠.  오른쪽?
이해가 되시나요?

2540
00:58:08,470 --> 00:58:08,480
이해가 되시나요?
 

2541
00:58:08,480 --> 00:58:10,069
이해가 되시나요?
범죄로 압수된 해산물의

2542
00:58:10,069 --> 00:58:10,079
범죄로 압수된 해산물의
 

2543
00:58:10,079 --> 00:58:11,589
범죄로 압수된 해산물의
무게 목록을 관리하는 데 도움이 되는 데이터베이스를 설계하세요. 이 데이터베이스는 다음

2544
00:58:11,589 --> 00:58:11,599
무게 목록을 관리하는 데 도움이 되는 데이터베이스를 설계하세요. 이 데이터베이스는 다음
 

2545
00:58:11,599 --> 00:58:13,829
무게 목록을 관리하는 데 도움이 되는 데이터베이스를 설계하세요. 이 데이터베이스는 다음
작업들을 각각 일정한 시간 내에 지원해야 합니다.  좋아요.

2546
00:58:13,829 --> 00:58:13,839
작업들을 각각 일정한 시간 내에 지원해야 합니다.  좋아요.
 

2547
00:58:13,839 --> 00:58:15,670
작업들을 각각 일정한 시간 내에 지원해야 합니다.  좋아요.
그래서 여기서는

2548
00:58:15,670 --> 00:58:15,680
그래서 여기서는
 

2549
00:58:15,680 --> 00:58:18,950
그래서 여기서는
실행 시간을 맨 위로 끌어올려 리팩토링했습니다.  어, 그리고 "

2550
00:58:18,950 --> 00:58:18,960
실행 시간을 맨 위로 끌어올려 리팩토링했습니다.  어, 그리고 "
 

2551
00:58:18,960 --> 00:58:22,069
실행 시간을 맨 위로 끌어올려 리팩토링했습니다.  어, 그리고 "
아, 죄송합니다. 여기에 빌드를 추가했습니다."라고 나오네요.  제

2552
00:58:22,069 --> 00:58:22,079
아, 죄송합니다. 여기에 빌드를 추가했습니다."라고 나오네요.  제
 

2553
00:58:22,079 --> 00:58:23,270
아, 죄송합니다. 여기에 빌드를 추가했습니다."라고 나오네요.  제
생각엔 그것도 여전히 일정한 시간인 것 같아요.

2554
00:58:23,270 --> 00:58:23,280
생각엔 그것도 여전히 일정한 시간인 것 같아요.
 

2555
00:58:23,280 --> 00:58:26,230
생각엔 그것도 여전히 일정한 시간인 것 같아요.
괜찮아요.  좋아요.  응.  각

2556
00:58:26,230 --> 00:58:26,240
괜찮아요.  좋아요.  응.  각
 

2557
00:58:26,240 --> 00:58:29,430
괜찮아요.  좋아요.  응.  각
실행 시간 작업이 최악의 경우

2558
00:58:29,430 --> 00:58:29,440
실행 시간 작업이 최악의 경우
 

2559
00:58:29,440 --> 00:58:31,670
실행 시간 작업이 최악의 경우
비용 상각을 하는지 여부를 명시하십시오.  그러니까 그 문구를 보면 '

2560
00:58:31,670 --> 00:58:33,670
비용 상각을 하는지 여부를 명시하십시오.  그러니까 그 문구를 보면 '
 

2561
00:58:33,670 --> 00:58:33,680

 

2562
00:58:33,680 --> 00:58:37,589

내가 원한다면 해시 테이블을 사용해도 되겠구나'라고 생각하는 거죠.

2563
00:58:37,589 --> 00:58:37,599
내가 원한다면 해시 테이블을 사용해도 되겠구나'라고 생각하는 거죠.
 

2564
00:58:37,599 --> 00:58:40,150
내가 원한다면 해시 테이블을 사용해도 되겠구나'라고 생각하는 거죠.
만약 제가 이 기능을 사용한다면, 해당 작업이

2565
00:58:40,150 --> 00:58:42,309
만약 제가 이 기능을 사용한다면, 해당 작업이
 

2566
00:58:42,309 --> 00:58:42,319

 

2567
00:58:42,319 --> 00:58:45,109

발생할 때 예상 작업인지 상각 작업인지 명확하게 표시해야 하는 거죠?

2568
00:58:45,109 --> 00:58:45,119
발생할 때 예상 작업인지 상각 작업인지 명확하게 표시해야 하는 거죠?
 

2569
00:58:45,119 --> 00:58:46,710
발생할 때 예상 작업인지 상각 작업인지 명확하게 표시해야 하는 거죠?
어떤 작업이 예상됩니까?

2570
00:58:46,710 --> 00:58:46,720
어떤 작업이 예상됩니까?
 

2571
00:58:46,720 --> 00:58:48,630
어떤 작업이 예상됩니까?
기본적으로 전부 다요.  어떤 사업활동이

2572
00:58:48,630 --> 00:58:48,640
기본적으로 전부 다요.  어떤 사업활동이
 

2573
00:58:48,640 --> 00:58:50,870
기본적으로 전부 다요.  어떤 사업활동이
상각 대상인가요?

2574
00:58:50,870 --> 00:58:50,880
상각 대상인가요?
 

2575
00:58:50,880 --> 00:58:52,710
상각 대상인가요?
데이터 구조 자체를 바꾼 사람들 말이죠?

2576
00:58:52,710 --> 00:58:52,720
데이터 구조 자체를 바꾼 사람들 말이죠?
 

2577
00:58:52,720 --> 00:58:55,829
데이터 구조 자체를 바꾼 사람들 말이죠?
삽입, 삭제.  네, 그럼

2578
00:58:55,829 --> 00:58:55,839
삽입, 삭제.  네, 그럼
 

2579
00:58:55,839 --> 00:58:58,470
삽입, 삭제.  네, 그럼
빈 객체를 생성하고

2580
00:58:58,470 --> 00:58:58,480
빈 객체를 생성하고
 

2581
00:58:58,480 --> 00:59:01,349
빈 객체를 생성하고
이름을 추가하는 몇 가지 작업을 진행해 보겠습니다.  그러니까 이 이름은

2582
00:59:01,349 --> 00:59:01,359
이름을 추가하는 몇 가지 작업을 진행해 보겠습니다.  그러니까 이 이름은
 

2583
00:59:01,359 --> 00:59:02,870
이름을 추가하는 몇 가지 작업을 진행해 보겠습니다.  그러니까 이 이름은
가중치 목록의 맨 뒤에 있는 X입니다.  내가

2584
00:59:02,870 --> 00:59:02,880
가중치 목록의 맨 뒤에 있는 X입니다.  내가
 

2585
00:59:02,880 --> 00:59:05,270
가중치 목록의 맨 뒤에 있는 X입니다.  내가
X에 대해 아는 게 뭐지?

2586
00:59:05,270 --> 00:59:05,280
X에 대해 아는 게 뭐지?
 

2587
00:59:05,280 --> 00:59:07,190
X에 대해 아는 게 뭐지?
이 수업에서 우리가 세운 가정에 따르면, 나는 이름에 대해 무엇을 알고 있을까요?   모두 다

2588
00:59:07,190 --> 00:59:07,200
이 수업에서 우리가 세운 가정에 따르면, 나는 이름에 대해 무엇을 알고 있을까요?   모두 다
 

2589
00:59:07,200 --> 00:59:08,470
이 수업에서 우리가 세운 가정에 따르면, 나는 이름에 대해 무엇을 알고 있을까요?   모두 다
독특해요.  그래서 그것들이 핵심이 될 수 있습니다

2590
00:59:08,470 --> 00:59:08,480
독특해요.  그래서 그것들이 핵심이 될 수 있습니다
 

2591
00:59:08,480 --> 00:59:10,549
독특해요.  그래서 그것들이 핵심이 될 수 있습니다
.  그것들은 독특하기 때문에 열쇠가 될 수 있고,

2592
00:59:10,549 --> 00:59:10,559
.  그것들은 독특하기 때문에 열쇠가 될 수 있고,
 

2593
00:59:10,559 --> 00:59:12,230
.  그것들은 독특하기 때문에 열쇠가 될 수 있고,

2594
00:59:12,230 --> 00:59:14,549

 

2595
00:59:14,549 --> 00:59:14,559

 

2596
00:59:14,559 --> 00:59:16,470

우리의 가정에 따르면 일정한 단어 수에 들어맞습니다.  오른쪽?  그래서

2597
00:59:16,470 --> 00:59:16,480
우리의 가정에 따르면 일정한 단어 수에 들어맞습니다.  오른쪽?  그래서
 

2598
00:59:16,480 --> 00:59:18,309
우리의 가정에 따르면 일정한 단어 수에 들어맞습니다.  오른쪽?  그래서
두 값을 비교하는 데 상수 시간이 걸리거나,

2599
00:59:18,309 --> 00:59:18,319
두 값을 비교하는 데 상수 시간이 걸리거나,
 

2600
00:59:18,319 --> 00:59:20,069
두 값을 비교하는 데 상수 시간이 걸리거나,
하나를 해싱하는 데 상수 시간이 걸립니다.  오른쪽?

2601
00:59:20,069 --> 00:59:20,079
하나를 해싱하는 데 상수 시간이 걸립니다.  오른쪽?
 

2602
00:59:20,079 --> 00:59:21,510
하나를 해싱하는 데 상수 시간이 걸립니다.  오른쪽?
우리가 이러한 입력값에 대해 하는 가정이 바로 그런 것입니다

2603
00:59:21,510 --> 00:59:21,520
우리가 이러한 입력값에 대해 하는 가정이 바로 그런 것입니다
 

2604
00:59:21,520 --> 00:59:23,910
우리가 이러한 입력값에 대해 하는 가정이 바로 그런 것입니다
.  이것들은 문자열이고, 저는

2605
00:59:23,910 --> 00:59:23,920
.  이것들은 문자열이고, 저는
 

2606
00:59:23,920 --> 00:59:26,549
.  이것들은 문자열이고, 저는
그 길이에 대한 제한을 지정하지 않았습니다.  그러니 아마

2607
00:59:26,549 --> 00:59:28,309
그 길이에 대한 제한을 지정하지 않았습니다.  그러니 아마
 

2608
00:59:28,309 --> 00:59:28,319

 

2609
00:59:28,319 --> 00:59:31,589

걱정할 필요는 없을 거예요.  오른쪽?  좋아요.  어, 이름을 삭제하는 거죠

2610
00:59:31,589 --> 00:59:31,599
걱정할 필요는 없을 거예요.  오른쪽?  좋아요.  어, 이름을 삭제하는 거죠
 

2611
00:59:31,599 --> 00:59:35,349
걱정할 필요는 없을 거예요.  오른쪽?  좋아요.  어, 이름을 삭제하는 거죠
?  벌써부터

2612
00:59:35,349 --> 00:59:35,359
?  벌써부터
 

2613
00:59:35,359 --> 00:59:36,870
?  벌써부터
물건들을 이름으로 찾을 수 있어야 할 것 같은 기분이 드네요

2614
00:59:36,870 --> 00:59:36,880
물건들을 이름으로 찾을 수 있어야 할 것 같은 기분이 드네요
 

2615
00:59:36,880 --> 00:59:39,270
물건들을 이름으로 찾을 수 있어야 할 것 같은 기분이 드네요
, 그렇죠?

2616
00:59:39,270 --> 00:59:39,280
, 그렇죠?
 

2617
00:59:39,280 --> 00:59:41,670
, 그렇죠?
좋아요.  어, 그리고 나서

2618
00:59:41,670 --> 00:59:41,680
좋아요.  어, 그리고 나서
 

2619
00:59:41,680 --> 00:59:45,109
좋아요.  어, 그리고 나서
줄 서 있는 다음 사람을 보세요.  이해가 되시나요?  그렇다면

2620
00:59:45,109 --> 00:59:46,789
줄 서 있는 다음 사람을 보세요.  이해가 되시나요?  그렇다면
 

2621
00:59:46,789 --> 00:59:46,799

 

2622
00:59:46,799 --> 00:59:49,589

여기서 유지 관리해야 할 것들은 어떤 것들이 있을까요?  저는 사람들이 있어요,

2623
00:59:49,589 --> 00:59:49,599
여기서 유지 관리해야 할 것들은 어떤 것들이 있을까요?  저는 사람들이 있어요,
 

2624
00:59:49,599 --> 00:59:51,750
여기서 유지 관리해야 할 것들은 어떤 것들이 있을까요?  저는 사람들이 있어요,
그렇죠?  그것들은 이름도 있고,

2625
00:59:51,750 --> 00:59:51,760
그렇죠?  그것들은 이름도 있고,
 

2626
00:59:51,760 --> 00:59:53,829
그렇죠?  그것들은 이름도 있고,
나름의 장소도 있죠, 그렇죠?

2627
00:59:53,829 --> 00:59:53,839
나름의 장소도 있죠, 그렇죠?
 

2628
00:59:53,839 --> 00:59:56,390
나름의 장소도 있죠, 그렇죠?
그들이 들어온 시간 말이죠?  하지만 내게 주어진

2629
00:59:56,390 --> 00:59:56,400
그들이 들어온 시간 말이죠?  하지만 내게 주어진
 

2630
00:59:56,400 --> 00:59:59,990
그들이 들어온 시간 말이죠?  하지만 내게 주어진
시간은 과연 언제일까요?

2631
00:59:59,990 --> 01:00:00,000

 

2632
01:00:00,000 --> 01:00:02,870

아니요, 저는 어디에서도 시간을 부여받지 못했어요, 그렇죠?

2633
01:00:02,870 --> 01:00:02,880
아니요, 저는 어디에서도 시간을 부여받지 못했어요, 그렇죠?
 

2634
01:00:02,880 --> 01:00:05,349
아니요, 저는 어디에서도 시간을 부여받지 못했어요, 그렇죠?
그건 제 작업 입력값에 포함되지 않는 거죠

2635
01:00:05,349 --> 01:00:05,359
그건 제 작업 입력값에 포함되지 않는 거죠
 

2636
01:00:05,359 --> 01:00:06,549
그건 제 작업 입력값에 포함되지 않는 거죠
?  그러니까, 제가

2637
01:00:06,549 --> 01:00:06,559
?  그러니까, 제가
 

2638
01:00:06,559 --> 01:00:08,950
?  그러니까, 제가
시간을 정확히 맞출 수 있을 것 같지는 않아요.

2639
01:00:08,950 --> 01:00:08,960
시간을 정확히 맞출 수 있을 것 같지는 않아요.
 

2640
01:00:08,960 --> 01:00:10,549
시간을 정확히 맞출 수 있을 것 같지는 않아요.
이해가 되시나요?  시대에 있어서 중요한 것은 무엇일까요

2641
01:00:10,549 --> 01:00:10,559
이해가 되시나요?  시대에 있어서 중요한 것은 무엇일까요
 

2642
01:00:10,559 --> 01:00:13,349
이해가 되시나요?  시대에 있어서 중요한 것은 무엇일까요
?  순서 맞죠?  그리고 당신은

2643
01:00:13,349 --> 01:00:13,359
?  순서 맞죠?  그리고 당신은
 

2644
01:00:13,359 --> 01:00:16,870
?  순서 맞죠?  그리고 당신은
그것을 받게 됩니다.  응.  기본적으로 저는 항상

2645
01:00:16,870 --> 01:00:18,549
그것을 받게 됩니다.  응.  기본적으로 저는 항상
 

2646
01:00:18,549 --> 01:00:18,559

 

2647
01:00:18,559 --> 01:00:20,549

이 사람들에 대한 순서를 유지하려고 노력합니다.

2648
01:00:20,549 --> 01:00:20,559
이 사람들에 대한 순서를 유지하려고 노력합니다.
 

2649
01:00:20,559 --> 01:00:23,109
이 사람들에 대한 순서를 유지하려고 노력합니다.
앞쪽이랑 뒤쪽이 있고,

2650
01:00:23,109 --> 01:00:23,119
앞쪽이랑 뒤쪽이 있고,
 

2651
01:00:23,119 --> 01:00:24,630
앞쪽이랑 뒤쪽이 있고,
가운데에 사람들이 있는 거죠?  그리고 저는

2652
01:00:24,630 --> 01:00:24,640
가운데에 사람들이 있는 거죠?  그리고 저는
 

2653
01:00:24,640 --> 01:00:26,309
가운데에 사람들이 있는 거죠?  그리고 저는
그 질서가 그대로 유지되도록 해야 해요. 그렇지 않으면

2654
01:00:26,309 --> 01:00:26,319
그 질서가 그대로 유지되도록 해야 해요. 그렇지 않으면
 

2655
01:00:26,319 --> 01:00:27,670
그 질서가 그대로 유지되도록 해야 해요. 그렇지 않으면
사람들이 저에게 화를 낼 테니까요,

2656
01:00:27,670 --> 01:00:27,680
사람들이 저에게 화를 낼 테니까요,
 

2657
01:00:27,680 --> 01:00:29,990
사람들이 저에게 화를 낼 테니까요,
그렇죠?  왜냐하면 그들이

2658
01:00:29,990 --> 01:00:30,000
그렇죠?  왜냐하면 그들이
 

2659
01:00:30,000 --> 01:00:33,750
그렇죠?  왜냐하면 그들이
나를 쫓아왔고, 그래 맞아, 너도 그런

2660
01:00:33,750 --> 01:00:33,760
나를 쫓아왔고, 그래 맞아, 너도 그런
 

2661
01:00:33,760 --> 01:00:36,789
나를 쫓아왔고, 그래 맞아, 너도 그런
상황을 겪어봤잖아.  네, 그러니까 저희는

2662
01:00:36,789 --> 01:00:38,470
상황을 겪어봤잖아.  네, 그러니까 저희는
 

2663
01:00:38,470 --> 01:00:38,480

 

2664
01:00:38,480 --> 01:00:41,670

이런 것들에 대해 일종의 순서, 즉 외적인 질서를 유지하려고 하는 거죠?

2665
01:00:41,670 --> 01:00:41,680
이런 것들에 대해 일종의 순서, 즉 외적인 질서를 유지하려고 하는 거죠?
 

2666
01:00:41,680 --> 01:00:43,190
이런 것들에 대해 일종의 순서, 즉 외적인 질서를 유지하려고 하는 거죠?
하지만 저는

2667
01:00:43,190 --> 01:00:45,670
하지만 저는
 

2668
01:00:45,670 --> 01:00:45,680

 

2669
01:00:45,680 --> 01:00:46,950

이 시스템을 바꾸고 싶기 때문에 사람들의 이름을 검색할 수 있어야 합니다.

2670
01:00:46,950 --> 01:00:46,960
이 시스템을 바꾸고 싶기 때문에 사람들의 이름을 검색할 수 있어야 합니다.
 

2671
01:00:46,960 --> 01:00:49,430
이 시스템을 바꾸고 싶기 때문에 사람들의 이름을 검색할 수 있어야 합니다.
이 문제가 이전에 이

2672
01:00:49,430 --> 01:00:52,549
이 문제가 이전에 이
 

2673
01:00:52,549 --> 01:00:52,559

 

2674
01:00:52,559 --> 01:00:55,510

학기 문제 세트에서 겪었던 문제와 비슷하게 들리지 않나요?  네,

2675
01:00:55,510 --> 01:00:59,589
학기 문제 세트에서 겪었던 문제와 비슷하게 들리지 않나요?  네,
 

2676
01:00:59,589 --> 01:00:59,599

 

2677
01:00:59,599 --> 01:01:01,829

채팅에 문제가 있었던 것 같아요.  오른쪽.

2678
01:01:01,829 --> 01:01:01,839
채팅에 문제가 있었던 것 같아요.  오른쪽.
 

2679
01:01:01,839 --> 01:01:03,829
채팅에 문제가 있었던 것 같아요.  오른쪽.
순서를 저장해야 했잖아요, 그렇죠?  하지만 그때는

2680
01:01:03,829 --> 01:01:03,839
순서를 저장해야 했잖아요, 그렇죠?  하지만 그때는
 

2681
01:01:03,839 --> 01:01:05,109
순서를 저장해야 했잖아요, 그렇죠?  하지만 그때는
사전을 찾아봐야 하는 경우도 있었잖아요

2682
01:01:05,109 --> 01:01:05,119
사전을 찾아봐야 하는 경우도 있었잖아요
 

2683
01:01:05,119 --> 01:01:07,190
사전을 찾아봐야 하는 경우도 있었잖아요
, 그렇죠?  자,

2684
01:01:07,190 --> 01:01:07,200
, 그렇죠?  자,
 

2685
01:01:07,200 --> 01:01:10,150
, 그렇죠?  자,
그

2686
01:01:10,150 --> 01:01:10,160
그
 

2687
01:01:10,160 --> 01:01:12,549
그
상황의 좋은 점은, 그렇죠

2688
01:01:12,549 --> 01:01:15,190
상황의 좋은 점은, 그렇죠
 

2689
01:01:15,190 --> 01:01:15,200

 

2690
01:01:15,200 --> 01:01:17,990

? 찾아봐야 할 정보들이 고정되어 있었다는 거예요.  그렇다면 이를 위한

2691
01:01:17,990 --> 01:01:18,000
? 찾아봐야 할 정보들이 고정되어 있었다는 거예요.  그렇다면 이를 위한
 

2692
01:01:18,000 --> 01:01:20,069
? 찾아봐야 할 정보들이 고정되어 있었다는 거예요.  그렇다면 이를 위한
사전, 즉 데이터

2693
01:01:20,069 --> 01:01:20,079
사전, 즉 데이터
 

2694
01:01:20,079 --> 01:01:22,390
사전, 즉 데이터
구조로는 무엇을 사용할 수 있을까요?   혹시

2695
01:01:22,390 --> 01:01:22,400
구조로는 무엇을 사용할 수 있을까요?   혹시
 

2696
01:01:22,400 --> 01:01:25,349
구조로는 무엇을 사용할 수 있을까요?   혹시
기억하는 사람 있나요?

2697
01:01:25,349 --> 01:01:25,359
기억하는 사람 있나요?
 

2698
01:01:25,359 --> 01:01:26,870
기억하는 사람 있나요?
정렬된 배열을 사용하면 되지

2699
01:01:26,870 --> 01:01:26,880
정렬된 배열을 사용하면 되지
 

2700
01:01:26,880 --> 01:01:28,710
정렬된 배열을 사용하면 되지
않을까요?  정적인 상태이기 때문에 이러한 것들은

2701
01:01:28,710 --> 01:01:28,720
않을까요?  정적인 상태이기 때문에 이러한 것들은
 

2702
01:01:28,720 --> 01:01:30,789
않을까요?  정적인 상태이기 때문에 이러한 것들은
항상 업데이트되는 것은 아니죠?

2703
01:01:30,789 --> 01:01:30,799
항상 업데이트되는 것은 아니죠?
 

2704
01:01:30,799 --> 01:01:32,710
항상 업데이트되는 것은 아니죠?
그래서 저는

2705
01:01:32,710 --> 01:01:32,720
그래서 저는
 

2706
01:01:32,720 --> 01:01:38,069
그래서 저는
정적 배열을 사용해도 괜찮았습니다.  오른쪽?  여기서는

2707
01:01:38,069 --> 01:01:38,079
정적 배열을 사용해도 괜찮았습니다.  오른쪽?  여기서는
 

2708
01:01:38,079 --> 01:01:39,990
정적 배열을 사용해도 괜찮았습니다.  오른쪽?  여기서는
최악의 경우

2709
01:01:39,990 --> 01:01:40,000
최악의 경우
 

2710
01:01:40,000 --> 01:01:42,390
최악의 경우
로그 함수에 따른 조회 시간을 알려드렸습니다.  오른쪽?  여기서 저는

2711
01:01:42,390 --> 01:01:42,400
로그 함수에 따른 조회 시간을 알려드렸습니다.  오른쪽?  여기서 저는
 

2712
01:01:42,400 --> 01:01:45,670
로그 함수에 따른 조회 시간을 알려드렸습니다.  오른쪽?  여기서 저는
일정한 시간을 요구하고 있습니다.  오른쪽?  AVL

2713
01:01:45,670 --> 01:01:45,680
일정한 시간을 요구하고 있습니다.  오른쪽?  AVL
 

2714
01:01:45,680 --> 01:01:47,430
일정한 시간을 요구하고 있습니다.  오른쪽?  AVL
정렬 배열로는 충분하지 않습니다.

2715
01:01:47,430 --> 01:01:47,440
정렬 배열로는 충분하지 않습니다.
 

2716
01:01:47,440 --> 01:01:48,789
정렬 배열로는 충분하지 않습니다.
AVL 설정으로는 충분하지 않습니다.

2717
01:01:48,789 --> 01:01:48,799
AVL 설정으로는 충분하지 않습니다.
 

2718
01:01:48,799 --> 01:01:51,510
AVL 설정으로는 충분하지 않습니다.
저는 그걸 사용할 거예요.  동적 배열 또는

2719
01:01:51,510 --> 01:01:51,520
저는 그걸 사용할 거예요.  동적 배열 또는
 

2720
01:01:51,520 --> 01:01:53,990
저는 그걸 사용할 거예요.  동적 배열 또는
해시 테이블.  오른쪽?  동적 배열은

2721
01:01:53,990 --> 01:01:55,670
해시 테이블.  오른쪽?  동적 배열은
 

2722
01:01:55,670 --> 01:01:57,750

 

2723
01:01:57,750 --> 01:01:57,760

 

2724
01:01:57,760 --> 01:01:59,270

키의 크기에 대한 수치적 제한이 없기 때문에 그다지 좋지 않을 수 있습니다.  그것들이

2725
01:01:59,270 --> 01:01:59,280
키의 크기에 대한 수치적 제한이 없기 때문에 그다지 좋지 않을 수 있습니다.  그것들이
 

2726
01:01:59,280 --> 01:02:02,630
키의 크기에 대한 수치적 제한이 없기 때문에 그다지 좋지 않을 수 있습니다.  그것들이
단어 안에 들어맞는다는 건 확실히 알겠어요, 그렇죠?  그래서 실제로

2727
01:02:02,630 --> 01:02:02,640
단어 안에 들어맞는다는 건 확실히 알겠어요, 그렇죠?  그래서 실제로
 

2728
01:02:02,640 --> 01:02:04,789
단어 안에 들어맞는다는 건 확실히 알겠어요, 그렇죠?  그래서 실제로
직접 접근 배열을 만들 수 없습니다. 왜냐하면 해당

2729
01:02:04,789 --> 01:02:04,799
직접 접근 배열을 만들 수 없습니다. 왜냐하면 해당
 

2730
01:02:04,799 --> 01:02:06,390
직접 접근 배열을 만들 수 없습니다. 왜냐하면 해당
단어들이 상수

2731
01:02:06,390 --> 01:02:06,400
단어들이 상수
 

2732
01:02:06,400 --> 01:02:08,150
단어들이 상수
개수의 단어에 맞기는 하지만,

2733
01:02:08,150 --> 01:02:08,160
개수의 단어에 맞기는 하지만,
 

2734
01:02:08,160 --> 01:02:09,510
개수의 단어에 맞기는 하지만,
그 단어들의 정수 표현이

2735
01:02:09,510 --> 01:02:09,520
그 단어들의 정수 표현이
 

2736
01:02:09,520 --> 01:02:11,750
그 단어들의 정수 표현이
다항식적으로 제한되는지 알 수 없기 때문입니다.

2737
01:02:11,750 --> 01:02:11,760
다항식적으로 제한되는지 알 수 없기 때문입니다.
 

2738
01:02:11,760 --> 01:02:13,910
다항식적으로 제한되는지 알 수 없기 때문입니다.
이해가 되시나요?  오른쪽?  그래서 저는

2739
01:02:13,910 --> 01:02:13,920
이해가 되시나요?  오른쪽?  그래서 저는
 

2740
01:02:13,920 --> 01:02:15,430
이해가 되시나요?  오른쪽?  그래서 저는
이 경우에 해싱을 사용하고 싶습니다

2741
01:02:15,430 --> 01:02:15,440
이 경우에 해싱을 사용하고 싶습니다
 

2742
01:02:15,440 --> 01:02:17,109
이 경우에 해싱을 사용하고 싶습니다
.  오른쪽?  그렇다면 제가

2743
01:02:17,109 --> 01:02:17,119
.  오른쪽?  그렇다면 제가
 

2744
01:02:17,119 --> 01:02:19,990
.  오른쪽?  그렇다면 제가
유지하고 싶은 것은 무엇일까요?  고객 정보를 순차적인 데이터 구조로 유지하고 싶습니다

2745
01:02:19,990 --> 01:02:24,230
유지하고 싶은 것은 무엇일까요?  고객 정보를 순차적인 데이터 구조로 유지하고 싶습니다
 

2746
01:02:24,230 --> 01:02:27,270

 

2747
01:02:27,270 --> 01:02:27,280

 

2748
01:02:27,280 --> 01:02:30,390

.

2749
01:02:30,390 --> 01:02:30,400

 

2750
01:02:30,400 --> 01:02:32,710

고객 여러분, 혹시 그 안에 U가 들어가 있나요

2751
01:02:32,710 --> 01:02:32,720
고객 여러분, 혹시 그 안에 U가 들어가 있나요
 

2752
01:02:32,720 --> 01:02:34,630
고객 여러분, 혹시 그 안에 U가 들어가 있나요
?  아니요, 이게 맞습니다.  오른쪽.

2753
01:02:34,630 --> 01:02:34,640
?  아니요, 이게 맞습니다.  오른쪽.
 

2754
01:02:34,640 --> 01:02:37,589
?  아니요, 이게 맞습니다.  오른쪽.
좋아요.  그리고

2755
01:02:37,589 --> 01:02:37,599
좋아요.  그리고
 

2756
01:02:37,599 --> 01:02:39,349
좋아요.  그리고

2757
01:02:39,349 --> 01:02:39,359

 

2758
01:02:39,359 --> 01:02:41,109

매핑 세트.   보통 저는 이런 식으로

2759
01:02:41,109 --> 01:02:41,119
매핑 세트.   보통 저는 이런 식으로
 

2760
01:02:41,119 --> 01:02:43,030
매핑 세트.   보통 저는 이런 식으로
합니다.

2761
01:02:43,030 --> 01:02:43,040
합니다.
 

2762
01:02:43,040 --> 01:02:46,390
합니다.
뭔가에 초점을 맞춘 세트라고 말하고 싶어요.

2763
01:02:46,390 --> 01:02:46,400
뭔가에 초점을 맞춘 세트라고 말하고 싶어요.
 

2764
01:02:46,400 --> 01:02:48,309
뭔가에 초점을 맞춘 세트라고 말하고 싶어요.
세트라면

2765
01:02:48,309 --> 01:02:48,319
세트라면
 

2766
01:02:48,319 --> 01:02:50,150
세트라면
키만 지정하면 되는 거죠?  그게

2767
01:02:50,150 --> 01:02:50,160
키만 지정하면 되는 거죠?  그게
 

2768
01:02:50,160 --> 01:02:52,710
키만 지정하면 되는 거죠?  그게
거기에 있는지 없는지 알아볼 수 있어요.  하지만

2769
01:02:52,710 --> 01:02:52,720
거기에 있는지 없는지 알아볼 수 있어요.  하지만
 

2770
01:02:52,720 --> 01:02:54,630
거기에 있는지 없는지 알아볼 수 있어요.  하지만
실제로 키 공간을

2771
01:02:54,630 --> 01:02:54,640
실제로 키 공간을
 

2772
01:02:54,640 --> 01:02:56,549
실제로 키 공간을
다른 곳에 매핑할 때는, 즉

2773
01:02:56,549 --> 01:02:56,559
다른 곳에 매핑할 때는, 즉
 

2774
01:02:56,559 --> 01:02:59,829
다른 곳에 매핑할 때는, 즉
키 공간을 다른 곳에 매핑한다고 말할 겁니다.

2775
01:02:59,829 --> 01:02:59,839
키 공간을 다른 곳에 매핑한다고 말할 겁니다.
 

2776
01:02:59,839 --> 01:03:01,750
키 공간을 다른 곳에 매핑한다고 말할 겁니다.
보통 제가 보관하는 물건이나, 아니면

2777
01:03:01,750 --> 01:03:03,589
보통 제가 보관하는 물건이나, 아니면
 

2778
01:03:03,589 --> 01:03:03,599

 

2779
01:03:03,599 --> 01:03:04,870

보관하는 물건과 관련된 어떤 속성 같은 거죠?

2780
01:03:04,870 --> 01:03:04,880
보관하는 물건과 관련된 어떤 속성 같은 거죠?
 

2781
01:03:04,880 --> 01:03:07,670
보관하는 물건과 관련된 어떤 속성 같은 거죠?
이해가 되시나요?  좋아요.  그럼, 여기서 뭘 매핑해야 할까요

2782
01:03:07,670 --> 01:03:07,680
이해가 되시나요?  좋아요.  그럼, 여기서 뭘 매핑해야 할까요
 

2783
01:03:07,680 --> 01:03:09,670
이해가 되시나요?  좋아요.  그럼, 여기서 뭘 매핑해야 할까요
?

2784
01:03:09,670 --> 01:03:09,680
?
 

2785
01:03:09,680 --> 01:03:13,510
?
이름들 말이죠, 그렇죠?

2786
01:03:13,510 --> 01:03:13,520

 

2787
01:03:13,520 --> 01:03:15,109


2788
01:03:15,109 --> 01:03:15,119

 

2789
01:03:15,119 --> 01:03:20,710

음, 시간을 어떻게 매핑하고 싶은 거죠?

2790
01:03:20,710 --> 01:03:23,670

 

2791
01:03:23,670 --> 01:03:26,309

 

2792
01:03:26,309 --> 01:03:27,589

 

2793
01:03:27,589 --> 01:03:27,599

 

2794
01:03:27,599 --> 01:03:29,270

고객이 들어온 시간을요? 그렇게 할 수는 없지만, 순서를 통해

2795
01:03:29,270 --> 01:03:29,280
고객이 들어온 시간을요? 그렇게 할 수는 없지만, 순서를 통해
 

2796
01:03:29,280 --> 01:03:31,670
고객이 들어온 시간을요? 그렇게 할 수는 없지만, 순서를 통해
다음에 무엇이 올지 보여줄 수 있을 거예요. 네, 저는 그

2797
01:03:31,670 --> 01:03:33,910
다음에 무엇이 올지 보여줄 수 있을 거예요. 네, 저는 그
 

2798
01:03:33,910 --> 01:03:33,920

 

2799
01:03:33,920 --> 01:03:36,069

순서에서 어디에 있는지 저장하고 싶어요. 그러니까

2800
01:03:36,069 --> 01:03:38,069
순서에서 어디에 있는지 저장하고 싶어요. 그러니까
 

2801
01:03:38,069 --> 01:03:38,079

 

2802
01:03:38,079 --> 01:03:39,670

순서에서 해당 위치의 인덱스를 저장해 두고 필요할 때 찾아보면 되겠죠?

2803
01:03:39,670 --> 01:03:42,150
순서에서 해당 위치의 인덱스를 저장해 두고 필요할 때 찾아보면 되겠죠?
 

2804
01:03:42,150 --> 01:03:42,160

 

2805
01:03:42,160 --> 01:03:45,109

네, 그렇게 하면 될 것 같아요.  제가 들은 게 맞나요?  지수는

2806
01:03:45,109 --> 01:03:45,119
네, 그렇게 하면 될 것 같아요.  제가 들은 게 맞나요?  지수는
 

2807
01:03:45,119 --> 01:03:47,029
네, 그렇게 하면 될 것 같아요.  제가 들은 게 맞나요?  지수는
변합니다.  응.  인덱스는

2808
01:03:47,029 --> 01:03:47,039
변합니다.  응.  인덱스는
 

2809
01:03:47,039 --> 01:03:49,750
변합니다.  응.  인덱스는
항목을 추가하거나 삭제할 때마다 변경되는 거죠?

2810
01:03:49,750 --> 01:03:49,760
항목을 추가하거나 삭제할 때마다 변경되는 거죠?
 

2811
01:03:49,760 --> 01:03:53,349
항목을 추가하거나 삭제할 때마다 변경되는 거죠?
아, 네.  포인터를 저장하는 거죠?

2812
01:03:53,349 --> 01:03:53,359
아, 네.  포인터를 저장하는 거죠?
 

2813
01:03:53,359 --> 01:03:56,630
아, 네.  포인터를 저장하는 거죠?

2814
01:03:56,630 --> 01:03:59,349

 

2815
01:03:59,349 --> 01:03:59,359

 

2816
01:03:59,359 --> 01:04:03,270

순서대로 배치할 위치를 가리키는 포인터입니다.  음, 제가 이 수열을 어떻게 표현했는지 아직 말씀드리지

2817
01:04:03,270 --> 01:04:03,280
순서대로 배치할 위치를 가리키는 포인터입니다.  음, 제가 이 수열을 어떻게 표현했는지 아직 말씀드리지
 

2818
01:04:03,280 --> 01:04:05,750
순서대로 배치할 위치를 가리키는 포인터입니다.  음, 제가 이 수열을 어떻게 표현했는지 아직 말씀드리지
않았기 때문에 이렇게 말하는 게 좀 이상하게 들릴 수도 있겠네요.

2819
01:04:05,750 --> 01:04:08,710
않았기 때문에 이렇게 말하는 게 좀 이상하게 들릴 수도 있겠네요.
 

2820
01:04:08,710 --> 01:04:08,720

 

2821
01:04:08,720 --> 01:04:12,390

하지만 개념적으로 말하자면,

2822
01:04:12,390 --> 01:04:12,400
하지만 개념적으로 말하자면,
 

2823
01:04:12,400 --> 01:04:14,390
하지만 개념적으로 말하자면,
저는 이것이 현재

2824
01:04:14,390 --> 01:04:14,400
저는 이것이 현재
 

2825
01:04:14,400 --> 01:04:15,910
저는 이것이 현재
어디에 있는지를 나타내는 포인터를 저장하고 있다고 할 수 있습니다.   그

2826
01:04:15,910 --> 01:04:15,920
어디에 있는지를 나타내는 포인터를 저장하고 있다고 할 수 있습니다.   그
 

2827
01:04:15,920 --> 01:04:17,510
어디에 있는지를 나타내는 포인터를 저장하고 있다고 할 수 있습니다.   그
세부 사항은

2828
01:04:17,510 --> 01:04:17,520
세부 사항은
 

2829
01:04:17,520 --> 01:04:21,029
세부 사항은
나중에 처리하겠습니다.  좋아요.  오른쪽.  하지만 일반적으로 저는

2830
01:04:21,029 --> 01:04:21,039
나중에 처리하겠습니다.  좋아요.  오른쪽.  하지만 일반적으로 저는
 

2831
01:04:21,039 --> 01:04:22,710
나중에 처리하겠습니다.  좋아요.  오른쪽.  하지만 일반적으로 저는
이것을 연결된 데이터 구조라고 부릅니다.  오른쪽?

2832
01:04:22,710 --> 01:04:22,720
이것을 연결된 데이터 구조라고 부릅니다.  오른쪽?
 

2833
01:04:22,720 --> 01:04:24,950
이것을 연결된 데이터 구조라고 부릅니다.  오른쪽?
두 데이터 구조를 연결하고 있기 때문입니다

2834
01:04:24,950 --> 01:04:24,960
두 데이터 구조를 연결하고 있기 때문입니다
 

2835
01:04:24,960 --> 01:04:28,470
두 데이터 구조를 연결하고 있기 때문입니다
.  오른쪽?  그래서

2836
01:04:28,470 --> 01:04:28,480
.  오른쪽?  그래서
 

2837
01:04:28,480 --> 01:04:30,230
.  오른쪽?  그래서
한 곳에서 쿼리를 실행하면

2838
01:04:30,230 --> 01:04:30,240
한 곳에서 쿼리를 실행하면
 

2839
01:04:30,240 --> 01:04:33,190
한 곳에서 쿼리를 실행하면
다른 곳에서 해당 쿼리의 위치를 ​​찾을 수 있습니다.  오른쪽?  아니면 다른 쪽에서 쿼리를 실행하세요

2840
01:04:33,190 --> 01:04:33,200
다른 곳에서 해당 쿼리의 위치를 ​​찾을 수 있습니다.  오른쪽?  아니면 다른 쪽에서 쿼리를 실행하세요
 

2841
01:04:33,200 --> 01:04:36,630
다른 곳에서 해당 쿼리의 위치를 ​​찾을 수 있습니다.  오른쪽?  아니면 다른 쪽에서 쿼리를 실행하세요
.  그런 종류의 것들.  좋아요.  그러니까

2842
01:04:36,630 --> 01:04:36,640
.  그런 종류의 것들.  좋아요.  그러니까
 

2843
01:04:36,640 --> 01:04:38,710
.  그런 종류의 것들.  좋아요.  그러니까
다들 제가 왜

2844
01:04:38,710 --> 01:04:38,720
다들 제가 왜
 

2845
01:04:38,720 --> 01:04:41,029
다들 제가 왜
이런 것들을 골랐는지 이해하시겠죠?  제가 이 문제에 접근하는 방식입니다

2846
01:04:41,029 --> 01:04:41,039
이런 것들을 골랐는지 이해하시겠죠?  제가 이 문제에 접근하는 방식입니다
 

2847
01:04:41,039 --> 01:04:45,430
이런 것들을 골랐는지 이해하시겠죠?  제가 이 문제에 접근하는 방식입니다
.  응.  음, 포인터가

2848
01:04:45,430 --> 01:04:45,440
.  응.  음, 포인터가
 

2849
01:04:45,440 --> 01:04:48,390
.  응.  음, 포인터가
인덱스만 저장하는 문제를 어떻게 해결해 줄지는 잘 모르겠네요. 아시다시피

2850
01:04:48,390 --> 01:04:48,400
인덱스만 저장하는 문제를 어떻게 해결해 줄지는 잘 모르겠네요. 아시다시피
 

2851
01:04:48,400 --> 01:04:52,230
인덱스만 저장하는 문제를 어떻게 해결해 줄지는 잘 모르겠네요. 아시다시피
,

2852
01:04:52,230 --> 01:04:52,240
,
 

2853
01:04:52,240 --> 01:04:54,069
,
순서에서 사람이 현재 있는 위치는

2854
01:04:54,069 --> 01:04:54,079
순서에서 사람이 현재 있는 위치는
 

2855
01:04:54,079 --> 01:04:55,589
순서에서 사람이 현재 있는 위치는
시간이 지남에 따라 변할 텐데요.

2856
01:04:55,589 --> 01:04:55,599
시간이 지남에 따라 변할 텐데요.
 

2857
01:04:55,599 --> 01:04:57,349
시간이 지남에 따라 변할 텐데요.
포인터가

2858
01:04:57,349 --> 01:04:57,359
포인터가
 

2859
01:04:57,359 --> 01:05:01,750
포인터가
해당 변경 사항에 따라 업데이트된다고 가정하는 건가요?  네, 알겠습니다.  자, 예를 들어

2860
01:05:01,750 --> 01:05:01,760
해당 변경 사항에 따라 업데이트된다고 가정하는 건가요?  네, 알겠습니다.  자, 예를 들어
 

2861
01:05:01,760 --> 01:05:04,710
해당 변경 사항에 따라 업데이트된다고 가정하는 건가요?  네, 알겠습니다.  자, 예를 들어
매번, 그러니까 제가

2862
01:05:04,710 --> 01:05:04,720
매번, 그러니까 제가
 

2863
01:05:04,720 --> 01:05:06,230
매번, 그러니까 제가
이

2864
01:05:06,230 --> 01:05:06,240
이
 

2865
01:05:06,240 --> 01:05:08,309
이
시퀀스를 연결 리스트에 저장한다고 가정해 봅시다.  제가 앞으로 이 작업 중간중간에

2866
01:05:08,309 --> 01:05:09,589
시퀀스를 연결 리스트에 저장한다고 가정해 봅시다.  제가 앞으로 이 작업 중간중간에
 

2867
01:05:09,589 --> 01:05:09,599

 

2868
01:05:09,599 --> 01:05:11,109

내용을 삽입하고 삭제해야 할 거라는 걸 알고 있기 때문에 미리 말씀드리는 겁니다

2869
01:05:11,109 --> 01:05:11,119
내용을 삽입하고 삭제해야 할 거라는 걸 알고 있기 때문에 미리 말씀드리는 겁니다
 

2870
01:05:11,119 --> 01:05:13,270
내용을 삽입하고 삭제해야 할 거라는 걸 알고 있기 때문에 미리 말씀드리는 겁니다
.

2871
01:05:13,270 --> 01:05:13,280
.
 

2872
01:05:13,280 --> 01:05:15,349
.
이해가 되시나요?  괜찮은.  그래서 저는

2873
01:05:15,349 --> 01:05:15,359
이해가 되시나요?  괜찮은.  그래서 저는
 

2874
01:05:15,359 --> 01:05:17,510
이해가 되시나요?  괜찮은.  그래서 저는
이것이

2875
01:05:17,510 --> 01:05:17,520
이것이
 

2876
01:05:17,520 --> 01:05:20,630
이것이
연결 리스트가 될 거라고 말씀드리겠습니다.  좋아요.  이제 제겐

2877
01:05:20,630 --> 01:05:20,640
연결 리스트가 될 거라고 말씀드리겠습니다.  좋아요.  이제 제겐
 

2878
01:05:20,640 --> 01:05:23,990
연결 리스트가 될 거라고 말씀드리겠습니다.  좋아요.  이제 제겐
연결된 리스트가 생겼습니다.

2879
01:05:23,990 --> 01:05:24,000
연결된 리스트가 생겼습니다.
 

2880
01:05:24,000 --> 01:05:28,390
연결된 리스트가 생겼습니다.
좋아요.  그러니까 제가 만약 이 세트

2881
01:05:28,390 --> 01:05:28,400
좋아요.  그러니까 제가 만약 이 세트
 

2882
01:05:28,400 --> 01:05:30,950
좋아요.  그러니까 제가 만약 이 세트
데이터 구조가

2883
01:05:30,950 --> 01:05:34,390
데이터 구조가
 

2884
01:05:34,390 --> 01:05:34,400

 

2885
01:05:34,400 --> 01:05:38,950

연결 리스트에서 어떤 위치에 있는지 저장한다고 가정해 볼게요. 예를 들어, '어, 여기'에 저장된다고 해봅시다. 좋아요.

2886
01:05:38,950 --> 01:05:43,670
연결 리스트에서 어떤 위치에 있는지 저장한다고 가정해 볼게요. 예를 들어, '어, 여기'에 저장된다고 해봅시다. 좋아요.
 

2887
01:05:43,670 --> 01:05:43,680

 

2888
01:05:43,680 --> 01:05:48,630

이제 만약 이 객체가 이

2889
01:05:48,630 --> 01:05:48,640
이제 만약 이 객체가 이
 

2890
01:05:48,640 --> 01:05:52,789
이제 만약 이 객체가 이
테이블에 있다면, 모든 인덱스가

2891
01:05:52,789 --> 01:05:52,799
테이블에 있다면, 모든 인덱스가
 

2892
01:05:52,799 --> 01:05:56,069
테이블에 있다면, 모든 인덱스가
변경되었겠죠. 따라서

2893
01:05:56,069 --> 01:05:56,079
변경되었겠죠. 따라서
 

2894
01:05:56,079 --> 01:05:57,990
변경되었겠죠. 따라서
이 세트 데이터 구조에 저장된 인덱스를 업데이트하려면

2895
01:05:57,990 --> 01:05:58,000
이 세트 데이터 구조에 저장된 인덱스를 업데이트하려면
 

2896
01:05:58,000 --> 01:05:59,829
이 세트 데이터 구조에 저장된 인덱스를 업데이트하려면
모든 인덱스를 하나씩 바꿔야 합니다

2897
01:05:59,829 --> 01:05:59,839
모든 인덱스를 하나씩 바꿔야 합니다
 

2898
01:05:59,839 --> 01:06:02,150
모든 인덱스를 하나씩 바꿔야 합니다
.  응.  이해가 되시나요?

2899
01:06:02,150 --> 01:06:02,160
.  응.  이해가 되시나요?
 

2900
01:06:02,160 --> 01:06:04,150
.  응.  이해가 되시나요?
응.  아니, 이게 훨씬 더 말이 돼.

2901
01:06:04,150 --> 01:06:04,160
응.  아니, 이게 훨씬 더 말이 돼.
 

2902
01:06:04,160 --> 01:06:06,150
응.  아니, 이게 훨씬 더 말이 돼.
응.  그러니까 제가 정말로 원하는 건

2903
01:06:06,150 --> 01:06:06,160
응.  그러니까 제가 정말로 원하는 건
 

2904
01:06:06,160 --> 01:06:08,069
응.  그러니까 제가 정말로 원하는 건
여기에 숫자가 아니라, 이 데이터를

2905
01:06:08,069 --> 01:06:08,079
여기에 숫자가 아니라, 이 데이터를
 

2906
01:06:08,079 --> 01:06:09,910
여기에 숫자가 아니라, 이 데이터를
담고 있는 노드를 가리키는 포인터를 저장하는 거예요

2907
01:06:09,910 --> 01:06:09,920
담고 있는 노드를 가리키는 포인터를 저장하는 거예요
 

2908
01:06:09,920 --> 01:06:12,630
담고 있는 노드를 가리키는 포인터를 저장하는 거예요
, 그렇죠?  노드는

2909
01:06:12,630 --> 01:06:12,640
, 그렇죠?  노드는
 

2910
01:06:12,640 --> 01:06:14,950
, 그렇죠?  노드는
해당 요소가 내 데이터 구조에서 사라지지 않는 한 변경되지 않기 때문이죠

2911
01:06:14,950 --> 01:06:14,960
해당 요소가 내 데이터 구조에서 사라지지 않는 한 변경되지 않기 때문이죠
 

2912
01:06:14,960 --> 01:06:17,109
해당 요소가 내 데이터 구조에서 사라지지 않는 한 변경되지 않기 때문이죠
, 그렇죠?  노드, 즉

2913
01:06:17,109 --> 01:06:17,119
, 그렇죠?  노드, 즉
 

2914
01:06:17,119 --> 01:06:19,109
, 그렇죠?  노드, 즉
메모리에서 해당 요소의 주소는,

2915
01:06:19,109 --> 01:06:19,119
메모리에서 해당 요소의 주소는,
 

2916
01:06:19,119 --> 01:06:21,670
메모리에서 해당 요소의 주소는,
노드는

2917
01:06:21,670 --> 01:06:21,680
노드는
 

2918
01:06:21,680 --> 01:06:23,990
노드는
항목과 다음

2919
01:06:23,990 --> 01:06:24,000
항목과 다음
 

2920
01:06:24,000 --> 01:06:25,349
항목과 다음
포인터를 담고 있는 작은 컨테이너일 뿐입니다.  그리고 사실,

2921
01:06:25,349 --> 01:06:25,359
포인터를 담고 있는 작은 컨테이너일 뿐입니다.  그리고 사실,
 

2922
01:06:25,359 --> 01:06:28,470
포인터를 담고 있는 작은 컨테이너일 뿐입니다.  그리고 사실,
여기서는 이전 포인터가 필요할 거예요,

2923
01:06:28,470 --> 01:06:28,480
여기서는 이전 포인터가 필요할 거예요,
 

2924
01:06:28,480 --> 01:06:29,990
여기서는 이전 포인터가 필요할 거예요,
그렇죠?  두 배

2925
01:06:29,990 --> 01:06:30,000
그렇죠?  두 배
 

2926
01:06:30,000 --> 01:06:32,710
그렇죠?  두 배
길이의 리스트가 필요하겠죠?  우리가

2927
01:06:32,710 --> 01:06:32,720
길이의 리스트가 필요하겠죠?  우리가
 

2928
01:06:32,720 --> 01:06:34,630
길이의 리스트가 필요하겠죠?  우리가
무언가를 제거할 때는

2929
01:06:34,630 --> 01:06:34,640
무언가를 제거할 때는
 

2930
01:06:34,640 --> 01:06:37,029
무언가를 제거할 때는
끊임없이 다시 붙여야 하는데

2931
01:06:37,029 --> 01:06:37,039
끊임없이 다시 붙여야 하는데
 

2932
01:06:37,039 --> 01:06:39,029
끊임없이 다시 붙여야 하는데
, 그러려면

2933
01:06:39,029 --> 01:06:39,039
, 그러려면
 

2934
01:06:39,039 --> 01:06:41,190
, 그러려면
우리 앞에 무엇이 있고

2935
01:06:41,190 --> 01:06:41,200
우리 앞에 무엇이 있고
 

2936
01:06:41,200 --> 01:06:44,710
우리 앞에 무엇이 있고
뒤에 무엇이 있는지 알아야 한다는 뜻이죠.  응.  좋아요.

2937
01:06:44,710 --> 01:06:44,720
뒤에 무엇이 있는지 알아야 한다는 뜻이죠.  응.  좋아요.
 

2938
01:06:44,720 --> 01:06:47,910
뒤에 무엇이 있는지 알아야 한다는 뜻이죠.  응.  좋아요.
괜찮은.  자, 여기서는 링크 리스트를 사용하고,

2939
01:06:47,910 --> 01:06:47,920
괜찮은.  자, 여기서는 링크 리스트를 사용하고,
 

2940
01:06:47,920 --> 01:06:53,109
괜찮은.  자, 여기서는 링크 리스트를 사용하고,
해시 테이블을 사용하는 것도 고려해 볼 수 있다고 이미 말씀드렸죠. 좋습니다. 이 정도면

2941
01:06:53,109 --> 01:06:57,029

 

2942
01:06:57,029 --> 01:06:57,039

 

2943
01:06:57,039 --> 01:07:00,789

기본적으로

2944
01:07:00,789 --> 01:07:00,799
기본적으로
 

2945
01:07:00,799 --> 01:07:03,109
기본적으로
제 데이터 구조라고 할 수 있겠네요.

2946
01:07:03,109 --> 01:07:03,119
제 데이터 구조라고 할 수 있겠네요.
 

2947
01:07:03,119 --> 01:07:04,870
제 데이터 구조라고 할 수 있겠네요.
불변 조건은 무엇일까요

2948
01:07:04,870 --> 01:07:07,430
불변 조건은 무엇일까요
 

2949
01:07:07,430 --> 01:07:09,270

 

2950
01:07:09,270 --> 01:07:12,789

 

2951
01:07:12,789 --> 01:07:14,390

 

2952
01:07:14,390 --> 01:07:15,990

 

2953
01:07:15,990 --> 01:07:18,150

 

2954
01:07:18,150 --> 01:07:18,160

 

2955
01:07:18,160 --> 01:07:21,270

? 모든 고객 정보를 저장하는 것이죠. 이것도 불변 조건 중 하나입니다. 아주 강력한 불변 조건은 아니지만, 어쨌든 모든 고객 정보를 저장하는 이유는 쿼리를 실행할 때 이 정보가 유지되도록 해야 하기 때문입니다.  그리고 여기서

2956
01:07:21,270 --> 01:07:21,280
? 모든 고객 정보를 저장하는 것이죠. 이것도 불변 조건 중 하나입니다. 아주 강력한 불변 조건은 아니지만, 어쨌든 모든 고객 정보를 저장하는 이유는 쿼리를 실행할 때 이 정보가 유지되도록 해야 하기 때문입니다.  그리고 여기서
 

2957
01:07:21,280 --> 01:07:24,789
? 모든 고객 정보를 저장하는 것이죠. 이것도 불변 조건 중 하나입니다. 아주 강력한 불변 조건은 아니지만, 어쨌든 모든 고객 정보를 저장하는 이유는 쿼리를 실행할 때 이 정보가 유지되도록 해야 하기 때문입니다.  그리고 여기서
매핑 이름을 포인터로 설정하는 거죠?

2958
01:07:24,789 --> 01:07:24,799
매핑 이름을 포인터로 설정하는 거죠?
 

2959
01:07:24,799 --> 01:07:28,150
매핑 이름을 포인터로 설정하는 거죠?
이거 안에 있는 그 부분 말이죠?  그리고 제가

2960
01:07:28,150 --> 01:07:28,160
이거 안에 있는 그 부분 말이죠?  그리고 제가
 

2961
01:07:28,160 --> 01:07:29,910
이거 안에 있는 그 부분 말이죠?  그리고 제가
어떤 것들을 제거할 때, 그

2962
01:07:29,910 --> 01:07:29,920
어떤 것들을 제거할 때, 그
 

2963
01:07:29,920 --> 01:07:31,990
어떤 것들을 제거할 때, 그
불변 조건은 그대로 유지되도록 해야 하겠죠?  제 시스템에

2964
01:07:31,990 --> 01:07:33,750
불변 조건은 그대로 유지되도록 해야 하겠죠?  제 시스템에
 

2965
01:07:33,750 --> 01:07:33,760

 

2966
01:07:33,760 --> 01:07:36,950

있는 모든 고객 이름을 해당 노드에 매핑하는 작업이 아직 진행 중입니다.

2967
01:07:36,950 --> 01:07:36,960
있는 모든 고객 이름을 해당 노드에 매핑하는 작업이 아직 진행 중입니다.
 

2968
01:07:36,960 --> 01:07:40,069
있는 모든 고객 이름을 해당 노드에 매핑하는 작업이 아직 진행 중입니다.
좋아요?  그러니 무언가가 떠나면

2969
01:07:40,069 --> 01:07:40,079
좋아요?  그러니 무언가가 떠나면
 

2970
01:07:40,079 --> 01:07:41,510
좋아요?  그러니 무언가가 떠나면
이 두 가지 모두

2971
01:07:41,510 --> 01:07:41,520
이 두 가지 모두
 

2972
01:07:41,520 --> 01:07:43,670
이 두 가지 모두
업데이트되었는지 확인해야 합니다.

2973
01:07:43,670 --> 01:07:43,680
업데이트되었는지 확인해야 합니다.
 

2974
01:07:43,680 --> 01:07:47,190
업데이트되었는지 확인해야 합니다.
이해가 되시나요?  좋습니다. 그럼 이러한 운영을 어떻게 유지 관리하면 될까요

2975
01:07:47,190 --> 01:07:47,200
이해가 되시나요?  좋습니다. 그럼 이러한 운영을 어떻게 유지 관리하면 될까요
 

2976
01:07:47,200 --> 01:07:50,470
이해가 되시나요?  좋습니다. 그럼 이러한 운영을 어떻게 유지 관리하면 될까요
?  빌드가 하나 있어요.  빌드 과정은

2977
01:07:50,470 --> 01:07:50,480
?  빌드가 하나 있어요.  빌드 과정은
 

2978
01:07:50,480 --> 01:07:53,109
?  빌드가 하나 있어요.  빌드 과정은
이러한 요소들을 모두 비워둔 채로 진행하는 거죠

2979
01:07:53,109 --> 01:07:53,119
이러한 요소들을 모두 비워둔 채로 진행하는 거죠
 

2980
01:07:53,119 --> 01:07:56,230
이러한 요소들을 모두 비워둔 채로 진행하는 거죠
?  그러니까 그냥 그렇게 말하면 되는 거죠?  저는

2981
01:07:56,230 --> 01:07:59,109
?  그러니까 그냥 그렇게 말하면 되는 거죠?  저는
 

2982
01:07:59,109 --> 01:07:59,119

 

2983
01:07:59,119 --> 01:08:01,430

고객들을 대상으로 빈 연결 리스트와 이중 연결 리스트를 만들고, 현재는 아무것도 없는 것에 아무것도

2984
01:08:01,430 --> 01:08:01,440
고객들을 대상으로 빈 연결 리스트와 이중 연결 리스트를 만들고, 현재는 아무것도 없는 것에 아무것도
 

2985
01:08:01,440 --> 01:08:06,069
고객들을 대상으로 빈 연결 리스트와 이중 연결 리스트를 만들고, 현재는 아무것도 없는 것에 아무것도
매핑하는 해시 테이블을 만들고 있습니다

2986
01:08:06,069 --> 01:08:06,079
매핑하는 해시 테이블을 만들고 있습니다
 

2987
01:08:06,079 --> 01:08:08,630
매핑하는 해시 테이블을 만들고 있습니다
.  오른쪽.  좋아요.  자, 이게 바로

2988
01:08:08,630 --> 01:08:08,640
.  오른쪽.  좋아요.  자, 이게 바로
 

2989
01:08:08,640 --> 01:08:12,230
.  오른쪽.  좋아요.  자, 이게 바로
빌드입니다.  제가 정확하게 말씀드리겠습니다.

2990
01:08:12,230 --> 01:08:15,270
빌드입니다.  제가 정확하게 말씀드리겠습니다.
 

2991
01:08:15,270 --> 01:08:18,630

 

2992
01:08:18,630 --> 01:08:18,640

 

2993
01:08:18,640 --> 01:08:21,669

연산 과정을 무시하지 말라고 말씀드렸기 때문에, 그 부분을 적어두겠습니다. 그렇지 않으면

2994
01:08:21,669 --> 01:08:21,679
연산 과정을 무시하지 말라고 말씀드렸기 때문에, 그 부분을 적어두겠습니다. 그렇지 않으면
 

2995
01:08:21,679 --> 01:08:24,229
연산 과정을 무시하지 말라고 말씀드렸기 때문에, 그 부분을 적어두겠습니다. 그렇지 않으면
점수를 드릴 수 없습니다.  다음

2996
01:08:24,229 --> 01:08:24,239
점수를 드릴 수 없습니다.  다음
 

2997
01:08:24,239 --> 01:08:27,030
점수를 드릴 수 없습니다.  다음
사람.  응.  빈 리스트를 만든다는 것은

2998
01:08:27,030 --> 01:08:29,990
사람.  응.  빈 리스트를 만든다는 것은
 

2999
01:08:29,990 --> 01:08:30,000

 

3000
01:08:30,000 --> 01:08:31,669

헤드와 테일이 모두 비어 있지만 리스트 자체는

3001
01:08:31,669 --> 01:08:31,679
헤드와 테일이 모두 비어 있지만 리스트 자체는
 

3002
01:08:31,679 --> 01:08:34,390
헤드와 테일이 모두 비어 있지만 리스트 자체는
존재하는 것을 의미하는 건가요?  응.  오른쪽.  그것은

3003
01:08:34,390 --> 01:08:34,400
존재하는 것을 의미하는 건가요?  응.  오른쪽.  그것은
 

3004
01:08:34,400 --> 01:08:36,870
존재하는 것을 의미하는 건가요?  응.  오른쪽.  그것은
우리가 기억 속에 저장하는 어떤 것입니다.

3005
01:08:36,870 --> 01:08:36,880
우리가 기억 속에 저장하는 어떤 것입니다.
 

3006
01:08:36,880 --> 01:08:38,789
우리가 기억 속에 저장하는 어떤 것입니다.
머리와 꼬리를 가리키는 포인터가 있습니다.  지금은

3007
01:08:38,789 --> 01:08:38,799
머리와 꼬리를 가리키는 포인터가 있습니다.  지금은
 

3008
01:08:38,799 --> 01:08:41,910
머리와 꼬리를 가리키는 포인터가 있습니다.  지금은
없지만 앞으로 추가할 예정입니다

3009
01:08:41,910 --> 01:08:41,920
없지만 앞으로 추가할 예정입니다
 

3010
01:08:41,920 --> 01:08:45,430
없지만 앞으로 추가할 예정입니다
.  오른쪽?  좋아요.  두 번째 항목에는 이름을 추가하는 게

3011
01:08:45,430 --> 01:08:45,440
.  오른쪽?  좋아요.  두 번째 항목에는 이름을 추가하는 게
 

3012
01:08:45,440 --> 01:08:50,870
.  오른쪽?  좋아요.  두 번째 항목에는 이름을 추가하는 게
맞죠?

3013
01:08:50,870 --> 01:08:50,880

 

3014
01:08:50,880 --> 01:08:52,630

우리가 할 말은 무엇일까요?  우리는

3015
01:08:52,630 --> 01:08:52,640
우리가 할 말은 무엇일까요?  우리는
 

3016
01:08:52,640 --> 01:08:54,149
우리가 할 말은 무엇일까요?  우리는
이 데이터 구조를 업데이트하여

3017
01:08:54,149 --> 01:08:54,159
이 데이터 구조를 업데이트하여
 

3018
01:08:54,159 --> 01:08:57,110
이 데이터 구조를 업데이트하여
분산을 유지할 수 있도록 해야 합니다.  오른쪽?  저는

3019
01:08:57,110 --> 01:08:57,120
분산을 유지할 수 있도록 해야 합니다.  오른쪽?  저는
 

3020
01:08:57,120 --> 01:09:00,789
분산을 유지할 수 있도록 해야 합니다.  오른쪽?  저는
보통 그중 하나부터 시작해야 합니다.  음, 어느 순간 '

3021
01:09:00,789 --> 01:09:00,799
보통 그중 하나부터 시작해야 합니다.  음, 어느 순간 '
 

3022
01:09:00,799 --> 01:09:03,269
보통 그중 하나부터 시작해야 합니다.  음, 어느 순간 '
아, 진작에

3023
01:09:03,269 --> 01:09:03,279
아, 진작에
 

3024
01:09:03,279 --> 01:09:05,269
아, 진작에
다른 걸 먼저 업데이트했어야 했는데'라는 생각이 들어요.

3025
01:09:05,269 --> 01:09:05,279
다른 걸 먼저 업데이트했어야 했는데'라는 생각이 들어요.
 

3026
01:09:05,279 --> 01:09:07,510
다른 걸 먼저 업데이트했어야 했는데'라는 생각이 들어요.
오른쪽?  그래서 때로는 잘 될 때도 있고 안 될 때도 있죠.

3027
01:09:07,510 --> 01:09:07,520
오른쪽?  그래서 때로는 잘 될 때도 있고 안 될 때도 있죠.
 

3028
01:09:07,520 --> 01:09:09,669
오른쪽?  그래서 때로는 잘 될 때도 있고 안 될 때도 있죠.
나는 여기서 무엇을 하고 싶은가?  음,

3029
01:09:09,669 --> 01:09:09,679
나는 여기서 무엇을 하고 싶은가?  음,
 

3030
01:09:09,679 --> 01:09:12,229
나는 여기서 무엇을 하고 싶은가?  음,
이 장면이 전체 순서에서 어디에 해당하는지 전혀 모르겠네요,

3031
01:09:12,229 --> 01:09:12,239
이 장면이 전체 순서에서 어디에 해당하는지 전혀 모르겠네요,
 

3032
01:09:12,239 --> 01:09:14,149
이 장면이 전체 순서에서 어디에 해당하는지 전혀 모르겠네요,
그렇죠?  그러니까, 제가

3033
01:09:14,149 --> 01:09:14,159
그렇죠?  그러니까, 제가
 

3034
01:09:14,159 --> 01:09:16,550
그렇죠?  그러니까, 제가
먼저 여기를 들러야 하는 거죠?

3035
01:09:16,550 --> 01:09:16,560
먼저 여기를 들러야 하는 거죠?
 

3036
01:09:16,560 --> 01:09:19,990
먼저 여기를 들러야 하는 거죠?
아, 죄송합니다.  어떤 식으로든 괜찮을 것 같은 사람을 추가하는 거잖아요

3037
01:09:19,990 --> 01:09:20,000
아, 죄송합니다.  어떤 식으로든 괜찮을 것 같은 사람을 추가하는 거잖아요
 

3038
01:09:20,000 --> 01:09:22,229
아, 죄송합니다.  어떤 식으로든 괜찮을 것 같은 사람을 추가하는 거잖아요
, 그렇죠?  나는 그가 어디로 갈지 알고 있어.

3039
01:09:22,229 --> 01:09:22,239
, 그렇죠?  나는 그가 어디로 갈지 알고 있어.
 

3040
01:09:22,239 --> 01:09:25,510
, 그렇죠?  나는 그가 어디로 갈지 알고 있어.
목록의 마지막이죠, 그렇죠?  그럼 그냥 저기에 꽂아두면 되는 거죠

3041
01:09:25,510 --> 01:09:25,520
목록의 마지막이죠, 그렇죠?  그럼 그냥 저기에 꽂아두면 되는 거죠
 

3042
01:09:25,520 --> 01:09:29,829
목록의 마지막이죠, 그렇죠?  그럼 그냥 저기에 꽂아두면 되는 거죠
?  그러므로

3043
01:09:29,829 --> 01:09:29,839
?  그러므로
 

3044
01:09:29,839 --> 01:09:31,749
?  그러므로

3045
01:09:31,749 --> 01:09:31,759

 

3046
01:09:31,759 --> 01:09:38,229

수열의 끝에 x를 더하세요.  괜찮은.  그래서 저는 이미 마음에 드는

3047
01:09:38,229 --> 01:09:38,239
수열의 끝에 x를 더하세요.  괜찮은.  그래서 저는 이미 마음에 드는
 

3048
01:09:38,239 --> 01:09:40,070
수열의 끝에 x를 더하세요.  괜찮은.  그래서 저는 이미 마음에 드는
방법을 하나 찾았어요,

3049
01:09:40,070 --> 01:09:40,080
방법을 하나 찾았어요,
 

3050
01:09:40,080 --> 01:09:44,870
방법을 하나 찾았어요,
그렇죠?  순서가 설정되었습니다.  네, 이

3051
01:09:44,870 --> 01:09:44,880
그렇죠?  순서가 설정되었습니다.  네, 이
 

3052
01:09:44,880 --> 01:09:46,470
그렇죠?  순서가 설정되었습니다.  네, 이
경우에는 한 세트에 시퀀스가 ​​하나만 있으니까

3053
01:09:46,470 --> 01:09:46,480
경우에는 한 세트에 시퀀스가 ​​하나만 있으니까
 

3054
01:09:46,480 --> 01:09:48,870
경우에는 한 세트에 시퀀스가 ​​하나만 있으니까
시퀀스와 세트라고 부르는 게

3055
01:09:48,870 --> 01:09:48,880
시퀀스와 세트라고 부르는 게
 

3056
01:09:48,880 --> 01:09:50,950
시퀀스와 세트라고 부르는 게
괜찮을 것 같네요, 그렇죠?  나는

3057
01:09:50,950 --> 01:09:50,960
괜찮을 것 같네요, 그렇죠?  나는
 

3058
01:09:50,960 --> 01:09:52,390
괜찮을 것 같네요, 그렇죠?  나는
더 큰 것을 혼란스럽게 하지 않을 거야. 나

3059
01:09:52,390 --> 01:09:52,400
더 큰 것을 혼란스럽게 하지 않을 거야. 나
 

3060
01:09:52,400 --> 01:09:55,430
더 큰 것을 혼란스럽게 하지 않을 거야. 나
자신을 혼란스럽게 하지도 않을 거고, 그렇지?  하지만

3061
01:09:55,430 --> 01:09:55,440
자신을 혼란스럽게 하지도 않을 거고, 그렇지?  하지만
 

3062
01:09:55,440 --> 01:09:57,430
자신을 혼란스럽게 하지도 않을 거고, 그렇지?  하지만
이런 것들이 두 개 이상 있거나,

3063
01:09:57,430 --> 01:09:57,440
이런 것들이 두 개 이상 있거나,
 

3064
01:09:57,440 --> 01:09:59,990
이런 것들이 두 개 이상 있거나,
시험처럼

3065
01:09:59,990 --> 01:10:00,000
시험처럼
 

3066
01:10:00,000 --> 01:10:01,990
시험처럼
시간이 제한적인 상황에서는 간결하게 표현하기 위해 이런

3067
01:10:01,990 --> 01:10:02,000
시간이 제한적인 상황에서는 간결하게 표현하기 위해 이런
 

3068
01:10:02,000 --> 01:10:04,550
시간이 제한적인 상황에서는 간결하게 표현하기 위해 이런
것들에 이름을 붙이는 게 좋겠죠?  이게

3069
01:10:04,550 --> 01:10:04,560
것들에 이름을 붙이는 게 좋겠죠?  이게
 

3070
01:10:04,560 --> 01:10:09,030
것들에 이름을 붙이는 게 좋겠죠?  이게
C와 M이라는 순서라고 해볼게요. 잘 모르겠네요.

3071
01:10:09,030 --> 01:10:09,040
C와 M이라는 순서라고 해볼게요. 잘 모르겠네요.
 

3072
01:10:09,040 --> 01:10:11,669
C와 M이라는 순서라고 해볼게요. 잘 모르겠네요.
여기에는 고객이 보이고, 여기에는 지도가 보이는데... 제가 잘

3073
01:10:11,669 --> 01:10:11,679
여기에는 고객이 보이고, 여기에는 지도가 보이는데... 제가 잘
 

3074
01:10:11,679 --> 01:10:14,310
여기에는 고객이 보이고, 여기에는 지도가 보이는데... 제가 잘
모르는 걸 수도 있지만, 그냥 각각에

3075
01:10:14,310 --> 01:10:14,320
모르는 걸 수도 있지만, 그냥 각각에
 

3076
01:10:14,320 --> 01:10:16,630
모르는 걸 수도 있지만, 그냥 각각에
문자를 붙여주시면 훨씬

3077
01:10:16,630 --> 01:10:16,640
문자를 붙여주시면 훨씬
 

3078
01:10:16,640 --> 01:10:18,470
문자를 붙여주시면 훨씬
더 명확하게 이해하고

3079
01:10:18,470 --> 01:10:18,480
더 명확하게 이해하고
 

3080
01:10:18,480 --> 01:10:23,189
더 명확하게 이해하고
더 정확하게 참조할 수 있을 거예요. C는 끝났고, 그럼 이제

3081
01:10:23,189 --> 01:10:23,199
더 정확하게 참조할 수 있을 거예요. C는 끝났고, 그럼 이제
 

3082
01:10:23,199 --> 01:10:25,189
더 정확하게 참조할 수 있을 거예요. C는 끝났고, 그럼 이제

3083
01:10:25,189 --> 01:10:25,199

 

3084
01:10:25,199 --> 01:10:28,790

뭘 해야 할까요?

3085
01:10:28,790 --> 01:10:28,800
뭘 해야 할까요?
 

3086
01:10:28,800 --> 01:10:31,510
뭘 해야 할까요?
이 사람은 괜찮아요. 이제

3087
01:10:31,510 --> 01:10:31,520
이 사람은 괜찮아요. 이제
 

3088
01:10:31,520 --> 01:10:36,310
이 사람은 괜찮아요. 이제
이 사람도 고쳐야 하죠. 그래서 집합에 x를 추가하고, 방금 전에

3089
01:10:36,310 --> 01:10:36,320
이 사람도 고쳐야 하죠. 그래서 집합에 x를 추가하고, 방금 전에
 

3090
01:10:36,320 --> 01:10:38,630
이 사람도 고쳐야 하죠. 그래서 집합에 x를 추가하고, 방금 전에
왔던 노드로 다시 매핑하면 돼요

3091
01:10:38,630 --> 01:10:38,640
왔던 노드로 다시 매핑하면 돼요
 

3092
01:10:38,640 --> 01:10:39,910
왔던 노드로 다시 매핑하면 돼요
.  오른쪽?  임시 변수에 저장해도 되겠죠

3093
01:10:39,910 --> 01:10:39,920
.  오른쪽?  임시 변수에 저장해도 되겠죠
 

3094
01:10:39,920 --> 01:10:44,229
.  오른쪽?  임시 변수에 저장해도 되겠죠
?

3095
01:10:44,229 --> 01:10:50,550
?
 

3096
01:10:50,550 --> 01:10:50,560

 

3097
01:10:50,560 --> 01:10:53,669


3098
01:10:53,669 --> 01:10:53,679

 

3099
01:10:53,679 --> 01:10:56,470

노드

3100
01:10:56,470 --> 01:10:56,480
노드
 

3101
01:10:56,480 --> 01:11:00,550
노드
v에서 v로 향하는 m에 x를 더하세요. 좋아요, 잘 됐네요.

3102
01:11:00,550 --> 01:11:00,560
v에서 v로 향하는 m에 x를 더하세요. 좋아요, 잘 됐네요.
 

3103
01:11:00,560 --> 01:11:04,709
v에서 v로 향하는 m에 x를 더하세요. 좋아요, 잘 됐네요.
그래서 C 끝에 X를 추가해서

3104
01:11:04,709 --> 01:11:04,719
그래서 C 끝에 X를 추가해서
 

3105
01:11:04,719 --> 01:11:08,310
그래서 C 끝에 X를 추가해서
노드 V를 만든 거죠?

3106
01:11:08,310 --> 01:11:08,320
노드 V를 만든 거죠?
 

3107
01:11:08,320 --> 01:11:10,390
노드 V를 만든 거죠?
나중에 참고할 수 있도록 라벨을 붙여두는 게 좋을 것 같아요,

3108
01:11:10,390 --> 01:11:10,400
나중에 참고할 수 있도록 라벨을 붙여두는 게 좋을 것 같아요,
 

3109
01:11:10,400 --> 01:11:13,030
나중에 참고할 수 있도록 라벨을 붙여두는 게 좋을 것 같아요,
그렇죠?  그리고 코드상으로는

3110
01:11:13,030 --> 01:11:13,040
그렇죠?  그리고 코드상으로는
 

3111
01:11:13,040 --> 01:11:15,750
그렇죠?  그리고 코드상으로는
그 노드가 무엇이었는지 아마 기억할 수 있을 거예요.

3112
01:11:15,750 --> 01:11:15,760
그 노드가 무엇이었는지 아마 기억할 수 있을 거예요.
 

3113
01:11:15,760 --> 01:11:19,750
그 노드가 무엇이었는지 아마 기억할 수 있을 거예요.
해당 노드를 가리키는 X를 M에 추가합니다.  오른쪽?

3114
01:11:19,750 --> 01:11:19,760
해당 노드를 가리키는 X를 M에 추가합니다.  오른쪽?
 

3115
01:11:19,760 --> 01:11:21,350
해당 노드를 가리키는 X를 M에 추가합니다.  오른쪽?
이제 저는 불변량을 유지했습니다.

3116
01:11:21,350 --> 01:11:21,360
이제 저는 불변량을 유지했습니다.
 

3117
01:11:21,360 --> 01:11:26,229
이제 저는 불변량을 유지했습니다.
엄청난.  다음은 뭘까요?  어,

3118
01:11:26,229 --> 01:11:26,239
엄청난.  다음은 뭘까요?  어,
 

3119
01:11:26,239 --> 01:11:28,390
엄청난.  다음은 뭘까요?  어,
키 X를 추가

3120
01:11:28,390 --> 01:11:28,400
키 X를 추가
 

3121
01:11:28,400 --> 01:11:33,910
키 X를 추가
하거나 M에 키 X를 추가하고, 키 X가

3122
01:11:33,910 --> 01:11:33,920
하거나 M에 키 X를 추가하고, 키 X가
 

3123
01:11:33,920 --> 01:11:35,830
하거나 M에 키 X를 추가하고, 키 X가
해당 음표를 가리키도록 하는 것입니다.

3124
01:11:35,830 --> 01:11:35,840
해당 음표를 가리키도록 하는 것입니다.
 

3125
01:11:35,840 --> 01:11:38,950
해당 음표를 가리키도록 하는 것입니다.
이해가 되시나요?  거기에는 미묘한 차이가 있어요.  좋아요.

3126
01:11:38,950 --> 01:11:38,960
이해가 되시나요?  거기에는 미묘한 차이가 있어요.  좋아요.
 

3127
01:11:38,960 --> 01:11:40,470
이해가 되시나요?  거기에는 미묘한 차이가 있어요.  좋아요.
세 번째로,

3128
01:11:40,470 --> 01:11:40,480
세 번째로,
 

3129
01:11:40,480 --> 01:11:43,110
세 번째로,
제거해야 할 것이 있습니다.   그

3130
01:11:43,110 --> 01:11:43,120
제거해야 할 것이 있습니다.   그
 

3131
01:11:43,120 --> 01:11:45,270
제거해야 할 것이 있습니다.   그
이름은 기억이 안 나요.

3132
01:11:45,270 --> 01:11:45,280
이름은 기억이 안 나요.
 

3133
01:11:45,280 --> 01:11:46,950
이름은 기억이 안 나요.
좋아요.

3134
01:11:46,950 --> 01:11:46,960
좋아요.
 

3135
01:11:46,960 --> 01:11:49,270
좋아요.
그러니까 여기서는 순서가 중요하죠,

3136
01:11:49,270 --> 01:11:49,280
그러니까 여기서는 순서가 중요하죠,
 

3137
01:11:49,280 --> 01:11:50,709
그러니까 여기서는 순서가 중요하죠,
그렇죠?  순서상 어디에 있는지는 모르겠지만,

3138
01:11:50,709 --> 01:11:50,719
그렇죠?  순서상 어디에 있는지는 모르겠지만,
 

3139
01:11:50,719 --> 01:11:53,350
그렇죠?  순서상 어디에 있는지는 모르겠지만,

3140
01:11:53,350 --> 01:11:53,360

 

3141
01:11:53,360 --> 01:11:55,270

세트에서 찾아보겠습니다.

3142
01:11:55,270 --> 01:11:55,280
세트에서 찾아보겠습니다.
 

3143
01:11:55,280 --> 01:11:58,149
세트에서 찾아보겠습니다.
저는 그것을 세트에서 제거하고, 그것이 가리키는 대상을

3144
01:11:58,149 --> 01:11:58,159
저는 그것을 세트에서 제거하고, 그것이 가리키는 대상을
 

3145
01:11:58,159 --> 01:11:59,830
저는 그것을 세트에서 제거하고, 그것이 가리키는 대상을
확인한 다음

3146
01:11:59,830 --> 01:11:59,840
확인한 다음
 

3147
01:11:59,840 --> 01:12:01,750
확인한 다음
시퀀스에서 제거하겠습니다.   네

3148
01:12:01,750 --> 01:12:01,760
시퀀스에서 제거하겠습니다.   네
 

3149
01:12:01,760 --> 01:12:03,510
시퀀스에서 제거하겠습니다.   네
, 시간이 좀 부족해서 전부 다 적지는

3150
01:12:03,510 --> 01:12:03,520
, 시간이 좀 부족해서 전부 다 적지는
 

3151
01:12:03,520 --> 01:12:04,630
, 시간이 좀 부족해서 전부 다 적지는
않겠지만

3152
01:12:04,630 --> 01:12:04,640
않겠지만
 

3153
01:12:04,640 --> 01:12:06,390
않겠지만
, 여러분은 무슨

3154
01:12:06,390 --> 01:12:06,400
, 여러분은 무슨
 

3155
01:12:06,400 --> 01:12:08,470
, 여러분은 무슨
뜻인지 아시겠죠?  여기서는 이중 연결 리스트라는 점을 이용하여

3156
01:12:08,470 --> 01:12:11,189
뜻인지 아시겠죠?  여기서는 이중 연결 리스트라는 점을 이용하여
 

3157
01:12:11,189 --> 01:12:11,199

 

3158
01:12:11,199 --> 01:12:13,189

요소들을 다시 연결할 수 있도록 하고 있습니다.

3159
01:12:13,189 --> 01:12:15,590
요소들을 다시 연결할 수 있도록 하고 있습니다.
 

3160
01:12:15,590 --> 01:12:15,600

 

3161
01:12:15,600 --> 01:12:18,709

이전 포인터를 다음 객체로 다시 연결하는 방법을 굳이 알려주실 필요는 없어요.

3162
01:12:18,709 --> 01:12:21,830
이전 포인터를 다음 객체로 다시 연결하는 방법을 굳이 알려주실 필요는 없어요.
 

3163
01:12:21,830 --> 01:12:23,270

 

3164
01:12:23,270 --> 01:12:23,280

 

3165
01:12:23,280 --> 01:12:25,270

이미

3166
01:12:25,270 --> 01:12:25,280
이미
 

3167
01:12:25,280 --> 01:12:28,709
이미
문제 세트 1에서 다뤘으니까요. 그냥

3168
01:12:28,709 --> 01:12:28,719
문제 세트 1에서 다뤘으니까요. 그냥
 

3169
01:12:28,719 --> 01:12:30,470
문제 세트 1에서 다뤘으니까요. 그냥
일반적인 상황에서

3170
01:12:30,470 --> 01:12:30,480
일반적인 상황에서
 

3171
01:12:30,480 --> 01:12:33,189
일반적인 상황에서
이중 연결 리스트 대신 일반 연결 리스트를 사용하는 게 더 나은 경우가 있을까요? 이중 연결 리스트가

3172
01:12:33,189 --> 01:12:34,470
이중 연결 리스트 대신 일반 연결 리스트를 사용하는 게 더 나은 경우가 있을까요? 이중 연결 리스트가
 

3173
01:12:34,470 --> 01:12:35,750

 

3174
01:12:35,750 --> 01:12:35,760

 

3175
01:12:35,760 --> 01:12:37,590

항상 문제를 해결해주는 것 같긴 한데 말이죠. 네, 이론적으로는

3176
01:12:37,590 --> 01:12:37,600
항상 문제를 해결해주는 것 같긴 한데 말이죠. 네, 이론적으로는
 

3177
01:12:37,600 --> 01:12:39,510
항상 문제를 해결해주는 것 같긴 한데 말이죠. 네, 이론적으로는
이중 연결 리스트가

3178
01:12:39,510 --> 01:12:39,520
이중 연결 리스트가
 

3179
01:12:39,520 --> 01:12:41,590
이중 연결 리스트가
단일 연결 리스트보다 거의 항상 더 좋긴 합니다.

3180
01:12:41,590 --> 01:12:41,600
단일 연결 리스트보다 거의 항상 더 좋긴 합니다.
 

3181
01:12:41,600 --> 01:12:47,669
단일 연결 리스트보다 거의 항상 더 좋긴 합니다.
그러니까 그냥 사용하세요.

3182
01:12:47,669 --> 01:12:47,679

 

3183
01:12:47,679 --> 01:12:55,189

좋아요.  어, 그리고 맨 마지막 자리에 앉으세요.

3184
01:12:55,189 --> 01:12:55,199

 

3185
01:12:55,199 --> 01:12:57,030

그건 그냥

3186
01:12:57,030 --> 01:12:57,040
그건 그냥
 

3187
01:12:57,040 --> 01:13:00,390
그건 그냥
시퀀스의 앞부분을 가져와서 제거하고

3188
01:13:00,390 --> 01:13:00,400
시퀀스의 앞부분을 가져와서 제거하고
 

3189
01:13:00,400 --> 01:13:02,709
시퀀스의 앞부분을 가져와서 제거하고
,

3190
01:13:02,709 --> 01:13:02,719
,
 

3191
01:13:02,719 --> 01:13:05,270
,
머리 부분을 바꾸는 것뿐이에요.  하지만

3192
01:13:05,270 --> 01:13:05,280
머리 부분을 바꾸는 것뿐이에요.  하지만
 

3193
01:13:05,280 --> 01:13:07,110
머리 부분을 바꾸는 것뿐이에요.  하지만
먼저 삭제할 수 있다는 건 이해해요, 그렇죠?  당신은

3194
01:13:07,110 --> 01:13:07,120
먼저 삭제할 수 있다는 건 이해해요, 그렇죠?  당신은
 

3195
01:13:07,120 --> 01:13:09,350
먼저 삭제할 수 있다는 건 이해해요, 그렇죠?  당신은
우리가 이전에 사용했던 인터페이스로 축소하고 있습니다.

3196
01:13:09,350 --> 01:13:09,360
우리가 이전에 사용했던 인터페이스로 축소하고 있습니다.
 

3197
01:13:09,360 --> 01:13:11,669
우리가 이전에 사용했던 인터페이스로 축소하고 있습니다.
이 순서에서 첫 번째 항목을 삭제하고 있습니다.

3198
01:13:11,669 --> 01:13:11,679
이 순서에서 첫 번째 항목을 삭제하고 있습니다.
 

3199
01:13:11,679 --> 01:13:15,430
이 순서에서 첫 번째 항목을 삭제하고 있습니다.
알겠습니다. 그런데 지금 우리에게는 문제가 생겼습니다.

3200
01:13:15,430 --> 01:13:15,440
알겠습니다. 그런데 지금 우리에게는 문제가 생겼습니다.
 

3201
01:13:15,440 --> 01:13:17,910
알겠습니다. 그런데 지금 우리에게는 문제가 생겼습니다.
첫 번째 사람을 삭제했어요.

3202
01:13:17,910 --> 01:13:17,920
첫 번째 사람을 삭제했어요.
 

3203
01:13:17,920 --> 01:13:20,229
첫 번째 사람을 삭제했어요.
첫 번째 남자가 누군지 어떻게 알 수 있죠?  음,

3204
01:13:20,229 --> 01:13:20,239
첫 번째 남자가 누군지 어떻게 알 수 있죠?  음,
 

3205
01:13:20,239 --> 01:13:22,070
첫 번째 남자가 누군지 어떻게 알 수 있죠?  음,
거기에 이름을 저장하는 거죠, 그렇죠?  저는

3206
01:13:22,070 --> 01:13:22,080
거기에 이름을 저장하는 거죠, 그렇죠?  저는
 

3207
01:13:22,080 --> 01:13:23,830
거기에 이름을 저장하는 거죠, 그렇죠?  저는
이 고객들의 이름을 저장하고 있습니다.  그래서 누가 맨 앞에 있었는지 알아요

3208
01:13:23,830 --> 01:13:23,840
이 고객들의 이름을 저장하고 있습니다.  그래서 누가 맨 앞에 있었는지 알아요
 

3209
01:13:23,840 --> 01:13:25,910
이 고객들의 이름을 저장하고 있습니다.  그래서 누가 맨 앞에 있었는지 알아요
.

3210
01:13:25,910 --> 01:13:25,920
.
 

3211
01:13:25,920 --> 01:13:28,550
.
저는 이 데이터 구조를 살펴보고

3212
01:13:28,550 --> 01:13:28,560
저는 이 데이터 구조를 살펴보고
 

3213
01:13:28,560 --> 01:13:30,790
저는 이 데이터 구조를 살펴보고
해당 항목을 제거합니다.  이해가 되시나요?

3214
01:13:30,790 --> 01:13:30,800
해당 항목을 제거합니다.  이해가 되시나요?
 

3215
01:13:30,800 --> 01:13:33,510
해당 항목을 제거합니다.  이해가 되시나요?
이제 나는 그가 어디로 가는지 더 이상 신경 쓸 필요가 없으니까요

3216
01:13:33,510 --> 01:13:33,520
이제 나는 그가 어디로 가는지 더 이상 신경 쓸 필요가 없으니까요
 

3217
01:13:33,520 --> 01:13:36,229
이제 나는 그가 어디로 가는지 더 이상 신경 쓸 필요가 없으니까요
.  사실,

3218
01:13:36,229 --> 01:13:36,239
.  사실,
 

3219
01:13:36,239 --> 01:13:39,750
.  사실,
저는 이 데이터 구조를 업데이트하지 않을 수도 있습니다

3220
01:13:39,750 --> 01:13:39,760
저는 이 데이터 구조를 업데이트하지 않을 수도 있습니다
 

3221
01:13:39,760 --> 01:13:42,870
저는 이 데이터 구조를 업데이트하지 않을 수도 있습니다
.  하지만 그렇게 하면

3222
01:13:42,870 --> 01:13:42,880
.  하지만 그렇게 하면
 

3223
01:13:42,880 --> 01:13:44,470
.  하지만 그렇게 하면
실행 시간은 여전히 ​​선형 시간이 되잖아요.

3224
01:13:44,470 --> 01:13:46,390
실행 시간은 여전히 ​​선형 시간이 되잖아요.
 

3225
01:13:46,390 --> 01:13:46,400

 

3226
01:13:46,400 --> 01:13:50,470

공간에 대한 제한을 드리는 게 아니라, 여전히 상수 시간으로 계산되는 거죠. 죄송합니다.

3227
01:13:50,470 --> 01:13:50,480
공간에 대한 제한을 드리는 게 아니라, 여전히 상수 시간으로 계산되는 거죠. 죄송합니다.
 

3228
01:13:50,480 --> 01:13:52,310
공간에 대한 제한을 드리는 게 아니라, 여전히 상수 시간으로 계산되는 거죠. 죄송합니다.
그러니까 실제로 그 부분을

3229
01:13:52,310 --> 01:13:52,320
그러니까 실제로 그 부분을
 

3230
01:13:52,320 --> 01:13:55,910
그러니까 실제로 그 부분을
삭제할 필요는 없지만, 만약 그 고객이 다시 와서

3231
01:13:55,910 --> 01:13:55,920
삭제할 필요는 없지만, 만약 그 고객이 다시 와서
 

3232
01:13:55,920 --> 01:13:57,430
삭제할 필요는 없지만, 만약 그 고객이 다시 와서
대기자 명단에 다시 이름을 올리고 싶어 한다면,

3233
01:13:57,430 --> 01:13:59,990
대기자 명단에 다시 이름을 올리고 싶어 한다면,
 

3234
01:13:59,990 --> 01:14:00,000

 

3235
01:14:00,000 --> 01:14:03,830

고려해야 할 사항들이 있죠.

3236
01:14:03,830 --> 01:14:07,110
고려해야 할 사항들이 있죠.
 

3237
01:14:07,110 --> 01:14:07,120

 

3238
01:14:07,120 --> 01:14:11,510

네, 그게 그 질문입니다. 다음 질문은 지난 10분 동안의

3239
01:14:11,510 --> 01:14:11,520
네, 그게 그 질문입니다. 다음 질문은 지난 10분 동안의
 

3240
01:14:11,520 --> 01:14:16,709
네, 그게 그 질문입니다. 다음 질문은 지난 10분 동안의
연구입니다.  이는

3241
01:14:16,709 --> 01:14:16,719
연구입니다.  이는
 

3242
01:14:16,719 --> 01:14:20,310
연구입니다.  이는
사람들이 악몽을 꿀 정도로 끔찍한 문제였다.

3243
01:14:20,310 --> 01:14:20,320
사람들이 악몽을 꿀 정도로 끔찍한 문제였다.
 

3244
01:14:20,320 --> 01:14:23,110
사람들이 악몽을 꿀 정도로 끔찍한 문제였다.
좋아요.  그러니까, 기본적으로 우리는 마더 완을 가지고 있어요

3245
01:14:23,110 --> 01:14:23,120
좋아요.  그러니까, 기본적으로 우리는 마더 완을 가지고 있어요
 

3246
01:14:23,120 --> 01:14:25,270
좋아요.  그러니까, 기본적으로 우리는 마더 완을 가지고 있어요
.

3247
01:14:25,270 --> 01:14:25,280
.
 

3248
01:14:25,280 --> 01:14:27,830
.
그는 기상캐스터입니다.  어,

3249
01:14:27,830 --> 01:14:27,840
그는 기상캐스터입니다.  어,
 

3250
01:14:27,840 --> 01:14:31,430
그는 기상캐스터입니다.  어,
전 세계 강우량을 연구하는 과학자입니다.  어, 그리고 그는 온 사방에

3251
01:14:31,430 --> 01:14:31,440
전 세계 강우량을 연구하는 과학자입니다.  어, 그리고 그는 온 사방에
 

3252
01:14:31,440 --> 01:14:34,470
전 세계 강우량을 연구하는 과학자입니다.  어, 그리고 그는 온 사방에
센서를 잔뜩 설치해 놨어요.

3253
01:14:34,470 --> 01:14:34,480
센서를 잔뜩 설치해 놨어요.
 

3254
01:14:34,480 --> 01:14:36,950
센서를 잔뜩 설치해 놨어요.
그리고 각각은

3255
01:14:36,950 --> 01:14:38,790
그리고 각각은
 

3256
01:14:38,790 --> 01:14:38,800

 

3257
01:14:38,800 --> 01:14:42,470

정수 세 개(R, L, T)로 이루어진 측정값을 클라우드나 다른 곳에 게시할 수 있습니다.

3258
01:14:42,470 --> 01:14:42,480
정수 세 개(R, L, T)로 이루어진 측정값을 클라우드나 다른 곳에 게시할 수 있습니다.
 

3259
01:14:42,480 --> 01:14:44,149
정수 세 개(R, L, T)로 이루어진 측정값을 클라우드나 다른 곳에 게시할 수 있습니다.
여기서 R은 양의 강우량

3260
01:14:44,149 --> 01:14:44,159
여기서 R은 양의 강우량
 

3261
01:14:44,159 --> 01:14:48,310
여기서 R은 양의 강우량
, L은 정수, T는 위도, T는

3262
01:14:48,310 --> 01:14:48,320
, L은 정수, T는 위도, T는
 

3263
01:14:48,320 --> 01:14:50,950
, L은 정수, T는 위도, T는
다시 정수입니다.   자

3264
01:14:50,950 --> 01:14:50,960
다시 정수입니다.   자
 

3265
01:14:50,960 --> 01:14:52,470
다시 정수입니다.   자
, 그럼 우리가 다뤄야 할 세 가지가 있습니다

3266
01:14:52,470 --> 01:14:52,480
, 그럼 우리가 다뤄야 할 세 가지가 있습니다
 

3267
01:14:52,480 --> 01:14:56,870
, 그럼 우리가 다뤄야 할 세 가지가 있습니다
.  왝.  좋아요.  하지만 그것들은

3268
01:14:56,870 --> 01:14:56,880
.  왝.  좋아요.  하지만 그것들은
 

3269
01:14:56,880 --> 01:14:58,790
.  왝.  좋아요.  하지만 그것들은
모두 정수입니다.  그리고 "아,

3270
01:14:58,790 --> 01:14:58,800
모두 정수입니다.  그리고 "아,
 

3271
01:14:58,800 --> 01:15:03,189
모두 정수입니다.  그리고 "아,
제이슨, 위도는 꽤 작으니까

3272
01:15:03,189 --> 01:15:03,199
제이슨, 위도는 꽤 작으니까
 

3273
01:15:03,199 --> 01:15:06,229
제이슨, 위도는 꽤 작으니까
이 정수들도 작고

3274
01:15:06,229 --> 01:15:06,239
이 정수들도 작고
 

3275
01:15:06,239 --> 01:15:08,550
이 정수들도 작고
이런 측정은 일정한 시간이 걸린다고 가정할 수 있겠지

3276
01:15:08,550 --> 01:15:08,560
이런 측정은 일정한 시간이 걸린다고 가정할 수 있겠지
 

3277
01:15:08,560 --> 01:15:10,229
이런 측정은 일정한 시간이 걸린다고 가정할 수 있겠지
?" 같은 생각은 하지 마세요. 제가

3278
01:15:10,229 --> 01:15:10,239
?" 같은 생각은 하지 마세요. 제가
 

3279
01:15:10,239 --> 01:15:12,470
?" 같은 생각은 하지 마세요. 제가
이 정수들을 측정하는 해상도를 명시한 것도 아니고,

3280
01:15:12,470 --> 01:15:14,630
이 정수들을 측정하는 해상도를 명시한 것도 아니고,
 

3281
01:15:14,630 --> 01:15:16,550

 

3282
01:15:16,550 --> 01:15:16,560

 

3283
01:15:16,560 --> 01:15:17,910

측정 횟수와 해상도 사이의 상한선을 알려준 것도 아니잖아요

3284
01:15:17,910 --> 01:15:17,920
측정 횟수와 해상도 사이의 상한선을 알려준 것도 아니잖아요
 

3285
01:15:17,920 --> 01:15:19,990
측정 횟수와 해상도 사이의 상한선을 알려준 것도 아니잖아요
. 그러니까 그런 식으로 접근하지 마세요. 알겠죠

3286
01:15:19,990 --> 01:15:20,000
. 그러니까 그런 식으로 접근하지 마세요. 알겠죠
 

3287
01:15:20,000 --> 01:15:22,709
. 그러니까 그런 식으로 접근하지 마세요. 알겠죠
? 특정 시점 이후 특정 위도에서의 최대 강우량은

3288
01:15:22,709 --> 01:15:22,719
? 특정 시점 이후 특정 위도에서의 최대 강우량은
 

3289
01:15:22,719 --> 01:15:25,030
? 특정 시점 이후 특정 위도에서의 최대 강우량은

3290
01:15:25,030 --> 01:15:28,630

 

3291
01:15:28,630 --> 01:15:28,640

 

3292
01:15:28,640 --> 01:15:31,270

해당 위도에서 그

3293
01:15:31,270 --> 01:15:31,280
해당 위도에서 그
 

3294
01:15:31,280 --> 01:15:34,070
해당 위도에서 그
시점 이상

3295
01:15:34,070 --> 01:15:34,080
시점 이상
 

3296
01:15:34,080 --> 01:15:36,470
시점 이상
또는 같은 시점에 측정된 모든 강우량 중 최대값입니다. 이해되시나요

3297
01:15:36,470 --> 01:15:36,480
또는 같은 시점에 측정된 모든 강우량 중 최대값입니다. 이해되시나요
 

3298
01:15:36,480 --> 01:15:38,709
또는 같은 시점에 측정된 모든 강우량 중 최대값입니다. 이해되시나요
?

3299
01:15:38,709 --> 01:15:38,719
?
 

3300
01:15:38,719 --> 01:15:40,790
?
해당 위도에서 측정값이 없으면 0이 되고요. 그 시점

3301
01:15:40,790 --> 01:15:40,800
해당 위도에서 측정값이 없으면 0이 되고요. 그 시점
 

3302
01:15:40,800 --> 01:15:43,189
해당 위도에서 측정값이 없으면 0이 되고요. 그 시점
이전이나 이후 등 어떤

3303
01:15:43,189 --> 01:15:43,199
이전이나 이후 등 어떤
 

3304
01:15:43,199 --> 01:15:45,669
이전이나 이후 등 어떤
시점이든 상관없습니다.

3305
01:15:45,669 --> 01:15:45,679
시점이든 상관없습니다.
 

3306
01:15:45,679 --> 01:15:48,470
시점이든 상관없습니다.
우리가 구축할 수 있는 데이터베이스를 설명해 주세요. 시간도 기록할 수 있도록요.

3307
01:15:48,470 --> 01:15:48,480
우리가 구축할 수 있는 데이터베이스를 설명해 주세요. 시간도 기록할 수 있도록요.
 

3308
01:15:48,480 --> 01:15:51,830
우리가 구축할 수 있는 데이터베이스를 설명해 주세요. 시간도 기록할 수 있도록요.
네, 비어있는 데이터베이스입니다. 지난 봄에 이 부분을 제대로 처리하지 못해서 추가했습니다

3309
01:15:51,830 --> 01:15:54,310
네, 비어있는 데이터베이스입니다. 지난 봄에 이 부분을 제대로 처리하지 못해서 추가했습니다
 

3310
01:15:54,310 --> 01:15:54,320

 

3311
01:15:54,320 --> 01:15:57,750

. 데이터를 기록할 때

3312
01:15:57,750 --> 01:15:57,760
. 데이터를 기록할 때
 

3313
01:15:57,760 --> 01:16:01,189
. 데이터를 기록할 때
세 개의 값을 제공하면, 데이터가

3314
01:16:01,189 --> 01:16:01,199
세 개의 값을 제공하면, 데이터가
 

3315
01:16:01,199 --> 01:16:03,350
세 개의 값을 제공하면, 데이터가
정확하게 기록되도록 제가

3316
01:16:03,350 --> 01:16:03,360
정확하게 기록되도록 제가
 

3317
01:16:03,360 --> 01:16:05,430
정확하게 기록되도록 제가
그 정보를 관리해야 합니다. 네, 맞습니다.

3318
01:16:05,430 --> 01:16:05,440
그 정보를 관리해야 합니다. 네, 맞습니다.
 

3319
01:16:05,440 --> 01:16:08,470
그 정보를 관리해야 합니다. 네, 맞습니다.
이런 종류의 데이터 관리를 위해서요.  업데이트 관련해서, 솔직히

3320
01:16:08,470 --> 01:16:08,480
이런 종류의 데이터 관리를 위해서요.  업데이트 관련해서, 솔직히
 

3321
01:16:08,480 --> 01:16:09,990
이런 종류의 데이터 관리를 위해서요.  업데이트 관련해서, 솔직히
이게 정확하다고 주장하기는 정말 어렵네요

3322
01:16:09,990 --> 01:16:10,000
이게 정확하다고 주장하기는 정말 어렵네요
 

3323
01:16:10,000 --> 01:16:12,709
이게 정확하다고 주장하기는 정말 어렵네요
. 그렇죠? 그냥

3324
01:16:12,709 --> 01:16:12,719
. 그렇죠? 그냥
 

3325
01:16:12,719 --> 01:16:14,229
. 그렇죠? 그냥
데이터베이스에 입력하는 거니까요.

3326
01:16:14,229 --> 01:16:14,239
데이터베이스에 입력하는 거니까요.
 

3327
01:16:14,239 --> 01:16:15,830
데이터베이스에 입력하는 거니까요.
데이터베이스가

3328
01:16:15,830 --> 01:16:15,840
데이터베이스가
 

3329
01:16:15,840 --> 01:16:19,590
데이터베이스가
제게 뭔가를 반환할 필요는 없잖아요?

3330
01:16:19,590 --> 01:16:19,600
제게 뭔가를 반환할 필요는 없잖아요?
 

3331
01:16:19,600 --> 01:16:20,950
제게 뭔가를 반환할 필요는 없잖아요?
여기서 정확성에 대한 중요한 점은

3332
01:16:20,950 --> 01:16:20,960
여기서 정확성에 대한 중요한 점은
 

3333
01:16:20,960 --> 01:16:23,590
여기서 정확성에 대한 중요한 점은
최대 강우량 함수가 제가

3334
01:16:23,590 --> 01:16:25,430
최대 강우량 함수가 제가
 

3335
01:16:25,430 --> 01:16:25,440

 

3336
01:16:25,440 --> 01:16:26,709

원하는 시간 범위 내에서 값을 제공한다는 겁니다. 최대 강우량 함수는

3337
01:16:26,709 --> 01:16:28,550
원하는 시간 범위 내에서 값을 제공한다는 겁니다. 최대 강우량 함수는
 

3338
01:16:28,550 --> 01:16:28,560

 

3339
01:16:28,560 --> 01:16:32,310

특정 위도에서 t 시점 이후의 최대 강우량을 반환합니다. 네.

3340
01:16:32,310 --> 01:16:32,320
특정 위도에서 t 시점 이후의 최대 강우량을 반환합니다. 네.
 

3341
01:16:32,320 --> 01:16:35,430
특정 위도에서 t 시점 이후의 최대 강우량을 반환합니다. 네.
세 가지가 있죠. 네. 첫째,

3342
01:16:35,430 --> 01:16:35,440
세 가지가 있죠. 네. 첫째,
 

3343
01:16:35,440 --> 01:16:37,189
세 가지가 있죠. 네. 첫째,
단일

3344
01:16:37,189 --> 01:16:37,199
단일
 

3345
01:16:37,199 --> 01:16:39,750
단일
측정값을 반환할 필요가 없다는 것은 그 측정값에 대한 기록을 저장할 필요가 없다는

3346
01:16:39,750 --> 01:16:41,270
측정값을 반환할 필요가 없다는 것은 그 측정값에 대한 기록을 저장할 필요가 없다는
 

3347
01:16:41,270 --> 01:16:41,280

 

3348
01:16:41,280 --> 01:16:43,430

뜻입니다. 둘째, 모든 정보를 저장할 필요가 없을 수도 있습니다.

3349
01:16:43,430 --> 01:16:43,440
뜻입니다. 둘째, 모든 정보를 저장할 필요가 없을 수도 있습니다.
 

3350
01:16:43,440 --> 01:16:45,750
뜻입니다. 둘째, 모든 정보를 저장할 필요가 없을 수도 있습니다.
왜냐하면 우리가

3351
01:16:45,750 --> 01:16:45,760
왜냐하면 우리가
 

3352
01:16:45,760 --> 01:16:48,870
왜냐하면 우리가
하는 일은 기본적으로 RS(강우량)만 반환하는 것이기 때문입니다.

3353
01:16:48,870 --> 01:16:48,880
하는 일은 기본적으로 RS(강우량)만 반환하는 것이기 때문입니다.
 

3354
01:16:48,880 --> 01:16:50,630
하는 일은 기본적으로 RS(강우량)만 반환하는 것이기 때문입니다.
그렇죠? 위도나

3355
01:16:50,630 --> 01:16:50,640
그렇죠? 위도나
 

3356
01:16:50,640 --> 01:16:54,070
그렇죠? 위도나
시간을 전혀 저장할 필요가 없을 수도 있습니다.

3357
01:16:54,070 --> 01:16:54,080
시간을 전혀 저장할 필요가 없을 수도 있습니다.
 

3358
01:16:54,080 --> 01:16:55,430
시간을 전혀 저장할 필요가 없을 수도 있습니다.
그렇죠? 심지어 세 가지 값(위도, 시간, 강우량)을 모두 저장할 필요도 없습니다

3359
01:16:55,430 --> 01:16:55,440
그렇죠? 심지어 세 가지 값(위도, 시간, 강우량)을 모두 저장할 필요도 없습니다
 

3360
01:16:55,440 --> 01:16:58,070
그렇죠? 심지어 세 가지 값(위도, 시간, 강우량)을 모두 저장할 필요도 없습니다
. 물론 실제로는

3361
01:16:58,070 --> 01:16:58,080
. 물론 실제로는
 

3362
01:16:58,080 --> 01:17:02,149
. 물론 실제로는
위도와 시간을 기준으로 쿼리를 하고 있으므로

3363
01:17:02,149 --> 01:17:02,159
위도와 시간을 기준으로 쿼리를 하고 있으므로
 

3364
01:17:02,159 --> 01:17:04,229
위도와 시간을 기준으로 쿼리를 하고 있으므로
어딘가에 저장해야겠지만, 아마도 그럴 수 있을 겁니다.

3365
01:17:04,229 --> 01:17:04,239
어딘가에 저장해야겠지만, 아마도 그럴 수 있을 겁니다.
 

3366
01:17:04,239 --> 01:17:06,310
어딘가에 저장해야겠지만, 아마도 그럴 수 있을 겁니다.
압축해야죠. 특히,

3367
01:17:06,310 --> 01:17:06,320
압축해야죠. 특히,
 

3368
01:17:06,320 --> 01:17:09,350
압축해야죠. 특히,
그렇죠? 같은 위도에 여러 가지 데이터가 저장될 수 있잖아요

3369
01:17:09,350 --> 01:17:09,360
그렇죠? 같은 위도에 여러 가지 데이터가 저장될 수 있잖아요
 

3370
01:17:09,360 --> 01:17:12,070
그렇죠? 같은 위도에 여러 가지 데이터가 저장될 수 있잖아요
? 그게 바로 이

3371
01:17:12,070 --> 01:17:12,080
? 그게 바로 이
 

3372
01:17:12,080 --> 01:17:14,390
? 그게 바로 이
쿼리의 핵심이에요. 그러니까

3373
01:17:14,390 --> 01:17:17,030
쿼리의 핵심이에요. 그러니까
 

3374
01:17:17,030 --> 01:17:17,040

 

3375
01:17:17,040 --> 01:17:18,470

위도는 한 번만 저장하면 될 수도 있잖아요.

3376
01:17:18,470 --> 01:17:18,480
위도는 한 번만 저장하면 될 수도 있잖아요.
 

3377
01:17:18,480 --> 01:17:21,110
위도는 한 번만 저장하면 될 수도 있잖아요.
이해되시나요? 네,

3378
01:17:21,110 --> 01:17:21,120
이해되시나요? 네,
 

3379
01:17:21,120 --> 01:17:22,630
이해되시나요? 네,
질문은 나중에 받겠습니다.

3380
01:17:22,630 --> 01:17:22,640
질문은 나중에 받겠습니다.
 

3381
01:17:22,640 --> 01:17:25,270
질문은 나중에 받겠습니다.
이 문제에 대한 해결책을 먼저 말씀드리고 싶거든요. 자

3382
01:17:25,270 --> 01:17:25,280
이 문제에 대한 해결책을 먼저 말씀드리고 싶거든요. 자
 

3383
01:17:25,280 --> 01:17:28,149
이 문제에 대한 해결책을 먼저 말씀드리고 싶거든요. 자
, 그럼 어떻게 해야 할까요?

3384
01:17:28,149 --> 01:17:28,159
, 그럼 어떻게 해야 할까요?
 

3385
01:17:28,159 --> 01:17:30,310
, 그럼 어떻게 해야 할까요?
데이터를 추가하고 결과를

3386
01:17:30,310 --> 01:17:30,320
데이터를 추가하고 결과를
 

3387
01:17:30,320 --> 01:17:32,390
데이터를 추가하고 결과를
반환해야 합니다. 그러니까 쿼리를 실행하고 결과를 반환해야겠죠? 예를 들어,

3388
01:17:32,390 --> 01:17:34,709
반환해야 합니다. 그러니까 쿼리를 실행하고 결과를 반환해야겠죠? 예를 들어,
 

3389
01:17:34,709 --> 01:17:35,990

 

3390
01:17:35,990 --> 01:17:38,709

 

3391
01:17:38,709 --> 01:17:38,719

 

3392
01:17:38,719 --> 01:17:41,030

시간 t 이후 위도 L에서의 최대 강우량을 반환하는 쿼리를 실행해야 합니다.

3393
01:17:41,030 --> 01:17:41,040
시간 t 이후 위도 L에서의 최대 강우량을 반환하는 쿼리를 실행해야 합니다.
 

3394
01:17:41,040 --> 01:17:42,390
시간 t 이후 위도 L에서의 최대 강우량을 반환하는 쿼리를 실행해야 합니다.
특정 쿼리에서 제가 중요하게 생각하는 것은 무엇일까요

3395
01:17:42,390 --> 01:17:42,400
특정 쿼리에서 제가 중요하게 생각하는 것은 무엇일까요
 

3396
01:17:42,400 --> 01:17:45,030
특정 쿼리에서 제가 중요하게 생각하는 것은 무엇일까요
? 저는 위도 L에 있는 모든 데이터에만 관심이 있습니다. 위도 L에서의 데이터 말이죠.

3397
01:17:45,030 --> 01:17:49,270
? 저는 위도 L에 있는 모든 데이터에만 관심이 있습니다. 위도 L에서의 데이터 말이죠.
 

3398
01:17:49,270 --> 01:17:49,280

 

3399
01:17:49,280 --> 01:17:52,390

사실 이건 그렇게 흥미로운

3400
01:17:52,390 --> 01:17:52,400
사실 이건 그렇게 흥미로운
 

3401
01:17:52,400 --> 01:17:54,310
사실 이건 그렇게 흥미로운
내용은 아니지만,

3402
01:17:54,310 --> 01:17:55,910
내용은 아니지만,
 

3403
01:17:55,910 --> 01:17:55,920

 

3404
01:17:55,920 --> 01:17:57,990

각 위도 L에 연결된 여러 데이터 구조를 만들고 싶습니다.

3405
01:17:57,990 --> 01:17:58,000
각 위도 L에 연결된 여러 데이터 구조를 만들고 싶습니다.
 

3406
01:17:58,000 --> 01:18:01,590
각 위도 L에 연결된 여러 데이터 구조를 만들고 싶습니다.
이해되시나요? 네. 그리고 각 위도 L에서 해당 데이터를 어떻게 빠르게 찾을 수 있을까요

3407
01:18:01,590 --> 01:18:01,600
이해되시나요? 네. 그리고 각 위도 L에서 해당 데이터를 어떻게 빠르게 찾을 수 있을까요
 

3408
01:18:01,600 --> 01:18:05,189
이해되시나요? 네. 그리고 각 위도 L에서 해당 데이터를 어떻게 빠르게 찾을 수 있을까요
?

3409
01:18:05,189 --> 01:18:05,199
?
 

3410
01:18:05,199 --> 01:18:06,870
?
딕셔너리에 저장하면 되겠네요. 제 시간은 얼마나 걸릴까요?

3411
01:18:06,870 --> 01:18:06,880
딕셔너리에 저장하면 되겠네요. 제 시간은 얼마나 걸릴까요?
 

3412
01:18:06,880 --> 01:18:09,030
딕셔너리에 저장하면 되겠네요. 제 시간은 얼마나 걸릴까요?
경계? 최악의 경우 log N이죠. 그렇죠? 그럼

3413
01:18:09,030 --> 01:18:09,040
경계? 최악의 경우 log N이죠. 그렇죠? 그럼
 

3414
01:18:09,040 --> 01:18:10,310
경계? 최악의 경우 log N이죠. 그렇죠? 그럼
제가 그 집합 데이터 구조에 어떤 데이터 구조를 사용했죠

3415
01:18:10,310 --> 01:18:10,320
제가 그 집합 데이터 구조에 어떤 데이터 구조를 사용했죠
 

3416
01:18:10,320 --> 01:18:13,510
제가 그 집합 데이터 구조에 어떤 데이터 구조를 사용했죠
? 집합 AVL이요. 그렇죠?

3417
01:18:13,510 --> 01:18:13,520
? 집합 AVL이요. 그렇죠?
 

3418
01:18:13,520 --> 01:18:20,070
? 집합 AVL이요. 그렇죠?
먼저 위도를 매핑하는 집합 AVL, 예를 들어

3419
01:18:20,070 --> 01:18:20,080

 

3420
01:18:20,080 --> 01:18:25,030

L이라고 해볼게요.

3421
01:18:25,030 --> 01:18:29,910
L이라고 해볼게요.
 

3422
01:18:29,910 --> 01:18:29,920

 

3423
01:18:29,920 --> 01:18:33,590


3424
01:18:33,590 --> 01:18:33,600

 

3425
01:18:33,600 --> 01:18:35,189


3426
01:18:35,189 --> 01:18:35,199

 

3427
01:18:35,199 --> 01:18:36,790

이제 데이터 구조가 더 필요하죠.

3428
01:18:36,790 --> 01:18:38,149
이제 데이터 구조가 더 필요하죠.
 

3429
01:18:38,149 --> 01:18:38,159

 

3430
01:18:38,159 --> 01:18:39,990

같은 위도를 가진 여러 항목들을

3431
01:18:39,990 --> 01:18:40,000
같은 위도를 가진 여러 항목들을
 

3432
01:18:40,000 --> 01:18:42,550
같은 위도를 가진 여러 항목들을
다른 데이터 구조에 저장하고 싶어요. 아마도

3433
01:18:42,550 --> 01:18:42,560
다른 데이터 구조에 저장하고 싶어요. 아마도
 

3434
01:18:42,560 --> 01:18:44,310
다른 데이터 구조에 저장하고 싶어요. 아마도

3435
01:18:44,310 --> 01:18:45,990

 

3436
01:18:45,990 --> 01:18:46,000

 

3437
01:18:46,000 --> 01:18:48,790

모든 측정값의 시간과 강우량을 저장하는 거겠죠. 네.

3438
01:18:48,790 --> 01:18:48,800
모든 측정값의 시간과 강우량을 저장하는 거겠죠. 네.
 

3439
01:18:48,800 --> 01:18:51,910
모든 측정값의 시간과 강우량을 저장하는 거겠죠. 네.
네, 해시 테이블이요. 해시 테이블이요.

3440
01:18:51,910 --> 01:18:51,920
네, 해시 테이블이요. 해시 테이블이요.
 

3441
01:18:51,920 --> 01:18:53,830
네, 해시 테이블이요. 해시 테이블이요.
좋아요. 그럼

3442
01:18:53,830 --> 01:18:53,840
좋아요. 그럼
 

3443
01:18:53,840 --> 01:18:55,910
좋아요. 그럼
같은 위도에 있는 항목들에 대해 어떤 쿼리를 하고 싶을까요

3444
01:18:55,910 --> 01:18:55,920
같은 위도에 있는 항목들에 대해 어떤 쿼리를 하고 싶을까요
 

3445
01:18:55,920 --> 01:18:57,830
같은 위도에 있는 항목들에 대해 어떤 쿼리를 하고 싶을까요
?

3446
01:18:57,830 --> 01:18:57,840
?
 

3447
01:18:57,840 --> 01:18:59,830
?
시간을 가져오고 싶을 거예요.

3448
01:18:59,830 --> 01:18:59,840
시간을 가져오고 싶을 거예요.
 

3449
01:18:59,840 --> 01:19:02,149
시간을 가져오고 싶을 거예요.
시간을 가져오고 싶지만, 그보다 더 중요한 건

3450
01:19:02,149 --> 01:19:02,159
시간을 가져오고 싶지만, 그보다 더 중요한 건
 

3451
01:19:02,159 --> 01:19:04,630
시간을 가져오고 싶지만, 그보다 더 중요한 건
정렬된 쿼리를 해야 한다는 거죠.

3452
01:19:04,630 --> 01:19:04,640
정렬된 쿼리를 해야 한다는 거죠.
 

3453
01:19:04,640 --> 01:19:05,990
정렬된 쿼리를 해야 한다는 거죠.
특정 시간보다 짧은 항목들이 필요해요. 특정 시간보다 긴 항목들도 필요하고요.

3454
01:19:05,990 --> 01:19:08,390
특정 시간보다 짧은 항목들이 필요해요. 특정 시간보다 긴 항목들도 필요하고요.
 

3455
01:19:08,390 --> 01:19:08,400

 

3456
01:19:08,400 --> 01:19:11,270

게다가 시간 간격도 초 단위여야 하죠.

3457
01:19:11,270 --> 01:19:11,280
게다가 시간 간격도 초 단위여야 하죠.
 

3458
01:19:11,280 --> 01:19:13,270
게다가 시간 간격도 초 단위여야 하죠.
시간을 위한 AVL

3459
01:19:13,270 --> 01:19:13,280
시간을 위한 AVL
 

3460
01:19:13,280 --> 01:19:16,229
시간을 위한 AVL
과 강우량을 위한 AVL을 각각 만들어야 해요. 좋아요.

3461
01:19:16,229 --> 01:19:16,239
과 강우량을 위한 AVL을 각각 만들어야 해요. 좋아요.
 

3462
01:19:16,239 --> 01:19:18,709
과 강우량을 위한 AVL을 각각 만들어야 해요. 좋아요.
강우량에 대한 AVL이 필요할까요? 제가

3463
01:19:18,709 --> 01:19:18,719
강우량에 대한 AVL이 필요할까요? 제가
 

3464
01:19:18,719 --> 01:19:22,470
강우량에 대한 AVL이 필요할까요? 제가
찾고 있는 걸까요?  강우량에 대해서 말씀하시는 건가요?

3465
01:19:22,470 --> 01:19:22,480
찾고 있는 걸까요?  강우량에 대해서 말씀하시는 건가요?
 

3466
01:19:22,480 --> 01:19:24,950
찾고 있는 걸까요?  강우량에 대해서 말씀하시는 건가요?
아니요. 네. 그럼,

3467
01:19:24,950 --> 01:19:24,960
아니요. 네. 그럼,
 

3468
01:19:24,960 --> 01:19:28,310
아니요. 네. 그럼,
이 값들을 시간 순서대로 정렬된 AVL에 저장하겠습니다. 위도

3469
01:19:28,310 --> 01:19:31,430
이 값들을 시간 순서대로 정렬된 AVL에 저장하겠습니다. 위도
 

3470
01:19:31,430 --> 01:19:35,590

 

3471
01:19:35,590 --> 01:19:35,600

 

3472
01:19:35,600 --> 01:19:38,870

L을

3473
01:19:38,870 --> 01:19:38,880
L을
 

3474
01:19:38,880 --> 01:19:40,550
L을
시간 데이터 구조라고 부르겠습니다.

3475
01:19:40,550 --> 01:19:40,560
시간 데이터 구조라고 부르겠습니다.
 

3476
01:19:40,560 --> 01:19:43,830
시간 데이터 구조라고 부르겠습니다.
T/L이라고 하겠습니다. 음

3477
01:19:43,830 --> 01:19:43,840
T/L이라고 하겠습니다. 음
 

3478
01:19:43,840 --> 01:19:45,110
T/L이라고 하겠습니다. 음
, 약간 재귀대명사처럼 보이네요.

3479
01:19:45,110 --> 01:19:45,120
, 약간 재귀대명사처럼 보이네요.
 

3480
01:19:45,120 --> 01:19:46,550
, 약간 재귀대명사처럼 보이네요.
지금 좀 거슬리지만, 더

3481
01:19:46,550 --> 01:19:46,560
지금 좀 거슬리지만, 더
 

3482
01:19:46,560 --> 01:19:47,750
지금 좀 거슬리지만, 더
나은 방법이 없네요. 좋습니다.

3483
01:19:47,750 --> 01:19:47,760
나은 방법이 없네요. 좋습니다.
 

3484
01:19:47,760 --> 01:19:50,310
나은 방법이 없네요. 좋습니다.
이제 각 시간 데이터

3485
01:19:50,310 --> 01:19:50,320
이제 각 시간 데이터
 

3486
01:19:50,320 --> 01:19:53,270
이제 각 시간 데이터
구조는

3487
01:19:53,270 --> 01:19:58,470
구조는
 

3488
01:19:58,470 --> 01:19:58,480

 

3489
01:19:58,480 --> 01:20:01,669


3490
01:20:01,669 --> 01:20:01,679

 

3491
01:20:01,679 --> 01:20:03,510

시간을

3492
01:20:03,510 --> 01:20:03,520
시간을
 

3493
01:20:03,520 --> 01:20:06,310
시간을
강우량

3494
01:20:06,310 --> 01:20:06,320
강우량
 

3495
01:20:06,320 --> 01:20:09,030
강우량
측정값에 매핑하는 AVL 집합이 됩니다. 그렇죠?

3496
01:20:09,030 --> 01:20:09,040
측정값에 매핑하는 AVL 집합이 됩니다. 그렇죠?
 

3497
01:20:09,040 --> 01:20:10,229
측정값에 매핑하는 AVL 집합이 됩니다. 그렇죠?
좋습니다.

3498
01:20:10,229 --> 01:20:10,239
좋습니다.
 

3499
01:20:10,239 --> 01:20:12,870
좋습니다.
따라서 제 쿼리가

3500
01:20:12,870 --> 01:20:12,880
따라서 제 쿼리가
 

3501
01:20:12,880 --> 01:20:16,550
따라서 제 쿼리가
최대 강우량을 반환하는 것이라면, 아니,

3502
01:20:16,550 --> 01:20:18,550
최대 강우량을 반환하는 것이라면, 아니,
 

3503
01:20:18,550 --> 01:20:18,560

 

3504
01:20:18,560 --> 01:20:22,790

위도 L, 시간 T에 해당하는 강우량을 반환하는 것이라면,

3505
01:20:22,790 --> 01:20:24,870
위도 L, 시간 T에 해당하는 강우량을 반환하는 것이라면,
 

3506
01:20:24,870 --> 01:20:24,880

 

3507
01:20:24,880 --> 01:20:27,510

이 쿼리를 처리하는 방법은 아시겠죠? 데이터를

3508
01:20:27,510 --> 01:20:27,520
이 쿼리를 처리하는 방법은 아시겠죠? 데이터를
 

3509
01:20:27,520 --> 01:20:29,510
이 쿼리를 처리하는 방법은 아시겠죠? 데이터를
삽입하려면

3510
01:20:29,510 --> 01:20:29,520
삽입하려면
 

3511
01:20:29,520 --> 01:20:31,590
삽입하려면
두 데이터 구조 모두에 삽입하고, 조회하면 됩니다.

3512
01:20:31,590 --> 01:20:31,600
두 데이터 구조 모두에 삽입하고, 조회하면 됩니다.
 

3513
01:20:31,600 --> 01:20:34,470
두 데이터 구조 모두에 삽입하고, 조회하면 됩니다.
여기서 한 가지 복잡한 점은

3514
01:20:34,470 --> 01:20:34,480
여기서 한 가지 복잡한 점은
 

3515
01:20:34,480 --> 01:20:38,070
여기서 한 가지 복잡한 점은
제가 특정 시점의 강우량을 묻는 것이 아니라는 것입니다

3516
01:20:38,070 --> 01:20:38,080
제가 특정 시점의 강우량을 묻는 것이 아니라는 것입니다
 

3517
01:20:38,080 --> 01:20:40,550
제가 특정 시점의 강우량을 묻는 것이 아니라는 것입니다
. 저는 현재 시점의 강우량을 알고 싶습니다.

3518
01:20:40,550 --> 01:20:40,560
. 저는 현재 시점의 강우량을 알고 싶습니다.
 

3519
01:20:40,560 --> 01:20:44,229
. 저는 현재 시점의 강우량을 알고 싶습니다.
최대 강우량이 현재까지 얼마인지

3520
01:20:44,229 --> 01:20:47,350
최대 강우량이 현재까지 얼마인지
 

3521
01:20:47,350 --> 01:20:47,360

 

3522
01:20:47,360 --> 01:20:49,750

알고 싶습니다. 전역 최대값을 알고 싶다면 맥스 힙이 좋겠죠? 하지만 여기서는 특정 범위

3523
01:20:49,750 --> 01:20:49,760
알고 싶습니다. 전역 최대값을 알고 싶다면 맥스 힙이 좋겠죠? 하지만 여기서는 특정 범위
 

3524
01:20:49,760 --> 01:20:52,229
알고 싶습니다. 전역 최대값을 알고 싶다면 맥스 힙이 좋겠죠? 하지만 여기서는 특정 범위
내의 최대값을 알고 싶습니다

3525
01:20:52,229 --> 01:20:52,239
내의 최대값을 알고 싶습니다
 

3526
01:20:52,239 --> 01:20:56,229
내의 최대값을 알고 싶습니다
. 좋습니다. 이제

3527
01:20:56,229 --> 01:20:56,239
. 좋습니다. 이제
 

3528
01:20:56,239 --> 01:20:57,830
. 좋습니다. 이제
질문을 받겠습니다. 시간이

3529
01:20:57,830 --> 01:20:57,840
질문을 받겠습니다. 시간이
 

3530
01:20:57,840 --> 01:20:59,750
질문을 받겠습니다. 시간이
조금 부족하네요.

3531
01:20:59,750 --> 01:20:59,760
조금 부족하네요.
 

3532
01:20:59,760 --> 01:21:03,750
조금 부족하네요.
자, 어떻게 하면 좋을지 아이디어 있으신 분 계신가요?

3533
01:21:03,750 --> 01:21:03,760
자, 어떻게 하면 좋을지 아이디어 있으신 분 계신가요?
 

3534
01:21:03,760 --> 01:21:06,470
자, 어떻게 하면 좋을지 아이디어 있으신 분 계신가요?
네.

3535
01:21:06,470 --> 01:21:06,480
네.
 

3536
01:21:06,480 --> 01:21:08,310
네.
최대값을 추가하면 됩니다.

3537
01:21:08,310 --> 01:21:08,320
최대값을 추가하면 됩니다.
 

3538
01:21:08,320 --> 01:21:10,070
최대값을 추가하면 됩니다.
오른쪽 자식 노드를 보고 그 노드의 최대값을 확인하면 됩니다

3539
01:21:10,070 --> 01:21:10,080
오른쪽 자식 노드를 보고 그 노드의 최대값을 확인하면 됩니다
 

3540
01:21:10,080 --> 01:21:12,310
오른쪽 자식 노드를 보고 그 노드의 최대값을 확인하면 됩니다
. 아, 알겠습니다. 동료분

3541
01:21:12,310 --> 01:21:12,320
. 아, 알겠습니다. 동료분
 

3542
01:21:12,320 --> 01:21:15,830
. 아, 알겠습니다. 동료분
말씀대로, 서브리에서 최대값 R을 추가하면

3543
01:21:15,830 --> 01:21:18,229
말씀대로, 서브리에서 최대값 R을 추가하면
 

3544
01:21:18,229 --> 01:21:18,239

 

3545
01:21:18,239 --> 01:21:20,870

이

3546
01:21:20,870 --> 01:21:20,880
이
 

3547
01:21:20,880 --> 01:21:22,950
이
쿼리를 해결할 수 있다는 말씀이시죠? 시간 T를 기준으로 정렬되어 있으니까,

3548
01:21:22,950 --> 01:21:25,669
쿼리를 해결할 수 있다는 말씀이시죠? 시간 T를 기준으로 정렬되어 있으니까,
 

3549
01:21:25,669 --> 01:21:28,709

 

3550
01:21:28,709 --> 01:21:28,719

 

3551
01:21:28,719 --> 01:21:33,030

쿼리에 포함될 모든 항목, 즉

3552
01:21:33,030 --> 01:21:33,040
쿼리에 포함될 모든 항목, 즉
 

3553
01:21:33,040 --> 01:21:36,229
쿼리에 포함될 모든 항목, 즉
특정 시간 T 오른쪽에 있는 모든 항목이 동일한 값을 가지는 단조로운 속성이 있다는 거죠.

3554
01:21:36,229 --> 01:21:40,870
특정 시간 T 오른쪽에 있는 모든 항목이 동일한 값을 가지는 단조로운 속성이 있다는 거죠.
 

3555
01:21:40,870 --> 01:21:40,880

 

3556
01:21:40,880 --> 01:21:42,630

특정 노드에서 시간이 T보다 크면,

3557
01:21:42,630 --> 01:21:42,640
특정 노드에서 시간이 T보다 크면,
 

3558
01:21:42,640 --> 01:21:45,669
특정 노드에서 시간이 T보다 크면,
오른쪽 서브리의 모든 항목도 T보다 크다는 거죠.

3559
01:21:45,669 --> 01:21:48,630
오른쪽 서브리의 모든 항목도 T보다 크다는 거죠.
 

3560
01:21:48,630 --> 01:21:48,640

 

3561
01:21:48,640 --> 01:21:49,830

데이터 구조의 순서 때문에요.  맞죠?

3562
01:21:49,830 --> 01:21:49,840
데이터 구조의 순서 때문에요.  맞죠?
 

3563
01:21:49,840 --> 01:21:52,629
데이터 구조의 순서 때문에요.  맞죠?
시간 순서대로 정렬되어 있으니까요. 그래서

3564
01:21:52,629 --> 01:21:54,550
시간 순서대로 정렬되어 있으니까요. 그래서
 

3565
01:21:54,550 --> 01:21:54,560

 

3566
01:21:54,560 --> 01:21:57,830

오른쪽 서브트리를 보면, 그 서브트리

3567
01:21:57,830 --> 01:21:57,840
오른쪽 서브트리를 보면, 그 서브트리
 

3568
01:21:57,840 --> 01:22:01,110
오른쪽 서브트리를 보면, 그 서브트리
에서 최댓값만 보고 모든 작업을 처리할 수 없을 가능성이 있습니다

3569
01:22:01,110 --> 01:22:01,120
에서 최댓값만 보고 모든 작업을 처리할 수 없을 가능성이 있습니다
 

3570
01:22:01,120 --> 01:22:03,430
에서 최댓값만 보고 모든 작업을 처리할 수 없을 가능성이 있습니다
. 그렇죠? 그래서

3571
01:22:03,430 --> 01:22:08,470
. 그렇죠? 그래서
 

3572
01:22:08,470 --> 01:22:08,480

 

3573
01:22:08,480 --> 01:22:10,070


3574
01:22:10,070 --> 01:22:10,080

 

3575
01:22:10,080 --> 01:22:12,550

서브트리

3576
01:22:12,550 --> 01:22:12,560
서브트리
 

3577
01:22:12,560 --> 01:22:15,910
서브트리
최댓값 r을 추가한 아이디어가 나온 겁니다. 네, 아마

3578
01:22:15,910 --> 01:22:15,920
최댓값 r을 추가한 아이디어가 나온 겁니다. 네, 아마
 

3579
01:22:15,920 --> 01:22:19,830
최댓값 r을 추가한 아이디어가 나온 겁니다. 네, 아마
이름도 붙여야겠죠? 예를 들어 v

3580
01:22:19,830 --> 01:22:19,840
이름도 붙여야겠죠? 예를 들어 v
 

3581
01:22:19,840 --> 01:22:21,910
이름도 붙여야겠죠? 예를 들어 v
max처럼요.

3582
01:22:21,910 --> 01:22:21,920
max처럼요.
 

3583
01:22:21,920 --> 01:22:24,310
max처럼요.
여기서 V는 서브트리에 있는 노드입니다.

3584
01:22:24,310 --> 01:22:24,320
여기서 V는 서브트리에 있는 노드입니다.
 

3585
01:22:24,320 --> 01:22:26,870
여기서 V는 서브트리에 있는 노드입니다.
그리고 이걸 어떻게 지원하는지, 자식 노드들을 이용해서 어떻게 계산하는지 보여주고 싶습니다

3586
01:22:26,870 --> 01:22:28,870
그리고 이걸 어떻게 지원하는지, 자식 노드들을 이용해서 어떻게 계산하는지 보여주고 싶습니다
 

3587
01:22:28,870 --> 01:22:28,880

 

3588
01:22:28,880 --> 01:22:30,870

.

3589
01:22:30,870 --> 01:22:30,880
.
 

3590
01:22:30,880 --> 01:22:34,149
.
이 쿼리를 어떻게 지원할까요?

3591
01:22:34,149 --> 01:22:34,159
이 쿼리를 어떻게 지원할까요?
 

3592
01:22:34,159 --> 01:22:37,910
이 쿼리를 어떻게 지원할까요?
재귀적으로 생각해 볼 수 있겠죠.

3593
01:22:37,910 --> 01:22:37,920
재귀적으로 생각해 볼 수 있겠죠.
 

3594
01:22:37,920 --> 01:22:42,149
재귀적으로 생각해 볼 수 있겠죠.
몇 가지 경우가 있습니다. 여기에 V를 추가하면,

3595
01:22:42,149 --> 01:22:44,470
몇 가지 경우가 있습니다. 여기에 V를 추가하면,
 

3596
01:22:44,470 --> 01:22:48,070

 

3597
01:22:48,070 --> 01:22:48,080

 

3598
01:22:48,080 --> 01:22:51,430

주어진 노드의 최대 강우량을 나타내는 재귀 함수를 정의하고 싶습니다. 하한은

3599
01:22:51,430 --> 01:22:51,440
주어진 노드의 최대 강우량을 나타내는 재귀 함수를 정의하고 싶습니다. 하한은
 

3600
01:22:51,440 --> 01:22:55,910
주어진 노드의 최대 강우량을 나타내는 재귀 함수를 정의하고 싶습니다. 하한은
t입니다. 네.

3601
01:22:55,910 --> 01:22:55,920
t입니다. 네.
 

3602
01:22:55,920 --> 01:22:58,470
t입니다. 네.
여기 두 가지 경우가 있습니다.

3603
01:22:58,470 --> 01:22:58,480
여기 두 가지 경우가 있습니다.
 

3604
01:22:58,480 --> 01:23:02,790
여기 두 가지 경우가 있습니다.
t가

3605
01:23:02,790 --> 01:23:02,800
t가
 

3606
01:23:02,800 --> 01:23:05,990
t가
범위 안에 있거나 범위를 벗어나는 경우입니다. 범위를

3607
01:23:05,990 --> 01:23:06,000
범위 안에 있거나 범위를 벗어나는 경우입니다. 범위를
 

3608
01:23:06,000 --> 01:23:07,990
범위 안에 있거나 범위를 벗어나는 경우입니다. 범위를
벗어나면...  범위 내에 있을 때, 어떻게 해야 할까요

3609
01:23:07,990 --> 01:23:08,000
벗어나면...  범위 내에 있을 때, 어떻게 해야 할까요
 

3610
01:23:08,000 --> 01:23:09,990
벗어나면...  범위 내에 있을 때, 어떻게 해야 할까요
? 그렇죠? 시간 제한보다 낮습니다

3611
01:23:09,990 --> 01:23:10,000
? 그렇죠? 시간 제한보다 낮습니다
 

3612
01:23:10,000 --> 01:23:12,070
? 그렇죠? 시간 제한보다 낮습니다
.

3613
01:23:12,070 --> 01:23:13,990
.
 

3614
01:23:13,990 --> 01:23:14,000

 

3615
01:23:14,000 --> 01:23:16,470

이 노드에서 이 함수를 재귀적으로 호출하면 되죠. 제가

3616
01:23:16,470 --> 01:23:18,470
이 노드에서 이 함수를 재귀적으로 호출하면 되죠. 제가
 

3617
01:23:18,470 --> 01:23:20,629

 

3618
01:23:20,629 --> 01:23:20,639

 

3619
01:23:20,639 --> 01:23:23,350

중요하게 생각하는 모든 것은 이 아래에 있을 테니까요.

3620
01:23:23,350 --> 01:23:23,360
중요하게 생각하는 모든 것은 이 아래에 있을 테니까요.
 

3621
01:23:23,360 --> 01:23:25,189
중요하게 생각하는 모든 것은 이 아래에 있을 테니까요.
그리고 이건 트리를 따라 한 번만 재귀적으로 호출하는 겁니다.

3622
01:23:25,189 --> 01:23:25,199
그리고 이건 트리를 따라 한 번만 재귀적으로 호출하는 겁니다.
 

3623
01:23:25,199 --> 01:23:27,830
그리고 이건 트리를 따라 한 번만 재귀적으로 호출하는 겁니다.
만약 트리를 따라

3624
01:23:27,830 --> 01:23:27,840
만약 트리를 따라
 

3625
01:23:27,840 --> 01:23:29,590
만약 트리를 따라
한 번만 재귀적으로 호출한다면

3626
01:23:29,590 --> 01:23:29,600
한 번만 재귀적으로 호출한다면
 

3627
01:23:29,600 --> 01:23:32,470
한 번만 재귀적으로 호출한다면
, 매번 아래로 내려가게 되죠. 그러면

3628
01:23:32,470 --> 01:23:32,480
, 매번 아래로 내려가게 되죠. 그러면
 

3629
01:23:32,480 --> 01:23:34,229
, 매번 아래로 내려가게 되죠. 그러면
로그 시간 복잡도가 될 겁니다.

3630
01:23:34,229 --> 01:23:34,239
로그 시간 복잡도가 될 겁니다.
 

3631
01:23:34,239 --> 01:23:35,830
로그 시간 복잡도가 될 겁니다.
그렇죠? 자, 이게 첫 번째 경우입니다.

3632
01:23:35,830 --> 01:23:35,840
그렇죠? 자, 이게 첫 번째 경우입니다.
 

3633
01:23:35,840 --> 01:23:37,990
그렇죠? 자, 이게 첫 번째 경우입니다.
쉬운 경우죠. 이 노드는

3634
01:23:37,990 --> 01:23:38,000
쉬운 경우죠. 이 노드는
 

3635
01:23:38,000 --> 01:23:40,709
쉬운 경우죠. 이 노드는
범위 내에 있지 않습니다. 오른쪽 노드를 재귀적으로 호출하면 됩니다

3636
01:23:40,709 --> 01:23:40,719
범위 내에 있지 않습니다. 오른쪽 노드를 재귀적으로 호출하면 됩니다
 

3637
01:23:40,719 --> 01:23:42,550
범위 내에 있지 않습니다. 오른쪽 노드를 재귀적으로 호출하면 됩니다
. 다른

3638
01:23:42,550 --> 01:23:42,560
. 다른
 

3639
01:23:42,560 --> 01:23:46,390
. 다른
경우는 어떨까요? 범위 내에 있는 경우죠?

3640
01:23:46,390 --> 01:23:46,400
경우는 어떨까요? 범위 내에 있는 경우죠?
 

3641
01:23:46,400 --> 01:23:48,310
경우는 어떨까요? 범위 내에 있는 경우죠?
이제 양쪽 노드를 모두 재귀적으로 호출할 수 있겠죠.

3642
01:23:48,310 --> 01:23:48,320
이제 양쪽 노드를 모두 재귀적으로 호출할 수 있겠죠.
 

3643
01:23:48,320 --> 01:23:51,590
이제 양쪽 노드를 모두 재귀적으로 호출할 수 있겠죠.
왜냐하면

3644
01:23:51,590 --> 01:23:51,600
왜냐하면
 

3645
01:23:51,600 --> 01:23:53,669
왜냐하면
이 피크가 말하는 게 바로 그거니까요.

3646
01:23:53,669 --> 01:23:53,679
이 피크가 말하는 게 바로 그거니까요.
 

3647
01:23:53,679 --> 01:23:55,750
이 피크가 말하는 게 바로 그거니까요.
최대 강우량은 얼마일까요? 하지만

3648
01:23:55,750 --> 01:23:55,760
최대 강우량은 얼마일까요? 하지만
 

3649
01:23:55,760 --> 01:23:57,830
최대 강우량은 얼마일까요? 하지만
이렇게 하면, 여기서도 재귀적으로 호출하고

3650
01:23:57,830 --> 01:23:57,840
이렇게 하면, 여기서도 재귀적으로 호출하고
 

3651
01:23:57,840 --> 01:23:59,750
이렇게 하면, 여기서도 재귀적으로 호출하고
저기서도 재귀적으로 호출하면

3652
01:23:59,750 --> 01:23:59,760
저기서도 재귀적으로 호출하면
 

3653
01:23:59,760 --> 01:24:01,350
저기서도 재귀적으로 호출하면
선형 시간 복잡도가 될 수 있습니다.

3654
01:24:01,350 --> 01:24:01,360
선형 시간 복잡도가 될 수 있습니다.
 

3655
01:24:01,360 --> 01:24:04,390
선형 시간 복잡도가 될 수 있습니다.
트리의 모든 노드를 건드릴 수도 있죠. 그래서 제가 왜

3656
01:24:04,390 --> 01:24:04,400
트리의 모든 노드를 건드릴 수도 있죠. 그래서 제가 왜
 

3657
01:24:04,400 --> 01:24:05,830
트리의 모든 노드를 건드릴 수도 있죠. 그래서 제가 왜
이런 확장을 했을까요? 바로 이 때문입니다.  그래서 저는

3658
01:24:05,830 --> 01:24:05,840
이런 확장을 했을까요? 바로 이 때문입니다.  그래서 저는
 

3659
01:24:05,840 --> 01:24:08,550
이런 확장을 했을까요? 바로 이 때문입니다.  그래서 저는
이 노드에서 작업을 할 필요가 없습니다.

3660
01:24:08,550 --> 01:24:08,560
이 노드에서 작업을 할 필요가 없습니다.
 

3661
01:24:08,560 --> 01:24:11,990
이 노드에서 작업을 할 필요가 없습니다.
이 서브트리에서 최대 강우량을 반환하기만 하면 됩니다.

3662
01:24:11,990 --> 01:24:12,000
이 서브트리에서 최대 강우량을 반환하기만 하면 됩니다.
 

3663
01:24:12,000 --> 01:24:15,189
이 서브트리에서 최대 강우량을 반환하기만 하면 됩니다.
그렇죠? 그리고 이쪽에서 재귀 호출을 합니다. 따라서

3664
01:24:15,189 --> 01:24:15,199
그렇죠? 그리고 이쪽에서 재귀 호출을 합니다. 따라서
 

3665
01:24:15,199 --> 01:24:18,310
그렇죠? 그리고 이쪽에서 재귀 호출을 합니다. 따라서
이쪽에서는 일정한 작업을 수행합니다.

3666
01:24:18,310 --> 01:24:18,320
이쪽에서는 일정한 작업을 수행합니다.
 

3667
01:24:18,320 --> 01:24:20,070
이쪽에서는 일정한 작업을 수행합니다.
여기서는 한 번의 재귀 호출만 하는데, 이 호출은 트리의 맨

3668
01:24:20,070 --> 01:24:20,080
여기서는 한 번의 재귀 호출만 하는데, 이 호출은 트리의 맨
 

3669
01:24:20,080 --> 01:24:22,070
여기서는 한 번의 재귀 호출만 하는데, 이 호출은 트리의 맨
아래까지 갈 수 있습니다. 괜찮습니다.

3670
01:24:22,070 --> 01:24:23,750
아래까지 갈 수 있습니다. 괜찮습니다.
 

3671
01:24:23,750 --> 01:24:23,760

 

3672
01:24:23,760 --> 01:24:26,149

트리의 맨 아래까지 가도 됩니다. 이해되시나요? 그리고 만약 두 서브트리 중 어느 하나라도

3673
01:24:26,149 --> 01:24:26,159
트리의 맨 아래까지 가도 됩니다. 이해되시나요? 그리고 만약 두 서브트리 중 어느 하나라도
 

3674
01:24:26,159 --> 01:24:29,430
트리의 맨 아래까지 가도 됩니다. 이해되시나요? 그리고 만약 두 서브트리 중 어느 하나라도
없으면 작업이 완료됩니다.

3675
01:24:29,430 --> 01:24:32,310
없으면 작업이 완료됩니다.
 

3676
01:24:32,310 --> 01:24:34,149

 

3677
01:24:34,149 --> 01:24:34,159

 

3678
01:24:34,159 --> 01:24:39,270

그렇죠? 만약 재귀 호출을 해야 할 노드가 없다면, 이 서브트리에서 최댓값을 직접 가져오고,

3679
01:24:39,270 --> 01:24:42,550
그렇죠? 만약 재귀 호출을 해야 할 노드가 없다면, 이 서브트리에서 최댓값을 직접 가져오고,
 

3680
01:24:42,550 --> 01:24:42,560

 

3681
01:24:42,560 --> 01:24:44,790

여기서 재귀 호출의 반환 값을 가져와서

3682
01:24:44,790 --> 01:24:44,800
여기서 재귀 호출의 반환 값을 가져와서
 

3683
01:24:44,800 --> 01:24:47,270
여기서 재귀 호출의 반환 값을 가져와서
세 값을 비교하고 최댓값을 반환합니다.

3684
01:24:47,270 --> 01:24:47,280
세 값을 비교하고 최댓값을 반환합니다.
 

3685
01:24:47,280 --> 01:24:49,590
세 값을 비교하고 최댓값을 반환합니다.
이해되시나요? 네, 이것이 바로

3686
01:24:49,590 --> 01:24:49,600
이해되시나요? 네, 이것이 바로
 

3687
01:24:49,600 --> 01:24:53,350
이해되시나요? 네, 이것이 바로
단측 범위 쿼리입니다. 아, 제가 아직 살펴보지

3688
01:24:53,350 --> 01:24:56,870
단측 범위 쿼리입니다. 아, 제가 아직 살펴보지
 

3689
01:24:56,870 --> 01:24:56,880

 

3690
01:24:56,880 --> 01:24:59,590

못한 문제 세션 4에서

3691
01:24:59,590 --> 01:25:01,510
못한 문제 세션 4에서
 

3692
01:25:01,510 --> 01:25:03,830

 

3693
01:25:03,830 --> 01:25:03,840

 

3694
01:25:03,840 --> 01:25:05,750

두 값 사이의 모든 값 중 최댓값을 구해야 하는 양방향 범위 쿼리 방법을 보여줍니다.

3695
01:25:05,750 --> 01:25:05,760
두 값 사이의 모든 값 중 최댓값을 구해야 하는 양방향 범위 쿼리 방법을 보여줍니다.
 

3696
01:25:05,760 --> 01:25:09,030
두 값 사이의 모든 값 중 최댓값을 구해야 하는 양방향 범위 쿼리 방법을 보여줍니다.
하지만

3697
01:25:09,030 --> 01:25:09,040
하지만
 

3698
01:25:09,040 --> 01:25:10,950
하지만
이 정의보다 더 어렵지는 않습니다.  양쪽에서 재귀 호출을 하지 않아도 되도록

3699
01:25:10,950 --> 01:25:10,960
이 정의보다 더 어렵지는 않습니다.  양쪽에서 재귀 호출을 하지 않아도 되도록
 

3700
01:25:10,960 --> 01:25:13,510
이 정의보다 더 어렵지는 않습니다.  양쪽에서 재귀 호출을 하지 않아도 되도록
확장 기능을 사용하는 재귀 함수입니다

3701
01:25:13,510 --> 01:25:16,629
확장 기능을 사용하는 재귀 함수입니다
 

3702
01:25:16,629 --> 01:25:16,639

 

3703
01:25:16,639 --> 01:25:19,830

. 이해되셨나요? 네

3704
01:25:19,830 --> 01:25:19,840
. 이해되셨나요? 네
 

3705
01:25:19,840 --> 01:25:22,629
. 이해되셨나요? 네
. 오늘은 여기까지입니다.

3706
01:25:22,629 --> 01:25:22,639
. 오늘은 여기까지입니다.
 

3707
01:25:22,639 --> 01:25:25,830
. 오늘은 여기까지입니다.
질문은 나중에 받겠습니다.

3708
01:25:25,830 --> 01:25:25,840
질문은 나중에 받겠습니다.
 

3709
01:25:25,840 --> 01:25:29,239
질문은 나중에 받겠습니다.
감사합니다.

