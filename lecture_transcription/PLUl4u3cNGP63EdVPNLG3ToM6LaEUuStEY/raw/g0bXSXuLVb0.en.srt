1
00:00:12,960 --> 00:00:14,310

all right welcome to

2
00:00:14,310 --> 00:00:14,320
all right welcome to
 

3
00:00:14,320 --> 00:00:16,310
all right welcome to
practice problem session three double o

4
00:00:16,310 --> 00:00:16,320
practice problem session three double o
 

5
00:00:16,320 --> 00:00:17,990
practice problem session three double o
six um

6
00:00:17,990 --> 00:00:18,000
six um
 

7
00:00:18,000 --> 00:00:19,990
six um
today we are going to go through a bunch

8
00:00:19,990 --> 00:00:20,000
today we are going to go through a bunch
 

9
00:00:20,000 --> 00:00:21,349
today we are going to go through a bunch
of problems which

10
00:00:21,349 --> 00:00:21,359
of problems which
 

11
00:00:21,359 --> 00:00:23,670
of problems which
you should have already um i was

12
00:00:23,670 --> 00:00:23,680
you should have already um i was
 

13
00:00:23,680 --> 00:00:25,109
you should have already um i was
thinking of skipping the very first

14
00:00:25,109 --> 00:00:25,119
thinking of skipping the very first
 

15
00:00:25,119 --> 00:00:26,790
thinking of skipping the very first
problem because it's just a mechanical

16
00:00:26,790 --> 00:00:26,800
problem because it's just a mechanical
 

17
00:00:26,800 --> 00:00:28,150
problem because it's just a mechanical
thing if we have time at the end we can

18
00:00:28,150 --> 00:00:28,160
thing if we have time at the end we can
 

19
00:00:28,160 --> 00:00:29,750
thing if we have time at the end we can
come back to it but there's not really

20
00:00:29,750 --> 00:00:29,760
come back to it but there's not really
 

21
00:00:29,760 --> 00:00:30,070
come back to it but there's not really
any

22
00:00:30,070 --> 00:00:30,080
any
 

23
00:00:30,080 --> 00:00:31,269
any
insight i can give you in how to

24
00:00:31,269 --> 00:00:31,279
insight i can give you in how to
 

25
00:00:31,279 --> 00:00:32,709
insight i can give you in how to
approach this problem it's just do you

26
00:00:32,709 --> 00:00:32,719
approach this problem it's just do you
 

27
00:00:32,719 --> 00:00:33,990
approach this problem it's just do you
understand hashing

28
00:00:33,990 --> 00:00:34,000
understand hashing
 

29
00:00:34,000 --> 00:00:35,510
understand hashing
so i want to go into the more creative

30
00:00:35,510 --> 00:00:35,520
so i want to go into the more creative
 

31
00:00:35,520 --> 00:00:37,510
so i want to go into the more creative
problems first i'll start with

32
00:00:37,510 --> 00:00:37,520
problems first i'll start with
 

33
00:00:37,520 --> 00:00:40,790
problems first i'll start with
problem three two hash sequence uh

34
00:00:40,790 --> 00:00:40,800
problem three two hash sequence uh
 

35
00:00:40,800 --> 00:00:43,190
problem three two hash sequence uh
so i'll just read it and then our first

36
00:00:43,190 --> 00:00:43,200
so i'll just read it and then our first
 

37
00:00:43,200 --> 00:00:44,790
so i'll just read it and then our first
task is to convert the la

38
00:00:44,790 --> 00:00:44,800
task is to convert the la
 

39
00:00:44,800 --> 00:00:48,470
task is to convert the la
the word problem into a concise formal

40
00:00:48,470 --> 00:00:48,480
the word problem into a concise formal
 

41
00:00:48,480 --> 00:00:50,069
the word problem into a concise formal
algorithms thing we need to achieve then

42
00:00:50,069 --> 00:00:50,079
algorithms thing we need to achieve then
 

43
00:00:50,079 --> 00:00:51,350
algorithms thing we need to achieve then
we need to come up with ideas for how to

44
00:00:51,350 --> 00:00:51,360
we need to come up with ideas for how to
 

45
00:00:51,360 --> 00:00:52,869
we need to come up with ideas for how to
achieve it and we need to check the

46
00:00:52,869 --> 00:00:52,879
achieve it and we need to check the
 

47
00:00:52,879 --> 00:00:53,830
achieve it and we need to check the
details

48
00:00:53,830 --> 00:00:53,840
details
 

49
00:00:53,840 --> 00:00:56,069
details
that'll be our general pattern so this

50
00:00:56,069 --> 00:00:56,079
that'll be our general pattern so this
 

51
00:00:56,079 --> 00:00:57,510
that'll be our general pattern so this
problem says hash tables are not only

52
00:00:57,510 --> 00:00:57,520
problem says hash tables are not only
 

53
00:00:57,520 --> 00:00:59,029
problem says hash tables are not only
useful for implementing set operations

54
00:00:59,029 --> 00:00:59,039
useful for implementing set operations
 

55
00:00:59,039 --> 00:01:00,229
useful for implementing set operations
they can also be used to implement

56
00:01:00,229 --> 00:01:00,239
they can also be used to implement
 

57
00:01:00,239 --> 00:01:00,869
they can also be used to implement
sequences

58
00:01:00,869 --> 00:01:00,879
sequences
 

59
00:01:00,879 --> 00:01:03,110
sequences
remember from lecture two we have a set

60
00:01:03,110 --> 00:01:03,120
remember from lecture two we have a set
 

61
00:01:03,120 --> 00:01:03,990
remember from lecture two we have a set
uh

62
00:01:03,990 --> 00:01:04,000
uh
 

63
00:01:04,000 --> 00:01:06,310
uh
interface which is about querying items

64
00:01:06,310 --> 00:01:06,320
interface which is about querying items
 

65
00:01:06,320 --> 00:01:08,149
interface which is about querying items
by either key and sort of intrinsic

66
00:01:08,149 --> 00:01:08,159
by either key and sort of intrinsic
 

67
00:01:08,159 --> 00:01:08,710
by either key and sort of intrinsic
order

68
00:01:08,710 --> 00:01:08,720
order
 

69
00:01:08,720 --> 00:01:11,270
order
that's about the items themselves versus

70
00:01:11,270 --> 00:01:11,280
that's about the items themselves versus
 

71
00:01:11,280 --> 00:01:12,789
that's about the items themselves versus
a sequence interface that we started out

72
00:01:12,789 --> 00:01:12,799
a sequence interface that we started out
 

73
00:01:12,799 --> 00:01:15,030
a sequence interface that we started out
with of linked lists and so on

74
00:01:15,030 --> 00:01:15,040
with of linked lists and so on
 

75
00:01:15,040 --> 00:01:18,390
with of linked lists and so on
and arrays for uh where we're given an

76
00:01:18,390 --> 00:01:18,400
and arrays for uh where we're given an
 

77
00:01:18,400 --> 00:01:19,910
and arrays for uh where we're given an
order we want to maintain that order and

78
00:01:19,910 --> 00:01:19,920
order we want to maintain that order and
 

79
00:01:19,920 --> 00:01:21,429
order we want to maintain that order and
that order may not have anything to do

80
00:01:21,429 --> 00:01:21,439
that order may not have anything to do
 

81
00:01:21,439 --> 00:01:21,990
that order may not have anything to do
with the

82
00:01:21,990 --> 00:01:22,000
with the
 

83
00:01:22,000 --> 00:01:23,590
with the
items themselves that's what we call an

84
00:01:23,590 --> 00:01:23,600
items themselves that's what we call an
 

85
00:01:23,600 --> 00:01:25,429
items themselves that's what we call an
extrinsic order we're told what the

86
00:01:25,429 --> 00:01:25,439
extrinsic order we're told what the
 

87
00:01:25,439 --> 00:01:27,109
extrinsic order we're told what the
order is by saying insert this item

88
00:01:27,109 --> 00:01:27,119
order is by saying insert this item
 

89
00:01:27,119 --> 00:01:28,789
order is by saying insert this item
after this one or append this one to the

90
00:01:28,789 --> 00:01:28,799
after this one or append this one to the
 

91
00:01:28,799 --> 00:01:31,429
after this one or append this one to the
end or prepend it to the beginning

92
00:01:31,429 --> 00:01:31,439
end or prepend it to the beginning
 

93
00:01:31,439 --> 00:01:34,390
end or prepend it to the beginning
so in lecture last week we saw hash

94
00:01:34,390 --> 00:01:34,400
so in lecture last week we saw hash
 

95
00:01:34,400 --> 00:01:35,670
so in lecture last week we saw hash
tables implement

96
00:01:35,670 --> 00:01:35,680
tables implement
 

97
00:01:35,680 --> 00:01:39,990
tables implement
sets and let me just remind you

98
00:01:39,990 --> 00:01:40,000
sets and let me just remind you
 

99
00:01:40,000 --> 00:01:43,270
sets and let me just remind you
some things that they can do

100
00:01:43,270 --> 00:01:43,280
some things that they can do
 

101
00:01:43,280 --> 00:01:47,030
some things that they can do
so we have on the one hand set

102
00:01:47,030 --> 00:01:47,040
so we have on the one hand set
 

103
00:01:47,040 --> 00:01:50,310
so we have on the one hand set
hashing

104
00:01:50,310 --> 00:01:50,320

 

105
00:01:50,320 --> 00:01:53,749

so this we're going to need this in a

106
00:01:53,749 --> 00:01:53,759
so this we're going to need this in a
 

107
00:01:53,759 --> 00:01:55,590
so this we're going to need this in a
moment

108
00:01:55,590 --> 00:01:55,600
moment
 

109
00:01:55,600 --> 00:01:58,230
moment
this is just a reminder from lecture we

110
00:01:58,230 --> 00:01:58,240
this is just a reminder from lecture we
 

111
00:01:58,240 --> 00:02:00,630
this is just a reminder from lecture we
can build one in linear time

112
00:02:00,630 --> 00:02:00,640
can build one in linear time
 

113
00:02:00,640 --> 00:02:03,350
can build one in linear time
expect it we can find an item in

114
00:02:03,350 --> 00:02:03,360
expect it we can find an item in
 

115
00:02:03,360 --> 00:02:04,469
expect it we can find an item in
constant time

116
00:02:04,469 --> 00:02:04,479
constant time
 

117
00:02:04,479 --> 00:02:07,510
constant time
expected by key and we can insert or

118
00:02:07,510 --> 00:02:07,520
expected by key and we can insert or
 

119
00:02:07,520 --> 00:02:12,229
expected by key and we can insert or
delete an item

120
00:02:12,229 --> 00:02:12,239

 

121
00:02:12,239 --> 00:02:16,630

in constant expected

122
00:02:16,630 --> 00:02:16,640
in constant expected
 

123
00:02:16,640 --> 00:02:20,470
in constant expected
amortized

124
00:02:20,470 --> 00:02:20,480

 

125
00:02:20,480 --> 00:02:23,190

okay uh so this is a black box that

126
00:02:23,190 --> 00:02:23,200
okay uh so this is a black box that
 

127
00:02:23,200 --> 00:02:24,949
okay uh so this is a black box that
we're given

128
00:02:24,949 --> 00:02:24,959
we're given
 

129
00:02:24,959 --> 00:02:28,869
we're given
and the problem

130
00:02:28,869 --> 00:02:28,879

 

131
00:02:28,879 --> 00:02:31,430

statement says that imagine you're given

132
00:02:31,430 --> 00:02:31,440
statement says that imagine you're given
 

133
00:02:31,440 --> 00:02:33,509
statement says that imagine you're given
a hash table as a black box which means

134
00:02:33,509 --> 00:02:33,519
a hash table as a black box which means
 

135
00:02:33,519 --> 00:02:34,949
a hash table as a black box which means
we're given a thing that behave

136
00:02:34,949 --> 00:02:34,959
we're given a thing that behave
 

137
00:02:34,959 --> 00:02:39,030
we're given a thing that behave
behaves just like a thank you to

138
00:02:39,030 --> 00:02:39,040
behaves just like a thank you to
 

139
00:02:39,040 --> 00:02:41,430
behaves just like a thank you to
uh we're given something that is a hash

140
00:02:41,430 --> 00:02:41,440
uh we're given something that is a hash
 

141
00:02:41,440 --> 00:02:42,309
uh we're given something that is a hash
table but

142
00:02:42,309 --> 00:02:42,319
table but
 

143
00:02:42,319 --> 00:02:43,589
table but
it's black box in the sense that we're

144
00:02:43,589 --> 00:02:43,599
it's black box in the sense that we're
 

145
00:02:43,599 --> 00:02:44,949
it's black box in the sense that we're
not allowed to reach in and change the

146
00:02:44,949 --> 00:02:44,959
not allowed to reach in and change the
 

147
00:02:44,959 --> 00:02:46,390
not allowed to reach in and change the
implementation details we're supposed to

148
00:02:46,390 --> 00:02:46,400
implementation details we're supposed to
 

149
00:02:46,400 --> 00:02:47,030
implementation details we're supposed to
use it as

150
00:02:47,030 --> 00:02:47,040
use it as
 

151
00:02:47,040 --> 00:02:49,670
use it as
is just by calling its interface so in

152
00:02:49,670 --> 00:02:49,680
is just by calling its interface so in
 

153
00:02:49,680 --> 00:02:50,949
is just by calling its interface so in
particular we're given these three

154
00:02:50,949 --> 00:02:50,959
particular we're given these three
 

155
00:02:50,959 --> 00:02:52,790
particular we're given these three
operations i'll maybe also use

156
00:02:52,790 --> 00:02:52,800
operations i'll maybe also use
 

157
00:02:52,800 --> 00:02:55,509
operations i'll maybe also use
it to iterate through the items so we're

158
00:02:55,509 --> 00:02:55,519
it to iterate through the items so we're
 

159
00:02:55,519 --> 00:02:56,790
it to iterate through the items so we're
allowed to build something in linear

160
00:02:56,790 --> 00:02:56,800
allowed to build something in linear
 

161
00:02:56,800 --> 00:02:57,190
allowed to build something in linear
time

162
00:02:57,190 --> 00:02:57,200
time
 

163
00:02:57,200 --> 00:02:58,710
time
find and insert and delete and

164
00:02:58,710 --> 00:02:58,720
find and insert and delete and
 

165
00:02:58,720 --> 00:03:02,149
find and insert and delete and
constantly expect it amortized

166
00:03:02,149 --> 00:03:02,159
constantly expect it amortized
 

167
00:03:02,159 --> 00:03:04,070
constantly expect it amortized
and what the problem is asking is to

168
00:03:04,070 --> 00:03:04,080
and what the problem is asking is to
 

169
00:03:04,080 --> 00:03:06,309
and what the problem is asking is to
build out of this data structure

170
00:03:06,309 --> 00:03:06,319
build out of this data structure
 

171
00:03:06,319 --> 00:03:11,190
build out of this data structure
a sequence with particular time balance

172
00:03:11,190 --> 00:03:11,200
a sequence with particular time balance
 

173
00:03:11,200 --> 00:03:16,390
a sequence with particular time balance
uh so this is what we call a reduction

174
00:03:16,390 --> 00:03:16,400

 

175
00:03:16,400 --> 00:03:19,589

in that we're going to convert uh

176
00:03:19,589 --> 00:03:19,599
in that we're going to convert uh
 

177
00:03:19,599 --> 00:03:21,589
in that we're going to convert uh
i guess technically we're reducing the

178
00:03:21,589 --> 00:03:21,599
i guess technically we're reducing the
 

179
00:03:21,599 --> 00:03:22,790
i guess technically we're reducing the
sequence problem

180
00:03:22,790 --> 00:03:22,800
sequence problem
 

181
00:03:22,800 --> 00:03:25,670
sequence problem
to the set problem um because we're

182
00:03:25,670 --> 00:03:25,680
to the set problem um because we're
 

183
00:03:25,680 --> 00:03:26,949
to the set problem um because we're
showing how to solve the sequence

184
00:03:26,949 --> 00:03:26,959
showing how to solve the sequence
 

185
00:03:26,959 --> 00:03:28,710
showing how to solve the sequence
problem using the set problem

186
00:03:28,710 --> 00:03:28,720
problem using the set problem
 

187
00:03:28,720 --> 00:03:30,149
problem using the set problem
but the way we'll think about it is in

188
00:03:30,149 --> 00:03:30,159
but the way we'll think about it is in
 

189
00:03:30,159 --> 00:03:31,509
but the way we'll think about it is in
the other direction we're given a data

190
00:03:31,509 --> 00:03:31,519
the other direction we're given a data
 

191
00:03:31,519 --> 00:03:32,869
the other direction we're given a data
structure to solve set and we're going

192
00:03:32,869 --> 00:03:32,879
structure to solve set and we're going
 

193
00:03:32,879 --> 00:03:34,309
structure to solve set and we're going
to convert it into a data structure that

194
00:03:34,309 --> 00:03:34,319
to convert it into a data structure that
 

195
00:03:34,319 --> 00:03:35,430
to convert it into a data structure that
solves sequence

196
00:03:35,430 --> 00:03:35,440
solves sequence
 

197
00:03:35,440 --> 00:03:37,190
solves sequence
so given that we already know how to do

198
00:03:37,190 --> 00:03:37,200
so given that we already know how to do
 

199
00:03:37,200 --> 00:03:38,789
so given that we already know how to do
this from lecture we're going to learn

200
00:03:38,789 --> 00:03:38,799
this from lecture we're going to learn
 

201
00:03:38,799 --> 00:03:40,710
this from lecture we're going to learn
how to do this

202
00:03:40,710 --> 00:03:40,720
how to do this
 

203
00:03:40,720 --> 00:03:42,470
how to do this
this is teaching you new stuff in a

204
00:03:42,470 --> 00:03:42,480
this is teaching you new stuff in a
 

205
00:03:42,480 --> 00:03:43,750
this is teaching you new stuff in a
problem set

206
00:03:43,750 --> 00:03:43,760
problem set
 

207
00:03:43,760 --> 00:03:45,430
problem set
so the specific bounds that we're told

208
00:03:45,430 --> 00:03:45,440
so the specific bounds that we're told
 

209
00:03:45,440 --> 00:03:47,350
so the specific bounds that we're told
to achieve are build

210
00:03:47,350 --> 00:03:47,360
to achieve are build
 

211
00:03:47,360 --> 00:03:50,949
to achieve are build
and constant expected time

212
00:03:50,949 --> 00:03:50,959

 

213
00:03:50,959 --> 00:03:55,670

get and set at

214
00:03:55,670 --> 00:03:55,680

 

215
00:03:55,680 --> 00:04:00,309

inconstant expected time

216
00:04:00,309 --> 00:04:00,319
inconstant expected time
 

217
00:04:00,319 --> 00:04:07,270
inconstant expected time
insert and delete app

218
00:04:07,270 --> 00:04:07,280

 

219
00:04:07,280 --> 00:04:12,830

and linear expected time

220
00:04:12,830 --> 00:04:12,840

 

221
00:04:12,840 --> 00:04:17,590

and insert and delete

222
00:04:17,590 --> 00:04:17,600
and insert and delete
 

223
00:04:17,600 --> 00:04:22,710
and insert and delete
uh first and last

224
00:04:22,710 --> 00:04:22,720

 

225
00:04:22,720 --> 00:04:25,990

and running out of room here

226
00:04:25,990 --> 00:04:26,000
and running out of room here
 

227
00:04:26,000 --> 00:04:31,430
and running out of room here
constant expected amortized

228
00:04:31,430 --> 00:04:31,440

 

229
00:04:31,440 --> 00:04:34,629

okay um so this is just what we're told

230
00:04:34,629 --> 00:04:34,639
okay um so this is just what we're told
 

231
00:04:34,639 --> 00:04:36,469
okay um so this is just what we're told
to do

232
00:04:36,469 --> 00:04:36,479
to do
 

233
00:04:36,479 --> 00:04:39,030
to do
and now we start thinking so we're given

234
00:04:39,030 --> 00:04:39,040
and now we start thinking so we're given
 

235
00:04:39,040 --> 00:04:39,749
and now we start thinking so we're given
this

236
00:04:39,749 --> 00:04:39,759
this
 

237
00:04:39,759 --> 00:04:43,189
this
we want to build this um and so

238
00:04:43,189 --> 00:04:43,199
we want to build this um and so
 

239
00:04:43,199 --> 00:04:44,469
we want to build this um and so
i'm going to tell you a little bit about

240
00:04:44,469 --> 00:04:44,479
i'm going to tell you a little bit about
 

241
00:04:44,479 --> 00:04:45,749
i'm going to tell you a little bit about
my thought process about when i'm

242
00:04:45,749 --> 00:04:45,759
my thought process about when i'm
 

243
00:04:45,759 --> 00:04:46,870
my thought process about when i'm
presenting with a problem like this

244
00:04:46,870 --> 00:04:46,880
presenting with a problem like this
 

245
00:04:46,880 --> 00:04:48,950
presenting with a problem like this
first thing is to read the problem

246
00:04:48,950 --> 00:04:48,960
first thing is to read the problem
 

247
00:04:48,960 --> 00:04:51,670
first thing is to read the problem
and see okay what what's what's the hard

248
00:04:51,670 --> 00:04:51,680
and see okay what what's what's the hard
 

249
00:04:51,680 --> 00:04:52,230
and see okay what what's what's the hard
part here

250
00:04:52,230 --> 00:04:52,240
part here
 

251
00:04:52,240 --> 00:04:53,590
part here
what are the challenges so clearly we

252
00:04:53,590 --> 00:04:53,600
what are the challenges so clearly we
 

253
00:04:53,600 --> 00:04:55,030
what are the challenges so clearly we
have to do all for all four of these

254
00:04:55,030 --> 00:04:55,040
have to do all for all four of these
 

255
00:04:55,040 --> 00:04:56,390
have to do all for all four of these
types of operations

256
00:04:56,390 --> 00:04:56,400
types of operations
 

257
00:04:56,400 --> 00:04:58,150
types of operations
building linear expected time that's

258
00:04:58,150 --> 00:04:58,160
building linear expected time that's
 

259
00:04:58,160 --> 00:04:59,749
building linear expected time that's
basically everything we've seen

260
00:04:59,749 --> 00:04:59,759
basically everything we've seen
 

261
00:04:59,759 --> 00:05:02,070
basically everything we've seen
uh get or set at in constant expected

262
00:05:02,070 --> 00:05:02,080
uh get or set at in constant expected
 

263
00:05:02,080 --> 00:05:03,749
uh get or set at in constant expected
time that's fast

264
00:05:03,749 --> 00:05:03,759
time that's fast
 

265
00:05:03,759 --> 00:05:06,390
time that's fast
and that feels kind of like this find

266
00:05:06,390 --> 00:05:06,400
and that feels kind of like this find
 

267
00:05:06,400 --> 00:05:07,189
and that feels kind of like this find
operation

268
00:05:07,189 --> 00:05:07,199
operation
 

269
00:05:07,199 --> 00:05:09,670
operation
so both of these seem pretty

270
00:05:09,670 --> 00:05:09,680
so both of these seem pretty
 

271
00:05:09,680 --> 00:05:11,270
so both of these seem pretty
matchy-matchy so that

272
00:05:11,270 --> 00:05:11,280
matchy-matchy so that
 

273
00:05:11,280 --> 00:05:13,270
matchy-matchy so that
looks like a good mapping i'm gonna try

274
00:05:13,270 --> 00:05:13,280
looks like a good mapping i'm gonna try
 

275
00:05:13,280 --> 00:05:14,790
looks like a good mapping i'm gonna try
to build these operations using those

276
00:05:14,790 --> 00:05:14,800
to build these operations using those
 

277
00:05:14,800 --> 00:05:16,070
to build these operations using those
operations

278
00:05:16,070 --> 00:05:16,080
operations
 

279
00:05:16,080 --> 00:05:19,110
operations
insert and delete uh at a specific

280
00:05:19,110 --> 00:05:19,120
insert and delete uh at a specific
 

281
00:05:19,120 --> 00:05:20,150
insert and delete uh at a specific
location

282
00:05:20,150 --> 00:05:20,160
location
 

283
00:05:20,160 --> 00:05:22,950
location
in constant expected time sorry linear

284
00:05:22,950 --> 00:05:22,960
in constant expected time sorry linear
 

285
00:05:22,960 --> 00:05:23,749
in constant expected time sorry linear
expected time

286
00:05:23,749 --> 00:05:23,759
expected time
 

287
00:05:23,759 --> 00:05:26,550
expected time
that's big linear expected time means i

288
00:05:26,550 --> 00:05:26,560
that's big linear expected time means i
 

289
00:05:26,560 --> 00:05:27,270
that's big linear expected time means i
can

290
00:05:27,270 --> 00:05:27,280
can
 

291
00:05:27,280 --> 00:05:29,029
can
rebuild the entire data structure every

292
00:05:29,029 --> 00:05:29,039
rebuild the entire data structure every
 

293
00:05:29,039 --> 00:05:30,550
rebuild the entire data structure every
time i do an operation

294
00:05:30,550 --> 00:05:30,560
time i do an operation
 

295
00:05:30,560 --> 00:05:33,590
time i do an operation
so this is easy okay that's first thing

296
00:05:33,590 --> 00:05:33,600
so this is easy okay that's first thing
 

297
00:05:33,600 --> 00:05:34,469
so this is easy okay that's first thing
you realize this

298
00:05:34,469 --> 00:05:34,479
you realize this
 

299
00:05:34,479 --> 00:05:37,670
you realize this
is big great so i don't really have to

300
00:05:37,670 --> 00:05:37,680
is big great so i don't really have to
 

301
00:05:37,680 --> 00:05:37,990
is big great so i don't really have to
worry

302
00:05:37,990 --> 00:05:38,000
worry
 

303
00:05:38,000 --> 00:05:39,909
worry
about these operations i mean i do have

304
00:05:39,909 --> 00:05:39,919
about these operations i mean i do have
 

305
00:05:39,919 --> 00:05:41,189
about these operations i mean i do have
to implement them but

306
00:05:41,189 --> 00:05:41,199
to implement them but
 

307
00:05:41,199 --> 00:05:43,749
to implement them but
it's not hard to do it that fast because

308
00:05:43,749 --> 00:05:43,759
it's not hard to do it that fast because
 

309
00:05:43,759 --> 00:05:45,749
it's not hard to do it that fast because
i can rebuild

310
00:05:45,749 --> 00:05:45,759
i can rebuild
 

311
00:05:45,759 --> 00:05:48,150
i can rebuild
uh and then here insert and delete at

312
00:05:48,150 --> 00:05:48,160
uh and then here insert and delete at
 

313
00:05:48,160 --> 00:05:49,749
uh and then here insert and delete at
the beginning and the end of the array

314
00:05:49,749 --> 00:05:49,759
the beginning and the end of the array
 

315
00:05:49,759 --> 00:05:50,550
the beginning and the end of the array
these are the deck

316
00:05:50,550 --> 00:05:50,560
these are the deck
 

317
00:05:50,560 --> 00:05:52,310
these are the deck
double ended queue operations can

318
00:05:52,310 --> 00:05:52,320
double ended queue operations can
 

319
00:05:52,320 --> 00:05:53,670
double ended queue operations can
certainly leave at either end

320
00:05:53,670 --> 00:05:53,680
certainly leave at either end
 

321
00:05:53,680 --> 00:05:55,670
certainly leave at either end
and constant expected amortized time

322
00:05:55,670 --> 00:05:55,680
and constant expected amortized time
 

323
00:05:55,680 --> 00:05:56,870
and constant expected amortized time
this i feel like is

324
00:05:56,870 --> 00:05:56,880
this i feel like is
 

325
00:05:56,880 --> 00:05:59,670
this i feel like is
a tricky one uh you've seen one way to

326
00:05:59,670 --> 00:05:59,680
a tricky one uh you've seen one way to
 

327
00:05:59,680 --> 00:06:01,350
a tricky one uh you've seen one way to
do this in problem set

328
00:06:01,350 --> 00:06:01,360
do this in problem set
 

329
00:06:01,360 --> 00:06:04,550
do this in problem set
but now we're gonna see another way with

330
00:06:04,550 --> 00:06:04,560
but now we're gonna see another way with
 

331
00:06:04,560 --> 00:06:06,550
but now we're gonna see another way with
okay the other thing to notice is these

332
00:06:06,550 --> 00:06:06,560
okay the other thing to notice is these
 

333
00:06:06,560 --> 00:06:08,309
okay the other thing to notice is these
expected words

334
00:06:08,309 --> 00:06:08,319
expected words
 

335
00:06:08,319 --> 00:06:10,150
expected words
uh in this case we're told to use

336
00:06:10,150 --> 00:06:10,160
uh in this case we're told to use
 

337
00:06:10,160 --> 00:06:12,230
uh in this case we're told to use
hashing but a lot of the problems

338
00:06:12,230 --> 00:06:12,240
hashing but a lot of the problems
 

339
00:06:12,240 --> 00:06:14,070
hashing but a lot of the problems
you're not told how to solve it or what

340
00:06:14,070 --> 00:06:14,080
you're not told how to solve it or what
 

341
00:06:14,080 --> 00:06:16,469
you're not told how to solve it or what
you should be basing your thing on

342
00:06:16,469 --> 00:06:16,479
you should be basing your thing on
 

343
00:06:16,479 --> 00:06:19,189
you should be basing your thing on
and so expected is always a good keyword

344
00:06:19,189 --> 00:06:19,199
and so expected is always a good keyword
 

345
00:06:19,199 --> 00:06:20,710
and so expected is always a good keyword
because it means randomization is

346
00:06:20,710 --> 00:06:20,720
because it means randomization is
 

347
00:06:20,720 --> 00:06:22,070
because it means randomization is
involved somehow if you're told the

348
00:06:22,070 --> 00:06:22,080
involved somehow if you're told the
 

349
00:06:22,080 --> 00:06:23,909
involved somehow if you're told the
bound is going to be expected

350
00:06:23,909 --> 00:06:23,919
bound is going to be expected
 

351
00:06:23,919 --> 00:06:25,590
bound is going to be expected
you should you probably need to use

352
00:06:25,590 --> 00:06:25,600
you should you probably need to use
 

353
00:06:25,600 --> 00:06:27,990
you should you probably need to use
randomization

354
00:06:27,990 --> 00:06:28,000
randomization
 

355
00:06:28,000 --> 00:06:29,510
randomization
and in this class the only form of

356
00:06:29,510 --> 00:06:29,520
and in this class the only form of
 

357
00:06:29,520 --> 00:06:30,870
and in this class the only form of
randomization you will use is

358
00:06:30,870 --> 00:06:30,880
randomization you will use is
 

359
00:06:30,880 --> 00:06:32,230
randomization you will use is
essentially hashing

360
00:06:32,230 --> 00:06:32,240
essentially hashing
 

361
00:06:32,240 --> 00:06:35,670
essentially hashing
so uh that's a good hint

362
00:06:35,670 --> 00:06:35,680
so uh that's a good hint
 

363
00:06:35,680 --> 00:06:36,790
so uh that's a good hint
in this case we know that we're supposed

364
00:06:36,790 --> 00:06:36,800
in this case we know that we're supposed
 

365
00:06:36,800 --> 00:06:40,390
in this case we know that we're supposed
to use hashing all right so

366
00:06:40,390 --> 00:06:40,400
to use hashing all right so
 

367
00:06:40,400 --> 00:06:46,309
to use hashing all right so
this is going to be the challenge

368
00:06:46,309 --> 00:06:46,319

 

369
00:06:46,319 --> 00:06:48,710

but any ideas on how we might tackle

370
00:06:48,710 --> 00:06:48,720
but any ideas on how we might tackle
 

371
00:06:48,720 --> 00:06:50,150
but any ideas on how we might tackle
this problem how can we

372
00:06:50,150 --> 00:06:50,160
this problem how can we
 

373
00:06:50,160 --> 00:06:53,350
this problem how can we
so set remember every item has a key

374
00:06:53,350 --> 00:06:53,360
so set remember every item has a key
 

375
00:06:53,360 --> 00:06:55,990
so set remember every item has a key
in a sequence items are just items and

376
00:06:55,990 --> 00:06:56,000
in a sequence items are just items and
 

377
00:06:56,000 --> 00:06:57,430
in a sequence items are just items and
we're told to insert and delete them at

378
00:06:57,430 --> 00:06:57,440
we're told to insert and delete them at
 

379
00:06:57,440 --> 00:06:58,950
we're told to insert and delete them at
particular locations

380
00:06:58,950 --> 00:06:58,960
particular locations
 

381
00:06:58,960 --> 00:07:01,589
particular locations
but they don't have keys so one of the

382
00:07:01,589 --> 00:07:01,599
but they don't have keys so one of the
 

383
00:07:01,599 --> 00:07:02,950
but they don't have keys so one of the
challenges is going to be

384
00:07:02,950 --> 00:07:02,960
challenges is going to be
 

385
00:07:02,960 --> 00:07:05,749
challenges is going to be
to take our items here give them keys so

386
00:07:05,749 --> 00:07:05,759
to take our items here give them keys so
 

387
00:07:05,759 --> 00:07:07,270
to take our items here give them keys so
that we can store them in a set

388
00:07:07,270 --> 00:07:07,280
that we can store them in a set
 

389
00:07:07,280 --> 00:07:12,790
that we can store them in a set
otherwise we can't use find

390
00:07:12,790 --> 00:07:12,800
otherwise we can't use find
 

391
00:07:12,800 --> 00:07:14,870
otherwise we can't use find
there's no keys there there's no way to

392
00:07:14,870 --> 00:07:14,880
there's no keys there there's no way to
 

393
00:07:14,880 --> 00:07:18,230
there's no keys there there's no way to
search by key

394
00:07:18,230 --> 00:07:18,240

 

395
00:07:18,240 --> 00:07:23,749

ideas

396
00:07:23,749 --> 00:07:23,759

 

397
00:07:23,759 --> 00:07:27,670

so let's think about what we want to do

398
00:07:27,670 --> 00:07:27,680
so let's think about what we want to do
 

399
00:07:27,680 --> 00:07:30,950
so let's think about what we want to do
let's start with so build i think is

400
00:07:30,950 --> 00:07:30,960
let's start with so build i think is
 

401
00:07:30,960 --> 00:07:31,670
let's start with so build i think is
fine if you

402
00:07:31,670 --> 00:07:31,680
fine if you
 

403
00:07:31,680 --> 00:07:33,430
fine if you
just want to build a data structure you

404
00:07:33,430 --> 00:07:33,440
just want to build a data structure you
 

405
00:07:33,440 --> 00:07:34,950
just want to build a data structure you
don't need to do anything

406
00:07:34,950 --> 00:07:34,960
don't need to do anything
 

407
00:07:34,960 --> 00:07:37,270
don't need to do anything
the hard part are the queries or updates

408
00:07:37,270 --> 00:07:37,280
the hard part are the queries or updates
 

409
00:07:37,280 --> 00:07:38,790
the hard part are the queries or updates
you want to be able to do on your data

410
00:07:38,790 --> 00:07:38,800
you want to be able to do on your data
 

411
00:07:38,800 --> 00:07:39,589
you want to be able to do on your data
structure

412
00:07:39,589 --> 00:07:39,599
structure
 

413
00:07:39,599 --> 00:07:42,150
structure
let's start with this operation get and

414
00:07:42,150 --> 00:07:42,160
let's start with this operation get and
 

415
00:07:42,160 --> 00:07:43,350
let's start with this operation get and
set at so

416
00:07:43,350 --> 00:07:43,360
set at so
 

417
00:07:43,360 --> 00:07:46,230
set at so
remember get at your given and index i

418
00:07:46,230 --> 00:07:46,240
remember get at your given and index i
 

419
00:07:46,240 --> 00:07:50,230
remember get at your given and index i
and you want to

420
00:07:50,230 --> 00:07:50,240

 

421
00:07:50,240 --> 00:07:53,270

find the item at position i

422
00:07:53,270 --> 00:07:53,280
find the item at position i
 

423
00:07:53,280 --> 00:07:56,869
find the item at position i
and set at we're given

424
00:07:56,869 --> 00:07:56,879
and set at we're given
 

425
00:07:56,879 --> 00:07:59,110
and set at we're given
a position and we want to change the

426
00:07:59,110 --> 00:07:59,120
a position and we want to change the
 

427
00:07:59,120 --> 00:08:00,230
a position and we want to change the
item stored

428
00:08:00,230 --> 00:08:00,240
item stored
 

429
00:08:00,240 --> 00:08:03,189
item stored
at that position at that index i now

430
00:08:03,189 --> 00:08:03,199
at that position at that index i now
 

431
00:08:03,199 --> 00:08:04,390
at that position at that index i now
over here

432
00:08:04,390 --> 00:08:04,400
over here
 

433
00:08:04,400 --> 00:08:07,029
over here
what we're given we can insert and

434
00:08:07,029 --> 00:08:07,039
what we're given we can insert and
 

435
00:08:07,039 --> 00:08:07,749
what we're given we can insert and
delete

436
00:08:07,749 --> 00:08:07,759
delete
 

437
00:08:07,759 --> 00:08:10,150
delete
but the main sort of lookup let's think

438
00:08:10,150 --> 00:08:10,160
but the main sort of lookup let's think
 

439
00:08:10,160 --> 00:08:11,749
but the main sort of lookup let's think
about get at first

440
00:08:11,749 --> 00:08:11,759
about get at first
 

441
00:08:11,759 --> 00:08:14,950
about get at first
the natural mapping given this arrow

442
00:08:14,950 --> 00:08:14,960
the natural mapping given this arrow
 

443
00:08:14,960 --> 00:08:17,909
the natural mapping given this arrow
is find find will search for an item by

444
00:08:17,909 --> 00:08:17,919
is find find will search for an item by
 

445
00:08:17,919 --> 00:08:19,350
is find find will search for an item by
key

446
00:08:19,350 --> 00:08:19,360
key
 

447
00:08:19,360 --> 00:08:22,070
key
so here's just staring at that once you

448
00:08:22,070 --> 00:08:22,080
so here's just staring at that once you
 

449
00:08:22,080 --> 00:08:23,430
so here's just staring at that once you
look at all the possible pairings you

450
00:08:23,430 --> 00:08:23,440
look at all the possible pairings you
 

451
00:08:23,440 --> 00:08:23,990
look at all the possible pairings you
could do

452
00:08:23,990 --> 00:08:24,000
could do
 

453
00:08:24,000 --> 00:08:26,150
could do
we have find by key over here and we

454
00:08:26,150 --> 00:08:26,160
we have find by key over here and we
 

455
00:08:26,160 --> 00:08:28,550
we have find by key over here and we
need to implement get at by index

456
00:08:28,550 --> 00:08:28,560
need to implement get at by index
 

457
00:08:28,560 --> 00:08:31,909
need to implement get at by index
so let's make the indices keys okay so

458
00:08:31,909 --> 00:08:31,919
so let's make the indices keys okay so
 

459
00:08:31,919 --> 00:08:33,909
so let's make the indices keys okay so
this is idea number one

460
00:08:33,909 --> 00:08:33,919
this is idea number one
 

461
00:08:33,919 --> 00:08:39,269
this is idea number one
uh index

462
00:08:39,269 --> 00:08:39,279

 

463
00:08:39,279 --> 00:08:43,430

assign a key

464
00:08:43,430 --> 00:08:43,440
assign a key
 

465
00:08:43,440 --> 00:08:47,750
assign a key
to each item

466
00:08:47,750 --> 00:08:47,760

 

467
00:08:47,760 --> 00:08:50,790

equal to the index

468
00:08:50,790 --> 00:08:50,800
equal to the index
 

469
00:08:50,800 --> 00:08:55,750
equal to the index
in the sequence

470
00:08:55,750 --> 00:08:55,760
in the sequence
 

471
00:08:55,760 --> 00:08:59,350
in the sequence
okay so then when i do to implement get

472
00:08:59,350 --> 00:08:59,360
okay so then when i do to implement get
 

473
00:08:59,360 --> 00:09:00,470
okay so then when i do to implement get
ad i can just call

474
00:09:00,470 --> 00:09:00,480
ad i can just call
 

475
00:09:00,480 --> 00:09:04,389
ad i can just call
find of i

476
00:09:04,389 --> 00:09:04,399
find of i
 

477
00:09:04,399 --> 00:09:07,030
find of i
if i is also a key and that should give

478
00:09:07,030 --> 00:09:07,040
if i is also a key and that should give
 

479
00:09:07,040 --> 00:09:07,590
if i is also a key and that should give
me

480
00:09:07,590 --> 00:09:07,600
me
 

481
00:09:07,600 --> 00:09:09,110
me
the thing that i want maybe for this to

482
00:09:09,110 --> 00:09:09,120
the thing that i want maybe for this to
 

483
00:09:09,120 --> 00:09:10,389
the thing that i want maybe for this to
make sense let me tell you how i'm

484
00:09:10,389 --> 00:09:10,399
make sense let me tell you how i'm
 

485
00:09:10,399 --> 00:09:11,670
make sense let me tell you how i'm
building

486
00:09:11,670 --> 00:09:11,680
building
 

487
00:09:11,680 --> 00:09:15,350
building
so if i'm given say an array of items

488
00:09:15,350 --> 00:09:15,360
so if i'm given say an array of items
 

489
00:09:15,360 --> 00:09:17,590
so if i'm given say an array of items
uh and they're both the only name

490
00:09:17,590 --> 00:09:17,600
uh and they're both the only name
 

491
00:09:17,600 --> 00:09:19,350
uh and they're both the only name
conflict here is built so let me call

492
00:09:19,350 --> 00:09:19,360
conflict here is built so let me call
 

493
00:09:19,360 --> 00:09:20,550
conflict here is built so let me call
this one

494
00:09:20,550 --> 00:09:20,560
this one
 

495
00:09:20,560 --> 00:09:24,150
this one
sequence build

496
00:09:24,150 --> 00:09:24,160

 

497
00:09:24,160 --> 00:09:25,750

and i'm going to implement it using set

498
00:09:25,750 --> 00:09:25,760
and i'm going to implement it using set
 

499
00:09:25,760 --> 00:09:29,590
and i'm going to implement it using set
build

500
00:09:29,590 --> 00:09:29,600

 

501
00:09:29,600 --> 00:09:32,070

and i'll use some short shorthand

502
00:09:32,070 --> 00:09:32,080
and i'll use some short shorthand
 

503
00:09:32,080 --> 00:09:33,590
and i'll use some short shorthand
notation here let's say

504
00:09:33,590 --> 00:09:33,600
notation here let's say
 

505
00:09:33,600 --> 00:09:37,509
notation here let's say
i want to make an object that has a key

506
00:09:37,509 --> 00:09:37,519
i want to make an object that has a key
 

507
00:09:37,519 --> 00:09:43,030
i want to make an object that has a key
equal to i and a value

508
00:09:43,030 --> 00:09:43,040
equal to i and a value
 

509
00:09:43,040 --> 00:09:47,829
equal to i and a value
equal to a of i

510
00:09:47,829 --> 00:09:47,839

 

511
00:09:47,839 --> 00:09:50,870

that's my object notation for i

512
00:09:50,870 --> 00:09:50,880
that's my object notation for i
 

513
00:09:50,880 --> 00:09:54,710
that's my object notation for i
equals 0 1 to

514
00:09:54,710 --> 00:09:54,720
equals 0 1 to
 

515
00:09:54,720 --> 00:09:57,829
equals 0 1 to
size of a minus 1.

516
00:09:57,829 --> 00:09:57,839
size of a minus 1.
 

517
00:09:57,839 --> 00:09:59,990
size of a minus 1.
that's a little bit code-like but not

518
00:09:59,990 --> 00:10:00,000
that's a little bit code-like but not
 

519
00:10:00,000 --> 00:10:01,750
that's a little bit code-like but not
quite literal code

520
00:10:01,750 --> 00:10:01,760
quite literal code
 

521
00:10:01,760 --> 00:10:03,509
quite literal code
so i'm just going to use this to say

522
00:10:03,509 --> 00:10:03,519
so i'm just going to use this to say
 

523
00:10:03,519 --> 00:10:07,030
so i'm just going to use this to say
let's make an object that has two

524
00:10:07,030 --> 00:10:07,040
let's make an object that has two
 

525
00:10:07,040 --> 00:10:09,030
let's make an object that has two
parts one is called the key so we can

526
00:10:09,030 --> 00:10:09,040
parts one is called the key so we can
 

527
00:10:09,040 --> 00:10:10,949
parts one is called the key so we can
talk about the object.key

528
00:10:10,949 --> 00:10:10,959
talk about the object.key
 

529
00:10:10,959 --> 00:10:13,030
talk about the object.key
so we can see which sets want to do and

530
00:10:13,030 --> 00:10:13,040
so we can see which sets want to do and
 

531
00:10:13,040 --> 00:10:14,550
so we can see which sets want to do and
we're also going to store a value which

532
00:10:14,550 --> 00:10:14,560
we're also going to store a value which
 

533
00:10:14,560 --> 00:10:17,430
we're also going to store a value which
is the actual item that we're given

534
00:10:17,430 --> 00:10:17,440
is the actual item that we're given
 

535
00:10:17,440 --> 00:10:19,350
is the actual item that we're given
so i'm just because these are given in

536
00:10:19,350 --> 00:10:19,360
so i'm just because these are given in
 

537
00:10:19,360 --> 00:10:20,790
so i'm just because these are given in
the sequence i'm just representing that

538
00:10:20,790 --> 00:10:20,800
the sequence i'm just representing that
 

539
00:10:20,800 --> 00:10:22,630
the sequence i'm just representing that
sequence order by assigning i to be the

540
00:10:22,630 --> 00:10:22,640
sequence order by assigning i to be the
 

541
00:10:22,640 --> 00:10:23,269
sequence order by assigning i to be the
key

542
00:10:23,269 --> 00:10:23,279
key
 

543
00:10:23,279 --> 00:10:25,509
key
and so now if i want to find the item at

544
00:10:25,509 --> 00:10:25,519
and so now if i want to find the item at
 

545
00:10:25,519 --> 00:10:26,310
and so now if i want to find the item at
index i

546
00:10:26,310 --> 00:10:26,320
index i
 

547
00:10:26,320 --> 00:10:28,310
index i
i can do find of i and technically i

548
00:10:28,310 --> 00:10:28,320
i can do find of i and technically i
 

549
00:10:28,320 --> 00:10:29,509
i can do find of i and technically i
should probably do dot

550
00:10:29,509 --> 00:10:29,519
should probably do dot
 

551
00:10:29,519 --> 00:10:32,310
should probably do dot
value that will give me the actual item

552
00:10:32,310 --> 00:10:32,320
value that will give me the actual item
 

553
00:10:32,320 --> 00:10:33,350
value that will give me the actual item
that's stored

554
00:10:33,350 --> 00:10:33,360
that's stored
 

555
00:10:33,360 --> 00:10:35,509
that's stored
at that position when i do find of i i'm

556
00:10:35,509 --> 00:10:35,519
at that position when i do find of i i'm
 

557
00:10:35,519 --> 00:10:37,430
at that position when i do find of i i'm
going to get this whole object

558
00:10:37,430 --> 00:10:37,440
going to get this whole object
 

559
00:10:37,440 --> 00:10:39,829
going to get this whole object
with the key of i and then i want to get

560
00:10:39,829 --> 00:10:39,839
with the key of i and then i want to get
 

561
00:10:39,839 --> 00:10:41,670
with the key of i and then i want to get
the value part of it

562
00:10:41,670 --> 00:10:41,680
the value part of it
 

563
00:10:41,680 --> 00:10:44,790
the value part of it
so then set at i can just

564
00:10:44,790 --> 00:10:44,800
so then set at i can just
 

565
00:10:44,800 --> 00:10:48,790
so then set at i can just
use this find operation to get

566
00:10:48,790 --> 00:10:48,800
use this find operation to get
 

567
00:10:48,800 --> 00:10:52,870
use this find operation to get
the object and set its value to x

568
00:10:52,870 --> 00:10:52,880
the object and set its value to x
 

569
00:10:52,880 --> 00:10:55,190
the object and set its value to x
boom we've implemented array like

570
00:10:55,190 --> 00:10:55,200
boom we've implemented array like
 

571
00:10:55,200 --> 00:10:56,550
boom we've implemented array like
semantics get at

572
00:10:56,550 --> 00:10:56,560
semantics get at
 

573
00:10:56,560 --> 00:11:00,389
semantics get at
i and set at i using

574
00:11:00,389 --> 00:11:00,399
i and set at i using
 

575
00:11:00,399 --> 00:11:02,230
i and set at i using
a set if you've ever programmed in

576
00:11:02,230 --> 00:11:02,240
a set if you've ever programmed in
 

577
00:11:02,240 --> 00:11:03,910
a set if you've ever programmed in
javascript this should feel very

578
00:11:03,910 --> 00:11:03,920
javascript this should feel very
 

579
00:11:03,920 --> 00:11:05,269
javascript this should feel very
familiar because javascript

580
00:11:05,269 --> 00:11:05,279
familiar because javascript
 

581
00:11:05,279 --> 00:11:07,990
familiar because javascript
actually implements arrays it's at least

582
00:11:07,990 --> 00:11:08,000
actually implements arrays it's at least
 

583
00:11:08,000 --> 00:11:10,069
actually implements arrays it's at least
at the conceptual level

584
00:11:10,069 --> 00:11:10,079
at the conceptual level
 

585
00:11:10,079 --> 00:11:13,110
at the conceptual level
as just general mapping types which are

586
00:11:13,110 --> 00:11:13,120
as just general mapping types which are
 

587
00:11:13,120 --> 00:11:14,470
as just general mapping types which are
they call them objects but they are

588
00:11:14,470 --> 00:11:14,480
they call them objects but they are
 

589
00:11:14,480 --> 00:11:16,630
they call them objects but they are
basically sets

590
00:11:16,630 --> 00:11:16,640
basically sets
 

591
00:11:16,640 --> 00:11:18,550
basically sets
and if it's even grosser they convert

592
00:11:18,550 --> 00:11:18,560
and if it's even grosser they convert
 

593
00:11:18,560 --> 00:11:20,870
and if it's even grosser they convert
the integers into strings and then index

594
00:11:20,870 --> 00:11:20,880
the integers into strings and then index
 

595
00:11:20,880 --> 00:11:22,470
the integers into strings and then index
everything by the strings

596
00:11:22,470 --> 00:11:22,480
everything by the strings
 

597
00:11:22,480 --> 00:11:25,350
everything by the strings
semantically anyway implementation

598
00:11:25,350 --> 00:11:25,360
semantically anyway implementation
 

599
00:11:25,360 --> 00:11:27,430
semantically anyway implementation
details can be more efficient but

600
00:11:27,430 --> 00:11:27,440
details can be more efficient but
 

601
00:11:27,440 --> 00:11:28,710
details can be more efficient but
conceptually that's what's going on and

602
00:11:28,710 --> 00:11:28,720
conceptually that's what's going on and
 

603
00:11:28,720 --> 00:11:31,829
conceptually that's what's going on and
so that's the the idea we're doing here

604
00:11:31,829 --> 00:11:31,839
so that's the the idea we're doing here
 

605
00:11:31,839 --> 00:11:36,550
so that's the the idea we're doing here
which seems great um any

606
00:11:36,550 --> 00:11:36,560
which seems great um any
 

607
00:11:36,560 --> 00:11:38,150
which seems great um any
any problem so i have let's see there's

608
00:11:38,150 --> 00:11:38,160
any problem so i have let's see there's
 

609
00:11:38,160 --> 00:11:39,590
any problem so i have let's see there's
insert and delete app

610
00:11:39,590 --> 00:11:39,600
insert and delete app
 

611
00:11:39,600 --> 00:11:41,350
insert and delete app
as i mentioned what i'm going to do for

612
00:11:41,350 --> 00:11:41,360
as i mentioned what i'm going to do for
 

613
00:11:41,360 --> 00:11:43,269
as i mentioned what i'm going to do for
those operations just rebuild the entire

614
00:11:43,269 --> 00:11:43,279
those operations just rebuild the entire
 

615
00:11:43,279 --> 00:11:44,630
those operations just rebuild the entire
structure

616
00:11:44,630 --> 00:11:44,640
structure
 

617
00:11:44,640 --> 00:11:49,190
structure
and just write that briefly

618
00:11:49,190 --> 00:11:49,200

 

619
00:11:49,200 --> 00:11:51,990

basically uh let's just iterate all the

620
00:11:51,990 --> 00:11:52,000
basically uh let's just iterate all the
 

621
00:11:52,000 --> 00:11:54,310
basically uh let's just iterate all the
items

622
00:11:54,310 --> 00:11:54,320
items
 

623
00:11:54,320 --> 00:11:57,829
items
iterate all items

624
00:11:57,829 --> 00:11:57,839
iterate all items
 

625
00:11:57,839 --> 00:12:00,870
iterate all items
um let's say into an array

626
00:12:00,870 --> 00:12:00,880
um let's say into an array
 

627
00:12:00,880 --> 00:12:04,629
um let's say into an array
insert delete one of them

628
00:12:04,629 --> 00:12:04,639
insert delete one of them
 

629
00:12:04,639 --> 00:12:08,069
insert delete one of them
and then rebuild okay

630
00:12:08,069 --> 00:12:08,079
and then rebuild okay
 

631
00:12:08,079 --> 00:12:10,230
and then rebuild okay
if i was writing a pset answer i would

632
00:12:10,230 --> 00:12:10,240
if i was writing a pset answer i would
 

633
00:12:10,240 --> 00:12:11,910
if i was writing a pset answer i would
say a little bit more detail what i

634
00:12:11,910 --> 00:12:11,920
say a little bit more detail what i
 

635
00:12:11,920 --> 00:12:15,110
say a little bit more detail what i
mean in this step um i've done it in the

636
00:12:15,110 --> 00:12:15,120
mean in this step um i've done it in the
 

637
00:12:15,120 --> 00:12:16,310
mean in this step um i've done it in the
notes not that hard

638
00:12:16,310 --> 00:12:16,320
notes not that hard
 

639
00:12:16,320 --> 00:12:18,230
notes not that hard
but we can afford linear expected time i

640
00:12:18,230 --> 00:12:18,240
but we can afford linear expected time i
 

641
00:12:18,240 --> 00:12:20,710
but we can afford linear expected time i
can afford to call build again

642
00:12:20,710 --> 00:12:20,720
can afford to call build again
 

643
00:12:20,720 --> 00:12:22,150
can afford to call build again
i guess technically i'm calling this

644
00:12:22,150 --> 00:12:22,160
i guess technically i'm calling this
 

645
00:12:22,160 --> 00:12:27,110
i guess technically i'm calling this
build sequence build

646
00:12:27,110 --> 00:12:27,120

 

647
00:12:27,120 --> 00:12:28,550

uh so i can afford to just extract

648
00:12:28,550 --> 00:12:28,560
uh so i can afford to just extract
 

649
00:12:28,560 --> 00:12:30,310
uh so i can afford to just extract
things into an array do the linear time

650
00:12:30,310 --> 00:12:30,320
things into an array do the linear time
 

651
00:12:30,320 --> 00:12:31,430
things into an array do the linear time
operation on the array of

652
00:12:31,430 --> 00:12:31,440
operation on the array of
 

653
00:12:31,440 --> 00:12:32,710
operation on the array of
with the shifting and everything and

654
00:12:32,710 --> 00:12:32,720
with the shifting and everything and
 

655
00:12:32,720 --> 00:12:35,230
with the shifting and everything and
then just call build again yeah

656
00:12:35,230 --> 00:12:35,240
then just call build again yeah
 

657
00:12:35,240 --> 00:12:43,910
then just call build again yeah
questions

658
00:12:43,910 --> 00:12:43,920

 

659
00:12:43,920 --> 00:12:46,629

no these are separate definitions yeah

660
00:12:46,629 --> 00:12:46,639
no these are separate definitions yeah
 

661
00:12:46,639 --> 00:12:47,430
no these are separate definitions yeah
sorry they got

662
00:12:47,430 --> 00:12:47,440
sorry they got
 

663
00:12:47,440 --> 00:12:48,949
sorry they got
a little close so this is the definition

664
00:12:48,949 --> 00:12:48,959
a little close so this is the definition
 

665
00:12:48,959 --> 00:12:51,110
a little close so this is the definition
of get at this is a definition of

666
00:12:51,110 --> 00:12:51,120
of get at this is a definition of
 

667
00:12:51,120 --> 00:12:52,710
of get at this is a definition of
sequence build

668
00:12:52,710 --> 00:12:52,720
sequence build
 

669
00:12:52,720 --> 00:12:57,269
sequence build
yeah thanks for asking

670
00:12:57,269 --> 00:12:57,279

 

671
00:12:57,279 --> 00:13:00,790

okay all good yeah can you

672
00:13:00,790 --> 00:13:00,800
okay all good yeah can you
 

673
00:13:00,800 --> 00:13:03,829
okay all good yeah can you
explain the answer explain insert and

674
00:13:03,829 --> 00:13:03,839
explain the answer explain insert and
 

675
00:13:03,839 --> 00:13:04,870
explain the answer explain insert and
delete okay so

676
00:13:04,870 --> 00:13:04,880
delete okay so
 

677
00:13:04,880 --> 00:13:06,870
delete okay so
maybe i should actually write one of

678
00:13:06,870 --> 00:13:06,880
maybe i should actually write one of
 

679
00:13:06,880 --> 00:13:09,110
maybe i should actually write one of
them down

680
00:13:09,110 --> 00:13:09,120
them down
 

681
00:13:09,120 --> 00:13:11,269
them down
or i'll just draw a picture maybe so we

682
00:13:11,269 --> 00:13:11,279
or i'll just draw a picture maybe so we
 

683
00:13:11,279 --> 00:13:13,509
or i'll just draw a picture maybe so we
have this data structure

684
00:13:13,509 --> 00:13:13,519
have this data structure
 

685
00:13:13,519 --> 00:13:17,269
have this data structure
which is now a sequence data structure

686
00:13:17,269 --> 00:13:17,279
which is now a sequence data structure
 

687
00:13:17,279 --> 00:13:20,470
which is now a sequence data structure
represents some sequence of items and my

688
00:13:20,470 --> 00:13:20,480
represents some sequence of items and my
 

689
00:13:20,480 --> 00:13:22,310
represents some sequence of items and my
goal is to say delete

690
00:13:22,310 --> 00:13:22,320
goal is to say delete
 

691
00:13:22,320 --> 00:13:25,110
goal is to say delete
the i item so there's some items in here

692
00:13:25,110 --> 00:13:25,120
the i item so there's some items in here
 

693
00:13:25,120 --> 00:13:26,230
the i item so there's some items in here
x0

694
00:13:26,230 --> 00:13:26,240
x0
 

695
00:13:26,240 --> 00:13:29,350
x0
up to xn minus 1. i want to remove x i

696
00:13:29,350 --> 00:13:29,360
up to xn minus 1. i want to remove x i
 

697
00:13:29,360 --> 00:13:31,750
up to xn minus 1. i want to remove x i
from the sequence

698
00:13:31,750 --> 00:13:31,760
from the sequence
 

699
00:13:31,760 --> 00:13:33,430
from the sequence
or i guess i should drop it this way

700
00:13:33,430 --> 00:13:33,440
or i guess i should drop it this way
 

701
00:13:33,440 --> 00:13:34,949
or i guess i should drop it this way
it's coming out

702
00:13:34,949 --> 00:13:34,959
it's coming out
 

703
00:13:34,959 --> 00:13:36,870
it's coming out
so uh what i'm going to do is first

704
00:13:36,870 --> 00:13:36,880
so uh what i'm going to do is first
 

705
00:13:36,880 --> 00:13:38,629
so uh what i'm going to do is first
extract all the items from the sequence

706
00:13:38,629 --> 00:13:38,639
extract all the items from the sequence
 

707
00:13:38,639 --> 00:13:40,389
extract all the items from the sequence
and i didn't write it but there's a

708
00:13:40,389 --> 00:13:40,399
and i didn't write it but there's a
 

709
00:13:40,399 --> 00:13:43,350
and i didn't write it but there's a
an interface over here called itter

710
00:13:43,350 --> 00:13:43,360
an interface over here called itter
 

711
00:13:43,360 --> 00:13:43,750
an interface over here called itter
which

712
00:13:43,750 --> 00:13:43,760
which
 

713
00:13:43,760 --> 00:13:46,790
which
just gives me all the items in order so

714
00:13:46,790 --> 00:13:46,800
just gives me all the items in order so
 

715
00:13:46,800 --> 00:13:47,990
just gives me all the items in order so
i'm going to extract

716
00:13:47,990 --> 00:13:48,000
i'm going to extract
 

717
00:13:48,000 --> 00:13:55,110
i'm going to extract
this into an array sequence

718
00:13:55,110 --> 00:13:55,120

 

719
00:13:55,120 --> 00:13:57,750

let's say i'll just build a static array

720
00:13:57,750 --> 00:13:57,760
let's say i'll just build a static array
 

721
00:13:57,760 --> 00:13:58,230
let's say i'll just build a static array
of size

722
00:13:58,230 --> 00:13:58,240
of size
 

723
00:13:58,240 --> 00:14:01,350
of size
n i also have a length operation that

724
00:14:01,350 --> 00:14:01,360
n i also have a length operation that
 

725
00:14:01,360 --> 00:14:01,990
n i also have a length operation that
tells me how many

726
00:14:01,990 --> 00:14:02,000
tells me how many
 

727
00:14:02,000 --> 00:14:04,629
tells me how many
items are in here and the the iter

728
00:14:04,629 --> 00:14:04,639
items are in here and the the iter
 

729
00:14:04,639 --> 00:14:06,389
items are in here and the the iter
operation will give me all the items in

730
00:14:06,389 --> 00:14:06,399
operation will give me all the items in
 

731
00:14:06,399 --> 00:14:08,069
operation will give me all the items in
order and so i'll put into my

732
00:14:08,069 --> 00:14:08,079
order and so i'll put into my
 

733
00:14:08,079 --> 00:14:11,509
order and so i'll put into my
array x0 and then x1 and so on as they

734
00:14:11,509 --> 00:14:11,519
array x0 and then x1 and so on as they
 

735
00:14:11,519 --> 00:14:13,509
array x0 and then x1 and so on as they
come out

736
00:14:13,509 --> 00:14:13,519
come out
 

737
00:14:13,519 --> 00:14:17,030
come out
then i go to position i

738
00:14:17,030 --> 00:14:17,040
then i go to position i
 

739
00:14:17,040 --> 00:14:19,829
then i go to position i
and i want to delete that item and shift

740
00:14:19,829 --> 00:14:19,839
and i want to delete that item and shift
 

741
00:14:19,839 --> 00:14:21,910
and i want to delete that item and shift
all the others over this is the

742
00:14:21,910 --> 00:14:21,920
all the others over this is the
 

743
00:14:21,920 --> 00:14:24,150
all the others over this is the
boring this is i think we even said how

744
00:14:24,150 --> 00:14:24,160
boring this is i think we even said how
 

745
00:14:24,160 --> 00:14:25,030
boring this is i think we even said how
to do delete

746
00:14:25,030 --> 00:14:25,040
to do delete
 

747
00:14:25,040 --> 00:14:28,550
to do delete
at in dynamic arrays

748
00:14:28,550 --> 00:14:28,560
at in dynamic arrays
 

749
00:14:28,560 --> 00:14:31,750
at in dynamic arrays
in recitation 2 pretty sure so i'm just

750
00:14:31,750 --> 00:14:31,760
in recitation 2 pretty sure so i'm just
 

751
00:14:31,760 --> 00:14:33,030
in recitation 2 pretty sure so i'm just
mimicking that i'm building

752
00:14:33,030 --> 00:14:33,040
mimicking that i'm building
 

753
00:14:33,040 --> 00:14:35,750
mimicking that i'm building
this just to get the new order of things

754
00:14:35,750 --> 00:14:35,760
this just to get the new order of things
 

755
00:14:35,760 --> 00:14:37,269
this just to get the new order of things
and then i'm applying

756
00:14:37,269 --> 00:14:37,279
and then i'm applying
 

757
00:14:37,279 --> 00:14:39,990
and then i'm applying
via the build operation i'm building a

758
00:14:39,990 --> 00:14:40,000
via the build operation i'm building a
 

759
00:14:40,000 --> 00:14:43,509
via the build operation i'm building a
totally new sequence

760
00:14:43,509 --> 00:14:43,519

 

761
00:14:43,519 --> 00:14:45,430

and that's how i would implement delete

762
00:14:45,430 --> 00:14:45,440
and that's how i would implement delete
 

763
00:14:45,440 --> 00:14:46,949
and that's how i would implement delete
app one way

764
00:14:46,949 --> 00:14:46,959
app one way
 

765
00:14:46,959 --> 00:14:51,350
app one way
there are other ways yeah um

766
00:14:51,350 --> 00:14:51,360

 

767
00:14:51,360 --> 00:14:54,150

how much space is this using uh oh it

768
00:14:54,150 --> 00:14:54,160
how much space is this using uh oh it
 

769
00:14:54,160 --> 00:14:55,430
how much space is this using uh oh it
problem with space if you're inserting

770
00:14:55,430 --> 00:14:55,440
problem with space if you're inserting
 

771
00:14:55,440 --> 00:14:56,870
problem with space if you're inserting
if you're inserting you probably want to

772
00:14:56,870 --> 00:14:56,880
if you're inserting you probably want to
 

773
00:14:56,880 --> 00:14:58,550
if you're inserting you probably want to
allocate a static array of size n plus

774
00:14:58,550 --> 00:14:58,560
allocate a static array of size n plus
 

775
00:14:58,560 --> 00:14:59,990
allocate a static array of size n plus
one you know exactly what's going to

776
00:14:59,990 --> 00:15:00,000
one you know exactly what's going to
 

777
00:15:00,000 --> 00:15:00,790
one you know exactly what's going to
happen

778
00:15:00,790 --> 00:15:00,800
happen
 

779
00:15:00,800 --> 00:15:02,949
happen
so just allocate a little bit bigger

780
00:15:02,949 --> 00:15:02,959
so just allocate a little bit bigger
 

781
00:15:02,959 --> 00:15:04,550
so just allocate a little bit bigger
then you can do the shift

782
00:15:04,550 --> 00:15:04,560
then you can do the shift
 

783
00:15:04,560 --> 00:15:06,470
then you can do the shift
you could also use dynamic arrays but

784
00:15:06,470 --> 00:15:06,480
you could also use dynamic arrays but
 

785
00:15:06,480 --> 00:15:08,629
you could also use dynamic arrays but
then you would get maybe an

786
00:15:08,629 --> 00:15:08,639
then you would get maybe an
 

787
00:15:08,639 --> 00:15:09,829
then you would get maybe an
it's not an amortized bound because

788
00:15:09,829 --> 00:15:09,839
it's not an amortized bound because
 

789
00:15:09,839 --> 00:15:11,910
it's not an amortized bound because
you're only doing one insertion

790
00:15:11,910 --> 00:15:11,920
you're only doing one insertion
 

791
00:15:11,920 --> 00:15:14,230
you're only doing one insertion
the point is this is really easy we can

792
00:15:14,230 --> 00:15:14,240
the point is this is really easy we can
 

793
00:15:14,240 --> 00:15:15,509
the point is this is really easy we can
spend linear time

794
00:15:15,509 --> 00:15:15,519
spend linear time
 

795
00:15:15,519 --> 00:15:18,389
spend linear time
so we can rebuild the we can rebuild

796
00:15:18,389 --> 00:15:18,399
so we can rebuild the we can rebuild
 

797
00:15:18,399 --> 00:15:19,110
so we can rebuild the we can rebuild
this array

798
00:15:19,110 --> 00:15:19,120
this array
 

799
00:15:19,120 --> 00:15:22,069
this array
three times if we want it question uh

800
00:15:22,069 --> 00:15:22,079
three times if we want it question uh
 

801
00:15:22,079 --> 00:15:23,750
three times if we want it question uh
what if you weren't allowed

802
00:15:23,750 --> 00:15:23,760
what if you weren't allowed
 

803
00:15:23,760 --> 00:15:27,670
what if you weren't allowed
externally uh non-constant space

804
00:15:27,670 --> 00:15:27,680
externally uh non-constant space
 

805
00:15:27,680 --> 00:15:29,350
externally uh non-constant space
ah you gotta throw me open problems uh

806
00:15:29,350 --> 00:15:29,360
ah you gotta throw me open problems uh
 

807
00:15:29,360 --> 00:15:30,870
ah you gotta throw me open problems uh
what if you only

808
00:15:30,870 --> 00:15:30,880
what if you only
 

809
00:15:30,880 --> 00:15:36,629
what if you only
have constant extra space uh

810
00:15:36,629 --> 00:15:36,639

 

811
00:15:36,639 --> 00:15:39,269

right then i think we need to use insert

812
00:15:39,269 --> 00:15:39,279
right then i think we need to use insert
 

813
00:15:39,279 --> 00:15:39,990
right then i think we need to use insert
and delete

814
00:15:39,990 --> 00:15:40,000
and delete
 

815
00:15:40,000 --> 00:15:44,069
and delete
so we could good question um

816
00:15:44,069 --> 00:15:44,079
so we could good question um
 

817
00:15:44,079 --> 00:15:46,470
so we could good question um
we could conceptually do this shifting

818
00:15:46,470 --> 00:15:46,480
we could conceptually do this shifting
 

819
00:15:46,480 --> 00:15:48,870
we could conceptually do this shifting
but do it using insert and delete

820
00:15:48,870 --> 00:15:48,880
but do it using insert and delete
 

821
00:15:48,880 --> 00:15:52,470
but do it using insert and delete
so we can so let's do the

822
00:15:52,470 --> 00:15:52,480
so we can so let's do the
 

823
00:15:52,480 --> 00:15:55,990
so we can so let's do the
delete case again so we want to

824
00:15:55,990 --> 00:15:56,000
delete case again so we want to
 

825
00:15:56,000 --> 00:15:58,150
delete case again so we want to
here's x i we want to replace it with x

826
00:15:58,150 --> 00:15:58,160
here's x i we want to replace it with x
 

827
00:15:58,160 --> 00:15:59,509
here's x i we want to replace it with x
i plus 1

828
00:15:59,509 --> 00:15:59,519
i plus 1
 

829
00:15:59,519 --> 00:16:04,310
i plus 1
and so on

830
00:16:04,310 --> 00:16:04,320

 

831
00:16:04,320 --> 00:16:07,749

and so we can start out by deleting

832
00:16:07,749 --> 00:16:07,759
and so we can start out by deleting
 

833
00:16:07,759 --> 00:16:10,790
and so we can start out by deleting
the item with key i that will get rid of

834
00:16:10,790 --> 00:16:10,800
the item with key i that will get rid of
 

835
00:16:10,800 --> 00:16:11,910
the item with key i that will get rid of
this guy

836
00:16:11,910 --> 00:16:11,920
this guy
 

837
00:16:11,920 --> 00:16:14,790
this guy
then we can delete the item with key i

838
00:16:14,790 --> 00:16:14,800
then we can delete the item with key i
 

839
00:16:14,800 --> 00:16:16,230
then we can delete the item with key i
plus one

840
00:16:16,230 --> 00:16:16,240
plus one
 

841
00:16:16,240 --> 00:16:18,710
plus one
give it and that gives us the item and

842
00:16:18,710 --> 00:16:18,720
give it and that gives us the item and
 

843
00:16:18,720 --> 00:16:20,790
give it and that gives us the item and
then we can reassign its key to be

844
00:16:20,790 --> 00:16:20,800
then we can reassign its key to be
 

845
00:16:20,800 --> 00:16:23,590
then we can reassign its key to be
i i instead of i plus 1 and then

846
00:16:23,590 --> 00:16:23,600
i i instead of i plus 1 and then
 

847
00:16:23,600 --> 00:16:25,030
i i instead of i plus 1 and then
reinsert it

848
00:16:25,030 --> 00:16:25,040
reinsert it
 

849
00:16:25,040 --> 00:16:27,430
reinsert it
so we can take this item out it has a

850
00:16:27,430 --> 00:16:27,440
so we can take this item out it has a
 

851
00:16:27,440 --> 00:16:28,550
so we can take this item out it has a
key

852
00:16:28,550 --> 00:16:28,560
key
 

853
00:16:28,560 --> 00:16:31,670
key
which is draw this properly

854
00:16:31,670 --> 00:16:31,680
which is draw this properly
 

855
00:16:31,680 --> 00:16:34,710
which is draw this properly
so we have key i plus 1

856
00:16:34,710 --> 00:16:34,720
so we have key i plus 1
 

857
00:16:34,720 --> 00:16:38,230
so we have key i plus 1
and value x i plus 1

858
00:16:38,230 --> 00:16:38,240
and value x i plus 1
 

859
00:16:38,240 --> 00:16:41,269
and value x i plus 1
stored in this data structure then we

860
00:16:41,269 --> 00:16:41,279
stored in this data structure then we
 

861
00:16:41,279 --> 00:16:44,150
stored in this data structure then we
update the key to i and then we reinsert

862
00:16:44,150 --> 00:16:44,160
update the key to i and then we reinsert
 

863
00:16:44,160 --> 00:16:44,629
update the key to i and then we reinsert
it

864
00:16:44,629 --> 00:16:44,639
it
 

865
00:16:44,639 --> 00:16:46,870
it
and it takes the place of this guy so

866
00:16:46,870 --> 00:16:46,880
and it takes the place of this guy so
 

867
00:16:46,880 --> 00:16:48,470
and it takes the place of this guy so
you could do that you could go down this

868
00:16:48,470 --> 00:16:48,480
you could do that you could go down this
 

869
00:16:48,480 --> 00:16:49,110
you could do that you could go down this
list

870
00:16:49,110 --> 00:16:49,120
list
 

871
00:16:49,120 --> 00:16:50,470
list
and or not the list but you could

872
00:16:50,470 --> 00:16:50,480
and or not the list but you could
 

873
00:16:50,480 --> 00:16:52,550
and or not the list but you could
iterate for i equals

874
00:16:52,550 --> 00:16:52,560
iterate for i equals
 

875
00:16:52,560 --> 00:16:55,110
iterate for i equals
sorry for j equals i to n minus one and

876
00:16:55,110 --> 00:16:55,120
sorry for j equals i to n minus one and
 

877
00:16:55,120 --> 00:16:56,310
sorry for j equals i to n minus one and
for each of those items

878
00:16:56,310 --> 00:16:56,320
for each of those items
 

879
00:16:56,320 --> 00:16:58,470
for each of those items
delete it change its key reinsert it

880
00:16:58,470 --> 00:16:58,480
delete it change its key reinsert it
 

881
00:16:58,480 --> 00:16:59,670
delete it change its key reinsert it
with a new key

882
00:16:59,670 --> 00:16:59,680
with a new key
 

883
00:16:59,680 --> 00:17:01,110
with a new key
and then you don't have to build this

884
00:17:01,110 --> 00:17:01,120
and then you don't have to build this
 

885
00:17:01,120 --> 00:17:02,870
and then you don't have to build this
intermediate data structure

886
00:17:02,870 --> 00:17:02,880
intermediate data structure
 

887
00:17:02,880 --> 00:17:04,150
intermediate data structure
so if you're told to have been in

888
00:17:04,150 --> 00:17:04,160
so if you're told to have been in
 

889
00:17:04,160 --> 00:17:06,069
so if you're told to have been in
myspace great and maybe you think of

890
00:17:06,069 --> 00:17:06,079
myspace great and maybe you think of
 

891
00:17:06,079 --> 00:17:07,669
myspace great and maybe you think of
that as simpler i like to think of this

892
00:17:07,669 --> 00:17:07,679
that as simpler i like to think of this
 

893
00:17:07,679 --> 00:17:08,710
that as simpler i like to think of this
as simpler because like

894
00:17:08,710 --> 00:17:08,720
as simpler because like
 

895
00:17:08,720 --> 00:17:11,029
as simpler because like
the point is i have linear time i can do

896
00:17:11,029 --> 00:17:11,039
the point is i have linear time i can do
 

897
00:17:11,039 --> 00:17:11,990
the point is i have linear time i can do
crazy

898
00:17:11,990 --> 00:17:12,000
crazy
 

899
00:17:12,000 --> 00:17:13,829
crazy
silly very non-data structuresy things

900
00:17:13,829 --> 00:17:13,839
silly very non-data structuresy things
 

901
00:17:13,839 --> 00:17:16,829
silly very non-data structuresy things
where i just start from scratch

902
00:17:16,829 --> 00:17:16,839
where i just start from scratch
 

903
00:17:16,839 --> 00:17:19,829
where i just start from scratch
okay great but there's one more set of

904
00:17:19,829 --> 00:17:19,839
okay great but there's one more set of
 

905
00:17:19,839 --> 00:17:23,510
okay great but there's one more set of
operations insert delete first and last

906
00:17:23,510 --> 00:17:23,520
operations insert delete first and last
 

907
00:17:23,520 --> 00:17:33,350
operations insert delete first and last
are these easy good

908
00:17:33,350 --> 00:17:33,360
are these easy good
 

909
00:17:33,360 --> 00:17:37,029
are these easy good
shall we try uh we can

910
00:17:37,029 --> 00:17:37,039
shall we try uh we can
 

911
00:17:37,039 --> 00:17:40,310
shall we try uh we can
insert last

912
00:17:40,310 --> 00:17:40,320

 

913
00:17:40,320 --> 00:17:44,070

so this is given an item x we want to

914
00:17:44,070 --> 00:17:44,080
so this is given an item x we want to
 

915
00:17:44,080 --> 00:17:45,669
so this is given an item x we want to
add it to the end of the structure so

916
00:17:45,669 --> 00:17:45,679
add it to the end of the structure so
 

917
00:17:45,679 --> 00:17:47,990
add it to the end of the structure so
that means its index is going to be

918
00:17:47,990 --> 00:17:48,000
that means its index is going to be
 

919
00:17:48,000 --> 00:17:48,630
that means its index is going to be
equal to

920
00:17:48,630 --> 00:17:48,640
equal to
 

921
00:17:48,640 --> 00:17:49,909
equal to
because we start at 0 it's going to be

922
00:17:49,909 --> 00:17:49,919
because we start at 0 it's going to be
 

923
00:17:49,919 --> 00:17:51,430
because we start at 0 it's going to be
equal to the length current length of

924
00:17:51,430 --> 00:17:51,440
equal to the length current length of
 

925
00:17:51,440 --> 00:17:52,630
equal to the length current length of
the structure

926
00:17:52,630 --> 00:17:52,640
the structure
 

927
00:17:52,640 --> 00:17:56,789
the structure
so let's just insert a new object

928
00:17:56,789 --> 00:17:56,799
so let's just insert a new object
 

929
00:17:56,799 --> 00:18:00,549
so let's just insert a new object
which has key equal to the length

930
00:18:00,549 --> 00:18:00,559
which has key equal to the length
 

931
00:18:00,559 --> 00:18:04,230
which has key equal to the length
and it has value equal to x

932
00:18:04,230 --> 00:18:04,240
and it has value equal to x
 

933
00:18:04,240 --> 00:18:06,789
and it has value equal to x
we're done delete last similar just

934
00:18:06,789 --> 00:18:06,799
we're done delete last similar just
 

935
00:18:06,799 --> 00:18:08,549
we're done delete last similar just
delete the item with key

936
00:18:08,549 --> 00:18:08,559
delete the item with key
 

937
00:18:08,559 --> 00:18:16,950
delete the item with key
length minus one okay what about first

938
00:18:16,950 --> 00:18:16,960

 

939
00:18:16,960 --> 00:18:18,390

this is supposed to add x to the

940
00:18:18,390 --> 00:18:18,400
this is supposed to add x to the
 

941
00:18:18,400 --> 00:18:22,710
this is supposed to add x to the
beginning of my sequence

942
00:18:22,710 --> 00:18:22,720

 

943
00:18:22,720 --> 00:18:25,029

well now i realize i have a problem

944
00:18:25,029 --> 00:18:25,039
well now i realize i have a problem
 

945
00:18:25,039 --> 00:18:25,830
well now i realize i have a problem
because

946
00:18:25,830 --> 00:18:25,840
because
 

947
00:18:25,840 --> 00:18:29,750
because
i want this new item to have key 0

948
00:18:29,750 --> 00:18:29,760
i want this new item to have key 0
 

949
00:18:29,760 --> 00:18:32,870
i want this new item to have key 0
because after i do an insert first get

950
00:18:32,870 --> 00:18:32,880
because after i do an insert first get
 

951
00:18:32,880 --> 00:18:35,270
because after i do an insert first get
out of 0 should return this item

952
00:18:35,270 --> 00:18:35,280
out of 0 should return this item
 

953
00:18:35,280 --> 00:18:38,070
out of 0 should return this item
but i already have an item with key 0

954
00:18:38,070 --> 00:18:38,080
but i already have an item with key 0
 

955
00:18:38,080 --> 00:18:39,830
but i already have an item with key 0
and an item with key 1 and an item with

956
00:18:39,830 --> 00:18:39,840
and an item with key 1 and an item with
 

957
00:18:39,840 --> 00:18:40,070
and an item with key 1 and an item with
key

958
00:18:40,070 --> 00:18:40,080
key
 

959
00:18:40,080 --> 00:18:42,390
key
2 and so on down the way and so if i

960
00:18:42,390 --> 00:18:42,400
2 and so on down the way and so if i
 

961
00:18:42,400 --> 00:18:44,549
2 and so on down the way and so if i
wanted to give x a key of 0 i have to

962
00:18:44,549 --> 00:18:44,559
wanted to give x a key of 0 i have to
 

963
00:18:44,559 --> 00:18:45,669
wanted to give x a key of 0 i have to
shift the keys of

964
00:18:45,669 --> 00:18:45,679
shift the keys of
 

965
00:18:45,679 --> 00:18:47,190
shift the keys of
all of those items just like we were

966
00:18:47,190 --> 00:18:47,200
all of those items just like we were
 

967
00:18:47,200 --> 00:18:48,870
all of those items just like we were
doing here and that's going to take

968
00:18:48,870 --> 00:18:48,880
doing here and that's going to take
 

969
00:18:48,880 --> 00:18:50,789
doing here and that's going to take
linear time

970
00:18:50,789 --> 00:18:50,799
linear time
 

971
00:18:50,799 --> 00:18:52,870
linear time
but we're supposed to do this in

972
00:18:52,870 --> 00:18:52,880
but we're supposed to do this in
 

973
00:18:52,880 --> 00:18:55,430
but we're supposed to do this in
constant expected amortized time

974
00:18:55,430 --> 00:18:55,440
constant expected amortized time
 

975
00:18:55,440 --> 00:18:59,510
constant expected amortized time
so that's no good so this idea

976
00:18:59,510 --> 00:18:59,520
so that's no good so this idea
 

977
00:18:59,520 --> 00:19:01,750
so that's no good so this idea
is not enough it's not a bad idea it's

978
00:19:01,750 --> 00:19:01,760
is not enough it's not a bad idea it's
 

979
00:19:01,760 --> 00:19:03,029
is not enough it's not a bad idea it's
still a good idea

980
00:19:03,029 --> 00:19:03,039
still a good idea
 

981
00:19:03,039 --> 00:19:04,789
still a good idea
but it's no longer what we actually want

982
00:19:04,789 --> 00:19:04,799
but it's no longer what we actually want
 

983
00:19:04,799 --> 00:19:06,710
but it's no longer what we actually want
to do it's only

984
00:19:06,710 --> 00:19:06,720
to do it's only
 

985
00:19:06,720 --> 00:19:10,470
to do it's only
morally what we want to do so

986
00:19:10,470 --> 00:19:10,480
morally what we want to do so
 

987
00:19:10,480 --> 00:19:13,029
morally what we want to do so
what do you have any thoughts on how we

988
00:19:13,029 --> 00:19:13,039
what do you have any thoughts on how we
 

989
00:19:13,039 --> 00:19:15,669
what do you have any thoughts on how we
might get around this problem

990
00:19:15,669 --> 00:19:15,679
might get around this problem
 

991
00:19:15,679 --> 00:19:17,510
might get around this problem
seems like inserting at position zero i

992
00:19:17,510 --> 00:19:17,520
seems like inserting at position zero i
 

993
00:19:17,520 --> 00:19:19,190
seems like inserting at position zero i
need to shift everything down

994
00:19:19,190 --> 00:19:19,200
need to shift everything down
 

995
00:19:19,200 --> 00:19:28,549
need to shift everything down
linear time that really sucks

996
00:19:28,549 --> 00:19:28,559

 

997
00:19:28,559 --> 00:19:31,830

yep um you could

998
00:19:31,830 --> 00:19:31,840
yep um you could
 

999
00:19:31,840 --> 00:19:35,029
yep um you could
create some sort of link to something

1000
00:19:35,029 --> 00:19:35,039
create some sort of link to something
 

1001
00:19:35,039 --> 00:19:36,230
create some sort of link to something
else

1002
00:19:36,230 --> 00:19:36,240
else
 

1003
00:19:36,240 --> 00:19:37,669
else
link this data structure with another

1004
00:19:37,669 --> 00:19:37,679
link this data structure with another
 

1005
00:19:37,679 --> 00:19:39,990
link this data structure with another
one so we could build more than one set

1006
00:19:39,990 --> 00:19:40,000
one so we could build more than one set
 

1007
00:19:40,000 --> 00:19:42,390
one so we could build more than one set
that's certainly allowed

1008
00:19:42,390 --> 00:19:42,400
that's certainly allowed
 

1009
00:19:42,400 --> 00:19:45,990
that's certainly allowed
uh i don't know how to

1010
00:19:45,990 --> 00:19:46,000
uh i don't know how to
 

1011
00:19:46,000 --> 00:19:47,990
uh i don't know how to
do oh i see you're saying maybe build a

1012
00:19:47,990 --> 00:19:48,000
do oh i see you're saying maybe build a
 

1013
00:19:48,000 --> 00:19:49,909
do oh i see you're saying maybe build a
whole another structure for the

1014
00:19:49,909 --> 00:19:49,919
whole another structure for the
 

1015
00:19:49,919 --> 00:19:52,950
whole another structure for the
items that come before xero yeah yeah

1016
00:19:52,950 --> 00:19:52,960
items that come before xero yeah yeah
 

1017
00:19:52,960 --> 00:19:56,390
items that come before xero yeah yeah
actually that would work i think

1018
00:19:56,390 --> 00:19:56,400

 

1019
00:19:56,400 --> 00:19:58,630

maybe uh it's like in the pset then you

1020
00:19:58,630 --> 00:19:58,640
maybe uh it's like in the pset then you
 

1021
00:19:58,640 --> 00:20:00,310
maybe uh it's like in the pset then you
have to deal with when

1022
00:20:00,310 --> 00:20:00,320
have to deal with when
 

1023
00:20:00,320 --> 00:20:02,070
have to deal with when
if you delete one of them it becomes

1024
00:20:02,070 --> 00:20:02,080
if you delete one of them it becomes
 

1025
00:20:02,080 --> 00:20:04,230
if you delete one of them it becomes
empty then things get messy

1026
00:20:04,230 --> 00:20:04,240
empty then things get messy
 

1027
00:20:04,240 --> 00:20:05,669
empty then things get messy
delete first is also going to be a

1028
00:20:05,669 --> 00:20:05,679
delete first is also going to be a
 

1029
00:20:05,679 --> 00:20:07,830
delete first is also going to be a
problem because i delete the beginning

1030
00:20:07,830 --> 00:20:07,840
problem because i delete the beginning
 

1031
00:20:07,840 --> 00:20:11,750
problem because i delete the beginning
of this data structure

1032
00:20:11,750 --> 00:20:11,760

 

1033
00:20:11,760 --> 00:20:14,390

then i lose my zero item and i want the

1034
00:20:14,390 --> 00:20:14,400
then i lose my zero item and i want the
 

1035
00:20:14,400 --> 00:20:15,990
then i lose my zero item and i want the
new zero item to be the

1036
00:20:15,990 --> 00:20:16,000
new zero item to be the
 

1037
00:20:16,000 --> 00:20:17,990
new zero item to be the
one item that's again all the indices

1038
00:20:17,990 --> 00:20:18,000
one item that's again all the indices
 

1039
00:20:18,000 --> 00:20:19,510
one item that's again all the indices
shift so delete and

1040
00:20:19,510 --> 00:20:19,520
shift so delete and
 

1041
00:20:19,520 --> 00:20:21,270
shift so delete and
inserting at the first is heart so we

1042
00:20:21,270 --> 00:20:21,280
inserting at the first is heart so we
 

1043
00:20:21,280 --> 00:20:23,510
inserting at the first is heart so we
could do that trick like in the pset but

1044
00:20:23,510 --> 00:20:23,520
could do that trick like in the pset but
 

1045
00:20:23,520 --> 00:20:25,510
could do that trick like in the pset but
or in like in less problem session and

1046
00:20:25,510 --> 00:20:25,520
or in like in less problem session and
 

1047
00:20:25,520 --> 00:20:27,350
or in like in less problem session and
so on um

1048
00:20:27,350 --> 00:20:27,360
so on um
 

1049
00:20:27,360 --> 00:20:31,430
so on um
but there's a much simpler idea

1050
00:20:31,430 --> 00:20:31,440

 

1051
00:20:31,440 --> 00:20:34,390

can you have an extra very to keep track

1052
00:20:34,390 --> 00:20:34,400
can you have an extra very to keep track
 

1053
00:20:34,400 --> 00:20:34,789
can you have an extra very to keep track
where

1054
00:20:34,789 --> 00:20:34,799
where
 

1055
00:20:34,799 --> 00:20:38,070
where
is that nice i have an extra variable

1056
00:20:38,070 --> 00:20:38,080
is that nice i have an extra variable
 

1057
00:20:38,080 --> 00:20:52,390
is that nice i have an extra variable
to keep track of where the beginning is

1058
00:20:52,390 --> 00:20:52,400

 

1059
00:20:52,400 --> 00:20:56,070

call this first this is going to be

1060
00:20:56,070 --> 00:20:56,080
call this first this is going to be
 

1061
00:20:56,080 --> 00:20:59,909
call this first this is going to be
the key

1062
00:20:59,909 --> 00:20:59,919

 

1063
00:20:59,919 --> 00:21:04,230

of the uh first

1064
00:21:04,230 --> 00:21:04,240
of the uh first
 

1065
00:21:04,240 --> 00:21:07,990
of the uh first
item index zero

1066
00:21:07,990 --> 00:21:08,000
item index zero
 

1067
00:21:08,000 --> 00:21:09,990
item index zero
another way to say this is let's just

1068
00:21:09,990 --> 00:21:10,000
another way to say this is let's just
 

1069
00:21:10,000 --> 00:21:12,390
another way to say this is let's just
use negative integers

1070
00:21:12,390 --> 00:21:12,400
use negative integers
 

1071
00:21:12,400 --> 00:21:15,110
use negative integers
right set sets work for any keys any

1072
00:21:15,110 --> 00:21:15,120
right set sets work for any keys any
 

1073
00:21:15,120 --> 00:21:16,549
right set sets work for any keys any
integer keys okay actually we

1074
00:21:16,549 --> 00:21:16,559
integer keys okay actually we
 

1075
00:21:16,559 --> 00:21:18,149
integer keys okay actually we
technically said they should use keys

1076
00:21:18,149 --> 00:21:18,159
technically said they should use keys
 

1077
00:21:18,159 --> 00:21:19,590
technically said they should use keys
zero to u minus one

1078
00:21:19,590 --> 00:21:19,600
zero to u minus one
 

1079
00:21:19,600 --> 00:21:21,990
zero to u minus one
but then uh if you have negative numbers

1080
00:21:21,990 --> 00:21:22,000
but then uh if you have negative numbers
 

1081
00:21:22,000 --> 00:21:22,870
but then uh if you have negative numbers
you can

1082
00:21:22,870 --> 00:21:22,880
you can
 

1083
00:21:22,880 --> 00:21:27,190
you can
easily fold do you know the string

1084
00:21:27,190 --> 00:21:27,200
easily fold do you know the string
 

1085
00:21:27,200 --> 00:21:28,789
easily fold do you know the string
ah python negative numbers means

1086
00:21:28,789 --> 00:21:28,799
ah python negative numbers means
 

1087
00:21:28,799 --> 00:21:30,390
ah python negative numbers means
something else but we're not using the

1088
00:21:30,390 --> 00:21:30,400
something else but we're not using the
 

1089
00:21:30,400 --> 00:21:32,070
something else but we're not using the
python interface we're using our custom

1090
00:21:32,070 --> 00:21:32,080
python interface we're using our custom
 

1091
00:21:32,080 --> 00:21:33,590
python interface we're using our custom
magical

1092
00:21:33,590 --> 00:21:33,600
magical
 

1093
00:21:33,600 --> 00:21:35,590
magical
set interface which we show how to

1094
00:21:35,590 --> 00:21:35,600
set interface which we show how to
 

1095
00:21:35,600 --> 00:21:37,270
set interface which we show how to
implement in recitation nuts

1096
00:21:37,270 --> 00:21:37,280
implement in recitation nuts
 

1097
00:21:37,280 --> 00:21:40,390
implement in recitation nuts
which can take an arbitrary key it

1098
00:21:40,390 --> 00:21:40,400
which can take an arbitrary key it
 

1099
00:21:40,400 --> 00:21:42,070
which can take an arbitrary key it
hashes that key

1100
00:21:42,070 --> 00:21:42,080
hashes that key
 

1101
00:21:42,080 --> 00:21:45,110
hashes that key
and you know finds a place to put

1102
00:21:45,110 --> 00:21:45,120
and you know finds a place to put
 

1103
00:21:45,120 --> 00:21:47,590
and you know finds a place to put
that item so we're not actually storing

1104
00:21:47,590 --> 00:21:47,600
that item so we're not actually storing
 

1105
00:21:47,600 --> 00:21:48,630
that item so we're not actually storing
things in order here we're storing

1106
00:21:48,630 --> 00:21:48,640
things in order here we're storing
 

1107
00:21:48,640 --> 00:21:49,750
things in order here we're storing
things in a hash table

1108
00:21:49,750 --> 00:21:49,760
things in a hash table
 

1109
00:21:49,760 --> 00:21:51,430
things in a hash table
but we're not supposed to get into the

1110
00:21:51,430 --> 00:21:51,440
but we're not supposed to get into the
 

1111
00:21:51,440 --> 00:21:52,789
but we're not supposed to get into the
implementation details

1112
00:21:52,789 --> 00:21:52,799
implementation details
 

1113
00:21:52,799 --> 00:21:54,630
implementation details
i think the way we presented hashing

1114
00:21:54,630 --> 00:21:54,640
i think the way we presented hashing
 

1115
00:21:54,640 --> 00:21:55,909
i think the way we presented hashing
with our

1116
00:21:55,909 --> 00:21:55,919
with our
 

1117
00:21:55,919 --> 00:21:57,669
with our
universal hash functions we only allowed

1118
00:21:57,669 --> 00:21:57,679
universal hash functions we only allowed
 

1119
00:21:57,679 --> 00:21:59,029
universal hash functions we only allowed
positive numbers

1120
00:21:59,029 --> 00:21:59,039
positive numbers
 

1121
00:21:59,039 --> 00:22:01,750
positive numbers
so maybe technically i should point out

1122
00:22:01,750 --> 00:22:01,760
so maybe technically i should point out
 

1123
00:22:01,760 --> 00:22:05,430
so maybe technically i should point out
if you have

1124
00:22:05,430 --> 00:22:05,440

 

1125
00:22:05,440 --> 00:22:08,070

positive and negative numbers you can

1126
00:22:08,070 --> 00:22:08,080
positive and negative numbers you can
 

1127
00:22:08,080 --> 00:22:10,230
positive and negative numbers you can
fold this in half

1128
00:22:10,230 --> 00:22:10,240
fold this in half
 

1129
00:22:10,240 --> 00:22:13,270
fold this in half
by mapping zero to zero one to

1130
00:22:13,270 --> 00:22:13,280
by mapping zero to zero one to
 

1131
00:22:13,280 --> 00:22:17,190
by mapping zero to zero one to
two two to four spreading it out

1132
00:22:17,190 --> 00:22:17,200
two two to four spreading it out
 

1133
00:22:17,200 --> 00:22:19,510
two two to four spreading it out
and then you can take minus one and map

1134
00:22:19,510 --> 00:22:19,520
and then you can take minus one and map
 

1135
00:22:19,520 --> 00:22:20,789
and then you can take minus one and map
it to plus one

1136
00:22:20,789 --> 00:22:20,799
it to plus one
 

1137
00:22:20,799 --> 00:22:23,590
it to plus one
and minus two and map it to plus three

1138
00:22:23,590 --> 00:22:23,600
and minus two and map it to plus three
 

1139
00:22:23,600 --> 00:22:24,470
and minus two and map it to plus three
so this is like

1140
00:22:24,470 --> 00:22:24,480
so this is like
 

1141
00:22:24,480 --> 00:22:26,310
so this is like
uh multiplying each of these guys by 2

1142
00:22:26,310 --> 00:22:26,320
uh multiplying each of these guys by 2
 

1143
00:22:26,320 --> 00:22:27,909
uh multiplying each of these guys by 2
and multiplying each of these guys by

1144
00:22:27,909 --> 00:22:27,919
and multiplying each of these guys by
 

1145
00:22:27,919 --> 00:22:30,070
and multiplying each of these guys by
minus 2 and adding 1.

1146
00:22:30,070 --> 00:22:30,080
minus 2 and adding 1.
 

1147
00:22:30,080 --> 00:22:33,430
minus 2 and adding 1.
and then you get non-negative

1148
00:22:33,430 --> 00:22:33,440
and then you get non-negative
 

1149
00:22:33,440 --> 00:22:37,830
and then you get non-negative
integers out of all integers this is a

1150
00:22:37,830 --> 00:22:37,840
integers out of all integers this is a
 

1151
00:22:37,840 --> 00:22:40,149
integers out of all integers this is a
typical math trick for showing that the

1152
00:22:40,149 --> 00:22:40,159
typical math trick for showing that the
 

1153
00:22:40,159 --> 00:22:41,909
typical math trick for showing that the
number of integers is equal to the

1154
00:22:41,909 --> 00:22:41,919
number of integers is equal to the
 

1155
00:22:41,919 --> 00:22:42,549
number of integers is equal to the
number of

1156
00:22:42,549 --> 00:22:42,559
number of
 

1157
00:22:42,559 --> 00:22:44,470
number of
non-negative integers which may seem

1158
00:22:44,470 --> 00:22:44,480
non-negative integers which may seem
 

1159
00:22:44,480 --> 00:22:45,830
non-negative integers which may seem
weird to you but they're both

1160
00:22:45,830 --> 00:22:45,840
weird to you but they're both
 

1161
00:22:45,840 --> 00:22:49,110
weird to you but they're both
countably infinite so you could

1162
00:22:49,110 --> 00:22:49,120
countably infinite so you could
 

1163
00:22:49,120 --> 00:22:51,270
countably infinite so you could
if your structure only supports negative

1164
00:22:51,270 --> 00:22:51,280
if your structure only supports negative
 

1165
00:22:51,280 --> 00:22:53,029
if your structure only supports negative
keys you could map negative keys in this

1166
00:22:53,029 --> 00:22:53,039
keys you could map negative keys in this
 

1167
00:22:53,039 --> 00:22:54,549
keys you could map negative keys in this
way and

1168
00:22:54,549 --> 00:22:54,559
way and
 

1169
00:22:54,559 --> 00:22:57,270
way and
throw them into the hash table okay so

1170
00:22:57,270 --> 00:22:57,280
throw them into the hash table okay so
 

1171
00:22:57,280 --> 00:22:58,310
throw them into the hash table okay so
now

1172
00:22:58,310 --> 00:22:58,320
now
 

1173
00:22:58,320 --> 00:23:00,500
now
i allow negative things for

1174
00:23:00,500 --> 00:23:00,510
i allow negative things for
 

1175
00:23:00,510 --> 00:23:03,350
i allow negative things for
[Applause]

1176
00:23:03,350 --> 00:23:03,360
[Applause]
 

1177
00:23:03,360 --> 00:23:05,590
[Applause]
like that and so great if i want to

1178
00:23:05,590 --> 00:23:05,600
like that and so great if i want to
 

1179
00:23:05,600 --> 00:23:07,190
like that and so great if i want to
insert at the beginning

1180
00:23:07,190 --> 00:23:07,200
insert at the beginning
 

1181
00:23:07,200 --> 00:23:12,789
insert at the beginning
what i can do is just decrement my

1182
00:23:12,789 --> 00:23:12,799

 

1183
00:23:12,799 --> 00:23:14,710

first variable which is keeping track of

1184
00:23:14,710 --> 00:23:14,720
first variable which is keeping track of
 

1185
00:23:14,720 --> 00:23:16,310
first variable which is keeping track of
the index so initially first is going to

1186
00:23:16,310 --> 00:23:16,320
the index so initially first is going to
 

1187
00:23:16,320 --> 00:23:17,830
the index so initially first is going to
be 0

1188
00:23:17,830 --> 00:23:17,840
be 0
 

1189
00:23:17,840 --> 00:23:20,710
be 0
so i'm going to add into my build first

1190
00:23:20,710 --> 00:23:20,720
so i'm going to add into my build first
 

1191
00:23:20,720 --> 00:23:21,430
so i'm going to add into my build first
i'm going to say

1192
00:23:21,430 --> 00:23:21,440
i'm going to say
 

1193
00:23:21,440 --> 00:23:25,270
i'm going to say
first equals zero

1194
00:23:25,270 --> 00:23:25,280
first equals zero
 

1195
00:23:25,280 --> 00:23:27,669
first equals zero
because i start with key zero and when i

1196
00:23:27,669 --> 00:23:27,679
because i start with key zero and when i
 

1197
00:23:27,679 --> 00:23:29,510
because i start with key zero and when i
initially build a structure

1198
00:23:29,510 --> 00:23:29,520
initially build a structure
 

1199
00:23:29,520 --> 00:23:30,950
initially build a structure
and if i wanna if i need more room

1200
00:23:30,950 --> 00:23:30,960
and if i wanna if i need more room
 

1201
00:23:30,960 --> 00:23:33,510
and if i wanna if i need more room
before zero i just set first to minus

1202
00:23:33,510 --> 00:23:33,520
before zero i just set first to minus
 

1203
00:23:33,520 --> 00:23:34,149
before zero i just set first to minus
one

1204
00:23:34,149 --> 00:23:34,159
one
 

1205
00:23:34,159 --> 00:23:36,230
one
and if i already have minus one element

1206
00:23:36,230 --> 00:23:36,240
and if i already have minus one element
 

1207
00:23:36,240 --> 00:23:38,230
and if i already have minus one element
i'll decrement it to minus two decrement

1208
00:23:38,230 --> 00:23:38,240
i'll decrement it to minus two decrement
 

1209
00:23:38,240 --> 00:23:40,070
i'll decrement it to minus two decrement
means decrease by one

1210
00:23:40,070 --> 00:23:40,080
means decrease by one
 

1211
00:23:40,080 --> 00:23:41,750
means decrease by one
it shows my assembly language

1212
00:23:41,750 --> 00:23:41,760
it shows my assembly language
 

1213
00:23:41,760 --> 00:23:43,590
it shows my assembly language
programming this is usually a built-in

1214
00:23:43,590 --> 00:23:43,600
programming this is usually a built-in
 

1215
00:23:43,600 --> 00:23:44,310
programming this is usually a built-in
operation on

1216
00:23:44,310 --> 00:23:44,320
operation on
 

1217
00:23:44,320 --> 00:23:49,990
operation on
most computers and then i can insert

1218
00:23:49,990 --> 00:23:50,000
most computers and then i can insert
 

1219
00:23:50,000 --> 00:23:54,390
most computers and then i can insert
an item with key first

1220
00:23:54,390 --> 00:23:54,400

 

1221
00:23:54,400 --> 00:23:58,710

and value x

1222
00:23:58,710 --> 00:23:58,720

 

1223
00:23:58,720 --> 00:24:00,310

right now if i want to delete the first

1224
00:24:00,310 --> 00:24:00,320
right now if i want to delete the first
 

1225
00:24:00,320 --> 00:24:01,909
right now if i want to delete the first
item i would delete

1226
00:24:01,909 --> 00:24:01,919
item i would delete
 

1227
00:24:01,919 --> 00:24:03,430
item i would delete
the item with key first and then

1228
00:24:03,430 --> 00:24:03,440
the item with key first and then
 

1229
00:24:03,440 --> 00:24:05,750
the item with key first and then
increment first

1230
00:24:05,750 --> 00:24:05,760
increment first
 

1231
00:24:05,760 --> 00:24:07,909
increment first
and now all of my operations have to

1232
00:24:07,909 --> 00:24:07,919
and now all of my operations have to
 

1233
00:24:07,919 --> 00:24:09,350
and now all of my operations have to
change a little bit let me use another

1234
00:24:09,350 --> 00:24:09,360
change a little bit let me use another
 

1235
00:24:09,360 --> 00:24:10,470
change a little bit let me use another
color

1236
00:24:10,470 --> 00:24:10,480
color
 

1237
00:24:10,480 --> 00:24:12,789
color
um because i was implicitly assuming

1238
00:24:12,789 --> 00:24:12,799
um because i was implicitly assuming
 

1239
00:24:12,799 --> 00:24:15,190
um because i was implicitly assuming
here that all my indices started at i

1240
00:24:15,190 --> 00:24:15,200
here that all my indices started at i
 

1241
00:24:15,200 --> 00:24:18,310
here that all my indices started at i
but now they start at first they

1242
00:24:18,310 --> 00:24:18,320
but now they start at first they
 

1243
00:24:18,320 --> 00:24:21,590
but now they start at first they
index zero maps to key

1244
00:24:21,590 --> 00:24:21,600
index zero maps to key
 

1245
00:24:21,600 --> 00:24:24,549
index zero maps to key
first and so the right thing to do here

1246
00:24:24,549 --> 00:24:24,559
first and so the right thing to do here
 

1247
00:24:24,559 --> 00:24:25,029
first and so the right thing to do here
is

1248
00:24:25,029 --> 00:24:25,039
is
 

1249
00:24:25,039 --> 00:24:28,870
is
plus first

1250
00:24:28,870 --> 00:24:28,880

 

1251
00:24:28,880 --> 00:24:31,990

and plus first basically add a whole

1252
00:24:31,990 --> 00:24:32,000
and plus first basically add a whole
 

1253
00:24:32,000 --> 00:24:33,750
and plus first basically add a whole
bunch of plus first

1254
00:24:33,750 --> 00:24:33,760
bunch of plus first
 

1255
00:24:33,760 --> 00:24:36,950
bunch of plus first
throughout this one's probably fine if

1256
00:24:36,950 --> 00:24:36,960
throughout this one's probably fine if
 

1257
00:24:36,960 --> 00:24:38,950
throughout this one's probably fine if
i'm globally rebuilding i can reassign

1258
00:24:38,950 --> 00:24:38,960
i'm globally rebuilding i can reassign
 

1259
00:24:38,960 --> 00:24:40,390
i'm globally rebuilding i can reassign
all my labels

1260
00:24:40,390 --> 00:24:40,400
all my labels
 

1261
00:24:40,400 --> 00:24:43,909
all my labels
but this one should be first plus

1262
00:24:43,909 --> 00:24:43,919
but this one should be first plus
 

1263
00:24:43,919 --> 00:24:47,590
but this one should be first plus
plus length

1264
00:24:47,590 --> 00:24:47,600
plus length
 

1265
00:24:47,600 --> 00:24:50,149
plus length
okay so just by keeping track of where

1266
00:24:50,149 --> 00:24:50,159
okay so just by keeping track of where
 

1267
00:24:50,159 --> 00:24:51,029
okay so just by keeping track of where
my

1268
00:24:51,029 --> 00:24:51,039
my
 

1269
00:24:51,039 --> 00:24:54,149
my
keys are starting i can do this shifting

1270
00:24:54,149 --> 00:24:54,159
keys are starting i can do this shifting
 

1271
00:24:54,159 --> 00:24:56,390
keys are starting i can do this shifting
and not have to worry about stuff

1272
00:24:56,390 --> 00:24:56,400
and not have to worry about stuff
 

1273
00:24:56,400 --> 00:24:57,909
and not have to worry about stuff
and this is a lot easier than having to

1274
00:24:57,909 --> 00:24:57,919
and this is a lot easier than having to
 

1275
00:24:57,919 --> 00:24:59,430
and this is a lot easier than having to
worry about

1276
00:24:59,430 --> 00:24:59,440
worry about
 

1277
00:24:59,440 --> 00:25:01,909
worry about
maintaining two structures and keeping

1278
00:25:01,909 --> 00:25:01,919
maintaining two structures and keeping
 

1279
00:25:01,919 --> 00:25:04,870
maintaining two structures and keeping
them both non-empty and stuff like that

1280
00:25:04,870 --> 00:25:04,880
them both non-empty and stuff like that
 

1281
00:25:04,880 --> 00:25:07,909
them both non-empty and stuff like that
because of if i assume my set has this

1282
00:25:07,909 --> 00:25:07,919
because of if i assume my set has this
 

1283
00:25:07,919 --> 00:25:08,710
because of if i assume my set has this
power

1284
00:25:08,710 --> 00:25:08,720
power
 

1285
00:25:08,720 --> 00:25:10,710
power
of dealing with negative integers and

1286
00:25:10,710 --> 00:25:10,720
of dealing with negative integers and
 

1287
00:25:10,720 --> 00:25:21,990
of dealing with negative integers and
strings and whatever else

1288
00:25:21,990 --> 00:25:22,000

 

1289
00:25:22,000 --> 00:25:24,070

oh why didn't i use a linked list

1290
00:25:24,070 --> 00:25:24,080
oh why didn't i use a linked list
 

1291
00:25:24,080 --> 00:25:26,630
oh why didn't i use a linked list
because

1292
00:25:26,630 --> 00:25:26,640
because
 

1293
00:25:26,640 --> 00:25:29,350
because
this linked lists are very bad at get

1294
00:25:29,350 --> 00:25:29,360
this linked lists are very bad at get
 

1295
00:25:29,360 --> 00:25:35,350
this linked lists are very bad at get
and set at a given index

1296
00:25:35,350 --> 00:25:35,360

 

1297
00:25:35,360 --> 00:25:36,870

this is not a linked list this is just

1298
00:25:36,870 --> 00:25:36,880
this is not a linked list this is just
 

1299
00:25:36,880 --> 00:25:38,470
this is not a linked list this is just
storing a single number as

1300
00:25:38,470 --> 00:25:38,480
storing a single number as
 

1301
00:25:38,480 --> 00:25:40,950
storing a single number as
integer in your data structure that says

1302
00:25:40,950 --> 00:25:40,960
integer in your data structure that says
 

1303
00:25:40,960 --> 00:25:42,710
integer in your data structure that says
what is the smallest key in my data

1304
00:25:42,710 --> 00:25:42,720
what is the smallest key in my data
 

1305
00:25:42,720 --> 00:25:44,470
what is the smallest key in my data
structure

1306
00:25:44,470 --> 00:25:44,480
structure
 

1307
00:25:44,480 --> 00:25:48,310
structure
that's all it does it's a it's a counter

1308
00:25:48,310 --> 00:25:48,320
that's all it does it's a it's a counter
 

1309
00:25:48,320 --> 00:25:50,549
that's all it does it's a it's a counter
okay so data structure keeps track of

1310
00:25:50,549 --> 00:25:50,559
okay so data structure keeps track of
 

1311
00:25:50,559 --> 00:25:51,750
okay so data structure keeps track of
its length and it keeps track of the

1312
00:25:51,750 --> 00:25:51,760
its length and it keeps track of the
 

1313
00:25:51,760 --> 00:25:52,789
its length and it keeps track of the
minimum key

1314
00:25:52,789 --> 00:25:52,799
minimum key
 

1315
00:25:52,799 --> 00:25:54,310
minimum key
and so it will always consist the

1316
00:25:54,310 --> 00:25:54,320
and so it will always consist the
 

1317
00:25:54,320 --> 00:25:55,990
and so it will always consist the
invariant is you'll always have keys

1318
00:25:55,990 --> 00:25:56,000
invariant is you'll always have keys
 

1319
00:25:56,000 --> 00:25:59,110
invariant is you'll always have keys
from first up to first plus length minus

1320
00:25:59,110 --> 00:25:59,120
from first up to first plus length minus
 

1321
00:25:59,120 --> 00:26:00,230
from first up to first plus length minus
one

1322
00:26:00,230 --> 00:26:00,240
one
 

1323
00:26:00,240 --> 00:26:04,630
one
and that's what we're exploiting here

1324
00:26:04,630 --> 00:26:04,640

 

1325
00:26:04,640 --> 00:26:06,310

we have no idea where first will be it

1326
00:26:06,310 --> 00:26:06,320
we have no idea where first will be it
 

1327
00:26:06,320 --> 00:26:08,230
we have no idea where first will be it
depends how many operations you've done

1328
00:26:08,230 --> 00:26:08,240
depends how many operations you've done
 

1329
00:26:08,240 --> 00:26:09,750
depends how many operations you've done
how many inserts at the beginning and so

1330
00:26:09,750 --> 00:26:09,760
how many inserts at the beginning and so
 

1331
00:26:09,760 --> 00:26:13,190
how many inserts at the beginning and so
on but the keys

1332
00:26:13,190 --> 00:26:13,200

 

1333
00:26:13,200 --> 00:26:22,310

keys will always be first

1334
00:26:22,310 --> 00:26:22,320

 

1335
00:26:22,320 --> 00:26:25,590

to first plus length

1336
00:26:25,590 --> 00:26:25,600
to first plus length
 

1337
00:26:25,600 --> 00:26:27,110
to first plus length
minus one this is what we call an

1338
00:26:27,110 --> 00:26:27,120
minus one this is what we call an
 

1339
00:26:27,120 --> 00:26:28,870
minus one this is what we call an
invariant useful to write these things

1340
00:26:28,870 --> 00:26:28,880
invariant useful to write these things
 

1341
00:26:28,880 --> 00:26:30,789
invariant useful to write these things
down

1342
00:26:30,789 --> 00:26:30,799
down
 

1343
00:26:30,799 --> 00:26:33,590
down
so you can understand what the heck why

1344
00:26:33,590 --> 00:26:33,600
so you can understand what the heck why
 

1345
00:26:33,600 --> 00:26:34,950
so you can understand what the heck why
is your data structure correct

1346
00:26:34,950 --> 00:26:34,960
is your data structure correct
 

1347
00:26:34,960 --> 00:26:36,470
is your data structure correct
because of invariance like this which

1348
00:26:36,470 --> 00:26:36,480
because of invariance like this which
 

1349
00:26:36,480 --> 00:26:38,149
because of invariance like this which
you can prove by induction

1350
00:26:38,149 --> 00:26:38,159
you can prove by induction
 

1351
00:26:38,159 --> 00:26:40,149
you can prove by induction
by showing each time you do an operation

1352
00:26:40,149 --> 00:26:40,159
by showing each time you do an operation
 

1353
00:26:40,159 --> 00:26:42,070
by showing each time you do an operation
this is maintained

1354
00:26:42,070 --> 00:26:42,080
this is maintained
 

1355
00:26:42,080 --> 00:26:44,149
this is maintained
even when i'm changing first in order to

1356
00:26:44,149 --> 00:26:44,159
even when i'm changing first in order to
 

1357
00:26:44,159 --> 00:26:47,750
even when i'm changing first in order to
maintain this invariant

1358
00:26:47,750 --> 00:26:47,760

 

1359
00:26:47,760 --> 00:26:49,430

cool sometimes you come up with the

1360
00:26:49,430 --> 00:26:49,440
cool sometimes you come up with the
 

1361
00:26:49,440 --> 00:26:51,190
cool sometimes you come up with the
invariant first in this case i came up

1362
00:26:51,190 --> 00:26:51,200
invariant first in this case i came up
 

1363
00:26:51,200 --> 00:26:52,390
invariant first in this case i came up
with it

1364
00:26:52,390 --> 00:26:52,400
with it
 

1365
00:26:52,400 --> 00:26:55,909
with it
episode uh post facto after the fact

1366
00:26:55,909 --> 00:26:55,919
episode uh post facto after the fact
 

1367
00:26:55,919 --> 00:27:00,070
episode uh post facto after the fact
uh cool let's move on

1368
00:27:00,070 --> 00:27:00,080
uh cool let's move on
 

1369
00:27:00,080 --> 00:27:16,470
uh cool let's move on
to problem three

1370
00:27:16,470 --> 00:27:16,480

 

1371
00:27:16,480 --> 00:27:19,190

which is called critter sort and the

1372
00:27:19,190 --> 00:27:19,200
which is called critter sort and the
 

1373
00:27:19,200 --> 00:27:20,710
which is called critter sort and the
other key thing i want you to learn

1374
00:27:20,710 --> 00:27:20,720
other key thing i want you to learn
 

1375
00:27:20,720 --> 00:27:21,350
other key thing i want you to learn
about

1376
00:27:21,350 --> 00:27:21,360
about
 

1377
00:27:21,360 --> 00:27:24,549
about
a question sorry um so when you do first

1378
00:27:24,549 --> 00:27:24,559
a question sorry um so when you do first
 

1379
00:27:24,559 --> 00:27:26,630
a question sorry um so when you do first
first plus one is that a rebuilding of

1380
00:27:26,630 --> 00:27:26,640
first plus one is that a rebuilding of
 

1381
00:27:26,640 --> 00:27:29,750
first plus one is that a rebuilding of
use this is just a sentence

1382
00:27:29,750 --> 00:27:29,760
use this is just a sentence
 

1383
00:27:29,760 --> 00:27:32,389
use this is just a sentence
is not an algorithm or data structure

1384
00:27:32,389 --> 00:27:32,399
is not an algorithm or data structure
 

1385
00:27:32,399 --> 00:27:34,789
is not an algorithm or data structure
this is a mathematical property

1386
00:27:34,789 --> 00:27:34,799
this is a mathematical property
 

1387
00:27:34,799 --> 00:27:37,110
this is a mathematical property
this is not an assignment this is a

1388
00:27:37,110 --> 00:27:37,120
this is not an assignment this is a
 

1389
00:27:37,120 --> 00:27:38,870
this is not an assignment this is a
mathematically is equal to but you are

1390
00:27:38,870 --> 00:27:38,880
mathematically is equal to but you are
 

1391
00:27:38,880 --> 00:27:41,590
mathematically is equal to but you are
reinvesting it though

1392
00:27:41,590 --> 00:27:41,600
reinvesting it though
 

1393
00:27:41,600 --> 00:27:43,669
reinvesting it though
because you're doing first plus one so

1394
00:27:43,669 --> 00:27:43,679
because you're doing first plus one so
 

1395
00:27:43,679 --> 00:27:44,950
because you're doing first plus one so
are you asking about one of these

1396
00:27:44,950 --> 00:27:44,960
are you asking about one of these
 

1397
00:27:44,960 --> 00:27:46,310
are you asking about one of these
operations

1398
00:27:46,310 --> 00:27:46,320
operations
 

1399
00:27:46,320 --> 00:27:49,029
operations
like this one wait oh okay never mind i

1400
00:27:49,029 --> 00:27:49,039
like this one wait oh okay never mind i
 

1401
00:27:49,039 --> 00:27:49,590
like this one wait oh okay never mind i
get it

1402
00:27:49,590 --> 00:27:49,600
get it
 

1403
00:27:49,600 --> 00:27:53,510
get it
yeah okay so the other important

1404
00:27:53,510 --> 00:27:53,520
yeah okay so the other important
 

1405
00:27:53,520 --> 00:27:55,430
yeah okay so the other important
takeaway i want you to get about reading

1406
00:27:55,430 --> 00:27:55,440
takeaway i want you to get about reading
 

1407
00:27:55,440 --> 00:27:56,950
takeaway i want you to get about reading
our problem sets is that they have

1408
00:27:56,950 --> 00:27:56,960
our problem sets is that they have
 

1409
00:27:56,960 --> 00:27:58,470
our problem sets is that they have
hidden humor inside

1410
00:27:58,470 --> 00:27:58,480
hidden humor inside
 

1411
00:27:58,480 --> 00:28:00,470
hidden humor inside
i don't know if you've noticed but

1412
00:28:00,470 --> 00:28:00,480
i don't know if you've noticed but
 

1413
00:28:00,480 --> 00:28:02,149
i don't know if you've noticed but
here's an example of a problem called

1414
00:28:02,149 --> 00:28:02,159
here's an example of a problem called
 

1415
00:28:02,159 --> 00:28:02,870
here's an example of a problem called
critter sort

1416
00:28:02,870 --> 00:28:02,880
critter sort
 

1417
00:28:02,880 --> 00:28:05,190
critter sort
ashley getum collects and trains pocket

1418
00:28:05,190 --> 00:28:05,200
ashley getum collects and trains pocket
 

1419
00:28:05,200 --> 00:28:06,950
ashley getum collects and trains pocket
critters to fight other pocket critters

1420
00:28:06,950 --> 00:28:06,960
critters to fight other pocket critters
 

1421
00:28:06,960 --> 00:28:07,590
critters to fight other pocket critters
in battle

1422
00:28:07,590 --> 00:28:07,600
in battle
 

1423
00:28:07,600 --> 00:28:10,310
in battle
what is this a reference to digimon

1424
00:28:10,310 --> 00:28:10,320
what is this a reference to digimon
 

1425
00:28:10,320 --> 00:28:11,110
what is this a reference to digimon
digimon

1426
00:28:11,110 --> 00:28:11,120
digimon
 

1427
00:28:11,120 --> 00:28:14,630
digimon
wow you guys are so young pokemon

1428
00:28:14,630 --> 00:28:14,640
wow you guys are so young pokemon
 

1429
00:28:14,640 --> 00:28:17,590
wow you guys are so young pokemon
the the old the ancient form pokemon is

1430
00:28:17,590 --> 00:28:17,600
the the old the ancient form pokemon is
 

1431
00:28:17,600 --> 00:28:19,590
the the old the ancient form pokemon is
short for pocket monsters

1432
00:28:19,590 --> 00:28:19,600
short for pocket monsters
 

1433
00:28:19,600 --> 00:28:22,549
short for pocket monsters
and in fact in the original anime okay

1434
00:28:22,549 --> 00:28:22,559
and in fact in the original anime okay
 

1435
00:28:22,559 --> 00:28:23,990
and in fact in the original anime okay
actually

1436
00:28:23,990 --> 00:28:24,000
actually
 

1437
00:28:24,000 --> 00:28:27,669
actually
i i don't know it was all after my time

1438
00:28:27,669 --> 00:28:27,679
i i don't know it was all after my time
 

1439
00:28:27,679 --> 00:28:29,590
i i don't know it was all after my time
we can debate after so pocket critters

1440
00:28:29,590 --> 00:28:29,600
we can debate after so pocket critters
 

1441
00:28:29,600 --> 00:28:31,029
we can debate after so pocket critters
is a reference to pokemons pocket

1442
00:28:31,029 --> 00:28:31,039
is a reference to pokemons pocket
 

1443
00:28:31,039 --> 00:28:33,110
is a reference to pokemons pocket
monsters which is pokemon

1444
00:28:33,110 --> 00:28:33,120
monsters which is pokemon
 

1445
00:28:33,120 --> 00:28:36,310
monsters which is pokemon
who's ashley getum

1446
00:28:36,310 --> 00:28:36,320

 

1447
00:28:36,320 --> 00:28:38,630

ash ketchum is his full name in the

1448
00:28:38,630 --> 00:28:38,640
ash ketchum is his full name in the
 

1449
00:28:38,640 --> 00:28:40,149
ash ketchum is his full name in the
english version

1450
00:28:40,149 --> 00:28:40,159
english version
 

1451
00:28:40,159 --> 00:28:41,990
english version
um totally different name in the

1452
00:28:41,990 --> 00:28:42,000
um totally different name in the
 

1453
00:28:42,000 --> 00:28:43,590
um totally different name in the
japanese version but

1454
00:28:43,590 --> 00:28:43,600
japanese version but
 

1455
00:28:43,600 --> 00:28:45,430
japanese version but
they're both puns on collect them all

1456
00:28:45,430 --> 00:28:45,440
they're both puns on collect them all
 

1457
00:28:45,440 --> 00:28:47,590
they're both puns on collect them all
right all right so that's the important

1458
00:28:47,590 --> 00:28:47,600
right all right so that's the important
 

1459
00:28:47,600 --> 00:28:50,070
right all right so that's the important
stuff we'll see more jokes later

1460
00:28:50,070 --> 00:28:50,080
stuff we'll see more jokes later
 

1461
00:28:50,080 --> 00:28:52,310
stuff we'll see more jokes later
so there's this setup but basically we

1462
00:28:52,310 --> 00:28:52,320
so there's this setup but basically we
 

1463
00:28:52,320 --> 00:28:53,590
so there's this setup but basically we
have n

1464
00:28:53,590 --> 00:28:53,600
have n
 

1465
00:28:53,600 --> 00:28:55,510
have n
critters and we want to sort them by

1466
00:28:55,510 --> 00:28:55,520
critters and we want to sort them by
 

1467
00:28:55,520 --> 00:28:57,110
critters and we want to sort them by
four different things

1468
00:28:57,110 --> 00:28:57,120
four different things
 

1469
00:28:57,120 --> 00:28:58,870
four different things
and so i'm just going to abstract this

1470
00:28:58,870 --> 00:28:58,880
and so i'm just going to abstract this
 

1471
00:28:58,880 --> 00:29:00,389
and so i'm just going to abstract this
problem into sort

1472
00:29:00,389 --> 00:29:00,399
problem into sort
 

1473
00:29:00,399 --> 00:29:04,310
problem into sort
m objects by the following types of keys

1474
00:29:04,310 --> 00:29:04,320
m objects by the following types of keys
 

1475
00:29:04,320 --> 00:29:05,830
m objects by the following types of keys
and for each one we want to know what

1476
00:29:05,830 --> 00:29:05,840
and for each one we want to know what
 

1477
00:29:05,840 --> 00:29:08,070
and for each one we want to know what
the best sorting algorithm is

1478
00:29:08,070 --> 00:29:08,080
the best sorting algorithm is
 

1479
00:29:08,080 --> 00:29:09,750
the best sorting algorithm is
and there's this footnote that's very

1480
00:29:09,750 --> 00:29:09,760
and there's this footnote that's very
 

1481
00:29:09,760 --> 00:29:11,750
and there's this footnote that's very
important it says faster correct

1482
00:29:11,750 --> 00:29:11,760
important it says faster correct
 

1483
00:29:11,760 --> 00:29:13,430
important it says faster correct
algorithms will receive more points than

1484
00:29:13,430 --> 00:29:13,440
algorithms will receive more points than
 

1485
00:29:13,440 --> 00:29:14,149
algorithms will receive more points than
slower

1486
00:29:14,149 --> 00:29:14,159
slower
 

1487
00:29:14,159 --> 00:29:16,630
slower
correct algorithms also correct

1488
00:29:16,630 --> 00:29:16,640
correct algorithms also correct
 

1489
00:29:16,640 --> 00:29:18,149
correct algorithms also correct
algorithms will receive more points than

1490
00:29:18,149 --> 00:29:18,159
algorithms will receive more points than
 

1491
00:29:18,159 --> 00:29:20,070
algorithms will receive more points than
incorrect algorithms but that's implicit

1492
00:29:20,070 --> 00:29:20,080
incorrect algorithms but that's implicit
 

1493
00:29:20,080 --> 00:29:22,389
incorrect algorithms but that's implicit
incorrect generally gets zero

1494
00:29:22,389 --> 00:29:22,399
incorrect generally gets zero
 

1495
00:29:22,399 --> 00:29:25,430
incorrect generally gets zero
okay so uh part a

1496
00:29:25,430 --> 00:29:25,440
okay so uh part a
 

1497
00:29:25,440 --> 00:29:27,830
okay so uh part a
uh it says species id but basically we

1498
00:29:27,830 --> 00:29:27,840
uh it says species id but basically we
 

1499
00:29:27,840 --> 00:29:30,630
uh it says species id but basically we
have integers

1500
00:29:30,630 --> 00:29:30,640
have integers
 

1501
00:29:30,640 --> 00:29:36,389
have integers
and the range minus and n

1502
00:29:36,389 --> 00:29:36,399

 

1503
00:29:36,399 --> 00:29:39,750

so if i want to sort and integers in the

1504
00:29:39,750 --> 00:29:39,760
so if i want to sort and integers in the
 

1505
00:29:39,760 --> 00:29:39,990
so if i want to sort and integers in the
range

1506
00:29:39,990 --> 00:29:40,000
range
 

1507
00:29:40,000 --> 00:29:42,630
range
minus end to end what should i do

1508
00:29:42,630 --> 00:29:42,640
minus end to end what should i do
 

1509
00:29:42,640 --> 00:29:44,470
minus end to end what should i do
reference to

1510
00:29:44,470 --> 00:29:44,480
reference to
 

1511
00:29:44,480 --> 00:29:49,990
reference to
yesterday's lecture

1512
00:29:49,990 --> 00:29:50,000

 

1513
00:29:50,000 --> 00:29:53,190

yeah radix sort yeah always a good

1514
00:29:53,190 --> 00:29:53,200
yeah radix sort yeah always a good
 

1515
00:29:53,200 --> 00:29:55,269
yeah radix sort yeah always a good
answer for almost always a good answer

1516
00:29:55,269 --> 00:29:55,279
answer for almost always a good answer
 

1517
00:29:55,279 --> 00:29:56,070
answer for almost always a good answer
when you

1518
00:29:56,070 --> 00:29:56,080
when you
 

1519
00:29:56,080 --> 00:29:57,510
when you
have integers it's a good answer

1520
00:29:57,510 --> 00:29:57,520
have integers it's a good answer
 

1521
00:29:57,520 --> 00:29:59,590
have integers it's a good answer
whenever you have small integers now

1522
00:29:59,590 --> 00:29:59,600
whenever you have small integers now
 

1523
00:29:59,600 --> 00:30:01,350
whenever you have small integers now
radix sort the way we phrased it

1524
00:30:01,350 --> 00:30:01,360
radix sort the way we phrased it
 

1525
00:30:01,360 --> 00:30:04,310
radix sort the way we phrased it
let me maybe put it down here uh radix

1526
00:30:04,310 --> 00:30:04,320
let me maybe put it down here uh radix
 

1527
00:30:04,320 --> 00:30:06,830
let me maybe put it down here uh radix
sort

1528
00:30:06,830 --> 00:30:06,840

 

1529
00:30:06,840 --> 00:30:09,350

sorts

1530
00:30:09,350 --> 00:30:09,360
sorts
 

1531
00:30:09,360 --> 00:30:12,870
sorts
n integers in the range

1532
00:30:12,870 --> 00:30:12,880
n integers in the range
 

1533
00:30:12,880 --> 00:30:17,990
n integers in the range
0 to u minus 1

1534
00:30:17,990 --> 00:30:18,000

 

1535
00:30:18,000 --> 00:30:22,310

in m plus

1536
00:30:22,310 --> 00:30:22,320
in m plus
 

1537
00:30:22,320 --> 00:30:25,430
in m plus
m log base n of u

1538
00:30:25,430 --> 00:30:25,440
m log base n of u
 

1539
00:30:25,440 --> 00:30:30,310
m log base n of u
time and in particular this is

1540
00:30:30,310 --> 00:30:30,320
time and in particular this is
 

1541
00:30:30,320 --> 00:30:33,350
time and in particular this is
linear time if u

1542
00:30:33,350 --> 00:30:33,360
linear time if u
 

1543
00:30:33,360 --> 00:30:38,310
linear time if u
is n to some constant power

1544
00:30:38,310 --> 00:30:38,320

 

1545
00:30:38,320 --> 00:30:41,190

okay so can i just apply this as is to

1546
00:30:41,190 --> 00:30:41,200
okay so can i just apply this as is to
 

1547
00:30:41,200 --> 00:30:43,350
okay so can i just apply this as is to
these integers

1548
00:30:43,350 --> 00:30:43,360
these integers
 

1549
00:30:43,360 --> 00:30:46,149
these integers
no because they're negative so what

1550
00:30:46,149 --> 00:30:46,159
no because they're negative so what
 

1551
00:30:46,159 --> 00:30:47,830
no because they're negative so what
should i do maybe i should do my folding

1552
00:30:47,830 --> 00:30:47,840
should i do maybe i should do my folding
 

1553
00:30:47,840 --> 00:30:49,269
should i do maybe i should do my folding
trick we just saw how to take

1554
00:30:49,269 --> 00:30:49,279
trick we just saw how to take
 

1555
00:30:49,279 --> 00:30:51,430
trick we just saw how to take
negative numbers and fold them in

1556
00:30:51,430 --> 00:30:51,440
negative numbers and fold them in
 

1557
00:30:51,440 --> 00:30:53,269
negative numbers and fold them in
interspersed with positive numbers if i

1558
00:30:53,269 --> 00:30:53,279
interspersed with positive numbers if i
 

1559
00:30:53,279 --> 00:30:55,110
interspersed with positive numbers if i
sort that

1560
00:30:55,110 --> 00:30:55,120
sort that
 

1561
00:30:55,120 --> 00:30:58,389
sort that
will that work no

1562
00:30:58,389 --> 00:30:58,399
will that work no
 

1563
00:30:58,399 --> 00:31:00,950
will that work no
because that does not preserve order it

1564
00:31:00,950 --> 00:31:00,960
because that does not preserve order it
 

1565
00:31:00,960 --> 00:31:01,830
because that does not preserve order it
would

1566
00:31:01,830 --> 00:31:01,840
would
 

1567
00:31:01,840 --> 00:31:04,149
would
intersperse it's just we want all the

1568
00:31:04,149 --> 00:31:04,159
intersperse it's just we want all the
 

1569
00:31:04,159 --> 00:31:05,350
intersperse it's just we want all the
negative numbers to come before all the

1570
00:31:05,350 --> 00:31:05,360
negative numbers to come before all the
 

1571
00:31:05,360 --> 00:31:08,149
negative numbers to come before all the
positive numbers yeah

1572
00:31:08,149 --> 00:31:08,159
positive numbers yeah
 

1573
00:31:08,159 --> 00:31:11,830
positive numbers yeah
just add n yup boom plus n

1574
00:31:11,830 --> 00:31:11,840
just add n yup boom plus n
 

1575
00:31:11,840 --> 00:31:14,870
just add n yup boom plus n
now we have integers in the range

1576
00:31:14,870 --> 00:31:14,880
now we have integers in the range
 

1577
00:31:14,880 --> 00:31:21,190
now we have integers in the range
let's be careful 0 to 2n

1578
00:31:21,190 --> 00:31:21,200

 

1579
00:31:21,200 --> 00:31:23,909

cool now we can apply this now u equals

1580
00:31:23,909 --> 00:31:23,919
cool now we can apply this now u equals
 

1581
00:31:23,919 --> 00:31:26,070
cool now we can apply this now u equals
technically 2n plus 1 because we're only

1582
00:31:26,070 --> 00:31:26,080
technically 2n plus 1 because we're only
 

1583
00:31:26,080 --> 00:31:27,669
technically 2n plus 1 because we're only
supposed to go to u minus 1.

1584
00:31:27,669 --> 00:31:27,679
supposed to go to u minus 1.
 

1585
00:31:27,679 --> 00:31:30,070
supposed to go to u minus 1.
but that's fine that's linear and so we

1586
00:31:30,070 --> 00:31:30,080
but that's fine that's linear and so we
 

1587
00:31:30,080 --> 00:31:31,669
but that's fine that's linear and so we
can sort in linear time

1588
00:31:31,669 --> 00:31:31,679
can sort in linear time
 

1589
00:31:31,679 --> 00:31:34,630
can sort in linear time
easy this is a super easy problem okay

1590
00:31:34,630 --> 00:31:34,640
easy this is a super easy problem okay
 

1591
00:31:34,640 --> 00:31:36,230
easy this is a super easy problem okay
but in each one we might need to do some

1592
00:31:36,230 --> 00:31:36,240
but in each one we might need to do some
 

1593
00:31:36,240 --> 00:31:37,110
but in each one we might need to do some
transformation

1594
00:31:37,110 --> 00:31:37,120
transformation
 

1595
00:31:37,120 --> 00:31:40,630
transformation
all right part b is a little more

1596
00:31:40,630 --> 00:31:40,640
all right part b is a little more
 

1597
00:31:40,640 --> 00:31:45,190
all right part b is a little more
interesting so we have strings

1598
00:31:45,190 --> 00:31:45,200
interesting so we have strings
 

1599
00:31:45,200 --> 00:31:53,350
interesting so we have strings
over 26 letters

1600
00:31:53,350 --> 00:31:53,360

 

1601
00:31:53,360 --> 00:31:56,710

of length

1602
00:31:56,710 --> 00:31:56,720

 

1603
00:31:56,720 --> 00:32:00,549

at most 10 ceiling log

1604
00:32:00,549 --> 00:32:00,559
at most 10 ceiling log
 

1605
00:32:00,559 --> 00:32:05,029
at most 10 ceiling log
n okay this is a little trickier

1606
00:32:05,029 --> 00:32:05,039
n okay this is a little trickier
 

1607
00:32:05,039 --> 00:32:07,029
n okay this is a little trickier
what could i do again i'd like to see

1608
00:32:07,029 --> 00:32:07,039
what could i do again i'd like to see
 

1609
00:32:07,039 --> 00:32:09,430
what could i do again i'd like to see
whether radix sort applies

1610
00:32:09,430 --> 00:32:09,440
whether radix sort applies
 

1611
00:32:09,440 --> 00:32:15,269
whether radix sort applies
um i should say radix sort sorts

1612
00:32:15,269 --> 00:32:15,279
um i should say radix sort sorts
 

1613
00:32:15,279 --> 00:32:17,110
um i should say radix sort sorts
i'd like to see if radix sort applies to

1614
00:32:17,110 --> 00:32:17,120
i'd like to see if radix sort applies to
 

1615
00:32:17,120 --> 00:32:18,870
i'd like to see if radix sort applies to
do that i have to map these strings into

1616
00:32:18,870 --> 00:32:18,880
do that i have to map these strings into
 

1617
00:32:18,880 --> 00:32:20,470
do that i have to map these strings into
integers somehow

1618
00:32:20,470 --> 00:32:20,480
integers somehow
 

1619
00:32:20,480 --> 00:32:24,230
integers somehow
any way to do that

1620
00:32:24,230 --> 00:32:24,240

 

1621
00:32:24,240 --> 00:32:25,830

this is easy if you understand radix

1622
00:32:25,830 --> 00:32:25,840
this is easy if you understand radix
 

1623
00:32:25,840 --> 00:32:29,190
this is easy if you understand radix
sort yeah

1624
00:32:29,190 --> 00:32:29,200
sort yeah
 

1625
00:32:29,200 --> 00:32:33,990
sort yeah
index the letters yeah

1626
00:32:33,990 --> 00:32:34,000

 

1627
00:32:34,000 --> 00:32:36,710

yep we can we can map right so we can

1628
00:32:36,710 --> 00:32:36,720
yep we can we can map right so we can
 

1629
00:32:36,720 --> 00:32:38,389
yep we can we can map right so we can
map a to zero

1630
00:32:38,389 --> 00:32:38,399
map a to zero
 

1631
00:32:38,399 --> 00:32:47,909
map a to zero
b to one then one

1632
00:32:47,909 --> 00:32:47,919

 

1633
00:32:47,919 --> 00:32:52,310

but we have a lot of letters

1634
00:32:52,310 --> 00:32:52,320

 

1635
00:32:52,320 --> 00:32:53,990

there are only 26 letters but then we

1636
00:32:53,990 --> 00:32:54,000
there are only 26 letters but then we
 

1637
00:32:54,000 --> 00:32:56,230
there are only 26 letters but then we
have uh 10 login

1638
00:32:56,230 --> 00:32:56,240
have uh 10 login
 

1639
00:32:56,240 --> 00:32:59,350
have uh 10 login
letters in a string that is together a

1640
00:32:59,350 --> 00:32:59,360
letters in a string that is together a
 

1641
00:32:59,360 --> 00:33:05,190
letters in a string that is together a
single key that we need to sort

1642
00:33:05,190 --> 00:33:05,200

 

1643
00:33:05,200 --> 00:33:08,630

yeah i'm going to sort by the first

1644
00:33:08,630 --> 00:33:08,640
yeah i'm going to sort by the first
 

1645
00:33:08,640 --> 00:33:11,350
yeah i'm going to sort by the first
first letter first start by the first

1646
00:33:11,350 --> 00:33:11,360
first letter first start by the first
 

1647
00:33:11,360 --> 00:33:12,710
first letter first start by the first
letter then the second letter that is

1648
00:33:12,710 --> 00:33:12,720
letter then the second letter that is
 

1649
00:33:12,720 --> 00:33:14,630
letter then the second letter that is
exactly the opposite of radix sort

1650
00:33:14,630 --> 00:33:14,640
exactly the opposite of radix sort
 

1651
00:33:14,640 --> 00:33:16,310
exactly the opposite of radix sort
remember radix or we want to sort by the

1652
00:33:16,310 --> 00:33:16,320
remember radix or we want to sort by the
 

1653
00:33:16,320 --> 00:33:17,269
remember radix or we want to sort by the
last letter

1654
00:33:17,269 --> 00:33:17,279
last letter
 

1655
00:33:17,279 --> 00:33:19,110
last letter
and then the next the last letter and

1656
00:33:19,110 --> 00:33:19,120
and then the next the last letter and
 

1657
00:33:19,120 --> 00:33:21,190
and then the next the last letter and
finally the first letter by the first

1658
00:33:21,190 --> 00:33:21,200
finally the first letter by the first
 

1659
00:33:21,200 --> 00:33:23,029
finally the first letter by the first
one here it's alphabetized

1660
00:33:23,029 --> 00:33:23,039
one here it's alphabetized
 

1661
00:33:23,039 --> 00:33:25,509
one here it's alphabetized
no to alphabetize we do want to in the

1662
00:33:25,509 --> 00:33:25,519
no to alphabetize we do want to in the
 

1663
00:33:25,519 --> 00:33:26,149
no to alphabetize we do want to in the
end

1664
00:33:26,149 --> 00:33:26,159
end
 

1665
00:33:26,159 --> 00:33:27,669
end
sort by the first letter but that's at

1666
00:33:27,669 --> 00:33:27,679
sort by the first letter but that's at
 

1667
00:33:27,679 --> 00:33:29,990
sort by the first letter but that's at
the end oh wait so that at the end

1668
00:33:29,990 --> 00:33:30,000
the end oh wait so that at the end
 

1669
00:33:30,000 --> 00:33:31,190
the end oh wait so that at the end
remember radix sorry always goes

1670
00:33:31,190 --> 00:33:31,200
remember radix sorry always goes
 

1671
00:33:31,200 --> 00:33:32,710
remember radix sorry always goes
backwards from the least significant to

1672
00:33:32,710 --> 00:33:32,720
backwards from the least significant to
 

1673
00:33:32,720 --> 00:33:34,710
backwards from the least significant to
the first to the most significant

1674
00:33:34,710 --> 00:33:34,720
the first to the most significant
 

1675
00:33:34,720 --> 00:33:35,909
the first to the most significant
so indeed that is what we want to do

1676
00:33:35,909 --> 00:33:35,919
so indeed that is what we want to do
 

1677
00:33:35,919 --> 00:33:37,190
so indeed that is what we want to do
you're just saying use radix work but

1678
00:33:37,190 --> 00:33:37,200
you're just saying use radix work but
 

1679
00:33:37,200 --> 00:33:38,549
you're just saying use radix work but
what am i radix sort on

1680
00:33:38,549 --> 00:33:38,559
what am i radix sort on
 

1681
00:33:38,559 --> 00:33:42,070
what am i radix sort on
what am i radix sorting on yeah on the

1682
00:33:42,070 --> 00:33:42,080
what am i radix sorting on yeah on the
 

1683
00:33:42,080 --> 00:33:43,509
what am i radix sorting on yeah on the
on the last letters not the first

1684
00:33:43,509 --> 00:33:43,519
on the last letters not the first
 

1685
00:33:43,519 --> 00:33:45,830
on the last letters not the first
letters so technically that would be

1686
00:33:45,830 --> 00:33:45,840
letters so technically that would be
 

1687
00:33:45,840 --> 00:33:47,350
letters so technically that would be
using counting sort

1688
00:33:47,350 --> 00:33:47,360
using counting sort
 

1689
00:33:47,360 --> 00:33:48,870
using counting sort
on the last letter counting start on the

1690
00:33:48,870 --> 00:33:48,880
on the last letter counting start on the
 

1691
00:33:48,880 --> 00:33:50,710
on the last letter counting start on the
next last letter dot dot counting sort

1692
00:33:50,710 --> 00:33:50,720
next last letter dot dot counting sort
 

1693
00:33:50,720 --> 00:33:53,190
next last letter dot dot counting sort
on the first letter

1694
00:33:53,190 --> 00:33:53,200
on the first letter
 

1695
00:33:53,200 --> 00:33:55,909
on the first letter
but that is together radix sort on

1696
00:33:55,909 --> 00:33:55,919
but that is together radix sort on
 

1697
00:33:55,919 --> 00:33:57,269
but that is together radix sort on
something or

1698
00:33:57,269 --> 00:33:57,279
something or
 

1699
00:33:57,279 --> 00:34:01,430
something or
jason likes to call this tuple sorting

1700
00:34:01,430 --> 00:34:01,440

 

1701
00:34:01,440 --> 00:34:03,830

tuple sort is the thing is the algorithm

1702
00:34:03,830 --> 00:34:03,840
tuple sort is the thing is the algorithm
 

1703
00:34:03,840 --> 00:34:04,470
tuple sort is the thing is the algorithm
that says

1704
00:34:04,470 --> 00:34:04,480
that says
 

1705
00:34:04,480 --> 00:34:06,070
that says
sort by the last thing then sort by the

1706
00:34:06,070 --> 00:34:06,080
sort by the last thing then sort by the
 

1707
00:34:06,080 --> 00:34:08,389
sort by the last thing then sort by the
previous thing and so on

1708
00:34:08,389 --> 00:34:08,399
previous thing and so on
 

1709
00:34:08,399 --> 00:34:09,909
previous thing and so on
you can also think of this as radix

1710
00:34:09,909 --> 00:34:09,919
you can also think of this as radix
 

1711
00:34:09,919 --> 00:34:15,589
you can also think of this as radix
sorting on a number written in base 26.

1712
00:34:15,589 --> 00:34:15,599

 

1713
00:34:15,599 --> 00:34:23,909

they're the same thing

1714
00:34:23,909 --> 00:34:23,919

 

1715
00:34:23,919 --> 00:34:26,790

okay but in the end we can sort in

1716
00:34:26,790 --> 00:34:26,800
okay but in the end we can sort in
 

1717
00:34:26,800 --> 00:34:35,669
okay but in the end we can sort in
linear time

1718
00:34:35,669 --> 00:34:35,679
linear time
 

1719
00:34:35,679 --> 00:34:37,349
linear time
how do you tell the algorithm that you

1720
00:34:37,349 --> 00:34:37,359
how do you tell the algorithm that you
 

1721
00:34:37,359 --> 00:34:39,750
how do you tell the algorithm that you
want a to come like

1722
00:34:39,750 --> 00:34:39,760
want a to come like
 

1723
00:34:39,760 --> 00:34:42,389
want a to come like
just like not zero is less than one a is

1724
00:34:42,389 --> 00:34:42,399
just like not zero is less than one a is
 

1725
00:34:42,399 --> 00:34:43,109
just like not zero is less than one a is
less than b

1726
00:34:43,109 --> 00:34:43,119
less than b
 

1727
00:34:43,119 --> 00:34:44,710
less than b
right so i mean technically when you

1728
00:34:44,710 --> 00:34:44,720
right so i mean technically when you
 

1729
00:34:44,720 --> 00:34:47,190
right so i mean technically when you
call something like tuple sort

1730
00:34:47,190 --> 00:34:47,200
call something like tuple sort
 

1731
00:34:47,200 --> 00:34:48,869
call something like tuple sort
or maybe it's even clearer when you call

1732
00:34:48,869 --> 00:34:48,879
or maybe it's even clearer when you call
 

1733
00:34:48,879 --> 00:34:50,550
or maybe it's even clearer when you call
it radix sort rakes are giving it a

1734
00:34:50,550 --> 00:34:50,560
it radix sort rakes are giving it a
 

1735
00:34:50,560 --> 00:34:51,589
it radix sort rakes are giving it a
bunch of numbers

1736
00:34:51,589 --> 00:34:51,599
bunch of numbers
 

1737
00:34:51,599 --> 00:34:53,669
bunch of numbers
so you're taking these strings and

1738
00:34:53,669 --> 00:34:53,679
so you're taking these strings and
 

1739
00:34:53,679 --> 00:34:55,349
so you're taking these strings and
mapping them to numbers

1740
00:34:55,349 --> 00:34:55,359
mapping them to numbers
 

1741
00:34:55,359 --> 00:34:57,030
mapping them to numbers
and when you do that you get to decide

1742
00:34:57,030 --> 00:34:57,040
and when you do that you get to decide
 

1743
00:34:57,040 --> 00:34:58,710
and when you do that you get to decide
which letter is the most significant

1744
00:34:58,710 --> 00:34:58,720
which letter is the most significant
 

1745
00:34:58,720 --> 00:35:00,550
which letter is the most significant
which is the least significant

1746
00:35:00,550 --> 00:35:00,560
which is the least significant
 

1747
00:35:00,560 --> 00:35:02,230
which is the least significant
all right so you you will choose to

1748
00:35:02,230 --> 00:35:02,240
all right so you you will choose to
 

1749
00:35:02,240 --> 00:35:03,750
all right so you you will choose to
always map the first letter in your

1750
00:35:03,750 --> 00:35:03,760
always map the first letter in your
 

1751
00:35:03,760 --> 00:35:04,630
always map the first letter in your
string

1752
00:35:04,630 --> 00:35:04,640
string
 

1753
00:35:04,640 --> 00:35:07,670
string
to position a two

1754
00:35:07,670 --> 00:35:07,680
to position a two
 

1755
00:35:07,680 --> 00:35:11,109
to position a two
uh um value

1756
00:35:11,109 --> 00:35:11,119
uh um value
 

1757
00:35:11,119 --> 00:35:14,150
uh um value
or the the position and positional

1758
00:35:14,150 --> 00:35:14,160
or the the position and positional
 

1759
00:35:14,160 --> 00:35:14,950
or the the position and positional
notation

1760
00:35:14,950 --> 00:35:14,960
notation
 

1761
00:35:14,960 --> 00:35:18,390
notation
position uh 26 to the power 10 log n

1762
00:35:18,390 --> 00:35:18,400
position uh 26 to the power 10 log n
 

1763
00:35:18,400 --> 00:35:19,990
position uh 26 to the power 10 log n
right as the most significant so it's

1764
00:35:19,990 --> 00:35:20,000
right as the most significant so it's
 

1765
00:35:20,000 --> 00:35:21,270
right as the most significant so it's
always most significant even if your

1766
00:35:21,270 --> 00:35:21,280
always most significant even if your
 

1767
00:35:21,280 --> 00:35:22,390
always most significant even if your
string is of length one

1768
00:35:22,390 --> 00:35:22,400
string is of length one
 

1769
00:35:22,400 --> 00:35:23,510
string is of length one
you want to put that in the most

1770
00:35:23,510 --> 00:35:23,520
you want to put that in the most
 

1771
00:35:23,520 --> 00:35:25,829
you want to put that in the most
significant digit and you'll pad with

1772
00:35:25,829 --> 00:35:25,839
significant digit and you'll pad with
 

1773
00:35:25,839 --> 00:35:27,510
significant digit and you'll pad with
zeros at the end if you

1774
00:35:27,510 --> 00:35:27,520
zeros at the end if you
 

1775
00:35:27,520 --> 00:35:30,950
zeros at the end if you
run out of letters in your strings

1776
00:35:30,950 --> 00:35:30,960
run out of letters in your strings
 

1777
00:35:30,960 --> 00:35:32,870
run out of letters in your strings
here how many times am i running

1778
00:35:32,870 --> 00:35:32,880
here how many times am i running
 

1779
00:35:32,880 --> 00:35:34,069
here how many times am i running
counting sort oh

1780
00:35:34,069 --> 00:35:34,079
counting sort oh
 

1781
00:35:34,079 --> 00:35:37,750
counting sort oh
10 log n times whoops yeah good question

1782
00:35:37,750 --> 00:35:37,760
10 log n times whoops yeah good question
 

1783
00:35:37,760 --> 00:35:41,270
10 log n times whoops yeah good question
good point uh computed this wrong so

1784
00:35:41,270 --> 00:35:41,280
good point uh computed this wrong so
 

1785
00:35:41,280 --> 00:35:44,470
good point uh computed this wrong so
uh right there are log n digits

1786
00:35:44,470 --> 00:35:44,480
uh right there are log n digits
 

1787
00:35:44,480 --> 00:35:47,990
uh right there are log n digits
in the string uh so that

1788
00:35:47,990 --> 00:35:48,000
in the string uh so that
 

1789
00:35:48,000 --> 00:35:51,109
in the string uh so that
is bad i mean it's okay

1790
00:35:51,109 --> 00:35:51,119
is bad i mean it's okay
 

1791
00:35:51,119 --> 00:36:01,750
is bad i mean it's okay
we'll end up with a n log n running time

1792
00:36:01,750 --> 00:36:01,760

 

1793
00:36:01,760 --> 00:36:04,069

however so that's the tuple sort so i

1794
00:36:04,069 --> 00:36:04,079
however so that's the tuple sort so i
 

1795
00:36:04,079 --> 00:36:05,510
however so that's the tuple sort so i
should really

1796
00:36:05,510 --> 00:36:05,520
should really
 

1797
00:36:05,520 --> 00:36:07,829
should really
if it's not equivalent if i run tuple

1798
00:36:07,829 --> 00:36:07,839
if it's not equivalent if i run tuple
 

1799
00:36:07,839 --> 00:36:09,589
if it's not equivalent if i run tuple
sort letter by letter

1800
00:36:09,589 --> 00:36:09,599
sort letter by letter
 

1801
00:36:09,599 --> 00:36:11,190
sort letter by letter
i'm going to do i'm running counting

1802
00:36:11,190 --> 00:36:11,200
i'm going to do i'm running counting
 

1803
00:36:11,200 --> 00:36:12,950
i'm going to do i'm running counting
sort log n times and so i get n log n

1804
00:36:12,950 --> 00:36:12,960
sort log n times and so i get n log n
 

1805
00:36:12,960 --> 00:36:16,150
sort log n times and so i get n log n
because each one takes linear time

1806
00:36:16,150 --> 00:36:16,160
because each one takes linear time
 

1807
00:36:16,160 --> 00:36:20,150
because each one takes linear time
if i map my strings into numbers

1808
00:36:20,150 --> 00:36:20,160
if i map my strings into numbers
 

1809
00:36:20,160 --> 00:36:22,550
if i map my strings into numbers
first radixor doesn't use base 26 it

1810
00:36:22,550 --> 00:36:22,560
first radixor doesn't use base 26 it
 

1811
00:36:22,560 --> 00:36:24,390
first radixor doesn't use base 26 it
uses base n

1812
00:36:24,390 --> 00:36:24,400
uses base n
 

1813
00:36:24,400 --> 00:36:27,990
uses base n
and then it will only run 10 times

1814
00:36:27,990 --> 00:36:28,000
and then it will only run 10 times
 

1815
00:36:28,000 --> 00:36:31,270
and then it will only run 10 times
because uh you know 2 to the

1816
00:36:31,270 --> 00:36:31,280
because uh you know 2 to the
 

1817
00:36:31,280 --> 00:36:34,470
because uh you know 2 to the
10 log n

1818
00:36:34,470 --> 00:36:34,480
10 log n
 

1819
00:36:34,480 --> 00:36:38,390
10 log n
is n to the 10.

1820
00:36:38,390 --> 00:36:38,400
is n to the 10.
 

1821
00:36:38,400 --> 00:36:41,670
is n to the 10.
and so uh the numbers that we're sorting

1822
00:36:41,670 --> 00:36:41,680
and so uh the numbers that we're sorting
 

1823
00:36:41,680 --> 00:36:43,910
and so uh the numbers that we're sorting
are between 0 and n to the 10

1824
00:36:43,910 --> 00:36:43,920
are between 0 and n to the 10
 

1825
00:36:43,920 --> 00:36:46,710
are between 0 and n to the 10
and so u is n to the 10 and so that's

1826
00:36:46,710 --> 00:36:46,720
and so u is n to the 10 and so that's
 

1827
00:36:46,720 --> 00:36:48,550
and so u is n to the 10 and so that's
the case when radix sort runs a linear

1828
00:36:48,550 --> 00:36:48,560
the case when radix sort runs a linear
 

1829
00:36:48,560 --> 00:36:49,190
the case when radix sort runs a linear
time

1830
00:36:49,190 --> 00:36:49,200
time
 

1831
00:36:49,200 --> 00:36:51,750
time
so if you run tuple sort letter by

1832
00:36:51,750 --> 00:36:51,760
so if you run tuple sort letter by
 

1833
00:36:51,760 --> 00:36:53,109
so if you run tuple sort letter by
letter it's slow

1834
00:36:53,109 --> 00:36:53,119
letter it's slow
 

1835
00:36:53,119 --> 00:36:55,270
letter it's slow
if you run radix sort it's doing a whole

1836
00:36:55,270 --> 00:36:55,280
if you run radix sort it's doing a whole
 

1837
00:36:55,280 --> 00:36:56,630
if you run radix sort it's doing a whole
bunch of letters at once

1838
00:36:56,630 --> 00:36:56,640
bunch of letters at once
 

1839
00:36:56,640 --> 00:36:58,310
bunch of letters at once
effectively it's doing log n letters at

1840
00:36:58,310 --> 00:36:58,320
effectively it's doing log n letters at
 

1841
00:36:58,320 --> 00:37:00,230
effectively it's doing log n letters at
a time in a single

1842
00:37:00,230 --> 00:37:00,240
a time in a single
 

1843
00:37:00,240 --> 00:37:02,310
a time in a single
call to counting sort and so the radix

1844
00:37:02,310 --> 00:37:02,320
call to counting sort and so the radix
 

1845
00:37:02,320 --> 00:37:03,589
call to counting sort and so the radix
sort will actually

1846
00:37:03,589 --> 00:37:03,599
sort will actually
 

1847
00:37:03,599 --> 00:37:09,510
sort will actually
win and get linear

1848
00:37:09,510 --> 00:37:09,520
win and get linear
 

1849
00:37:09,520 --> 00:37:11,349
win and get linear
there's a subtlety here which is i'm

1850
00:37:11,349 --> 00:37:11,359
there's a subtlety here which is i'm
 

1851
00:37:11,359 --> 00:37:13,030
there's a subtlety here which is i'm
assuming that we can actually

1852
00:37:13,030 --> 00:37:13,040
assuming that we can actually
 

1853
00:37:13,040 --> 00:37:14,950
assuming that we can actually
take these strings and convert them into

1854
00:37:14,950 --> 00:37:14,960
take these strings and convert them into
 

1855
00:37:14,960 --> 00:37:16,310
take these strings and convert them into
integers in

1856
00:37:16,310 --> 00:37:16,320
integers in
 

1857
00:37:16,320 --> 00:37:19,430
integers in
constant time each and this problem set

1858
00:37:19,430 --> 00:37:19,440
constant time each and this problem set
 

1859
00:37:19,440 --> 00:37:20,710
constant time each and this problem set
was ambiguous

1860
00:37:20,710 --> 00:37:20,720
was ambiguous
 

1861
00:37:20,720 --> 00:37:22,630
was ambiguous
and both answers were accepted if you

1862
00:37:22,630 --> 00:37:22,640
and both answers were accepted if you
 

1863
00:37:22,640 --> 00:37:24,390
and both answers were accepted if you
assume these letters are nice and

1864
00:37:24,390 --> 00:37:24,400
assume these letters are nice and
 

1865
00:37:24,400 --> 00:37:25,750
assume these letters are nice and
compactly stored then

1866
00:37:25,750 --> 00:37:25,760
compactly stored then
 

1867
00:37:25,760 --> 00:37:28,310
compactly stored then
and they fit in 10 words because a word

1868
00:37:28,310 --> 00:37:28,320
and they fit in 10 words because a word
 

1869
00:37:28,320 --> 00:37:29,589
and they fit in 10 words because a word
is at least log n

1870
00:37:29,589 --> 00:37:29,599
is at least log n
 

1871
00:37:29,599 --> 00:37:32,710
is at least log n
if it's long then you can actually do

1872
00:37:32,710 --> 00:37:32,720
if it's long then you can actually do
 

1873
00:37:32,720 --> 00:37:33,510
if it's long then you can actually do
this

1874
00:37:33,510 --> 00:37:33,520
this
 

1875
00:37:33,520 --> 00:37:36,230
this
if you store each letter in a separate

1876
00:37:36,230 --> 00:37:36,240
if you store each letter in a separate
 

1877
00:37:36,240 --> 00:37:38,069
if you store each letter in a separate
word then just reading the entire input

1878
00:37:38,069 --> 00:37:38,079
word then just reading the entire input
 

1879
00:37:38,079 --> 00:37:39,030
word then just reading the entire input
will take

1880
00:37:39,030 --> 00:37:39,040
will take
 

1881
00:37:39,040 --> 00:37:42,230
will take
and log in time

1882
00:37:42,230 --> 00:37:42,240

 

1883
00:37:42,240 --> 00:37:44,310

that's a subtlety which we don't need to

1884
00:37:44,310 --> 00:37:44,320
that's a subtlety which we don't need to
 

1885
00:37:44,320 --> 00:37:55,109
that's a subtlety which we don't need to
worry too much about in this class yeah

1886
00:37:55,109 --> 00:37:55,119

 

1887
00:37:55,119 --> 00:37:58,230

yeah there are 26 possible letters

1888
00:37:58,230 --> 00:37:58,240
yeah there are 26 possible letters
 

1889
00:37:58,240 --> 00:38:01,670
yeah there are 26 possible letters
numbering them 0 to 25. um and then

1890
00:38:01,670 --> 00:38:01,680
numbering them 0 to 25. um and then
 

1891
00:38:01,680 --> 00:38:04,710
numbering them 0 to 25. um and then
when we take a string like a

1892
00:38:04,710 --> 00:38:04,720
when we take a string like a
 

1893
00:38:04,720 --> 00:38:08,630
when we take a string like a
a map this into 0 0

1894
00:38:08,630 --> 00:38:08,640
a map this into 0 0
 

1895
00:38:08,640 --> 00:38:12,230
a map this into 0 0
in base 26

1896
00:38:12,230 --> 00:38:12,240

 

1897
00:38:12,240 --> 00:38:15,910

that's a number if we do bb for example

1898
00:38:15,910 --> 00:38:15,920
that's a number if we do bb for example
 

1899
00:38:15,920 --> 00:38:16,870
that's a number if we do bb for example
this is

1900
00:38:16,870 --> 00:38:16,880
this is
 

1901
00:38:16,880 --> 00:38:20,790
this is
maps to 1 1 in base 26 which means

1902
00:38:20,790 --> 00:38:20,800
maps to 1 1 in base 26 which means
 

1903
00:38:20,800 --> 00:38:24,790
maps to 1 1 in base 26 which means
uh 1 times 26 plus 1

1904
00:38:24,790 --> 00:38:24,800
uh 1 times 26 plus 1
 

1905
00:38:24,800 --> 00:38:27,589
uh 1 times 26 plus 1
which is 27. okay so that's that's the

1906
00:38:27,589 --> 00:38:27,599
which is 27. okay so that's that's the
 

1907
00:38:27,599 --> 00:38:28,870
which is 27. okay so that's that's the
mapping that i mean

1908
00:38:28,870 --> 00:38:28,880
mapping that i mean
 

1909
00:38:28,880 --> 00:38:31,270
mapping that i mean
you're mapping the whole string the

1910
00:38:31,270 --> 00:38:31,280
you're mapping the whole string the
 

1911
00:38:31,280 --> 00:38:34,069
you're mapping the whole string the
whole string to a single number yeah

1912
00:38:34,069 --> 00:38:34,079
whole string to a single number yeah
 

1913
00:38:34,079 --> 00:38:35,670
whole string to a single number yeah
and there's a subtlety because i want

1914
00:38:35,670 --> 00:38:35,680
and there's a subtlety because i want
 

1915
00:38:35,680 --> 00:38:37,510
and there's a subtlety because i want
lexicographic i need to pad things with

1916
00:38:37,510 --> 00:38:37,520
lexicographic i need to pad things with
 

1917
00:38:37,520 --> 00:38:39,270
lexicographic i need to pad things with
spaces at the end or pad them with a's

1918
00:38:39,270 --> 00:38:39,280
spaces at the end or pad them with a's
 

1919
00:38:39,280 --> 00:38:40,310
spaces at the end or pad them with a's
at the end

1920
00:38:40,310 --> 00:38:40,320
at the end
 

1921
00:38:40,320 --> 00:38:44,310
at the end
in case they're shorter than 10 log n

1922
00:38:44,310 --> 00:38:44,320
in case they're shorter than 10 log n
 

1923
00:38:44,320 --> 00:38:50,310
in case they're shorter than 10 log n
okay uh cool that was b

1924
00:38:50,310 --> 00:38:50,320

 

1925
00:38:50,320 --> 00:38:55,750

c is not very interesting it's integers

1926
00:38:55,750 --> 00:38:55,760

 

1927
00:38:55,760 --> 00:39:00,310

in the range 0 to n squared

1928
00:39:00,310 --> 00:39:00,320
in the range 0 to n squared
 

1929
00:39:00,320 --> 00:39:02,310
in the range 0 to n squared
this i can just solve with radix sort

1930
00:39:02,310 --> 00:39:02,320
this i can just solve with radix sort
 

1931
00:39:02,320 --> 00:39:03,670
this i can just solve with radix sort
because my radix sort at this point

1932
00:39:03,670 --> 00:39:03,680
because my radix sort at this point
 

1933
00:39:03,680 --> 00:39:04,470
because my radix sort at this point
we've done it

1934
00:39:04,470 --> 00:39:04,480
we've done it
 

1935
00:39:04,480 --> 00:39:06,710
we've done it
it's our third time rate of sort we can

1936
00:39:06,710 --> 00:39:06,720
it's our third time rate of sort we can
 

1937
00:39:06,720 --> 00:39:07,829
it's our third time rate of sort we can
sort as long as

1938
00:39:07,829 --> 00:39:07,839
sort as long as
 

1939
00:39:07,839 --> 00:39:09,430
sort as long as
uh the integers are bounded by a

1940
00:39:09,430 --> 00:39:09,440
uh the integers are bounded by a
 

1941
00:39:09,440 --> 00:39:11,190
uh the integers are bounded by a
polynomial here it's a

1942
00:39:11,190 --> 00:39:11,200
polynomial here it's a
 

1943
00:39:11,200 --> 00:39:13,829
polynomial here it's a
fixed polynomial with constant exponent

1944
00:39:13,829 --> 00:39:13,839
fixed polynomial with constant exponent
 

1945
00:39:13,839 --> 00:39:14,710
fixed polynomial with constant exponent
so this will

1946
00:39:14,710 --> 00:39:14,720
so this will
 

1947
00:39:14,720 --> 00:39:16,630
so this will
and this is radix sort i like to saw

1948
00:39:16,630 --> 00:39:16,640
and this is radix sort i like to saw
 

1949
00:39:16,640 --> 00:39:18,790
and this is radix sort i like to saw
that just calls counting sword twice

1950
00:39:18,790 --> 00:39:18,800
that just calls counting sword twice
 

1951
00:39:18,800 --> 00:39:22,310
that just calls counting sword twice
uh linear time d is where things get

1952
00:39:22,310 --> 00:39:22,320
uh linear time d is where things get
 

1953
00:39:22,320 --> 00:39:23,990
uh linear time d is where things get
more interesting

1954
00:39:23,990 --> 00:39:24,000
more interesting
 

1955
00:39:24,000 --> 00:39:29,030
more interesting
let me get this phrasing same

1956
00:39:29,030 --> 00:39:29,040
let me get this phrasing same
 

1957
00:39:29,040 --> 00:39:32,870
let me get this phrasing same
so

1958
00:39:32,870 --> 00:39:32,880

 

1959
00:39:32,880 --> 00:39:35,510

v we have rational numbers of the form w

1960
00:39:35,510 --> 00:39:35,520
v we have rational numbers of the form w
 

1961
00:39:35,520 --> 00:39:37,030
v we have rational numbers of the form w
over f this is

1962
00:39:37,030 --> 00:39:37,040
over f this is
 

1963
00:39:37,040 --> 00:39:40,150
over f this is
win some win ratio

1964
00:39:40,150 --> 00:39:40,160
win some win ratio
 

1965
00:39:40,160 --> 00:39:42,470
win some win ratio
always in the range zero to one as you

1966
00:39:42,470 --> 00:39:42,480
always in the range zero to one as you
 

1967
00:39:42,480 --> 00:39:44,470
always in the range zero to one as you
say w is at most f

1968
00:39:44,470 --> 00:39:44,480
say w is at most f
 

1969
00:39:44,480 --> 00:39:47,990
say w is at most f
and zero is less than w is

1970
00:39:47,990 --> 00:39:48,000
and zero is less than w is
 

1971
00:39:48,000 --> 00:39:50,310
and zero is less than w is
some f is less than n squared because

1972
00:39:50,310 --> 00:39:50,320
some f is less than n squared because
 

1973
00:39:50,320 --> 00:39:51,430
some f is less than n squared because
the

1974
00:39:51,430 --> 00:39:51,440
the
 

1975
00:39:51,440 --> 00:39:56,630
the
that is really confusing it's less than

1976
00:39:56,630 --> 00:39:56,640
that is really confusing it's less than
 

1977
00:39:56,640 --> 00:39:59,829
that is really confusing it's less than
n squared those are separate statements

1978
00:39:59,829 --> 00:39:59,839
n squared those are separate statements
 

1979
00:39:59,839 --> 00:40:01,430
n squared those are separate statements
uh because the f actually comes from

1980
00:40:01,430 --> 00:40:01,440
uh because the f actually comes from
 

1981
00:40:01,440 --> 00:40:03,829
uh because the f actually comes from
part c c is really a set up for this one

1982
00:40:03,829 --> 00:40:03,839
part c c is really a set up for this one
 

1983
00:40:03,839 --> 00:40:06,630
part c c is really a set up for this one
um doesn't really matter what this means

1984
00:40:06,630 --> 00:40:06,640
um doesn't really matter what this means
 

1985
00:40:06,640 --> 00:40:07,910
um doesn't really matter what this means
it's just that we have

1986
00:40:07,910 --> 00:40:07,920
it's just that we have
 

1987
00:40:07,920 --> 00:40:09,750
it's just that we have
numbers w and f where w is always less

1988
00:40:09,750 --> 00:40:09,760
numbers w and f where w is always less
 

1989
00:40:09,760 --> 00:40:11,510
numbers w and f where w is always less
than f and they're between 0 and n

1990
00:40:11,510 --> 00:40:11,520
than f and they're between 0 and n
 

1991
00:40:11,520 --> 00:40:12,230
than f and they're between 0 and n
squared

1992
00:40:12,230 --> 00:40:12,240
squared
 

1993
00:40:12,240 --> 00:40:14,550
squared
so you should think this is a good range

1994
00:40:14,550 --> 00:40:14,560
so you should think this is a good range
 

1995
00:40:14,560 --> 00:40:15,349
so you should think this is a good range
for me right

1996
00:40:15,349 --> 00:40:15,359
for me right
 

1997
00:40:15,359 --> 00:40:17,270
for me right
that i'm representing this rational in

1998
00:40:17,270 --> 00:40:17,280
that i'm representing this rational in
 

1999
00:40:17,280 --> 00:40:19,030
that i'm representing this rational in
terms of two numbers between zero and n

2000
00:40:19,030 --> 00:40:19,040
terms of two numbers between zero and n
 

2001
00:40:19,040 --> 00:40:20,069
terms of two numbers between zero and n
squared so

2002
00:40:20,069 --> 00:40:20,079
squared so
 

2003
00:40:20,079 --> 00:40:22,069
squared so
there's like n to the fourth possible

2004
00:40:22,069 --> 00:40:22,079
there's like n to the fourth possible
 

2005
00:40:22,079 --> 00:40:23,270
there's like n to the fourth possible
choices for what w

2006
00:40:23,270 --> 00:40:23,280
choices for what w
 

2007
00:40:23,280 --> 00:40:26,150
choices for what w
and f are so the range of my values is n

2008
00:40:26,150 --> 00:40:26,160
and f are so the range of my values is n
 

2009
00:40:26,160 --> 00:40:27,750
and f are so the range of my values is n
to the fourth that's the setting

2010
00:40:27,750 --> 00:40:27,760
to the fourth that's the setting
 

2011
00:40:27,760 --> 00:40:29,670
to the fourth that's the setting
where rate of sort should run fast

2012
00:40:29,670 --> 00:40:29,680
where rate of sort should run fast
 

2013
00:40:29,680 --> 00:40:31,510
where rate of sort should run fast
unfortunately these numbers

2014
00:40:31,510 --> 00:40:31,520
unfortunately these numbers
 

2015
00:40:31,520 --> 00:40:34,309
unfortunately these numbers
what i want to sort by is not an integer

2016
00:40:34,309 --> 00:40:34,319
what i want to sort by is not an integer
 

2017
00:40:34,319 --> 00:40:36,550
what i want to sort by is not an integer
it's a rational

2018
00:40:36,550 --> 00:40:36,560
it's a rational
 

2019
00:40:36,560 --> 00:40:40,309
it's a rational
and that's annoying so there are

2020
00:40:40,309 --> 00:40:40,319
and that's annoying so there are
 

2021
00:40:40,319 --> 00:40:42,870
and that's annoying so there are
a couple of ways to solve this problem

2022
00:40:42,870 --> 00:40:42,880
a couple of ways to solve this problem
 

2023
00:40:42,880 --> 00:40:43,750
a couple of ways to solve this problem
uh

2024
00:40:43,750 --> 00:40:43,760
uh
 

2025
00:40:43,760 --> 00:40:47,510
uh
in general a good way to solve sorting

2026
00:40:47,510 --> 00:40:47,520
in general a good way to solve sorting
 

2027
00:40:47,520 --> 00:40:49,589
in general a good way to solve sorting
is to use merge sort workshop is always

2028
00:40:49,589 --> 00:40:49,599
is to use merge sort workshop is always
 

2029
00:40:49,599 --> 00:40:51,670
is to use merge sort workshop is always
a good answer it's not the best answer

2030
00:40:51,670 --> 00:40:51,680
a good answer it's not the best answer
 

2031
00:40:51,680 --> 00:40:54,230
a good answer it's not the best answer
in these cases we've we shaved off a log

2032
00:40:54,230 --> 00:40:54,240
in these cases we've we shaved off a log
 

2033
00:40:54,240 --> 00:40:55,510
in these cases we've we shaved off a log
we got to linear time

2034
00:40:55,510 --> 00:40:55,520
we got to linear time
 

2035
00:40:55,520 --> 00:40:57,430
we got to linear time
but n log n is pretty good it's pretty

2036
00:40:57,430 --> 00:40:57,440
but n log n is pretty good it's pretty
 

2037
00:40:57,440 --> 00:40:58,950
but n log n is pretty good it's pretty
close to n so

2038
00:40:58,950 --> 00:40:58,960
close to n so
 

2039
00:40:58,960 --> 00:41:01,750
close to n so
first goal might be can we even achieve

2040
00:41:01,750 --> 00:41:01,760
first goal might be can we even achieve
 

2041
00:41:01,760 --> 00:41:06,630
first goal might be can we even achieve
n log n via merge sort

2042
00:41:06,630 --> 00:41:06,640
n log n via merge sort
 

2043
00:41:06,640 --> 00:41:10,950
n log n via merge sort
what would i need to do in order to

2044
00:41:10,950 --> 00:41:10,960
what would i need to do in order to
 

2045
00:41:10,960 --> 00:41:14,230
what would i need to do in order to
actually apply merge sort to this

2046
00:41:14,230 --> 00:41:14,240
actually apply merge sort to this
 

2047
00:41:14,240 --> 00:41:18,470
actually apply merge sort to this
instance

2048
00:41:18,470 --> 00:41:18,480

 

2049
00:41:18,480 --> 00:41:32,829

what does merge sword do to its keys

2050
00:41:32,829 --> 00:41:32,839

 

2051
00:41:32,839 --> 00:41:36,550

sorry it isolates and compares them yeah

2052
00:41:36,550 --> 00:41:36,560
sorry it isolates and compares them yeah
 

2053
00:41:36,560 --> 00:41:38,870
sorry it isolates and compares them yeah
right so there's an array data structure

2054
00:41:38,870 --> 00:41:38,880
right so there's an array data structure
 

2055
00:41:38,880 --> 00:41:40,710
right so there's an array data structure
and it indexes into the array that's the

2056
00:41:40,710 --> 00:41:40,720
and it indexes into the array that's the
 

2057
00:41:40,720 --> 00:41:41,670
and it indexes into the array that's the
isolation

2058
00:41:41,670 --> 00:41:41,680
isolation
 

2059
00:41:41,680 --> 00:41:43,750
isolation
but then it the thing it actually does

2060
00:41:43,750 --> 00:41:43,760
but then it the thing it actually does
 

2061
00:41:43,760 --> 00:41:45,829
but then it the thing it actually does
with the items themselves is always a

2062
00:41:45,829 --> 00:41:45,839
with the items themselves is always a
 

2063
00:41:45,839 --> 00:41:46,630
with the items themselves is always a
comparison

2064
00:41:46,630 --> 00:41:46,640
comparison
 

2065
00:41:46,640 --> 00:41:48,150
comparison
this is why we introduced the comparison

2066
00:41:48,150 --> 00:41:48,160
this is why we introduced the comparison
 

2067
00:41:48,160 --> 00:41:49,510
this is why we introduced the comparison
model and proved an ad log and lower

2068
00:41:49,510 --> 00:41:49,520
model and proved an ad log and lower
 

2069
00:41:49,520 --> 00:41:50,069
model and proved an ad log and lower
bound

2070
00:41:50,069 --> 00:41:50,079
bound
 

2071
00:41:50,079 --> 00:41:51,670
bound
in the comparison model because merge

2072
00:41:51,670 --> 00:41:51,680
in the comparison model because merge
 

2073
00:41:51,680 --> 00:41:53,270
in the comparison model because merge
sort and insertion sort and selection

2074
00:41:53,270 --> 00:41:53,280
sort and insertion sort and selection
 

2075
00:41:53,280 --> 00:41:55,750
sort and insertion sort and selection
sort are all comparison algorithms

2076
00:41:55,750 --> 00:41:55,760
sort are all comparison algorithms
 

2077
00:41:55,760 --> 00:41:58,230
sort are all comparison algorithms
rated sort is not but this one is but to

2078
00:41:58,230 --> 00:41:58,240
rated sort is not but this one is but to
 

2079
00:41:58,240 --> 00:42:00,390
rated sort is not but this one is but to
run to apply merge sort i need to say

2080
00:42:00,390 --> 00:42:00,400
run to apply merge sort i need to say
 

2081
00:42:00,400 --> 00:42:03,990
run to apply merge sort i need to say
how do i compare w i over

2082
00:42:03,990 --> 00:42:04,000
how do i compare w i over
 

2083
00:42:04,000 --> 00:42:07,349
how do i compare w i over
f i versus

2084
00:42:07,349 --> 00:42:07,359
f i versus
 

2085
00:42:07,359 --> 00:42:12,710
f i versus
w j over f j

2086
00:42:12,710 --> 00:42:12,720

 

2087
00:42:12,720 --> 00:42:15,670

my computer only deals with integers we

2088
00:42:15,670 --> 00:42:15,680
my computer only deals with integers we
 

2089
00:42:15,680 --> 00:42:16,069
my computer only deals with integers we
can't

2090
00:42:16,069 --> 00:42:16,079
can't
 

2091
00:42:16,079 --> 00:42:19,030
can't
actually represent w i over f i

2092
00:42:19,030 --> 00:42:19,040
actually represent w i over f i
 

2093
00:42:19,040 --> 00:42:20,309
actually represent w i over f i
explicitly in

2094
00:42:20,309 --> 00:42:20,319
explicitly in
 

2095
00:42:20,319 --> 00:42:22,550
explicitly in
in binary because it has infinitely many

2096
00:42:22,550 --> 00:42:22,560
in binary because it has infinitely many
 

2097
00:42:22,560 --> 00:42:23,589
in binary because it has infinitely many
bits

2098
00:42:23,589 --> 00:42:23,599
bits
 

2099
00:42:23,599 --> 00:42:25,430
bits
but i can represent it implicitly by

2100
00:42:25,430 --> 00:42:25,440
but i can represent it implicitly by
 

2101
00:42:25,440 --> 00:42:27,109
but i can represent it implicitly by
storing wi and fi

2102
00:42:27,109 --> 00:42:27,119
storing wi and fi
 

2103
00:42:27,119 --> 00:42:31,430
storing wi and fi
yeah multiply by f i and fj yeah as

2104
00:42:31,430 --> 00:42:31,440
yeah multiply by f i and fj yeah as
 

2105
00:42:31,440 --> 00:42:33,430
yeah multiply by f i and fj yeah as
when i went i didn't go to school but

2106
00:42:33,430 --> 00:42:33,440
when i went i didn't go to school but
 

2107
00:42:33,440 --> 00:42:34,550
when i went i didn't go to school but
then we learned

2108
00:42:34,550 --> 00:42:34,560
then we learned
 

2109
00:42:34,560 --> 00:42:37,430
then we learned
cross multiplication uh so it's which is

2110
00:42:37,430 --> 00:42:37,440
cross multiplication uh so it's which is
 

2111
00:42:37,440 --> 00:42:39,109
cross multiplication uh so it's which is
the same as multiplying both sides by fi

2112
00:42:39,109 --> 00:42:39,119
the same as multiplying both sides by fi
 

2113
00:42:39,119 --> 00:42:40,870
the same as multiplying both sides by fi
and multiplying both sides by f j as you

2114
00:42:40,870 --> 00:42:40,880
and multiplying both sides by f j as you
 

2115
00:42:40,880 --> 00:42:41,430
and multiplying both sides by f j as you
said

2116
00:42:41,430 --> 00:42:41,440
said
 

2117
00:42:41,440 --> 00:42:44,870
said
so then we get f i f j less than

2118
00:42:44,870 --> 00:42:44,880
so then we get f i f j less than
 

2119
00:42:44,880 --> 00:42:48,710
so then we get f i f j less than
question mark uh f

2120
00:42:48,710 --> 00:42:48,720
question mark uh f
 

2121
00:42:48,720 --> 00:42:53,430
question mark uh f
whatever f i w j

2122
00:42:53,430 --> 00:42:53,440
whatever f i w j
 

2123
00:42:53,440 --> 00:42:54,950
whatever f i w j
uh when we do that we better make sure

2124
00:42:54,950 --> 00:42:54,960
uh when we do that we better make sure
 

2125
00:42:54,960 --> 00:42:56,230
uh when we do that we better make sure
that the things are multiplying by our

2126
00:42:56,230 --> 00:42:56,240
that the things are multiplying by our
 

2127
00:42:56,240 --> 00:42:58,630
that the things are multiplying by our
non-negative otherwise the sign flips

2128
00:42:58,630 --> 00:42:58,640
non-negative otherwise the sign flips
 

2129
00:42:58,640 --> 00:43:00,630
non-negative otherwise the sign flips
but here we assume they're all

2130
00:43:00,630 --> 00:43:00,640
but here we assume they're all
 

2131
00:43:00,640 --> 00:43:01,750
but here we assume they're all
non-negative

2132
00:43:01,750 --> 00:43:01,760
non-negative
 

2133
00:43:01,760 --> 00:43:03,589
non-negative
so this is good and now we're just

2134
00:43:03,589 --> 00:43:03,599
so this is good and now we're just
 

2135
00:43:03,599 --> 00:43:04,870
so this is good and now we're just
multiplying two integers here

2136
00:43:04,870 --> 00:43:04,880
multiplying two integers here
 

2137
00:43:04,880 --> 00:43:06,069
multiplying two integers here
multiplying two integers here and

2138
00:43:06,069 --> 00:43:06,079
multiplying two integers here and
 

2139
00:43:06,079 --> 00:43:06,870
multiplying two integers here and
comparing

2140
00:43:06,870 --> 00:43:06,880
comparing
 

2141
00:43:06,880 --> 00:43:08,309
comparing
those are all things i can do in a word

2142
00:43:08,309 --> 00:43:08,319
those are all things i can do in a word
 

2143
00:43:08,319 --> 00:43:11,349
those are all things i can do in a word
round okay

2144
00:43:11,349 --> 00:43:11,359
round okay
 

2145
00:43:11,359 --> 00:43:12,950
round okay
so this was actually the intended

2146
00:43:12,950 --> 00:43:12,960
so this was actually the intended
 

2147
00:43:12,960 --> 00:43:14,870
so this was actually the intended
solution when this problem was posed

2148
00:43:14,870 --> 00:43:14,880
solution when this problem was posed
 

2149
00:43:14,880 --> 00:43:16,470
solution when this problem was posed
here's a way to do comparison sort we

2150
00:43:16,470 --> 00:43:16,480
here's a way to do comparison sort we
 

2151
00:43:16,480 --> 00:43:18,630
here's a way to do comparison sort we
get n log n but in fact

2152
00:43:18,630 --> 00:43:18,640
get n log n but in fact
 

2153
00:43:18,640 --> 00:43:34,390
get n log n but in fact
you can achieve linear time yeah

2154
00:43:34,390 --> 00:43:34,400

 

2155
00:43:34,400 --> 00:43:38,710

uh i feel like there's a joke here like

2156
00:43:38,710 --> 00:43:38,720
uh i feel like there's a joke here like
 

2157
00:43:38,720 --> 00:43:40,309
uh i feel like there's a joke here like
pikachu is superior that's always the

2158
00:43:40,309 --> 00:43:40,319
pikachu is superior that's always the
 

2159
00:43:40,319 --> 00:43:42,630
pikachu is superior that's always the
answer

2160
00:43:42,630 --> 00:43:42,640
answer
 

2161
00:43:42,640 --> 00:43:44,950
answer
so how do i tell whether one pokemon is

2162
00:43:44,950 --> 00:43:44,960
so how do i tell whether one pokemon is
 

2163
00:43:44,960 --> 00:43:46,230
so how do i tell whether one pokemon is
superior to the other

2164
00:43:46,230 --> 00:43:46,240
superior to the other
 

2165
00:43:46,240 --> 00:43:49,349
superior to the other
if i i multiply

2166
00:43:49,349 --> 00:43:49,359
if i i multiply
 

2167
00:43:49,359 --> 00:43:53,030
if i i multiply
uh my i multiply i's

2168
00:43:53,030 --> 00:43:53,040
uh my i multiply i's
 

2169
00:43:53,040 --> 00:43:56,309
uh my i multiply i's
f value with j's w value and i see

2170
00:43:56,309 --> 00:43:56,319
f value with j's w value and i see
 

2171
00:43:56,319 --> 00:43:58,950
f value with j's w value and i see
whether that's greater than

2172
00:43:58,950 --> 00:43:58,960
whether that's greater than
 

2173
00:43:58,960 --> 00:44:02,309
whether that's greater than
i's w value times j's f value

2174
00:44:02,309 --> 00:44:02,319
i's w value times j's f value
 

2175
00:44:02,319 --> 00:44:05,430
i's w value times j's f value
and if it is so these are

2176
00:44:05,430 --> 00:44:05,440
and if it is so these are
 

2177
00:44:05,440 --> 00:44:07,750
and if it is so these are
equivalent if this one is greater than

2178
00:44:07,750 --> 00:44:07,760
equivalent if this one is greater than
 

2179
00:44:07,760 --> 00:44:09,190
equivalent if this one is greater than
this one i know that this is greater

2180
00:44:09,190 --> 00:44:09,200
this one i know that this is greater
 

2181
00:44:09,200 --> 00:44:09,990
this one i know that this is greater
than this

2182
00:44:09,990 --> 00:44:10,000
than this
 

2183
00:44:10,000 --> 00:44:12,470
than this
these are equivalent sentences by

2184
00:44:12,470 --> 00:44:12,480
these are equivalent sentences by
 

2185
00:44:12,480 --> 00:44:14,230
these are equivalent sentences by
mathematics by algebra

2186
00:44:14,230 --> 00:44:14,240
mathematics by algebra
 

2187
00:44:14,240 --> 00:44:16,470
mathematics by algebra
and so uh this is what i want to know

2188
00:44:16,470 --> 00:44:16,480
and so uh this is what i want to know
 

2189
00:44:16,480 --> 00:44:18,710
and so uh this is what i want to know
this would say j is superior to i

2190
00:44:18,710 --> 00:44:18,720
this would say j is superior to i
 

2191
00:44:18,720 --> 00:44:20,870
this would say j is superior to i
and so i determine that by actually

2192
00:44:20,870 --> 00:44:20,880
and so i determine that by actually
 

2193
00:44:20,880 --> 00:44:21,750
and so i determine that by actually
doing this

2194
00:44:21,750 --> 00:44:21,760
doing this
 

2195
00:44:21,760 --> 00:44:23,670
doing this
so then i don't have to divide and deal

2196
00:44:23,670 --> 00:44:23,680
so then i don't have to divide and deal
 

2197
00:44:23,680 --> 00:44:24,870
so then i don't have to divide and deal
with real numbers

2198
00:44:24,870 --> 00:44:24,880
with real numbers
 

2199
00:44:24,880 --> 00:44:27,349
with real numbers
because i don't know how cause i'm a

2200
00:44:27,349 --> 00:44:27,359
because i don't know how cause i'm a
 

2201
00:44:27,359 --> 00:44:29,620
because i don't know how cause i'm a
computer

2202
00:44:29,620 --> 00:44:29,630
computer
 

2203
00:44:29,630 --> 00:44:30,950
computer
[Applause]

2204
00:44:30,950 --> 00:44:30,960
[Applause]
 

2205
00:44:30,960 --> 00:44:39,510
[Applause]
we're all computers

2206
00:44:39,510 --> 00:44:39,520

 

2207
00:44:39,520 --> 00:44:52,950

okay uh

2208
00:44:52,950 --> 00:44:52,960

 

2209
00:44:52,960 --> 00:44:56,950

so it would be great if my numbers all

2210
00:44:56,950 --> 00:44:56,960
so it would be great if my numbers all
 

2211
00:44:56,960 --> 00:44:58,550
so it would be great if my numbers all
had the same denominator

2212
00:44:58,550 --> 00:44:58,560
had the same denominator
 

2213
00:44:58,560 --> 00:45:00,550
had the same denominator
if they all had the same f then i could

2214
00:45:00,550 --> 00:45:00,560
if they all had the same f then i could
 

2215
00:45:00,560 --> 00:45:02,390
if they all had the same f then i could
just compare the w's

2216
00:45:02,390 --> 00:45:02,400
just compare the w's
 

2217
00:45:02,400 --> 00:45:05,510
just compare the w's
so that's one intuition for why

2218
00:45:05,510 --> 00:45:05,520
so that's one intuition for why
 

2219
00:45:05,520 --> 00:45:07,589
so that's one intuition for why
we can actually do this in linear time

2220
00:45:07,589 --> 00:45:07,599
we can actually do this in linear time
 

2221
00:45:07,599 --> 00:45:08,950
we can actually do this in linear time
um

2222
00:45:08,950 --> 00:45:08,960
um
 

2223
00:45:08,960 --> 00:45:10,550
um
but the the way i like to think about it

2224
00:45:10,550 --> 00:45:10,560
but the the way i like to think about it
 

2225
00:45:10,560 --> 00:45:12,950
but the the way i like to think about it
so let's just draw

2226
00:45:12,950 --> 00:45:12,960
so let's just draw
 

2227
00:45:12,960 --> 00:45:16,150
so let's just draw
the real interval from zero to one

2228
00:45:16,150 --> 00:45:16,160
the real interval from zero to one
 

2229
00:45:16,160 --> 00:45:18,630
the real interval from zero to one
and there are various spots all over

2230
00:45:18,630 --> 00:45:18,640
and there are various spots all over
 

2231
00:45:18,640 --> 00:45:21,109
and there are various spots all over
here

2232
00:45:21,109 --> 00:45:21,119

 

2233
00:45:21,119 --> 00:45:23,589

um that represent i can't actually

2234
00:45:23,589 --> 00:45:23,599
um that represent i can't actually
 

2235
00:45:23,599 --> 00:45:25,109
um that represent i can't actually
compute this but conceptually each of

2236
00:45:25,109 --> 00:45:25,119
compute this but conceptually each of
 

2237
00:45:25,119 --> 00:45:26,150
compute this but conceptually each of
these wi over

2238
00:45:26,150 --> 00:45:26,160
these wi over
 

2239
00:45:26,160 --> 00:45:28,230
these wi over
fi's falls somewhere in that interval

2240
00:45:28,230 --> 00:45:28,240
fi's falls somewhere in that interval
 

2241
00:45:28,240 --> 00:45:29,750
fi's falls somewhere in that interval
from 0 to 1.

2242
00:45:29,750 --> 00:45:29,760
from 0 to 1.
 

2243
00:45:29,760 --> 00:45:33,910
from 0 to 1.
and i want to sort them somehow

2244
00:45:33,910 --> 00:45:33,920
and i want to sort them somehow
 

2245
00:45:33,920 --> 00:45:35,589
and i want to sort them somehow
so one thing that would be great is if i

2246
00:45:35,589 --> 00:45:35,599
so one thing that would be great is if i
 

2247
00:45:35,599 --> 00:45:37,030
so one thing that would be great is if i
could take these real numbers and

2248
00:45:37,030 --> 00:45:37,040
could take these real numbers and
 

2249
00:45:37,040 --> 00:45:37,910
could take these real numbers and
somehow

2250
00:45:37,910 --> 00:45:37,920
somehow
 

2251
00:45:37,920 --> 00:45:42,790
somehow
map them to integers

2252
00:45:42,790 --> 00:45:42,800

 

2253
00:45:42,800 --> 00:45:45,030

which are uniformly spaced maybe a

2254
00:45:45,030 --> 00:45:45,040
which are uniformly spaced maybe a
 

2255
00:45:45,040 --> 00:45:47,430
which are uniformly spaced maybe a
little a few more of them

2256
00:45:47,430 --> 00:45:47,440
little a few more of them
 

2257
00:45:47,440 --> 00:45:50,550
little a few more of them
but these go from zero to u minus one

2258
00:45:50,550 --> 00:45:50,560
but these go from zero to u minus one
 

2259
00:45:50,560 --> 00:45:53,270
but these go from zero to u minus one
if i could get u relatively small and i

2260
00:45:53,270 --> 00:45:53,280
if i could get u relatively small and i
 

2261
00:45:53,280 --> 00:45:54,309
if i could get u relatively small and i
could map

2262
00:45:54,309 --> 00:45:54,319
could map
 

2263
00:45:54,319 --> 00:45:56,390
could map
each of these so i want the mapping to

2264
00:45:56,390 --> 00:45:56,400
each of these so i want the mapping to
 

2265
00:45:56,400 --> 00:45:58,390
each of these so i want the mapping to
be order preserving

2266
00:45:58,390 --> 00:45:58,400
be order preserving
 

2267
00:45:58,400 --> 00:46:00,710
be order preserving
and i want two very close but distinct

2268
00:46:00,710 --> 00:46:00,720
and i want two very close but distinct
 

2269
00:46:00,720 --> 00:46:01,750
and i want two very close but distinct
items

2270
00:46:01,750 --> 00:46:01,760
items
 

2271
00:46:01,760 --> 00:46:04,950
items
to map to distinct keys here i want them

2272
00:46:04,950 --> 00:46:04,960
to map to distinct keys here i want them
 

2273
00:46:04,960 --> 00:46:06,790
to map to distinct keys here i want them
to map to distinct integers down here if

2274
00:46:06,790 --> 00:46:06,800
to map to distinct integers down here if
 

2275
00:46:06,800 --> 00:46:08,230
to map to distinct integers down here if
i could do that then i just sort by the

2276
00:46:08,230 --> 00:46:08,240
i could do that then i just sort by the
 

2277
00:46:08,240 --> 00:46:09,829
i could do that then i just sort by the
integers and that's the same as sorting

2278
00:46:09,829 --> 00:46:09,839
integers and that's the same as sorting
 

2279
00:46:09,839 --> 00:46:10,470
integers and that's the same as sorting
by

2280
00:46:10,470 --> 00:46:10,480
by
 

2281
00:46:10,480 --> 00:46:14,630
by
the real numbers and so at this point i

2282
00:46:14,630 --> 00:46:14,640
the real numbers and so at this point i
 

2283
00:46:14,640 --> 00:46:15,910
the real numbers and so at this point i
wonder

2284
00:46:15,910 --> 00:46:15,920
wonder
 

2285
00:46:15,920 --> 00:46:20,230
wonder
how close can two of these numbers be

2286
00:46:20,230 --> 00:46:20,240
how close can two of these numbers be
 

2287
00:46:20,240 --> 00:46:25,349
how close can two of these numbers be
so how close

2288
00:46:25,349 --> 00:46:25,359

 

2289
00:46:25,359 --> 00:46:29,910

can two keys e

2290
00:46:29,910 --> 00:46:29,920
can two keys e
 

2291
00:46:29,920 --> 00:46:33,589
can two keys e
so i want to consider w i over f i

2292
00:46:33,589 --> 00:46:33,599
so i want to consider w i over f i
 

2293
00:46:33,599 --> 00:46:37,430
so i want to consider w i over f i
minus w j over f j

2294
00:46:37,430 --> 00:46:37,440
minus w j over f j
 

2295
00:46:37,440 --> 00:46:41,030
minus w j over f j
an absolute value okay

2296
00:46:41,030 --> 00:46:41,040
an absolute value okay
 

2297
00:46:41,040 --> 00:46:44,710
an absolute value okay
now i do algebra um so this is

2298
00:46:44,710 --> 00:46:44,720
now i do algebra um so this is
 

2299
00:46:44,720 --> 00:46:47,990
now i do algebra um so this is
i'd like to bring this into one ratio so

2300
00:46:47,990 --> 00:46:48,000
i'd like to bring this into one ratio so
 

2301
00:46:48,000 --> 00:46:48,950
i'd like to bring this into one ratio so
this is

2302
00:46:48,950 --> 00:46:48,960
this is
 

2303
00:46:48,960 --> 00:46:51,030
this is
i can do that by multiplying one by five

2304
00:46:51,030 --> 00:46:51,040
i can do that by multiplying one by five
 

2305
00:46:51,040 --> 00:46:53,109
i can do that by multiplying one by five
one by f j

2306
00:46:53,109 --> 00:46:53,119
one by f j
 

2307
00:46:53,119 --> 00:46:56,230
one by f j
and it's w i f j minus w

2308
00:46:56,230 --> 00:46:56,240
and it's w i f j minus w
 

2309
00:46:56,240 --> 00:46:59,109
and it's w i f j minus w
j f i which should look a lot like

2310
00:46:59,109 --> 00:46:59,119
j f i which should look a lot like
 

2311
00:46:59,119 --> 00:47:00,630
j f i which should look a lot like
something here

2312
00:47:00,630 --> 00:47:00,640
something here
 

2313
00:47:00,640 --> 00:47:03,430
something here
uh but never mind so i'm sure there's a

2314
00:47:03,430 --> 00:47:03,440
uh but never mind so i'm sure there's a
 

2315
00:47:03,440 --> 00:47:04,630
uh but never mind so i'm sure there's a
deep connection here i could probably

2316
00:47:04,630 --> 00:47:04,640
deep connection here i could probably
 

2317
00:47:04,640 --> 00:47:05,589
deep connection here i could probably
use this to prove that

2318
00:47:05,589 --> 00:47:05,599
use this to prove that
 

2319
00:47:05,599 --> 00:47:09,190
use this to prove that
or vice versa cool so

2320
00:47:09,190 --> 00:47:09,200
or vice versa cool so
 

2321
00:47:09,200 --> 00:47:11,829
or vice versa cool so
with some absolute values same thing uh

2322
00:47:11,829 --> 00:47:11,839
with some absolute values same thing uh
 

2323
00:47:11,839 --> 00:47:12,630
with some absolute values same thing uh
maybe

2324
00:47:12,630 --> 00:47:12,640
maybe
 

2325
00:47:12,640 --> 00:47:15,030
maybe
these are non-negative so i can actually

2326
00:47:15,030 --> 00:47:15,040
these are non-negative so i can actually
 

2327
00:47:15,040 --> 00:47:18,150
these are non-negative so i can actually
just put absolute values on the top part

2328
00:47:18,150 --> 00:47:18,160
just put absolute values on the top part
 

2329
00:47:18,160 --> 00:47:22,630
just put absolute values on the top part
and okay wi is an integer fj is an

2330
00:47:22,630 --> 00:47:22,640
and okay wi is an integer fj is an
 

2331
00:47:22,640 --> 00:47:23,990
and okay wi is an integer fj is an
integer w j is an integer

2332
00:47:23,990 --> 00:47:24,000
integer w j is an integer
 

2333
00:47:24,000 --> 00:47:25,990
integer w j is an integer
f is an integer all greater than equal

2334
00:47:25,990 --> 00:47:26,000
f is an integer all greater than equal
 

2335
00:47:26,000 --> 00:47:27,190
f is an integer all greater than equal
to zero

2336
00:47:27,190 --> 00:47:27,200
to zero
 

2337
00:47:27,200 --> 00:47:30,390
to zero
so this thing is an integer

2338
00:47:30,390 --> 00:47:30,400
so this thing is an integer
 

2339
00:47:30,400 --> 00:47:33,910
so this thing is an integer
so uh it could be equal to zero it's a

2340
00:47:33,910 --> 00:47:33,920
so uh it could be equal to zero it's a
 

2341
00:47:33,920 --> 00:47:35,190
so uh it could be equal to zero it's a
non-negative integer because all the

2342
00:47:35,190 --> 00:47:35,200
non-negative integer because all the
 

2343
00:47:35,200 --> 00:47:36,309
non-negative integer because all the
things are non-negative

2344
00:47:36,309 --> 00:47:36,319
things are non-negative
 

2345
00:47:36,319 --> 00:47:37,510
things are non-negative
it could be equal to zero but if they're

2346
00:47:37,510 --> 00:47:37,520
it could be equal to zero but if they're
 

2347
00:47:37,520 --> 00:47:40,630
it could be equal to zero but if they're
equal to zero that's actually identical

2348
00:47:40,630 --> 00:47:40,640
equal to zero that's actually identical
 

2349
00:47:40,640 --> 00:47:42,390
equal to zero that's actually identical
ratios right if this is zero the whole

2350
00:47:42,390 --> 00:47:42,400
ratios right if this is zero the whole
 

2351
00:47:42,400 --> 00:47:43,750
ratios right if this is zero the whole
thing is zero and so

2352
00:47:43,750 --> 00:47:43,760
thing is zero and so
 

2353
00:47:43,760 --> 00:47:46,309
thing is zero and so
these two values were the same okay but

2354
00:47:46,309 --> 00:47:46,319
these two values were the same okay but
 

2355
00:47:46,319 --> 00:47:47,829
these two values were the same okay but
let's suppose it's not zero if it's not

2356
00:47:47,829 --> 00:47:47,839
let's suppose it's not zero if it's not
 

2357
00:47:47,839 --> 00:47:49,430
let's suppose it's not zero if it's not
zero it's actually at least

2358
00:47:49,430 --> 00:47:49,440
zero it's actually at least
 

2359
00:47:49,440 --> 00:47:52,230
zero it's actually at least
one an absolute value because it's an

2360
00:47:52,230 --> 00:47:52,240
one an absolute value because it's an
 

2361
00:47:52,240 --> 00:47:53,829
one an absolute value because it's an
integer

2362
00:47:53,829 --> 00:47:53,839
integer
 

2363
00:47:53,839 --> 00:47:57,109
integer
what about the bottom f i so now we want

2364
00:47:57,109 --> 00:47:57,119
what about the bottom f i so now we want
 

2365
00:47:57,119 --> 00:47:57,829
what about the bottom f i so now we want
this

2366
00:47:57,829 --> 00:47:57,839
this
 

2367
00:47:57,839 --> 00:47:59,589
this
i want to know how small this ratio can

2368
00:47:59,589 --> 00:47:59,599
i want to know how small this ratio can
 

2369
00:47:59,599 --> 00:48:01,190
i want to know how small this ratio can
be it's going to be small when this is

2370
00:48:01,190 --> 00:48:01,200
be it's going to be small when this is
 

2371
00:48:01,200 --> 00:48:01,589
be it's going to be small when this is
small

2372
00:48:01,589 --> 00:48:01,599
small
 

2373
00:48:01,599 --> 00:48:04,710
small
and this is big how big could fifj be

2374
00:48:04,710 --> 00:48:04,720
and this is big how big could fifj be
 

2375
00:48:04,720 --> 00:48:06,230
and this is big how big could fifj be
well we're told that all the f's are

2376
00:48:06,230 --> 00:48:06,240
well we're told that all the f's are
 

2377
00:48:06,240 --> 00:48:08,950
well we're told that all the f's are
less than n squared so this thing

2378
00:48:08,950 --> 00:48:08,960
less than n squared so this thing
 

2379
00:48:08,960 --> 00:48:11,990
less than n squared so this thing
is at most n squared n to the fourth

2380
00:48:11,990 --> 00:48:12,000
is at most n squared n to the fourth
 

2381
00:48:12,000 --> 00:48:14,790
is at most n squared n to the fourth
less than n to the fourth n squared

2382
00:48:14,790 --> 00:48:14,800
less than n to the fourth n squared
 

2383
00:48:14,800 --> 00:48:15,430
less than n to the fourth n squared
minus one

2384
00:48:15,430 --> 00:48:15,440
minus one
 

2385
00:48:15,440 --> 00:48:19,510
minus one
squared but less than n to the fourth

2386
00:48:19,510 --> 00:48:19,520
squared but less than n to the fourth
 

2387
00:48:19,520 --> 00:48:22,390
squared but less than n to the fourth
uh f i is at most n squared f j is the

2388
00:48:22,390 --> 00:48:22,400
uh f i is at most n squared f j is the
 

2389
00:48:22,400 --> 00:48:23,990
uh f i is at most n squared f j is the
most n squared

2390
00:48:23,990 --> 00:48:24,000
most n squared
 

2391
00:48:24,000 --> 00:48:27,190
most n squared
so it's n squared squared so this is at

2392
00:48:27,190 --> 00:48:27,200
so it's n squared squared so this is at
 

2393
00:48:27,200 --> 00:48:27,829
so it's n squared squared so this is at
least

2394
00:48:27,829 --> 00:48:27,839
least
 

2395
00:48:27,839 --> 00:48:30,549
least
one over n to the fourth so the the

2396
00:48:30,549 --> 00:48:30,559
one over n to the fourth so the the
 

2397
00:48:30,559 --> 00:48:32,710
one over n to the fourth so the the
closest the two points can get here

2398
00:48:32,710 --> 00:48:32,720
closest the two points can get here
 

2399
00:48:32,720 --> 00:48:35,030
closest the two points can get here
is one over n to the fourth so what

2400
00:48:35,030 --> 00:48:35,040
is one over n to the fourth so what
 

2401
00:48:35,040 --> 00:48:35,990
is one over n to the fourth so what
could i do

2402
00:48:35,990 --> 00:48:36,000
could i do
 

2403
00:48:36,000 --> 00:48:39,349
could i do
to scale that up to make them

2404
00:48:39,349 --> 00:48:39,359
to scale that up to make them
 

2405
00:48:39,359 --> 00:48:42,870
to scale that up to make them
kind of like integers multiply by n to

2406
00:48:42,870 --> 00:48:42,880
kind of like integers multiply by n to
 

2407
00:48:42,880 --> 00:48:45,270
kind of like integers multiply by n to
the fourth

2408
00:48:45,270 --> 00:48:45,280
the fourth
 

2409
00:48:45,280 --> 00:48:48,630
the fourth
so just multiply

2410
00:48:48,630 --> 00:48:48,640
so just multiply
 

2411
00:48:48,640 --> 00:48:52,230
so just multiply
by n to the fourth and then

2412
00:48:52,230 --> 00:48:52,240
by n to the fourth and then
 

2413
00:48:52,240 --> 00:48:55,670
by n to the fourth and then
floor so we're going to take

2414
00:48:55,670 --> 00:48:55,680
floor so we're going to take
 

2415
00:48:55,680 --> 00:48:59,109
floor so we're going to take
each fi over

2416
00:48:59,109 --> 00:48:59,119
each fi over
 

2417
00:48:59,119 --> 00:49:01,109
each fi over
i like to compute this ratio but i don't

2418
00:49:01,109 --> 00:49:01,119
i like to compute this ratio but i don't
 

2419
00:49:01,119 --> 00:49:02,390
i like to compute this ratio but i don't
know how so

2420
00:49:02,390 --> 00:49:02,400
know how so
 

2421
00:49:02,400 --> 00:49:05,750
know how so
instead i'm going to take f i multi okay

2422
00:49:05,750 --> 00:49:05,760
instead i'm going to take f i multi okay
 

2423
00:49:05,760 --> 00:49:07,510
instead i'm going to take f i multi okay
conceptually what i want to do is

2424
00:49:07,510 --> 00:49:07,520
conceptually what i want to do is
 

2425
00:49:07,520 --> 00:49:09,270
conceptually what i want to do is
multiply by n to the fourth and take the

2426
00:49:09,270 --> 00:49:09,280
multiply by n to the fourth and take the
 

2427
00:49:09,280 --> 00:49:10,390
multiply by n to the fourth and take the
floor

2428
00:49:10,390 --> 00:49:10,400
floor
 

2429
00:49:10,400 --> 00:49:12,150
floor
how do i actually do this

2430
00:49:12,150 --> 00:49:12,160
how do i actually do this
 

2431
00:49:12,160 --> 00:49:14,870
how do i actually do this
[Applause]

2432
00:49:14,870 --> 00:49:14,880
[Applause]
 

2433
00:49:14,880 --> 00:49:17,270
[Applause]
in a machine that doesn't have real

2434
00:49:17,270 --> 00:49:17,280
in a machine that doesn't have real
 

2435
00:49:17,280 --> 00:49:20,470
in a machine that doesn't have real
numbers like this

2436
00:49:20,470 --> 00:49:20,480

 

2437
00:49:20,480 --> 00:49:23,910

and so i don't have a floor operation

2438
00:49:23,910 --> 00:49:23,920
and so i don't have a floor operation
 

2439
00:49:23,920 --> 00:49:29,109
and so i don't have a floor operation
just have integer operations then i can

2440
00:49:29,109 --> 00:49:29,119
just have integer operations then i can
 

2441
00:49:29,119 --> 00:49:33,030
just have integer operations then i can
uh take f i

2442
00:49:33,030 --> 00:49:33,040
uh take f i
 

2443
00:49:33,040 --> 00:49:36,470
uh take f i
multiply it by n to the fourth

2444
00:49:36,470 --> 00:49:36,480
multiply it by n to the fourth
 

2445
00:49:36,480 --> 00:49:41,190
multiply it by n to the fourth
and integer divide by w j

2446
00:49:41,190 --> 00:49:41,200

 

2447
00:49:41,200 --> 00:49:43,349

that is the same that computes exactly

2448
00:49:43,349 --> 00:49:43,359
that is the same that computes exactly
 

2449
00:49:43,359 --> 00:49:44,870
that is the same that computes exactly
this

2450
00:49:44,870 --> 00:49:44,880
this
 

2451
00:49:44,880 --> 00:49:46,309
this
because i can do the multiplication of

2452
00:49:46,309 --> 00:49:46,319
because i can do the multiplication of
 

2453
00:49:46,319 --> 00:49:47,990
because i can do the multiplication of
the division in either order

2454
00:49:47,990 --> 00:49:48,000
the division in either order
 

2455
00:49:48,000 --> 00:49:51,190
the division in either order
uh in real space and then this does the

2456
00:49:51,190 --> 00:49:51,200
uh in real space and then this does the
 

2457
00:49:51,200 --> 00:49:52,470
uh in real space and then this does the
floor at the appropriate time but this

2458
00:49:52,470 --> 00:49:52,480
floor at the appropriate time but this
 

2459
00:49:52,480 --> 00:49:54,549
floor at the appropriate time but this
is just operations on integers

2460
00:49:54,549 --> 00:49:54,559
is just operations on integers
 

2461
00:49:54,559 --> 00:49:56,950
is just operations on integers
and now these are integers representing

2462
00:49:56,950 --> 00:49:56,960
and now these are integers representing
 

2463
00:49:56,960 --> 00:49:58,309
and now these are integers representing
how good my pokemon

2464
00:49:58,309 --> 00:49:58,319
how good my pokemon
 

2465
00:49:58,319 --> 00:50:00,710
how good my pokemon
are that have the property that any two

2466
00:50:00,710 --> 00:50:00,720
are that have the property that any two
 

2467
00:50:00,720 --> 00:50:01,910
are that have the property that any two
distinct ones

2468
00:50:01,910 --> 00:50:01,920
distinct ones
 

2469
00:50:01,920 --> 00:50:03,589
distinct ones
before i take the floor any two distinct

2470
00:50:03,589 --> 00:50:03,599
before i take the floor any two distinct
 

2471
00:50:03,599 --> 00:50:05,270
before i take the floor any two distinct
ones are at least one apart

2472
00:50:05,270 --> 00:50:05,280
ones are at least one apart
 

2473
00:50:05,280 --> 00:50:06,790
ones are at least one apart
so after i take the floor they will

2474
00:50:06,790 --> 00:50:06,800
so after i take the floor they will
 

2475
00:50:06,800 --> 00:50:08,069
so after i take the floor they will
remain one apart they will remain

2476
00:50:08,069 --> 00:50:08,079
remain one apart they will remain
 

2477
00:50:08,079 --> 00:50:09,670
remain one apart they will remain
distinct integers

2478
00:50:09,670 --> 00:50:09,680
distinct integers
 

2479
00:50:09,680 --> 00:50:11,190
distinct integers
and so i have successfully mapped my

2480
00:50:11,190 --> 00:50:11,200
and so i have successfully mapped my
 

2481
00:50:11,200 --> 00:50:13,750
and so i have successfully mapped my
real numbers to integers where distinct

2482
00:50:13,750 --> 00:50:13,760
real numbers to integers where distinct
 

2483
00:50:13,760 --> 00:50:15,190
real numbers to integers where distinct
real numbers map to distinct

2484
00:50:15,190 --> 00:50:15,200
real numbers map to distinct
 

2485
00:50:15,200 --> 00:50:17,349
real numbers map to distinct
integers yeah wait so why is fi now in

2486
00:50:17,349 --> 00:50:17,359
integers yeah wait so why is fi now in
 

2487
00:50:17,359 --> 00:50:19,910
integers yeah wait so why is fi now in
the numerator

2488
00:50:19,910 --> 00:50:19,920

 

2489
00:50:19,920 --> 00:50:23,109

did i flip them yeah sorry please invert

2490
00:50:23,109 --> 00:50:23,119
did i flip them yeah sorry please invert
 

2491
00:50:23,119 --> 00:50:26,390
did i flip them yeah sorry please invert
everything just here

2492
00:50:26,390 --> 00:50:26,400
everything just here
 

2493
00:50:26,400 --> 00:50:33,190
everything just here
this is w and f5 that was just a typo

2494
00:50:33,190 --> 00:50:33,200

 

2495
00:50:33,200 --> 00:50:36,630

that's all that okay

2496
00:50:36,630 --> 00:50:36,640
that's all that okay
 

2497
00:50:36,640 --> 00:50:40,710
that's all that okay
are they both i's or js

2498
00:50:40,710 --> 00:50:40,720
are they both i's or js
 

2499
00:50:40,720 --> 00:50:43,510
are they both i's or js
uh these should are supposed to both be

2500
00:50:43,510 --> 00:50:43,520
uh these should are supposed to both be
 

2501
00:50:43,520 --> 00:50:45,030
uh these should are supposed to both be
eyes yeah

2502
00:50:45,030 --> 00:50:45,040
eyes yeah
 

2503
00:50:45,040 --> 00:50:48,150
eyes yeah
thank you this was for each for each

2504
00:50:48,150 --> 00:50:48,160
thank you this was for each for each
 

2505
00:50:48,160 --> 00:50:49,349
thank you this was for each for each
pokemon i

2506
00:50:49,349 --> 00:50:49,359
pokemon i
 

2507
00:50:49,359 --> 00:50:52,549
pokemon i
we're going to compute this as our key

2508
00:50:52,549 --> 00:50:52,559
we're going to compute this as our key
 

2509
00:50:52,559 --> 00:50:53,670
we're going to compute this as our key
then we're going to sort by those

2510
00:50:53,670 --> 00:50:53,680
then we're going to sort by those
 

2511
00:50:53,680 --> 00:50:55,349
then we're going to sort by those
integer keys and that will sort the

2512
00:50:55,349 --> 00:50:55,359
integer keys and that will sort the
 

2513
00:50:55,359 --> 00:50:58,650
integer keys and that will sort the
pokemon by the ratios

2514
00:50:58,650 --> 00:50:58,660

 

2515
00:50:58,660 --> 00:51:00,710

[Music]

2516
00:51:00,710 --> 00:51:00,720
[Music]
 

2517
00:51:00,720 --> 00:51:10,230
[Music]
that's right for monster

2518
00:51:10,230 --> 00:51:10,240

 

2519
00:51:10,240 --> 00:51:13,750

uh so my u was just a sorry this is

2520
00:51:13,750 --> 00:51:13,760
uh so my u was just a sorry this is
 

2521
00:51:13,760 --> 00:51:16,390
uh so my u was just a sorry this is
uh a label on this thing can i help you

2522
00:51:16,390 --> 00:51:16,400
uh a label on this thing can i help you
 

2523
00:51:16,400 --> 00:51:18,950
uh a label on this thing can i help you
yeah

2524
00:51:18,950 --> 00:51:18,960

 

2525
00:51:18,960 --> 00:51:22,950

so uh now my u all right what is my u

2526
00:51:22,950 --> 00:51:22,960
so uh now my u all right what is my u
 

2527
00:51:22,960 --> 00:51:32,309
so uh now my u all right what is my u
how what is my largest key

2528
00:51:32,309 --> 00:51:32,319

 

2529
00:51:32,319 --> 00:51:34,630

occurs to me i really would like fi to

2530
00:51:34,630 --> 00:51:34,640
occurs to me i really would like fi to
 

2531
00:51:34,640 --> 00:51:36,309
occurs to me i really would like fi to
be bigger than zero

2532
00:51:36,309 --> 00:51:36,319
be bigger than zero
 

2533
00:51:36,319 --> 00:51:39,589
be bigger than zero
but yeah let's not worry about it

2534
00:51:39,589 --> 00:51:39,599
but yeah let's not worry about it
 

2535
00:51:39,599 --> 00:51:42,870
but yeah let's not worry about it
uh how big could you be well the biggest

2536
00:51:42,870 --> 00:51:42,880
uh how big could you be well the biggest
 

2537
00:51:42,880 --> 00:51:44,069
uh how big could you be well the biggest
this could be is if f

2538
00:51:44,069 --> 00:51:44,079
this could be is if f
 

2539
00:51:44,079 --> 00:51:46,790
this could be is if f
i is small and this is big let's say f i

2540
00:51:46,790 --> 00:51:46,800
i is small and this is big let's say f i
 

2541
00:51:46,800 --> 00:51:48,309
i is small and this is big let's say f i
can only go down to one otherwise i get

2542
00:51:48,309 --> 00:51:48,319
can only go down to one otherwise i get
 

2543
00:51:48,319 --> 00:51:49,510
can only go down to one otherwise i get
a division by zero

2544
00:51:49,510 --> 00:51:49,520
a division by zero
 

2545
00:51:49,520 --> 00:51:51,750
a division by zero
i have to deal with infinity especially

2546
00:51:51,750 --> 00:51:51,760
i have to deal with infinity especially
 

2547
00:51:51,760 --> 00:51:52,870
i have to deal with infinity especially
probably the problem isn't even well

2548
00:51:52,870 --> 00:51:52,880
probably the problem isn't even well
 

2549
00:51:52,880 --> 00:51:53,829
probably the problem isn't even well
defined then

2550
00:51:53,829 --> 00:51:53,839
defined then
 

2551
00:51:53,839 --> 00:51:55,750
defined then
uh how big could this be well i know the

2552
00:51:55,750 --> 00:51:55,760
uh how big could this be well i know the
 

2553
00:51:55,760 --> 00:51:57,109
uh how big could this be well i know the
w i's

2554
00:51:57,109 --> 00:51:57,119
w i's
 

2555
00:51:57,119 --> 00:52:00,230
w i's
i'm sorry defined as positive oh good

2556
00:52:00,230 --> 00:52:00,240
i'm sorry defined as positive oh good
 

2557
00:52:00,240 --> 00:52:02,390
i'm sorry defined as positive oh good
here's also a positive constraint here

2558
00:52:02,390 --> 00:52:02,400
here's also a positive constraint here
 

2559
00:52:02,400 --> 00:52:05,430
here's also a positive constraint here
just i failed to

2560
00:52:05,430 --> 00:52:05,440
just i failed to
 

2561
00:52:05,440 --> 00:52:07,589
just i failed to
preserve that constraint in my mapping

2562
00:52:07,589 --> 00:52:07,599
preserve that constraint in my mapping
 

2563
00:52:07,599 --> 00:52:09,670
preserve that constraint in my mapping
from the word problem into the formal

2564
00:52:09,670 --> 00:52:09,680
from the word problem into the formal
 

2565
00:52:09,680 --> 00:52:12,710
from the word problem into the formal
problem

2566
00:52:12,710 --> 00:52:12,720

 

2567
00:52:12,720 --> 00:52:15,829

so f is at least one good but let's

2568
00:52:15,829 --> 00:52:15,839
so f is at least one good but let's
 

2569
00:52:15,839 --> 00:52:16,309
so f is at least one good but let's
minim

2570
00:52:16,309 --> 00:52:16,319
minim
 

2571
00:52:16,319 --> 00:52:18,710
minim
worst cases when it's one and when wi

2572
00:52:18,710 --> 00:52:18,720
worst cases when it's one and when wi
 

2573
00:52:18,720 --> 00:52:20,470
worst cases when it's one and when wi
how big could it be well n squared minus

2574
00:52:20,470 --> 00:52:20,480
how big could it be well n squared minus
 

2575
00:52:20,480 --> 00:52:21,190
how big could it be well n squared minus
one

2576
00:52:21,190 --> 00:52:21,200
one
 

2577
00:52:21,200 --> 00:52:23,589
one
so this could be basically n squared

2578
00:52:23,589 --> 00:52:23,599
so this could be basically n squared
 

2579
00:52:23,599 --> 00:52:25,510
so this could be basically n squared
times n to the fourth divided by one

2580
00:52:25,510 --> 00:52:25,520
times n to the fourth divided by one
 

2581
00:52:25,520 --> 00:52:27,430
times n to the fourth divided by one
which is n to the sixth

2582
00:52:27,430 --> 00:52:27,440
which is n to the sixth
 

2583
00:52:27,440 --> 00:52:30,470
which is n to the sixth
so w is sorry u the largest key i can

2584
00:52:30,470 --> 00:52:30,480
so w is sorry u the largest key i can
 

2585
00:52:30,480 --> 00:52:31,670
so w is sorry u the largest key i can
have plus one

2586
00:52:31,670 --> 00:52:31,680
have plus one
 

2587
00:52:31,680 --> 00:52:34,950
have plus one
is n to the sixth but that's okay

2588
00:52:34,950 --> 00:52:34,960
is n to the sixth but that's okay
 

2589
00:52:34,960 --> 00:52:36,790
is n to the sixth but that's okay
because radix sort can handle any fixed

2590
00:52:36,790 --> 00:52:36,800
because radix sort can handle any fixed
 

2591
00:52:36,800 --> 00:52:38,549
because radix sort can handle any fixed
polynomial in n

2592
00:52:38,549 --> 00:52:38,559
polynomial in n
 

2593
00:52:38,559 --> 00:52:40,309
polynomial in n
so it's going to end up doing six

2594
00:52:40,309 --> 00:52:40,319
so it's going to end up doing six
 

2595
00:52:40,319 --> 00:52:46,950
so it's going to end up doing six
counting sort passes

2596
00:52:46,950 --> 00:52:46,960
counting sort passes
 

2597
00:52:46,960 --> 00:52:51,750
counting sort passes
yay that's problem three

2598
00:52:51,750 --> 00:52:51,760
yay that's problem three
 

2599
00:52:51,760 --> 00:53:12,829
yay that's problem three
let's move on

2600
00:53:12,829 --> 00:53:12,839

 

2601
00:53:12,839 --> 00:53:18,390

uh

2602
00:53:18,390 --> 00:53:18,400

 

2603
00:53:18,400 --> 00:53:21,270

so problem four mit has employed gank

2604
00:53:21,270 --> 00:53:21,280
so problem four mit has employed gank
 

2605
00:53:21,280 --> 00:53:22,069
so problem four mit has employed gank
freri

2606
00:53:22,069 --> 00:53:22,079
freri
 

2607
00:53:22,079 --> 00:53:26,470
freri
who's that

2608
00:53:26,470 --> 00:53:26,480

 

2609
00:53:26,480 --> 00:53:29,910

frank gehry yep this is a common uh

2610
00:53:29,910 --> 00:53:29,920
frank gehry yep this is a common uh
 

2611
00:53:29,920 --> 00:53:34,870
frank gehry yep this is a common uh
encoding that jason really likes

2612
00:53:34,870 --> 00:53:34,880
encoding that jason really likes
 

2613
00:53:34,880 --> 00:53:38,390
encoding that jason really likes
i've grown to like it

2614
00:53:38,390 --> 00:53:38,400
i've grown to like it
 

2615
00:53:38,400 --> 00:53:40,630
i've grown to like it
uh is this called spoonerism where you

2616
00:53:40,630 --> 00:53:40,640
uh is this called spoonerism where you
 

2617
00:53:40,640 --> 00:53:41,990
uh is this called spoonerism where you
replace some

2618
00:53:41,990 --> 00:53:42,000
replace some
 

2619
00:53:42,000 --> 00:53:45,109
replace some
some part of the beginning of your uh

2620
00:53:45,109 --> 00:53:45,119
some part of the beginning of your uh
 

2621
00:53:45,119 --> 00:53:47,430
some part of the beginning of your uh
thing okay that's one joke there's

2622
00:53:47,430 --> 00:53:47,440
thing okay that's one joke there's
 

2623
00:53:47,440 --> 00:53:49,270
thing okay that's one joke there's
another joke in this problem

2624
00:53:49,270 --> 00:53:49,280
another joke in this problem
 

2625
00:53:49,280 --> 00:53:50,870
another joke in this problem
uh anyway they're building a new wing of

2626
00:53:50,870 --> 00:53:50,880
uh anyway they're building a new wing of
 

2627
00:53:50,880 --> 00:53:52,710
uh anyway they're building a new wing of
this data center as one does

2628
00:53:52,710 --> 00:53:52,720
this data center as one does
 

2629
00:53:52,720 --> 00:53:55,910
this data center as one does
uh we have a bunch of cubes if you read

2630
00:53:55,910 --> 00:53:55,920
uh we have a bunch of cubes if you read
 

2631
00:53:55,920 --> 00:53:57,270
uh we have a bunch of cubes if you read
long enough you realize that's a red

2632
00:53:57,270 --> 00:53:57,280
long enough you realize that's a red
 

2633
00:53:57,280 --> 00:53:58,549
long enough you realize that's a red
herring that's

2634
00:53:58,549 --> 00:53:58,559
herring that's
 

2635
00:53:58,559 --> 00:54:00,790
herring that's
cubes do not play a role in this problem

2636
00:54:00,790 --> 00:54:00,800
cubes do not play a role in this problem
 

2637
00:54:00,800 --> 00:54:01,750
cubes do not play a role in this problem
in the end

2638
00:54:01,750 --> 00:54:01,760
in the end
 

2639
00:54:01,760 --> 00:54:05,109
in the end
what we have is a bunch of

2640
00:54:05,109 --> 00:54:05,119
what we have is a bunch of
 

2641
00:54:05,119 --> 00:54:08,390
what we have is a bunch of
integers which happen to be the side

2642
00:54:08,390 --> 00:54:08,400
integers which happen to be the side
 

2643
00:54:08,400 --> 00:54:10,790
integers which happen to be the side
length of the cube cubes but we just

2644
00:54:10,790 --> 00:54:10,800
length of the cube cubes but we just
 

2645
00:54:10,800 --> 00:54:12,069
length of the cube cubes but we just
care about the side lengths not their

2646
00:54:12,069 --> 00:54:12,079
care about the side lengths not their
 

2647
00:54:12,079 --> 00:54:14,230
care about the side lengths not their
volume or anything

2648
00:54:14,230 --> 00:54:14,240
volume or anything
 

2649
00:54:14,240 --> 00:54:18,069
volume or anything
s

2650
00:54:18,069 --> 00:54:18,079

 

2651
00:54:18,079 --> 00:54:21,510

n minus one

2652
00:54:21,510 --> 00:54:21,520

 

2653
00:54:21,520 --> 00:54:24,870

and we want two

2654
00:54:24,870 --> 00:54:24,880
and we want two
 

2655
00:54:24,880 --> 00:54:29,910
and we want two
numbers in s

2656
00:54:29,910 --> 00:54:29,920

 

2657
00:54:29,920 --> 00:54:36,710

summing to h

2658
00:54:36,710 --> 00:54:36,720

 

2659
00:54:36,720 --> 00:54:38,390

this is the side length not the number

2660
00:54:38,390 --> 00:54:38,400
this is the side length not the number
 

2661
00:54:38,400 --> 00:54:43,910
this is the side length not the number
of sides so you got a cube

2662
00:54:43,910 --> 00:54:43,920

 

2663
00:54:43,920 --> 00:54:45,190

cool i didn't know we'd be doing 3d

2664
00:54:45,190 --> 00:54:45,200
cool i didn't know we'd be doing 3d
 

2665
00:54:45,200 --> 00:54:47,910
cool i didn't know we'd be doing 3d
geometry today ssi

2666
00:54:47,910 --> 00:54:47,920
geometry today ssi
 

2667
00:54:47,920 --> 00:54:49,750
geometry today ssi
okay so you've got little cubes you've

2668
00:54:49,750 --> 00:54:49,760
okay so you've got little cubes you've
 

2669
00:54:49,760 --> 00:54:51,589
okay so you've got little cubes you've
got big cubes

2670
00:54:51,589 --> 00:54:51,599
got big cubes
 

2671
00:54:51,599 --> 00:54:53,030
got big cubes
okay this is the smaller side it's the

2672
00:54:53,030 --> 00:54:53,040
okay this is the smaller side it's the
 

2673
00:54:53,040 --> 00:54:54,549
okay this is the smaller side it's the
biggest eye doesn't matter though

2674
00:54:54,549 --> 00:54:54,559
biggest eye doesn't matter though
 

2675
00:54:54,559 --> 00:54:55,750
biggest eye doesn't matter though
they're just numbers

2676
00:54:55,750 --> 00:54:55,760
they're just numbers
 

2677
00:54:55,760 --> 00:54:57,510
they're just numbers
okay we're not using them at all in the

2678
00:54:57,510 --> 00:54:57,520
okay we're not using them at all in the
 

2679
00:54:57,520 --> 00:54:58,950
okay we're not using them at all in the
problem you're trying to like stack one

2680
00:54:58,950 --> 00:54:58,960
problem you're trying to like stack one
 

2681
00:54:58,960 --> 00:54:59,990
problem you're trying to like stack one
cube on the other but

2682
00:54:59,990 --> 00:55:00,000
cube on the other but
 

2683
00:55:00,000 --> 00:55:01,670
cube on the other but
all we really care about is two numbers

2684
00:55:01,670 --> 00:55:01,680
all we really care about is two numbers
 

2685
00:55:01,680 --> 00:55:03,510
all we really care about is two numbers
who's whose sum

2686
00:55:03,510 --> 00:55:03,520
who's whose sum
 

2687
00:55:03,520 --> 00:55:06,710
who's whose sum
regular old sum is exactly h ideally

2688
00:55:06,710 --> 00:55:06,720
regular old sum is exactly h ideally
 

2689
00:55:06,720 --> 00:55:08,069
regular old sum is exactly h ideally
there's going to be two versions of this

2690
00:55:08,069 --> 00:55:08,079
there's going to be two versions of this
 

2691
00:55:08,079 --> 00:55:09,109
there's going to be two versions of this
problem

2692
00:55:09,109 --> 00:55:09,119
problem
 

2693
00:55:09,119 --> 00:55:11,270
problem
and so first goal is to solve this

2694
00:55:11,270 --> 00:55:11,280
and so first goal is to solve this
 

2695
00:55:11,280 --> 00:55:12,309
and so first goal is to solve this
exactly

2696
00:55:12,309 --> 00:55:12,319
exactly
 

2697
00:55:12,319 --> 00:55:17,270
exactly
in linear expected time

2698
00:55:17,270 --> 00:55:17,280

 

2699
00:55:17,280 --> 00:55:21,349

that's what the problem says so

2700
00:55:21,349 --> 00:55:21,359
that's what the problem says so
 

2701
00:55:21,359 --> 00:55:24,950
that's what the problem says so
what do we know well linear time that's

2702
00:55:24,950 --> 00:55:24,960
what do we know well linear time that's
 

2703
00:55:24,960 --> 00:55:26,230
what do we know well linear time that's
can't get much faster than that because

2704
00:55:26,230 --> 00:55:26,240
can't get much faster than that because
 

2705
00:55:26,240 --> 00:55:28,069
can't get much faster than that because
we need that just to read the input

2706
00:55:28,069 --> 00:55:28,079
we need that just to read the input
 

2707
00:55:28,079 --> 00:55:31,829
we need that just to read the input
expected time hashing

2708
00:55:31,829 --> 00:55:31,839
expected time hashing
 

2709
00:55:31,839 --> 00:55:33,750
expected time hashing
right we're told basically we should use

2710
00:55:33,750 --> 00:55:33,760
right we're told basically we should use
 

2711
00:55:33,760 --> 00:55:35,990
right we're told basically we should use
hashing now if we're really annoying

2712
00:55:35,990 --> 00:55:36,000
hashing now if we're really annoying
 

2713
00:55:36,000 --> 00:55:37,349
hashing now if we're really annoying
maybe we throw that in even when you

2714
00:55:37,349 --> 00:55:37,359
maybe we throw that in even when you
 

2715
00:55:37,359 --> 00:55:38,789
maybe we throw that in even when you
don't need it but

2716
00:55:38,789 --> 00:55:38,799
don't need it but
 

2717
00:55:38,799 --> 00:55:41,990
don't need it but
that's pretty rare uh so when we see

2718
00:55:41,990 --> 00:55:42,000
that's pretty rare uh so when we see
 

2719
00:55:42,000 --> 00:55:43,910
that's pretty rare uh so when we see
expected we should in a problem set

2720
00:55:43,910 --> 00:55:43,920
expected we should in a problem set
 

2721
00:55:43,920 --> 00:55:45,430
expected we should in a problem set
setting like this in real life you never

2722
00:55:45,430 --> 00:55:45,440
setting like this in real life you never
 

2723
00:55:45,440 --> 00:55:46,870
setting like this in real life you never
know what you should use but in

2724
00:55:46,870 --> 00:55:46,880
know what you should use but in
 

2725
00:55:46,880 --> 00:55:48,950
know what you should use but in
our and was your learning in this class

2726
00:55:48,950 --> 00:55:48,960
our and was your learning in this class
 

2727
00:55:48,960 --> 00:55:50,470
our and was your learning in this class
we're going to tell you basically

2728
00:55:50,470 --> 00:55:50,480
we're going to tell you basically
 

2729
00:55:50,480 --> 00:55:52,230
we're going to tell you basically
what tricks you're allowed to use here

2730
00:55:52,230 --> 00:55:52,240
what tricks you're allowed to use here
 

2731
00:55:52,240 --> 00:55:53,750
what tricks you're allowed to use here
you're allowed to use randomization so

2732
00:55:53,750 --> 00:55:53,760
you're allowed to use randomization so
 

2733
00:55:53,760 --> 00:55:55,510
you're allowed to use randomization so
probably we need it

2734
00:55:55,510 --> 00:55:55,520
probably we need it
 

2735
00:55:55,520 --> 00:55:58,470
probably we need it
indeed you need it to achieve this bound

2736
00:55:58,470 --> 00:55:58,480
indeed you need it to achieve this bound
 

2737
00:55:58,480 --> 00:56:00,829
indeed you need it to achieve this bound
ah

2738
00:56:00,829 --> 00:56:00,839

 

2739
00:56:00,839 --> 00:56:03,349

cool

2740
00:56:03,349 --> 00:56:03,359
cool
 

2741
00:56:03,359 --> 00:56:04,789
cool
not obvious how to approach this problem

2742
00:56:04,789 --> 00:56:04,799
not obvious how to approach this problem
 

2743
00:56:04,799 --> 00:56:06,870
not obvious how to approach this problem
with hashing so i'm going to give you

2744
00:56:06,870 --> 00:56:06,880
with hashing so i'm going to give you
 

2745
00:56:06,880 --> 00:56:09,589
with hashing so i'm going to give you
uh the way i it's it's hard for me to

2746
00:56:09,589 --> 00:56:09,599
uh the way i it's it's hard for me to
 

2747
00:56:09,599 --> 00:56:10,710
uh the way i it's it's hard for me to
not know this algorithm

2748
00:56:10,710 --> 00:56:10,720
not know this algorithm
 

2749
00:56:10,720 --> 00:56:13,829
not know this algorithm
but um to me the first thing you should

2750
00:56:13,829 --> 00:56:13,839
but um to me the first thing you should
 

2751
00:56:13,839 --> 00:56:16,390
but um to me the first thing you should
think about is if if i have linear time

2752
00:56:16,390 --> 00:56:16,400
think about is if if i have linear time
 

2753
00:56:16,400 --> 00:56:18,309
think about is if if i have linear time
and n things and i'm going to use

2754
00:56:18,309 --> 00:56:18,319
and n things and i'm going to use
 

2755
00:56:18,319 --> 00:56:21,030
and n things and i'm going to use
hashing

2756
00:56:21,030 --> 00:56:21,040

 

2757
00:56:21,040 --> 00:56:23,430

the obvious thing to do is to take those

2758
00:56:23,430 --> 00:56:23,440
the obvious thing to do is to take those
 

2759
00:56:23,440 --> 00:56:25,510
the obvious thing to do is to take those
n things and put them in a hash table

2760
00:56:25,510 --> 00:56:25,520
n things and put them in a hash table
 

2761
00:56:25,520 --> 00:56:29,670
n things and put them in a hash table
build why not uh so let's just

2762
00:56:29,670 --> 00:56:29,680
build why not uh so let's just
 

2763
00:56:29,680 --> 00:56:35,109
build why not uh so let's just
build a hash table

2764
00:56:35,109 --> 00:56:35,119

 

2765
00:56:35,119 --> 00:56:38,309

on all the keys in s

2766
00:56:38,309 --> 00:56:38,319
on all the keys in s
 

2767
00:56:38,319 --> 00:56:45,349
on all the keys in s
that's idea one

2768
00:56:45,349 --> 00:56:45,359
that's idea one
 

2769
00:56:45,359 --> 00:56:47,030
that's idea one
seems like the first thing to try so

2770
00:56:47,030 --> 00:56:47,040
seems like the first thing to try so
 

2771
00:56:47,040 --> 00:56:49,349
seems like the first thing to try so
what does that let me do

2772
00:56:49,349 --> 00:56:49,359
what does that let me do
 

2773
00:56:49,359 --> 00:56:51,990
what does that let me do
it lets me i just erased the interface

2774
00:56:51,990 --> 00:56:52,000
it lets me i just erased the interface
 

2775
00:56:52,000 --> 00:56:53,829
it lets me i just erased the interface
for hash tables but

2776
00:56:53,829 --> 00:56:53,839
for hash tables but
 

2777
00:56:53,839 --> 00:56:55,109
for hash tables but
i can build a sequence out of it but

2778
00:56:55,109 --> 00:56:55,119
i can build a sequence out of it but
 

2779
00:56:55,119 --> 00:56:57,510
i can build a sequence out of it but
normally it gives me a set interface

2780
00:56:57,510 --> 00:56:57,520
normally it gives me a set interface
 

2781
00:56:57,520 --> 00:56:59,829
normally it gives me a set interface
so i can call find now in constant time

2782
00:56:59,829 --> 00:56:59,839
so i can call find now in constant time
 

2783
00:56:59,839 --> 00:57:02,069
so i can call find now in constant time
it lets me given a number

2784
00:57:02,069 --> 00:57:02,079
it lets me given a number
 

2785
00:57:02,079 --> 00:57:03,670
it lets me given a number
determine immediately whether that

2786
00:57:03,670 --> 00:57:03,680
determine immediately whether that
 

2787
00:57:03,680 --> 00:57:05,910
determine immediately whether that
number is in s

2788
00:57:05,910 --> 00:57:05,920
number is in s
 

2789
00:57:05,920 --> 00:57:07,589
number is in s
well that sounds interesting because i'm

2790
00:57:07,589 --> 00:57:07,599
well that sounds interesting because i'm
 

2791
00:57:07,599 --> 00:57:09,510
well that sounds interesting because i'm
looking for two numbers in s

2792
00:57:09,510 --> 00:57:09,520
looking for two numbers in s
 

2793
00:57:09,520 --> 00:57:11,910
looking for two numbers in s
so it lets me find one of them so i call

2794
00:57:11,910 --> 00:57:11,920
so it lets me find one of them so i call
 

2795
00:57:11,920 --> 00:57:13,589
so it lets me find one of them so i call
it twice

2796
00:57:13,589 --> 00:57:13,599
it twice
 

2797
00:57:13,599 --> 00:57:16,630
it twice
no uh calling it twice and only spending

2798
00:57:16,630 --> 00:57:16,640
no uh calling it twice and only spending
 

2799
00:57:16,640 --> 00:57:18,069
no uh calling it twice and only spending
constant time on this beautiful data

2800
00:57:18,069 --> 00:57:18,079
constant time on this beautiful data
 

2801
00:57:18,079 --> 00:57:19,589
constant time on this beautiful data
structure will not give you anything

2802
00:57:19,589 --> 00:57:19,599
structure will not give you anything
 

2803
00:57:19,599 --> 00:57:23,109
structure will not give you anything
useful

2804
00:57:23,109 --> 00:57:23,119

 

2805
00:57:23,119 --> 00:57:25,109

but we have linear time right so in

2806
00:57:25,109 --> 00:57:25,119
but we have linear time right so in
 

2807
00:57:25,119 --> 00:57:26,789
but we have linear time right so in
addition to building a table

2808
00:57:26,789 --> 00:57:26,799
addition to building a table
 

2809
00:57:26,799 --> 00:57:28,950
addition to building a table
we could call find on that table a

2810
00:57:28,950 --> 00:57:28,960
we could call find on that table a
 

2811
00:57:28,960 --> 00:57:30,630
we could call find on that table a
linear number of times because each find

2812
00:57:30,630 --> 00:57:30,640
linear number of times because each find
 

2813
00:57:30,640 --> 00:57:32,549
linear number of times because each find
only takes constant expected

2814
00:57:32,549 --> 00:57:32,559
only takes constant expected
 

2815
00:57:32,559 --> 00:57:34,870
only takes constant expected
amortized time so if i do n of them that

2816
00:57:34,870 --> 00:57:34,880
amortized time so if i do n of them that
 

2817
00:57:34,880 --> 00:57:35,589
amortized time so if i do n of them that
will take

2818
00:57:35,589 --> 00:57:35,599
will take
 

2819
00:57:35,599 --> 00:57:37,990
will take
linear expected time the amortization

2820
00:57:37,990 --> 00:57:38,000
linear expected time the amortization
 

2821
00:57:38,000 --> 00:57:39,430
linear expected time the amortization
disappears because

2822
00:57:39,430 --> 00:57:39,440
disappears because
 

2823
00:57:39,440 --> 00:57:42,630
disappears because
i'm using it 10 times all right find

2824
00:57:42,630 --> 00:57:42,640
i'm using it 10 times all right find
 

2825
00:57:42,640 --> 00:57:44,150
i'm using it 10 times all right find
never has amortization so

2826
00:57:44,150 --> 00:57:44,160
never has amortization so
 

2827
00:57:44,160 --> 00:57:45,670
never has amortization so
it doesn't disappear because it was

2828
00:57:45,670 --> 00:57:45,680
it doesn't disappear because it was
 

2829
00:57:45,680 --> 00:57:47,510
it doesn't disappear because it was
never there never mind

2830
00:57:47,510 --> 00:57:47,520
never there never mind
 

2831
00:57:47,520 --> 00:57:51,589
never there never mind
i can afford n calls or five n calls

2832
00:57:51,589 --> 00:57:51,599
i can afford n calls or five n calls
 

2833
00:57:51,599 --> 00:57:53,109
i can afford n calls or five n calls
to find because each one costs constant

2834
00:57:53,109 --> 00:57:53,119
to find because each one costs constant
 

2835
00:57:53,119 --> 00:57:55,190
to find because each one costs constant
constant expected

2836
00:57:55,190 --> 00:57:55,200
constant expected
 

2837
00:57:55,200 --> 00:57:56,789
constant expected
and the total for that will be linear

2838
00:57:56,789 --> 00:57:56,799
and the total for that will be linear
 

2839
00:57:56,799 --> 00:57:58,230
and the total for that will be linear
time so next idea

2840
00:57:58,230 --> 00:57:58,240
time so next idea
 

2841
00:57:58,240 --> 00:58:01,510
time so next idea
is let's just somehow call

2842
00:58:01,510 --> 00:58:01,520
is let's just somehow call
 

2843
00:58:01,520 --> 00:58:04,630
is let's just somehow call
find

2844
00:58:04,630 --> 00:58:04,640

 

2845
00:58:04,640 --> 00:58:10,789

a linear number of times

2846
00:58:10,789 --> 00:58:10,799

 

2847
00:58:10,799 --> 00:58:13,430

okay okay uh so i want to find two

2848
00:58:13,430 --> 00:58:13,440
okay okay uh so i want to find two
 

2849
00:58:13,440 --> 00:58:14,390
okay okay uh so i want to find two
numbers

2850
00:58:14,390 --> 00:58:14,400
numbers
 

2851
00:58:14,400 --> 00:58:16,789
numbers
summing to a given value h that wasn't

2852
00:58:16,789 --> 00:58:16,799
summing to a given value h that wasn't
 

2853
00:58:16,799 --> 00:58:19,349
summing to a given value h that wasn't
maybe clear but h is given

2854
00:58:19,349 --> 00:58:19,359
maybe clear but h is given
 

2855
00:58:19,359 --> 00:58:21,270
maybe clear but h is given
sorry um how long does it take to build

2856
00:58:21,270 --> 00:58:21,280
sorry um how long does it take to build
 

2857
00:58:21,280 --> 00:58:22,630
sorry um how long does it take to build
the hash table

2858
00:58:22,630 --> 00:58:22,640
the hash table
 

2859
00:58:22,640 --> 00:58:23,670
the hash table
how long does it take to build a hash

2860
00:58:23,670 --> 00:58:23,680
how long does it take to build a hash
 

2861
00:58:23,680 --> 00:58:25,190
how long does it take to build a hash
table it was previously on this board

2862
00:58:25,190 --> 00:58:25,200
table it was previously on this board
 

2863
00:58:25,200 --> 00:58:29,270
table it was previously on this board
linear expected time

2864
00:58:29,270 --> 00:58:29,280

 

2865
00:58:29,280 --> 00:58:32,470

see previous lecture

2866
00:58:32,470 --> 00:58:32,480
see previous lecture
 

2867
00:58:32,480 --> 00:58:35,589
see previous lecture
no two lectures ago ah okay

2868
00:58:35,589 --> 00:58:35,599
no two lectures ago ah okay
 

2869
00:58:35,599 --> 00:58:36,789
no two lectures ago ah okay
well if we're gonna do this linear

2870
00:58:36,789 --> 00:58:36,799
well if we're gonna do this linear
 

2871
00:58:36,799 --> 00:58:38,309
well if we're gonna do this linear
number of times i guess we should have a

2872
00:58:38,309 --> 00:58:38,319
number of times i guess we should have a
 

2873
00:58:38,319 --> 00:58:39,109
number of times i guess we should have a
for loop

2874
00:58:39,109 --> 00:58:39,119
for loop
 

2875
00:58:39,119 --> 00:58:41,109
for loop
let's do a for loop over the numbers

2876
00:58:41,109 --> 00:58:41,119
let's do a for loop over the numbers
 

2877
00:58:41,119 --> 00:58:44,309
let's do a for loop over the numbers
this next idea

2878
00:58:44,309 --> 00:58:44,319

 

2879
00:58:44,319 --> 00:58:48,150

loop over s

2880
00:58:48,150 --> 00:58:48,160
loop over s
 

2881
00:58:48,160 --> 00:58:52,710
loop over s
and at this point we're done almost um

2882
00:58:52,710 --> 00:58:52,720
and at this point we're done almost um
 

2883
00:58:52,720 --> 00:58:55,829
and at this point we're done almost um
space so i want to

2884
00:58:55,829 --> 00:58:55,839
space so i want to
 

2885
00:58:55,839 --> 00:58:57,510
space so i want to
loop over the numbers and each one i

2886
00:58:57,510 --> 00:58:57,520
loop over the numbers and each one i
 

2887
00:58:57,520 --> 00:58:59,270
loop over the numbers and each one i
want to do a find that's

2888
00:58:59,270 --> 00:58:59,280
want to do a find that's
 

2889
00:58:59,280 --> 00:59:02,549
want to do a find that's
kind of all i have time to do so

2890
00:59:02,549 --> 00:59:02,559
kind of all i have time to do so
 

2891
00:59:02,559 --> 00:59:05,109
kind of all i have time to do so
seems like a natural thing to try this

2892
00:59:05,109 --> 00:59:05,119
seems like a natural thing to try this
 

2893
00:59:05,119 --> 00:59:06,549
seems like a natural thing to try this
this is by no means easy

2894
00:59:06,549 --> 00:59:06,559
this is by no means easy
 

2895
00:59:06,559 --> 00:59:08,230
this is by no means easy
don't don't get me wrong having these

2896
00:59:08,230 --> 00:59:08,240
don't don't get me wrong having these
 

2897
00:59:08,240 --> 00:59:09,670
don't don't get me wrong having these
ideas is well

2898
00:59:09,670 --> 00:59:09,680
ideas is well
 

2899
00:59:09,680 --> 00:59:11,990
ideas is well
i'm explaining them as the obvious ideas

2900
00:59:11,990 --> 00:59:12,000
i'm explaining them as the obvious ideas
 

2901
00:59:12,000 --> 00:59:13,349
i'm explaining them as the obvious ideas
they're not obvious

2902
00:59:13,349 --> 00:59:13,359
they're not obvious
 

2903
00:59:13,359 --> 00:59:16,549
they're not obvious
but uh they are easy at least

2904
00:59:16,549 --> 00:59:16,559
but uh they are easy at least
 

2905
00:59:16,559 --> 00:59:17,910
but uh they are easy at least
just not obvious to come up with the

2906
00:59:17,910 --> 00:59:17,920
just not obvious to come up with the
 

2907
00:59:17,920 --> 00:59:20,950
just not obvious to come up with the
easy ideas so let's loop over s

2908
00:59:20,950 --> 00:59:20,960
easy ideas so let's loop over s
 

2909
00:59:20,960 --> 00:59:23,510
easy ideas so let's loop over s
somehow called find using our hash table

2910
00:59:23,510 --> 00:59:23,520
somehow called find using our hash table
 

2911
00:59:23,520 --> 00:59:24,710
somehow called find using our hash table
so the order is actually we're going to

2912
00:59:24,710 --> 00:59:24,720
so the order is actually we're going to
 

2913
00:59:24,720 --> 00:59:25,750
so the order is actually we're going to
build the hash table

2914
00:59:25,750 --> 00:59:25,760
build the hash table
 

2915
00:59:25,760 --> 00:59:27,190
build the hash table
then loop and inside the loop we're

2916
00:59:27,190 --> 00:59:27,200
then loop and inside the loop we're
 

2917
00:59:27,200 --> 00:59:29,750
then loop and inside the loop we're
going to call find once per loop

2918
00:59:29,750 --> 00:59:29,760
going to call find once per loop
 

2919
00:59:29,760 --> 00:59:33,109
going to call find once per loop
iteration so let's do it let's say

2920
00:59:33,109 --> 00:59:33,119
iteration so let's do it let's say
 

2921
00:59:33,119 --> 00:59:40,230
iteration so let's do it let's say
for uh s-i-m-s

2922
00:59:40,230 --> 00:59:40,240

 

2923
00:59:40,240 --> 00:59:42,549

so i want to find two numbers here i've

2924
00:59:42,549 --> 00:59:42,559
so i want to find two numbers here i've
 

2925
00:59:42,559 --> 00:59:43,670
so i want to find two numbers here i've
exhaustively

2926
00:59:43,670 --> 00:59:43,680
exhaustively
 

2927
00:59:43,680 --> 00:59:46,549
exhaustively
looped over one number i just need to

2928
00:59:46,549 --> 00:59:46,559
looped over one number i just need to
 

2929
00:59:46,559 --> 00:59:47,910
looped over one number i just need to
find the second number that could

2930
00:59:47,910 --> 00:59:47,920
find the second number that could
 

2931
00:59:47,920 --> 00:59:48,789
find the second number that could
possibly

2932
00:59:48,789 --> 00:59:48,799
possibly
 

2933
00:59:48,799 --> 00:59:53,109
possibly
add up right i want to find

2934
00:59:53,109 --> 00:59:53,119

 

2935
00:59:53,119 --> 00:59:56,870

whether there's an sj in s

2936
00:59:56,870 --> 00:59:56,880
whether there's an sj in s
 

2937
00:59:56,880 --> 00:59:59,990
whether there's an sj in s
such that

2938
00:59:59,990 --> 01:00:00,000
such that
 

2939
01:00:00,000 --> 01:00:03,190
such that
s i plus s j

2940
01:00:03,190 --> 01:00:03,200
s i plus s j
 

2941
01:00:03,200 --> 01:00:07,910
s i plus s j
equals h

2942
01:00:07,910 --> 01:00:07,920

 

2943
01:00:07,920 --> 01:00:12,829

can i do that query with find

2944
01:00:12,829 --> 01:00:12,839

 

2945
01:00:12,839 --> 01:00:16,230

oh

2946
01:00:16,230 --> 01:00:16,240

 

2947
01:00:16,240 --> 01:00:18,549

so what what does find do find says if i

2948
01:00:18,549 --> 01:00:18,559
so what what does find do find says if i
 

2949
01:00:18,559 --> 01:00:21,030
so what what does find do find says if i
give you a key

2950
01:00:21,030 --> 01:00:21,040
give you a key
 

2951
01:00:21,040 --> 01:00:22,870
give you a key
it will tell me whether like if i knew

2952
01:00:22,870 --> 01:00:22,880
it will tell me whether like if i knew
 

2953
01:00:22,880 --> 01:00:24,789
it will tell me whether like if i knew
what sj was

2954
01:00:24,789 --> 01:00:24,799
what sj was
 

2955
01:00:24,799 --> 01:00:33,510
what sj was
i it would tell me whether it's in s

2956
01:00:33,510 --> 01:00:33,520

 

2957
01:00:33,520 --> 01:00:36,309

subtract h from s i and see whether that

2958
01:00:36,309 --> 01:00:36,319
subtract h from s i and see whether that
 

2959
01:00:36,319 --> 01:00:38,710
subtract h from s i and see whether that
exists

2960
01:00:38,710 --> 01:00:38,720
exists
 

2961
01:00:38,720 --> 01:00:42,390
exists
okay get it right h minus s-i let's

2962
01:00:42,390 --> 01:00:42,400
okay get it right h minus s-i let's
 

2963
01:00:42,400 --> 01:00:46,150
okay get it right h minus s-i let's
get wrong

2964
01:00:46,150 --> 01:00:46,160

 

2965
01:00:46,160 --> 01:00:47,910

i don't feel bad that you also got it

2966
01:00:47,910 --> 01:00:47,920
i don't feel bad that you also got it
 

2967
01:00:47,920 --> 01:00:49,430
i don't feel bad that you also got it
wrong makes you feel better because i

2968
01:00:49,430 --> 01:00:49,440
wrong makes you feel better because i
 

2969
01:00:49,440 --> 01:00:50,789
wrong makes you feel better because i
always get it wrong

2970
01:00:50,789 --> 01:00:50,799
always get it wrong
 

2971
01:00:50,799 --> 01:00:53,990
always get it wrong
so a claim is this why because what we

2972
01:00:53,990 --> 01:00:54,000
so a claim is this why because what we
 

2973
01:00:54,000 --> 01:00:54,630
so a claim is this why because what we
want to do

2974
01:00:54,630 --> 01:00:54,640
want to do
 

2975
01:00:54,640 --> 01:00:57,829
want to do
is find well

2976
01:00:57,829 --> 01:00:57,839
is find well
 

2977
01:00:57,839 --> 01:01:00,630
is find well
okay let's write see what it says over

2978
01:01:00,630 --> 01:01:00,640
okay let's write see what it says over
 

2979
01:01:00,640 --> 01:01:01,510
okay let's write see what it says over
here so if we do h

2980
01:01:01,510 --> 01:01:01,520
here so if we do h
 

2981
01:01:01,520 --> 01:01:04,710
here so if we do h
minus s i equals sj

2982
01:01:04,710 --> 01:01:04,720
minus s i equals sj
 

2983
01:01:04,720 --> 01:01:07,589
minus s i equals sj
right so these are equivalent statements

2984
01:01:07,589 --> 01:01:07,599
right so these are equivalent statements
 

2985
01:01:07,599 --> 01:01:08,470
right so these are equivalent statements
just by

2986
01:01:08,470 --> 01:01:08,480
just by
 

2987
01:01:08,480 --> 01:01:11,270
just by
moving the si over and this is a query

2988
01:01:11,270 --> 01:01:11,280
moving the si over and this is a query
 

2989
01:01:11,280 --> 01:01:11,829
moving the si over and this is a query
we can do

2990
01:01:11,829 --> 01:01:11,839
we can do
 

2991
01:01:11,839 --> 01:01:14,309
we can do
we don't so let's remember these are

2992
01:01:14,309 --> 01:01:14,319
we don't so let's remember these are
 

2993
01:01:14,319 --> 01:01:19,750
we don't so let's remember these are
things we know

2994
01:01:19,750 --> 01:01:19,760

 

2995
01:01:19,760 --> 01:01:21,750

and sj is something we don't know

2996
01:01:21,750 --> 01:01:21,760
and sj is something we don't know
 

2997
01:01:21,760 --> 01:01:23,990
and sj is something we don't know
although we know is that it's an s

2998
01:01:23,990 --> 01:01:24,000
although we know is that it's an s
 

2999
01:01:24,000 --> 01:01:25,589
although we know is that it's an s
okay so we know these two things so if

3000
01:01:25,589 --> 01:01:25,599
okay so we know these two things so if
 

3001
01:01:25,599 --> 01:01:27,750
okay so we know these two things so if
we bring them over to the same side

3002
01:01:27,750 --> 01:01:27,760
we bring them over to the same side
 

3003
01:01:27,760 --> 01:01:29,990
we bring them over to the same side
we're searching for an unknown thing

3004
01:01:29,990 --> 01:01:30,000
we're searching for an unknown thing
 

3005
01:01:30,000 --> 01:01:31,670
we're searching for an unknown thing
which is equal to exactly this thing

3006
01:01:31,670 --> 01:01:31,680
which is equal to exactly this thing
 

3007
01:01:31,680 --> 01:01:32,870
which is equal to exactly this thing
that we can compute

3008
01:01:32,870 --> 01:01:32,880
that we can compute
 

3009
01:01:32,880 --> 01:01:35,510
that we can compute
so we just compute h minus s i we call

3010
01:01:35,510 --> 01:01:35,520
so we just compute h minus s i we call
 

3011
01:01:35,520 --> 01:01:37,109
so we just compute h minus s i we call
find that will tell us whether there is

3012
01:01:37,109 --> 01:01:37,119
find that will tell us whether there is
 

3013
01:01:37,119 --> 01:01:37,990
find that will tell us whether there is
an sj

3014
01:01:37,990 --> 01:01:38,000
an sj
 

3015
01:01:38,000 --> 01:01:41,349
an sj
equal to this okay so this is

3016
01:01:41,349 --> 01:01:41,359
equal to this okay so this is
 

3017
01:01:41,359 --> 01:01:43,589
equal to this okay so this is
this is like a comment all right and

3018
01:01:43,589 --> 01:01:43,599
this is like a comment all right and
 

3019
01:01:43,599 --> 01:01:45,910
this is like a comment all right and
then this is what we actually do

3020
01:01:45,910 --> 01:01:45,920
then this is what we actually do
 

3021
01:01:45,920 --> 01:01:48,150
then this is what we actually do
and if there is a pair of numbers

3022
01:01:48,150 --> 01:01:48,160
and if there is a pair of numbers
 

3023
01:01:48,160 --> 01:01:50,230
and if there is a pair of numbers
summing the h this will find it

3024
01:01:50,230 --> 01:01:50,240
summing the h this will find it
 

3025
01:01:50,240 --> 01:01:52,150
summing the h this will find it
how much time did it take well we're

3026
01:01:52,150 --> 01:01:52,160
how much time did it take well we're
 

3027
01:01:52,160 --> 01:01:54,549
how much time did it take well we're
doing n iterations of this loop

3028
01:01:54,549 --> 01:01:54,559
doing n iterations of this loop
 

3029
01:01:54,559 --> 01:01:56,150
doing n iterations of this loop
each one we're calling a single find

3030
01:01:56,150 --> 01:01:56,160
each one we're calling a single find
 

3031
01:01:56,160 --> 01:01:57,670
each one we're calling a single find
operation and

3032
01:01:57,670 --> 01:01:57,680
operation and
 

3033
01:01:57,680 --> 01:02:01,750
operation and
find cos constant expected time

3034
01:02:01,750 --> 01:02:01,760
find cos constant expected time
 

3035
01:02:01,760 --> 01:02:04,230
find cos constant expected time
and so the total is linear with respect

3036
01:02:04,230 --> 01:02:04,240
and so the total is linear with respect
 

3037
01:02:04,240 --> 01:02:05,589
and so the total is linear with respect
to time

3038
01:02:05,589 --> 01:02:05,599
to time
 

3039
01:02:05,599 --> 01:02:19,430
to time
great part a done

3040
01:02:19,430 --> 01:02:19,440

 

3041
01:02:19,440 --> 01:02:21,510

then they throw part b at us to make it

3042
01:02:21,510 --> 01:02:21,520
then they throw part b at us to make it
 

3043
01:02:21,520 --> 01:02:24,150
then they throw part b at us to make it
harder

3044
01:02:24,150 --> 01:02:24,160

 

3045
01:02:24,160 --> 01:02:33,589

those pesky instructors

3046
01:02:33,589 --> 01:02:33,599

 

3047
01:02:33,599 --> 01:02:37,589

so we read part b and part b

3048
01:02:37,589 --> 01:02:37,599
so we read part b and part b
 

3049
01:02:37,599 --> 01:02:41,109
so we read part b and part b
says two things to make it harder

3050
01:02:41,109 --> 01:02:41,119
says two things to make it harder
 

3051
01:02:41,119 --> 01:02:44,390
says two things to make it harder
so first of all we want linear worst

3052
01:02:44,390 --> 01:02:44,400
so first of all we want linear worst
 

3053
01:02:44,400 --> 01:02:50,150
so first of all we want linear worst
case time

3054
01:02:50,150 --> 01:02:50,160

 

3055
01:02:50,160 --> 01:02:53,109

and furthermore so we can't use hashing

3056
01:02:53,109 --> 01:02:53,119
and furthermore so we can't use hashing
 

3057
01:02:53,119 --> 01:02:54,309
and furthermore so we can't use hashing
anymore

3058
01:02:54,309 --> 01:02:54,319
anymore
 

3059
01:02:54,319 --> 01:02:57,270
anymore
furthermore uh so here we just needed to

3060
01:02:57,270 --> 01:02:57,280
furthermore uh so here we just needed to
 

3061
01:02:57,280 --> 01:02:58,950
furthermore uh so here we just needed to
solve the exact problem to find whether

3062
01:02:58,950 --> 01:02:58,960
solve the exact problem to find whether
 

3063
01:02:58,960 --> 01:03:01,430
solve the exact problem to find whether
the two numbers summing exactly to h

3064
01:03:01,430 --> 01:03:01,440
the two numbers summing exactly to h
 

3065
01:03:01,440 --> 01:03:03,109
the two numbers summing exactly to h
now we would like to find the best

3066
01:03:03,109 --> 01:03:03,119
now we would like to find the best
 

3067
01:03:03,119 --> 01:03:05,829
now we would like to find the best
solution smaller than or equal to h

3068
01:03:05,829 --> 01:03:05,839
solution smaller than or equal to h
 

3069
01:03:05,839 --> 01:03:11,670
solution smaller than or equal to h
so find biggest

3070
01:03:11,670 --> 01:03:11,680

 

3071
01:03:11,680 --> 01:03:17,349

pairwise sum

3072
01:03:17,349 --> 01:03:17,359
pairwise sum
 

3073
01:03:17,359 --> 01:03:20,390
pairwise sum
that's less than or equal to h if no

3074
01:03:20,390 --> 01:03:20,400
that's less than or equal to h if no
 

3075
01:03:20,400 --> 01:03:23,349
that's less than or equal to h if no
if there's no perfect pair but we're

3076
01:03:23,349 --> 01:03:23,359
if there's no perfect pair but we're
 

3077
01:03:23,359 --> 01:03:23,829
if there's no perfect pair but we're
given

3078
01:03:23,829 --> 01:03:23,839
given
 

3079
01:03:23,839 --> 01:03:28,150
given
a little bit of extra information

3080
01:03:28,150 --> 01:03:28,160

 

3081
01:03:28,160 --> 01:03:31,990

which is we can assume h

3082
01:03:31,990 --> 01:03:32,000

 

3083
01:03:32,000 --> 01:03:37,349

equals 600 n to the sixth

3084
01:03:37,349 --> 01:03:37,359

 

3085
01:03:37,359 --> 01:03:40,789

it's a weird polynomial it took me a

3086
01:03:40,789 --> 01:03:40,799
it's a weird polynomial it took me a
 

3087
01:03:40,799 --> 01:03:42,630
it's a weird polynomial it took me a
while to even notice that that was jerk

3088
01:03:42,630 --> 01:03:42,640
while to even notice that that was jerk
 

3089
01:03:42,640 --> 01:03:43,270
while to even notice that that was jerk
in here

3090
01:03:43,270 --> 01:03:43,280
in here
 

3091
01:03:43,280 --> 01:03:46,870
in here
6006 hiding in a polynomial

3092
01:03:46,870 --> 01:03:46,880
6006 hiding in a polynomial
 

3093
01:03:46,880 --> 01:03:50,870
6006 hiding in a polynomial
all right so polynomial

3094
01:03:50,870 --> 01:03:50,880
all right so polynomial
 

3095
01:03:50,880 --> 01:03:52,789
all right so polynomial
that should make you think radix sort it

3096
01:03:52,789 --> 01:03:52,799
that should make you think radix sort it
 

3097
01:03:52,799 --> 01:03:53,990
that should make you think radix sort it
is radix or weak

3098
01:03:53,990 --> 01:03:54,000
is radix or weak
 

3099
01:03:54,000 --> 01:03:56,630
is radix or weak
so that is a natural thing to try but in

3100
01:03:56,630 --> 01:03:56,640
so that is a natural thing to try but in
 

3101
01:03:56,640 --> 01:03:58,549
so that is a natural thing to try but in
general even later in the semester when

3102
01:03:58,549 --> 01:03:58,559
general even later in the semester when
 

3103
01:03:58,559 --> 01:03:59,510
general even later in the semester when
you see

3104
01:03:59,510 --> 01:03:59,520
you see
 

3105
01:03:59,520 --> 01:04:02,470
you see
uh a nice polynomial with a fixed

3106
01:04:02,470 --> 01:04:02,480
uh a nice polynomial with a fixed
 

3107
01:04:02,480 --> 01:04:03,589
uh a nice polynomial with a fixed
constant like this

3108
01:04:03,589 --> 01:04:03,599
constant like this
 

3109
01:04:03,599 --> 01:04:05,190
constant like this
and it's somehow related to the integers

3110
01:04:05,190 --> 01:04:05,200
and it's somehow related to the integers
 

3111
01:04:05,200 --> 01:04:06,230
and it's somehow related to the integers
we're dealing with you should think

3112
01:04:06,230 --> 01:04:06,240
we're dealing with you should think
 

3113
01:04:06,240 --> 01:04:07,510
we're dealing with you should think
radix sort especially because now we

3114
01:04:07,510 --> 01:04:07,520
radix sort especially because now we
 

3115
01:04:07,520 --> 01:04:09,589
radix sort especially because now we
want constant worst case time

3116
01:04:09,589 --> 01:04:09,599
want constant worst case time
 

3117
01:04:09,599 --> 01:04:10,870
want constant worst case time
rate of source seems like a good thing

3118
01:04:10,870 --> 01:04:10,880
rate of source seems like a good thing
 

3119
01:04:10,880 --> 01:04:13,270
rate of source seems like a good thing
to do don't know what to do with it yet

3120
01:04:13,270 --> 01:04:13,280
to do don't know what to do with it yet
 

3121
01:04:13,280 --> 01:04:14,069
to do don't know what to do with it yet
in fact

3122
01:04:14,069 --> 01:04:14,079
in fact
 

3123
01:04:14,079 --> 01:04:16,390
in fact
i can't even apply radix sort but idea

3124
01:04:16,390 --> 01:04:16,400
i can't even apply radix sort but idea
 

3125
01:04:16,400 --> 01:04:17,190
i can't even apply radix sort but idea
one

3126
01:04:17,190 --> 01:04:17,200
one
 

3127
01:04:17,200 --> 01:04:19,829
one
is radical just because i see that

3128
01:04:19,829 --> 01:04:19,839
is radical just because i see that
 

3129
01:04:19,839 --> 01:04:20,870
is radical just because i see that
polynomial

3130
01:04:20,870 --> 01:04:20,880
polynomial
 

3131
01:04:20,880 --> 01:04:24,470
polynomial
i think maybe i should try it

3132
01:04:24,470 --> 01:04:24,480
i think maybe i should try it
 

3133
01:04:24,480 --> 01:04:26,789
i think maybe i should try it
now there's a problem here because we're

3134
01:04:26,789 --> 01:04:26,799
now there's a problem here because we're
 

3135
01:04:26,799 --> 01:04:28,950
now there's a problem here because we're
given some numbers

3136
01:04:28,950 --> 01:04:28,960
given some numbers
 

3137
01:04:28,960 --> 01:04:31,349
given some numbers
we're all some integers s i's we're also

3138
01:04:31,349 --> 01:04:31,359
we're all some integers s i's we're also
 

3139
01:04:31,359 --> 01:04:33,190
we're all some integers s i's we're also
given h we're told now that h is a nice

3140
01:04:33,190 --> 01:04:33,200
given h we're told now that h is a nice
 

3141
01:04:33,200 --> 01:04:34,390
given h we're told now that h is a nice
small polynomial

3142
01:04:34,390 --> 01:04:34,400
small polynomial
 

3143
01:04:34,400 --> 01:04:36,150
small polynomial
we have no idea how big these numbers

3144
01:04:36,150 --> 01:04:36,160
we have no idea how big these numbers
 

3145
01:04:36,160 --> 01:04:37,589
we have no idea how big these numbers
are

3146
01:04:37,589 --> 01:04:37,599
are
 

3147
01:04:37,599 --> 01:04:43,270
are
so problem with this idea is that um

3148
01:04:43,270 --> 01:04:43,280

 

3149
01:04:43,280 --> 01:04:46,470

when s i could be bigger than h we we

3150
01:04:46,470 --> 01:04:46,480
when s i could be bigger than h we we
 

3151
01:04:46,480 --> 01:04:47,589
when s i could be bigger than h we we
have no idea how big

3152
01:04:47,589 --> 01:04:47,599
have no idea how big
 

3153
01:04:47,599 --> 01:04:51,190
have no idea how big
the s i's are can i

3154
01:04:51,190 --> 01:04:51,200
the s i's are can i
 

3155
01:04:51,200 --> 01:04:53,349
the s i's are can i
what can i say about s i's that are

3156
01:04:53,349 --> 01:04:53,359
what can i say about s i's that are
 

3157
01:04:53,359 --> 01:04:56,549
what can i say about s i's that are
bigger than h

3158
01:04:56,549 --> 01:04:56,559

 

3159
01:04:56,559 --> 01:05:00,069

for this problem

3160
01:05:00,069 --> 01:05:00,079

 

3161
01:05:00,079 --> 01:05:03,589

summing to h oh i didn't say but all

3162
01:05:03,589 --> 01:05:03,599
summing to h oh i didn't say but all
 

3163
01:05:03,599 --> 01:05:05,029
summing to h oh i didn't say but all
these numbers are non-negative that's

3164
01:05:05,029 --> 01:05:05,039
these numbers are non-negative that's
 

3165
01:05:05,039 --> 01:05:06,309
these numbers are non-negative that's
important

3166
01:05:06,309 --> 01:05:06,319
important
 

3167
01:05:06,319 --> 01:05:09,589
important
that looks like korean

3168
01:05:09,589 --> 01:05:09,599
that looks like korean
 

3169
01:05:09,599 --> 01:05:16,630
that looks like korean
greater than or equal to zero

3170
01:05:16,630 --> 01:05:16,640

 

3171
01:05:16,640 --> 01:05:19,349

yeah well they can't be a solution right

3172
01:05:19,349 --> 01:05:19,359
yeah well they can't be a solution right
 

3173
01:05:19,359 --> 01:05:20,630
yeah well they can't be a solution right
if i'm finding a sum that's less than

3174
01:05:20,630 --> 01:05:20,640
if i'm finding a sum that's less than
 

3175
01:05:20,640 --> 01:05:22,390
if i'm finding a sum that's less than
equal to h they're non-negative

3176
01:05:22,390 --> 01:05:22,400
equal to h they're non-negative
 

3177
01:05:22,400 --> 01:05:25,109
equal to h they're non-negative
uh and any number any number that's

3178
01:05:25,109 --> 01:05:25,119
uh and any number any number that's
 

3179
01:05:25,119 --> 01:05:25,829
uh and any number any number that's
greater than h

3180
01:05:25,829 --> 01:05:25,839
greater than h
 

3181
01:05:25,839 --> 01:05:28,870
greater than h
i can just throw away they'll never be

3182
01:05:28,870 --> 01:05:28,880
i can just throw away they'll never be
 

3183
01:05:28,880 --> 01:05:29,670
i can just throw away they'll never be
in a solution

3184
01:05:29,670 --> 01:05:29,680
in a solution
 

3185
01:05:29,680 --> 01:05:31,510
in a solution
it's like already a single sum of one

3186
01:05:31,510 --> 01:05:31,520
it's like already a single sum of one
 

3187
01:05:31,520 --> 01:05:33,190
it's like already a single sum of one
numbers here than h so two is only going

3188
01:05:33,190 --> 01:05:33,200
numbers here than h so two is only going
 

3189
01:05:33,200 --> 01:05:37,910
numbers here than h so two is only going
to get bigger if they're non-negative

3190
01:05:37,910 --> 01:05:37,920

 

3191
01:05:37,920 --> 01:05:39,990

so let's idea number two is let's just

3192
01:05:39,990 --> 01:05:40,000
so let's idea number two is let's just
 

3193
01:05:40,000 --> 01:05:41,670
so let's idea number two is let's just
throw out all the big sis

3194
01:05:41,670 --> 01:05:41,680
throw out all the big sis
 

3195
01:05:41,680 --> 01:05:44,230
throw out all the big sis
anything bigger than h now that won't

3196
01:05:44,230 --> 01:05:44,240
anything bigger than h now that won't
 

3197
01:05:44,240 --> 01:05:45,670
anything bigger than h now that won't
change the answer because those can

3198
01:05:45,670 --> 01:05:45,680
change the answer because those can
 

3199
01:05:45,680 --> 01:05:47,190
change the answer because those can
never be in a solution

3200
01:05:47,190 --> 01:05:47,200
never be in a solution
 

3201
01:05:47,200 --> 01:05:49,029
never be in a solution
and now i have all the sis having the

3202
01:05:49,029 --> 01:05:49,039
and now i have all the sis having the
 

3203
01:05:49,039 --> 01:05:50,470
and now i have all the sis having the
property that they're less than or equal

3204
01:05:50,470 --> 01:05:50,480
property that they're less than or equal
 

3205
01:05:50,480 --> 01:05:51,589
property that they're less than or equal
to h

3206
01:05:51,589 --> 01:05:51,599
to h
 

3207
01:05:51,599 --> 01:05:54,710
to h
and so they are small

3208
01:05:54,710 --> 01:05:54,720
and so they are small
 

3209
01:05:54,720 --> 01:05:56,470
and so they are small
bounded by a fixed polynomial and now i

3210
01:05:56,470 --> 01:05:56,480
bounded by a fixed polynomial and now i
 

3211
01:05:56,480 --> 01:05:58,549
bounded by a fixed polynomial and now i
can apply radix sort so after this idea

3212
01:05:58,549 --> 01:05:58,559
can apply radix sort so after this idea
 

3213
01:05:58,559 --> 01:06:00,870
can apply radix sort so after this idea
i can apply this idea

3214
01:06:00,870 --> 01:06:00,880
i can apply this idea
 

3215
01:06:00,880 --> 01:06:02,789
i can apply this idea
okay this gives you a flavor of how i

3216
01:06:02,789 --> 01:06:02,799
okay this gives you a flavor of how i
 

3217
01:06:02,799 --> 01:06:04,630
okay this gives you a flavor of how i
like to think about problems

3218
01:06:04,630 --> 01:06:04,640
like to think about problems
 

3219
01:06:04,640 --> 01:06:06,950
like to think about problems
i see clues like polynomial i think

3220
01:06:06,950 --> 01:06:06,960
i see clues like polynomial i think
 

3221
01:06:06,960 --> 01:06:07,990
i see clues like polynomial i think
radix sort

3222
01:06:07,990 --> 01:06:08,000
radix sort
 

3223
01:06:08,000 --> 01:06:10,309
radix sort
doesn't work but with some more ideas i

3224
01:06:10,309 --> 01:06:10,319
doesn't work but with some more ideas i
 

3225
01:06:10,319 --> 01:06:12,630
doesn't work but with some more ideas i
can get it to work

3226
01:06:12,630 --> 01:06:12,640
can get it to work
 

3227
01:06:12,640 --> 01:06:15,670
can get it to work
okay uh what good is it

3228
01:06:15,670 --> 01:06:15,680
okay uh what good is it
 

3229
01:06:15,680 --> 01:06:19,109
okay uh what good is it
so now i've sorted si okay great s

3230
01:06:19,109 --> 01:06:19,119
so now i've sorted si okay great s
 

3231
01:06:19,119 --> 01:06:23,510
so now i've sorted si okay great s
is sorted

3232
01:06:23,510 --> 01:06:23,520

 

3233
01:06:23,520 --> 01:06:25,829

i guess we can try to do the same

3234
01:06:25,829 --> 01:06:25,839
i guess we can try to do the same
 

3235
01:06:25,839 --> 01:06:27,029
i guess we can try to do the same
algorithm

3236
01:06:27,029 --> 01:06:27,039
algorithm
 

3237
01:06:27,039 --> 01:06:29,349
algorithm
except i don't have a hash table anymore

3238
01:06:29,349 --> 01:06:29,359
except i don't have a hash table anymore
 

3239
01:06:29,359 --> 01:06:30,309
except i don't have a hash table anymore
so let's just

3240
01:06:30,309 --> 01:06:30,319
so let's just
 

3241
01:06:30,319 --> 01:06:33,510
so let's just
try doing a for loop over the s

3242
01:06:33,510 --> 01:06:33,520
try doing a for loop over the s
 

3243
01:06:33,520 --> 01:06:37,829
try doing a for loop over the s
why not so let's do 4

3244
01:06:37,829 --> 01:06:37,839

 

3245
01:06:37,839 --> 01:06:40,309

s i and s but now it's sorted so

3246
01:06:40,309 --> 01:06:40,319
s i and s but now it's sorted so
 

3247
01:06:40,319 --> 01:06:41,829
s i and s but now it's sorted so
presumably i should exploit the

3248
01:06:41,829 --> 01:06:41,839
presumably i should exploit the
 

3249
01:06:41,839 --> 01:06:45,349
presumably i should exploit the
sorted order so let's do do them in

3250
01:06:45,349 --> 01:06:45,359
sorted order so let's do do them in
 

3251
01:06:45,359 --> 01:06:46,069
sorted order so let's do do them in
order so i

3252
01:06:46,069 --> 01:06:46,079
order so i
 

3253
01:06:46,079 --> 01:06:49,750
order so i
equals 0 1 up to n minus 1.

3254
01:06:49,750 --> 01:06:49,760
equals 0 1 up to n minus 1.
 

3255
01:06:49,760 --> 01:06:52,309
equals 0 1 up to n minus 1.
let's say that s 0 is the smallest s 1

3256
01:06:52,309 --> 01:06:52,319
let's say that s 0 is the smallest s 1
 

3257
01:06:52,319 --> 01:06:52,789
let's say that s 0 is the smallest s 1
is the

3258
01:06:52,789 --> 01:06:52,799
is the
 

3259
01:06:52,799 --> 01:06:56,150
is the
next smallest s n minus 1 is the biggest

3260
01:06:56,150 --> 01:06:56,160
next smallest s n minus 1 is the biggest
 

3261
01:06:56,160 --> 01:06:58,309
next smallest s n minus 1 is the biggest
so i want to do something with this so i

3262
01:06:58,309 --> 01:06:58,319
so i want to do something with this so i
 

3263
01:06:58,319 --> 01:07:02,069
so i want to do something with this so i
have s i and i want to figure out

3264
01:07:02,069 --> 01:07:02,079
have s i and i want to figure out
 

3265
01:07:02,079 --> 01:07:08,549
have s i and i want to figure out
whether h minus s i is in there

3266
01:07:08,549 --> 01:07:08,559

 

3267
01:07:08,559 --> 01:07:11,910

hard to do that better than ah

3268
01:07:11,910 --> 01:07:11,920
hard to do that better than ah
 

3269
01:07:11,920 --> 01:07:13,670
hard to do that better than ah
actually i could do this with binary

3270
01:07:13,670 --> 01:07:13,680
actually i could do this with binary
 

3271
01:07:13,680 --> 01:07:15,109
actually i could do this with binary
search right

3272
01:07:15,109 --> 01:07:15,119
search right
 

3273
01:07:15,119 --> 01:07:18,230
search right
i know i'm looking for this value so i

3274
01:07:18,230 --> 01:07:18,240
i know i'm looking for this value so i
 

3275
01:07:18,240 --> 01:07:18,630
i know i'm looking for this value so i
could

3276
01:07:18,630 --> 01:07:18,640
could
 

3277
01:07:18,640 --> 01:07:20,549
could
and i have a sorted array now so i could

3278
01:07:20,549 --> 01:07:20,559
and i have a sorted array now so i could
 

3279
01:07:20,559 --> 01:07:22,789
and i have a sorted array now so i could
binary search for h minus si

3280
01:07:22,789 --> 01:07:22,799
binary search for h minus si
 

3281
01:07:22,799 --> 01:07:25,029
binary search for h minus si
and in login time i will find whether

3282
01:07:25,029 --> 01:07:25,039
and in login time i will find whether
 

3283
01:07:25,039 --> 01:07:26,390
and in login time i will find whether
that guy is in there

3284
01:07:26,390 --> 01:07:26,400
that guy is in there
 

3285
01:07:26,400 --> 01:07:28,309
that guy is in there
and if not keep looping i can keep track

3286
01:07:28,309 --> 01:07:28,319
and if not keep looping i can keep track
 

3287
01:07:28,319 --> 01:07:29,670
and if not keep looping i can keep track
of the best thing that i've found

3288
01:07:29,670 --> 01:07:29,680
of the best thing that i've found
 

3289
01:07:29,680 --> 01:07:31,430
of the best thing that i've found
and so in n log n time i can definitely

3290
01:07:31,430 --> 01:07:31,440
and so in n log n time i can definitely
 

3291
01:07:31,440 --> 01:07:33,670
and so in n log n time i can definitely
solve this but i'd like to get

3292
01:07:33,670 --> 01:07:33,680
solve this but i'd like to get
 

3293
01:07:33,680 --> 01:07:41,910
solve this but i'd like to get
linear time okay good question

3294
01:07:41,910 --> 01:07:41,920

 

3295
01:07:41,920 --> 01:07:43,589

i'm not looking for s i i'm going to

3296
01:07:43,589 --> 01:07:43,599
i'm not looking for s i i'm going to
 

3297
01:07:43,599 --> 01:07:45,430
i'm not looking for s i i'm going to
compute h minus s i

3298
01:07:45,430 --> 01:07:45,440
compute h minus s i
 

3299
01:07:45,440 --> 01:07:47,589
compute h minus s i
so so this is maybe i shouldn't even

3300
01:07:47,589 --> 01:07:47,599
so so this is maybe i shouldn't even
 

3301
01:07:47,599 --> 01:08:00,870
so so this is maybe i shouldn't even
write this down

3302
01:08:00,870 --> 01:08:00,880

 

3303
01:08:00,880 --> 01:08:03,910

right so in particular if um

3304
01:08:03,910 --> 01:08:03,920
right so in particular if um
 

3305
01:08:03,920 --> 01:08:06,230
right so in particular if um
if there are two items that sum to h i

3306
01:08:06,230 --> 01:08:06,240
if there are two items that sum to h i
 

3307
01:08:06,240 --> 01:08:07,750
if there are two items that sum to h i
want to find it

3308
01:08:07,750 --> 01:08:07,760
want to find it
 

3309
01:08:07,760 --> 01:08:09,990
want to find it
so uh so let's start with that so i'm

3310
01:08:09,990 --> 01:08:10,000
so uh so let's start with that so i'm
 

3311
01:08:10,000 --> 01:08:11,829
so uh so let's start with that so i'm
binary searching for

3312
01:08:11,829 --> 01:08:11,839
binary searching for
 

3313
01:08:11,839 --> 01:08:15,430
binary searching for
h minus s i in s so i could certainly do

3314
01:08:15,430 --> 01:08:15,440
h minus s i in s so i could certainly do
 

3315
01:08:15,440 --> 01:08:16,229
h minus s i in s so i could certainly do
that

3316
01:08:16,229 --> 01:08:16,239
that
 

3317
01:08:16,239 --> 01:08:19,910
that
and um if i if i find it great i found a

3318
01:08:19,910 --> 01:08:19,920
and um if i if i find it great i found a
 

3319
01:08:19,920 --> 01:08:21,669
and um if i if i find it great i found a
pair that sums to exactly h if i don't

3320
01:08:21,669 --> 01:08:21,679
pair that sums to exactly h if i don't
 

3321
01:08:21,679 --> 01:08:22,470
pair that sums to exactly h if i don't
find it

3322
01:08:22,470 --> 01:08:22,480
find it
 

3323
01:08:22,480 --> 01:08:24,870
find it
binary search tells me not only that

3324
01:08:24,870 --> 01:08:24,880
binary search tells me not only that
 

3325
01:08:24,880 --> 01:08:26,470
binary search tells me not only that
it's not there but it tells me what the

3326
01:08:26,470 --> 01:08:26,480
it's not there but it tells me what the
 

3327
01:08:26,480 --> 01:08:27,030
it's not there but it tells me what the
previous

3328
01:08:27,030 --> 01:08:27,040
previous
 

3329
01:08:27,040 --> 01:08:29,269
previous
and next value are so even though h

3330
01:08:29,269 --> 01:08:29,279
and next value are so even though h
 

3331
01:08:29,279 --> 01:08:30,950
and next value are so even though h
minus s i isn't there i can get what the

3332
01:08:30,950 --> 01:08:30,960
minus s i isn't there i can get what the
 

3333
01:08:30,960 --> 01:08:31,510
minus s i isn't there i can get what the
large

3334
01:08:31,510 --> 01:08:31,520
large
 

3335
01:08:31,520 --> 01:08:32,709
large
the next largest thing and the next

3336
01:08:32,709 --> 01:08:32,719
the next largest thing and the next
 

3337
01:08:32,719 --> 01:08:34,070
the next largest thing and the next
smallest thing what i want is the next

3338
01:08:34,070 --> 01:08:34,080
smallest thing what i want is the next
 

3339
01:08:34,080 --> 01:08:35,189
smallest thing what i want is the next
smallest thing

3340
01:08:35,189 --> 01:08:35,199
smallest thing
 

3341
01:08:35,199 --> 01:08:37,349
smallest thing
and that will be the largest sum i can

3342
01:08:37,349 --> 01:08:37,359
and that will be the largest sum i can
 

3343
01:08:37,359 --> 01:08:38,630
and that will be the largest sum i can
get using s

3344
01:08:38,630 --> 01:08:38,640
get using s
 

3345
01:08:38,640 --> 01:08:42,309
get using s
i and so then that's one candidate

3346
01:08:42,309 --> 01:08:42,319
i and so then that's one candidate
 

3347
01:08:42,319 --> 01:08:44,789
i and so then that's one candidate
for a sum let's equal to h i want to

3348
01:08:44,789 --> 01:08:44,799
for a sum let's equal to h i want to
 

3349
01:08:44,799 --> 01:08:46,709
for a sum let's equal to h i want to
find the largest one so i do a for loop

3350
01:08:46,709 --> 01:08:46,719
find the largest one so i do a for loop
 

3351
01:08:46,719 --> 01:08:48,870
find the largest one so i do a for loop
i always keep track i take a list of all

3352
01:08:48,870 --> 01:08:48,880
i always keep track i take a list of all
 

3353
01:08:48,880 --> 01:08:50,709
i always keep track i take a list of all
the candidates i got each time i do a

3354
01:08:50,709 --> 01:08:50,719
the candidates i got each time i do a
 

3355
01:08:50,719 --> 01:08:51,430
the candidates i got each time i do a
four

3356
01:08:51,430 --> 01:08:51,440
four
 

3357
01:08:51,440 --> 01:08:52,709
four
iteration of this loop i get one

3358
01:08:52,709 --> 01:08:52,719
iteration of this loop i get one
 

3359
01:08:52,719 --> 01:08:56,070
iteration of this loop i get one
candidate then i take the largest one

3360
01:08:56,070 --> 01:08:56,080
candidate then i take the largest one
 

3361
01:08:56,080 --> 01:09:06,630
candidate then i take the largest one
okay so return largest candidate

3362
01:09:06,630 --> 01:09:06,640
okay so return largest candidate
 

3363
01:09:06,640 --> 01:09:09,749
okay so return largest candidate
so this gives me a candidate

3364
01:09:09,749 --> 01:09:09,759
so this gives me a candidate
 

3365
01:09:09,759 --> 01:09:13,030
so this gives me a candidate
which is uh the previous item this is

3366
01:09:13,030 --> 01:09:13,040
which is uh the previous item this is
 

3367
01:09:13,040 --> 01:09:13,669
which is uh the previous item this is
what we called

3368
01:09:13,669 --> 01:09:13,679
what we called
 

3369
01:09:13,679 --> 01:09:16,550
what we called
find previous or find prev probably in

3370
01:09:16,550 --> 01:09:16,560
find previous or find prev probably in
 

3371
01:09:16,560 --> 01:09:18,149
find previous or find prev probably in
our set interface

3372
01:09:18,149 --> 01:09:18,159
our set interface
 

3373
01:09:18,159 --> 01:09:19,749
our set interface
and if you have a sorted set you can do

3374
01:09:19,749 --> 01:09:19,759
and if you have a sorted set you can do
 

3375
01:09:19,759 --> 01:09:21,990
and if you have a sorted set you can do
that in log n time so this is an n log n

3376
01:09:21,990 --> 01:09:22,000
that in log n time so this is an n log n
 

3377
01:09:22,000 --> 01:09:25,269
that in log n time so this is an n log n
solution

3378
01:09:25,269 --> 01:09:25,279

 

3379
01:09:25,279 --> 01:09:27,590

i want because we do n iterations for

3380
01:09:27,590 --> 01:09:27,600
i want because we do n iterations for
 

3381
01:09:27,600 --> 01:09:29,829
i want because we do n iterations for
the loop each binary search takes log n

3382
01:09:29,829 --> 01:09:29,839
the loop each binary search takes log n
 

3383
01:09:29,839 --> 01:09:34,709
the loop each binary search takes log n
i want to get linear this

3384
01:09:34,709 --> 01:09:34,719
i want to get linear this
 

3385
01:09:34,719 --> 01:09:40,550
i want to get linear this
is not obvious

3386
01:09:40,550 --> 01:09:40,560

 

3387
01:09:40,560 --> 01:09:42,229

the best intuition i can think of for

3388
01:09:42,229 --> 01:09:42,239
the best intuition i can think of for
 

3389
01:09:42,239 --> 01:09:44,309
the best intuition i can think of for
this next idea is

3390
01:09:44,309 --> 01:09:44,319
this next idea is
 

3391
01:09:44,319 --> 01:09:47,510
this next idea is
well i start with a very small

3392
01:09:47,510 --> 01:09:47,520
well i start with a very small
 

3393
01:09:47,520 --> 01:09:50,870
well i start with a very small
smallest item in s and i want to sum up

3394
01:09:50,870 --> 01:09:50,880
smallest item in s and i want to sum up
 

3395
01:09:50,880 --> 01:09:52,309
smallest item in s and i want to sum up
to something that's kind of

3396
01:09:52,309 --> 01:09:52,319
to something that's kind of
 

3397
01:09:52,319 --> 01:09:54,950
to something that's kind of
big i threw away all the items bigger

3398
01:09:54,950 --> 01:09:54,960
big i threw away all the items bigger
 

3399
01:09:54,960 --> 01:09:55,990
big i threw away all the items bigger
than h

3400
01:09:55,990 --> 01:09:56,000
than h
 

3401
01:09:56,000 --> 01:09:58,950
than h
if i start if s zero is like tiny like

3402
01:09:58,950 --> 01:09:58,960
if i start if s zero is like tiny like
 

3403
01:09:58,960 --> 01:10:00,550
if i start if s zero is like tiny like
close to zero

3404
01:10:00,550 --> 01:10:00,560
close to zero
 

3405
01:10:00,560 --> 01:10:02,470
close to zero
because it's the smallest one then maybe

3406
01:10:02,470 --> 01:10:02,480
because it's the smallest one then maybe
 

3407
01:10:02,480 --> 01:10:03,830
because it's the smallest one then maybe
i should look at the

3408
01:10:03,830 --> 01:10:03,840
i should look at the
 

3409
01:10:03,840 --> 01:10:06,070
i should look at the
end of the array because i want to

3410
01:10:06,070 --> 01:10:06,080
end of the array because i want to
 

3411
01:10:06,080 --> 01:10:07,990
end of the array because i want to
compare or i want to add the smallest

3412
01:10:07,990 --> 01:10:08,000
compare or i want to add the smallest
 

3413
01:10:08,000 --> 01:10:09,669
compare or i want to add the smallest
thing probably with the biggest thing

3414
01:10:09,669 --> 01:10:09,679
thing probably with the biggest thing
 

3415
01:10:09,679 --> 01:10:12,870
thing probably with the biggest thing
that's as close as i can imagine uh

3416
01:10:12,870 --> 01:10:12,880
that's as close as i can imagine uh
 

3417
01:10:12,880 --> 01:10:16,950
that's as close as i can imagine uh
so then

3418
01:10:16,950 --> 01:10:16,960
so then
 

3419
01:10:16,960 --> 01:10:19,270
so then
so here's my sorted s this is the

3420
01:10:19,270 --> 01:10:19,280
so here's my sorted s this is the
 

3421
01:10:19,280 --> 01:10:21,110
so here's my sorted s this is the
smallest item biggest item

3422
01:10:21,110 --> 01:10:21,120
smallest item biggest item
 

3423
01:10:21,120 --> 01:10:23,510
smallest item biggest item
so i'm going to loop over these items

3424
01:10:23,510 --> 01:10:23,520
so i'm going to loop over these items
 

3425
01:10:23,520 --> 01:10:25,030
so i'm going to loop over these items
one by one

3426
01:10:25,030 --> 01:10:25,040
one by one
 

3427
01:10:25,040 --> 01:10:26,630
one by one
so let's start by comparing the first

3428
01:10:26,630 --> 01:10:26,640
so let's start by comparing the first
 

3429
01:10:26,640 --> 01:10:31,590
so let's start by comparing the first
one with the last one

3430
01:10:31,590 --> 01:10:31,600
one with the last one
 

3431
01:10:31,600 --> 01:10:41,750
one with the last one
the two-finger algorithm okay

3432
01:10:41,750 --> 01:10:41,760

 

3433
01:10:41,760 --> 01:10:44,390

this is the big idea you're doing it all

3434
01:10:44,390 --> 01:10:44,400
this is the big idea you're doing it all
 

3435
01:10:44,400 --> 01:10:45,990
this is the big idea you're doing it all
the time in this class it's super useful

3436
01:10:45,990 --> 01:10:46,000
the time in this class it's super useful
 

3437
01:10:46,000 --> 01:10:47,590
the time in this class it's super useful
we saw it in merge sort for example and

3438
01:10:47,590 --> 01:10:47,600
we saw it in merge sort for example and
 

3439
01:10:47,600 --> 01:10:48,790
we saw it in merge sort for example and
merging two lists

3440
01:10:48,790 --> 01:10:48,800
merging two lists
 

3441
01:10:48,800 --> 01:10:50,310
merging two lists
we have fingers and two lists that

3442
01:10:50,310 --> 01:10:50,320
we have fingers and two lists that
 

3443
01:10:50,320 --> 01:10:52,470
we have fingers and two lists that
advance and because they only advance

3444
01:10:52,470 --> 01:10:52,480
advance and because they only advance
 

3445
01:10:52,480 --> 01:10:54,790
advance and because they only advance
it takes linear total time so we're

3446
01:10:54,790 --> 01:10:54,800
it takes linear total time so we're
 

3447
01:10:54,800 --> 01:10:56,229
it takes linear total time so we're
going to do this kind of folded and

3448
01:10:56,229 --> 01:10:56,239
going to do this kind of folded and
 

3449
01:10:56,239 --> 01:10:58,229
going to do this kind of folded and
backwards here we're going to start here

3450
01:10:58,229 --> 01:10:58,239
backwards here we're going to start here
 

3451
01:10:58,239 --> 01:10:59,669
backwards here we're going to start here
this seems like a good candidate to

3452
01:10:59,669 --> 01:10:59,679
this seems like a good candidate to
 

3453
01:10:59,679 --> 01:11:02,630
this seems like a good candidate to
start with now what else could this add

3454
01:11:02,630 --> 01:11:02,640
start with now what else could this add
 

3455
01:11:02,640 --> 01:11:05,910
start with now what else could this add
with well maybe smaller items and

3456
01:11:05,910 --> 01:11:05,920
with well maybe smaller items and
 

3457
01:11:05,920 --> 01:11:07,270
with well maybe smaller items and
maybe i have to go all the way through

3458
01:11:07,270 --> 01:11:07,280
maybe i have to go all the way through
 

3459
01:11:07,280 --> 01:11:09,110
maybe i have to go all the way through
here and then i've got to advance my

3460
01:11:09,110 --> 01:11:09,120
here and then i've got to advance my
 

3461
01:11:09,120 --> 01:11:10,310
here and then i've got to advance my
left finger

3462
01:11:10,310 --> 01:11:10,320
left finger
 

3463
01:11:10,320 --> 01:11:14,870
left finger
yeah okay so uh here's the idea

3464
01:11:14,870 --> 01:11:14,880
yeah okay so uh here's the idea
 

3465
01:11:14,880 --> 01:11:19,030
yeah okay so uh here's the idea
so um let's look at

3466
01:11:19,030 --> 01:11:19,040
so um let's look at
 

3467
01:11:19,040 --> 01:11:21,430
so um let's look at
so i'm going to call this finger i this

3468
01:11:21,430 --> 01:11:21,440
so i'm going to call this finger i this
 

3469
01:11:21,440 --> 01:11:22,709
so i'm going to call this finger i this
finger j

3470
01:11:22,709 --> 01:11:22,719
finger j
 

3471
01:11:22,719 --> 01:11:25,590
finger j
so we want to sum two things so i guess

3472
01:11:25,590 --> 01:11:25,600
so we want to sum two things so i guess
 

3473
01:11:25,600 --> 01:11:26,870
so we want to sum two things so i guess
another inspiration here is

3474
01:11:26,870 --> 01:11:26,880
another inspiration here is
 

3475
01:11:26,880 --> 01:11:29,189
another inspiration here is
we want to add two things up and we have

3476
01:11:29,189 --> 01:11:29,199
we want to add two things up and we have
 

3477
01:11:29,199 --> 01:11:30,790
we want to add two things up and we have
one algorithm that has the word two in

3478
01:11:30,790 --> 01:11:30,800
one algorithm that has the word two in
 

3479
01:11:30,800 --> 01:11:32,870
one algorithm that has the word two in
it and it's the two finger algorithm

3480
01:11:32,870 --> 01:11:32,880
it and it's the two finger algorithm
 

3481
01:11:32,880 --> 01:11:35,189
it and it's the two finger algorithm
so let's try that um so we're gonna

3482
01:11:35,189 --> 01:11:35,199
so let's try that um so we're gonna
 

3483
01:11:35,199 --> 01:11:36,950
so let's try that um so we're gonna
start with i equals zero and j equals n

3484
01:11:36,950 --> 01:11:36,960
start with i equals zero and j equals n
 

3485
01:11:36,960 --> 01:11:37,830
start with i equals zero and j equals n
minus one

3486
01:11:37,830 --> 01:11:37,840
minus one
 

3487
01:11:37,840 --> 01:11:42,229
minus one
we're gonna look at s i plus s j

3488
01:11:42,229 --> 01:11:42,239
we're gonna look at s i plus s j
 

3489
01:11:42,239 --> 01:11:45,510
we're gonna look at s i plus s j
and see how good it is it how close to

3490
01:11:45,510 --> 01:11:45,520
and see how good it is it how close to
 

3491
01:11:45,520 --> 01:11:46,950
and see how good it is it how close to
summing to h is it

3492
01:11:46,950 --> 01:11:46,960
summing to h is it
 

3493
01:11:46,960 --> 01:11:49,990
summing to h is it
well in particular it's either less than

3494
01:11:49,990 --> 01:11:50,000
well in particular it's either less than
 

3495
01:11:50,000 --> 01:11:51,270
well in particular it's either less than
or equal to h

3496
01:11:51,270 --> 01:11:51,280
or equal to h
 

3497
01:11:51,280 --> 01:11:57,910
or equal to h
or bigger than h

3498
01:11:57,910 --> 01:11:57,920

 

3499
01:11:57,920 --> 01:12:00,870

if it's bigger than h so this sum is too

3500
01:12:00,870 --> 01:12:00,880
if it's bigger than h so this sum is too
 

3501
01:12:00,880 --> 01:12:01,189
if it's bigger than h so this sum is too
big

3502
01:12:01,189 --> 01:12:01,199
big
 

3503
01:12:01,199 --> 01:12:03,510
big
i can't even use it as a candidate well

3504
01:12:03,510 --> 01:12:03,520
i can't even use it as a candidate well
 

3505
01:12:03,520 --> 01:12:04,310
i can't even use it as a candidate well
that means

3506
01:12:04,310 --> 01:12:04,320
that means
 

3507
01:12:04,320 --> 01:12:06,630
that means
i really don't need this guy right it's

3508
01:12:06,630 --> 01:12:06,640
i really don't need this guy right it's
 

3509
01:12:06,640 --> 01:12:08,390
i really don't need this guy right it's
too big overall this is i'm adding the

3510
01:12:08,390 --> 01:12:08,400
too big overall this is i'm adding the
 

3511
01:12:08,400 --> 01:12:09,590
too big overall this is i'm adding the
smallest item

3512
01:12:09,590 --> 01:12:09,600
smallest item
 

3513
01:12:09,600 --> 01:12:11,750
smallest item
to this item and it's too big well then

3514
01:12:11,750 --> 01:12:11,760
to this item and it's too big well then
 

3515
01:12:11,760 --> 01:12:13,270
to this item and it's too big well then
i should go to the left i should move my

3516
01:12:13,270 --> 01:12:13,280
i should go to the left i should move my
 

3517
01:12:13,280 --> 01:12:14,709
i should go to the left i should move my
right finger to the left

3518
01:12:14,709 --> 01:12:14,719
right finger to the left
 

3519
01:12:14,719 --> 01:12:19,750
right finger to the left
so in this case uh we decrement j

3520
01:12:19,750 --> 01:12:19,760
so in this case uh we decrement j
 

3521
01:12:19,760 --> 01:12:22,550
so in this case uh we decrement j
move the right finger to the left so i'm

3522
01:12:22,550 --> 01:12:22,560
move the right finger to the left so i'm
 

3523
01:12:22,560 --> 01:12:23,830
move the right finger to the left so i'm
guessing in this case i'm going to

3524
01:12:23,830 --> 01:12:23,840
guessing in this case i'm going to
 

3525
01:12:23,840 --> 01:12:26,709
guessing in this case i'm going to
increment i

3526
01:12:26,709 --> 01:12:26,719

 

3527
01:12:26,719 --> 01:12:31,270

why if i add these two items up

3528
01:12:31,270 --> 01:12:31,280
why if i add these two items up
 

3529
01:12:31,280 --> 01:12:33,830
why if i add these two items up
and this is too small smaller than h

3530
01:12:33,830 --> 01:12:33,840
and this is too small smaller than h
 

3531
01:12:33,840 --> 01:12:35,189
and this is too small smaller than h
then this item was

3532
01:12:35,189 --> 01:12:35,199
then this item was
 

3533
01:12:35,199 --> 01:12:37,189
then this item was
probably too small it might actually

3534
01:12:37,189 --> 01:12:37,199
probably too small it might actually
 

3535
01:12:37,199 --> 01:12:38,709
probably too small it might actually
it's an okay solution it's less or equal

3536
01:12:38,709 --> 01:12:38,719
it's an okay solution it's less or equal
 

3537
01:12:38,719 --> 01:12:41,189
it's an okay solution it's less or equal
to h so i should keep it as a candidate

3538
01:12:41,189 --> 01:12:41,199
to h so i should keep it as a candidate
 

3539
01:12:41,199 --> 01:12:45,430
to h so i should keep it as a candidate
um let's say add

3540
01:12:45,430 --> 01:12:45,440
um let's say add
 

3541
01:12:45,440 --> 01:12:48,630
um let's say add
candidate so i'm just going to keep a

3542
01:12:48,630 --> 01:12:48,640
candidate so i'm just going to keep a
 

3543
01:12:48,640 --> 01:12:50,149
candidate so i'm just going to keep a
list of candidates

3544
01:12:50,149 --> 01:12:50,159
list of candidates
 

3545
01:12:50,159 --> 01:12:52,229
list of candidates
that i see so this is a possible

3546
01:12:52,229 --> 01:12:52,239
that i see so this is a possible
 

3547
01:12:52,239 --> 01:12:54,229
that i see so this is a possible
solution it might not be the best one

3548
01:12:54,229 --> 01:12:54,239
solution it might not be the best one
 

3549
01:12:54,239 --> 01:12:55,669
solution it might not be the best one
but it's one to add to my list

3550
01:12:55,669 --> 01:12:55,679
but it's one to add to my list
 

3551
01:12:55,679 --> 01:12:57,990
but it's one to add to my list
and then i'm going to increase i and now

3552
01:12:57,990 --> 01:12:58,000
and then i'm going to increase i and now
 

3553
01:12:58,000 --> 01:13:00,229
and then i'm going to increase i and now
work with on this sub array

3554
01:13:00,229 --> 01:13:00,239
work with on this sub array
 

3555
01:13:00,239 --> 01:13:02,390
work with on this sub array
because that will be a little bit bigger

3556
01:13:02,390 --> 01:13:02,400
because that will be a little bit bigger
 

3557
01:13:02,400 --> 01:13:03,910
because that will be a little bit bigger
i can't go this way to make it bigger

3558
01:13:03,910 --> 01:13:03,920
i can't go this way to make it bigger
 

3559
01:13:03,920 --> 01:13:05,750
i can't go this way to make it bigger
because i'm at the last item

3560
01:13:05,750 --> 01:13:05,760
because i'm at the last item
 

3561
01:13:05,760 --> 01:13:07,669
because i'm at the last item
and it's not obvious that this works i

3562
01:13:07,669 --> 01:13:07,679
and it's not obvious that this works i
 

3563
01:13:07,679 --> 01:13:09,590
and it's not obvious that this works i
think there's a nice invariant

3564
01:13:09,590 --> 01:13:09,600
think there's a nice invariant
 

3565
01:13:09,600 --> 01:13:14,550
think there's a nice invariant
that will help

3566
01:13:14,550 --> 01:13:14,560

 

3567
01:13:14,560 --> 01:13:16,830

somewhere wherever i put my piece of

3568
01:13:16,830 --> 01:13:16,840
somewhere wherever i put my piece of
 

3569
01:13:16,840 --> 01:13:26,870
somewhere wherever i put my piece of
paper

3570
01:13:26,870 --> 01:13:26,880

 

3571
01:13:26,880 --> 01:13:37,030

here's an invariant

3572
01:13:37,030 --> 01:13:37,040

 

3573
01:13:37,040 --> 01:14:00,870

oh yes

3574
01:14:00,870 --> 01:14:00,880

 

3575
01:14:00,880 --> 01:14:02,070

it's really clear this is the right

3576
01:14:02,070 --> 01:14:02,080
it's really clear this is the right
 

3577
01:14:02,080 --> 01:14:03,510
it's really clear this is the right
thing to do in the first step and the

3578
01:14:03,510 --> 01:14:03,520
thing to do in the first step and the
 

3579
01:14:03,520 --> 01:14:05,189
thing to do in the first step and the
tricky part is to argue that it works in

3580
01:14:05,189 --> 01:14:05,199
tricky part is to argue that it works in
 

3581
01:14:05,199 --> 01:14:06,149
tricky part is to argue that it works in
all steps

3582
01:14:06,149 --> 01:14:06,159
all steps
 

3583
01:14:06,159 --> 01:14:07,669
all steps
because when i really have the smallest

3584
01:14:07,669 --> 01:14:07,679
because when i really have the smallest
 

3585
01:14:07,679 --> 01:14:09,189
because when i really have the smallest
item and the smaller and the largest

3586
01:14:09,189 --> 01:14:09,199
item and the smaller and the largest
 

3587
01:14:09,199 --> 01:14:10,470
item and the smaller and the largest
item it's clear that i should advance

3588
01:14:10,470 --> 01:14:10,480
item it's clear that i should advance
 

3589
01:14:10,480 --> 01:14:11,510
item it's clear that i should advance
one or the other

3590
01:14:11,510 --> 01:14:11,520
one or the other
 

3591
01:14:11,520 --> 01:14:13,750
one or the other
i'm too small or too big but the way to

3592
01:14:13,750 --> 01:14:13,760
i'm too small or too big but the way to
 

3593
01:14:13,760 --> 01:14:15,590
i'm too small or too big but the way to
prove it in general by induction

3594
01:14:15,590 --> 01:14:15,600
prove it in general by induction
 

3595
01:14:15,600 --> 01:14:18,070
prove it in general by induction
is to show this invariant that so it in

3596
01:14:18,070 --> 01:14:18,080
is to show this invariant that so it in
 

3597
01:14:18,080 --> 01:14:19,830
is to show this invariant that so it in
at some point through this execution i

3598
01:14:19,830 --> 01:14:19,840
at some point through this execution i
 

3599
01:14:19,840 --> 01:14:20,149
at some point through this execution i
and j

3600
01:14:20,149 --> 01:14:20,159
and j
 

3601
01:14:20,159 --> 01:14:21,750
and j
are somewhere and i want to say that if

3602
01:14:21,750 --> 01:14:21,760
are somewhere and i want to say that if
 

3603
01:14:21,760 --> 01:14:23,750
are somewhere and i want to say that if
i take any j from the right

3604
01:14:23,750 --> 01:14:23,760
i take any j from the right
 

3605
01:14:23,760 --> 01:14:25,990
i take any j from the right
any j prime to the right of j and any i

3606
01:14:25,990 --> 01:14:26,000
any j prime to the right of j and any i
 

3607
01:14:26,000 --> 01:14:27,189
any j prime to the right of j and any i
prime to the left of i

3608
01:14:27,189 --> 01:14:27,199
prime to the left of i
 

3609
01:14:27,199 --> 01:14:30,310
prime to the left of i
unstrictly then all of those pairs all

3610
01:14:30,310 --> 01:14:30,320
unstrictly then all of those pairs all
 

3611
01:14:30,320 --> 01:14:31,510
unstrictly then all of those pairs all
those pairwise sums

3612
01:14:31,510 --> 01:14:31,520
those pairwise sums
 

3613
01:14:31,520 --> 01:14:33,510
those pairwise sums
are either too big and that's when we

3614
01:14:33,510 --> 01:14:33,520
are either too big and that's when we
 

3615
01:14:33,520 --> 01:14:34,630
are either too big and that's when we
decrease j

3616
01:14:34,630 --> 01:14:34,640
decrease j
 

3617
01:14:34,640 --> 01:14:36,470
decrease j
or they're less than or equal to the

3618
01:14:36,470 --> 01:14:36,480
or they're less than or equal to the
 

3619
01:14:36,480 --> 01:14:39,350
or they're less than or equal to the
largest candidate that we've seen so far

3620
01:14:39,350 --> 01:14:39,360
largest candidate that we've seen so far
 

3621
01:14:39,360 --> 01:14:41,430
largest candidate that we've seen so far
that's because we add these candidates

3622
01:14:41,430 --> 01:14:41,440
that's because we add these candidates
 

3623
01:14:41,440 --> 01:14:42,709
that's because we add these candidates
in there so

3624
01:14:42,709 --> 01:14:42,719
in there so
 

3625
01:14:42,719 --> 01:14:44,630
in there so
this that invariant will hold by

3626
01:14:44,630 --> 01:14:44,640
this that invariant will hold by
 

3627
01:14:44,640 --> 01:14:45,990
this that invariant will hold by
induction because whenever there's a

3628
01:14:45,990 --> 01:14:46,000
induction because whenever there's a
 

3629
01:14:46,000 --> 01:14:47,270
induction because whenever there's a
possible thing that's

3630
01:14:47,270 --> 01:14:47,280
possible thing that's
 

3631
01:14:47,280 --> 01:14:49,830
possible thing that's
good i add it to my candidate list and

3632
01:14:49,830 --> 01:14:49,840
good i add it to my candidate list and
 

3633
01:14:49,840 --> 01:14:51,750
good i add it to my candidate list and
then at the end of the algorithm i just

3634
01:14:51,750 --> 01:14:51,760
then at the end of the algorithm i just
 

3635
01:14:51,760 --> 01:14:53,189
then at the end of the algorithm i just
loop through my candidate list compute

3636
01:14:53,189 --> 01:14:53,199
loop through my candidate list compute
 

3637
01:14:53,199 --> 01:14:58,229
loop through my candidate list compute
the max return that pair

3638
01:14:58,229 --> 01:14:58,239

 

3639
01:14:58,239 --> 01:15:01,430

okay so that is two-finger algorithm

3640
01:15:01,430 --> 01:15:01,440
okay so that is two-finger algorithm
 

3641
01:15:01,440 --> 01:15:03,350
okay so that is two-finger algorithm
which solves the non-exact

3642
01:15:03,350 --> 01:15:03,360
which solves the non-exact
 

3643
01:15:03,360 --> 01:15:08,070
which solves the non-exact
problem in linear worst case time yeah

3644
01:15:08,070 --> 01:15:08,080
problem in linear worst case time yeah
 

3645
01:15:08,080 --> 01:15:09,350
problem in linear worst case time yeah
oh i cannot right so what are the

3646
01:15:09,350 --> 01:15:09,360
oh i cannot right so what are the
 

3647
01:15:09,360 --> 01:15:11,669
oh i cannot right so what are the
termination conditions when i

3648
01:15:11,669 --> 01:15:11,679
termination conditions when i
 

3649
01:15:11,679 --> 01:15:14,229
termination conditions when i
equals j that's probably when you want

3650
01:15:14,229 --> 01:15:14,239
equals j that's probably when you want
 

3651
01:15:14,239 --> 01:15:15,990
equals j that's probably when you want
to stop it depends you could say

3652
01:15:15,990 --> 01:15:16,000
to stop it depends you could say
 

3653
01:15:16,000 --> 01:15:19,110
to stop it depends you could say
if i is greater than j stop

3654
01:15:19,110 --> 01:15:19,120
if i is greater than j stop
 

3655
01:15:19,120 --> 01:15:23,990
if i is greater than j stop
uh return max candidate uh it's

3656
01:15:23,990 --> 01:15:24,000
uh return max candidate uh it's
 

3657
01:15:24,000 --> 01:15:25,270
uh return max candidate uh it's
there are two ways to interpret this

3658
01:15:25,270 --> 01:15:25,280
there are two ways to interpret this
 

3659
01:15:25,280 --> 01:15:28,229
there are two ways to interpret this
problem one is that the two values you

3660
01:15:28,229 --> 01:15:28,239
problem one is that the two values you
 

3661
01:15:28,239 --> 01:15:28,870
problem one is that the two values you
choose in

3662
01:15:28,870 --> 01:15:28,880
choose in
 

3663
01:15:28,880 --> 01:15:31,669
choose in
s need to be different values or you

3664
01:15:31,669 --> 01:15:31,679
s need to be different values or you
 

3665
01:15:31,679 --> 01:15:33,110
s need to be different values or you
allow them to be the same value like

3666
01:15:33,110 --> 01:15:33,120
allow them to be the same value like
 

3667
01:15:33,120 --> 01:15:35,030
allow them to be the same value like
they can both be h over two

3668
01:15:35,030 --> 01:15:35,040
they can both be h over two
 

3669
01:15:35,040 --> 01:15:37,030
they can both be h over two
and either way is easy to solve if you

3670
01:15:37,030 --> 01:15:37,040
and either way is easy to solve if you
 

3671
01:15:37,040 --> 01:15:38,470
and either way is easy to solve if you
if you want to allow

3672
01:15:38,470 --> 01:15:38,480
if you want to allow
 

3673
01:15:38,480 --> 01:15:39,990
if you want to allow
s over 2 then i would put greater than

3674
01:15:39,990 --> 01:15:40,000
s over 2 then i would put greater than
 

3675
01:15:40,000 --> 01:15:43,669
s over 2 then i would put greater than
here if you don't want to allow

3676
01:15:43,669 --> 01:15:43,679
here if you don't want to allow
 

3677
01:15:43,679 --> 01:15:45,110
here if you don't want to allow
h over 2 then i have a greater than or

3678
01:15:45,110 --> 01:15:45,120
h over 2 then i have a greater than or
 

3679
01:15:45,120 --> 01:15:46,870
h over 2 then i have a greater than or
equal to

3680
01:15:46,870 --> 01:15:46,880
equal to
 

3681
01:15:46,880 --> 01:15:48,550
equal to
either way both both of these problems

3682
01:15:48,550 --> 01:15:48,560
either way both both of these problems
 

3683
01:15:48,560 --> 01:15:50,950
either way both both of these problems
you can solve both ways or both

3684
01:15:50,950 --> 01:15:50,960
you can solve both ways or both
 

3685
01:15:50,960 --> 01:15:54,709
you can solve both ways or both
algorithms can handle both situations

3686
01:15:54,709 --> 01:15:54,719
algorithms can handle both situations
 

3687
01:15:54,719 --> 01:16:00,870
algorithms can handle both situations
okay one more problem

3688
01:16:00,870 --> 01:16:00,880

 

3689
01:16:00,880 --> 01:16:03,910

all right yeah a lot of time

3690
01:16:03,910 --> 01:16:03,920
all right yeah a lot of time
 

3691
01:16:03,920 --> 01:16:06,630
all right yeah a lot of time
but i'm getting faster and faster so of

3692
01:16:06,630 --> 01:16:06,640
but i'm getting faster and faster so of
 

3693
01:16:06,640 --> 01:16:08,310
but i'm getting faster and faster so of
course on the hardest problem i can do

3694
01:16:08,310 --> 01:16:08,320
course on the hardest problem i can do
 

3695
01:16:08,320 --> 01:16:09,510
course on the hardest problem i can do
it the fastest

3696
01:16:09,510 --> 01:16:09,520
it the fastest
 

3697
01:16:09,520 --> 01:16:12,550
it the fastest
all right so jet so meh

3698
01:16:12,550 --> 01:16:12,560
all right so jet so meh
 

3699
01:16:12,560 --> 01:16:15,669
all right so jet so meh
jah this is a reference to jeff ma

3700
01:16:15,669 --> 01:16:15,679
jah this is a reference to jeff ma
 

3701
01:16:15,679 --> 01:16:17,430
jah this is a reference to jeff ma
of the mit blackjack team who i got to

3702
01:16:17,430 --> 01:16:17,440
of the mit blackjack team who i got to
 

3703
01:16:17,440 --> 01:16:18,950
of the mit blackjack team who i got to
see speak here at lsc

3704
01:16:18,950 --> 01:16:18,960
see speak here at lsc
 

3705
01:16:18,960 --> 01:16:20,630
see speak here at lsc
a bunch of years ago but he's featured

3706
01:16:20,630 --> 01:16:20,640
a bunch of years ago but he's featured
 

3707
01:16:20,640 --> 01:16:22,790
a bunch of years ago but he's featured
in the movie 21 and so on

3708
01:16:22,790 --> 01:16:22,800
in the movie 21 and so on
 

3709
01:16:22,800 --> 01:16:25,830
in the movie 21 and so on
fictionalized um

3710
01:16:25,830 --> 01:16:25,840
fictionalized um
 

3711
01:16:25,840 --> 01:16:28,630
fictionalized um
so as playing this game it's great great

3712
01:16:28,630 --> 01:16:28,640
so as playing this game it's great great
 

3713
01:16:28,640 --> 01:16:29,750
so as playing this game it's great great
great setup you should definitely read

3714
01:16:29,750 --> 01:16:29,760
great setup you should definitely read
 

3715
01:16:29,760 --> 01:16:30,550
great setup you should definitely read
this problem

3716
01:16:30,550 --> 01:16:30,560
this problem
 

3717
01:16:30,560 --> 01:16:35,030
this problem
uh po k er

3718
01:16:35,030 --> 01:16:35,040
uh po k er
 

3719
01:16:35,040 --> 01:16:38,149
uh po k er
and he has a deck of cards where each

3720
01:16:38,149 --> 01:16:38,159
and he has a deck of cards where each
 

3721
01:16:38,159 --> 01:16:40,310
and he has a deck of cards where each
card has a letter of the alphabet on i

3722
01:16:40,310 --> 01:16:40,320
card has a letter of the alphabet on i
 

3723
01:16:40,320 --> 01:16:40,870
card has a letter of the alphabet on i
get this

3724
01:16:40,870 --> 01:16:40,880
get this
 

3725
01:16:40,880 --> 01:16:43,510
get this
the right way up so i of course have

3726
01:16:43,510 --> 01:16:43,520
the right way up so i of course have
 

3727
01:16:43,520 --> 01:16:44,709
the right way up so i of course have
such a deck

3728
01:16:44,709 --> 01:16:44,719
such a deck
 

3729
01:16:44,719 --> 01:16:46,950
such a deck
doesn't everyone you can buy these i

3730
01:16:46,950 --> 01:16:46,960
doesn't everyone you can buy these i
 

3731
01:16:46,960 --> 01:16:48,790
doesn't everyone you can buy these i
have several actually

3732
01:16:48,790 --> 01:16:48,800
have several actually
 

3733
01:16:48,800 --> 01:16:50,870
have several actually
um and so we can do a quick magic trick

3734
01:16:50,870 --> 01:16:50,880
um and so we can do a quick magic trick
 

3735
01:16:50,880 --> 01:16:52,870
um and so we can do a quick magic trick
like uh pick a card any card here pick a

3736
01:16:52,870 --> 01:16:52,880
like uh pick a card any card here pick a
 

3737
01:16:52,880 --> 01:16:55,990
like uh pick a card any card here pick a
card

3738
01:16:55,990 --> 01:16:56,000

 

3739
01:16:56,000 --> 01:16:58,790

okay oh good choice i can't force so it

3740
01:16:58,790 --> 01:16:58,800
okay oh good choice i can't force so it
 

3741
01:16:58,800 --> 01:16:59,910
okay oh good choice i can't force so it
doesn't really matter

3742
01:16:59,910 --> 01:16:59,920
doesn't really matter
 

3743
01:16:59,920 --> 01:17:03,189
doesn't really matter
okay and uh so this is your card

3744
01:17:03,189 --> 01:17:03,199
okay and uh so this is your card
 

3745
01:17:03,199 --> 01:17:07,750
okay and uh so this is your card
right and your card is an s right

3746
01:17:07,750 --> 01:17:07,760
right and your card is an s right
 

3747
01:17:07,760 --> 01:17:10,630
right and your card is an s right
okay good okay no not all the cards are

3748
01:17:10,630 --> 01:17:10,640
okay good okay no not all the cards are
 

3749
01:17:10,640 --> 01:17:14,790
okay good okay no not all the cards are
s's

3750
01:17:14,790 --> 01:17:14,800

 

3751
01:17:14,800 --> 01:17:17,990

but he has mirrors in his glasses no i

3752
01:17:17,990 --> 01:17:18,000
but he has mirrors in his glasses no i
 

3753
01:17:18,000 --> 01:17:19,669
but he has mirrors in his glasses no i
can reveal later how that's done

3754
01:17:19,669 --> 01:17:19,679
can reveal later how that's done
 

3755
01:17:19,679 --> 01:17:23,270
can reveal later how that's done
um okay so a deck of cards each card has

3756
01:17:23,270 --> 01:17:23,280
um okay so a deck of cards each card has
 

3757
01:17:23,280 --> 01:17:26,790
um okay so a deck of cards each card has
26 possible letters on it and

3758
01:17:26,790 --> 01:17:26,800
26 possible letters on it and
 

3759
01:17:26,800 --> 01:17:28,950
26 possible letters on it and
uh there's this weird dealing process

3760
01:17:28,950 --> 01:17:28,960
uh there's this weird dealing process
 

3761
01:17:28,960 --> 01:17:30,470
uh there's this weird dealing process
even just defining this problem it's

3762
01:17:30,470 --> 01:17:30,480
even just defining this problem it's
 

3763
01:17:30,480 --> 01:17:31,510
even just defining this problem it's
going to take a little while oh here's

3764
01:17:31,510 --> 01:17:31,520
going to take a little while oh here's
 

3765
01:17:31,520 --> 01:17:35,830
going to take a little while oh here's
my piece of paper

3766
01:17:35,830 --> 01:17:35,840

 

3767
01:17:35,840 --> 01:17:38,070

so we have this dealing process here's

3768
01:17:38,070 --> 01:17:38,080
so we have this dealing process here's
 

3769
01:17:38,080 --> 01:17:38,950
so we have this dealing process here's
an example

3770
01:17:38,950 --> 01:17:38,960
an example
 

3771
01:17:38,960 --> 01:17:42,229
an example
it's in the problem a b c sorry

3772
01:17:42,229 --> 01:17:42,239
it's in the problem a b c sorry
 

3773
01:17:42,239 --> 01:17:46,870
it's in the problem a b c sorry
d b c so that you know the order of the

3774
01:17:46,870 --> 01:17:46,880
d b c so that you know the order of the
 

3775
01:17:46,880 --> 01:17:48,550
d b c so that you know the order of the
cards this is the top card this is the

3776
01:17:48,550 --> 01:17:48,560
cards this is the top card this is the
 

3777
01:17:48,560 --> 01:17:49,910
cards this is the top card this is the
bottom card

3778
01:17:49,910 --> 01:17:49,920
bottom card
 

3779
01:17:49,920 --> 01:17:53,430
bottom card
and now randomly you do a cut

3780
01:17:53,430 --> 01:17:53,440
and now randomly you do a cut
 

3781
01:17:53,440 --> 01:17:57,669
and now randomly you do a cut
cut is this right so i take some chunk

3782
01:17:57,669 --> 01:17:57,679
cut is this right so i take some chunk
 

3783
01:17:57,679 --> 01:17:58,550
cut is this right so i take some chunk
off the top

3784
01:17:58,550 --> 01:17:58,560
off the top
 

3785
01:17:58,560 --> 01:18:01,910
off the top
move it to the bottom once randomly

3786
01:18:01,910 --> 01:18:01,920
move it to the bottom once randomly
 

3787
01:18:01,920 --> 01:18:05,990
move it to the bottom once randomly
so for example i could take this cut

3788
01:18:05,990 --> 01:18:06,000
so for example i could take this cut
 

3789
01:18:06,000 --> 01:18:09,510
so for example i could take this cut
and then what i would get is cdbc

3790
01:18:09,510 --> 01:18:09,520
and then what i would get is cdbc
 

3791
01:18:09,520 --> 01:18:12,709
and then what i would get is cdbc
for for this part

3792
01:18:12,709 --> 01:18:12,719
for for this part
 

3793
01:18:12,719 --> 01:18:16,070
for for this part
that's copied here and a b

3794
01:18:16,070 --> 01:18:16,080
that's copied here and a b
 

3795
01:18:16,080 --> 01:18:19,990
that's copied here and a b
that's the so this is so the first thing

3796
01:18:19,990 --> 01:18:20,000
that's the so this is so the first thing
 

3797
01:18:20,000 --> 01:18:21,830
that's the so this is so the first thing
we do is cut

3798
01:18:21,830 --> 01:18:21,840
we do is cut
 

3799
01:18:21,840 --> 01:18:25,030
we do is cut
at i this is position i

3800
01:18:25,030 --> 01:18:25,040
at i this is position i
 

3801
01:18:25,040 --> 01:18:28,709
at i this is position i
this example i equals two

3802
01:18:28,709 --> 01:18:28,719
this example i equals two
 

3803
01:18:28,719 --> 01:18:31,910
this example i equals two
okay then we deal the top

3804
01:18:31,910 --> 01:18:31,920
okay then we deal the top
 

3805
01:18:31,920 --> 01:18:35,830
okay then we deal the top
k cards so uh let's say we deal

3806
01:18:35,830 --> 01:18:35,840
k cards so uh let's say we deal
 

3807
01:18:35,840 --> 01:18:38,950
k cards so uh let's say we deal
the top four cards k equals four so this

3808
01:18:38,950 --> 01:18:38,960
the top four cards k equals four so this
 

3809
01:18:38,960 --> 01:18:39,990
the top four cards k equals four so this
is uh

3810
01:18:39,990 --> 01:18:40,000
is uh
 

3811
01:18:40,000 --> 01:18:44,790
is uh
dl k so we get cdbc

3812
01:18:44,790 --> 01:18:44,800
dl k so we get cdbc
 

3813
01:18:44,800 --> 01:18:46,470
dl k so we get cdbc
in that order but the order doesn't

3814
01:18:46,470 --> 01:18:46,480
in that order but the order doesn't
 

3815
01:18:46,480 --> 01:18:48,390
in that order but the order doesn't
matter because the last operation we do

3816
01:18:48,390 --> 01:18:48,400
matter because the last operation we do
 

3817
01:18:48,400 --> 01:18:50,229
matter because the last operation we do
in the problem is sort them

3818
01:18:50,229 --> 01:18:50,239
in the problem is sort them
 

3819
01:18:50,239 --> 01:18:53,510
in the problem is sort them
which is b c c d

3820
01:18:53,510 --> 01:18:53,520
which is b c c d
 

3821
01:18:53,520 --> 01:18:55,110
which is b c c d
okay like you do when you get a hand of

3822
01:18:55,110 --> 01:18:55,120
okay like you do when you get a hand of
 

3823
01:18:55,120 --> 01:18:57,270
okay like you do when you get a hand of
cards you tend to sort them

3824
01:18:57,270 --> 01:18:57,280
cards you tend to sort them
 

3825
01:18:57,280 --> 01:18:59,590
cards you tend to sort them
okay so this is a process given a deck

3826
01:18:59,590 --> 01:18:59,600
okay so this is a process given a deck
 

3827
01:18:59,600 --> 01:19:00,950
okay so this is a process given a deck
so the deck here is

3828
01:19:00,950 --> 01:19:00,960
so the deck here is
 

3829
01:19:00,960 --> 01:19:04,229
so the deck here is
fixed uh we call this

3830
01:19:04,229 --> 01:19:04,239
fixed uh we call this
 

3831
01:19:04,239 --> 01:19:08,550
fixed uh we call this
process i think p of d comma i

3832
01:19:08,550 --> 01:19:08,560
process i think p of d comma i
 

3833
01:19:08,560 --> 01:19:11,510
process i think p of d comma i
comma k we're told what d is we're told

3834
01:19:11,510 --> 01:19:11,520
comma k we're told what d is we're told
 

3835
01:19:11,520 --> 01:19:11,990
comma k we're told what d is we're told
what k

3836
01:19:11,990 --> 01:19:12,000
what k
 

3837
01:19:12,000 --> 01:19:15,110
what k
is i is chosen randomly

3838
01:19:15,110 --> 01:19:15,120
is i is chosen randomly
 

3839
01:19:15,120 --> 01:19:17,270
is i is chosen randomly
and we'd like to know what happens with

3840
01:19:17,270 --> 01:19:17,280
and we'd like to know what happens with
 

3841
01:19:17,280 --> 01:19:20,470
and we'd like to know what happens with
different eyes

3842
01:19:20,470 --> 01:19:20,480

 

3843
01:19:20,480 --> 01:19:23,189

so so if you start this problem enough

3844
01:19:23,189 --> 01:19:23,199
so so if you start this problem enough
 

3845
01:19:23,199 --> 01:19:24,709
so so if you start this problem enough
it begins to simplify this is a

3846
01:19:24,709 --> 01:19:24,719
it begins to simplify this is a
 

3847
01:19:24,719 --> 01:19:26,229
it begins to simplify this is a
complicated setup

3848
01:19:26,229 --> 01:19:26,239
complicated setup
 

3849
01:19:26,239 --> 01:19:27,430
complicated setup
but what's really going on is we're

3850
01:19:27,430 --> 01:19:27,440
but what's really going on is we're
 

3851
01:19:27,440 --> 01:19:29,669
but what's really going on is we're
starting at position i and we're taking

3852
01:19:29,669 --> 01:19:29,679
starting at position i and we're taking
 

3853
01:19:29,679 --> 01:19:31,910
starting at position i and we're taking
the next k cards from there

3854
01:19:31,910 --> 01:19:31,920
the next k cards from there
 

3855
01:19:31,920 --> 01:19:33,669
the next k cards from there
cyclically so here we just took those

3856
01:19:33,669 --> 01:19:33,679
cyclically so here we just took those
 

3857
01:19:33,679 --> 01:19:36,310
cyclically so here we just took those
four if i equaled three would deal d

3858
01:19:36,310 --> 01:19:36,320
four if i equaled three would deal d
 

3859
01:19:36,320 --> 01:19:36,790
four if i equaled three would deal d
then b

3860
01:19:36,790 --> 01:19:36,800
then b
 

3861
01:19:36,800 --> 01:19:40,229
then b
then c then a but then we sort them

3862
01:19:40,229 --> 01:19:40,239
then c then a but then we sort them
 

3863
01:19:40,239 --> 01:19:41,350
then c then a but then we sort them
okay so we're getting different

3864
01:19:41,350 --> 01:19:41,360
okay so we're getting different
 

3865
01:19:41,360 --> 01:19:44,229
okay so we're getting different
substrings of length k cyclically

3866
01:19:44,229 --> 01:19:44,239
substrings of length k cyclically
 

3867
01:19:44,239 --> 01:19:46,630
substrings of length k cyclically
but uh then we're sorting those letters

3868
01:19:46,630 --> 01:19:46,640
but uh then we're sorting those letters
 

3869
01:19:46,640 --> 01:19:48,070
but uh then we're sorting those letters
sorting is really crucial for this

3870
01:19:48,070 --> 01:19:48,080
sorting is really crucial for this
 

3871
01:19:48,080 --> 01:19:50,790
sorting is really crucial for this
problem to at all be feasible

3872
01:19:50,790 --> 01:19:50,800
problem to at all be feasible
 

3873
01:19:50,800 --> 01:19:52,950
problem to at all be feasible
it took me a while even to see how to

3874
01:19:52,950 --> 01:19:52,960
it took me a while even to see how to
 

3875
01:19:52,960 --> 01:19:54,149
it took me a while even to see how to
solve this problem but the key is

3876
01:19:54,149 --> 01:19:54,159
solve this problem but the key is
 

3877
01:19:54,159 --> 01:19:55,270
solve this problem but the key is
sorting

3878
01:19:55,270 --> 01:19:55,280
sorting
 

3879
01:19:55,280 --> 01:19:58,310
sorting
that they get sorted because

3880
01:19:58,310 --> 01:19:58,320
that they get sorted because
 

3881
01:19:58,320 --> 01:20:00,709
that they get sorted because
that means because we sort it doesn't

3882
01:20:00,709 --> 01:20:00,719
that means because we sort it doesn't
 

3883
01:20:00,719 --> 01:20:02,149
that means because we sort it doesn't
matter whether you have a

3884
01:20:02,149 --> 01:20:02,159
matter whether you have a
 

3885
01:20:02,159 --> 01:20:07,910
matter whether you have a
a b a

3886
01:20:07,910 --> 01:20:07,920

 

3887
01:20:07,920 --> 01:20:11,270

these are all the same if you take these

3888
01:20:11,270 --> 01:20:11,280
these are all the same if you take these
 

3889
01:20:11,280 --> 01:20:12,229
these are all the same if you take these
cards dealt

3890
01:20:12,229 --> 01:20:12,239
cards dealt
 

3891
01:20:12,239 --> 01:20:14,950
cards dealt
you sort them to the same thing which is

3892
01:20:14,950 --> 01:20:14,960
you sort them to the same thing which is
 

3893
01:20:14,960 --> 01:20:16,229
you sort them to the same thing which is
the one i didn't write

3894
01:20:16,229 --> 01:20:16,239
the one i didn't write
 

3895
01:20:16,239 --> 01:20:19,430
the one i didn't write
a a b all these get sorted to the same

3896
01:20:19,430 --> 01:20:19,440
a a b all these get sorted to the same
 

3897
01:20:19,440 --> 01:20:19,830
a a b all these get sorted to the same
thing

3898
01:20:19,830 --> 01:20:19,840
thing
 

3899
01:20:19,840 --> 01:20:22,709
thing
so we lost some information when we sort

3900
01:20:22,709 --> 01:20:22,719
so we lost some information when we sort
 

3901
01:20:22,719 --> 01:20:23,830
so we lost some information when we sort
lost the order

3902
01:20:23,830 --> 01:20:23,840
lost the order
 

3903
01:20:23,840 --> 01:20:25,510
lost the order
the first question to get you thinking

3904
01:20:25,510 --> 01:20:25,520
the first question to get you thinking
 

3905
01:20:25,520 --> 01:20:26,950
the first question to get you thinking
in this direction

3906
01:20:26,950 --> 01:20:26,960
in this direction
 

3907
01:20:26,960 --> 01:20:30,310
in this direction
part a says build a data structure given

3908
01:20:30,310 --> 01:20:30,320
part a says build a data structure given
 

3909
01:20:30,320 --> 01:20:30,709
part a says build a data structure given
d

3910
01:20:30,709 --> 01:20:30,719
d
 

3911
01:20:30,719 --> 01:20:34,229
d
and k that lets you lets me know

3912
01:20:34,229 --> 01:20:34,239
and k that lets you lets me know
 

3913
01:20:34,239 --> 01:20:37,669
and k that lets you lets me know
given two indices i and j do i

3914
01:20:37,669 --> 01:20:37,679
given two indices i and j do i
 

3915
01:20:37,679 --> 01:20:39,669
given two indices i and j do i
end up with the exact same hand this

3916
01:20:39,669 --> 01:20:39,679
end up with the exact same hand this
 

3917
01:20:39,679 --> 01:20:42,950
end up with the exact same hand this
thing is called a hand

3918
01:20:42,950 --> 01:20:42,960

 

3919
01:20:42,960 --> 01:20:46,629

and it's exactly this pdik

3920
01:20:46,629 --> 01:20:46,639
and it's exactly this pdik
 

3921
01:20:46,639 --> 01:20:49,830
and it's exactly this pdik
so i want to do p d i k and p d j

3922
01:20:49,830 --> 01:20:49,840
so i want to do p d i k and p d j
 

3923
01:20:49,840 --> 01:20:52,870
so i want to do p d i k and p d j
k and i want to know j k and i want to

3924
01:20:52,870 --> 01:20:52,880
k and i want to know j k and i want to
 

3925
01:20:52,880 --> 01:20:53,270
k and i want to know j k and i want to
know

3926
01:20:53,270 --> 01:20:53,280
know
 

3927
01:20:53,280 --> 01:20:56,149
know
whether those two things are equal in

3928
01:20:56,149 --> 01:20:56,159
whether those two things are equal in
 

3929
01:20:56,159 --> 01:20:58,830
whether those two things are equal in
constant time that's what this says

3930
01:20:58,830 --> 01:20:58,840
constant time that's what this says
 

3931
01:20:58,840 --> 01:21:01,669
constant time that's what this says
constant time doesn't say worst case but

3932
01:21:01,669 --> 01:21:01,679
constant time doesn't say worst case but
 

3933
01:21:01,679 --> 01:21:05,510
constant time doesn't say worst case but
worst case is possible

3934
01:21:05,510 --> 01:21:05,520

 

3935
01:21:05,520 --> 01:21:07,990

uh and that sounds hard because i mean

3936
01:21:07,990 --> 01:21:08,000
uh and that sounds hard because i mean
 

3937
01:21:08,000 --> 01:21:09,510
uh and that sounds hard because i mean
there's k symbols for one of them

3938
01:21:09,510 --> 01:21:09,520
there's k symbols for one of them
 

3939
01:21:09,520 --> 01:21:11,350
there's k symbols for one of them
another k symbols for the other guy

3940
01:21:11,350 --> 01:21:11,360
another k symbols for the other guy
 

3941
01:21:11,360 --> 01:21:12,870
another k symbols for the other guy
but we don't have to compare the symbols

3942
01:21:12,870 --> 01:21:12,880
but we don't have to compare the symbols
 

3943
01:21:12,880 --> 01:21:14,629
but we don't have to compare the symbols
we just need to compare

3944
01:21:14,629 --> 01:21:14,639
we just need to compare
 

3945
01:21:14,639 --> 01:21:17,910
we just need to compare
the sorting of those strings and this we

3946
01:21:17,910 --> 01:21:17,920
the sorting of those strings and this we
 

3947
01:21:17,920 --> 01:21:19,510
the sorting of those strings and this we
can compress

3948
01:21:19,510 --> 01:21:19,520
can compress
 

3949
01:21:19,520 --> 01:21:22,390
can compress
so this is a subtlety but what i really

3950
01:21:22,390 --> 01:21:22,400
so this is a subtlety but what i really
 

3951
01:21:22,400 --> 01:21:24,070
so this is a subtlety but what i really
need to know is that there are three a's

3952
01:21:24,070 --> 01:21:24,080
need to know is that there are three a's
 

3953
01:21:24,080 --> 01:21:25,590
need to know is that there are three a's
here

3954
01:21:25,590 --> 01:21:25,600
here
 

3955
01:21:25,600 --> 01:21:28,629
here
and one b and zero c's

3956
01:21:28,629 --> 01:21:28,639
and one b and zero c's
 

3957
01:21:28,639 --> 01:21:31,830
and one b and zero c's
and zero d's and zero e's and so on

3958
01:21:31,830 --> 01:21:31,840
and zero d's and zero e's and so on
 

3959
01:21:31,840 --> 01:21:34,629
and zero d's and zero e's and so on
but uh because there's only 26 letters

3960
01:21:34,629 --> 01:21:34,639
but uh because there's only 26 letters
 

3961
01:21:34,639 --> 01:21:36,310
but uh because there's only 26 letters
in this deck and indeed in this deck

3962
01:21:36,310 --> 01:21:36,320
in this deck and indeed in this deck
 

3963
01:21:36,320 --> 01:21:38,310
in this deck and indeed in this deck
happens to have upper and lower case a

3964
01:21:38,310 --> 01:21:38,320
happens to have upper and lower case a
 

3965
01:21:38,320 --> 01:21:39,669
happens to have upper and lower case a
through z but

3966
01:21:39,669 --> 01:21:39,679
through z but
 

3967
01:21:39,679 --> 01:21:41,590
through z but
we might have n cards but they're only

3968
01:21:41,590 --> 01:21:41,600
we might have n cards but they're only
 

3969
01:21:41,600 --> 01:21:43,590
we might have n cards but they're only
26 possible labels so in fact a lot of

3970
01:21:43,590 --> 01:21:43,600
26 possible labels so in fact a lot of
 

3971
01:21:43,600 --> 01:21:46,149
26 possible labels so in fact a lot of
them are going to be equal if n is large

3972
01:21:46,149 --> 01:21:46,159
them are going to be equal if n is large
 

3973
01:21:46,159 --> 01:21:47,830
them are going to be equal if n is large
so this is a good compression scheme

3974
01:21:47,830 --> 01:21:47,840
so this is a good compression scheme
 

3975
01:21:47,840 --> 01:21:49,750
so this is a good compression scheme
because i to represent

3976
01:21:49,750 --> 01:21:49,760
because i to represent
 

3977
01:21:49,760 --> 01:21:52,390
because i to represent
the things i get after sorting i just

3978
01:21:52,390 --> 01:21:52,400
the things i get after sorting i just
 

3979
01:21:52,400 --> 01:21:54,950
the things i get after sorting i just
need to give you 26 numbers

3980
01:21:54,950 --> 01:21:54,960
need to give you 26 numbers
 

3981
01:21:54,960 --> 01:21:57,110
need to give you 26 numbers
and for us 26 is small because 26 is a

3982
01:21:57,110 --> 01:21:57,120
and for us 26 is small because 26 is a
 

3983
01:21:57,120 --> 01:21:57,990
and for us 26 is small because 26 is a
constant

3984
01:21:57,990 --> 01:21:58,000
constant
 

3985
01:21:58,000 --> 01:21:59,910
constant
independent of the number of cards i

3986
01:21:59,910 --> 01:21:59,920
independent of the number of cards i
 

3987
01:21:59,920 --> 01:22:01,510
independent of the number of cards i
just need to say how many a's are there

3988
01:22:01,510 --> 01:22:01,520
just need to say how many a's are there
 

3989
01:22:01,520 --> 01:22:02,870
just need to say how many a's are there
could be anywhere between 0 and

3990
01:22:02,870 --> 01:22:02,880
could be anywhere between 0 and
 

3991
01:22:02,880 --> 01:22:05,510
could be anywhere between 0 and
n how many b's are there between 0 and n

3992
01:22:05,510 --> 01:22:05,520
n how many b's are there between 0 and n
 

3993
01:22:05,520 --> 01:22:07,669
n how many b's are there between 0 and n
how many c's are there between 0 and n

3994
01:22:07,669 --> 01:22:07,679
how many c's are there between 0 and n
 

3995
01:22:07,679 --> 01:22:10,950
how many c's are there between 0 and n
so 26 numbers

3996
01:22:10,950 --> 01:22:10,960
so 26 numbers
 

3997
01:22:10,960 --> 01:22:15,590
so 26 numbers
in the range 0 to n

3998
01:22:15,590 --> 01:22:15,600

 

3999
01:22:15,600 --> 01:22:19,669

i like to think of this as a 26 digit

4000
01:22:19,669 --> 01:22:19,679
i like to think of this as a 26 digit
 

4001
01:22:19,679 --> 01:22:24,550
i like to think of this as a 26 digit
number base n plus 1.

4002
01:22:24,550 --> 01:22:24,560
number base n plus 1.
 

4003
01:22:24,560 --> 01:22:29,110
number base n plus 1.
we can map this into base n plus 1

4004
01:22:29,110 --> 01:22:29,120

 

4005
01:22:29,120 --> 01:22:34,790

and we get 26 digits

4006
01:22:34,790 --> 01:22:34,800

 

4007
01:22:34,800 --> 01:22:37,189

in that base another way to say it is

4008
01:22:37,189 --> 01:22:37,199
in that base another way to say it is
 

4009
01:22:37,199 --> 01:22:37,990
in that base another way to say it is
that the number of

4010
01:22:37,990 --> 01:22:38,000
that the number of
 

4011
01:22:38,000 --> 01:22:41,030
that the number of
possible uh combinations here how many

4012
01:22:41,030 --> 01:22:41,040
possible uh combinations here how many
 

4013
01:22:41,040 --> 01:22:42,950
possible uh combinations here how many
a's how many b's how many c's

4014
01:22:42,950 --> 01:22:42,960
a's how many b's how many c's
 

4015
01:22:42,960 --> 01:22:46,229
a's how many b's how many c's
is um not even theta it is

4016
01:22:46,229 --> 01:22:46,239
is um not even theta it is
 

4017
01:22:46,239 --> 01:22:48,870
is um not even theta it is
n plus one anything between zero and n

4018
01:22:48,870 --> 01:22:48,880
n plus one anything between zero and n
 

4019
01:22:48,880 --> 01:22:51,030
n plus one anything between zero and n
uh to the power 26.

4020
01:22:51,030 --> 01:22:51,040
uh to the power 26.
 

4021
01:22:51,040 --> 01:22:54,229
uh to the power 26.
this is a good polynomial

4022
01:22:54,229 --> 01:22:54,239
this is a good polynomial
 

4023
01:22:54,239 --> 01:22:57,669
this is a good polynomial
so i can do stuff

4024
01:22:57,669 --> 01:22:57,679
so i can do stuff
 

4025
01:22:57,679 --> 01:23:01,430
so i can do stuff
like radix sort

4026
01:23:01,430 --> 01:23:01,440

 

4027
01:23:01,440 --> 01:23:04,229

cool so let me summarize a little bit

4028
01:23:04,229 --> 01:23:04,239
cool so let me summarize a little bit
 

4029
01:23:04,239 --> 01:23:07,110
cool so let me summarize a little bit
how we solve part a

4030
01:23:07,110 --> 01:23:07,120
how we solve part a
 

4031
01:23:07,120 --> 01:23:08,950
how we solve part a
so i want to build a data structure

4032
01:23:08,950 --> 01:23:08,960
so i want to build a data structure
 

4033
01:23:08,960 --> 01:23:10,310
so i want to build a data structure
which is

4034
01:23:10,310 --> 01:23:10,320
which is
 

4035
01:23:10,320 --> 01:23:13,189
which is
for each value i i know i'm going to end

4036
01:23:13,189 --> 01:23:13,199
for each value i i know i'm going to end
 

4037
01:23:13,199 --> 01:23:15,430
for each value i i know i'm going to end
up serving these four

4038
01:23:15,430 --> 01:23:15,440
up serving these four
 

4039
01:23:15,440 --> 01:23:18,070
up serving these four
cards or in general k cards so for those

4040
01:23:18,070 --> 01:23:18,080
cards or in general k cards so for those
 

4041
01:23:18,080 --> 01:23:20,070
cards or in general k cards so for those
cards i would like to compute

4042
01:23:20,070 --> 01:23:20,080
cards i would like to compute
 

4043
01:23:20,080 --> 01:23:22,390
cards i would like to compute
um how many a's how many b's how many

4044
01:23:22,390 --> 01:23:22,400
um how many a's how many b's how many
 

4045
01:23:22,400 --> 01:23:24,470
um how many a's how many b's how many
c's are there and then just write down

4046
01:23:24,470 --> 01:23:24,480
c's are there and then just write down
 

4047
01:23:24,480 --> 01:23:26,790
c's are there and then just write down
this number this is a number which i can

4048
01:23:26,790 --> 01:23:26,800
this number this is a number which i can
 

4049
01:23:26,800 --> 01:23:29,830
this number this is a number which i can
write down in at most 26 words

4050
01:23:29,830 --> 01:23:29,840
write down in at most 26 words
 

4051
01:23:29,840 --> 01:23:31,669
write down in at most 26 words
because we can represent numbers between

4052
01:23:31,669 --> 01:23:31,679
because we can represent numbers between
 

4053
01:23:31,679 --> 01:23:33,430
because we can represent numbers between
0 and n in a single word

4054
01:23:33,430 --> 01:23:33,440
0 and n in a single word
 

4055
01:23:33,440 --> 01:23:35,030
0 and n in a single word
that's the wb's at least login

4056
01:23:35,030 --> 01:23:35,040
that's the wb's at least login
 

4057
01:23:35,040 --> 01:23:36,950
that's the wb's at least login
assumption uh

4058
01:23:36,950 --> 01:23:36,960
assumption uh
 

4059
01:23:36,960 --> 01:23:39,030
assumption uh
so it's constant size in a constant

4060
01:23:39,030 --> 01:23:39,040
so it's constant size in a constant
 

4061
01:23:39,040 --> 01:23:40,790
so it's constant size in a constant
number of numbers

4062
01:23:40,790 --> 01:23:40,800
number of numbers
 

4063
01:23:40,800 --> 01:23:43,510
number of numbers
i can represent all i need to know about

4064
01:23:43,510 --> 01:23:43,520
i can represent all i need to know about
 

4065
01:23:43,520 --> 01:23:44,550
i can represent all i need to know about
a thing of size

4066
01:23:44,550 --> 01:23:44,560
a thing of size
 

4067
01:23:44,560 --> 01:23:46,870
a thing of size
of length k here because i don't need to

4068
01:23:46,870 --> 01:23:46,880
of length k here because i don't need to
 

4069
01:23:46,880 --> 01:23:48,310
of length k here because i don't need to
know the individual which

4070
01:23:48,310 --> 01:23:48,320
know the individual which
 

4071
01:23:48,320 --> 01:23:49,830
know the individual which
letter is where just need to know the

4072
01:23:49,830 --> 01:23:49,840
letter is where just need to know the
 

4073
01:23:49,840 --> 01:23:51,350
letter is where just need to know the
sorted order so i just need to know this

4074
01:23:51,350 --> 01:23:51,360
sorted order so i just need to know this
 

4075
01:23:51,360 --> 01:23:53,350
sorted order so i just need to know this
is called a frequency table

4076
01:23:53,350 --> 01:23:53,360
is called a frequency table
 

4077
01:23:53,360 --> 01:23:55,910
is called a frequency table
how many a's how many b's and so if i

4078
01:23:55,910 --> 01:23:55,920
how many a's how many b's and so if i
 

4079
01:23:55,920 --> 01:23:57,350
how many a's how many b's and so if i
can compute those

4080
01:23:57,350 --> 01:23:57,360
can compute those
 

4081
01:23:57,360 --> 01:23:59,669
can compute those
then given that representation for

4082
01:23:59,669 --> 01:23:59,679
then given that representation for
 

4083
01:23:59,679 --> 01:24:00,709
then given that representation for
starting at i

4084
01:24:00,709 --> 01:24:00,719
starting at i
 

4085
01:24:00,719 --> 01:24:02,470
starting at i
and given that representation for

4086
01:24:02,470 --> 01:24:02,480
and given that representation for
 

4087
01:24:02,480 --> 01:24:04,550
and given that representation for
starting it j say which would be these

4088
01:24:04,550 --> 01:24:04,560
starting it j say which would be these
 

4089
01:24:04,560 --> 01:24:06,870
starting it j say which would be these
two and these two

4090
01:24:06,870 --> 01:24:06,880
two and these two
 

4091
01:24:06,880 --> 01:24:08,470
two and these two
i can compare them by just comparing

4092
01:24:08,470 --> 01:24:08,480
i can compare them by just comparing
 

4093
01:24:08,480 --> 01:24:09,990
i can compare them by just comparing
those 26 numbers

4094
01:24:09,990 --> 01:24:10,000
those 26 numbers
 

4095
01:24:10,000 --> 01:24:11,750
those 26 numbers
they're all equal then they're the same

4096
01:24:11,750 --> 01:24:11,760
they're all equal then they're the same
 

4097
01:24:11,760 --> 01:24:13,189
they're all equal then they're the same
string after sorting

4098
01:24:13,189 --> 01:24:13,199
string after sorting
 

4099
01:24:13,199 --> 01:24:14,550
string after sorting
and if there's any difference then

4100
01:24:14,550 --> 01:24:14,560
and if there's any difference then
 

4101
01:24:14,560 --> 01:24:15,990
and if there's any difference then
they're different so that's how i could

4102
01:24:15,990 --> 01:24:16,000
they're different so that's how i could
 

4103
01:24:16,000 --> 01:24:16,870
they're different so that's how i could
do it in constant time

4104
01:24:16,870 --> 01:24:16,880
do it in constant time
 

4105
01:24:16,880 --> 01:24:19,270
do it in constant time
if i can compute these representations

4106
01:24:19,270 --> 01:24:19,280
if i can compute these representations
 

4107
01:24:19,280 --> 01:24:21,669
if i can compute these representations
and it's not hard to do that you

4108
01:24:21,669 --> 01:24:21,679
and it's not hard to do that you
 

4109
01:24:21,679 --> 01:24:23,270
and it's not hard to do that you
it's called a sliding window technique

4110
01:24:23,270 --> 01:24:23,280
it's called a sliding window technique
 

4111
01:24:23,280 --> 01:24:25,350
it's called a sliding window technique
where you compute it for the first

4112
01:24:25,350 --> 01:24:25,360
where you compute it for the first
 

4113
01:24:25,360 --> 01:24:28,229
where you compute it for the first
k guys and then you remove this item and

4114
01:24:28,229 --> 01:24:28,239
k guys and then you remove this item and
 

4115
01:24:28,239 --> 01:24:29,270
k guys and then you remove this item and
add this item

4116
01:24:29,270 --> 01:24:29,280
add this item
 

4117
01:24:29,280 --> 01:24:31,510
add this item
into just by incrementing the counter

4118
01:24:31,510 --> 01:24:31,520
into just by incrementing the counter
 

4119
01:24:31,520 --> 01:24:33,430
into just by incrementing the counter
for b decrementing the counter for a

4120
01:24:33,430 --> 01:24:33,440
for b decrementing the counter for a
 

4121
01:24:33,440 --> 01:24:36,229
for b decrementing the counter for a
now i know this the representation for

4122
01:24:36,229 --> 01:24:36,239
now i know this the representation for
 

4123
01:24:36,239 --> 01:24:37,030
now i know this the representation for
these guys

4124
01:24:37,030 --> 01:24:37,040
these guys
 

4125
01:24:37,040 --> 01:24:38,550
these guys
make a copy of that which is a copy of

4126
01:24:38,550 --> 01:24:38,560
make a copy of that which is a copy of
 

4127
01:24:38,560 --> 01:24:40,390
make a copy of that which is a copy of
those 26 numbers constant

4128
01:24:40,390 --> 01:24:40,400
those 26 numbers constant
 

4129
01:24:40,400 --> 01:24:43,990
those 26 numbers constant
then i add on c remove b then i add on

4130
01:24:43,990 --> 01:24:44,000
then i add on c remove b then i add on
 

4131
01:24:44,000 --> 01:24:47,510
then i add on c remove b then i add on
a remove c add on b

4132
01:24:47,510 --> 01:24:47,520
a remove c add on b
 

4133
01:24:47,520 --> 01:24:50,790
a remove c add on b
remove d add on c remove b

4134
01:24:50,790 --> 01:24:50,800
remove d add on c remove b
 

4135
01:24:50,800 --> 01:24:54,070
remove d add on c remove b
and add on d and remove c

4136
01:24:54,070 --> 01:24:54,080
and add on d and remove c
 

4137
01:24:54,080 --> 01:24:55,590
and add on d and remove c
i got back to the beginning so now i

4138
01:24:55,590 --> 01:24:55,600
i got back to the beginning so now i
 

4139
01:24:55,600 --> 01:24:57,430
i got back to the beginning so now i
have representation of those

4140
01:24:57,430 --> 01:24:57,440
have representation of those
 

4141
01:24:57,440 --> 01:24:59,910
have representation of those
okay so i by sliding this window i'm

4142
01:24:59,910 --> 01:24:59,920
okay so i by sliding this window i'm
 

4143
01:24:59,920 --> 01:25:01,270
okay so i by sliding this window i'm
only changing

4144
01:25:01,270 --> 01:25:01,280
only changing
 

4145
01:25:01,280 --> 01:25:03,669
only changing
at the two ends i add one guy on i

4146
01:25:03,669 --> 01:25:03,679
at the two ends i add one guy on i
 

4147
01:25:03,679 --> 01:25:05,430
at the two ends i add one guy on i
increment one of these counters

4148
01:25:05,430 --> 01:25:05,440
increment one of these counters
 

4149
01:25:05,440 --> 01:25:07,189
increment one of these counters
i decrement one of these counters so in

4150
01:25:07,189 --> 01:25:07,199
i decrement one of these counters so in
 

4151
01:25:07,199 --> 01:25:08,629
i decrement one of these counters so in
constant time

4152
01:25:08,629 --> 01:25:08,639
constant time
 

4153
01:25:08,639 --> 01:25:10,229
constant time
given the representation of one of these

4154
01:25:10,229 --> 01:25:10,239
given the representation of one of these
 

4155
01:25:10,239 --> 01:25:11,430
given the representation of one of these
substrings i can compute the

4156
01:25:11,430 --> 01:25:11,440
substrings i can compute the
 

4157
01:25:11,440 --> 01:25:11,990
substrings i can compute the
representation

4158
01:25:11,990 --> 01:25:12,000
representation
 

4159
01:25:12,000 --> 01:25:14,390
representation
of the next one that's how in linear

4160
01:25:14,390 --> 01:25:14,400
of the next one that's how in linear
 

4161
01:25:14,400 --> 01:25:15,830
of the next one that's how in linear
time can build such a data structure

4162
01:25:15,830 --> 01:25:15,840
time can build such a data structure
 

4163
01:25:15,840 --> 01:25:16,310
time can build such a data structure
that

4164
01:25:16,310 --> 01:25:16,320
that
 

4165
01:25:16,320 --> 01:25:18,550
that
lets me tell whether any two hands are

4166
01:25:18,550 --> 01:25:18,560
lets me tell whether any two hands are
 

4167
01:25:18,560 --> 01:25:19,669
lets me tell whether any two hands are
equal

4168
01:25:19,669 --> 01:25:19,679
equal
 

4169
01:25:19,679 --> 01:25:22,950
equal
the next problem part b is given all

4170
01:25:22,950 --> 01:25:22,960
the next problem part b is given all
 

4171
01:25:22,960 --> 01:25:24,870
the next problem part b is given all
these representations

4172
01:25:24,870 --> 01:25:24,880
these representations
 

4173
01:25:24,880 --> 01:25:26,709
these representations
can you find which one is the most

4174
01:25:26,709 --> 01:25:26,719
can you find which one is the most
 

4175
01:25:26,719 --> 01:25:28,790
can you find which one is the most
common because we're choosing i

4176
01:25:28,790 --> 01:25:28,800
common because we're choosing i
 

4177
01:25:28,800 --> 01:25:30,310
common because we're choosing i
uniformly at random i want to know what

4178
01:25:30,310 --> 01:25:30,320
uniformly at random i want to know what
 

4179
01:25:30,320 --> 01:25:31,830
uniformly at random i want to know what
the most likely

4180
01:25:31,830 --> 01:25:31,840
the most likely
 

4181
01:25:31,840 --> 01:25:35,030
the most likely
hand that you get is and i think the

4182
01:25:35,030 --> 01:25:35,040
hand that you get is and i think the
 

4183
01:25:35,040 --> 01:25:36,709
hand that you get is and i think the
easiest way to say this is you can do

4184
01:25:36,709 --> 01:25:36,719
easiest way to say this is you can do
 

4185
01:25:36,719 --> 01:25:38,390
easiest way to say this is you can do
that by radix sorting

4186
01:25:38,390 --> 01:25:38,400
that by radix sorting
 

4187
01:25:38,400 --> 01:25:40,070
that by radix sorting
you take all these representations they

4188
01:25:40,070 --> 01:25:40,080
you take all these representations they
 

4189
01:25:40,080 --> 01:25:41,669
you take all these representations they
are nice numbers in the

4190
01:25:41,669 --> 01:25:41,679
are nice numbers in the
 

4191
01:25:41,679 --> 01:25:44,790
are nice numbers in the
range 0 to n plus 1 to the 26th power

4192
01:25:44,790 --> 01:25:44,800
range 0 to n plus 1 to the 26th power
 

4193
01:25:44,800 --> 01:25:46,390
range 0 to n plus 1 to the 26th power
so i can just run radix sort and sort

4194
01:25:46,390 --> 01:25:46,400
so i can just run radix sort and sort
 

4195
01:25:46,400 --> 01:25:48,070
so i can just run radix sort and sort
them all and then do

4196
01:25:48,070 --> 01:25:48,080
them all and then do
 

4197
01:25:48,080 --> 01:25:49,830
them all and then do
with a single scan through the array i

4198
01:25:49,830 --> 01:25:49,840
with a single scan through the array i
 

4199
01:25:49,840 --> 01:25:51,430
with a single scan through the array i
can see which one is the most

4200
01:25:51,430 --> 01:25:51,440
can see which one is the most
 

4201
01:25:51,440 --> 01:25:54,149
can see which one is the most
common or rather i can in single scan i

4202
01:25:54,149 --> 01:25:54,159
common or rather i can in single scan i
 

4203
01:25:54,159 --> 01:25:54,950
common or rather i can in single scan i
can compute

4204
01:25:54,950 --> 01:25:54,960
can compute
 

4205
01:25:54,960 --> 01:25:56,629
can compute
okay how many of the same things are at

4206
01:25:56,629 --> 01:25:56,639
okay how many of the same things are at
 

4207
01:25:56,639 --> 01:25:58,550
okay how many of the same things are at
the front they're sorted then

4208
01:25:58,550 --> 01:25:58,560
the front they're sorted then
 

4209
01:25:58,560 --> 01:26:00,149
the front they're sorted then
all the equal ones will be together so

4210
01:26:00,149 --> 01:26:00,159
all the equal ones will be together so
 

4211
01:26:00,159 --> 01:26:02,229
all the equal ones will be together so
how many are there then how many

4212
01:26:02,229 --> 01:26:02,239
how many are there then how many
 

4213
01:26:02,239 --> 01:26:04,149
how many are there then how many
equal ones next and how many forms

4214
01:26:04,149 --> 01:26:04,159
equal ones next and how many forms
 

4215
01:26:04,159 --> 01:26:05,750
equal ones next and how many forms
before this next each time comparing

4216
01:26:05,750 --> 01:26:05,760
before this next each time comparing
 

4217
01:26:05,760 --> 01:26:08,229
before this next each time comparing
each item to the previous one then i get

4218
01:26:08,229 --> 01:26:08,239
each item to the previous one then i get
 

4219
01:26:08,239 --> 01:26:10,149
each item to the previous one then i get
frequency counts for all of these

4220
01:26:10,149 --> 01:26:10,159
frequency counts for all of these
 

4221
01:26:10,159 --> 01:26:12,390
frequency counts for all of these
uh hands and then i do another scan to

4222
01:26:12,390 --> 01:26:12,400
uh hands and then i do another scan to
 

4223
01:26:12,400 --> 01:26:13,830
uh hands and then i do another scan to
find the most common one

4224
01:26:13,830 --> 01:26:13,840
find the most common one
 

4225
01:26:13,840 --> 01:26:15,189
find the most common one
and i can do another scan to find the

4226
01:26:15,189 --> 01:26:15,199
and i can do another scan to find the
 

4227
01:26:15,199 --> 01:26:16,790
and i can do another scan to find the
lexically best one because that's

4228
01:26:16,790 --> 01:26:16,800
lexically best one because that's
 

4229
01:26:16,800 --> 01:26:17,830
lexically best one because that's
lexically

4230
01:26:17,830 --> 01:26:17,840
lexically
 

4231
01:26:17,840 --> 01:26:20,390
lexically
last one and that's how you solve

4232
01:26:20,390 --> 01:26:20,400
last one and that's how you solve
 

4233
01:26:20,400 --> 01:26:23,840
last one and that's how you solve
problem five

