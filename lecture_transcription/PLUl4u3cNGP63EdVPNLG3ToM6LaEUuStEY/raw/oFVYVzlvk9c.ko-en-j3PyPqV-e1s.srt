1
00:00:00,000 --> 00:00:07,728
[삐걱거리는 소리]
[바스락거리는 소리] [딸깍거리는 소리]

2
00:00:13,618 --> 00:00:14,660
저스틴 솔로몬: 자, 팀원들.  오늘

3
00:00:14,660 --> 00:00:18,600
하루를 시작해 볼까요?

4
00:00:18,600 --> 00:00:21,350

여러분 모두를 만나 뵙게 되어 기쁩니다.  혹시

5
00:00:21,350 --> 00:00:23,000

기억이 안 나실까 봐 말씀드리는데, 저는 저스틴입니다.

6
00:00:23,000 --> 00:00:26,630
저는 여러분이 아마 잊고 계셨을 006 수업의 세 번째 강사입니다.

7
00:00:26,630 --> 00:00:29,180
하지만 앞으로
그래프 이론 부분에서 저를 더 자주 보게 되실 겁니다. 제가

8
00:00:29,180 --> 00:00:31,640

알고리즘 중에서 가장

9
00:00:31,640 --> 00:00:32,280
좋아하는 부분이 바로 그래프 이론이기 때문입니다.

10
00:00:32,280 --> 00:00:35,672
만약 내가
이론 컴퓨터 과학자로 환생한다면, 아마

11
00:00:35,672 --> 00:00:37,130

이 분야를 선택할 것 같다.

12
00:00:37,130 --> 00:00:38,420
안녕하세요 여러분.

13
00:00:38,420 --> 00:00:40,490
좋아요.  앞으로 며칠 동안

14
00:00:40,490 --> 00:00:43,190
박사 과정 입학
심사 방문일이 있어서

15
00:00:43,190 --> 00:00:46,460

캠프 상담원 겸

16
00:00:46,460 --> 00:00:47,780
응원단장 목소리를 연습하고 있어요.

17
00:00:47,780 --> 00:00:51,680
그러니 내가 너희 모두를 깨워서
하루를 시작하게 만들지 마.

18
00:00:51,680 --> 00:00:53,490
당신은 그걸 좋아하지 않을 거예요.

19
00:00:53,490 --> 00:00:57,350
어쨌든,
6.006

20
00:00:57,350 --> 00:00:59,000
강의 계획서를 다시 보시면 아시겠지만,

21
00:00:59,000 --> 00:01:01,610
이 수업의 2부가 공식적으로 시작됩니다.

22
00:01:01,610 --> 00:01:04,155

그 사실에는 몇 가지 결과가 따른다.

23
00:01:04,155 --> 00:01:06,030
그럼, 더 이상 질문이 없으시면

24
00:01:06,030 --> 00:01:09,140

6.006 강의의 새로운 단원인

25
00:01:09,140 --> 00:01:11,870
그래프 이론을 시작하겠습니다.  궁금해하실

26
00:01:11,870 --> 00:01:15,153
분들을 위해 말씀드리자면,
화면에 그래프가 있습니다.

27
00:01:15,153 --> 00:01:17,570
물론,

28
00:01:17,570 --> 00:01:19,370
오늘 강의를 통해 좀 더 자세한 정보를 알려드리겠습니다.

29
00:01:19,370 --> 00:01:24,680
제가 가르치는 법을 배우던 시절
, 그리고 지금도 배우고 있는 과정에서,

30
00:01:24,680 --> 00:01:26,960
박사 학위 지도교수님께서
제게 "누군가에게

31
00:01:26,960 --> 00:01:29,460
무언가를 가르치고 싶다면, 최대한
크고 자세하게 설명해야 한다"고 말씀하셨습니다.

32
00:01:29,460 --> 00:01:31,880
그래서 저는

33
00:01:31,880 --> 00:01:34,260
오늘 슬라이드에서 그러한 접근 방식을 적극적으로 활용하려고 합니다.

34
00:01:34,260 --> 00:01:36,770
그래서 어쨌든,
오늘은

35
00:01:36,770 --> 00:01:38,690

그래프에 대한 첫 번째 강의를 진행할 예정인데, 아마

36
00:01:38,690 --> 00:01:42,890

많은 분들에게는 이미 익숙한 내용일 것 같습니다.

37
00:01:42,890 --> 00:01:44,337
만약 그렇지 않더라도
괜찮아요.

38
00:01:44,337 --> 00:01:45,920
우리는
처음부터 시작해서 그래프를

39
00:01:45,920 --> 00:01:47,420


40
00:01:47,420 --> 00:01:50,300
이해하고 처리하는 데 필요한 모든 개념을 차근차근 쌓아갈 것이고,

41
00:01:50,300 --> 00:01:53,560
강의가 끝날 때쯤에는

42
00:01:53,560 --> 00:01:56,060

한 정점에서 다른 모든 정점까지의 최단 경로를 계산하는 알고리즘을 익힐 수 있기를 바랍니다

43
00:01:56,060 --> 00:01:58,140
.

44
00:01:58,140 --> 00:02:01,620
혹시
용어를 잊어버렸을까 봐 다시 설명드리자면, 그래프는 두 가지 요소의 모음입니다.

45
00:02:01,620 --> 00:02:04,370
어떤 사람들은 이것을 네트워크라고 부르기도
하지만, 이 용어는 때때로 여러 가지 변형된 의미

46
00:02:04,370 --> 00:02:06,620
로 혼용되기도 합니다.

47
00:02:10,070 --> 00:02:12,650
이것이 바로
괄호 표기법의 의미입니다.

48
00:02:12,650 --> 00:02:16,520
정점들의 집합과
간선들의 집합이 있습니다.

49
00:02:16,520 --> 00:02:19,670
그리고
보시다시피 화면의 세 번째 점과 같은 모서리는

50
00:02:19,670 --> 00:02:23,600

v와 v의 교차 집합의 부분 집합입니다.

51
00:02:23,600 --> 00:02:25,220
이것은 아주

52
00:02:25,220 --> 00:02:27,257
간단한 것을 좀 더 복잡하게 표현한 표기법입니다.

53
00:02:27,257 --> 00:02:28,590
이게 나에게 뭘 말해주는 걸까요?

54
00:02:28,590 --> 00:02:30,870
이것은

55
00:02:30,870 --> 00:02:32,640
화면에 보이는 그림처럼 가장자리가 있다는 것을 말해줍니다.

56
00:02:32,640 --> 00:02:36,107
그것은 단지
정점들을 서로 연결하는 것일 뿐입니다.

57
00:02:36,107 --> 00:02:38,690
그러니까 만약
시작점과 끝점처럼 두 개의 꼭짓점이 있다고 생각하면,

58
00:02:38,690 --> 00:02:42,335
그것은 꼭짓점

59
00:02:42,335 --> 00:02:44,010
v와 자기 자신의 외적의 부분집합이 됩니다.

60
00:02:44,010 --> 00:02:46,502

화면 세 번째 줄에 있는 표기법이

61
00:02:46,502 --> 00:02:47,210
어느 정도 이해가 되셨으면 좋겠습니다.

62
00:02:47,210 --> 00:02:50,900
이는
간선이 정점 쌍을 나타낸다는 것을 멋지게 표기한 것일 뿐입니다.

63
00:02:50,900 --> 00:02:52,790
하지만 물론,
그 표기법 안에는 이 수업에서 우리가 중요하게 생각하는

64
00:02:52,790 --> 00:02:57,230
두 가지 특별한 경우가 있습니다
.

65
00:02:57,230 --> 00:02:59,390
하나는
방향 그래프일 때이고, 다른 하나는

66
00:02:59,390 --> 00:03:01,550

무방향 그래프일 때입니다. 화면에 표시된 순서와 반대로

67
00:03:01,550 --> 00:03:03,592
말했기 때문입니다

68
00:03:03,592 --> 00:03:04,930
.

69
00:03:04,930 --> 00:03:08,355
무방향 그래프에서
간선은 여전히 ​​두

70
00:03:08,355 --> 00:03:10,730
정점의 쌍으로 생각되지만,
사실 표기법을

71
00:03:10,730 --> 00:03:12,230
조금
다르게 했어야 했습니다. OCW 강의에

72
00:03:12,230 --> 00:03:14,480

들어가기 전에 슬라이드를 수정할 생각입니다. 'e =

73
00:03:15,650 --> 00:03:20,150

w 쉼표 v'라고 쓰는 대신 'e = v

74
00:03:20,150 --> 00:03:24,950

쉼표 w'라고 쓰는 것이 더 적절할 것 같습니다.

75
00:03:24,950 --> 00:03:27,770
그리고

76
00:03:27,770 --> 00:03:30,020
슬라이드에 있는 표기법과 제가
칠판에 쓴 표기법(

77
00:03:30,020 --> 00:03:32,480
여기서는 집합 기호) 사이에 약간의 차이가 있다는 점에 유의하세요.

78
00:03:32,480 --> 00:03:35,050

괄호와 물결선의 차이점은

79
00:03:35,050 --> 00:03:36,580
이것이 순서가 지정되지 않았다는 것입니다.

80
00:03:36,580 --> 00:03:38,140
이것은 여러 가지 사물의 집합입니다.

81
00:03:38,140 --> 00:03:40,960
칠판에 적힌 내용,

82
00:03:40,960 --> 00:03:43,030
아니, 화면에 적힌 내용이 순서대로 되어 있습니다.

83
00:03:43,030 --> 00:03:44,860
물론, 방향이
없는 간선에서는

84
00:03:44,860 --> 00:03:46,930

w에서 v로 가는 간선과 v에서

85
00:03:46,930 --> 00:03:49,788

w로 가는 간선이 서로 구별되는 개념이 없습니다.

86
00:03:49,788 --> 00:03:50,830
둘은 같은 것입니다.

87
00:03:50,830 --> 00:03:51,622
그들은 방향성을 잃었다.

88
00:03:51,622 --> 00:03:53,890
그것은 단지
연결성에 대한 개념일 뿐입니다.

89
00:03:53,890 --> 00:03:56,020
방향 그래프에서는

90
00:03:56,020 --> 00:03:58,120


91
00:03:58,120 --> 00:04:01,330

w에서 v로 가는 간선이

92
00:04:01,330 --> 00:04:03,987

v에서 w로 가는 간선과 다르다는 것을 나타내기 위해 괄호 표기법을 사용합니다.

93
00:04:03,987 --> 00:04:05,570
그건
큰 차이를 만들어낼 거예요.  예를 들어

94
00:04:05,570 --> 00:04:09,160

오른쪽에 있는 그래프를

95
00:04:09,160 --> 00:04:12,470

칠판에 다시 그려보도록 하겠습니다.

96
00:04:12,470 --> 00:04:14,140
그래서 우리는 네 개의 꼭짓점을 가지고 있습니다.

97
00:04:14,140 --> 00:04:16,540
어젯밤에 그린 그림인데,
이 예시가

98
00:04:16,540 --> 00:04:17,260
제대로 작동했으면 좋겠네요.

99
00:04:22,029 --> 00:04:26,580
저렇게 하면, 이 그래프에서 간선을 따라
오른쪽 위 꼭짓점에서

100
00:04:26,580 --> 00:04:31,550
왼쪽 아래 꼭짓점으로 이동할 수 있을까요
?

101
00:04:31,550 --> 00:04:33,500
한 사람의 말을 들었습니다.

102
00:04:33,500 --> 00:04:35,838
모두 셋에 맞춰서-- 1, 2, 3.

103
00:04:35,838 --> 00:04:36,380
관객: 아니요.

104
00:04:36,380 --> 00:04:37,463
저스틴 솔로몬: 네, 맞아요.

105
00:04:37,463 --> 00:04:38,780
왜냐하면 만약 제가 이렇게 그리고 싶었다면, 그러니까 예를 들어

106
00:04:38,780 --> 00:04:41,300

이 경로를 여기에 그리는 것을 생각해 봤을 수도 있는데,

107
00:04:41,300 --> 00:04:44,270
물론 오른쪽 위에서 왼쪽 아래로
간다면…

108
00:04:45,590 --> 00:04:48,550
이건 제가 지금까지 그린 것 중에 가장 못생긴 그림이에요
, 정말 죄송합니다…

109
00:04:48,550 --> 00:04:50,300


110
00:04:50,300 --> 00:04:52,410
여기서는 가장자리가 위쪽을 향하고 있는 것을 알 수 있을 거예요.

111
00:04:52,410 --> 00:04:54,650
그러면
물의 흐름을 거슬러 가야 하는데,

112
00:04:54,650 --> 00:04:57,242

방향 그래프에서는 그게 허용되지 않아요.

113
00:04:57,242 --> 00:04:58,700
물론, 저는

114
00:04:58,700 --> 00:05:01,075
우리가 아직
제대로 정하지 않은 미래의 방향을 벌써부터 예상하고 있습니다.

115
00:05:01,075 --> 00:05:02,900
하지만
직관적으로 생각해 보면, 그것이

116
00:05:02,900 --> 00:05:06,015

방향 그래프와 무방향 그래프의 가장 큰 차이점인 것 같습니다.

117
00:05:06,015 --> 00:05:08,140
이 차이점을
여러분 모두에게 이해시키셨나요,

118
00:05:08,140 --> 00:05:12,560
아니면 제가
4분도 안 돼서 여러분을 완전히 혼란스럽게 만든 건가요?

119
00:05:12,560 --> 00:05:14,360
훌륭한.

120
00:05:14,360 --> 00:05:16,652
그래서 저는 강의 노트와 아주 조금 순서를 바꿨습니다.

121
00:05:16,652 --> 00:05:18,110


122
00:05:18,110 --> 00:05:19,777
그래프가 무엇인지 먼저 정의한
다음 그

123
00:05:19,777 --> 00:05:21,690
의미를 설명하는 게 좋겠다고 생각했기 때문입니다.

124
00:05:21,690 --> 00:05:23,990
하지만 어쨌든,

125
00:05:23,990 --> 00:05:26,000


126
00:05:26,000 --> 00:05:28,640
그래프가

127
00:05:28,640 --> 00:05:30,320
우리 일상생활 도처에 있다고 말하는 건 그리 무리한 상상도 아닐 거라고 생각합니다.

128
00:05:30,320 --> 00:05:34,130
여러 가지가 서로
연결된 네트워크를 떠올릴 때

129
00:05:34,130 --> 00:05:37,040
, 무의식적으로

130
00:05:37,040 --> 00:05:40,480
머릿속 한구석에는
그래프를 생각하는 것이 가장 적절한 추상화 방식인 경우가 많습니다.

131
00:05:40,480 --> 00:05:42,230
간단한
예를 몇 가지 들자면,

132
00:05:42,230 --> 00:05:43,730


133
00:05:43,730 --> 00:05:45,580
컴퓨터 네트워크를 생각해 볼 수 있습니다. 이 경우 그래프

134
00:05:45,580 --> 00:05:49,160
의 노드 또는 정점은

135
00:05:49,160 --> 00:05:50,960
컴퓨터이고,
간선은

136
00:05:50,960 --> 00:05:53,480
대략적으로

137
00:05:53,480 --> 00:05:57,110

네트워크 작동 방식에 대한 제 이해로는 컴퓨터들을 연결하는 케이블과 같습니다.

138
00:05:57,110 --> 00:05:59,060
또는 소셜 네트워크를 예로 들 수 있습니다.

139
00:05:59,060 --> 00:06:02,210
노드는
소셜 네트워크에 있는 사람들이고,

140
00:06:02,210 --> 00:06:04,490
간선은
친구 관계,

141
00:06:04,490 --> 00:06:08,300
적대적 관계 또는 그
외의 관계들을 나타냅니다.

142
00:06:08,300 --> 00:06:11,330
사실, 저는 그 특정 네트워크에 대해
지향성 버전과 비지향성 버전 모두를 생각해 볼 수 있다고 생각합니다

143
00:06:11,330 --> 00:06:15,220

.

144
00:06:15,220 --> 00:06:18,110
도로망을 예로 들자면,
제가 구글에서 일하고 있고

145
00:06:18,110 --> 00:06:20,600


146
00:06:20,600 --> 00:06:22,220
당신의 집에서 MIT까지의 최단 경로를 알려주고 싶다고 가정해 봅시다.

147
00:06:22,220 --> 00:06:24,500
물론,
그렇게 하기 위해서는, 그리고 본질적으로 보이지 않는

148
00:06:24,500 --> 00:06:26,840
곳에서, 우리는 그래프에서

149
00:06:26,840 --> 00:06:28,640

두 정점 사이의 최단 경로를 계산하는 문제를 해결하고 있는 것입니다

150
00:06:28,640 --> 00:06:30,225
.

151
00:06:30,225 --> 00:06:31,850
그건 약간
거짓말인데, 왜냐하면

152
00:06:31,850 --> 00:06:33,808

그 문제에는

153
00:06:33,808 --> 00:06:35,930
우리가 이
수업에서 활용하지 않을 구조적인 요소가 많이 포함되어 있기 때문입니다.

154
00:06:35,930 --> 00:06:38,900
도로망은 매우
특별한 유형의 그래프이며,

155
00:06:38,900 --> 00:06:40,670

고급 과정을 수강한다면 아마도 "

156
00:06:40,670 --> 00:06:43,490

그래프에 대해 좀 더 잘 알면

157
00:06:43,490 --> 00:06:46,740

여기서 다룰 일반적인 경우보다 더 잘할 수 있겠다"라고 생각하게 될 것입니다.

158
00:06:46,740 --> 00:06:49,610
하지만
6.006 버전에서 다룰 기본 알고리즘은

159
00:06:49,610 --> 00:06:51,073

이러한 경우에 확실히 관련이 있으며, 여러분이

160
00:06:51,073 --> 00:06:52,490


161
00:06:52,490 --> 00:06:54,620


162
00:06:54,620 --> 00:06:57,260
휴대폰에서
구글 지도

163
00:06:57,260 --> 00:06:59,630
나 구글 웨이즈 등을 열 때 매일 사용하는 도구들의 작동 원리를 구성하는 기본 요소입니다.

164
00:06:59,630 --> 00:07:01,310
물론, 그 외에도
많은 것들이 있습니다.  예를 들어

165
00:07:01,310 --> 00:07:03,835
,

166
00:07:03,835 --> 00:07:05,210
좀
더 미묘한 예시를 들자면, 이산적인 사물

167
00:07:05,210 --> 00:07:07,430
의 상태
와 전이 집합을 들 수 있습니다

168
00:07:07,430 --> 00:07:08,820
.

169
00:07:08,820 --> 00:07:11,420

루빅 큐브를 생각해 보세요.

170
00:07:11,420 --> 00:07:13,580
그래서 저는

171
00:07:13,580 --> 00:07:15,860

루빅 큐브의 모든 회전 상태,

172
00:07:15,860 --> 00:07:17,300
즉 모든 구성 상태를 노드로 하는 그래프를 만들 수 있습니다.

173
00:07:17,300 --> 00:07:19,490
그리고 나서 가장자리 부분은

174
00:07:19,490 --> 00:07:21,500


175
00:07:21,500 --> 00:07:24,170
간단한
전환, 예를 들어 한 번의 뒤집기를 통해 이 구성에서 저 구성으로 넘어갈 수 있는지 여부입니다.

176
00:07:24,170 --> 00:07:26,420
사실 저는
루빅 큐브 용어를 잘 모르지만,

177
00:07:26,420 --> 00:07:29,870
당신은
한 바퀴 돌리는 동안에는 알 것 같네요.

178
00:07:29,870 --> 00:07:32,478
트위스트님, 감사합니다.

179
00:07:32,478 --> 00:07:34,270
물론, 그
외에도 많은 곳들이 있습니다.

180
00:07:34,270 --> 00:07:38,250
예를 들어, 저는
MIT에서

181
00:07:38,250 --> 00:07:40,130

컴퓨터 그래픽스 강의를 주로 가르칩니다.

182
00:07:40,130 --> 00:07:42,170
그리고 사실 그래프
이론은 우리가

183
00:07:42,170 --> 00:07:45,170
매우 다른 방식으로 이야기하지만,
그 세계에서 끊임없이 등장합니다

184
00:07:45,170 --> 00:07:46,460
.

185
00:07:46,460 --> 00:07:48,860
당연히 컴퓨터 화면의
모든 3D 모델 뒤에는

186
00:07:48,860 --> 00:07:52,725

거대한 삼각형 네트워크가 자리 잡고 있기 때문입니다.

187
00:07:52,725 --> 00:07:54,350
이것을
삼각화된 표면이라고 합니다.

188
00:07:54,350 --> 00:07:56,210
여기 보이는 토러스처럼 말이죠.

189
00:07:56,210 --> 00:07:57,827
이것은 그저
그래프일 뿐입니다.

190
00:07:57,827 --> 00:07:59,660
사실, 6838에서 다루는
알고리즘들을 자세히 살펴보면

191
00:07:59,660 --> 00:08:01,460

,

192
00:08:01,460 --> 00:08:05,373
그것들은 사실상
그래프 알고리즘을 변형한 것에 불과하다는 것을 알 수 있습니다.

193
00:08:05,373 --> 00:08:07,790
사실, 제 대학원 수업을 들으시면

194
00:08:07,790 --> 00:08:10,165

미분기하학을 꽤 오랫동안 다루게 될 겁니다.

195
00:08:10,165 --> 00:08:12,103
그리고 나서
10피트 뒤로 물러나 보면, 삼각형 메쉬의

196
00:08:12,103 --> 00:08:13,520


197
00:08:13,520 --> 00:08:17,570
곡률과 굴곡도를 계산하는 데 사용하는 알고리즘이

198
00:08:17,570 --> 00:08:19,940

그래프 알고리즘처럼 보이고

199
00:08:19,940 --> 00:08:22,540
네트워크에도
똑같은 방식으로 적용될 수 있다는 것을 알게 됩니다.

200
00:08:22,540 --> 00:08:25,430
그래서
거기서 재밌는 반전이 펼쳐질 것 같아요.

201
00:08:25,430 --> 00:08:28,940
그리고 물론,
마지막으로 재미있는 활용법이 하나 더 있습니다.

202
00:08:28,940 --> 00:08:31,160
사실 저는
지난 며칠 동안

203
00:08:31,160 --> 00:08:33,320

정치적 선거구 재조정에 관한 컨퍼런스에 참석하느라 자리를 비웠습니다.

204
00:08:33,320 --> 00:08:35,570
그리고 재밌는 건

205
00:08:35,570 --> 00:08:38,510
그 학회에서 나눈 토론의 대부분이
그래프 이론에 관한 것이었다는 점입니다.  그

206
00:08:38,510 --> 00:08:43,340
이유는

207
00:08:43,340 --> 00:08:46,642
기하학에서 자주 나타나는 주제와 관련이 있는데, 예를 들어

208
00:08:46,642 --> 00:08:48,350


209
00:08:48,350 --> 00:08:51,500
어떤 주의 투표구들을 생각해 보면,

210
00:08:51,500 --> 00:08:53,810
인접
관계를 고려할 때 각 투표구마다

211
00:08:53,810 --> 00:08:56,570
노드를 놓고,

212
00:08:56,570 --> 00:08:59,760

경계를 공유하는 곳마다 간선을 연결할 수 있습니다.

213
00:08:59,760 --> 00:09:01,010
이제 저에게는 네트워크가 생겼습니다.

214
00:09:01,010 --> 00:09:03,980
그리고 어쩌면 제 그래프의 한 영역은

215
00:09:03,980 --> 00:09:06,150
이 네트워크의 연결된 부분과 같을지도 모릅니다.

216
00:09:06,150 --> 00:09:08,780
어쨌든, 이것은

217
00:09:08,780 --> 00:09:11,210
그래프, 네트워크,
연결성 등이

218
00:09:11,210 --> 00:09:12,920
말 그대로
어디를 가든 나타나는 사례 중 하나입니다.

219
00:09:12,920 --> 00:09:14,877
그것들은 완전히 피할 수 없어요.

220
00:09:14,877 --> 00:09:17,210
그래서 이번 수업에서 그 부분에
꽤 많은 시간을 할애할 예정입니다

221
00:09:17,210 --> 00:09:20,250
.  제 생각에는

222
00:09:20,250 --> 00:09:23,000


223
00:09:23,000 --> 00:09:27,620

MIT에서 그래프 이론 관련 강좌를 최소 세 개는 충분히 수강할 수 있고, 그래프에 관한

224
00:09:27,620 --> 00:09:30,560


225
00:09:30,560 --> 00:09:32,780
아주 간단한
문제들만 풀어도 박사 학위 논문을 쉽게 쓸 수 있을 겁니다.

226
00:09:32,780 --> 00:09:37,580
물론, 이 수업에서는

227
00:09:37,580 --> 00:09:38,455
많은 강의 중 일부만 들을 수 있도록 제한되어 있습니다.

228
00:09:38,455 --> 00:09:40,372
그래서 우리는 해결하고자

229
00:09:40,372 --> 00:09:43,250
하는 문제
와

230
00:09:43,250 --> 00:09:44,760
우리가 관심을 갖는 그래프 모두에 대해 몇 가지 가정을 세울 것입니다.

231
00:09:44,760 --> 00:09:47,210
특히, 여기서 다룰 알고리즘 대부분에는 큰 영향을 미치지 않지만 명시적으로 언급할 가치가 있는 한 가지
단순화 가정은,

232
00:09:47,210 --> 00:09:48,767


233
00:09:48,767 --> 00:09:50,600


234
00:09:50,600 --> 00:09:52,790


235
00:09:52,790 --> 00:09:55,520
우리가 주로 단순 그래프라는
특정 유형

236
00:09:55,520 --> 00:09:58,810
의 그래프를 고려할 것이라는 점입니다
.

237
00:09:58,810 --> 00:10:01,690
사실,
그래프를 어떻게 정의하느냐에 따라 의도치 않게

238
00:10:01,690 --> 00:10:03,970

그래프를 단순화하게 되는 경우가 종종 있습니다

239
00:10:03,970 --> 00:10:05,200
.

240
00:10:05,200 --> 00:10:07,570
예를 들어, 우리는
간선이

241
00:10:07,570 --> 00:10:11,110
v와 v의 교차 집합의 부분집합이라고 썼습니다. 이는

242
00:10:11,110 --> 00:10:15,460


243
00:10:15,460 --> 00:10:17,110
같은 두 정점을 통과하는 간선이 여러 개 있을 수 없다는 것을 의미할 수도 있습니다.

244
00:10:17,110 --> 00:10:22,190
그럼 단순하지 않은 그래프의 예를 살펴보겠습니다
.

245
00:10:22,190 --> 00:10:23,920
정말 죄송하지만,
아직 정의를 내리지 못했어요.

246
00:10:23,920 --> 00:10:27,440
단순 그래프는
자기 자신으로 가는 루프가 없는 그래프입니다.

247
00:10:27,440 --> 00:10:30,210
즉,
정점에서 자기 자신으로 돌아갈 수 없으며,

248
00:10:30,210 --> 00:10:31,860
모든 간선이 서로 다릅니다.  자,

249
00:10:31,860 --> 00:10:36,610
그럼
우리가 생각할 수 있는 가장 복잡한 그래프를 만들어 봅시다.

250
00:10:36,610 --> 00:10:40,600
예를 들어,
정점이 두 개 있다고 가정해 봅시다.

251
00:10:40,600 --> 00:10:42,700
그러니까 제가 만약 그래프를 만들고 싶다면,

252
00:10:42,700 --> 00:10:45,400

두 개의 꼭짓점과 하나의 간선이 있다고 가정해 볼게요.

253
00:10:45,400 --> 00:10:47,050
이건 간단합니다.

254
00:10:47,050 --> 00:10:49,420
만약 내가 일부러 짜증 나게
하고 복잡하게 만들고 싶었다면,

255
00:10:49,420 --> 00:10:53,130
이 특징을
세 번 복제해서

256
00:10:53,130 --> 00:10:54,430
재미 삼아 그렇게 했을지도 몰라요.

257
00:10:54,430 --> 00:10:57,090
이는
두 번째 가정을 위반하는 것입니다.

258
00:10:57,090 --> 00:10:59,590
게다가 상황을 더 악화시키자면,

259
00:10:59,590 --> 00:11:03,050

이 정점에서 자기 자신으로 이어지는 간선을 추가하면 첫 번째 조건을 위반할 수도 있습니다.

260
00:11:03,050 --> 00:11:06,530
이것은 간단한 문제가 아닙니다.  사실

261
00:11:09,828 --> 00:11:12,370
뭐라고 불러야 할지 모르겠네요.
일반적인 그래프라고 할까요?

262
00:11:12,370 --> 00:11:14,930

간단하지 않으니 복잡하다고 할 수 있겠네요.  글쎄요,

263
00:11:14,930 --> 00:11:19,297
멀티그래프인 것 같은데요.

264
00:11:19,297 --> 00:11:20,380
저는 항상 그렇게 생각했어요.

265
00:11:20,380 --> 00:11:22,220
어쨌든, 상관없어요.

266
00:11:22,220 --> 00:11:24,100
하지만 어쨌든
이 수업에서는

267
00:11:24,100 --> 00:11:26,745

이 특정 상황에 대해 걱정하지 않을 겁니다.

268
00:11:26,745 --> 00:11:28,870
물론
그래프 이론의 많은 응용 분야에서 그러한 가정을 하는 것은

269
00:11:28,870 --> 00:11:31,612
완전히 합리적입니다
.

270
00:11:31,612 --> 00:11:33,820

단순 그래프의 정의에 대해 궁금한 점이 있으신가요?

271
00:11:36,440 --> 00:11:39,092
좋아요, 그럼 이제부터
그래프에 대해 생각할 때마다,

272
00:11:39,092 --> 00:11:40,550


273
00:11:40,550 --> 00:11:42,260
그래프가 단순하다는 것을 마음속으로 떠올려 봅시다.

274
00:11:42,260 --> 00:11:44,870

단순 그래프가 가진 멋진 특징 중 하나는,

275
00:11:44,870 --> 00:11:47,120
제가
화면에 큰 글씨로 적어 놓았듯이

276
00:11:47,120 --> 00:11:52,250
,
간선이 v 제곱의 큰 O라는 점입니다.

277
00:11:52,250 --> 00:11:55,790
그리고 실제로,
그 공식을 아주 조금 더 확장해 보겠습니다.

278
00:11:55,790 --> 00:11:57,860
그래서 크게
두 가지 경우가 있는데, 하나는

279
00:11:57,860 --> 00:11:59,870
그래프가
무방향 그래프인 경우이고, 다른 하나는

280
00:11:59,870 --> 00:12:03,780
그래프가 방향 그래프인 경우입니다.

281
00:12:03,780 --> 00:12:05,270
자, 만약 방향 그래프가 있다면

282
00:12:12,220 --> 00:12:15,570
, 그래프에 몇 개의
간선이 있을 수 있는지 생각해 봅시다.

283
00:12:15,570 --> 00:12:21,580
간선은 출발
정점과 도착 정점의 쌍이며, 절대

284
00:12:21,580 --> 00:12:23,230
두 번 반복될 수 없습니다.

285
00:12:23,230 --> 00:12:27,190
그건
여기서 두 번째 가정과 비슷한 거죠.

286
00:12:27,190 --> 00:12:29,570
그렇다면 구체적으로
우리는 무엇을 알고 있을까요?

287
00:12:29,570 --> 00:12:31,390
우리는 mod E, 즉

288
00:12:31,390 --> 00:12:36,740
그래프의 간선 개수가
무엇에 의해 상한이 정해지는지 알고 있습니다.

289
00:12:36,740 --> 00:12:40,600
음, 저는 이렇게 아무 정점 쌍이나 선택할 수 있지만,

290
00:12:43,958 --> 00:12:46,000


291
00:12:46,000 --> 00:12:48,250
제 그래프가 방향 그래프이기 때문에 시작점과 끝점이

292
00:12:48,250 --> 00:12:50,450
중요하므로 조금 주의해야 합니다.

293
00:12:50,450 --> 00:12:52,900
즉, v choose
2는 임의의

294
00:12:52,900 --> 00:12:55,630
고유한 두 정점 쌍을 선택할 수 있지만,

295
00:12:55,630 --> 00:12:57,940


296
00:12:57,940 --> 00:13:00,190

소스 정점과 대상 정점이 서로

297
00:13:00,190 --> 00:13:01,900
바뀔 수 있다는 점을 고려하여 앞에 2라는 인수를 붙여야 한다는 것을 의미합니다.

298
00:13:01,900 --> 00:13:03,825
물론, 제가 연출 없이 연기하고 싶다면

299
00:13:03,825 --> 00:13:05,200

그런 걱정은 할 필요가 없죠.

300
00:13:10,520 --> 00:13:16,540
여기서 E는
mod v choose 2보다 작거나 같습니다.

301
00:13:16,540 --> 00:13:19,030
즉,

302
00:13:19,030 --> 00:13:21,400
모든 간선은
두 개의 정점으로 이루어져 있고,

303
00:13:21,400 --> 00:13:22,648
내 간선은 모두 고유하다는 것을 좀 더 세련되게 표현한 것입니다.

304
00:13:22,648 --> 00:13:24,190
그리고 한 가지,

305
00:13:24,190 --> 00:13:27,160

이항계수 공식을 여기에 적어보면

306
00:13:27,160 --> 00:13:30,440

이 두 가지 모두—

307
00:13:30,440 --> 00:13:33,850
아, 맞다, 죄송합니다—

308
00:13:37,330 --> 00:13:39,920
최악의 경우 mod v 제곱이라는 것을 알 수 있습니다.

309
00:13:43,370 --> 00:13:45,723
그건 당연한 일이죠.
왜냐하면 간선은 당연히 두 개의

310
00:13:45,723 --> 00:13:46,640
정점의 쌍이니까요.

311
00:13:46,640 --> 00:13:48,470

거기에 광장이 있을 거라고 예상하는 게 당연하죠.  예

312
00:13:48,470 --> 00:13:48,970
?

313
00:13:48,970 --> 00:13:53,942
관객: [잘 안 들림]

314
00:13:53,942 --> 00:13:55,150
저스틴 솔로몬: 정말 죄송합니다.

315
00:13:55,150 --> 00:13:56,177
안 들려요.

316
00:13:56,177 --> 00:13:57,760
청중: 그러니까 숫자 2는

317
00:13:57,760 --> 00:13:58,932
출처에서 나온 거군요.

318
00:13:58,932 --> 00:14:00,140
저스틴 솔로몬: 네, 맞습니다.

319
00:14:00,140 --> 00:14:03,400
따라서 디렉터의 경우 2라는 값은

320
00:14:03,400 --> 00:14:07,900
v에서 w로 가는 간선과 w에서 v로 가는
간선이 다르다는 사실에서 비롯됩니다

321
00:14:07,900 --> 00:14:11,105
.
여기서 이항 계수는

322
00:14:11,105 --> 00:14:12,730


323
00:14:12,730 --> 00:14:15,280

크기가 v인 집합에서 두 가지를 선택하는 방법의 수를 세는 것일 뿐 순서는

324
00:14:15,280 --> 00:14:16,930
고려하지 않는다는 점을 기억하세요
.

325
00:14:16,930 --> 00:14:20,760
네, 다른 질문 있으신가요?

326
00:14:20,760 --> 00:14:21,808
굉장한.

327
00:14:21,808 --> 00:14:23,100
그렇다면 이것이 왜 중요할까요?

328
00:14:23,100 --> 00:14:24,600
음, 이런 종류
의 제약 조건들은

329
00:14:24,600 --> 00:14:26,470

여러분에게는 다소 당연해 보일 수도 있지만,

330
00:14:26,470 --> 00:14:28,428
우리는
그래프 알고리즘을 작성할 것입니다.

331
00:14:28,428 --> 00:14:30,480
이제
실행 시간과

332
00:14:30,480 --> 00:14:33,368
차지하는 공간을 분석할 때,

333
00:14:34,410 --> 00:14:37,740
정점의 수
와 간선의 수라는 두 가지 다른 수치를 고려할 수 있게 되었습니다.  예를 들어

334
00:14:37,740 --> 00:14:39,240
, 간선의 수에 비례하는

335
00:14:39,240 --> 00:14:42,300
실행 시간을 갖는 알고리즘을 작성했다면

336
00:14:42,300 --> 00:14:44,940
,
일반적으로 그래프에 대한 추가적인 가정을 하지 않는 한, 그

337
00:14:44,940 --> 00:14:46,513

알고리즘의 실행

338
00:14:46,513 --> 00:14:48,930
시간은 정점 수
의 제곱에 비례할 것이라고 생각할 수 있을 것입니다

339
00:14:48,930 --> 00:14:51,030


340
00:14:51,030 --> 00:14:52,100
.

341
00:14:52,100 --> 00:14:53,850
그래서

342
00:14:53,850 --> 00:14:55,470
이러한 여러
상수들 사이에는 어떤 연관성이 있으며,

343
00:14:55,470 --> 00:14:57,000
이를 항상 염두에 두는 것이 유용합니다
.

344
00:14:57,000 --> 00:14:59,417
때때로 여러 가지
표현이 있지만, 그 표현들이 서로 다른 언어로

345
00:14:59,417 --> 00:15:02,220
대략
같은 관계를 나타내는 경우를 볼 수 있습니다.

346
00:15:04,130 --> 00:15:06,840
물론, 이는
우리가 더 정확하게 표현할 수 있다는 것을 의미하기도 합니다.

347
00:15:06,840 --> 00:15:10,470
그래서 때때로 그래프는
우리가 흔히 말하는 희소 그래프가 될 수 있습니다.

348
00:15:10,470 --> 00:15:12,290
제 관점에서 보면, 제가 일상생활에서 접하는
거의 모든 그래프는

349
00:15:12,290 --> 00:15:15,530

극히 희소한 형태를 띠고 있습니다.

350
00:15:15,530 --> 00:15:18,530
이는
위상수학의 결과입니다.  그렇기

351
00:15:18,530 --> 00:15:20,750
때문에, 실제로는 모든 가능한 쌍을 연결하는 것보다

352
00:15:20,750 --> 00:15:22,790

간선의 수가 적은 경우가 많으므로,

353
00:15:22,790 --> 00:15:25,215


354
00:15:25,215 --> 00:15:26,840

간선의 수에 비례하여 확장되는 알고리즘이 정점의 수의 제곱에 비례하여 확장되는 알고리즘보다 훨씬 더 바람직할 수 있습니다

355
00:15:26,840 --> 00:15:28,910


356
00:15:28,910 --> 00:15:32,330

.

357
00:15:32,330 --> 00:15:34,560
그래서

358
00:15:34,560 --> 00:15:37,190
우리가
이러한 수치에 대해 생각하는 이유가 바로 이것입니다.

359
00:15:37,190 --> 00:15:40,550
좋아요, 그럼
여기서 지루한 정의들을 계속 만들어 봅시다.

360
00:15:40,550 --> 00:15:42,560

우리가 생각해 봐야 할 다른 몇 가지 사항은

361
00:15:42,560 --> 00:15:46,490

그래프의 위상이나 연결성,

362
00:15:46,490 --> 00:15:49,280
특히
이웃 노드에 관한 것입니다.

363
00:15:49,280 --> 00:15:52,400
일반적으로 우리는
두 정점 사이에 간선이 있으면 그 두 정점을

364
00:15:52,400 --> 00:15:54,090
이웃이라고 생각합니다

365
00:15:54,090 --> 00:15:55,940
.

366
00:15:55,940 --> 00:15:57,710
우리는
조금 조심해야 합니다.

367
00:15:57,710 --> 00:16:00,440
왜냐하면,
분명한 방향성을 가진 관계가 형성될 때는, 이웃 관계에서

368
00:16:00,440 --> 00:16:02,900

누가 주고

369
00:16:02,900 --> 00:16:05,480
받는 입장에 있는지 신중해야 하기 때문입니다
.

370
00:16:05,480 --> 00:16:08,730
네, 그럼 아주 아주
간단한 그래프를 그려보죠.

371
00:16:08,730 --> 00:16:13,130
자, 여기가 정점 0이고, 여기가
정점 1이고, 여기가 정점 2입니다.

372
00:16:13,130 --> 00:16:17,570
그리고
위로 올라가는 간선, 아래로 내려가는 간선,

373
00:16:17,570 --> 00:16:21,470
그리고 여기에 순환이 있을 수도 있습니다.

374
00:16:21,470 --> 00:16:22,700
좋아요.

375
00:16:22,700 --> 00:16:24,980
이제 우리는

376
00:16:24,980 --> 00:16:27,290

나가는 이웃 집합,

377
00:16:27,290 --> 00:16:29,120
들어오는 이웃 집합과 같이 다양한 이웃 개념을 정의할 수 있습니다.  여기서

378
00:16:29,120 --> 00:16:30,800
기본적인 아이디어는

379
00:16:30,800 --> 00:16:34,040

정점에서 나가는 간선과 정점으로 향하는 간선을 추적하는 것입니다

380
00:16:34,040 --> 00:16:35,630
.

381
00:16:35,630 --> 00:16:37,910
네, 예를 들어,

382
00:16:37,910 --> 00:16:42,200

여기서 Adj 플러스로 표기할 나가는 이웃 집합은 무엇일까요?

383
00:16:44,900 --> 00:16:49,037

노드 0의 나가는 이웃 집합은 무엇일까요?

384
00:16:49,037 --> 00:16:50,870
자, 살펴보면

385
00:16:50,870 --> 00:16:54,230
노드 0에서 노드 2로 향하는 간선이 하나 있는 것을 알 수 있습니다.

386
00:16:54,230 --> 00:16:57,230
따라서 이것은

387
00:16:57,230 --> 00:16:59,390
다른 노드 하나만 포함하는 집합입니다.

388
00:16:59,390 --> 00:17:05,960
마찬가지로,
노드 0의 들어오는 이웃 집합을

389
00:17:05,960 --> 00:17:09,540
보면,
정점 1에서 들어오는 이웃이 하나 있으므로, 그

390
00:17:09,540 --> 00:17:14,180
집합은 위와 같습니다.

391
00:17:14,180 --> 00:17:16,550
물론
무방향 그래프에서는

392
00:17:16,550 --> 00:17:18,650

이 두 가지 사이의 구분이

393
00:17:18,650 --> 00:17:19,323
중요하지 않습니다.

394
00:17:19,323 --> 00:17:20,990
자, 여기
마지막 항목을 보시면

395
00:17:20,990 --> 00:17:22,910
, 방향이
없는 경우에는

396
00:17:22,910 --> 00:17:25,020
플러스
나 마이너스 부호를 생략하는 경우가 많은데, 그 이유는

397
00:17:25,020 --> 00:17:28,069
사실상
중요하지 않기 때문입니다.

398
00:17:28,069 --> 00:17:31,190
어쨌든, 중요한 용어 하나가 더 있는데

399
00:17:31,190 --> 00:17:33,890

, 바로 '정도'입니다.

400
00:17:33,890 --> 00:17:35,780
그리고 이것은
단순히

401
00:17:35,780 --> 00:17:37,010
이 집합의 크기를 세는 것과 다를 바 없습니다.

402
00:17:37,010 --> 00:17:38,910
따라서 차수(out degree)는

403
00:17:38,910 --> 00:17:40,830
한 정점에서 바깥쪽으로 향하는 간선의 수를 나타냅니다.

404
00:17:40,830 --> 00:17:44,150
그리고 진입 차수는
해당 방향으로 향하는 간선의 개수입니다.

405
00:17:44,150 --> 00:17:47,475
따라서 이 경우
두 숫자 모두 1인 것을 알 수 있습니다. 두 숫자가 1이 아닌

406
00:17:47,475 --> 00:17:49,100
예를 살펴보겠습니다
.

407
00:17:49,100 --> 00:17:53,160
노드 1을 보면
두 개의 간선이 나오는 것을 알 수 있습니다.

408
00:17:53,160 --> 00:17:56,030
그래서
노드 1의 나가는 차수는 2입니다.

409
00:17:56,030 --> 00:18:01,420
들어오는 간선이 하나 있으므로
들어오는 차수는 1입니다.

410
00:18:01,420 --> 00:18:03,177
자, 그렇다면 왜
이런 방식을 자주 사용할까요?

411
00:18:03,177 --> 00:18:05,260
음, 우리는 주어진 정점의 이웃들을 순회하는 FOR 루프를 사용하는
그래프 알고리즘을 많이 접하게 될 겁니다

412
00:18:05,260 --> 00:18:07,660


413
00:18:07,660 --> 00:18:08,750
.

414
00:18:08,750 --> 00:18:12,320
그리고 나서 이 도수가 중요한 역할을 하게 될 겁니다
.

415
00:18:12,320 --> 00:18:15,950
이런 것들을 아주 조금만 제한해 두는 것이 좋습니다
.

416
00:18:15,950 --> 00:18:20,050
특히, 우리가 생각해 볼 수 있는 한 가지는

417
00:18:23,610 --> 00:18:25,840


418
00:18:27,940 --> 00:18:29,030
다음과 같습니다. (글이 너무 길어서 금방 지면이 부족해질 것 같네요.)

419
00:18:29,030 --> 00:18:33,250
그럼 제 그래프 안에 있을
수 있는 모든 노드를 살펴보고

420
00:18:33,250 --> 00:18:35,578
,
이제 그

421
00:18:35,578 --> 00:18:36,745
노드들의 차수를 모두 더해 보겠습니다.

422
00:18:42,460 --> 00:18:43,760
자, 그럼 한번 살펴볼까요?

423
00:18:43,760 --> 00:18:45,890

이 그래프를 보면

424
00:18:45,890 --> 00:18:49,940

이 정점에는 인접한 간선이 세 개 있고

425
00:18:49,940 --> 00:18:52,910
, 저 정점에도 인접한 간선이 세 개
, 그리고 이 정점에는 인접한 간선이 두 개 있습니다.

426
00:18:52,910 --> 00:18:54,760
그래서 우리는 그것들을 모두 합산합니다.

427
00:18:54,760 --> 00:18:56,830
그래서

428
00:18:56,830 --> 00:18:58,160
이러한
것들을 합산하는 편리한 상한선을 정하는 것이 좋습니다. 왜냐하면 우리는

429
00:18:58,160 --> 00:19:00,620

모든 정점과

430
00:19:00,620 --> 00:19:02,400
모든 이웃에 대해 어떤 작업을 수행하는 알고리즘을 갖게 될 것이기 때문입니다.

431
00:19:02,400 --> 00:19:04,850
그러니 대략 얼마나 걸릴지 알아두는 게 좋겠죠

432
00:19:04,850 --> 00:19:06,920
.

433
00:19:06,920 --> 00:19:09,120
이 점에 대해 생각해 봅시다.

434
00:19:09,120 --> 00:19:10,475
그렇다면 우리가 알고 있는 것은 무엇일까요?

435
00:19:10,475 --> 00:19:14,030
무방향
그래프에서 모든 간선은

436
00:19:14,030 --> 00:19:15,380
두 개의 정점에 인접해 있습니다.

437
00:19:18,320 --> 00:19:20,540
그렇다면
우리가 학위를 어떻게 설명하는지 생각해 보면,

438
00:19:20,540 --> 00:19:23,440
우리는 무엇을 알고 있을까요?

439
00:19:23,440 --> 00:19:25,060
우리는 간선이 서로

440
00:19:25,060 --> 00:19:29,470

다른 두 정점의 차수에 영향을 미친다는 것을 알고 있습니다.

441
00:19:29,470 --> 00:19:35,260
자,
여기서 좀 더 자세히 생각해 보면,

442
00:19:35,260 --> 00:19:38,710

그래프가 무방향 그래프라면…

443
00:19:43,070 --> 00:19:49,020
아, 죄송합니다.
제가 또 헷갈렸네요.

444
00:19:49,020 --> 00:19:53,060
만약
두 개의 정점과 하나의 간선을 가진 무

445
00:19:53,060 --> 00:19:58,500
방향 그래프가 있고, 여기서
간선의 개수는

446
00:19:58,500 --> 00:19:59,670
1개입니다. 이

447
00:19:59,670 --> 00:20:02,580
그래프의 차수의 합은 얼마일까요?

448
00:20:02,580 --> 00:20:04,890
음, 1 더하기 1은 2죠.

449
00:20:04,890 --> 00:20:14,990
네, 그래서
그래프가 무방향 그래프이면 여기에 2가 있고, 방향

450
00:20:14,990 --> 00:20:20,900
그래프이면 E가 있습니다.
제가 세는 것이

451
00:20:20,900 --> 00:20:24,776
나가는 차수뿐이라면 말이죠.

452
00:20:24,776 --> 00:20:25,790
이해가 되시나요?  제가

453
00:20:25,790 --> 00:20:27,832

그 문장을 완전히 망쳐버린 것 같으니

454
00:20:27,832 --> 00:20:29,280
다시 시도해 볼까요?

455
00:20:29,280 --> 00:20:32,180
그러니까 만약 제가

456
00:20:32,180 --> 00:20:34,250
모든 정점에서 뻗어 나오는 간선의 개수만 세고,

457
00:20:34,250 --> 00:20:36,560

가능한 모든 정점에 대해 그 수를 세면,

458
00:20:36,560 --> 00:20:37,890
두 가지 경우가 생깁니다.

459
00:20:37,890 --> 00:20:40,220
하나는 방향성 간선이고, 다른
하나는 무방향 간선입니다.

460
00:20:40,220 --> 00:20:42,590
따라서 무방향 그래프의 경우

461
00:20:42,590 --> 00:20:44,840
모든
간선이 동시에

462
00:20:44,840 --> 00:20:46,400
진입하고 나가는 형태이기 때문에 여기서는 2라는 값이 나옵니다.  반면

463
00:20:46,400 --> 00:20:48,140


464
00:20:48,140 --> 00:20:49,070
방향성이 있는 경우에는 계수가 1이 됩니다.

465
00:20:49,070 --> 00:20:50,210
이해가 되시나요?

466
00:20:50,210 --> 00:20:53,030

잠깐 실수를 해서 죄송합니다.

467
00:20:53,030 --> 00:20:54,950
좋습니다, 훌륭합니다.

468
00:20:54,950 --> 00:20:58,298
좋아, 그건
나중에 우리에게 유용한 단서가 될 거야.

469
00:20:58,298 --> 00:20:59,840
이제 그래프에 대해 생각해 봅시다.
물론

470
00:20:59,840 --> 00:21:01,010
우리는
지난 몇 주 동안

471
00:21:01,010 --> 00:21:02,305
데이터 구조에 대해 생각해 왔으니까요.

472
00:21:02,305 --> 00:21:04,680

그래프를 컴퓨터에 저장하는 방법에 대해 생각해 봐야 하는데,

473
00:21:04,680 --> 00:21:06,720
여러
가지 방법이 있습니다.

474
00:21:06,720 --> 00:21:10,040
사실,
여러분이 할 수 있는 가장 좋은 방법 중 하나는

475
00:21:10,040 --> 00:21:12,227

집합에 대해 이야기했을 때처럼 쌍을 이루는 것입니다.

476
00:21:12,227 --> 00:21:14,060

세트를 저장하는 방법은 여러 가지가 있습니다.  이를

477
00:21:14,060 --> 00:21:16,340
이해하는 한 가지 방법은

478
00:21:16,340 --> 00:21:18,860
우리가
해당 데이터 세트와 어떻게 상호 작용할지에 따라, 상호 작용 유형을

479
00:21:18,860 --> 00:21:21,830

최적화하고

480
00:21:21,830 --> 00:21:24,590


481
00:21:24,590 --> 00:21:26,360

가능한 한 빠르게 처리하기 위해 특정 데이터 구조를 선택할 수 있다는 것입니다.

482
00:21:26,360 --> 00:21:29,690

그래프의 경우에도 마찬가지입니다.

483
00:21:29,690 --> 00:21:33,470
예를 들어, 그래프를
표현하는 가장 단순한 방법은

484
00:21:33,470 --> 00:21:36,530
단순히
간선의 긴 목록을 나열하는 것입니다.

485
00:21:36,530 --> 00:21:39,980
예를 들어,
위 그래프에서

486
00:21:39,980 --> 00:21:44,930
0, 1이 하나의
간선이고, 0,

487
00:21:44,930 --> 00:21:50,930
2가 또 다른 간선이며,
1, 2, 그리고 2, 1과 같은 간선들이 있을 수 있습니다.

488
00:21:50,930 --> 00:21:52,340
간선들의 목록은 아주 길죠.

489
00:21:52,340 --> 00:21:53,480
이건 진짜 세트예요.

490
00:21:53,480 --> 00:21:55,312
순서는 상관없어요.

491
00:21:55,312 --> 00:21:56,718
관객: 첫 번째는 1, 2입니다.

492
00:21:56,718 --> 00:21:58,260
저스틴 솔로몬: 1--
아, 맞아요.

493
00:21:58,260 --> 00:21:58,860
죄송합니다.

494
00:21:58,860 --> 00:22:00,630
네, 모서리가 위쪽을 향하고 있네요.

495
00:22:00,630 --> 00:22:01,875
에릭, 고마워요. 아니, 에릭이 아니라

496
00:22:01,875 --> 00:22:02,375
제이슨이에요.

497
00:22:05,110 --> 00:22:08,408
좋아요, 예를 들어
그래프 알고리즘이 있다고 가정해 볼게요. 이 알고리즘은

498
00:22:08,408 --> 00:22:09,950


499
00:22:09,950 --> 00:22:13,100

v에서 w로 가는 간선이 존재하는지 여부를

500
00:22:13,100 --> 00:22:14,270
여러 번 확인해야 합니다.

501
00:22:16,790 --> 00:22:19,380

이 데이터 구조에서 그 작업을 하는 데 얼마나 걸릴까요?

502
00:22:19,380 --> 00:22:22,850
음, 만약 제가 뒤죽박죽이고 정리되지 않은
간선 목록을 가지고 있고,

503
00:22:22,850 --> 00:22:25,250

v에서 w로 가는 간선이 존재하는지 알고 싶다면, 할

504
00:22:25,250 --> 00:22:28,605
수 있는 유일한 방법은 이 목록을 따라가면서 제가 찾고 있는 간선을 찾는 FOR 루프를 작성하는 것뿐입니다

505
00:22:28,605 --> 00:22:30,480

.

506
00:22:30,480 --> 00:22:30,890
아니요.

507
00:22:30,890 --> 00:22:31,880

제가 찾던 이점이 바로 이런 건가요?

508
00:22:31,880 --> 00:22:32,645
아니요.

509
00:22:32,645 --> 00:22:35,360
따라서
간선을 찾을 때마다 그래프의 간선 수에

510
00:22:35,360 --> 00:22:37,933

비례하는 시간이 소요될 수 있으며,

511
00:22:37,933 --> 00:22:39,350


512
00:22:39,350 --> 00:22:42,020
이는 최대
v 제곱에 이를 수도 있습니다.

513
00:22:42,020 --> 00:22:44,600
네, 그래서

514
00:22:44,600 --> 00:22:47,352
제 컴퓨터에서 그래프를 보여주는 방식은 그다지 좋지 않습니다.  데이터 구조를

515
00:22:47,352 --> 00:22:49,310
다시 생각해 보면, '

516
00:22:49,310 --> 00:22:52,130
아, 엣지 리스트는
아마 좋은 방법이 아닐 거야'라고 말할 수 있을 겁니다.

517
00:22:52,130 --> 00:22:53,780
하지만
우리가 그래프를 표기하는 방식이

518
00:22:53,780 --> 00:22:56,750
마치
간선 목록처럼 보인다는 점에 주목하세요.

519
00:22:56,750 --> 00:22:59,870
하지만 어쨌든,
더 일반적인 방법은

520
00:22:59,870 --> 00:23:03,750

인접 목록과 같은 것을 가져오는 것입니다.

521
00:23:03,750 --> 00:23:08,360

인접 리스트의 기본 개념은

522
00:23:08,360 --> 00:23:18,710

정점

523
00:23:18,710 --> 00:23:24,465
u와 u에 인접한 모든 정점을 연결하는 집합을 저장하는 것입니다.

524
00:23:24,465 --> 00:23:25,840
즉,

525
00:23:25,840 --> 00:23:27,465


526
00:23:27,465 --> 00:23:29,830
모든 정점에서 나가는 모든 간선을 추적하겠다는 뜻입니다.

527
00:23:29,830 --> 00:23:33,642
이제
이 객체를 어떻게 저장할지 결정해야 합니다.

528
00:23:33,642 --> 00:23:35,100
그리고 종종
우리는

529
00:23:35,100 --> 00:23:37,350

v에서 w로 가는 간선이 존재하는지와 같은 질문에 답해야 할 것입니다

530
00:23:37,350 --> 00:23:38,522
.

531
00:23:38,522 --> 00:23:39,480
그렇다면 제가 어떻게 그렇게 할 수 있을까요?

532
00:23:39,480 --> 00:23:43,140
먼저
v를 검색하면 v와 인접한

533
00:23:43,140 --> 00:23:44,958

모든 것들의 목록이나 집합이 반환됩니다

534
00:23:44,958 --> 00:23:47,250
. 그리고
저는 그 목록을 조회해야 합니다.

535
00:23:47,250 --> 00:23:49,110
그리고 저는 그 과정이 꽤 빨랐으면 좋겠어요.

536
00:23:49,110 --> 00:23:54,990
그래서 제가 할 수 있는 방법은

537
00:23:54,990 --> 00:24:00,990
인접한 요소들의 집합을
직접 접근

538
00:24:00,990 --> 00:24:07,500
배열이나 해시 테이블 같은 형태로 저장해서
검색 속도를 높이는 것입니다.

539
00:24:14,870 --> 00:24:17,123
예를 들어,

540
00:24:17,123 --> 00:24:19,040


541
00:24:19,040 --> 00:24:20,457


542
00:24:20,457 --> 00:24:22,213
내 그래프에 간선이 존재하는지 확인하는 데 얼마나 걸릴까요? 아, 제가 문장을 마저 마무리할게요.

543
00:24:22,213 --> 00:24:23,130
음, 나라면 어떻게 하겠어?

544
00:24:23,130 --> 00:24:24,680
저는 먼저
이 물건을 꺼낸 다음, 그 안을 들여다볼 겁니다

545
00:24:24,680 --> 00:24:26,720

.

546
00:24:26,720 --> 00:24:28,490
그래서 만약 이걸
해시 테이블로 저장한다면,

547
00:24:28,490 --> 00:24:31,100

첫 번째 주문 조회에 걸리는 예상 시간은 다음과 같습니다.

548
00:24:31,100 --> 00:24:32,690
왜냐하면 이게
첫 번째 주문이고, 그 다음에

549
00:24:32,690 --> 00:24:34,890
또 다른 첫 번째 주문
조회가 있기 때문입니다.

550
00:24:34,890 --> 00:24:38,580
그래서 우리는
간단한 요령 하나로 v²에서 1로 변환했습니다.  예

551
00:24:38,580 --> 00:24:39,327
?

552
00:24:39,327 --> 00:24:42,223
관객:
방향이 중요한가요? [잘 안 들림]

553
00:24:42,223 --> 00:24:43,890
저스틴 솔로몬:
좋은 질문입니다.

554
00:24:43,890 --> 00:24:45,307
그러니까 이건 디자인적인
결정입니다.

555
00:24:45,307 --> 00:24:48,110
죄송합니다. 제가 머릿속으로
무방향 그래프에 대해 많이 생각하다

556
00:24:48,110 --> 00:24:49,818
보니
이런 실수를 자주 할 것 같습니다.

557
00:24:49,818 --> 00:24:51,260
그리고 당신이 저를 잡아주셔서 정말 다행이에요.

558
00:24:51,260 --> 00:24:52,968
아주
합리적인 방법이 하나 있는데, 아마도

559
00:24:52,968 --> 00:24:55,670


560
00:24:55,670 --> 00:24:56,687
모든 정점의 나가는 간선을 추적하는 것일 겁니다.

561
00:24:56,687 --> 00:24:57,770
이는 설계상의 결정입니다.

562
00:24:57,770 --> 00:24:59,690
알고리즘을 위해

563
00:24:59,690 --> 00:25:00,973
들어오는 간선을 추적하고 싶을 수도 있습니다.

564
00:25:00,973 --> 00:25:02,390
어쨌든,

565
00:25:02,390 --> 00:25:05,580

나중에 그래프를 만들 때 원하는 내용과 일치하는지 확인하기만 하면 돼요.  아주

566
00:25:05,580 --> 00:25:06,990
좋은 지적입니다.

567
00:25:06,990 --> 00:25:10,520
죄송하지만, 기하학 전공자로서
방향 그래프는 거의 접할 기회가 없습니다

568
00:25:10,520 --> 00:25:11,540
.

569
00:25:11,540 --> 00:25:13,700
하지만

570
00:25:13,700 --> 00:25:16,870
모든 사람이
나와 같은 문제를 연구하는 것은 아니라는 점을 항상 기억하는 것이 중요합니다.

571
00:25:16,870 --> 00:25:20,630
좋아요, 이제
좀 극단적인 예를 들어보자면, 표현의

572
00:25:20,630 --> 00:25:22,683
세 번째 예시로,

573
00:25:22,683 --> 00:25:24,100

어떤 의미에서는 인접 리스트와

574
00:25:24,100 --> 00:25:25,725
비슷하게 생각할 수 있는

575
00:25:25,725 --> 00:25:28,340
인접 행렬이 필요합니다. 이 행렬에서는

576
00:25:28,340 --> 00:25:32,090

이 간선이 존재하는지, 저

577
00:25:32,090 --> 00:25:33,780
간선이 존재하는지 등을 나타내는 거대한 v x v 배열을 유지해야 합니다.

578
00:25:33,780 --> 00:25:38,670
이제
간선이 존재하는지 확인하는 것이 정말 정말 쉬워졌습니다.

579
00:25:38,670 --> 00:25:41,045
하지만 이제

580
00:25:41,045 --> 00:25:42,420


581
00:25:42,420 --> 00:25:45,470
어떤 정점의 모든 이웃 정점을 순회하는 FOR 루프를 사용하는 그래프 알고리즘을 만든다고 가정해 보겠습니다.

582
00:25:45,470 --> 00:25:49,900
따라서 여기서
u의 모든 이웃을 순회하고 싶다면,

583
00:25:49,900 --> 00:25:51,400


584
00:25:51,400 --> 00:25:54,300
u의 이웃 개수에 비례하는 시간 안에 그렇게 할 수 있습니다.

585
00:25:54,300 --> 00:25:56,130
하지만 만약 제가 단순히 이진 값들만 있는
큰 인접 행렬을 가지고 있다면,

586
00:25:56,130 --> 00:25:59,760
예를 들어
모든 정점 쌍에 대해

587
00:25:59,760 --> 00:26:02,610
이 정점들이
인접한지 여부를 나타내는 '예' 또는 '아니오'와 같은 값들 말입니다.

588
00:26:02,610 --> 00:26:04,720
만약 제가
모든 이웃들을 순회하고 싶다면,

589
00:26:04,720 --> 00:26:07,110
이제는
모든 정점을 순회하면서

590
00:26:07,110 --> 00:26:10,132
그 정점이 1번인지 확인하고 그에 따라
어떤 작업을 수행해야 합니다.

591
00:26:10,132 --> 00:26:12,090
그래서 실제로
추가적인 시간

592
00:26:12,090 --> 00:26:13,200
과 공간이 필요할 수 있습니다.

593
00:26:13,200 --> 00:26:16,450
이해가 되시나요?

594
00:26:16,450 --> 00:26:18,930
어쨌든, 그건
일종의 게으른 사람을 위한 그래프

595
00:26:18,930 --> 00:26:19,680
표현 방식입니다.

596
00:26:19,680 --> 00:26:22,260
코딩할 때 인접 행렬을 많이 사용하는데,

597
00:26:22,260 --> 00:26:23,160
다루기 쉽기 때문입니다.

598
00:26:23,160 --> 00:26:25,407
하지만 이렇게 하면
추가 공간이 많이 필요하고,

599
00:26:25,407 --> 00:26:27,240


600
00:26:27,240 --> 00:26:29,460
공간이 충분하더라도 이웃을
순회하는 데

601
00:26:29,460 --> 00:26:32,700

시간이 꽤 걸릴 수 있기 때문에 항상 가장 효율적인 방법은 아닙니다.

602
00:26:32,700 --> 00:26:35,250
네, 그럼
오늘 강의의 핵심은 그래프에서

603
00:26:35,250 --> 00:26:37,980


604
00:26:37,980 --> 00:26:39,900
우리 모두가 고민하는 대표적인 문제,

605
00:26:39,900 --> 00:26:43,383
즉 경로 계산, 특히
최단 경로 계산에 대해 소개하는 것입니다.

606
00:26:43,383 --> 00:26:45,300
그러므로 우리가 가장 먼저 해야 할 일은
당연히 그래프에서

607
00:26:45,300 --> 00:26:48,580
경로란 무엇인지 정의하는 것입니다
.  자,

608
00:26:48,580 --> 00:26:51,570
그럼
그래프를 도로망처럼 생각해 봅시다.

609
00:26:51,570 --> 00:26:54,660

여기 있는 모든 노드를 교집합이라고 생각해 봅시다.

610
00:26:54,660 --> 00:26:56,970
여기가 대략
켄달 스퀘어 근처입니다.

611
00:26:56,970 --> 00:26:59,520
보시다시피 정사각형입니다.  어쨌든

612
00:26:59,520 --> 00:27:04,050
, 예를 들어

613
00:27:04,050 --> 00:27:05,850


614
00:27:05,850 --> 00:27:08,970

정점 1에서 정점 3으로 가는 방법이 있는지 알아보고 싶다고 가정해 봅시다. 그러면 더 나은 질문은 정점 1에서 정점 3으로

615
00:27:08,970 --> 00:27:10,380


616
00:27:10,380 --> 00:27:12,870

가는 가장 빠른 방법이 있는지 알아보는 것이겠죠.

617
00:27:13,647 --> 00:27:15,480
물론, 가장
먼저 해야 할 일은 제가 찾아야 할

618
00:27:15,480 --> 00:27:16,440
대상을 정의하는 것입니다.  제가

619
00:27:16,440 --> 00:27:19,380

찾고 있는 것, 즉 경로를 정의했습니다.

620
00:27:19,380 --> 00:27:23,130
따라서 경로란
그래프에서

621
00:27:23,130 --> 00:27:26,280
인접한 정점 쌍이 모두

622
00:27:26,280 --> 00:27:27,560
간선이 되는 일련의 정점들의 순서에 지나지 않습니다.

623
00:27:27,560 --> 00:27:29,310
제 생각에는 이 모든 것이

624
00:27:29,310 --> 00:27:31,360
그래프에서 경로가 무엇인지에 대한 우리의 직관과 일치하는 것 같습니다.

625
00:27:31,360 --> 00:27:35,370
예를 들어,
경로 p는 v1, v2, v3와 같습니다.

626
00:27:35,370 --> 00:27:38,310
보시다시피
v1에서 v2로 가는 간선이 있고,

627
00:27:38,310 --> 00:27:40,020
v2에서 v3로 가는 간선도 있습니다.

628
00:27:40,020 --> 00:27:45,600
따라서 이는
우리의 정의에서 제시된 가정을 충족합니다.

629
00:27:45,600 --> 00:27:47,370

우리 그래프에서 경로가 아닌 것은

630
00:27:47,370 --> 00:27:51,900
v1 쉼표 v3과 같은 것입니다.
왜냐하면 거기에 간선이 없기 때문입니다.  네

631
00:27:51,900 --> 00:27:55,110
, 경로에 대해 이야기할 때
, 길이라는

632
00:27:55,110 --> 00:27:58,407
개념이 아주 자연스럽게 떠오릅니다
.

633
00:27:58,407 --> 00:28:00,990
길이는 경로상의
정점 수에서

634
00:28:00,990 --> 00:28:03,870
1을 뺀 값,
또는 경로가 지나가는 간선의 수와 같다고 생각하면 될 것 같습니다

635
00:28:03,870 --> 00:28:05,100
.

636
00:28:05,100 --> 00:28:06,960
둘은 같은 것입니다.  예를 들어

637
00:28:06,960 --> 00:28:10,485
,
여기서 경로 p의 길이는 2입니다.

638
00:28:10,485 --> 00:28:12,360
모두 이해하셨나요?

639
00:28:12,360 --> 00:28:14,970

제가 자주 접하는 아주 흔한 코딩 오류는 실수로

640
00:28:14,970 --> 00:28:18,750
해당 숫자에 1을 더하는 것입니다
.

641
00:28:18,750 --> 00:28:21,310
당연히
경로상의 정점 수가 간선 수보다 하나 더 많기 때문입니다

642
00:28:21,310 --> 00:28:23,690
.

643
00:28:23,690 --> 00:28:25,730
네, 그리고
다양한 경로가 존재합니다.

644
00:28:25,730 --> 00:28:28,512


645
00:28:28,512 --> 00:28:29,720
어떤 두 정점 사이에도 잠재적으로 하나 이상의 경로가 있을 수 있습니다.

646
00:28:29,720 --> 00:28:33,470
예를 들어 다음과 같은
무방향 그래프가 있다고 가정해 보겠습니다

647
00:28:33,470 --> 00:28:35,100
.

648
00:28:35,100 --> 00:28:37,880
그러니까
정사각형에 대각선을 더한 것과 같다는 거죠.  자,

649
00:28:37,880 --> 00:28:39,365
여기에 노드들이 있습니다.

650
00:28:42,110 --> 00:28:44,600
그렇다면 왼쪽 아래에서 오른쪽 위로 가는 완벽하게 유효한
경로는 옆으로 한 칸

651
00:28:44,600 --> 00:28:47,758

이동한 다음 위로 한 칸 이동하는 것이지만,

652
00:28:47,758 --> 00:28:49,550
물론 왼쪽 아래에서 오른쪽 위로 가는
더 효율적인 방법은

653
00:28:49,550 --> 00:28:51,717


654
00:28:51,717 --> 00:28:54,667
대각선으로 이동하는 것입니다.

655
00:28:54,667 --> 00:28:56,500
따라서
최단 경로란

656
00:28:56,500 --> 00:28:57,875


657
00:28:57,875 --> 00:28:59,920


658
00:28:59,920 --> 00:29:05,290

그래프에서 임의의 두 정점 사이의 간선 또는 정점의 수가 가장 적은 경로의 길이를 의미합니다.

659
00:29:05,290 --> 00:29:06,460
자, 그럼 이 녀석이 우리의 적입니다.

660
00:29:06,460 --> 00:29:07,502
이것이 바로 우리가 추구하는 바입니다.

661
00:29:07,502 --> 00:29:11,690

그래프에서 정점들 사이의 최단 경로를 계산하는 것입니다.

662
00:29:11,690 --> 00:29:14,260
그리고 이것이 바로
우리가 이

663
00:29:14,260 --> 00:29:15,135
강좌에서 꽤 많이 다룰 내용입니다.

664
00:29:15,135 --> 00:29:17,135
당연히
매우 현실적인 문제이기 때문입니다.

665
00:29:17,135 --> 00:29:19,180
예를 들어
라우팅 문제를 해결하고 네트워크에서

666
00:29:19,180 --> 00:29:20,900
패킷을 이동시키고 싶을 때
,

667
00:29:20,900 --> 00:29:23,350

Tor를 사용하는 경우가 아니라면

668
00:29:23,350 --> 00:29:27,040

중간에 너무 많은 컴퓨터를 거치지 않도록 하고 싶습니다.

669
00:29:27,040 --> 00:29:28,990
그렇다면
컴퓨터가 알려주는 최단 경로가 필요할지도 모르겠네요.

670
00:29:28,990 --> 00:29:33,910
혹은 표면적으로는
정보를 너무 멀리 이동시키지 않는 방식으로 전달하고 싶을 수도 있습니다

671
00:29:33,910 --> 00:29:36,190

.

672
00:29:36,190 --> 00:29:38,140
하지만 물론

673
00:29:38,140 --> 00:29:40,990

최단 경로

674
00:29:40,990 --> 00:29:42,870
또는
경로의 존재 자체에 대해 이야기할 때에는 그 주제에 대한 다양한 변형이 존재합니다.

675
00:29:42,870 --> 00:29:44,980
이것들은

676
00:29:44,980 --> 00:29:47,480
우리가 그래프 상에서 해결할 수 있는 세 가지 유형의 모델 문제입니다.

677
00:29:47,480 --> 00:29:50,090
첫 번째는,
물론 여기서는 '

678
00:29:50,090 --> 00:29:52,360
단일
쌍 도달 가능성'이라고 부르는 것인데,

679
00:29:52,360 --> 00:29:54,310


680
00:29:54,310 --> 00:29:58,720
그래프 g에서 두 정점 s와 t가 있을 때,

681
00:29:58,720 --> 00:30:01,794
s와 ​​t 사이에 경로가 존재하는지 묻는 것입니다.

682
00:30:01,794 --> 00:30:04,010
그렇다면

683
00:30:04,010 --> 00:30:07,670
이 문제가
항상 '

684
00:30:07,670 --> 00:30:09,265
예'라는 답을 주지 않는 극단적인 예는 무엇일까요?  우리는

685
00:30:09,265 --> 00:30:11,390
머릿속으로
모든 그래프가 서로

686
00:30:11,390 --> 00:30:13,250
연결되어 있다고 생각하는 경향이 있는 것 같습니다.

687
00:30:13,250 --> 00:30:15,840
하지만 우리가 정의한 방식대로라면 완벽하게 유효한 그래프는

688
00:30:15,840 --> 00:30:19,713

정점 10개에 간선이 없는 그래프일 것입니다.

689
00:30:19,713 --> 00:30:21,380


690
00:30:21,380 --> 00:30:23,930
만약
당신이 신경 쓰는 그래프가 그것 하나뿐이라면, 이 함수는 코딩하기가 매우 쉬울 것입니다.

691
00:30:23,930 --> 00:30:26,560
하지만 어떤 경우든
경로의 존재 여부 자체가

692
00:30:26,560 --> 00:30:28,310

약간의

693
00:30:28,310 --> 00:30:29,310
알고리즘적 사고를 필요로 하는 질문입니다.

694
00:30:29,310 --> 00:30:32,950
우리는
아직 그 방법을 알아내지 못했습니다.

695
00:30:32,950 --> 00:30:35,450
이제 우리가 해결할 수 있는 또 다른 문제는
최단 경로입니다.

696
00:30:35,450 --> 00:30:37,670
그래프와
두 개의 정점이 주어졌을 때, 두 정점 사이의

697
00:30:37,670 --> 00:30:41,150


698
00:30:41,150 --> 00:30:43,910
최단 거리를 구하려면 두 정점 사이의 거리는 얼마나 될까요?  두 번째

699
00:30:45,650 --> 00:30:49,250

문제를 이용하여 첫 번째 문제를 해결할 수 있다는 점에 주목하세요.

700
00:30:49,250 --> 00:30:51,200


701
00:30:51,200 --> 00:30:55,600
두 정점 사이에 경로가 없을 때, 두 정점 사이의 최단 경로 길이는 얼마일까요
?

702
00:30:55,600 --> 00:30:57,700
무한대라고 하거나 어깨를 으쓱하는 것, 둘 다

703
00:30:57,700 --> 00:30:58,720
완전히 타당한 답변이죠.

704
00:30:58,720 --> 00:31:00,730
네, 맞아요.

705
00:31:00,730 --> 00:31:03,760
그렇다면
접근성 코드를 어떻게 구현할 수 있을까요?

706
00:31:03,760 --> 00:31:05,680
음,
최단 경로 코드를 호출하면

707
00:31:05,680 --> 00:31:07,030
무한대가 나옵니다.

708
00:31:07,030 --> 00:31:08,990
그러면 저는 "아니요,
연결할 수 없습니다."라고 답장합니다.

709
00:31:08,990 --> 00:31:12,250
그리고 만약 그것이 내게 무한대를 주지 않는다면
, 나는 '예'라고 답할 것이다.

710
00:31:12,250 --> 00:31:14,917
그러니
알고리즘 수업에서 핵심 개념 중 하나가 바로

711
00:31:14,917 --> 00:31:16,000
환원이라는 점을 기억하세요.

712
00:31:16,000 --> 00:31:19,190
하나의 함수를 사용하여
다른 함수를 해결할 수 있다는 것입니다.

713
00:31:19,190 --> 00:31:21,260
따라서
최단 경로를 찾을 수 있다면

714
00:31:21,260 --> 00:31:23,890


715
00:31:23,890 --> 00:31:26,620
해당 코드를 호출하여 도달 가능성 문제를 확실히 해결할 수 있습니다.

716
00:31:26,620 --> 00:31:30,130
그리고 마지막으로
단일 출발점 최단

717
00:31:30,130 --> 00:31:30,730
경로에 대해 이야기해 볼 수 있겠습니다.  자,

718
00:31:30,730 --> 00:31:35,220
이제
입력 노드가 s 하나뿐이라는 것을 알 수 있습니다.

719
00:31:35,220 --> 00:31:37,020
이 문제는

720
00:31:37,020 --> 00:31:38,790

s에서

721
00:31:38,790 --> 00:31:42,493

그래프의 다른 모든 정점까지의 최단 경로 길이를 구하라는 것입니다.

722
00:31:42,493 --> 00:31:43,410
이해가 되시나요?

723
00:31:43,410 --> 00:31:46,230
예를 들어,
모든 정보, 즉

724
00:31:46,230 --> 00:31:49,690
최단 거리 하나하나를 담은 큰 배열을 반환할 수도 있습니다.

725
00:31:49,690 --> 00:31:52,650
그렇다면 단일 출발점 최단 경로를
사용하여 단일 쌍 최단 경로를 구할 수 있을까요

726
00:31:52,650 --> 00:31:56,120
?

727
00:31:56,120 --> 00:31:57,110
전적으로.

728
00:31:57,110 --> 00:32:01,580
단일
쌍 최단 경로 문제에서, s

729
00:32:01,580 --> 00:32:04,935
에서 다른 모든 지점까지의 최단 경로를 계산한

730
00:32:04,935 --> 00:32:07,560
다음,

731
00:32:07,560 --> 00:32:10,050
t까지의 최단 경로만 남기고 나머지 정보는 모두 버리면 문제가 해결됩니다.

732
00:32:10,050 --> 00:32:13,350
물론
이것이 두 번째 문제를 해결하는 가장 빠른

733
00:32:13,350 --> 00:32:14,760
방법이라는 것을 입증한 것은 아니지만,

734
00:32:14,760 --> 00:32:17,370
적어도
세 번째 문제를 해결할 수 있다면

735
00:32:17,370 --> 00:32:19,572
두 번째 문제도 해결할 수 있다는 것을 보여줍니다.

736
00:32:19,572 --> 00:32:21,780
두 번째 문제를 풀 수 있다면 첫 번째
문제도 풀 수 있습니다.

737
00:32:21,780 --> 00:32:24,030
오늘 강의에서는

738
00:32:24,030 --> 00:32:25,603

3번 문제만 다뤄보겠습니다.

739
00:32:25,603 --> 00:32:27,270
다시 말하면, 이러한
것들은 난이도

740
00:32:27,270 --> 00:32:31,390

순으로 나열되어 있다는 뜻입니다.

741
00:32:31,390 --> 00:32:34,810
자, 그럼
단일 출발점 최단 경로

742
00:32:34,810 --> 00:32:37,480
문제를 생각해 보기 위해
추가적인 구성을 하나 만들어 보겠습니다.

743
00:32:37,480 --> 00:32:41,530
이것은
최단 경로 트리라고 불리는 개념입니다.

744
00:32:41,530 --> 00:32:44,290

어제 새벽 2시에 파워포인트 슬라이드를 만드는 게 귀찮아져서

745
00:32:44,290 --> 00:32:48,230
대신
칠판에 그림을 그렸어요.

746
00:32:48,230 --> 00:32:52,940
그럼 그래프를 그려봅시다.

747
00:32:52,940 --> 00:32:56,140
자, 여기 a, b가 있습니다. 앞으로는 노드를 언급할 때 숫자 대신

748
00:32:56,140 --> 00:32:58,030
문자를 사용하겠습니다.

749
00:32:58,030 --> 00:33:01,330


750
00:33:01,330 --> 00:33:03,130

최단 경로의 길이

751
00:33:03,130 --> 00:33:06,440
와 노드의 인덱스를 혼동하고 싶지 않기 때문입니다.

752
00:33:06,440 --> 00:33:08,320
자, 여기 a, b, c가 있습니다. 제 메모와

753
00:33:08,320 --> 00:33:10,320
맞춰볼게요.

754
00:33:10,320 --> 00:33:14,725
d, e, f도 있습니다.

755
00:33:17,310 --> 00:33:19,815
여기 그래프가 하나 있습니다. 이것도
무방향 그래프인데,

756
00:33:19,815 --> 00:33:22,440
교수님이
무방향 그래프에 대해 생각하는 걸 좋아하시기 때문입니다.

757
00:33:22,440 --> 00:33:24,232
하지만

758
00:33:24,232 --> 00:33:26,110
나중에 내가 그렇게 하면 안 됐다는 피드백을 받을 거라는 걸 알고 있어요.

759
00:33:26,110 --> 00:33:27,570
어쨌든, A에서

760
00:33:27,570 --> 00:33:29,820


761
00:33:29,820 --> 00:33:31,535
다른 모든 지점까지의 최단 경로, 또는 그 길이를 계산하고 싶다고 가정해 봅시다.

762
00:33:31,535 --> 00:33:33,910
우선,
알고리즘에 대해 이야기하지 않더라도, 이것이 무엇인지 짐작하기는 꽤

763
00:33:33,910 --> 00:33:35,785
쉬울 거라고 생각합니다
.

764
00:33:35,785 --> 00:33:39,240
그러므로
a에서 a까지의 최단 경로는 길이가 0임이 분명합니다.

765
00:33:39,240 --> 00:33:42,360
a에서
b까지의 최단 경로는 1이고, a에서 c까지의 최단 경로는 2입니다.

766
00:33:42,360 --> 00:33:43,920
왜냐하면 저는 이 사람들을 따라갈 수 있기 때문입니다.

767
00:33:43,920 --> 00:33:45,040
이제부터 상황이 복잡해집니다.

768
00:33:45,040 --> 00:33:47,250
그것은 갈라졌다.

769
00:33:47,250 --> 00:33:52,695
다음으로 짧은 경로는
길이가 3이고, 그 다음은 4입니다.

770
00:33:52,695 --> 00:33:54,570


771
00:33:54,570 --> 00:33:56,653
제가 여기에 표시해 둔 숫자들이

772
00:33:56,653 --> 00:33:58,590
A에서 다른 모든 지점까지의 최단 경로 길이라는 데 모두 동의하시나요?

773
00:34:01,520 --> 00:34:03,880
하지만 내가 하지 않은 일이 무엇이 있겠습니까?

774
00:34:03,880 --> 00:34:06,430
저는 여러분에게
경로를 실제로 계산하는 방법을 알려드린 것이 아니라, 단지

775
00:34:06,430 --> 00:34:09,730

경로의 길이만 알려드린 것입니다.

776
00:34:09,730 --> 00:34:12,340
따라서 저는

777
00:34:12,340 --> 00:34:15,550
단일 출발점
최단 경로 길이를 계산하는 것 외에도

778
00:34:15,550 --> 00:34:19,989
단일
출발점 최단 경로를 계산하는 코드가 필요할 수 있습니다.

779
00:34:19,989 --> 00:34:22,460
처음에
그 생각을 하면,

780
00:34:22,460 --> 00:34:25,420


781
00:34:25,420 --> 00:34:28,060
그 모든 경로를 저장할 수 있는 데이터 구조를 어떻게 작성해야 할지조차 막막할 수 있습니다.

782
00:34:28,060 --> 00:34:31,060
모든 경로
에는 v개의 정점이 있을 수 있잖아요.

783
00:34:31,060 --> 00:34:33,255

어떤 이유에서인지

784
00:34:33,255 --> 00:34:34,880

제 그래프에 분기가 많이 생겨 있을 수도 있습니다.

785
00:34:34,880 --> 00:34:36,730
그리고 모든 길이
엄청나게 길어요.

786
00:34:36,730 --> 00:34:38,409
사실,

787
00:34:38,409 --> 00:34:40,929
가지치기를 하면 길이가 더 길어질
지 짧아질지 생각해 봐야 할 것 같아요.

788
00:34:40,929 --> 00:34:44,415
하지만 어쨌든,

789
00:34:44,415 --> 00:34:45,790

모든 정점에 대해

790
00:34:45,790 --> 00:34:51,570

a에서 해당 정점까지의 최단 경로를 추적하는 아주 지루한 데이터 구조를 만들 수도 있습니다.

791
00:34:51,570 --> 00:34:54,210
그
데이터 구조는 얼마나 클까요?

792
00:34:54,210 --> 00:34:56,730
만약 경로 길이에 대한 유일한 제약 조건이

793
00:34:58,215 --> 00:35:02,010

그래프의 모든 정점을 거쳐야 한다는 것이라면,

794
00:35:02,010 --> 00:35:04,750
어떤 경로든
v 공간을 차지하게 될 것입니다.

795
00:35:04,750 --> 00:35:07,700
그러면
총 v²만큼의 공간이 필요하게 됩니다.

796
00:35:07,700 --> 00:35:08,930
그건 별로 좋지 않을 거예요.

797
00:35:08,930 --> 00:35:11,450
어쩐지 지금
제 그래프에 있는 정보량이

798
00:35:11,450 --> 00:35:12,470
선형적인 형태를 띠고 있거든요.

799
00:35:12,470 --> 00:35:13,997
단순히
경로의 길이 차이일 뿐입니다.

800
00:35:13,997 --> 00:35:15,830
내가
그 길을 실제로 재구성하고 싶다면,

801
00:35:15,830 --> 00:35:18,650
처음에는 정신적으로 훨씬

802
00:35:18,650 --> 00:35:20,242
더 많은 공간이 필요할 것 같다는 생각이 들어요.

803
00:35:20,242 --> 00:35:21,950
하지만
사실 우리는 그렇지 않습니다.

804
00:35:21,950 --> 00:35:23,480
우리는
선형 공간만 필요하며,

805
00:35:23,480 --> 00:35:25,490
이를 위해

806
00:35:25,490 --> 00:35:26,740
최단 경로 트리라는 객체를 저장하는 아이디어가 있습니다.  예

807
00:35:26,740 --> 00:35:27,240
?

808
00:35:27,240 --> 00:35:33,823
청중: [알아들을 수 없는 부분]
이전 [알아들을 수 없는 부분] 때문에...

809
00:35:33,823 --> 00:35:35,990
저스틴 솔로몬:
질문은 재귀에 관한 것이었습니다.

810
00:35:35,990 --> 00:35:38,240
사실 우리는
그래프 알고리즘을 따로 적어놓지 않았습니다.

811
00:35:38,240 --> 00:35:41,105
그래서
실제로 재귀 호출을 할 때까지 그 부분은 보류하겠습니다.

812
00:35:41,105 --> 00:35:42,980
그런 다음 좀
더 신중하게 생각해 보겠습니다.

813
00:35:42,980 --> 00:35:45,410
네, 하지만 아주
타당한 질문입니다.

814
00:35:45,410 --> 00:35:47,810
재귀적인
그래프 알고리즘은 많이 있습니다.

815
00:35:47,810 --> 00:35:50,500
그러면 우리는 확실히

816
00:35:50,500 --> 00:35:51,500
아주 신중하게 세어야 할 거예요.

817
00:35:54,480 --> 00:35:57,990
네, 그래서 우리는 대신

818
00:35:57,990 --> 00:35:59,250
최단 경로 트리라는 객체를 정의할 겁니다.  여기서

819
00:35:59,250 --> 00:36:01,810
핵심은 "

820
00:36:01,810 --> 00:36:04,550
어떻게 A에서 C로 갔지?"라고 묻는 것입니다.

821
00:36:04,550 --> 00:36:08,990
음,

822
00:36:08,990 --> 00:36:10,290
최단 경로에는 항상 그 이전의 정점이 존재합니다.

823
00:36:10,290 --> 00:36:12,960
최단 경로에는
정말 멋진 속성이 하나 있는데, 바로

824
00:36:12,960 --> 00:36:16,790

a에서 c까지의 최단 경로를 잘라내면(

825
00:36:16,790 --> 00:36:19,990
즉, a에서 b를 거쳐 c로 가면) 그

826
00:36:19,990 --> 00:36:23,140
잘라낸 경로가

827
00:36:23,140 --> 00:36:24,515
이전 정점으로 가는 최단 경로와 같다는 것입니다.  자,

828
00:36:24,515 --> 00:36:26,140
그럼 그 문장에 대해 좀 더 생각해 봅시다.

829
00:36:26,140 --> 00:36:27,970
왜냐하면 그 문장은 늘 그렇듯

830
00:36:27,970 --> 00:36:29,530
강사님이 제대로 표현하지 못했기 때문입니다.

831
00:36:29,530 --> 00:36:31,930
예를 들어,

832
00:36:31,930 --> 00:36:38,800
a에서 d까지 가는 최단 경로가
a, b, c, d라고 가정해 봅시다.

833
00:36:38,800 --> 00:36:40,540
우리 모두 동의할 수 있을 거라고 생각합니다.

834
00:36:40,540 --> 00:36:42,820
그리고 이제 저는 이런
하위 목록을 만들어 봤어요.

835
00:36:42,820 --> 00:36:45,310
저는 그냥 A부터 C까지 순서대로 봐요.

836
00:36:45,310 --> 00:36:47,020


837
00:36:47,020 --> 00:36:53,270
이것이 A에서 C까지의 최단 경로가 아니
거나, 최단 경로가 아닌 경우가 있을까요?

838
00:36:53,270 --> 00:36:56,750
아니요, 만약 a에서 c까지
더 짧은 경로가 있다면

839
00:36:56,750 --> 00:36:59,930
,
그 경로를 여기에 연결해서

840
00:36:59,930 --> 00:37:02,636

a에서 d까지 최단 경로를 찾을 수 있을 테니까요.

841
00:37:02,636 --> 00:37:04,670
보이시나요?

842
00:37:04,670 --> 00:37:06,920
그러므로 그러한
추론에 따라,

843
00:37:06,920 --> 00:37:10,000

최단 경로의 거대한 집합을 나열하는 대신,

844
00:37:10,000 --> 00:37:11,750

어떤 의미에서는

845
00:37:11,750 --> 00:37:15,290
재귀적인 제안을 적용하는 대신,

846
00:37:15,290 --> 00:37:19,832

최단 경로에서 내 앞에 있는 하나의 정점만 생각하면 됩니다.

847
00:37:19,832 --> 00:37:21,040
저는 역추적해 보겠습니다.

848
00:37:21,040 --> 00:37:22,730
그럼
여기 그래프를 한번 살펴볼까요?

849
00:37:25,667 --> 00:37:27,750
기본적으로
제가 추적하려는 대상은

850
00:37:27,750 --> 00:37:30,130
이전 담당자와 같은 존재입니다.

851
00:37:30,130 --> 00:37:34,210
그렇다면
최단 경로상에서 f의 선행자는 무엇일까요?

852
00:37:34,210 --> 00:37:35,620
사실 답은 d 아니면 e입니다.

853
00:37:35,620 --> 00:37:37,460
이 경우에는 상관없습니다.

854
00:37:37,460 --> 00:37:42,690
어쩌면 그 전의 단어는
재미를 뜻하는 'e'일지도 모르겠네요.  '

855
00:37:42,690 --> 00:37:44,040
e'의 전신은 무엇인가요?

856
00:37:44,040 --> 00:37:47,160
음,
최단 경로상의 이전 정점은 분명히

857
00:37:47,160 --> 00:37:49,260
c입니다.

858
00:37:49,260 --> 00:37:54,540
마찬가지로 d의 경우에도 이제
b와 a, 그리고

859
00:37:54,540 --> 00:37:56,640
이 방향을 가리키는 여러 개의 화살표가 있습니다.

860
00:37:56,640 --> 00:37:58,092
그래서 각 정점마다

861
00:37:58,092 --> 00:38:00,300


862
00:38:00,300 --> 00:38:01,270
최단 경로상의 이전 정점을 가리키는 화살표를 시작할 겁니다.  최단

863
00:38:01,270 --> 00:38:03,480

경로 전체를 저장하는 것이 아니라,

864
00:38:03,480 --> 00:38:06,370
마지막 간선만 저장할 것입니다.

865
00:38:06,370 --> 00:38:10,530
우선,
이 제품은 저장 공간을 얼마나 차지하나요?

866
00:38:10,530 --> 00:38:11,663
v 공간을 차지합니다.

867
00:38:11,663 --> 00:38:12,330
보이시나요?

868
00:38:12,330 --> 00:38:14,220
또는
꼭짓점 공간의 크기.

869
00:38:14,220 --> 00:38:16,570
각 정점은

870
00:38:16,570 --> 00:38:20,642

최단 경로상의 이전 정점이라는 단 한 가지 정보만 저장하면 되기 때문입니다.

871
00:38:20,642 --> 00:38:22,850
그렇다면
최단 경로 추적 알고리즘은 어떻게 작동할까요?

872
00:38:22,850 --> 00:38:23,850
정말 간단해요.

873
00:38:23,850 --> 00:38:25,940
나는 그냥
이 가장자리를 따라 계속 걸어가다가 다시

874
00:38:25,940 --> 00:38:29,208

a 지점으로 돌아오곤 한다.

875
00:38:29,208 --> 00:38:31,250
이제 이 객체를
최단 경로 트리라고 부릅니다.  제가

876
00:38:31,250 --> 00:38:35,060
슬쩍 '나무'라는 단어를 하나 더 넣었다는 걸 눈치채셨나요?

877
00:38:35,060 --> 00:38:35,630
왜 그런가요?

878
00:38:35,630 --> 00:38:38,612

이 그래프에 주기적인 패턴이 나타날 수 있을까요?

879
00:38:38,612 --> 00:38:40,320
그건
전혀 말이 안 되잖아요, 그렇죠?

880
00:38:40,320 --> 00:38:41,320
이것이 최단 경로입니다.

881
00:38:41,320 --> 00:38:43,570

그라디언트를 따라

882
00:38:43,570 --> 00:38:46,450
원래 정점으로 되돌아갈 수 있을 겁니다.

883
00:38:46,450 --> 00:38:51,460
네, 그러니까
제 그래프에

884
00:38:51,460 --> 00:38:52,570
한 가지 요소를 더 추가해서 꾸미겠다는 뜻입니다.

885
00:38:52,570 --> 00:38:55,960
우리는 이것을 출발점에서 최종 정점 v까지의 최단 경로상의 이전 정점인 p of v라고 부르겠습니다

886
00:38:55,960 --> 00:39:00,590

. 제가

887
00:39:00,590 --> 00:39:02,972

오늘 여러분께 주장하려고 했던 것은,

888
00:39:02,972 --> 00:39:04,430

이 정보만 있으면

889
00:39:04,430 --> 00:39:06,763

최단 경로를 재구성하기에 충분하다는 것입니다.

890
00:39:06,763 --> 00:39:10,190
저는 계속해서 v의 p를 취하고
, 그다음 v의 p의 p를 취하고,

891
00:39:10,190 --> 00:39:12,230
그다음 v의 p의 p의 p를 취하는 식으로 계속 진행합니다. 말로는

892
00:39:12,230 --> 00:39:14,330

복잡해 보이지만, 결국

893
00:39:14,330 --> 00:39:17,010

처음 정점으로 되돌아갑니다.

894
00:39:17,010 --> 00:39:20,368
그리고 이 객체는 개념적으로
최단 경로 트리라고 불립니다.  궁금한 점 있으신가요

895
00:39:20,368 --> 00:39:21,410
?  예

896
00:39:23,930 --> 00:39:25,106
?

897
00:39:25,106 --> 00:39:28,045
청중: [잘 안 들림]

898
00:39:28,045 --> 00:39:30,925
저스틴 솔로몬: 만약
a와 d를 연결하는 모서리가 있다면, 괜찮을 텐데요.

899
00:39:30,925 --> 00:39:36,980
청중: [잘 안 들림]

900
00:39:36,980 --> 00:39:39,680
저스틴 솔로몬: 아, 네.
질문은, 여기 계신

901
00:39:39,680 --> 00:39:44,600
동료분이 좀 더
날카로운 의견을 제시했다고 가정해 봅시다. 정말

902
00:39:44,600 --> 00:39:47,840
좋은 질문입니다.

903
00:39:47,840 --> 00:39:51,410
누군가 악의적이었어요.
제 적대적 신경망이 악의적으로

904
00:39:51,410 --> 00:39:53,810
여기에 엉뚱한 부분을 넣어놨어요.

905
00:39:53,810 --> 00:39:56,580
최단
경로 코드가 실패하도록 만들고 싶었던 거죠.

906
00:39:56,580 --> 00:40:01,250
그런데 어쩐 일인지 제가
당신에게 보여드렸던 나무 그림이 더 이상 정확하지 않네요.

907
00:40:01,250 --> 00:40:03,440
제 대답은 '예'입니다.

908
00:40:03,440 --> 00:40:04,070
왜 그런가요?

909
00:40:04,070 --> 00:40:07,580
음, 여기에 모서리를 추가하니
최단 경로의 길이가

910
00:40:07,580 --> 00:40:08,450
바뀌었네요.

911
00:40:08,450 --> 00:40:10,927

이제 a에서 d까지의 최단 경로는 1입니다.

912
00:40:10,927 --> 00:40:12,260
따라서 이 트리는 더 이상 유효하지 않습니다.

913
00:40:12,260 --> 00:40:14,120
새 나무가 필요해요.

914
00:40:14,120 --> 00:40:19,120
그렇다면
여기서 d의 이전 p는 무엇일까요?

915
00:40:19,120 --> 00:40:22,720
음,
c보다는 a가 더 맞을 것 같네요.

916
00:40:22,720 --> 00:40:24,230
네, 전적으로 맞습니다.

917
00:40:24,230 --> 00:40:27,580
그리고 이는 실제로

918
00:40:27,580 --> 00:40:31,150
최단 경로의 매우 성가신 속성을 반영하는데,
그래프에 간선을 하나 추가하면 모든 정점까지의

919
00:40:31,150 --> 00:40:34,030
최단 경로 길이가
바뀔 수 있다는 것입니다.

920
00:40:34,030 --> 00:40:37,330
음,
소스 정점을 제외하면 그렇다고 생각해요.

921
00:40:37,330 --> 00:40:41,140
네, 그리고 그건

922
00:40:41,140 --> 00:40:42,170
특정 응용 분야에서 실제로 큰 골칫거리입니다.

923
00:40:42,170 --> 00:40:44,980
예를 들어, 이제
응용 분야 이야기는 그만하고

924
00:40:44,980 --> 00:40:47,020
다시 수학 이야기로 돌아가자면,

925
00:40:47,020 --> 00:40:48,880
저는 3D 모델링 작업을 많이 합니다.

926
00:40:48,880 --> 00:40:51,730
그리고
발레리나 같은 사람들의 3D 모델로 이루어진 방대한 데이터 세트가 있습니다.

927
00:40:51,730 --> 00:40:54,105
발레리나들은
가끔씩 저렇게 손을 모으는 버릇 때문에 정말 짜증나요

928
00:40:54,105 --> 00:40:55,580

.

929
00:40:55,580 --> 00:40:58,540
그러다 갑자기
손가락 사이의 최단 경로가

930
00:40:58,540 --> 00:41:02,770
온몸에서 0으로 바로 이어지게 됩니다.

931
00:41:02,770 --> 00:41:05,860
따라서
최단 경로를 계산하는 점진적 알고리즘은

932
00:41:05,860 --> 00:41:06,940
이런 경우에 제대로 작동하지 못할 수 있습니다.

933
00:41:06,940 --> 00:41:08,890


934
00:41:08,890 --> 00:41:11,975
만약 제가 실수로
손가락을 붙여버렸다면, 모든 걸 업데이트해야 하니까요.  자, 그럼 이제

935
00:41:11,975 --> 00:41:13,600


936
00:41:13,600 --> 00:41:14,725
여러분이 그 문제를 어떻게 해결할지 생각해 보세요.

937
00:41:14,725 --> 00:41:17,380
더 자세히 알고 싶으시면
6.838을 참고하세요.  예

938
00:41:17,380 --> 00:41:18,226
?

939
00:41:18,226 --> 00:41:19,862
청중: [알아들을 수 없음].

940
00:41:19,862 --> 00:41:21,820
저스틴 솔로몬:
소스 노드를 변경하면

941
00:41:21,820 --> 00:41:23,120
가능한 가장 짧은
변경 사항이 다시 적용됩니다.

942
00:41:23,120 --> 00:41:25,310
네, 그래서 이건
정말 지루한 설명이 될 것 같은데,

943
00:41:25,310 --> 00:41:26,240


944
00:41:26,240 --> 00:41:28,440

제 문제에서 어떤 부분을 바꾸든, 예를 들어

945
00:41:28,440 --> 00:41:30,440
출발점을 바꾸거나,
연결선을 바꾸면,

946
00:41:30,440 --> 00:41:32,580

모든 최단 경로를 다시 계산해야 합니다.

947
00:41:32,580 --> 00:41:36,570
물론 그런 방식을 사용하지 않는 알고리즘도 존재합니다
.

948
00:41:36,570 --> 00:41:38,600
하지만 우리는
아직 그것들에 대해 생각하지 않을 겁니다.

949
00:41:38,600 --> 00:41:39,710
좋아요.  늘

950
00:41:39,710 --> 00:41:41,230
그렇듯 제가
너무 말을 많이 해서 정작

951
00:41:41,230 --> 00:41:43,220


952
00:41:43,220 --> 00:41:45,860

강의에서 흥미로운 알고리즘을 설명하는 데 10분 정도밖에 남지 않았네요.

953
00:41:46,467 --> 00:41:48,550
사실
그렇게 복잡한 알고리즘은 아니니까

954
00:41:48,550 --> 00:41:50,120
괜찮을 것 같아요. 바로

955
00:41:50,120 --> 00:41:52,288

최단 경로를 계산하는 방법이죠.

956
00:41:52,288 --> 00:41:54,080
네, 그리고
우리가 하려는 기본적인 일은

957
00:41:54,080 --> 00:41:57,388

이 나무 비유를 바탕으로 하는 것입니다.

958
00:41:57,388 --> 00:41:59,930
우리가 정의할 객체 하나가 더 있는데
, 저는 이게 정말 마음에 들어요.

959
00:41:59,930 --> 00:42:02,305
사실
제이슨의 노트에서 이 부분을 봤는데

960
00:42:02,305 --> 00:42:04,730
미적분처럼 보여서 좋았어요.
제가 좋아하는 게 바로

961
00:42:04,730 --> 00:42:08,150

레벨 세트라는 개념이에요.

962
00:42:08,150 --> 00:42:11,060
그래서 이것은
L sub k라는 것들의 전체 집합입니다.

963
00:42:11,060 --> 00:42:13,715
그리고 이것들은 모두

964
00:42:13,715 --> 00:42:15,810
내 출발점에서 거리 k만큼 떨어진 정점들입니다.

965
00:42:15,810 --> 00:42:18,620
예를 들어,
이 예시에서 소스 정점이

966
00:42:18,620 --> 00:42:20,540

맨 왼쪽 정점이라면,

967
00:42:20,540 --> 00:42:24,230
L0에는 당연히
그 정점만 포함되겠죠.

968
00:42:24,230 --> 00:42:25,670
다음은 L1입니다.

969
00:42:25,670 --> 00:42:27,080
L2는 세 번째입니다.

970
00:42:27,080 --> 00:42:30,597
하지만 이제 L3는
세 개의 정점으로 이루어진 집합인데,

971
00:42:30,597 --> 00:42:32,680
그 이유는 이 세 정점이

972
00:42:32,680 --> 00:42:34,170
소스에서 3만큼 떨어진 모든 요소이기 때문입니다.

973
00:42:34,170 --> 00:42:36,630
제가
분홍색으로 표시해 둔 부분이 바로 그거예요.

974
00:42:36,630 --> 00:42:40,230
네,
이 표기법이 의미하는 바는 이게 전부입니다.

975
00:42:40,230 --> 00:42:42,840
아, 제가 약간 오타를 냈네요.
이 수업에서는 거리를 d가

976
00:42:42,840 --> 00:42:46,165
아니라 delta라고 써야 하는데
, 뭐 괜찮아요.

977
00:42:46,165 --> 00:42:47,040
청중: [잘 안 들림]

978
00:42:47,040 --> 00:42:48,180
저스틴 솔로몬:
최단 거리,

979
00:42:48,180 --> 00:42:49,200
बिल्कुल 맞습니다.

980
00:42:49,200 --> 00:42:51,283
예를 들어,

981
00:42:51,283 --> 00:42:52,390
L0에서 L2까지의 거리가 매우 멀 수 있죠.

982
00:42:52,390 --> 00:42:54,990

L0과 L1 사이를 왔다 갔다 하다가

983
00:42:54,990 --> 00:42:57,220
L4로 이동했다가 다시
돌아올 수도 있겠죠.

984
00:42:57,220 --> 00:43:00,040
하지만 그걸
계산하는 건 그다지 도움이 되지 않을 겁니다.

985
00:43:00,040 --> 00:43:01,040
그건 전적으로 맞습니다.  예

986
00:43:01,040 --> 00:43:02,286
?

987
00:43:02,286 --> 00:43:04,197
청중: [알아들을 수 없음].

988
00:43:04,197 --> 00:43:05,780
저스틴 솔로몬: 아,
빨간색 배경은

989
00:43:05,780 --> 00:43:10,515
집합 L을 나타냅니다. 예를 들어,
L3에는 왼쪽에서 거리가 3인 모든 요소가 포함되어 있으므로 이 세 개의 꼭짓점이 들어 있습니다

990
00:43:10,515 --> 00:43:12,140


991
00:43:12,140 --> 00:43:14,000
.

992
00:43:14,000 --> 00:43:17,930

어젯밤 늦게 도표를 그리다가 너무 과하게 공들여 그렸나 봐요.  전 그게

993
00:43:17,930 --> 00:43:19,800
꽤 자랑스러워요.

994
00:43:19,800 --> 00:43:24,140
네, 그러니까 기본적으로 맨

995
00:43:24,140 --> 00:43:27,350

왼쪽 끝에서

996
00:43:27,350 --> 00:43:29,590
다른 모든
정점까지의 최단 경로 길이를 계산하고 싶다면, 한 가지 방법은

997
00:43:29,590 --> 00:43:32,090

모든 레벨 세트를 계산한 다음 현재

998
00:43:32,090 --> 00:43:35,150
어떤
레벨 세트에 있는지 확인하는 것이죠.

999
00:43:35,150 --> 00:43:37,700
그래서 우리는 대략 그런 작업을 수행하는

1000
00:43:37,700 --> 00:43:40,940
너비 우선 탐색이라는 알고리즘을 소개하려고 합니다
.  오늘

1001
00:43:40,940 --> 00:43:42,680

우리가 소개할 너비 우선 탐색은

1002
00:43:42,680 --> 00:43:45,440


1003
00:43:45,440 --> 00:43:48,500
모든 레벨 집합 L
<sub>i</sub>를 계산하는 알고리즘이며, 이를 통해

1004
00:43:48,500 --> 00:43:50,120


1005
00:43:50,120 --> 00:43:52,740
최단 경로의 길이와 모양까지 구성할 수 있습니다.  이제 제가 손으로 쓴

1006
00:43:52,740 --> 00:43:55,350

메모를 보여드리겠습니다.

1007
00:43:55,350 --> 00:44:00,568
좋습니다, 그럼 이제 우리
알고리즘이 할 일을 설명드리겠습니다.

1008
00:44:00,568 --> 00:44:02,610


1009
00:44:02,610 --> 00:44:07,080
메모와
화면에 나와 있는 내용과는 약간 다르게 적겠습니다. 아주 조금만요.

1010
00:44:07,080 --> 00:44:10,530
우선,
우리 모두가 동의할 수 있는 한 가지는

1011
00:44:10,530 --> 00:44:12,150
레벨 세트 0,

1012
00:44:12,150 --> 00:44:15,200
아, 저건... 이
분필로 갈라진 선인데...

1013
00:44:15,200 --> 00:44:17,400
여기에는 노드가 하나 있다는 것입니다.

1014
00:44:17,400 --> 00:44:19,450
해당 노드는 무엇이어야 할까요?

1015
00:44:19,450 --> 00:44:22,120
소스 노드는 소스로부터
거리가 0인 유일한 요소이기 때문에

1016
00:44:22,120 --> 00:44:24,140

소스 노드가 소스입니다.

1017
00:44:28,750 --> 00:44:33,460
좋습니다. 그리고 그 외에도,

1018
00:44:33,460 --> 00:44:35,753
소스에서 자기 자신까지의 거리를 초기화할 수 있습니다.

1019
00:44:35,753 --> 00:44:37,420
모두 셋에 맞춰서,

1020
00:44:37,420 --> 00:44:38,560
음원에서 자기 자신까지의 거리는 얼마일까요? -

1021
00:44:38,560 --> 00:44:39,500
1, 2, 3.

1022
00:44:39,500 --> 00:44:40,117
관객: 0.

1023
00:44:40,117 --> 00:44:41,200
저스틴 솔로몬: 감사합니다.

1024
00:44:41,200 --> 00:44:43,790

이제 막 깨어났네요. 거의 11시,

1025
00:44:43,790 --> 00:44:44,290
12시쯤 됐어요.  지금

1026
00:44:44,290 --> 00:44:45,200
몇 시예요?

1027
00:44:45,200 --> 00:44:49,210
거의 12시네요. 좋아요,
그리고 마지막으로... 음,

1028
00:44:49,210 --> 00:44:50,830
처음에는

1029
00:44:50,830 --> 00:44:54,100
배열 p에 대해 아무것도 모르니까 그냥
비워두는 거죠.

1030
00:44:54,100 --> 00:44:56,545
출처의 p 값 때문에
어쩐지 상관없게 느껴집니다.

1031
00:44:56,545 --> 00:44:58,420

출발점으로 돌아오면

1032
00:44:58,420 --> 00:45:00,402

최단 경로 계산은 끝나는 거니까요.

1033
00:45:00,402 --> 00:45:02,110
그래서 우리는

1034
00:45:02,110 --> 00:45:06,310
모든 레벨 세트를 계산하고,
배열 p를 채우고,

1035
00:45:06,310 --> 00:45:08,380
거리 값을
모두 한 번에 입력하는 알고리즘을 작성할 것입니다.

1036
00:45:08,380 --> 00:45:11,040
우리는 이것을
너비 우선 탐색이라고 부를 것입니다.

1037
00:45:11,040 --> 00:45:12,080
좋아요, 그럼 그렇게 해봅시다.

1038
00:45:15,810 --> 00:45:17,785
그래서 우리는 여기서 표기법을 사용할 수 있습니다.

1039
00:45:17,785 --> 00:45:19,160
그리고
기본적으로

1040
00:45:19,160 --> 00:45:22,070
귀납적 추론이 진행되고 있다는 점에 주목하세요. 즉,

1041
00:45:22,070 --> 00:45:25,490
레벨 세트 0에서 레벨 세트 1을 계산하고,
레벨 세트 1에서 레벨 세트 2를 계산하는 식으로

1042
00:45:25,490 --> 00:45:28,560

모든 레벨 세트를 채울 때까지 계속 진행하는 것입니다.

1043
00:45:28,560 --> 00:45:30,250
이해가 되시나요?

1044
00:45:30,250 --> 00:45:34,080

같은 내용을 약간 다르게 표기하는 방법을 알려드리겠습니다.

1045
00:45:34,080 --> 00:45:35,580
저는
WHILE 루프를 사용할 건데,

1046
00:45:35,580 --> 00:45:39,540
약간
정통적인 방식은 아니지만 괜찮아요.

1047
00:45:39,540 --> 00:45:42,720
그래서 저는
숫자 i를 1로 초기화하겠습니다.

1048
00:45:42,720 --> 00:45:44,580
이것이
카운터 역할을 할 것입니다.

1049
00:45:44,580 --> 00:45:52,830
제가 말씀드리고 싶은 것은
이전 레벨 세트가 비어 있지 않다는 것입니다. 즉,

1050
00:45:52,830 --> 00:45:55,470


1051
00:45:55,470 --> 00:45:57,960

이전 레벨 세트를 거쳐

1052
00:45:57,960 --> 00:45:59,640
다음 레벨 세트로 이어지는 경로가 존재할 가능성이 있다는 뜻입니다.

1053
00:45:59,640 --> 00:46:02,340

내 레벨 중 하나가 비어 있으면,

1054
00:46:02,340 --> 00:46:04,845

더 큰 i에 대한 Li

1055
00:46:04,845 --> 00:46:05,970
도 마찬가지로 비어 있게 된다는 것을 알아두세요.

1056
00:46:05,970 --> 00:46:08,910

거리가

1057
00:46:08,910 --> 00:46:12,110
i가 아니라 i+5인 경우는 거의 없잖아요.

1058
00:46:12,110 --> 00:46:15,570
자, 그럼 이제 어떻게 해야 할까요
?

1059
00:46:15,570 --> 00:46:18,110
자, 그럼
우리가 봤던 그래프를 다시 떠올려 봅시다.

1060
00:46:23,040 --> 00:46:26,100
그러니까 이제 저는
이 사람이 0거리에 있다는 걸 알게 됐어요.

1061
00:46:26,100 --> 00:46:28,090
그게 제가 시작한 거예요.  자,

1062
00:46:28,090 --> 00:46:30,998
이제
이 정점의 모든 이웃을 살펴보겠습니다.

1063
00:46:30,998 --> 00:46:32,790
그리고 저는
그것들을 1만큼 떨어뜨려 놓을 거예요.

1064
00:46:32,790 --> 00:46:35,740
이해가 되시나요?

1065
00:46:35,740 --> 00:46:38,850
그리고 여기도 마찬가지로,
이 사람은 거리가 2입니다.

1066
00:46:38,850 --> 00:46:42,300
결국 저는
곤란한 상황에 처하게 될 텐데, 왜냐하면…

1067
00:46:42,300 --> 00:46:44,110
음,
좋은 예가 뭐가 있을까요?  저는

1068
00:46:44,110 --> 00:46:46,272
그림을 그려볼 생각조차 하지 않을 거예요.  서로

1069
00:46:46,272 --> 00:46:47,730


1070
00:46:47,730 --> 00:46:51,670

다른 레벨 세트에 동일한 정점을 두 번 추가하고 싶지 않다면 문제가 발생할 수 있습니다.

1071
00:46:51,670 --> 00:46:53,970
일단
Li에 넣었으면

1072
00:46:53,970 --> 00:46:56,190
Li+5에 넣고 싶지 않아요.
왜냐하면 이미

1073
00:46:56,190 --> 00:46:58,260
거리가 i만큼 떨어져 있다는 걸 알고 있기 때문이에요.

1074
00:46:58,260 --> 00:47:00,090
이해가 되시나요?

1075
00:47:00,090 --> 00:47:01,890
좋아요, 그럼 이제 제가 할 일은

1076
00:47:01,890 --> 00:47:04,720

이전에 만든 레벨

1077
00:47:04,720 --> 00:47:05,220
세트의 모든 정점을 순회하는 것입니다.

1078
00:47:09,680 --> 00:47:12,260
이제

1079
00:47:12,260 --> 00:47:15,512
u에 인접한 모든 꼭짓점을 살펴보겠습니다.

1080
00:47:15,512 --> 00:47:16,470
내가 뭘 알겠어?

1081
00:47:16,470 --> 00:47:19,520
내가
당신에게 도달하는 데 i-1걸음이 걸린다면,

1082
00:47:19,520 --> 00:47:24,310

당신의 이웃에게 도달하는 데는 총 몇 걸음이 걸릴까요?

1083
00:47:24,310 --> 00:47:26,710
i걸음이면

1084
00:47:26,710 --> 00:47:30,370
i에서 1을 뺀 길이의 경로를 따라갈 수 있고, 거기에
모서리 하나를 더하면

1085
00:47:30,370 --> 00:47:32,590
그 새로운 대상에게 도달할 수 있습니다.

1086
00:47:32,590 --> 00:47:35,000
그럼 제가 할 수 있는 일은 무엇일까요?

1087
00:47:35,000 --> 00:47:37,450


1088
00:47:37,450 --> 00:47:42,790
u의 인접 집합에 속하는 v의 모든 요소를 ​​순회할 수 있습니다.

1089
00:47:42,790 --> 00:47:45,310
하지만 혹시라도 불리한 상황에 놓이게 되면
어떡하지? 하는 생각에 조금 조심해야겠어요.  예를 들어

1090
00:47:46,510 --> 00:47:48,610
,
여기에는

1091
00:47:48,610 --> 00:47:50,560
소스로 되돌아가는 모서리가 있습니다.

1092
00:47:50,560 --> 00:47:52,260
제 생각엔 이건...

1093
00:47:52,260 --> 00:47:54,665
네, 타당한 예시네요.  저는

1094
00:47:54,665 --> 00:47:56,040


1095
00:47:56,040 --> 00:47:58,560

이미

1096
00:47:58,560 --> 00:48:01,080
이전 사용자가 소스를 추가했기 때문에 세 번째 레벨 세트에 소스를 추가하고 싶지 않습니다.

1097
00:48:01,080 --> 00:48:05,175
그래서 저는

1098
00:48:05,175 --> 00:48:06,300
이전의 모든 레벨 세트의 합집합을 없애고 싶습니다.

1099
00:48:11,416 --> 00:48:12,405
이해가 되시나요?

1100
00:48:12,405 --> 00:48:13,780
즉,

1101
00:48:13,780 --> 00:48:17,950


1102
00:48:17,950 --> 00:48:21,160
제 레벨 세트
계산 알고리즘에서는 아직 방문하지 않은 인접한 정점만 살펴볼 것입니다.

1103
00:48:21,160 --> 00:48:23,410
제가 할 일은
배열을 업데이트하는 것뿐이죠, 그렇죠?

1104
00:48:23,410 --> 00:48:32,230
특히, 아직 정점 v를 보지 못했기 때문에
정점 v를 레벨 세트 i에 추가하려고 합니다

1105
00:48:32,230 --> 00:48:34,450
.  현재 레벨 세트 i를 채우고 있으므로

1106
00:48:34,450 --> 00:48:43,030

s에서 v까지의 거리를 i로 설정하겠습니다

1107
00:48:43,030 --> 00:48:46,240

.

1108
00:48:46,240 --> 00:48:51,820
그리고 마지막으로 v의 p는 무엇입니까?  내 출발점에서

1109
00:48:51,820 --> 00:48:54,430

v까지의 최단 경로에서 v 바로 이전 정점은 무엇입니까

1110
00:48:54,430 --> 00:48:55,540
?

1111
00:48:58,420 --> 00:48:59,680
너 맞지?

1112
00:48:59,680 --> 00:49:01,810
왜냐하면 그 사람이 바로 제가 앞으로 나아가는 길을 만들어가고 있는 이전 레벨 세트에 나오는 그 사람이기 때문이죠

1113
00:49:01,810 --> 00:49:05,590

.

1114
00:49:05,590 --> 00:49:07,247
그걸 u로 설정할게요.

1115
00:49:07,247 --> 00:49:08,830
그리고 나서—죄송합니다,
공간이 부족해서 다 못 쓰겠네요—i 값

1116
00:49:08,830 --> 00:49:12,990
도 증가시켜야 합니다.

1117
00:49:12,990 --> 00:49:15,910
자, 그럼
이 알고리즘은 무슨 일을 하는 걸까요?  한 번에

1118
00:49:15,910 --> 00:49:17,880
한 레벨씩 만들어가는 과정입니다
.

1119
00:49:17,880 --> 00:49:21,930
다시 그림으로 돌아가서 보면, 먼저
L0을

1120
00:49:21,930 --> 00:49:25,110
소스 정점으로 초기화한 다음, 거기에서 나오는
모든 간선을 살펴봅니다.

1121
00:49:25,110 --> 00:49:27,210

이 경우에는 간선이 하나뿐이므로

1122
00:49:27,210 --> 00:49:29,190
그 길이를 1로 설정합니다

1123
00:49:29,190 --> 00:49:30,125
. 이런 식으로 계속 진행됩니다.

1124
00:49:30,125 --> 00:49:31,500
그래서 이것은

1125
00:49:31,500 --> 00:49:32,990

이러한 레벨 세트를 점진적으로 쌓아가는 과정입니다.

1126
00:49:32,990 --> 00:49:34,740
이제

1127
00:49:34,740 --> 00:49:37,350
이
알고리즘이 최단 경로를 계산하는 데 필요한 모든 정보인

1128
00:49:37,350 --> 00:49:40,140
L,
p, 델타를 정확하게 계산한다는 것을 귀납적으로 아주 간단하게 증명할 수 있습니다

1129
00:49:40,140 --> 00:49:43,890


1130
00:49:43,890 --> 00:49:44,490
.

1131
00:49:44,490 --> 00:49:46,448
제 생각에는 여러분이

1132
00:49:46,448 --> 00:49:49,800
아직
귀납적 증명 연습이 조금 더 필요하다면 수업 시간에 해보시면 될 것 같습니다

1133
00:49:49,800 --> 00:49:51,240
.

1134
00:49:51,240 --> 00:49:53,130
마지막으로
확인해야 할 것은

1135
00:49:53,130 --> 00:49:55,860

이 알고리즘의 실행 시간입니다.

1136
00:49:55,860 --> 00:49:59,800

마지막 순간에 억지로 끼워 넣겠습니다.

1137
00:49:59,800 --> 00:50:01,540
그럼 한번 살펴보겠습니다.

1138
00:50:01,540 --> 00:50:08,700
우선, 제가 알고리즘의 0단계에서 약간...
아, 괜찮아요...

1139
00:50:08,700 --> 00:50:10,298


1140
00:50:10,298 --> 00:50:12,840


1141
00:50:12,840 --> 00:50:14,490
정점의 개수와 같은 크기의 배열을 만들어야 했어요.

1142
00:50:14,490 --> 00:50:17,250
6.006 버전에서

1143
00:50:17,250 --> 00:50:19,853
메모리 할당에 얼마나 시간이 걸리는지 기억하시나요?

1144
00:50:19,853 --> 00:50:21,770
네,

1145
00:50:21,770 --> 00:50:24,590

할당한 메모리 용량에 비례해서 시간이 걸립니다.

1146
00:50:24,590 --> 00:50:27,180
스테프,
손은 보이는데 시간이 얼마 남지 않았어.

1147
00:50:27,180 --> 00:50:29,210
그래서 우리는 끝까지 가야 해요.

1148
00:50:29,210 --> 00:50:32,600

최단 경로

1149
00:50:32,600 --> 00:50:34,730
배열이 v 공간을 차지하기 때문에 이미 v 시간이 소요되었습니다.

1150
00:50:34,730 --> 00:50:39,500
하지만 그 외에도,

1151
00:50:39,500 --> 00:50:44,610
모든 노드에 대해 해당 노드의
모든 이웃 노드를 방문해야 하는 이상한 FOR 루프가 있습니다.

1152
00:50:44,610 --> 00:50:49,080
그런데 우선,
여기서 두 번 나타나는 노드를 본 적이 있나요?

1153
00:50:49,080 --> 00:50:52,260
아니요, 저는
거리 순서대로 가고 있기 때문입니다.

1154
00:50:52,260 --> 00:50:54,423
그리고
한 레벨 세트에 노드가 있는 것을 확인하는 순간

1155
00:50:54,423 --> 00:50:55,590
, 다른 레벨 세트에는 노드가 있을 수 없습니다.

1156
00:50:55,590 --> 00:50:58,830
이것이 바로 저희의 기본적인
구조입니다.

1157
00:50:58,830 --> 00:51:01,380
다행히도
여러분은 이미

1158
00:51:01,380 --> 00:51:03,060

우리가 필요로 하는 정확한 공식을 증명해냈습니다.

1159
00:51:03,060 --> 00:51:04,560
그리고 운이 좋다면,
추적하지 않았을 거예요.

1160
00:51:04,560 --> 00:51:06,900
네, 여기 있습니다.

1161
00:51:06,900 --> 00:51:09,630
자, 여기를 살펴보면,
이것이 바로

1162
00:51:09,630 --> 00:51:10,712
우리가 처한 상황입니다.

1163
00:51:10,712 --> 00:51:11,670
왜냐하면 우리가 무엇을 했기 때문이죠?

1164
00:51:11,670 --> 00:51:14,622
우리는
그래프의 모든 노드를 순회한

1165
00:51:14,622 --> 00:51:17,080
다음,
해당 노드들의 모든 이웃 노드를 순회했습니다.

1166
00:51:17,080 --> 00:51:18,705
그리고 그것이 우리 알고리즘의 기본적인
계산 시간입니다

1167
00:51:18,705 --> 00:51:20,950
.  제 코드에서

1168
00:51:20,950 --> 00:51:25,150
FOR 루프, 아니
정확히는 WHILE 루프는

1169
00:51:25,150 --> 00:51:29,510

엣지 수에 비례하는 시간을 소모합니다.

1170
00:51:29,510 --> 00:51:33,440
그렇다면 너비 우선 탐색의 총 실행 시간은 얼마일까요
?

1171
00:51:33,440 --> 00:51:36,980
그럼,
그 배열을 만들어야겠네요.

1172
00:51:36,980 --> 00:51:40,280
그러니까 0단계에서만
v 시간이 발생했습니다.

1173
00:51:40,280 --> 00:51:43,340
그런 다음

1174
00:51:43,340 --> 00:51:45,120
가장 많은 간선을 차지하는 항목을 순회해야 합니다.

1175
00:51:45,120 --> 00:51:54,813
따라서 우리 알고리즘은 전체적으로
mod v + mod e 시간 복잡도가 빅 O입니다.

1176
00:51:54,813 --> 00:51:56,730
자, 여기서 알아두셔야 할 점은,
이것이 다소 불필요해 보일 수도 있다는 것입니다

1177
00:51:56,730 --> 00:51:57,605
.

1178
00:51:57,605 --> 00:51:58,630
그런데 말이죠,

1179
00:51:58,630 --> 00:52:00,060
제가
제이슨과 약간의 이의가 있어요.

1180
00:52:00,060 --> 00:52:02,160
하지만 이 수업에서는

1181
00:52:02,160 --> 00:52:04,140


1182
00:52:04,140 --> 00:52:05,833
그래프를 저장하는 데 사용하는 공간에 대해 선형적인 시간이 걸리기 때문에 이 알고리즘을 선형 시간 알고리즘이라고 부르겠습니다.

1183
00:52:05,833 --> 00:52:07,500

개인적으로는 좀 수상하다고 생각하는데,

1184
00:52:07,500 --> 00:52:10,090
이 척도는
v에 대해 제곱으로 증가할 수 있기 때문이야

1185
00:52:10,090 --> 00:52:12,930
. 하지만 이야기가 옆길로 샜네.

1186
00:52:12,930 --> 00:52:19,210
어쨌든, 왜
이 두 용어가 모두 필요한 걸까요?

1187
00:52:19,210 --> 00:52:23,740
자, 만약
제 그래프에 간선이 하나도 없다면,

1188
00:52:23,740 --> 00:52:26,110
이 항이
지배적인 역할을 하게 될 거라는 점에 주목하세요.

1189
00:52:26,110 --> 00:52:28,870
하지만 그래프에 간선을 추가할수록
이 값은

1190
00:52:28,870 --> 00:52:30,470
v 제곱까지 올라갈 수 있습니다.

1191
00:52:30,470 --> 00:52:32,470
그래서 이 표현은 단순히 "

1192
00:52:32,470 --> 00:52:35,003

최악의 경우 이는 v 제곱 시간의 제곱이다"라고 말하는 것보다 훨씬 더 유익한 표현입니다.

1193
00:52:35,003 --> 00:52:35,920
이해가 되시나요?

1194
00:52:35,920 --> 00:52:38,290
약간 더 나은
공식이죠.

1195
00:52:38,290 --> 00:52:40,630
네, 그렇게 해서 우리는 간신히
결승선에 도착했습니다.

1196
00:52:40,630 --> 00:52:43,340
우리는
최단 경로를 계산하는 알고리즘을 가지고 있습니다.

1197
00:52:43,340 --> 00:52:46,980
그럼
화요일에 다시 뵙겠습니다.

