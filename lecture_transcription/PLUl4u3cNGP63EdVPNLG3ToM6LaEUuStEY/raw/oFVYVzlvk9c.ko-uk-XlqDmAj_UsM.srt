1
00:00:00,000 --> 00:00:07,727
[쥐 우는 소리]
[소리] [딸깍]

2
00:00:13,618 --> 00:00:14,660
저스틴 솔로몬: 자, 팀 여러분.

3
00:00:14,660 --> 00:00:18,600
오늘 하루를 시작해 볼까요?

4
00:00:18,600 --> 00:00:21,350
기쁩니다.
다음에 봐요 여러분.

5
00:00:21,350 --> 00:00:23,000
만약 당신이 그렇지 않다면
제 이름은 저스틴이에요.

6
00:00:23,000 --> 00:00:26,629
저는 세 번째 교관 006입니다.
아마 잊으셨을 텐데,

7
00:00:26,629 --> 00:00:29,179
하지만 당신은 보게 될 거예요
저는 훨씬 더...

8
00:00:29,179 --> 00:00:31,640
우리 강좌의 일부는 그래프 이론에 할애되어 있습니다. 왜냐하면
이것은 알고리즘의 일부입니다.

9
00:00:31,640 --> 00:00:32,280
나는 둘 중 어느 것을 좋아해.

10
00:00:32,280 --> 00:00:35,672
내가 만약 ~로 환생한다면
이론 컴퓨터 과학자,

11
00:00:35,671 --> 00:00:37,129
저는 아마 그럴 것 같아요
이 분야에 뛰어들었다.

12
00:00:37,130 --> 00:00:38,420
안녕하세요 여러분.

13
00:00:38,420 --> 00:00:40,490
좋은.  곧

14
00:00:40,490 --> 00:00:43,190
박사 학위 논문 방문을 요청합니다.

15
00:00:43,189 --> 00:00:46,460
다음 며칠 동안 나는
저도 지금 작업 중이에요.

16
00:00:46,460 --> 00:00:47,780
캠프 팬의 목소리로.

17
00:00:47,780 --> 00:00:51,679
그러니 날 깨우지 마.
여러분 모두를 하루 동안 만나요.

18
00:00:51,679 --> 00:00:53,490
당신은 좋아하지 않을 거예요.

19
00:00:53,490 --> 00:00:57,350
하지만 어쨌든, 그래서
6.006을 돌아보면

20
00:00:57,350 --> 00:00:59,000
수업 계획표에서,
우리는 공식적으로

21
00:00:59,000 --> 00:01:01,609
이 수업의 두 번째 부분을 시작하겠습니다.

22
00:01:01,609 --> 00:01:04,155
이 사실에는 여러 가지 결과가 따른다.

23
00:01:04,155 --> 00:01:06,030
그래서, 만약 없다면
이것에 대한 질문입니다.

24
00:01:06,030 --> 00:01:09,140
우리는 다음으로 시작하겠습니다.
저희 새 유닛은 6.006입니다.

25
00:01:09,140 --> 00:01:11,870
이것이 바로 그래프 이론입니다.

26
00:01:11,870 --> 00:01:15,153
관심 있으시면,
화면에 그래프가 있습니다.

27
00:01:15,153 --> 00:01:17,570
하지만 물론, 오늘 저희는 제공해 드리겠습니다.
좀 더 자세한 정보

28
00:01:17,569 --> 00:01:19,369
강의 중에.

29
00:01:19,370 --> 00:01:24,680
제가 공부할 때
제가 지금도 하고 있는 것을 가르치기 위해서요.

30
00:01:24,680 --> 00:01:26,960
사실 제 박사 학위는...
누군가를 원한다면 그렇게 말해줬어

31
00:01:26,959 --> 00:01:29,459
당신은 무언가를 배웠습니다.
가능한 한 자세히 적어 두세요.

32
00:01:29,459 --> 00:01:31,879
그래서 저는 정말 집중했어요.
이 접근 방식에

33
00:01:31,879 --> 00:01:34,259
오늘 슬라이드에서 살펴보겠습니다.

34
00:01:34,259 --> 00:01:36,770
그래서 어쨌든,
오늘 우리는

35
00:01:36,769 --> 00:01:38,689
우리는 첫 번째 행사를 개최할 것입니다
그래프에 관한 강의,

36
00:01:38,689 --> 00:01:42,890
제 생각에는 어느 정도는 그럴 것 같습니다.
많은 분들을 위한 리뷰입니다.

37
00:01:42,890 --> 00:01:44,337
그렇지 않다면,
그것도 멋지네요.

38
00:01:44,337 --> 00:01:45,920
왜냐하면 우리는 시작할 것이기 때문입니다
처음부터

39
00:01:45,920 --> 00:01:47,420
그리고 그런 것 같습니다
모든 컨셉을 만들어 봅시다.

40
00:01:47,420 --> 00:01:50,299
이해에 필수적이며
그래프 처리, 그리고 바라건대,

41
00:01:50,299 --> 00:01:53,560
강의가 끝날 때까지
우리는 특정한 스타일을 가질 것입니다

42
00:01:53,560 --> 00:01:56,060
계산 알고리즘
한 정점에서 출발하는 최단 경로

43
00:01:56,060 --> 00:01:58,140
다른 모든 분들께.

44
00:01:58,140 --> 00:02:01,620
그래서, 우리가 조금이라도 잊어버렸다면
용어, 일정 —

45
00:02:01,620 --> 00:02:04,370
어떤 사람들은 이것을 네트워크라고 부릅니다.
하지만 때때로 이 용어는

46
00:02:04,370 --> 00:02:06,620
여러 가지로 과부하됨
다양한 변형

47
00:02:06,620 --> 00:02:07,820
주제 —

48
00:02:07,819 --> 00:02:10,068
두 가지가 결합된 것입니다.

49
00:02:10,068 --> 00:02:12,650
저것
괄호 안의 표기법을 의미합니다.

50
00:02:12,650 --> 00:02:16,520
정점들의 집합이 있습니다.
그리고 갈비뼈 한 세트.

51
00:02:16,520 --> 00:02:19,670
그리고 갈비도 가능하죠.
제3의 관점에서 보십시오

52
00:02:19,669 --> 00:02:23,599
여기 화면에는 다음과 같은 것이 있습니다.
부분집합 v 교차 v. 이제

53
00:02:23,599 --> 00:02:25,219
이건 정말 훌륭해요
어떤 것의 명칭

54
00:02:25,219 --> 00:02:27,257
아주아주 간단합니다.

55
00:02:27,257 --> 00:02:28,590
그게 나에게 뭘 말해주는 걸까요?

56
00:02:28,590 --> 00:02:30,870
이것은 내게 ~에 대해 알려줍니다
사진에서처럼 가장자리,

57
00:02:30,870 --> 00:02:32,640
화면에서 보시는 바와 같습니다.

58
00:02:32,639 --> 00:02:36,106
그냥 그게
꼭짓점들을 서로 연결합니다.

59
00:02:36,106 --> 00:02:38,689
그래서, 만약 제가 가지게 되는 것에 대해 생각한다면
정점 쌍, 예를 들어 에서

60
00:02:38,689 --> 00:02:42,335
그리고 그렇다면 이것은
교차곱의 부분집합

61
00:02:42,335 --> 00:02:44,010
v와 나.

62
00:02:44,009 --> 00:02:46,501
그래서, 바라건대, 표기법은 다음과 같을 것입니다.
화면의 세 번째 줄

63
00:02:46,502 --> 00:02:47,210
어느 정도 일리가 있네요.

64
00:02:47,210 --> 00:02:50,900
이건 그냥 멋을 부린 명칭일 뿐입니다. 왜냐하면
간선은 정점들의 쌍입니다.

65
00:02:50,900 --> 00:02:52,789
하지만 물론,
이 표기법

66
00:02:52,789 --> 00:02:57,228
두 가지 특별한 경우가 있습니다.
우리가 이 수업에서 중요하게 생각하는 것입니다.

67
00:02:57,228 --> 00:02:59,389
하나는
일정 지향적

68
00:02:59,389 --> 00:03:01,549
두 번째는 방향성이 없습니다.

69
00:03:01,550 --> 00:03:03,592
내가 그렇게 말했으니까
그것과 정반대되는 순서

70
00:03:03,592 --> 00:03:04,930
화면에.

71
00:03:04,930 --> 00:03:08,355
따라서 무방향 그래프에서 나는
우리는 아직 갈비뼈에 대해 생각하고 있는 것 같아요.

72
00:03:08,353 --> 00:03:10,728
마치 두 개의 봉우리처럼 보이지만,
사실 표시했어야 했는데

73
00:03:10,728 --> 00:03:12,228
이건 좀
그렇지 않으면, 사실은,

74
00:03:12,228 --> 00:03:14,478
한번 알아볼게요.
다음으로 넘어가기 전에 슬라이드를 보세요.

75
00:03:14,478 --> 00:03:15,649
OCW로--

76
00:03:15,650 --> 00:03:20,150
글을 쓰는 대신에
e는 w와 v와 같습니다.

77
00:03:20,150 --> 00:03:24,950
나는 글을 써야만 한다.
실제로 v 쉼표 w와 같습니다.

78
00:03:24,949 --> 00:03:27,769
그리고 작은 부분이 있다는 점에 유의하세요.
명칭 간의 차이점

79
00:03:27,770 --> 00:03:30,020
슬라이드에 있는 것과 내가
칠판에 적었다, 즉

80
00:03:30,020 --> 00:03:32,480
여기에 정해진 표기법이 있습니다.

81
00:03:32,478 --> 00:03:35,049
차이점은 무엇인가요?
괄호와 물결선

82
00:03:35,050 --> 00:03:36,579
이 사람은 정리정돈을 잘 못한다는 겁니다.

83
00:03:36,579 --> 00:03:38,140
이것은 여러 가지 사물의 집합입니다.

84
00:03:38,139 --> 00:03:40,959
그리고 뭐에 대해서?
칠판은 질서정연하다.

85
00:03:40,960 --> 00:03:43,030
더 정확히 말하면 화면에 보이는 내용입니다.

86
00:03:43,030 --> 00:03:44,860
그리고 물론, 에서
방향 없는 모서리

87
00:03:44,860 --> 00:03:46,930
그런 건 없어요.
w의 가장자리로서

88
00:03:46,930 --> 00:03:49,788
v로의 변환은 다음과 다를 것입니다.
v에서 w로의 모서리.

89
00:03:49,788 --> 00:03:50,829
똑같아요.

90
00:03:50,829 --> 00:03:51,622
그들은 지시를 받지 않습니다.

91
00:03:51,622 --> 00:03:53,890
그건 단지 개념일 뿐이에요.
연결성.

92
00:03:53,889 --> 00:03:56,019
반면, 지향된 경우에는
지금 우리도 세어주세요

93
00:03:56,020 --> 00:03:58,120
우리는 이것을 사용할 것입니다
괄호 안의 표기법,

94
00:03:58,120 --> 00:04:01,330
그렇게 말하다
w에서 v로의 모서리

95
00:04:01,330 --> 00:04:03,987
~와 다르다
v에서 w로의 모서리.

96
00:04:03,986 --> 00:04:05,569
이것은 가질 것입니다
매우 중요합니다.

97
00:04:05,569 --> 00:04:09,159
예를 들어, ~에
오른쪽 그래프 -

98
00:04:09,159 --> 00:04:12,469
다시 그려보는 건 어떨까요?
여기 게시판에 적혀 있어요.

99
00:04:12,469 --> 00:04:14,139
그래서 우리는 네 개의 꼭짓점을 가지고 있습니다.

100
00:04:14,139 --> 00:04:16,539
이 그림은 어젯밤에 그렸어요.
이 예시가 도움이 되기를 바랍니다.

101
00:04:16,540 --> 00:04:17,260
정말 효과가 있어요.

102
00:04:22,028 --> 00:04:26,579
그럼... 제가 다음으로 넘어갈 수 있을까요?
오른쪽 위 꼭짓점

103
00:04:26,579 --> 00:04:31,550
왼쪽 아래 꼭짓점까지
이 그래프의 가장자리를 따라요?

104
00:04:31,550 --> 00:04:33,500
한 사람의 말을 들었습니다.

105
00:04:33,500 --> 00:04:35,838
모두에게 3개씩... 1, 2, 3.

106
00:04:35,838 --> 00:04:36,379
청중: 없음.

107
00:04:36,379 --> 00:04:37,463
저스틴 솔로몬: 네, 맞습니다.

108
00:04:37,463 --> 00:04:38,780
왜냐하면 만약 내가 원한다면-

109
00:04:38,779 --> 00:04:41,299
제 말은, 어쩌면 제가 ~에 대해 생각하고 있는지도 모른다는 거죠.
여기에 경로를 그려주세요.

110
00:04:41,300 --> 00:04:44,270
하지만 물론 내가
오른쪽 상단 모서리에서 이동했습니다.

111
00:04:44,269 --> 00:04:45,589
왼쪽 아래 --

112
00:04:45,589 --> 00:04:48,549
그건 정말 최악의 광경일 거예요.
제가 그랬다면 정말 죄송합니다.

113
00:04:48,550 --> 00:04:50,300
여기서 알아차리실 수도 있습니다.
모서리는 방향성을 가집니다.

114
00:04:50,300 --> 00:04:52,409
위에.

115
00:04:52,409 --> 00:04:54,650
그래서 저는 반대 의견을 내야 할 것 같습니다.
물살,

116
00:04:54,649 --> 00:04:57,241
하지만 이는 용납할 수 없습니다.
방향 그래프의 경우.

117
00:04:57,242 --> 00:04:58,700
물론이죠, 저는
벌써부터 예감이 들어요.

118
00:04:58,699 --> 00:05:01,074
우리가 가는 길의 개념
아직 결정되지 않았습니다.

119
00:05:01,074 --> 00:05:02,899
하지만 저는
직관적으로 나는 이것이라고 생각한다.

120
00:05:02,899 --> 00:05:06,014
큰 차이
방향 그래프와 무방향 그래프.

121
00:05:06,014 --> 00:05:08,139
이 차이가 중요한가요?
여러분 모두에게 의미하는 바는 다음과 같습니다.

122
00:05:08,139 --> 00:05:12,560
내가 졌나?
4분 안에, 아니면 그보다 더 빨리?

123
00:05:12,560 --> 00:05:14,360
아주.

124
00:05:14,360 --> 00:05:16,651
그래서 상황을 조금 바꿔봤습니다.
~와 함께

125
00:05:16,651 --> 00:05:18,110
제가 수업 노트를 가지고 있기 때문입니다.
우리는 다음과 같이 결정했습니다.

126
00:05:18,110 --> 00:05:19,776
먼저 그래프가 무엇인지 정의해 보겠습니다.
말하기 전에,

127
00:05:19,776 --> 00:05:21,689
그 결과는 무엇일까요?

128
00:05:21,689 --> 00:05:23,990
하지만 어쨌든,
제 생각엔 이것은

129
00:05:23,990 --> 00:05:26,000
크지 않음
상상력,

130
00:05:26,000 --> 00:05:28,639
그래프가
말 그대로 모든 곳

131
00:05:28,639 --> 00:05:30,319
우리 일상생활에서 그렇잖아요, 그렇죠?

132
00:05:30,319 --> 00:05:34,129
우리가 생각해낼 때마다
연결된 사물 네트워크

133
00:05:34,129 --> 00:05:37,040
함께, 암묵적으로
자주 발생하는 올바른 추상화

134
00:05:37,040 --> 00:05:40,480
우리 머릿속에,
일정을 고려해야 합니다.

135
00:05:40,480 --> 00:05:42,230
자, 간단한 몇 가지
제가 생각하는 예시들

136
00:05:42,230 --> 00:05:43,730
모두가 올 것입니다
저희 생각으로는,

137
00:05:43,730 --> 00:05:45,580
컴퓨터 네트워크와 유사함 -

138
00:05:45,579 --> 00:05:49,159
따라서 노드 또는 정점
이 경우 그래프는 아마도 다음과 같을 것입니다.

139
00:05:49,159 --> 00:05:50,960
컴퓨터입니다.
그리고 갈비뼈는

140
00:05:50,959 --> 00:05:53,479
대략 다음과 같은 케이블
그것들을 서로 연결하세요

141
00:05:53,480 --> 00:05:57,110
제가 아주 대략적으로 이해한 바로는,
네트워크는 어떻게 작동하는가?

142
00:05:57,110 --> 00:05:59,060
아니면 소셜 미디어에서일지도 몰라요.

143
00:05:59,060 --> 00:06:02,209
노드는 사람입니다.
소셜 네트워크에서,

144
00:06:02,209 --> 00:06:04,489
그리고 경계는 다음과 같습니다.
우호적인 관계

145
00:06:04,490 --> 00:06:08,300
적대적 관계
아니면 다른 무언가.

146
00:06:08,300 --> 00:06:11,329
사실, 당신은 아마 그렇게 생각할 것 같아요.
방향성 있는 것과 방향성 없는 것에 대하여

147
00:06:11,329 --> 00:06:15,219
이것의 버전
특정 네트워크.

148
00:06:15,220 --> 00:06:18,110
도로망과 관련해서는 아마도
저는 구글에서 일합니다.

149
00:06:18,110 --> 00:06:20,600
그리고 제가 말씀드리고 싶은 것은
가장 빠른 길

150
00:06:20,600 --> 00:06:22,220
당신 집과 MIT 사이.

151
00:06:22,220 --> 00:06:24,500
물론,
이를 위해, 그리고 실제로,

152
00:06:24,500 --> 00:06:26,839
무대 뒤에서 우리는
우리는 어떤 버전을 선택하기로 결정했어요

153
00:06:26,839 --> 00:06:28,639
계산
두 지점 사이의 최단 경로

154
00:06:28,639 --> 00:06:30,224
그래프의 꼭짓점.

155
00:06:30,225 --> 00:06:31,850
이것은 작은 것입니다
거짓말이란 다음과 같은 의미입니다.

156
00:06:31,850 --> 00:06:33,808
무엇
이 문제에는 많은 구조적 요소가 있습니다.

157
00:06:33,807 --> 00:06:35,930
우리가 하지 않을 일
본 과정에서 사용됩니다.

158
00:06:35,930 --> 00:06:38,900
도로망은 매우
특수한 유형의 그래프,

159
00:06:38,899 --> 00:06:40,669
그리고 만약 당신이 통과한다면
고급 과정일 수도 있습니다.

160
00:06:40,670 --> 00:06:43,490
당신은 이렇게 말합니다: 글쎄, 내가 안다면
일정에 대해 좀 더 자세히 알려주세요.

161
00:06:43,490 --> 00:06:46,740
나는 평균보다 더 잘할 수 있다.
우리가 여기서 논의할 사례는 다음과 같습니다.

162
00:06:46,740 --> 00:06:49,610
하지만 기본적인 알고리즘은 다음과 같습니다.
우리는 6.006에 이야기할 것입니다.

163
00:06:49,610 --> 00:06:51,073
틀림없이,
이 경우와 관련됨

164
00:06:51,072 --> 00:06:52,489
그리고 실제로 그렇습니다.
빌딩 블록

165
00:06:52,490 --> 00:06:54,620
지금 일어나고 있는 일에 대해서
도구에서

166
00:06:54,620 --> 00:06:57,259
매일 사용하는
구글 지도를 열면 휴대폰 화면에 표시됩니다.

167
00:06:57,259 --> 00:06:59,629
또는 방법이나 다른 무언가.

168
00:06:59,629 --> 00:07:01,310
그리고 물론,
그 외에도 많습니다.

169
00:07:01,310 --> 00:07:03,834
예를 들면,
예시

170
00:07:03,834 --> 00:07:05,209
조금
희석제,

171
00:07:05,209 --> 00:07:07,430
일련의 상태들이 있을 것입니다.
그리고 전환

172
00:07:07,430 --> 00:07:08,819
별개의 문제입니다.

173
00:07:08,819 --> 00:07:11,420
그러니 어떻게 생각해 볼까요?
루빅 큐브.

174
00:07:11,420 --> 00:07:13,580
그래서 제가 만들 수 있도록
그래프에서 노드

175
00:07:13,579 --> 00:07:15,859
모든 구성이 가능합니다
내 루빅 큐브,

176
00:07:15,860 --> 00:07:17,300
매 회전마다 마찬가지입니다.

177
00:07:17,300 --> 00:07:19,490
그리고 나서 가장자리가
내가 할 수 있을까와 비슷하게

178
00:07:19,490 --> 00:07:21,500
이 주제에서 벗어나세요
다른 구성으로 변경,

179
00:07:21,500 --> 00:07:24,170
간단한 것을 하나 만들어서
마치 한 번의 혁명과 같은 전환기입니다.

180
00:07:24,170 --> 00:07:26,420
저도 잘 모르겠어요.
루빅 큐브 용어,

181
00:07:26,420 --> 00:07:29,870
나는 당신이 그렇게 느낀다고 생각해요
아시다시피, 한 번만 돌리면 돼요.

182
00:07:29,870 --> 00:07:32,478
트위스트님, 감사합니다.

183
00:07:32,478 --> 00:07:34,269
그리고 물론,
다른 곳도 많습니다.

184
00:07:34,269 --> 00:07:38,250
예를 들어, ~하는 동안
MIT에서 제가 하는 본업은 다음과 같습니다.

185
00:07:38,250 --> 00:07:40,129
저는 보통 가르칩니다.
컴퓨터 그래픽 강좌.

186
00:07:40,129 --> 00:07:42,170
그리고 실제로
그래프 이론은 비록 우리가

187
00:07:42,170 --> 00:07:45,170
우리는 그것에 대해 완전히 다른 방식으로 이야기합니다.
그 세계에 나타난다

188
00:07:45,170 --> 00:07:46,460
끊임없이.

189
00:07:46,459 --> 00:07:48,859
당연히 그렇죠.
3D 모델 뒤에 앉아 있는

190
00:07:48,860 --> 00:07:52,725
컴퓨터에는 다음과 같은 것이 있습니다.
거대한 삼각형 네트워크.

191
00:07:52,725 --> 00:07:54,350
이것은 이렇게 불립니다
삼각형 표면--

192
00:07:54,350 --> 00:07:56,210
여기 보이는 이 토러스처럼 말이죠.

193
00:07:56,209 --> 00:07:57,826
그리고 이것은 아닙니다
단순한 일정표 그 이상입니다.

194
00:07:57,826 --> 00:07:59,659
그리고 사실, 만약 당신이
알고리즘을 살펴보세요.

195
00:07:59,659 --> 00:08:01,460
이에 대해서는 6장에서 자세히 논의합니다.
838,

196
00:08:01,459 --> 00:08:05,372
대략적인 값임을 알 수 있을 것입니다.
마스크된 그래프 알고리즘.

197
00:08:05,372 --> 00:08:07,789
사실, 제 대학원 과정을 보시면
물론, 우리는 한 가지 일을 할 것입니다.

198
00:08:07,790 --> 00:08:10,165
이 일에는 시간이 많이 걸릴 것입니다.
미분기하학에 관하여.

199
00:08:10,165 --> 00:08:12,103
그리고 나서 우리는 후퇴할 것입니다.
10피트 뒤로 물러나면 알아챌 거예요.

200
00:08:12,103 --> 00:08:13,519
무엇
우리가 사용하는 알고리즘

201
00:08:13,519 --> 00:08:17,569
곡률을 계산하는 데 사용됩니다.
그리고 삼각형으로 굽힘

202
00:08:17,569 --> 00:08:19,939
그리드, 보세요
그래프 알고리즘으로서

203
00:08:19,939 --> 00:08:22,540
네트워크에 적용될 수 있습니다.
완전히 똑같습니다.

204
00:08:22,540 --> 00:08:25,430
그러면 좋을 거예요.
재미있는 발견이네요.

205
00:08:25,430 --> 00:08:28,939
물론 있죠.
최신 재밌는 앱입니다.

206
00:08:28,939 --> 00:08:31,160
사실 저는 그 자리에 없었어요.
지난 며칠 동안

207
00:08:31,160 --> 00:08:33,320
컨퍼런스에서
정치적 재분배.

208
00:08:33,320 --> 00:08:35,570
그리고 재밌는 건,
대부분의 토론

209
00:08:35,570 --> 00:08:38,510
그 회의에서
그래프 이론에 관심이 있었습니다.

210
00:08:38,509 --> 00:08:43,340
그 이유는 다음과 같습니다.
어떤 주제

211
00:08:43,340 --> 00:08:46,642
기하학의 세계에서 자주 등장합니다.
제 주를 예로 들자면,

212
00:08:46,642 --> 00:08:48,350
이 경우에는 제 생각에는
이것들은 선택 사항입니다

213
00:08:48,350 --> 00:08:51,500
그 구역
또는 다른 주,

214
00:08:51,500 --> 00:08:53,809
그리고 나는 바라본다
인접 관계,

215
00:08:53,809 --> 00:08:56,569
그럼 노드를 설치해 볼까 생각 중이에요.
각 구역 및 지역

216
00:08:56,570 --> 00:08:59,760
그들이 공통점을 가질 때마다
국경.

217
00:08:59,759 --> 00:09:01,009
이제 저에게는 네트워크가 생겼습니다.

218
00:09:01,009 --> 00:09:03,980
그리고 아마도 제 일정에 있는 지역일 겁니다.
연결된 부분과 같습니다.

219
00:09:03,980 --> 00:09:06,149
이 네트워크의.

220
00:09:06,149 --> 00:09:08,779
어쨌든 이것은 하나입니다.
이러한 예시들 중에서

221
00:09:08,779 --> 00:09:11,209
그래프, 네트워크,
의사소통 등 간단히

222
00:09:11,210 --> 00:09:12,920
말 그대로 나타나다
어디를 가든 마찬가지입니다.

223
00:09:12,919 --> 00:09:14,876
그것들은 절대적으로 피할 수 없습니다.

224
00:09:14,876 --> 00:09:17,209
그래서 우리는
우리는 많은 시간을 보낼 것입니다

225
00:09:17,210 --> 00:09:20,250
이번 수업에서.

226
00:09:20,250 --> 00:09:23,000
이제 당신은 쉽게 할 수 있습니다
들어보세요, 제 생각에는,

227
00:09:23,000 --> 00:09:27,620
최소 세 가지 코스 요리를 모두 드셔보세요.
MIT의 그래프 이론 분야에서,

228
00:09:27,620 --> 00:09:30,560
그리고 여러분은 쉽게 만들 수 있습니다
박사 학위 논문, 연구 중

229
00:09:30,559 --> 00:09:32,779
정말 간단한 것들만
그래프 관련 작업.

230
00:09:32,779 --> 00:09:37,579
물론, 이번 수업에서는
우리는 몇 가지로 제한되어 있습니다.

231
00:09:37,580 --> 00:09:38,455
많은 사람들의 강의.

232
00:09:38,455 --> 00:09:40,372
그럼 그렇게 하겠습니다.
몇 가지 가정

233
00:09:40,371 --> 00:09:43,250
우리가 원하는 문제들은 어떻게 되는 건가요?
문제를 풀기 위해서, 그리고 그래프를 위해서,

234
00:09:43,250 --> 00:09:44,759
우리가 관심을 갖는 것들.

235
00:09:44,759 --> 00:09:47,210
특히, 하나는
단순화된 가정입니다.

236
00:09:47,210 --> 00:09:48,767
어느
별로 영향을 주지 않아요

237
00:09:48,767 --> 00:09:50,600
많은 알고리즘,
여기서 우리가 이야기할 주제는 바로 이것입니다.

238
00:09:50,600 --> 00:09:52,790
하지만 그럴 만한 가치가 있어요
명확히 밝히자면,

239
00:09:52,789 --> 00:09:55,519
우리는 무엇이 될까요?
특정 유형에 대해서만 주로 생각하다

240
00:09:55,519 --> 00:09:58,809
그래픽, 즉
간단한 그래프.

241
00:09:58,809 --> 00:10:01,689
그리고 사실, 종종 상황에 따라
일정을 어떻게 정하느냐에 따라,

242
00:10:01,690 --> 00:10:03,970
어쩌다 보니
일정을 간소화했습니다.

243
00:10:03,970 --> 00:10:05,200
설령 그들이 의도하지 않았더라도.

244
00:10:05,200 --> 00:10:07,570
예를 들어, 우리는
우리 갈비뼈에 대해 썼다

245
00:10:07,570 --> 00:10:11,110
v의 부분집합이 v와 교차합니다.
이건 아마 내가 할 수 없다는 뜻일 거야

246
00:10:11,110 --> 00:10:15,460
갈비뼈가 여러 개 있다,
교차하는 것들

247
00:10:15,460 --> 00:10:17,110
동일한 두 꼭짓점.

248
00:10:17,110 --> 00:10:22,190
그럼 예를 하나 들어보겠습니다.
빡빡한 일정.

249
00:10:22,190 --> 00:10:23,920
실례합니다, 저는
실제로 정의하지는 않았습니다.

250
00:10:23,919 --> 00:10:27,439
단순 그래프는 말 그대로 그래프입니다.
자체 순환이 없는 것,

251
00:10:27,440 --> 00:10:30,210
그래서 그는 움직일 수 없어요
정상은 그 자체로,

252
00:10:30,210 --> 00:10:31,860
그리고 각 모서리는 분리되어 있습니다.

253
00:10:31,860 --> 00:10:36,610
자, 그럼 가장 어려운 문제를 만들어 봅시다.
상상조차 할 수 없는 일정입니다.

254
00:10:36,610 --> 00:10:40,600
내가
제게는 두 개의 봉우리가 있습니다.

255
00:10:40,600 --> 00:10:42,700
그래서 어쩌면 제가 직접 만들어보고 싶을지도 모르겠네요...

256
00:10:42,700 --> 00:10:45,400
그러니까 그래프가 있는 거죠, 그렇죠?
두 개의 꼭짓점과 하나의 모서리.

257
00:10:45,399 --> 00:10:47,049
간단합니다.

258
00:10:47,049 --> 00:10:49,419
내가 누군가를 짜증나게 하고 싶었다면
그리고 어렵게 만들겠다.

259
00:10:49,419 --> 00:10:53,129
어쩌면 이 기회를 잡아야겠어.
세 번 복사할게요.

260
00:10:53,129 --> 00:10:54,429
오락을 위해서.

261
00:10:54,429 --> 00:10:57,089
이는 위반입니다
두 번째 가정.

262
00:10:57,090 --> 00:10:59,590
그런데 지금 더 나쁜 건,
첫 번째 건은 부술 수 있을 것 같아.

263
00:10:59,590 --> 00:11:03,050
엣지를 더하다
이 봉우리에서 그 자체까지.

264
00:11:03,049 --> 00:11:06,529
쉽지 않아요.

265
00:11:09,827 --> 00:11:12,370
나는 당신이 어떻게 할지 모르겠어요
이것은 실제로 일반 일정표라고 불립니다.

266
00:11:12,370 --> 00:11:14,929
제 생각엔 복잡한 문제인 것 같아요.
간단하지 않기 때문입니다.

267
00:11:14,929 --> 00:11:19,296
모르겠어요 - 멀티그래프요.

268
00:11:19,297 --> 00:11:20,379
저는 항상 이 생각을 해왔어요.

269
00:11:20,379 --> 00:11:22,220
어쨌든 상관없어요.

270
00:11:22,220 --> 00:11:24,100
하지만 어쨌든
이 수업에서 우리는

271
00:11:24,100 --> 00:11:26,745
걱정하지 말자
이러한 특정한 상황.

272
00:11:26,745 --> 00:11:28,870
그리고 물론, 많은 사람들이
그래프 이론의 응용

273
00:11:28,870 --> 00:11:31,611
그건 꽤 합리적이네요.
추정.

274
00:11:31,611 --> 00:11:33,819
다음과 같은 질문들이 있습니다.
단순 그래프의 정의는 무엇인가요?

275
00:11:36,440 --> 00:11:39,092
그러므로 이제부터 매번
일정에 대해 생각해 보겠습니다.

276
00:11:39,091 --> 00:11:40,549
그의
우리가 수장이 될 것입니다

277
00:11:40,549 --> 00:11:42,259
우리의 일정이 간단하다고 생각하다니.  간단한 그래프에서

278
00:11:42,259 --> 00:11:44,870
훌륭한 부동산이 하나 있습니다.
,

279
00:11:44,870 --> 00:11:47,120
제가 여기에 쓴 내용은 매우
화면에 큰 글씨

280
00:11:47,120 --> 00:11:52,250
즉,
에지(edges)는 v²의 큰 O입니다.

281
00:11:52,250 --> 00:11:55,789
그리고 사실, 우리 함께 해봅시다
이 공식을 좀 더 자세히 설명해 보겠습니다.

282
00:11:55,789 --> 00:11:57,860
그래서, 있습니다.
두 가지 경우: 하나

283
00:11:57,860 --> 00:11:59,870
— 제 일정은 언제인가요?
방향 감각이 없는, 기타 —

284
00:11:59,870 --> 00:12:03,779
제 일정이 정해져 있을 때요.

285
00:12:03,779 --> 00:12:05,269
그러니까, 만약 제가 방향 그래프를 가지고 있다면...

286
00:12:12,220 --> 00:12:15,570
좋아요, 얼마나 될지 생각해 봅시다.
우리는 갈비뼈를 가지고 있을지도 몰라요.

287
00:12:15,570 --> 00:12:21,580
따라서, 엣지는 쌍입니다.
한 꼭짓점에서 다른 꼭짓점으로,

288
00:12:21,580 --> 00:12:23,230
그리고 저는 그걸 두 번 다시 할 수 없어요.

289
00:12:23,230 --> 00:12:27,190
이것은 ~와 같은 것입니다.
두 번째 가정.

290
00:12:27,190 --> 00:12:29,570
특히,
우리가 알고 있는 것은 무엇일까요?

291
00:12:29,570 --> 00:12:31,390
우리는 모드 E--를 알고 있습니다.
또는 더 정확히 말하면, 숫자

292
00:12:31,389 --> 00:12:36,740
우리 그래프의 간선은 다음과 같습니다.
무엇의 상한선인가요?

293
00:12:36,740 --> 00:12:40,600
음, 저는 아무거나 다 받을 수 있어요.
두어 개의 봉우리 --

294
00:12:43,957 --> 00:12:46,000
이렇게—하지만 난 그래야만 해
조금 조심하세요.

295
00:12:46,000 --> 00:12:48,250
내 그래프는 방향 그래프이기 때문입니다.

296
00:12:48,250 --> 00:12:50,450
그러므로 '~에서'와 '~까지'가 여기서 중요합니다.

297
00:12:50,450 --> 00:12:52,900
이것이 바로 v 선택입니다.
2는 내가

298
00:12:52,899 --> 00:12:55,629
저는 어떤 독특한 것이든 받아들일 수 있습니다.
두어 개의 봉우리,

299
00:12:55,629 --> 00:12:57,939
하지만 저는 넣어야 해요
그 전에는 계수가 2였습니다.

300
00:12:57,940 --> 00:13:00,190
다음 사실을 고려하기 위해
소스 및 대상

301
00:13:00,190 --> 00:13:01,900
앞뒤로 돌릴 수 있습니다.

302
00:13:01,899 --> 00:13:03,824
물론, 제가 원한다면요.
연출 없이 영화를 촬영하다

303
00:13:03,825 --> 00:13:05,200
저는 그게 필요 없어요.
그것에 대해 걱정할 필요가 없습니다.

304
00:13:10,519 --> 00:13:16,539
여기서 E가 보다 작다는 것을 알게 될 것입니다.
또는 단순히 mod v select 2와 같습니다.

305
00:13:16,539 --> 00:13:19,029
그러니까 간단해요.
이상하게 들리겠지만,

306
00:13:19,029 --> 00:13:21,399
각 모서리가 다음과 같이 구성됩니다.
두 봉우리에서,

307
00:13:21,399 --> 00:13:22,648
그리고 제 갈비는 독특해요.

308
00:13:22,648 --> 00:13:24,190
그리고 한 가지, 만약
여기에 쓰시면 됩니다

309
00:13:24,190 --> 00:13:27,160
우리의 공식
이항계수,

310
00:13:27,159 --> 00:13:30,439
우리는 둘 다 보게 될 것입니다
이런 것들 --

311
00:13:30,440 --> 00:13:33,850
아, 아, 네, 죄송합니다.

312
00:13:37,330 --> 00:13:39,920
여기서 mod v 제곱 값이 더 나빠집니다.

313
00:13:43,370 --> 00:13:45,722
그리고 이는 아주 논리적입니다.
당연히, 가장자리 때문에 —

314
00:13:45,722 --> 00:13:46,639
이것은 한 쌍의 정점입니다.

315
00:13:46,639 --> 00:13:48,470
당신은 그렇게 기대하는 것 같군요.
광장이 생길 것입니다.

316
00:13:48,470 --> 00:13:48,970
예?

317
00:13:48,970 --> 00:13:53,942
청중: [알아들을 수 없음]

318
00:13:53,942 --> 00:13:55,149
저스틴 솔로몬: 정말 죄송합니다.

319
00:13:55,149 --> 00:13:56,177
안 들려요.

320
00:13:56,177 --> 00:13:57,759
청중: 그래서, 2
이는 다음 사실에서 비롯됩니다.

321
00:13:57,759 --> 00:13:58,932
이것은 출처가 어디인가요?

322
00:13:58,932 --> 00:14:00,139
저스틴 솔로몬: 네, 맞습니다.

323
00:14:00,139 --> 00:14:03,399
그래서, 2개
감독의 경우, 그 이유는 다음과 같은 사실에서 비롯됩니다.

324
00:14:03,399 --> 00:14:07,899
v에서 w로 가는 모서리
w의 가장자리와 다릅니다

325
00:14:07,899 --> 00:14:11,105
v로. 그러니 기억하세요.
여기서 이항계수

326
00:14:11,105 --> 00:14:12,730
그냥 세는 중
내가 할 수 있는 방법의 수

327
00:14:12,730 --> 00:14:15,279
두 가지를 고를 수 있어요.
크기가 v인 집합에서,

328
00:14:15,279 --> 00:14:16,929
하지만 그는 신경 쓰지 않아요.
주문에 관해서요.

329
00:14:16,929 --> 00:14:20,759
네, 더 질문 있으신가요?

330
00:14:20,759 --> 00:14:21,807
아주.

331
00:14:21,807 --> 00:14:23,100
이것이 왜 중요할까요?

332
00:14:23,100 --> 00:14:24,600
이런 종류
한계, 그러니까 그걸 말하는 거예요.

333
00:14:24,600 --> 00:14:26,470
그들은 포기할지도 모릅니다
당신에게는 조금 당연하게 들리겠죠.

334
00:14:26,470 --> 00:14:28,427
하지만 우리는 갈 거예요
그래프 알고리즘을 적어보세요.

335
00:14:28,427 --> 00:14:30,480
자, 이제 분석해 보겠습니다.
실행 시간 및 공간

336
00:14:30,480 --> 00:14:33,368
그들이 점령했고, 이제 우리는
서로 다른 두 숫자,

337
00:14:33,368 --> 00:14:34,410
우리가 생각해 볼 수 있는 것들은 다음과 같습니다.

338
00:14:34,409 --> 00:14:37,740
정점의 개수
그리고 모서리의 개수.

339
00:14:37,740 --> 00:14:39,240
따라서 예를 들면,
내가 적으면

340
00:14:39,240 --> 00:14:42,299
알고리즘, 실행 시간
수에 비례하여

341
00:14:42,299 --> 00:14:44,939
갈비뼈, 아마도
그렇다면 저는

342
00:14:44,940 --> 00:14:46,513
또한 그렇게 생각할 수도 있습니다.
연산

343
00:14:46,513 --> 00:14:48,930
실행 시간이 다음과 같습니다.
정점의 개수로

344
00:14:48,929 --> 00:14:51,029
내가 그렇게 하지 않으면 사각형이 됩니다
추가적인 가정

345
00:14:51,029 --> 00:14:52,100
제 일정에 관해서 말씀드리자면,

346
00:14:52,100 --> 00:14:53,850
그래서, 특정한 것이 있습니다.
모두 사이의 연결

347
00:14:53,850 --> 00:14:55,470
이러한 다양한
상수, 그리고

348
00:14:55,470 --> 00:14:57,000
이것을 보관하는 것이 좋습니다
머리 뒤쪽에.

349
00:14:57,000 --> 00:14:59,417
때때로 당신은 보게 될 것입니다
다양한 표현들,

350
00:14:59,417 --> 00:15:02,220
실제로 거의 같은 것을 인코딩하는 것들입니다.
관계 그 자체, 간단히 말해서

351
00:15:02,220 --> 00:15:04,129
다른 언어로.

352
00:15:04,129 --> 00:15:06,840
물론, 이는 또한 다음을 의미합니다.
더 정확하게 말할 수 있도록 하기 위해서입니다.

353
00:15:06,840 --> 00:15:10,470
그래서 때때로 일정은 다음과 같습니다.
우리가 희소하다고 부르는 것.

354
00:15:10,470 --> 00:15:12,290
그래서 내 우주에서는
거의 모든 그래픽,

355
00:15:12,289 --> 00:15:15,529
내가 거래하는 사람
일상생활은 극히 드문 경우입니다.

356
00:15:15,529 --> 00:15:18,529
이것은 결과입니다
위상수학.

357
00:15:18,529 --> 00:15:20,750
그리고 왜냐하면
이것은 알고리즘입니다.

358
00:15:20,750 --> 00:15:22,789
이는 다음과 같이 확장됩니다.
갈비뼈의 개수,

359
00:15:22,789 --> 00:15:25,214
사실 훨씬 더 그럴 수 있어요
알고리즘보다 더 낫다.

360
00:15:25,215 --> 00:15:26,840
이는 다음과 같이 확장됩니다.
정점의 수

361
00:15:26,840 --> 00:15:28,910
정사각형, 왜냐하면
실제로는 종종

362
00:15:28,909 --> 00:15:32,329
갈비뼈가 더 적은 것보다
각각의 가능한 쌍.

363
00:15:32,330 --> 00:15:34,560
그래서

364
00:15:34,559 --> 00:15:37,189
우리는 생각한다
이 숫자들에 대해서요.

365
00:15:37,190 --> 00:15:40,550
좋아요, 계속해서 만들어 봅시다.
여기 지루한 정의들이 있습니다.

366
00:15:40,549 --> 00:15:42,559
그래서 다른 몇 가지가 있습니다.
우리는 생각해야 합니다.

367
00:15:42,559 --> 00:15:46,489
위상수학과 관련된 또는
우리 그래프의 연결성,

368
00:15:46,490 --> 00:15:49,279
특히, 생각하다
이웃에 관해서.

369
00:15:49,279 --> 00:15:52,399
그래서 종합적으로 우리는 이렇게 생각합니다.
정점 쌍

370
00:15:52,399 --> 00:15:54,090
이웃들
서로,

371
00:15:54,090 --> 00:15:55,940
둘 사이에 차이가 있다면.

372
00:15:55,940 --> 00:15:57,710
우리는 그래야만 한다
조금 조심스러워요.

373
00:15:57,710 --> 00:16:00,440
왜냐하면 당연히, ~에 있을 때
우리는 방향성 측면에서 유리한 위치에 있습니다.

374
00:16:00,440 --> 00:16:02,900
우리는 조심해야 합니다.
전송하는 사람,

375
00:16:02,899 --> 00:16:05,480
그리고 누가 얻게 되는가
이러한 이웃 관계.

376
00:16:05,480 --> 00:16:08,730
네, 그림을 그려요.
아주 아주 간단한 그래프입니다.

377
00:16:08,730 --> 00:16:13,129
자, 여기가 정점 0이고, 여기가
첫 번째 정점, 여기는 두 번째 정점입니다.

378
00:16:13,129 --> 00:16:17,570
그러면 어쩌면 우리가 유리한 위치에 서게 될지도 모릅니다.
갈비뼈는 위로 올라가고, 갈비뼈는 아래로 내려간다.

379
00:16:17,570 --> 00:16:21,470
그리고 나서 순환이 시작됩니다.

380
00:16:21,470 --> 00:16:22,700
좋은.

381
00:16:22,700 --> 00:16:24,980
이제 우리는 많은 것을 결정할 수 있습니다.
서로 다른 개념들

382
00:16:24,980 --> 00:16:27,289
이웃들 - 예를 들면
초기 이웃 집합,

383
00:16:27,289 --> 00:16:29,120
새로 들어오는 이웃들.

384
00:16:29,120 --> 00:16:30,799
핵심은 다음과 같습니다.
우리는 무엇인가

385
00:16:30,799 --> 00:16:34,039
우리는 다음과 같은 에지를 추적하고 싶습니다.
위에서 내려오는 것과 가장자리는

386
00:16:34,039 --> 00:16:35,629
하나의 전체를 가리킨다.

387
00:16:35,629 --> 00:16:37,909
예를 들면,
주말

388
00:16:37,909 --> 00:16:42,199
우리가 선택할 이웃들의 집합
여기에 Adj 플러스라고 표시하세요...

389
00:16:44,899 --> 00:16:49,036
휴일이란 무엇인가요?
여기서 노드 0의 이웃 노드 집합은 무엇인가요?

390
00:16:49,037 --> 00:16:50,870
음, 우리가 살펴보면,
참고하세요

391
00:16:50,870 --> 00:16:54,230
노드 0에서 하나의 간선이 나갑니다.
이는 노드 2를 가리킵니다.

392
00:16:54,230 --> 00:16:57,230
그래서 당연히 이것은
설정하세요

393
00:16:57,230 --> 00:16:59,389
다른 노드가 하나만 포함되어 있습니다.

394
00:16:59,389 --> 00:17:05,960
마찬가지로 들어오는
노드 0의 이웃 집합, 좋음

395
00:17:05,960 --> 00:17:09,539
참고로 하나가 있습니다.
정점 1에서 들어오는 이웃,

396
00:17:09,539 --> 00:17:14,180
이것이 바로 그러한 세트입니다.

397
00:17:14,180 --> 00:17:16,549
물론, 에서
무방향 그래프

398
00:17:16,549 --> 00:17:18,648
차이점
이 두 가지 사이에

399
00:17:18,650 --> 00:17:19,323
상관없어요.

400
00:17:19,323 --> 00:17:20,990
그러니까, 저희를 보시면
마지막 표시 지점

401
00:17:20,990 --> 00:17:22,910
여기에서, 종종
방향이 지정되지 않은 경우

402
00:17:22,910 --> 00:17:25,019
우리는 그냥 떨어뜨렸어요
위첨자 "플러스" 또는 "마이너스",

403
00:17:25,019 --> 00:17:28,068
왜냐하면 그것은
별로 중요하지 않다고 생각하는 모양입니다.

404
00:17:28,068 --> 00:17:31,190
어쨌든 하나는 있습니다.
용어의 추가적인 부분,

405
00:17:31,190 --> 00:17:33,890
충분한 것을 가지고 있는
매우 중요하며, 이것이 바로 그 정도입니다.

406
00:17:33,890 --> 00:17:35,780
그리고 그건 그게 아니에요
단순히 세는 것 외에는

407
00:17:35,779 --> 00:17:37,009
이 세트의 크기.

408
00:17:37,009 --> 00:17:38,910
따라서 외부적 정도는 다음과 같습니다.
갈비뼈의 개수,

409
00:17:38,910 --> 00:17:40,830
위쪽에서 나오는 것들입니다.

410
00:17:40,829 --> 00:17:44,149
그리고 그 학위는
안쪽으로 향하는 모서리의 개수.

411
00:17:44,150 --> 00:17:47,475
그러니 이 경우에는 다음 사항을 참고하세요.
이 두 숫자는 모두 1과 같습니다.

412
00:17:47,474 --> 00:17:49,099
예를 하나 들어보죠.
그렇지 않은 곳에서.

413
00:17:49,099 --> 00:17:53,159
따라서 노드 1에서 다음을 확인하세요.
두 개의 모서리가 얻어집니다.

414
00:17:53,160 --> 00:17:56,029
따라서 출력 정도는
노드 1은 2와 같습니다.

415
00:17:56,029 --> 00:18:01,420
한쪽 모서리가 가리키고 있습니다.
안쪽으로 향하므로 입력 전력은 1입니다.

416
00:18:01,420 --> 00:18:03,177
자, 그럼 우리는 왜 그렇게 자주 그럴까요?
우리가 이걸 할 건가요?

417
00:18:03,176 --> 00:18:05,259
그럼, 우리는 얻게 될 겁니다.
많은 그래프 알고리즘,

418
00:18:05,259 --> 00:18:07,660
FOR 루프를 가진
이웃들 위로

419
00:18:07,660 --> 00:18:08,750
봉우리.

420
00:18:08,750 --> 00:18:12,319
그런 다음
이 단계 수가 중요한 역할을 하게 될 것입니다.

421
00:18:12,319 --> 00:18:15,950
이러한 것들을 조금 제한하는 것이 좋습니다.
것들.

422
00:18:15,950 --> 00:18:20,049
특히 한 가지 말씀드리자면,
우리가 생각해 볼 수 있는 것들 -

423
00:18:23,609 --> 00:18:25,839
글씨를 너무 크게 써서,

424
00:18:25,839 --> 00:18:27,939
여기는 금방 공간이 부족해질 거예요.

425
00:18:27,940 --> 00:18:29,029
다음은 이것입니다.

426
00:18:29,029 --> 00:18:33,250
그럼 한번 살펴보겠습니다.
가능한 모든 노드

427
00:18:33,250 --> 00:18:35,577
내 일정표 안에,
자, 이제 시작해 봅시다

428
00:18:35,577 --> 00:18:36,744
그들의 학위를 모두 합산해 봅시다.

429
00:18:42,460 --> 00:18:43,759
그래서 저는--

430
00:18:43,759 --> 00:18:45,890
내가 할 수 있을지 한번 보자
이 차트를 살펴보겠습니다.

431
00:18:45,890 --> 00:18:49,940
나는 모서리가 세 개 있다는 것을 알아차릴 것이다.
이 꼭짓점에 인접한

432
00:18:49,940 --> 00:18:52,910
세 모서리가 인접해 있습니다.
저것과 그에 인접한 두 모서리.

433
00:18:52,910 --> 00:18:54,759
자, 그럼 이 모든 것을 종합해 보겠습니다.

434
00:18:54,759 --> 00:18:56,829
그래서 그냥 편리한 거죠.
연결 -

435
00:18:56,829 --> 00:18:58,159
이것들을 요약하면 다음과 같습니다.
우리가 가진 것들 때문에

436
00:18:58,160 --> 00:19:00,620
우리는 다음과 같은 알고리즘을 갖게 될 것입니다.
각 정점에 대해 다음과 같이 보일 것입니다.

437
00:19:00,619 --> 00:19:02,399
모든 이웃들이 뭔가를 하고 있네요.

438
00:19:02,400 --> 00:19:04,850
그러므로 우리는 대략적으로 알 수 있습니다.
얼마나 걸려요

439
00:19:04,849 --> 00:19:06,919
시간이 걸릴 겁니다.

440
00:19:06,920 --> 00:19:09,120
이 점에 대해 생각해 봅시다.

441
00:19:09,119 --> 00:19:10,474
그렇다면 우리가 알고 있는 것은 무엇일까요?

442
00:19:10,474 --> 00:19:14,029
방향 감각이 없는 상태에서
각 간선을 그래프로 나타내세요

443
00:19:14,029 --> 00:19:15,379
두 꼭짓점에 인접해 있습니다.

444
00:19:18,319 --> 00:19:20,539
자, 한번 생각해 봅시다.
우리가 어떻게 고려하는지에 대하여

445
00:19:20,539 --> 00:19:23,440
우리가 알고 있는 학위는 몇 점일까요?

446
00:19:23,440 --> 00:19:25,059
우리는 그것을 알고 있습니다
갈비뼈처럼

447
00:19:25,059 --> 00:19:29,470
정도에 영향을 미칩니다
서로 다른 두 개의 봉우리.

448
00:19:29,470 --> 00:19:35,259
그러므로 우리가 신중하게 생각해 보면
이것이 여기 있습니다.

449
00:19:35,259 --> 00:19:38,710
우리는 그것을 보게 될 것입니다
그래프가 무방향 그래프인 경우 --

450
00:19:43,069 --> 00:19:49,019
아, 죄송합니다. 맞아요.
잠깐, 나 다시 돌아왔어.

451
00:19:49,019 --> 00:19:53,059
만약 제가 다음과 같은 그래프를 가지고 있다면
두 개의 꼭짓점과 하나의 모서리,

452
00:19:53,059 --> 00:19:58,500
그리고 방향성이 없으니 주의하세요.
간선의 개수는 몇 개입니까?

453
00:19:58,500 --> 00:19:59,670
여기서는 1과 같습니다.

454
00:19:59,670 --> 00:20:02,580
각 도의 합은 얼마입니까?

455
00:20:02,579 --> 00:20:04,889
음, 1 더하기 1은 2죠.

456
00:20:04,890 --> 00:20:14,990
네, 여기 두 개 있어요.
내 일정이 체계적이지 않다면,

457
00:20:14,990 --> 00:20:20,900
그리고 E는 내 그래프입니다
제가 계산하는 것이라면, 지시된 것입니다.

458
00:20:20,900 --> 00:20:24,776
이것은 단지 시작점에 불과합니다.

459
00:20:24,776 --> 00:20:25,789
이해가 되시나요?

460
00:20:25,789 --> 00:20:27,831
저는 성공했다고 생각합니다.
이 문장을 완전히 망쳐버리다.

461
00:20:27,832 --> 00:20:29,280
그럼 다시 시도해 볼까요?

462
00:20:29,279 --> 00:20:32,180
그러니까, 만약 내가 오직 하나만 세면
모서리의 수를 나타내는

463
00:20:32,180 --> 00:20:34,250
각 꼭짓점에서,
그리고 나는 그것을 세어봅니다.

464
00:20:34,250 --> 00:20:36,559
모두의 뒤에
가능한 꼭짓점,

465
00:20:36,559 --> 00:20:37,889
그렇다면 두 가지 경우가 있습니다.

466
00:20:37,890 --> 00:20:40,220
한 사람은 지시를 받고,
다른 하나는 방향성이 없습니다.

467
00:20:40,220 --> 00:20:42,589
그래서 방향 감각이 없는 상태에서
2개를 얻는 경우,

468
00:20:42,589 --> 00:20:44,839
왜냐하면 거의 모든
가장자리는 동시에

469
00:20:44,839 --> 00:20:46,399
주말과 주말.

470
00:20:46,400 --> 00:20:48,140
그러면 1을 얻게 됩니다.
계수로서

471
00:20:48,140 --> 00:20:49,070
지시된 사건의 경우.

472
00:20:49,069 --> 00:20:50,210
이해가 되시나요?

473
00:20:50,210 --> 00:20:53,029
제가 그런 일을 해서 죄송합니다
내가 순간 망쳐버렸어.

474
00:20:53,029 --> 00:20:54,950
좋아요, 좋습니다.

475
00:20:54,950 --> 00:20:58,298
네, 이것은 다음과 같이 진행될 것입니다.
나중에 필요할 거예요.

476
00:20:58,298 --> 00:20:59,839
지금 우리는 ~에 대해 생각하고 있습니다.
물론 그래픽이죠.

477
00:20:59,839 --> 00:21:01,009
우리는 방금 돈을 썼습니다
지난 몇 주 동안

478
00:21:01,009 --> 00:21:02,305
데이터 구조에 대해 생각해 봅니다.

479
00:21:02,305 --> 00:21:04,680
우리는 어떻게 해야 할지 생각해 봐야 합니다.
일정을 컴퓨터에 저장하세요.

480
00:21:04,680 --> 00:21:06,720
그리고
선택지는 많습니다.

481
00:21:06,720 --> 00:21:10,039
사실, 정말로 한 가지
할 수 있어요, 한 쌍 같은 거예요.

482
00:21:10,039 --> 00:21:12,226
마치 우리가
세트에 대해 이야기했습니다.

483
00:21:12,227 --> 00:21:14,060
다양한 것들이 있습니다
세트를 저장하는 방법.

484
00:21:14,059 --> 00:21:16,339
그것에 대해 생각해 볼 수 있는 한 가지 방법은 다음과 같습니다.
이것에 관하여: 상황에 따라

485
00:21:16,339 --> 00:21:18,859
우리가 어떻게 상호작용할 것인지부터
이 세트를 이용하면 하나를 선택할 수 있습니다.

486
00:21:18,859 --> 00:21:21,829
또는 다른 데이터 구조,
최적화하기 위해

487
00:21:21,829 --> 00:21:24,589
우리가 하는 상호작용의 유형
이 세트로 우리는 얻게 될 것입니다.

488
00:21:24,589 --> 00:21:26,359
그리고 그렇게 만들도록
가능한 한 빨리.

489
00:21:26,359 --> 00:21:29,689
좋아요.
그래프도 마찬가지입니다.

490
00:21:29,690 --> 00:21:33,470
예를 들면,
세상에서 가장 멍청한 프레젠테이션

491
00:21:33,470 --> 00:21:36,529
그래프는 간단할 것입니다.
간선 목록이 길다.

492
00:21:36,529 --> 00:21:39,980
예를 들어,
이 그래프는 아마도

493
00:21:39,980 --> 00:21:44,930
나는 0, 1, 이것을 가지고 있다
가장자리, 그리고 0,

494
00:21:44,930 --> 00:21:50,930
2, 이것은 또 다른 이점입니다.
그다음 1, 2, 그리고 2, 1.

495
00:21:50,930 --> 00:21:52,340
갈비 종류 목록이 아주 많습니다.

496
00:21:52,339 --> 00:21:53,480
이건 정말 완벽한 세트네요.

497
00:21:53,480 --> 00:21:55,312
나는 질서에 신경 쓰지 않아.

498
00:21:55,311 --> 00:21:56,717
청중: 첫 번째는 1, 2입니다.

499
00:21:56,718 --> 00:21:58,259
저스틴 솔로몬: 1—
아, 맞아요.

500
00:21:58,259 --> 00:21:58,859
죄송합니다.

501
00:21:58,859 --> 00:22:00,629
네, 모서리가 위쪽을 향하고 있습니다.

502
00:22:00,630 --> 00:22:01,875
에릭, 고마워. 아니, 에릭, 괜찮아.

503
00:22:01,875 --> 00:22:02,375
제이슨.

504
00:22:05,109 --> 00:22:08,407
좋아요, 제가 가지고 있다고 가정해 봅시다.
그래프 알고리즘입니다.

505
00:22:08,407 --> 00:22:09,949
그리고 나
뭔가를 해야 할 것이다

506
00:22:09,950 --> 00:22:13,100
예를 들면,
v에서 오는 모서리가 있습니다.

507
00:22:13,099 --> 00:22:14,269
w를 여러 번.

508
00:22:16,789 --> 00:22:19,379
얼마나 걸리나요?
이 데이터 구조에서 어떤 역할을 할까요?

509
00:22:19,380 --> 00:22:22,850
음, 만약 내가 그냥
정렬되지 않은 간선 목록,

510
00:22:22,849 --> 00:22:25,250
그리고 저는 알고 싶습니다.
v에서 w로 향하는 모서리가 있습니다.

511
00:22:25,250 --> 00:22:28,605
내가 할 수 있는 건 글쓰는 것뿐이야.
이것을 따라가는 FOR 루프

512
00:22:28,605 --> 00:22:30,480
그리고는 "여기 있습니다"라고 말합니다.
저는 우위를 점하려고 합니다.

513
00:22:30,480 --> 00:22:30,890
아니요.

514
00:22:30,890 --> 00:22:31,880
이것은 다음과 같은 이점이 있습니다.
제가 찾고 있는 것은 무엇인가요?

515
00:22:31,880 --> 00:22:32,645
아니요.

516
00:22:32,644 --> 00:22:35,359
매번 내가
나는 경쟁 우위를 확보하고 싶다.

517
00:22:35,359 --> 00:22:37,932
시간이 걸릴 것입니다
시간, 비례

518
00:22:37,932 --> 00:22:39,349
수량
내 그래프의 가장자리,

519
00:22:39,349 --> 00:22:42,019
잠재적으로
v 제곱이 됩니다.

520
00:22:42,019 --> 00:22:44,599
네, 그런 건 아니에요.
훌륭한 프레젠테이션

521
00:22:44,599 --> 00:22:47,351
내 컴퓨터의 그래픽.

522
00:22:47,352 --> 00:22:49,310
자, 한번 생각해 봅시다.
데이터 구조에 대해 설명드리겠습니다.

523
00:22:49,309 --> 00:22:52,129
우리는 이렇게 말할 수 있습니다: 좋습니다, 그럼 제한 목록은 다음과 같습니다.
아마 잘못된 방법일 겁니다.

524
00:22:52,130 --> 00:22:53,780
단, 다음 사항에 유의하십시오.
앞서 언급했듯이,

525
00:22:53,779 --> 00:22:56,750
스케줄이란 무엇인가요?
제한 목록처럼 보이네요.

526
00:22:56,750 --> 00:22:59,869
하지만 어쨌든,
가장 흔한 것

527
00:22:59,869 --> 00:23:03,750
무언가를 창조하는 것은
샘플 인접 목록.

528
00:23:03,750 --> 00:23:08,359
요컨대, 핵심은 이렇습니다.
인접 목록

529
00:23:08,359 --> 00:23:18,709
제가 계속 유지할 거라는 뜻입니다.
정점을 나타내는 집합

530
00:23:18,710 --> 00:23:24,465
u는 u에 인접한 모든 것과 연결됩니다.

531
00:23:24,464 --> 00:23:25,839
다시 말해서,
나 지금 가는 중이야.

532
00:23:25,839 --> 00:23:27,464
모두를 따라가다
출력 에지

533
00:23:27,464 --> 00:23:29,829
각 꼭짓점에서.

534
00:23:29,829 --> 00:23:33,641
이제 나는 어떻게 할지 결정해야 한다
이 물건은 제가 가지겠습니다.

535
00:23:33,642 --> 00:23:35,100
그리고 종종
우리는 해야 할 것이다

536
00:23:35,099 --> 00:23:37,349
예를 들어, 다음과 같은 질문에 답하십시오.
v에서 오는 모서리가 있습니다.

537
00:23:37,349 --> 00:23:38,521
w에게.

538
00:23:38,521 --> 00:23:39,480
그렇다면 제가 어떻게 그렇게 할 수 있을까요?

539
00:23:39,480 --> 00:23:43,140
첫째, 저는
저는 v를 찾고 있는데, v를 얻었습니다.

540
00:23:43,140 --> 00:23:44,958
목록 또는
모든 것의 집합체,

541
00:23:44,958 --> 00:23:47,250
v에 인접한 것들. 그리고
이건 꼭 물어봐야겠어요.

542
00:23:47,250 --> 00:23:49,109
그리고 저는 그게 꽤 빨리 끝났으면 좋겠어요.

543
00:23:49,109 --> 00:23:54,990
그래서 아마도,
저는 세트를 저장하고 있습니다.

544
00:23:54,990 --> 00:24:00,990
관련 자료는 다음과 같습니다.
랜덤 액세스 배열과 같은 것

545
00:24:00,990 --> 00:24:07,500
또는 해시 테이블
빠른 검색.

546
00:24:14,869 --> 00:24:17,122
예를 들어, 얼마나
시간이 걸릴 겁니다.

547
00:24:17,123 --> 00:24:19,039
알겠습니다, 그럼 가보죠.
여기서 문장을 완성하세요.

548
00:24:19,039 --> 00:24:20,456
얼마나 걸려요
확인하려면 그게 필요해요.

549
00:24:20,457 --> 00:24:22,213
내 그래프에 간선이 존재합니까?

550
00:24:22,212 --> 00:24:23,129
음, 나라면 어떻게 하겠어?

551
00:24:23,130 --> 00:24:24,680
저는 먼저
이 물건을 꺼냈습니다.

552
00:24:24,680 --> 00:24:26,720
그러고 나서 저는 살펴보겠습니다.
여기서부터 안쪽으로.

553
00:24:26,720 --> 00:24:28,490
그래서 만약 내가 이걸 계속 가지고 있다면
해시 테이블로서,

554
00:24:28,490 --> 00:24:31,099
그게 제가 예상하는 시간입니다.
검색 주문이 하나 있을 것입니다.

555
00:24:31,099 --> 00:24:32,689
왜냐하면 그것은
하나 주문하고, 그 다음에는

556
00:24:32,690 --> 00:24:34,890
주문이 다릅니다
한 번의 검색.

557
00:24:34,890 --> 00:24:38,580
그래서 우리는 v 제곱에서 ~로 넘어갔습니다.
하나의 간단한 기술을 사용하여 장치를 구성합니다.

558
00:24:38,579 --> 00:24:39,326
예?

559
00:24:39,326 --> 00:24:42,222
청중: 그게 중요한가요?
방향 [필수]

560
00:24:42,222 --> 00:24:43,889
저스틴 솔로몬: 이것은
훌륭한 질문입니다.

561
00:24:43,890 --> 00:24:45,307
자, 이분이 디자이너입니다.
결정.

562
00:24:45,307 --> 00:24:48,110
죄송합니다, 제 머릿속에서는...
저는 무방향 그래프에 대해 많이 생각합니다.

563
00:24:48,109 --> 00:24:49,817
그리고 저는 갈 거예요
이런 실수를 자주 저지릅니다.

564
00:24:49,817 --> 00:24:51,259
그리고 저를 잡아주셔서 정말 다행이에요.

565
00:24:51,259 --> 00:24:52,968
꽤 있습니다
똑똑한 일이네요.

566
00:24:52,968 --> 00:24:55,670
아마도 이것은 다음과 같은 것으로 구성됩니다.
트랙 출력 에지

567
00:24:55,670 --> 00:24:56,687
각 정점에 대해.

568
00:24:56,686 --> 00:24:57,769
이는 설계상의 결정입니다.

569
00:24:57,769 --> 00:24:59,690
알고리즘의 경우,
어쩌면 내가 원하는 걸지도 몰라

570
00:24:59,690 --> 00:25:00,972
들어오는 에지를 모니터링합니다.

571
00:25:00,972 --> 00:25:02,389
그게 뭐든 간에, 난 그냥
반드시 확인해야 합니다

572
00:25:02,390 --> 00:25:05,580
그가 내 의견에 동의한다는 것
나중에 제 일정에 맞춰서 하고 싶어요.

573
00:25:05,579 --> 00:25:06,990
아주 좋은 지적입니다.

574
00:25:06,990 --> 00:25:10,519
죄송하지만 저희는 기하학적인 사람들이라서요.
우리는 방향성을 가진 사람들을 거의 만나지 않습니다.

575
00:25:10,519 --> 00:25:11,539
그래프.

576
00:25:11,539 --> 00:25:13,700
하지만 그것은 중요합니다
기억하다,

577
00:25:13,700 --> 00:25:16,870
모두가 참여하고 있는 것은 아닌 것
저와 같은 문제를 겪고 있습니다.

578
00:25:16,869 --> 00:25:20,629
좋아요, 이제 제가 만약 ~하고 싶다면
이 문제에 대해서는 절대적으로 극단적입니다.

579
00:25:20,630 --> 00:25:22,683
세 번째 예시로 들자면
대표,

580
00:25:22,682 --> 00:25:24,099
사실,
어떤 의미에서는,

581
00:25:24,099 --> 00:25:25,724
다음과 같이 상상할 수 있습니다.
인접 목록 --

582
00:25:25,724 --> 00:25:28,339
인접 행렬이 필요합니다.
제가 지금 보관하고 있는 곳

583
00:25:28,339 --> 00:25:32,089
거대한 v x v 배열
이것이 존재하나요?

584
00:25:32,089 --> 00:25:33,779
그러한 경계선이 존재할까요?

585
00:25:33,779 --> 00:25:38,670
이제는 정말 정말 쉬워요
간선이 존재하는지 확인합니다.

586
00:25:38,670 --> 00:25:41,045
하지만 이제 내가
그래프 알고리즘을 만들었습니다.

587
00:25:41,045 --> 00:25:42,420
가질 것이다
FOR 루프를 사용하여 모두

588
00:25:42,420 --> 00:25:45,470
어떤 정점의 이웃들.

589
00:25:45,470 --> 00:25:49,900
그래서 만약 제가 통과하고 싶다면
당신의 모든 이웃에 대해,

590
00:25:49,900 --> 00:25:51,400
제가 해드릴 수 있어요
시간, 비례

591
00:25:51,400 --> 00:25:54,300
이웃 수 u.

592
00:25:54,299 --> 00:25:56,129
하지만 만약 제가 방금
대규모 인접 행렬,

593
00:25:56,130 --> 00:25:59,760
그냥 이진 값들의 집합일 뿐입니다.
각 꼭짓점 쌍에 대해, 또는

594
00:25:59,759 --> 00:26:02,609
이 봉우리들은 무엇인가요?
인접해 있습니까? 예 또는 아니오.

595
00:26:02,609 --> 00:26:04,719
반복하고 싶다면
나의 모든 이웃들에게,

596
00:26:04,720 --> 00:26:07,110
이제 가야겠어요
모든 봉우리에서

597
00:26:07,109 --> 00:26:10,131
그리고 이것이 숫자인지 확인하세요
첫째, 그리고 나서 뭔가를 하세요.

598
00:26:10,132 --> 00:26:12,090
그래서 실제로 가능합니다
추가 시간이 필요합니다

599
00:26:12,089 --> 00:26:13,199
그리고 추가 공간.

600
00:26:13,200 --> 00:26:16,450
이해가 되시나요?

601
00:26:16,450 --> 00:26:18,930
어쨌든 이것은
게으른 백작처럼

602
00:26:18,930 --> 00:26:19,680
.

603
00:26:19,680 --> 00:26:22,259
저는 코딩할 때 자주 사용합니다.
인접 행렬을 사용하면

604
00:26:22,259 --> 00:26:23,160
함께 일하기 편합니다.

605
00:26:23,160 --> 00:26:25,407
하지만 많은 노력이 필요합니다.
추가 공간,

606
00:26:25,406 --> 00:26:27,240
그리고 그것이 항상 가장 효과적인 방법은 아닙니다.

607
00:26:27,240 --> 00:26:29,460
공간이 있더라도,
반복 때문에

608
00:26:29,460 --> 00:26:32,700
이웃들은 실제로
시간이 꽤 오래 걸립니다.

609
00:26:32,700 --> 00:26:35,250
좋아, 진짜 목표는 뭐야?
오늘 강의의 주제는 다음과 같습니다.

610
00:26:35,250 --> 00:26:37,980
알아가기 시작하세요
정전적 문제, ~에 관하여

611
00:26:37,980 --> 00:26:39,900
우리 모두가 걱정하는 것
그래프에 관해서 말씀드리자면,

612
00:26:39,900 --> 00:26:43,383
즉, 경로 계산,
특히 최단 경로.

613
00:26:43,383 --> 00:26:45,299
그래서 우리가 제일 먼저 할 일은
당연히 해야죠.

614
00:26:45,299 --> 00:26:48,579
경로란 무엇인지 정의하십시오.
그래프에서.

615
00:26:48,579 --> 00:26:51,569
그럼 우리는 ~에 대해 이야기해 보겠습니다.
우리의 일정은 마치 도로망과 같습니다.

616
00:26:51,569 --> 00:26:54,659
각각에 대해 생각해 봅시다.
여기서 노드는 교차점과 같습니다.

617
00:26:54,660 --> 00:26:56,970
그러니까 대략적인 금액은 다음과 같습니다.
켄달 스퀘어.

618
00:26:56,970 --> 00:26:59,519
봐, 정사각형이잖아.

619
00:26:59,519 --> 00:27:04,049
하지만 어쨌든,
제가 찾고 싶은 게...라고 가정해 봅시다.

620
00:27:04,049 --> 00:27:05,849
어쩌면 질문일지도
다음과 같을 것입니다: 또는

621
00:27:05,849 --> 00:27:08,969
그곳에 가는 방법이 있습니다
1번 정점에서 3번 정점까지?

622
00:27:08,970 --> 00:27:10,380
그러면 더 나아질 거예요.
질문을 하다, ~인지

623
00:27:10,380 --> 00:27:12,870
존재한다
정점 1에서 가는 지름길

624
00:27:12,869 --> 00:27:13,646
상위 3위까지.

625
00:27:13,646 --> 00:27:15,480
그렇다면 당연히,
제가 제일 먼저 해야 할 일은

626
00:27:15,480 --> 00:27:16,440
그것은 적을 식별하는 것입니다.

627
00:27:16,440 --> 00:27:19,380
나는 다음과 같이 결정했다.
제가 찾고 있는 것은 바로 그 길입니다.

628
00:27:19,380 --> 00:27:23,130
그러므로 그 경로는 그 이상도 이하도 아닙니다.
그래프의 정점 순서,

629
00:27:23,130 --> 00:27:26,280
인접한 각 쌍에서
이 시퀀스의 꼭짓점

630
00:27:26,279 --> 00:27:27,559
그것은 이점입니다.

631
00:27:27,559 --> 00:27:29,309
이 모든 것이 일관성이 있다고 생각합니다.
우리의 직관으로

632
00:27:29,309 --> 00:27:31,359
그래프에서 경로가 무엇인지에 관하여.

633
00:27:31,359 --> 00:27:35,369
예를 들어, 여기에서
경로 p는 v1, v2, v3와 같습니다.

634
00:27:35,369 --> 00:27:38,309
그러니 다음 사항을 참고하세요.
v1에서 v2로의 에지

635
00:27:38,309 --> 00:27:40,019
그리고 v2에서 v3로 넘어가는 과정에서의 차이점도 있습니다.

636
00:27:40,019 --> 00:27:45,599
그러므로, 이는 가정을 만족시킨다.
저희 정의에 명시되어 있습니다.

637
00:27:45,599 --> 00:27:47,369
그렇지 않았을 것
참고로 저희 일정표에는...

638
00:27:47,369 --> 00:27:51,899
v1과 v3에 유사할 것입니다.
거기에는 경계선이 없기 때문입니다.

639
00:27:51,900 --> 00:27:55,110
그러니까, 우리가 ~에 대해 이야기하고 있다면
즉, 여러 가지 방법이 있다는 거죠.

640
00:27:55,109 --> 00:27:58,406
아주 자연스러운 개념입니다.
길이는 얼마인가요?

641
00:27:58,406 --> 00:28:00,990
길이는 생각해 볼 수 있을 것 같습니다.
정점의 개수로

642
00:28:00,990 --> 00:28:03,870
경로에서 마이너스 1
또는 모서리의 개수,

643
00:28:03,869 --> 00:28:05,099
당신의 길을 가로지르는 것.

644
00:28:05,099 --> 00:28:06,959
똑같아요.

645
00:28:06,960 --> 00:28:10,485
예를 들어, 길이
여기서 경로 p는 2와 같습니다.

646
00:28:10,484 --> 00:28:12,359
모두들 이걸 보고 있나요?

647
00:28:12,359 --> 00:28:14,969
매우 흔한 코딩 오류 중 하나는 다음과 같습니다.
제가 자주 접하는 상황입니다.

648
00:28:14,970 --> 00:28:18,750
이 값에 임의로 1을 더한 값입니다.
숫자.

649
00:28:18,750 --> 00:28:21,309
당연히 그렇죠.
가는 길에 봉우리 하나만 더 남았습니다.

650
00:28:21,309 --> 00:28:23,690
갈비뼈보다.

651
00:28:23,690 --> 00:28:25,730
네, 바로 이거죠.
다양한 -

652
00:28:25,730 --> 00:28:28,511
잠재적으로 가능할 수 있습니다
한 가지 이상의 방법

653
00:28:28,511 --> 00:28:29,720
임의의 두 정점 사이.

654
00:28:29,720 --> 00:28:33,470
자, 제가 가지고 있다고 가정해 봅시다.
무방향 그래프, 즉

655
00:28:33,470 --> 00:28:35,100
이렇게 생겼습니다.

656
00:28:35,099 --> 00:28:37,879
그러니까 그냥 정사각형이에요.
대각선을 더합니다.  그러므로,

657
00:28:37,880 --> 00:28:39,365
여기에 노드들이 있습니다.

658
00:28:42,109 --> 00:28:44,599
그러므로 그것은 완전히 옳습니다.
참고로 왼쪽 아래 모서리부터

659
00:28:44,599 --> 00:28:47,757
오른쪽 위 모서리는 다음과 같습니다.
하나씩 차례대로 올라가기 위해,

660
00:28:47,758 --> 00:28:49,549
물론 있죠
보다 효율적인 방법

661
00:28:49,549 --> 00:28:51,716
왼쪽 아래 모서리에서 손을 뻗으세요
오른쪽 위로,

662
00:28:51,717 --> 00:28:54,667
즉, 대각선으로 이동하십시오.

663
00:28:54,666 --> 00:28:56,500
그래서 우리가 이야기할 때
최단 경로에 관해서,

664
00:28:56,500 --> 00:28:57,875
이것은 그 이상도 이하도 아닙니다.
길이로

665
00:28:57,875 --> 00:28:59,920
그 경로는
가장 적은 수의 간선

666
00:28:59,920 --> 00:29:05,289
또는 임의의 쌍 사이의 꼭짓점
내 그래프의 정점들.

667
00:29:05,289 --> 00:29:06,460
좋아, 이 녀석이 우리의 적이다.

668
00:29:06,460 --> 00:29:07,501
이것이 바로 우리가 추구하는 바입니다.

669
00:29:07,501 --> 00:29:11,690
이것은 최단 경로 계산입니다.
그래프의 정점들 사이.

670
00:29:11,690 --> 00:29:14,259
이게 전부입니다.
우리는 이에 대해 충분히 이야기할 것입니다.

671
00:29:14,259 --> 00:29:15,134
이 강좌에는 이야기할 거리가 많습니다.

672
00:29:15,134 --> 00:29:17,134
당연히 그렇죠.
매우 현실적인 문제입니다.

673
00:29:17,134 --> 00:29:19,180
예를 들어, 내가 원할 때
라우팅 문제를 해결합니다.

674
00:29:19,180 --> 00:29:20,900
저는 소포를 옮기고 싶습니다.
내 네트워크에서,

675
00:29:20,900 --> 00:29:23,350
저는 그러고 싶지 않아요. 음,
만약 제가 Tor를 사용하지 않는다면--

676
00:29:23,349 --> 00:29:27,039
나는 그들이 잡히지 않기를 바란다.
그들 사이에 컴퓨터가 너무 많다.

677
00:29:27,039 --> 00:29:28,990
그럼 나도 원할지도 몰라
컴퓨터 최단 경로.

678
00:29:28,990 --> 00:29:33,910
표면적으로는 어쩌면 내가
정보를 이동시키고 싶습니다.

679
00:29:33,910 --> 00:29:36,190
그리 멀지 않아요.

680
00:29:36,190 --> 00:29:38,140
하지만 물론 있죠.
다양한 변형

681
00:29:38,140 --> 00:29:40,990
우리가 이 주제에 대해 이야기할 때
우리는 최단 경로에 대해 이야기하고 있습니다.

682
00:29:40,990 --> 00:29:42,870
또는 심지어 ~에 대해서
경로의 존재.

683
00:29:42,869 --> 00:29:44,979
그래서, 세 명입니다.
모델 문제의 유형,

684
00:29:44,980 --> 00:29:47,480
그래프 상에서 풀 수 있는 문제입니다.

685
00:29:47,480 --> 00:29:50,089
자, 첫 번째는,
어느 것

686
00:29:50,089 --> 00:29:52,359
우리는 당연히 그렇게 부릅니다.
한 쌍의 손이 닿는 곳에,

687
00:29:52,359 --> 00:29:54,309
그것은 다음과 같은 생각일 것이다
나는 두 개의 꼭짓점을 취한다.

688
00:29:54,309 --> 00:29:58,720
그리고 그래프 g에서 t,
그리고 저는 당신에게 묻습니다.

689
00:29:58,720 --> 00:30:01,794
s와 t 사이에는 경로가 있습니다.

690
00:30:01,794 --> 00:30:04,009
그래서, 그게 뭐였든 간에,
극단적인 예,

691
00:30:04,009 --> 00:30:07,670
이 문제는 언제 발생하나요?
항상 그런 건 아니에요

692
00:30:07,670 --> 00:30:09,265
"예"라고 대답합니까?

693
00:30:09,265 --> 00:30:11,390
무슨 이유인지 모르겠지만 우리 머릿속에서는 나는
모든 그래프를 고려해야 한다고 생각합니다.

694
00:30:11,390 --> 00:30:13,250
동점.

695
00:30:13,250 --> 00:30:15,839
하지만 그래프는 완전히 정확합니다.
우리가 정의한 대로,

696
00:30:15,839 --> 00:30:19,712
10개를 가질 것이다
꼭짓점만 있고 모서리는 없습니다.

697
00:30:19,712 --> 00:30:21,379
이 함수
코딩하기는 매우 쉬울 것입니다.

698
00:30:21,380 --> 00:30:23,930
만약 그것이 유일한 것이었다면
지금까지 당신이 관심을 가졌던 그래프.

699
00:30:23,930 --> 00:30:26,560
하지만 어떤 경우든,
경로의 존재 –

700
00:30:26,559 --> 00:30:28,309
이것은 요청입니다.
약간의 것이 필요한

701
00:30:28,309 --> 00:30:29,309
알고리즘적 사고.

702
00:30:29,309 --> 00:30:32,950
아직 해결책을 찾지 못했어요.
어떻게 하는가

703
00:30:32,950 --> 00:30:35,450
자, 이제 우리가 해결할 수 있는 또 다른 문제가 있습니다.
— 최단 경로.

704
00:30:35,450 --> 00:30:37,670
주어진 그래프와
두 개의 봉우리, 우리는

705
00:30:37,670 --> 00:30:41,150
두 사람이 얼마나 떨어져 있는지 알 수 있습니다.
내 그래프의 이러한 정점들,

706
00:30:41,150 --> 00:30:43,910
사용하고 싶다면
한 곳에서 가장 짧은 거리

707
00:30:43,910 --> 00:30:45,650
다른 사람에게.

708
00:30:45,650 --> 00:30:49,250
참고로 저는 두 번째 방법을 사용할 수 있습니다.
첫 번째 문제를 해결해야 합니다.

709
00:30:49,250 --> 00:30:51,200
왜냐하면 무엇
가장 짧은 것의 길이

710
00:30:51,200 --> 00:30:55,600
두 정점 사이의 경로,
그 사이에는 길이 없는 건가요?

711
00:30:55,599 --> 00:30:57,699
무한대 아니면 어깨를 으쓱하는 것 –
그것

712
00:30:57,700 --> 00:30:58,720
아주 합리적인 답변입니다.

713
00:30:58,720 --> 00:31:00,730
네, 맞습니다.

714
00:31:00,730 --> 00:31:03,759
그렇다면 어떻게 구현할 수 있을까요?
접근성 코드인가요?

715
00:31:03,759 --> 00:31:05,680
음, 제가 전화할 수도 있겠네요.
최단 경로의 코드,

716
00:31:05,680 --> 00:31:07,029
그리고 그것이 내게 무한을 준다.

717
00:31:07,029 --> 00:31:08,990
그럼 저는 아니라고 답하겠습니다.
이 서비스는 이용할 수 없습니다.

718
00:31:08,990 --> 00:31:12,250
그리고 만약 그것이 내게 아무것도 주지 않는다면
무한대, 나는 '예'라고 답합니다.

719
00:31:12,250 --> 00:31:14,916
그러니 핵심을 기억하세요.
알고리즘 수업에서 나온 아이디어

720
00:31:14,916 --> 00:31:16,000
축소라는 개념이 있습니다.

721
00:31:16,000 --> 00:31:19,190
이걸 어디에 쓸 수 있을까요?
다른 문제를 해결하기 위한 함수.

722
00:31:19,190 --> 00:31:21,259
그래서 우리가 할 수 있다면
최단 경로를 구하기 위해,

723
00:31:21,259 --> 00:31:23,890
그렇다면 우리는 확실히 해결할 수 있습니다.
접근성 문제,

724
00:31:23,890 --> 00:31:26,620
이 코드 부분을 호출합니다.

725
00:31:26,619 --> 00:31:30,129
그리고 마침내 우리는 이야기를 나눌 수 있습니다.
한 출발점에서 출발하는 최단 경로에 관하여

726
00:31:30,130 --> 00:31:30,730
.

727
00:31:30,730 --> 00:31:35,220
그러니 다음 사항을 참고하세요.
입력 노드는 하나뿐입니다.

728
00:31:35,220 --> 00:31:37,019
그러므로 이 과제
나에게 주는 것은

729
00:31:37,019 --> 00:31:38,789
길이
s에서 출발하는 최단 경로

730
00:31:38,789 --> 00:31:42,492
서로에게
내 그래프의 정점들.

731
00:31:42,492 --> 00:31:43,409
이해가 되시나요?

732
00:31:43,410 --> 00:31:46,230
어쩌면 저는 큰 물건을 반품하는 걸지도 몰라요.
모든 정보가 담긴 배열

733
00:31:46,230 --> 00:31:49,690
모든 최단 거리.

734
00:31:49,690 --> 00:31:52,650
그럼, 하나 풀어볼 수 있을까요?
두 개의 최단 경로를 사용하여

735
00:31:52,650 --> 00:31:56,120
한 출발점에서 출발하는 최단 경로는 무엇일까요?

736
00:31:56,119 --> 00:31:57,109
전적으로.

737
00:31:57,109 --> 00:32:01,579
나는 내 안에 s를 넣을 수 있다
한 쌍의 경로를 사용하는 최단 경로 문제

738
00:32:01,579 --> 00:32:04,934
에서 최단 경로를 계산하세요
다른 모든 것에 대해,

739
00:32:04,934 --> 00:32:07,559
그리고 나서 이 모든 것을 버리세요
가장 짧은 정보를 제외한 모든 정보

740
00:32:07,559 --> 00:32:10,049
잘 다녀왔고, 이제 괜찮아요.

741
00:32:10,049 --> 00:32:13,349
나는 그것을 정당화하지 않았다
이것이 가능한 가장 빠른 방법입니다.

742
00:32:13,349 --> 00:32:14,759
해결 방법
두 번째 문제는,

743
00:32:14,759 --> 00:32:17,369
하지만 적어도 그것은 그것을 보여줍니다.
만약 제가 3번 문제를 풀 수 있다면,

744
00:32:17,369 --> 00:32:19,571
저는 2번 문제도 풀 수 있습니다.

745
00:32:19,571 --> 00:32:21,779
두 개로 풀 수 있다면,
저도 문제 하나를 해결할 수 있습니다.

746
00:32:21,779 --> 00:32:24,029
그래서 오늘
우리는 강의에만 신경 쓸 거예요.

747
00:32:24,029 --> 00:32:25,603
세 번째 문제에 관해서입니다.

748
00:32:25,603 --> 00:32:27,269
즉, 이것들은
것들

749
00:32:27,269 --> 00:32:31,389
목록에 있는
복잡성이 증가하는 순서대로.

750
00:32:31,390 --> 00:32:34,810
자, 그럼 문제를 생각해 봅시다.
단일 출발점에서 출발하는 최단 경로

751
00:32:34,809 --> 00:32:37,480
우리는 만들겠습니다
추가 구조물 하나.

752
00:32:37,480 --> 00:32:41,529
그리고 이것은 다음과 같은 아이디어입니다.
최단 경로 트리.

753
00:32:41,529 --> 00:32:44,289
그림 그리기가 너무 귀찮았어요.
어제 새벽 2시에 파워포인트 슬라이드를 봤어요.

754
00:32:44,289 --> 00:32:48,230
그리고 대신에 생각했다
칠판에 그림을 그려 보세요.

755
00:32:48,230 --> 00:32:52,940
그럼 그래프를 그려봅시다.

756
00:32:52,940 --> 00:32:56,140
자, 이제부터 a와 b가 있습니다.

757
00:32:56,140 --> 00:32:58,030
저는 글자를 사용하겠습니다.
숫자 대신에

758
00:32:58,029 --> 00:33:01,329
노드를 표시하기 위해,
나는 그러고 싶지 않아서

759
00:33:01,329 --> 00:33:03,129
길이를 혼동하다
최단 경로

760
00:33:03,130 --> 00:33:06,440
내 노드의 인덱스와 함께.

761
00:33:06,440 --> 00:33:08,320
자, 여기 a, b, c가 있습니다--

762
00:33:08,319 --> 00:33:10,319
저는 비교해 보겠습니다.
여기에 메모를 남겨주세요.

763
00:33:10,319 --> 00:33:14,724
디, 이, 프.

764
00:33:17,309 --> 00:33:19,815
일정은 다음과 같습니다.
다시 방향 감각을 잃었다.

765
00:33:19,815 --> 00:33:22,440
선생님이 좋아하시기 때문에
무방향 그래프를 생각해 보세요.

766
00:33:22,440 --> 00:33:24,231
하지만 저는 알고 있습니다
저는 제가 받을 피드백을 받게 될 것입니다.

767
00:33:24,231 --> 00:33:26,109
나중에 그러지 말았어야 했어요.

768
00:33:26,109 --> 00:33:27,569
하지만 어쨌든,
내가

769
00:33:27,569 --> 00:33:29,819
최단 경로를 계산하고 싶습니다.
A에서 모든 것으로 가는 길

770
00:33:29,819 --> 00:33:31,534
다른 하나는, 혹은 길이입니다.

771
00:33:31,535 --> 00:33:33,910
우선, 심지어
알고리즘에 대해 말하자면,

772
00:33:33,910 --> 00:33:35,785
제 생각엔 꽤 쉬울 것 같아요.
무엇인지 맞춰보세요.

773
00:33:35,785 --> 00:33:39,240
그러므로 최단 경로는 명백합니다.
a에서 a까지의 길이는 0입니다.

774
00:33:39,240 --> 00:33:42,359
가장 짧은 길이는
b까지의 거리는 1이고, a에서 c까지의 거리는 2입니다.

775
00:33:42,359 --> 00:33:43,919
내가 이 사람들을 감시할 수 있으니까요.

776
00:33:43,920 --> 00:33:45,039
이제부터 상황이 복잡해집니다.

777
00:33:45,039 --> 00:33:47,250
그것은 분기되어 있습니다.

778
00:33:47,250 --> 00:33:52,694
따라서 다음으로 짧은 경로는 다음과 같습니다.
길이는 3이고, 그 다음에는 이렇게 4입니다.

779
00:33:52,694 --> 00:33:54,569
모두 동의하시나요?
나와 함께, 어떤 숫자들, 어떤

780
00:33:54,569 --> 00:33:56,653
네, 제가 여기를 꾸몄어요.
가장 짧은 것의 길이

781
00:33:56,653 --> 00:33:58,589
A에서 다른 모든 것으로 가는 경로는 무엇일까요?

782
00:34:01,519 --> 00:34:03,879
그렇다면 내가 하지 않은 일은 무엇일까요?

783
00:34:03,880 --> 00:34:06,430
나는 방법을 알려주지 않았어.
실제로 경로를 계산합니다.

784
00:34:06,430 --> 00:34:09,730
방금 당신에게 드렸어요
경로의 길이.

785
00:34:09,730 --> 00:34:12,340
그래서 저는 조각이 필요할 수도 있습니다.
코드에는 정의하는 것 외에도 추가적으로 포함되어 있습니다.

786
00:34:12,340 --> 00:34:15,550
한 소스까지의 최단 경로의 길이,

787
00:34:15,550 --> 00:34:19,989
또한 나에게 준다
단일 소스에 이르는 최단 경로.

788
00:34:19,989 --> 00:34:22,460
우선, 제가 생각할 때
이건 제가 생각해 볼 수 있어요.

789
00:34:22,460 --> 00:34:25,420
자, 저는 잘 지내고 있을까요?
데이터 구조를 작성하세요

790
00:34:25,420 --> 00:34:28,059
이 모든 경로를 저장할 수 있습니다.

791
00:34:28,059 --> 00:34:31,059
음, 모든 길에는 나름의 장점이 있을 수 있죠.
v개의 정점처럼 말이죠.

792
00:34:31,059 --> 00:34:33,255
아마도,
어떤 이유로든

793
00:34:33,255 --> 00:34:34,880
내 그래프에는 많은 분기점이 있습니다.

794
00:34:34,880 --> 00:34:36,730
그리고 모든 방법들
아주 길다.

795
00:34:36,730 --> 00:34:38,409
사실, 저는 제가
생각해야 해,

796
00:34:38,409 --> 00:34:40,929
또는 분기
길이를 더 길게 또는 더 짧게 만들 수 있습니다.

797
00:34:40,929 --> 00:34:44,414
하지만 어쨌든 나는 그렇게 할 수 있었을 것이다
정말 지루한 데이터 구조,

798
00:34:44,414 --> 00:34:45,789
이는 오직 다음을 위한 것입니다
각각의 꼭짓점

799
00:34:45,789 --> 00:34:51,570
가장 짧은 트랙
a에서 이 정점까지의 경로.

800
00:34:51,570 --> 00:34:54,210
얼마나 큰지
이 데이터 구조는 무엇일까요?

801
00:34:54,210 --> 00:34:56,730
음, 만약 제가 가진 유일한 제약이 있다면
제가 가지고 있는 경로의 길이는 다음과 같습니다.

802
00:34:56,730 --> 00:34:58,215
무엇--

803
00:34:58,215 --> 00:35:02,010
그는 확실히 가장 많은 부분을 차지한다.
내 그래프의 모든 정점들--

804
00:35:02,010 --> 00:35:04,750
그럼 어쨌든
v개의 자리를 차지할 것입니다.

805
00:35:04,750 --> 00:35:07,699
따라서 v가 소요될 것입니다.
전체 공간의 제곱.

806
00:35:07,699 --> 00:35:08,929
그건 별로 좋지 않을 거예요.

807
00:35:08,929 --> 00:35:11,449
어떤 면에서는
내 일정에

808
00:35:11,449 --> 00:35:12,469
지금은 선형적인 정보가 존재합니다.

809
00:35:12,469 --> 00:35:13,996
간단합니다.
경로 길이.

810
00:35:13,996 --> 00:35:15,829
내가 실제로 원한다면
그런 다음 이 경로를 재구성하십시오.

811
00:35:15,829 --> 00:35:18,650
첫째로 영적으로
저는 많은 것이 필요하다고 느껴요.

812
00:35:18,650 --> 00:35:20,242
이를 위한 공간이 더 필요합니다.

813
00:35:20,242 --> 00:35:21,950
하지만 답은 다음과 같습니다.
사실 저희는 그렇게 하지 않습니다.

814
00:35:21,949 --> 00:35:23,480
우리에게
선형 공간만 필요합니다.

815
00:35:23,480 --> 00:35:25,490
그리고 그 아이디어는 다음과 같습니다.
객체를 저장하세요

816
00:35:25,489 --> 00:35:26,739
최단 경로 트리라고 합니다.

817
00:35:26,739 --> 00:35:27,239
예?

818
00:35:27,239 --> 00:35:33,822
대상: [알아들을 수 없는 부분]만 해당
이전 [표시 안 됨]..

819
00:35:33,822 --> 00:35:35,989
저스틴 솔로몬: 그래서,
질문은 재귀에 관한 것이었습니다.

820
00:35:35,989 --> 00:35:38,239
사실 우리는 그렇지 않아요.
그래프 알고리즘은 작성되지 않았습니다.

821
00:35:38,239 --> 00:35:41,104
그래서 연기하기로 했습니다.
즉, 우리가 실제로 같은 말을 반복하기 전까지는 그렇습니다.

822
00:35:41,105 --> 00:35:42,980
그런 다음
좀 더 신중하게 생각해 봅시다.

823
00:35:42,980 --> 00:35:45,409
네, 하지만 그건 완전히 틀렸어요.
합리적인 질문입니다.

824
00:35:45,409 --> 00:35:47,809
재귀적인 것들이 많이 있습니다.
그래프 알고리즘.

825
00:35:47,809 --> 00:35:50,500
그리고 나서 우리는,

826
00:35:50,500 --> 00:35:51,500
아마도 매우 신중하게 계산해야 할 것입니다.

827
00:35:54,480 --> 00:35:57,990
네, 대신에 저희는
객체를 정의합니다.

828
00:35:57,989 --> 00:35:59,250
최단 경로 트리.

829
00:35:59,250 --> 00:36:01,809
그리고 핵심 비결은...
여기서 말하고자 하는 바는 다음과 같습니다.

830
00:36:01,809 --> 00:36:04,549
나는 어떻게 a에서 c로 이동했을까?

831
00:36:04,550 --> 00:36:08,990
뭐, 최단 경로에는 항상 정점이 있기 마련이죠.
그것의 전신

832
00:36:08,989 --> 00:36:10,289
.

833
00:36:10,289 --> 00:36:12,960
그리고 최단 경로는 다음과 같은 특징을 가지고 있습니다.
훌륭한 부동산입니다.

834
00:36:12,960 --> 00:36:16,789
즉, 최단 경로입니다.
a에서 c로, 줄여서 말하면-

835
00:36:16,789 --> 00:36:19,989
네, 그러니까 A에서 B로, 그리고 C로 가는 거죠.

836
00:36:19,989 --> 00:36:23,139
그러면 잘린 경로
또한 가장 짧은 경로이기도 합니다.

837
00:36:23,139 --> 00:36:24,514
이전 최고점까지.

838
00:36:24,514 --> 00:36:26,139
그럼 잠시 생각해 봅시다.
이로써,

839
00:36:26,139 --> 00:36:27,969
이 문장 때문에
늘 그렇듯, 상황은 좋지 않았다.

840
00:36:27,969 --> 00:36:29,529
담당 교수가 작성한 것입니다.

841
00:36:29,530 --> 00:36:31,930
자, 그럼 다음과 같이 가정해 봅시다.
제가 제일 짧아요.

842
00:36:31,929 --> 00:36:38,799
a에서 d로 가는 경로, 즉
아주 분명하게 a, b, c, d를 의미합니다.

843
00:36:38,800 --> 00:36:40,539
우리 모두 동의할 수 있을 거라고 생각합니다.

844
00:36:40,539 --> 00:36:42,820
그리고 이제 제가 가져가겠습니다.
그러한 하위 목록.

845
00:36:42,820 --> 00:36:45,309
저는 그냥 A부터 C까지 보고 있어요.  또는

846
00:36:45,309 --> 00:36:47,019
그런 적이 있나요?
어떤 상황에서

847
00:36:47,019 --> 00:36:53,269
이것은 가장 빠른 길이 아닙니다
또는 A에서 C까지의 최단 경로는 무엇일까요?

848
00:36:53,269 --> 00:36:56,750
아니, 맞아요. 왜냐하면 만약
더 짧은 길이 있었다

849
00:36:56,750 --> 00:36:59,929
a부터 c까지, 나는 할 수 있다
여기서 연결하세요

850
00:36:59,929 --> 00:37:02,635
그리고 가장 짧은 것을 찾으세요
a에서 d로 가는 경로.

851
00:37:02,635 --> 00:37:04,670
보이시나요?

852
00:37:04,670 --> 00:37:06,920
따라서, 이를 바탕으로
추론하자면, 입력하는 대신 최단 경로상에서 내 앞에 있는 정점 하나만 떠올리면 되니까요.

853
00:37:06,920 --> 00:37:10,000
이 거대한 선과 같은 선
최단 경로들의 집합,

854
00:37:10,000 --> 00:37:11,750
겉보기에는 실제로
어떤 의미에서 적용하는 것입니다.

855
00:37:11,750 --> 00:37:15,289
재귀적 제안.

856
00:37:19,831 --> 00:37:21,039
저는 그 경로를 추적해 보겠습니다.

857
00:37:21,039 --> 00:37:22,730
그럼 한번 살펴보겠습니다.
저희 일정에 맞춰서요.

858
00:37:25,666 --> 00:37:27,750
본질적으로, 그 이면에 있는 대상은
저도 따라가겠습니다.

859
00:37:27,750 --> 00:37:30,130
전작과 비슷하죠?

860
00:37:30,130 --> 00:37:34,210
그렇다면 그 전신은 무엇일까요?
f는 최단 경로상에 있습니까?

861
00:37:34,210 --> 00:37:35,619
사실 답은 d 아니면 e입니다.

862
00:37:35,619 --> 00:37:37,460
이 경우에는 상관없습니다.

863
00:37:37,460 --> 00:37:42,690
아마도 전임자일 것입니다.
재미로 하는 거죠, 그렇죠?

864
00:37:42,690 --> 00:37:44,039
e의 전신은 무엇인가요?

865
00:37:44,039 --> 00:37:47,159
이전의 것이 분명합니다
최단 경로로 정상에 오르세요

866
00:37:47,159 --> 00:37:49,259
이것은 c입니다.

867
00:37:49,260 --> 00:37:54,540
마찬가지로 d--의 경우에도 이제 우리는
우리는 b와 a, 그리고 많은 것들을 가지고 있습니다.

868
00:37:54,539 --> 00:37:56,639
그 방향을 가리키는 화살표.

869
00:37:56,639 --> 00:37:58,092
따라서 각 꼭짓점에 대해
저는 그냥

870
00:37:58,092 --> 00:38:00,300
나는 가리키는 화살표를 시작할 것이다.
이전 최고점까지

871
00:38:00,300 --> 00:38:01,269
최단 경로로.

872
00:38:01,269 --> 00:38:03,480
저는 그걸 간직하지 않을 거예요.
전체 최단 경로만

873
00:38:03,480 --> 00:38:06,369
마지막 갈비뼈.

874
00:38:06,369 --> 00:38:10,529
우선, 얼마인지부터 알아볼까요?
이 프로그램은 메모리를 얼마나 사용하나요?

875
00:38:10,530 --> 00:38:11,663
이것은 v개의 공간을 차지합니다.

876
00:38:11,663 --> 00:38:12,329
보이시나요?

877
00:38:12,329 --> 00:38:14,219
또는 크기
정점 공간.

878
00:38:14,219 --> 00:38:16,569
각 정점 때문에
단 한 가지만 남겨야 합니다.

879
00:38:16,570 --> 00:38:20,642
바로 이전 것입니다.
최단 경로상의 정상.

880
00:38:20,641 --> 00:38:22,849
그렇다면 제 알고리즘은 무엇을 의미할까요?
최단 경로를 추적하기 위해서요?

881
00:38:22,849 --> 00:38:23,849
아주 간단합니다.

882
00:38:23,849 --> 00:38:25,940
저는 이제 막 걷기 시작했어요.
이 가장자리를 따라,

883
00:38:25,940 --> 00:38:29,208
아직 아님
나는 a로 돌아갈 것이다.

884
00:38:29,208 --> 00:38:31,250
이제 이 객체는 이렇게 불립니다.
최단 경로 트리.

885
00:38:31,250 --> 00:38:35,059
참고로 저는 훔쳤습니다.
나무를 의미하는 또 다른 단어.

886
00:38:35,059 --> 00:38:35,630
왜 그렇죠?

887
00:38:35,630 --> 00:38:38,612
저도 언젠가 하나 가질 수 있을까요?
이 그래프에서 주기적인 현상이 나타나나요?

888
00:38:38,612 --> 00:38:40,320
이건 사실 그렇지 않아요
말이 안 되잖아요, 그렇죠?

889
00:38:40,320 --> 00:38:41,320
이것이 최단 경로입니다.

890
00:38:41,320 --> 00:38:43,570
당신은 할 수 있을 겁니다.
경사를 거꾸로 따라가는 것과 같은 방식

891
00:38:43,570 --> 00:38:46,450
초기 정점으로.

892
00:38:46,449 --> 00:38:51,460
네, 다시 말해서, 저는
저는 제 일정표를 꾸밀 거예요.

893
00:38:51,460 --> 00:38:52,570
한 가지 더 말씀드릴 게 있습니다.

894
00:38:52,570 --> 00:38:55,960
우리는 이것을 v의 p라고 부를 것입니다.
이전 정점입니다

895
00:38:55,960 --> 00:39:00,590
내 집에서 가장 짧은 경로로
내 정점 v의 시작점.

896
00:39:00,590 --> 00:39:02,972
그리고 저는 노력했다고 생각해요.
오늘 여러분께 증명해 보이겠습니다.

897
00:39:02,972 --> 00:39:04,430
만약 내가 가지고 있다면?
이 정보는,

898
00:39:04,429 --> 00:39:06,762
사실 이 정도면 충분합니다.
최단 경로를 재구성합니다.

899
00:39:06,762 --> 00:39:10,190
저는 계속해서 p를 가져갑니다.
v, 그리고 나서 p와 v를 함께 사용합니다.

900
00:39:10,190 --> 00:39:12,230
그리고 나서 p와 p, 그리고 p
v 등과 함께, 그것은

901
00:39:12,230 --> 00:39:14,329
소리
실제보다 더 복잡하다.

902
00:39:14,329 --> 00:39:17,009
내가 추적할 때까지
원래 꼭짓점.

903
00:39:17,010 --> 00:39:20,368
그리고 이 객체는 개념적으로
최단 경로 트리라고 합니다.

904
00:39:20,367 --> 00:39:21,409
이와 관련해서 궁금한 점 있으신가요?

905
00:39:23,929 --> 00:39:25,105
예?

906
00:39:25,106 --> 00:39:28,045
청중: [알아들을 수 없음]

907
00:39:28,045 --> 00:39:30,925
저스틴 솔로몬: 만약 내가
a와 d를 연결하는 모서리는 양호합니다.

908
00:39:30,925 --> 00:39:36,980
청중: [알아들을 수 없음]

909
00:39:36,980 --> 00:39:39,679
저스틴 솔로몬: 아, 알겠습니다.
문제는 이것이었습니다.

910
00:39:39,679 --> 00:39:44,599
우리 동료를 예로 들어보자
이점을 추가했습니다.

911
00:39:44,599 --> 00:39:47,839
정말 좋은 질문입니다.

912
00:39:47,840 --> 00:39:51,410
아시다시피, 누군가 화가 났어요.
내 경쟁 신경망

913
00:39:51,409 --> 00:39:53,809
여기에 갇혔습니다.
그녀는 승부욕이 강했다.

914
00:39:53,809 --> 00:39:56,579
그리고 그녀는 내 것을 원했어요
최단 경로 코드 실행에 실패했습니다.

915
00:39:56,579 --> 00:40:01,250
그리고 이제 어쩌다 보니 내가 가진 그 나무는…
내가 너에게 준 건데, 이제는 예전 같지 않아.

916
00:40:01,250 --> 00:40:03,440
제 대답은 '예'입니다.

917
00:40:03,440 --> 00:40:04,070
왜 그렇습니까?

918
00:40:04,070 --> 00:40:07,580
자, 여기에 이런 특징을 더하면,
내 최단 경로의 길이

919
00:40:07,579 --> 00:40:08,449
변경되었습니다.

920
00:40:08,449 --> 00:40:10,926
최단 경로
a부터 d까지는 이제 모두 1입니다.

921
00:40:10,927 --> 00:40:12,260
따라서 이 트리는 더 이상 유효하지 않습니다.

922
00:40:12,260 --> 00:40:14,120
새 크리스마스 트리가 필요해요.

923
00:40:14,119 --> 00:40:19,119
그렇다면 어떤 모습일까요?
여기 d에서 이전 p가 나왔나요?

924
00:40:19,119 --> 00:40:22,719
음, 대신에
c라면 a가 될 것이다.

925
00:40:22,719 --> 00:40:24,230
네, 그건 전적으로 맞습니다.

926
00:40:24,230 --> 00:40:27,579
그리고 실제로 그것은 반영합니다
정말 불쾌한 특징

927
00:40:27,579 --> 00:40:31,150
최단 경로: 만약
그래프에 간선을 하나 추가합니다.

928
00:40:31,150 --> 00:40:34,030
최단 경로의 길이
각 정점의 값이 변경될 수 있습니다.

929
00:40:34,030 --> 00:40:37,330
글쎄요, 저는 그렇게 생각해요.
원래 꼭짓점을 제외하고.

930
00:40:37,329 --> 00:40:41,139
네, 그리고 이것은
정말 큰 두통

931
00:40:41,139 --> 00:40:42,170
일부 프로그램에서는 그렇습니다.

932
00:40:42,170 --> 00:40:44,980
예를 들면,
프로그램에 대해서는 함구하겠습니다.

933
00:40:44,980 --> 00:40:47,019
그리고 저는 다시 수학 문제를 풀겠습니다.

934
00:40:47,019 --> 00:40:48,880
저는 3D 모델링 작업을 많이 합니다.

935
00:40:48,880 --> 00:40:51,730
그리고 방대한 데이터 세트가 있습니다.
발레리나 같은 3D 모델들.

936
00:40:51,730 --> 00:40:54,105
그리고 발레리나들은 정말로
짜증나는 건 가끔 그럴 때가 있다는 거예요.

937
00:40:54,105 --> 00:40:55,579
손을 모으다
.

938
00:40:55,579 --> 00:40:58,539
그러다 갑자기 가장 짧은
손가락 사이의 길

939
00:40:58,539 --> 00:41:02,769
되다
0과 유사합니다.

940
00:41:02,769 --> 00:41:05,860
따라서 점진적 알고리즘
최단 경로를 계산하기 위해

941
00:41:05,860 --> 00:41:06,940
여기서 실패할 수도 있겠죠?

942
00:41:06,940 --> 00:41:08,889
왜냐하면 저는 가지고 있기 때문입니다
다른 모든 것들과 마찬가지로 업데이트될 것입니다.

943
00:41:08,889 --> 00:41:11,974
만약 내가
그래서 나는 손가락을 서로 붙였다.

944
00:41:11,974 --> 00:41:13,599
어느 쪽이든, 허락할게요.
어떻게 생각하는지

945
00:41:13,599 --> 00:41:14,724
당신은 이 문제를 해결할 수 있습니다.

946
00:41:14,724 --> 00:41:17,380
더 자세히 알고 싶으시다면,
6.838을 선택해야 합니다.

947
00:41:17,380 --> 00:41:18,226
예?

948
00:41:18,226 --> 00:41:19,862
청중: [알아들을 수 없음].

949
00:41:19,862 --> 00:41:21,820
저스틴 솔로몬: 만약 당신이
소스 노드를 변경하세요.

950
00:41:21,820 --> 00:41:23,120
가능한 한 빨리 다시 바꾸세요.

951
00:41:23,119 --> 00:41:25,309
네, 그게 하나가 될 겁니다.
정말 지루한 것들 중 하나,

952
00:41:25,309 --> 00:41:26,239
제가 가려고 하는 것
계속 답변해 주세요.

953
00:41:26,239 --> 00:41:28,439
매번 그럴 때마다
내 문제의 일부를 바꿔볼게.

954
00:41:28,440 --> 00:41:30,440
출처를 변경하겠습니다.
저는 제 한계를 바꿀 것입니다.

955
00:41:30,440 --> 00:41:32,579
저는 세어보기만 하면 돼요.
모든 최단 경로.

956
00:41:32,579 --> 00:41:36,569
확실히,
이런 방식을 사용하지 않는 알고리즘도 있습니다.

957
00:41:36,570 --> 00:41:38,600
하지만 우리는
지금은 그 문제에 대해 생각하지 않겠습니다.

958
00:41:38,599 --> 00:41:39,710
좋은.

959
00:41:39,710 --> 00:41:41,230
그래서, 늘 그렇듯이, 저는
너무 많이 말했어요

960
00:41:41,230 --> 00:41:43,219
그리고 그것을 내 가까이에 두었다.
현상하는 데 10분 소요

961
00:41:43,219 --> 00:41:45,859
실제 알고리즘은 다음과 같습니다.
강의가 흥미로웠다.

962
00:41:46,467 --> 00:41:48,550
실제로는 그렇지만
그렇게 어렵지 않아요.

963
00:41:48,550 --> 00:41:50,120
그래서 우리는 괜찮을 거라고 생각해요.

964
00:41:50,119 --> 00:41:52,288
즉, 이것이 바로 나의 진짜 모습이다.
최단 경로를 계산하시겠습니까?

965
00:41:52,288 --> 00:41:54,079
네, 그리고 가장 중요한 것은,
우리는 어떻게 해야 할까요?

966
00:41:54,079 --> 00:41:57,387
마치 건물을 짓는 것과 같아요
이 비유는 나무에 관한 것입니다.

967
00:41:57,387 --> 00:41:59,929
우리는 또 다른 하나를 정의할 것입니다.
내가 정말 좋아하는 물건 --

968
00:41:59,929 --> 00:42:02,304
사실 전 그게 마음에 들어요.
제이슨의 메모는 다음과 같습니다.

969
00:42:02,304 --> 00:42:04,730
계산으로서,
그리고 전 그게 좋아요.

970
00:42:04,730 --> 00:42:08,150
그리고 이것은 하나의 아이디어입니다.
레벨 세트.

971
00:42:08,150 --> 00:42:11,059
그래서, 이것은 전체입니다.
사물 집합 L 하위 k.

972
00:42:11,059 --> 00:42:13,715
그게 전부입니다.
거리 k만큼 떨어진 꼭짓점들

973
00:42:13,715 --> 00:42:15,809
제 정보원에 따르면.

974
00:42:15,809 --> 00:42:18,619
예를 들어, 만약 내
이 예시의 원래 정점

975
00:42:18,619 --> 00:42:20,539
최고입니다
완전히 왼쪽으로,

976
00:42:20,539 --> 00:42:24,230
그렇다면 L0에는 분명히 다음이 포함됩니다.
바로 오른쪽에 있는 이 봉우리 말입니다.

977
00:42:24,230 --> 00:42:25,670
다음은 L1입니다.

978
00:42:25,670 --> 00:42:27,079
L2는 세 번째입니다.

979
00:42:27,079 --> 00:42:30,596
하지만 이제 L3는 세트입니다.
세 개의 봉우리에서,

980
00:42:30,597 --> 00:42:32,680
왜냐하면 그들은 모두 그렇기 때문입니다
거리가 있습니다

981
00:42:32,679 --> 00:42:34,169
출처에서 3개.

982
00:42:34,170 --> 00:42:36,630
이것이 제가
분홍색으로 표시되어 있습니다.

983
00:42:36,630 --> 00:42:40,230
네, 그게 다입니다.
이 표기법은 다음을 의미합니다.

984
00:42:40,230 --> 00:42:42,840
아, 제가 작은 실수를 했네요.
이 수업에서는 거리가

985
00:42:42,840 --> 00:42:46,164
델타가 아니라
하지만 그래도.

986
00:42:46,164 --> 00:42:47,039
청중: [미완성]

987
00:42:47,039 --> 00:42:48,179
저스틴 솔로몬:
최단 거리는

988
00:42:48,179 --> 00:42:49,199
그건 전적으로 맞는 말입니다.

989
00:42:49,199 --> 00:42:51,282
예를 들어, 저는 다음과 같은 상황을 겪을 수 있습니다.
매우 먼 거리

990
00:42:51,282 --> 00:42:52,389
L0에서 L2로의 이동이 맞습니다.

991
00:42:52,389 --> 00:42:54,989
스크롤을 앞으로 넘기면 되잖아요.
L0과 L1 사이로 돌아가서,

992
00:42:54,989 --> 00:42:57,219
L4로 이동할 수도 있습니다.
그리고 나서 돌아오세요.

993
00:42:57,219 --> 00:43:00,039
하지만 그건 그다지 좋지 않을 거예요
계산에 유용합니다.

994
00:43:00,039 --> 00:43:01,039
그건 전적으로 맞는 말입니다.

995
00:43:01,039 --> 00:43:02,286
예?

996
00:43:02,286 --> 00:43:04,197
청중: [알아들을 수 없음].

997
00:43:04,197 --> 00:43:05,780
저스틴 솔로몬: 오,
붉은색 배경 —

998
00:43:05,780 --> 00:43:10,515
L의 집합입니다. 예를 들어,
L3에는 이 세 개의 정점이 포함되어 있습니다.

999
00:43:10,514 --> 00:43:12,139
그들은 모두 켜져 있기 때문입니다

1000
00:43:12,139 --> 00:43:14,000
왼쪽 가장자리에서 3만큼 떨어진 거리.  어젯밤 늦게

1001
00:43:14,000 --> 00:43:17,929
내가 너무 교묘하게 그림을 그렸어.
당신의 도표입니다.

1002
00:43:17,929 --> 00:43:19,799
저는 이 점이 어느 정도 자랑스럽습니다.

1003
00:43:19,800 --> 00:43:24,140
네, 그러니까 기본적으로 만약
나는 계산하고 싶었다

1004
00:43:24,139 --> 00:43:27,349
최단 경로의 길이
왼쪽 전체에서

1005
00:43:27,349 --> 00:43:29,589
다른 모든 사람들에게
정점, 일방통행

1006
00:43:29,590 --> 00:43:32,090
이를 위해서는 계산해야 합니다.
이러한 모든 레벨 세트, 그리고 나서

1007
00:43:32,090 --> 00:43:35,150
어떤 건지 확인해 보세요.
제가 찬성하는 레벨 세트 맞죠?

1008
00:43:35,150 --> 00:43:37,700
자, 그럼 저희가 발표하겠습니다.
알고리즘이라고 불리는 것

1009
00:43:37,699 --> 00:43:40,939
"광범위한 검색",
이것은 대략 다음과 같은 역할을 합니다.

1010
00:43:40,940 --> 00:43:42,679
그래서, 너비 우선 탐색
우리가

1011
00:43:42,679 --> 00:43:45,440
오늘 저희가 발표하겠습니다.
계산을 위한 알고리즘이 될 것입니다.

1012
00:43:45,440 --> 00:43:48,500
이 모든 레벨 세트 중에서 L
i를 대입하고, 그 다음부터 이것으로부터

1013
00:43:48,500 --> 00:43:50,119
우리는 만들 수 있습니다
길이와 심지어

1014
00:43:50,119 --> 00:43:52,739
최단 경로의 형태.  .

1015
00:43:52,739 --> 00:43:55,349
그리고 저는 이사 갈 거예요.
당신이 손으로 쓴 메모에.

1016
00:43:55,349 --> 00:44:00,567
좋아요, 그럼 이제부터 알려드릴게요.
저희 알고리즘이 해낼 겁니다.

1017
00:44:00,568 --> 00:44:02,610
저는 이것을 쓸 거예요.
약간 다르게,

1018
00:44:02,610 --> 00:44:07,079
메모에 있는 내용보다 더 많은 것
화면이지만, 아주 조금만요.

1019
00:44:07,079 --> 00:44:10,529
우선,
우리 모두 동의할 수 있을 거라고 생각합니다.

1020
00:44:10,530 --> 00:44:12,150
레벨 집합 0--

1021
00:44:12,150 --> 00:44:15,200
아, 이거… 이거
분필로 갈라진 모양--

1022
00:44:15,199 --> 00:44:17,399
이 파일에는 노드가 하나 포함되어 있습니다.

1023
00:44:17,400 --> 00:44:19,450
이 노드는 어떤 모습이어야 할까요?

1024
00:44:19,449 --> 00:44:22,119
출처는 다음과 같습니다.
저 멀리 있는 유일한 것

1025
00:44:22,119 --> 00:44:24,139
소스에서 0,
이것이 소스 노드입니다.

1026
00:44:28,750 --> 00:44:33,460
네, 그리고 그 외에도,
우리는 거리를 초기화할 수 있습니다

1027
00:44:33,460 --> 00:44:35,753
근원에서 당신 자신에게까지.

1028
00:44:35,753 --> 00:44:37,420
모두 셋씩,
거리는 얼마인가요?

1029
00:44:37,420 --> 00:44:38,559
근원에서 자기 자신으로 --

1030
00:44:38,559 --> 00:44:39,500
1, 2, 3.

1031
00:44:39,500 --> 00:44:40,117
관객 수: 0명.

1032
00:44:40,117 --> 00:44:41,200
저스틴 솔로몬: 감사합니다.

1033
00:44:41,199 --> 00:44:43,789
보시다시피, 당신은 깨어나고 있습니다.
벌써 거의 11시네요.

1034
00:44:43,789 --> 00:44:44,289
12시.

1035
00:44:44,289 --> 00:44:45,199
지금 몇 시예요?

1036
00:44:45,199 --> 00:44:49,210
거의 12시가 다 됐어요. 좋은,
그리고 마지막으로,

1037
00:44:49,210 --> 00:44:50,829
아마 먼저일 거예요
우리

1038
00:44:50,829 --> 00:44:54,099
우리는 배열에 대해 아무것도 모릅니다
p, 그래서 그냥 비워 버립니다.

1039
00:44:54,099 --> 00:44:56,545
p 소스이므로,
무슨 이유인지 모르겠지만, 그건 중요하지 않아요.

1040
00:44:56,545 --> 00:44:58,420
내가
출처로 돌아갔습니다.

1041
00:44:58,420 --> 00:45:00,402
계산을 마쳤습니다.
최단 경로.

1042
00:45:00,402 --> 00:45:02,110
그래서 우리는
다음과 같은 알고리즘을 작성해 봅시다.

1043
00:45:02,110 --> 00:45:06,309
모든 레벨 세트를 계산합니다.
이 배열 p를 채우고 채웁니다.

1044
00:45:06,309 --> 00:45:08,380
거리
하나의 큰 프레임.

1045
00:45:08,380 --> 00:45:11,039
우리는 그것을 이렇게 부를 겁니다
너비 우선 탐색.

1046
00:45:11,039 --> 00:45:12,079
좋아요, 시작해 봅시다.

1047
00:45:15,809 --> 00:45:17,784
그래서 우리는 여기서 표기법을 사용할 수 있습니다.

1048
00:45:17,784 --> 00:45:19,159
그리고 다음 사항에 유의하십시오.
원래

1049
00:45:19,159 --> 00:45:22,069
귀납법이 발생하는데, 이는 다음과 같은 사실로 구성된다.
레벨 세트를 계산하겠습니다.

1050
00:45:22,070 --> 00:45:25,490
레벨 0 세트에서 1개,
레벨 1 세트에서 레벨 2 세트로

1051
00:45:25,489 --> 00:45:28,559
그렇게 해서 다 채울 때까지 계속합니다.
모든 레벨 세트.

1052
00:45:28,559 --> 00:45:30,250
이해가 되시나요?

1053
00:45:30,250 --> 00:45:34,079
자, 이번에는 좀 다른 걸 보여드릴게요.
같은 것을 나타내는 한 가지 방법.

1054
00:45:34,079 --> 00:45:35,579
저는 사용할 것입니다
WHILE 루프는 다음과 같습니다.

1055
00:45:35,579 --> 00:45:39,539
저도 조금은 알아요.
유대교 율법에 맞는 음식은 아니지만 괜찮아요.

1056
00:45:39,539 --> 00:45:42,719
그럼 초기화하겠습니다.
숫자 i부터 1까지.

1057
00:45:42,719 --> 00:45:44,579
이것은
저희 카운터처럼요.

1058
00:45:44,579 --> 00:45:52,829
제가 말씀드리자면, ~하는 동안
이전 레벨 세트는 아닙니다

1059
00:45:52,829 --> 00:45:55,469
비어있다는 뜻입니다.
잠재적으로 존재한다

1060
00:45:55,469 --> 00:45:57,959
통과하는 길
이전 레벨 세트

1061
00:45:57,960 --> 00:45:59,639
다음번까지.

1062
00:45:59,639 --> 00:46:02,339
왜냐하면 하나가 되는 순간
내 레벨이 모두 비어 있게 될 것입니다.

1063
00:46:02,340 --> 00:46:04,845
참고로,
Li는 훨씬 더 큰 i를 위해,

1064
00:46:04,844 --> 00:46:05,969
또한 비어 있을 것입니다.

1065
00:46:05,969 --> 00:46:08,909
그런 경우는 절대 없습니다.
거리를 초월하는 무언가가 있다

1066
00:46:08,909 --> 00:46:12,109
i, 그리고 거리는 i에 5를 더한 값입니다.

1067
00:46:12,110 --> 00:46:15,570
그래, 그래서 뭐?
나는 어떻게 해야 할까?

1068
00:46:15,570 --> 00:46:18,110
그럼 가자.
자, 다시 일정으로 돌아가 봅시다.

1069
00:46:23,039 --> 00:46:26,099
이제 나는 그것을 안다
이 남자는 거리가 0입니다.

1070
00:46:26,099 --> 00:46:28,089
이것이 제가 처음 시작했던 것입니다.

1071
00:46:28,090 --> 00:46:30,998
자, 이제 모두를 살펴보겠습니다.
이 봉우리의 이웃들.

1072
00:46:30,998 --> 00:46:32,789
그리고 저는 강제로 할 겁니다
두 사람의 거리는 1입니다.

1073
00:46:32,789 --> 00:46:35,739
이해가 되시나요?

1074
00:46:35,739 --> 00:46:38,849
여기도 마찬가지입니다.
이 남자의 거리는 2입니다.

1075
00:46:38,849 --> 00:46:42,299
그리고 마지막으로 저는
나는 문제가 생길지도 몰라...

1076
00:46:42,300 --> 00:46:44,110
음, 뭐
좋은 예가 여기 있습니다.

1077
00:46:44,110 --> 00:46:46,271
저는 그림을 그려볼 생각조차 하지 않을 거예요.  안에

1078
00:46:46,271 --> 00:46:47,730
제가 그랬을지도 몰라요
내가 그렇게 하지 않으면 문제가 생깁니다

1079
00:46:47,730 --> 00:46:51,670
정점을 두 번 추가하고 싶습니다.
서로 다른 두 가지 레벨 세트로.

1080
00:46:51,670 --> 00:46:53,970
제가 이것을 놓았을 때
리에서 나는 아니다

1081
00:46:53,969 --> 00:46:56,189
저는 이것을 리에 넣고 싶습니다.
이미 가지고 있으니까 5점 더!

1082
00:46:56,190 --> 00:46:58,260
저는 이것이 거리라는 것을 알고 있습니다.

1083
00:46:58,260 --> 00:47:00,090
이해가 되시나요?

1084
00:47:00,090 --> 00:47:01,890
내가 잘하고 있어
내가 할 거야, 바로 나야.

1085
00:47:01,889 --> 00:47:04,719
제가 모든 내용을 다시 반복하겠습니다.
이전 상의

1086
00:47:04,719 --> 00:47:05,219
레벨 세트.

1087
00:47:09,679 --> 00:47:12,259
그리고 지금 나는
나는 모든 봉우리를 살펴볼 것이다.

1088
00:47:12,260 --> 00:47:15,512
u에 인접해 있습니다.

1089
00:47:15,512 --> 00:47:16,470
내가 뭘 알겠어?

1090
00:47:16,469 --> 00:47:19,519
내가 거기에 갈 수만 있다면...
i 마이너스 1단계 후에 당신에게

1091
00:47:19,519 --> 00:47:24,309
몇 단계
제가 이웃집에 가야 할 일이 있을까요?

1092
00:47:24,309 --> 00:47:26,710
그리고 제가 할 수 있기 때문에 단계들을 밟아 나갑니다.
그 길로 가기 위해

1093
00:47:26,710 --> 00:47:30,369
길이 i 마이너스와 같습니다.
1. 모서리를 하나 더 추가합니다.

1094
00:47:30,369 --> 00:47:32,589
그리고 이 새로운 사람에 대해 이야기해 볼게요.

1095
00:47:32,590 --> 00:47:35,000
그럼 제가 할 수 있는 일은 무엇일까요?

1096
00:47:35,000 --> 00:47:37,449
반복할 수 있습니다
모든 v에 대해,

1097
00:47:37,449 --> 00:47:42,789
이웃 집합 u에 있습니다.

1098
00:47:42,789 --> 00:47:45,309
하지만 난 그래야만 해.
조금 조심하세요, 왜냐하면,

1099
00:47:45,309 --> 00:47:46,509
내가 다시 우위를 점할 수 있다면?

1100
00:47:46,510 --> 00:47:48,610
예를 들면,
여기서 내가 유리한 위치에 있다.

1101
00:47:48,610 --> 00:47:50,559
근원으로.

1102
00:47:50,559 --> 00:47:52,259
제 생각엔 이건...

1103
00:47:52,260 --> 00:47:54,665
네, 좋은 예시네요.

1104
00:47:54,664 --> 00:47:56,039
나는 그러고 싶지 않다
소스 추가

1105
00:47:56,039 --> 00:47:58,559
3단계 채용으로,
왜냐하면 저는 이미

1106
00:47:58,559 --> 00:48:01,079
이전 영상에 이미 추가했어요.

1107
00:48:01,079 --> 00:48:05,174
그래서 저는 없애고 싶어요
모두의 통합

1108
00:48:05,175 --> 00:48:06,300
이전 레벨 세트.

1109
00:48:11,416 --> 00:48:12,405
이해가 되시나요?

1110
00:48:12,405 --> 00:48:13,780
다시 말해서,
저는 단지 고려하고 있을 뿐입니다.

1111
00:48:13,780 --> 00:48:17,950
인접한 꼭짓점,
제가 아직 방문하지 못한 곳입니다

1112
00:48:17,949 --> 00:48:21,159
내
레벨 집합에 대한 계산 알고리즘.

1113
00:48:21,159 --> 00:48:23,409
제가 해야 할 일은 이것뿐입니다.
배열을 업데이트해야죠.

1114
00:48:23,409 --> 00:48:32,230
특히, 저는
레벨 집합 i에 정점 v를 추가하겠습니다.

1115
00:48:32,230 --> 00:48:34,449
아직 v를 보지 못했거든요.

1116
00:48:34,449 --> 00:48:43,029
제가 거리를 설정하겠습니다.
s에서 v로의 변화는 i와 같습니다.

1117
00:48:43,030 --> 00:48:46,240
왜냐하면 지금 나는
저는 레벨 1 과정을 수료하고 있습니다.

1118
00:48:46,239 --> 00:48:51,819
마지막으로, v의 p는 무엇입니까?

1119
00:48:51,820 --> 00:48:54,430
이전 것은 무엇인가요?
가장 짧은 옷의 탑에서 브이까지

1120
00:48:54,429 --> 00:48:55,539
근원에서 멀리 떨어져 있다는 말인가요?

1121
00:48:58,420 --> 00:48:59,680
당신 맞죠?

1122
00:48:59,679 --> 00:49:01,809
왜냐하면 이 사람이 바로 그 사람이기 때문입니다.
이전 레벨에서, 에서

1123
00:49:01,809 --> 00:49:05,590
제가 짓고 있는 것
네 방식대로 하는 게 맞지?

1124
00:49:05,590 --> 00:49:07,247
제가 설정해 드리겠습니다.

1125
00:49:07,246 --> 00:49:08,829
그리고 나서… 죄송합니다, 제가…
공간이 부족했어요.

1126
00:49:08,829 --> 00:49:12,989
하지만 저도 i 값을 늘려야 합니다.

1127
00:49:12,989 --> 00:49:15,909
그래, 그래서 뭐?
이 알고리즘은 어떤 역할을 하나요?

1128
00:49:15,909 --> 00:49:17,879
그냥 하나를 만드는 것뿐이에요
한 번에 한 단계씩.

1129
00:49:17,880 --> 00:49:21,930
우리가 앞서 살펴본 이미지로 돌아가 보면,
그러므로 L0을 초기화하는 것부터 시작합니다.

1130
00:49:21,929 --> 00:49:25,109
시작 정점으로만 사용됩니다.
그리고 나서 모든 모서리를 살펴봅니다.

1131
00:49:25,110 --> 00:49:27,210
그것에서 벗어나고 있는 중-
이 경우에는 단 하나뿐입니다.

1132
00:49:27,210 --> 00:49:29,190
이렇게 하면 이 길이는 1이 됩니다.

1133
00:49:29,190 --> 00:49:30,125
등.

1134
00:49:30,125 --> 00:49:31,500
그래서 그런 겁니다.
점진적으로만

1135
00:49:31,500 --> 00:49:32,989
모두 쌓아 올리다
이러한 레벨 세트.

1136
00:49:32,989 --> 00:49:34,739
이제 충분합니다
단순한

1137
00:49:34,739 --> 00:49:37,349
이것이 귀납적 증명이라는 것을 증명합니다.
알고리즘이 정확합니다

1138
00:49:37,349 --> 00:49:40,139
L을 계산합니다.
p와 델타, 그리고

1139
00:49:40,139 --> 00:49:43,889
우리가 가지고 있는 정보는 이게 전부입니다.
최단 거리를 계산하는 데 필요합니다

1140
00:49:43,889 --> 00:49:44,489
방법.

1141
00:49:44,489 --> 00:49:46,447
저는 여러분이 할 수 있다고 생각합니다.
이것은 낭송 중에 일어나는 일입니다.

1142
00:49:46,447 --> 00:49:49,799
아직 조금 더 필요하시다면
귀납적 증명 방법

1143
00:49:49,800 --> 00:49:51,240
.

1144
00:49:51,239 --> 00:49:53,129
그리고 마지막으로,
우리가 확인해야 할 것은 무엇일까요?

1145
00:49:53,130 --> 00:49:55,860
이것은 실행 시간입니다.
이 알고리즘의.

1146
00:49:55,860 --> 00:49:59,800
거기에 억지로 끼워 넣어 볼게요.
여기서 마지막 순간에요.

1147
00:49:59,800 --> 00:50:01,539
그럼 한번 살펴보겠습니다.

1148
00:50:01,539 --> 00:50:08,699
그래서 먼저, 저는 뭔가를 했습니다.
꼬마야... 아뇨, 그건 정상이야...

1149
00:50:08,699 --> 00:50:10,297
내 알고리즘에서
실제로는 0단계입니다.

1150
00:50:10,297 --> 00:50:12,839
배열을 만들어야 했습니다.
그 크기는 숫자와 같습니다.

1151
00:50:12,840 --> 00:50:14,490
봉우리.

1152
00:50:14,489 --> 00:50:17,250
6.006 버전을 기억하세요
얼마나 걸려요

1153
00:50:17,250 --> 00:50:19,853
메모리 할당이 필요합니까?

1154
00:50:19,853 --> 00:50:21,769
네, 숫자가 필요합니다.
시간, 비례

1155
00:50:21,769 --> 00:50:24,590
용량
내가 할당한 메모리의 일부입니다.

1156
00:50:24,590 --> 00:50:27,180
벌써… 스테프, 네 것도 보이네.
손은 괜찮지만 시간이 많지 않아요.

1157
00:50:27,179 --> 00:50:29,210
그러니 우리는 끝까지 가야 합니다.

1158
00:50:29,210 --> 00:50:32,599
우리는 이미 v 시간을 썼습니다.
우리의 최단 경로 배열 이후로

1159
00:50:32,599 --> 00:50:34,730
v 장소를 차지합니다.

1160
00:50:34,730 --> 00:50:39,500
하지만 그 외에도 우리는 다음과 같은 것들을 가지고 있습니다.
웃긴 FOR 루프가 하나 있어요.

1161
00:50:39,500 --> 00:50:44,610
각 노드에 대해 나는 다음을 해야 합니다.
모든 이웃을 방문하기 위해.

1162
00:50:44,610 --> 00:50:49,079
하지만 먼저,
여기 매듭이 두 개 있는 것 같은데요?

1163
00:50:49,079 --> 00:50:52,259
아니요, 저는 떠나기 때문입니다.
거리에 따라 순서대로.

1164
00:50:52,260 --> 00:50:54,423
그리고 두 번째로, 내가
하나에 매듭이 있는 것을 봤어요

1165
00:50:54,422 --> 00:50:55,589
레벨 세트이므로 다른 레벨에 속할 수 없습니다.

1166
00:50:55,590 --> 00:50:58,829
이것이 우리의 주요 사항입니다.
건설.

1167
00:50:58,829 --> 00:51:01,380
음, 어떻게
편안하신가요?

1168
00:51:01,380 --> 00:51:03,059
그것이 정확히 증명되었다
우리가 필요한 공식입니다.

1169
00:51:03,059 --> 00:51:04,559
그리고 운이 좋다면,
저는 그걸 찾아내지 못했어요.

1170
00:51:04,559 --> 00:51:06,900
네, 저희는 여기 있습니다.

1171
00:51:06,900 --> 00:51:09,630
자, 여기를 보면,
이것이 바로 그러한 시나리오입니다.

1172
00:51:09,630 --> 00:51:10,711
네, 그렇습니다.

1173
00:51:10,711 --> 00:51:11,670
우리가 무슨 짓을 저질렀기에?

1174
00:51:11,670 --> 00:51:14,622
우리는 모든 과정을 반복했습니다.
우리 그래프의 노드,

1175
00:51:14,621 --> 00:51:17,079
그리고 나서 모든 것이
이 노드들의 이웃 노드들입니다.

1176
00:51:17,079 --> 00:51:18,704
그리고 이것이 기본입니다
컴퓨팅 시간

1177
00:51:18,704 --> 00:51:20,949
저희 알고리즘에서요.

1178
00:51:20,949 --> 00:51:25,149
따라서 FOR 루프는 다음과 같습니다.
더 정확히 말하면, 제 코드에서 WHILE 루프는

1179
00:51:25,150 --> 00:51:29,510
시간에 비례하여 걸립니다
모서리의 개수.

1180
00:51:29,510 --> 00:51:33,440
그렇다면 총 작업 시간은 얼마입니까?
폭넓게 검색하는 것인가요?

1181
00:51:33,440 --> 00:51:36,980
음, 우리는 필요해요
이 배열을 생성하세요.

1182
00:51:36,980 --> 00:51:40,280
자, 그럼 0단계에서
우리에겐 시간이 있어.

1183
00:51:40,280 --> 00:51:43,340
그리고 나서 우리는 다시 반복해야 합니다.
무언가

1184
00:51:43,340 --> 00:51:45,120
가장 많은 간선을 차지합니다.

1185
00:51:45,119 --> 00:51:54,813
따라서, 우리 알고리즘은 총 몇 분의 30분 정도 소요됩니다.
모드 V와 모드 E를 함께 사용하는 시간이 많습니다.

1186
00:51:54,813 --> 00:51:56,730
자, 이제 이것이...라는 점에 주목하세요.
고려해 볼 수 있습니다.

1187
00:51:56,730 --> 00:51:57,605
불필요한.

1188
00:51:57,605 --> 00:51:58,630
그런데, 에서

1189
00:51:58,630 --> 00:52:00,059
저는 작은 사이즈를 가지고 있어요.
제이슨과의 말다툼.

1190
00:52:00,059 --> 00:52:02,159
하지만 이 수업에서는 이렇게 부를 것입니다.
이것은 선형 시간 알고리즘입니다.

1191
00:52:02,159 --> 00:52:04,139
선형이기 때문에
당신이 있는 공간

1192
00:52:04,139 --> 00:52:05,833
일정을 저장하는 데 사용하세요.  몸소

1193
00:52:05,833 --> 00:52:07,500
제 생각엔 이것은
조금 의심스럽다.

1194
00:52:07,500 --> 00:52:10,090
이 척도는 다음과 같을 수 있기 때문입니다.
v에 대해 제곱에 비례하여 스케일링합니다.

1195
00:52:10,090 --> 00:52:12,930
하지만 이야기가 옆길로 샜네요.

1196
00:52:12,929 --> 00:52:19,210
어쨌든, 우리가 왜 그래야 하죠?
이 두 용어 모두 여기에 필요한가요?

1197
00:52:19,210 --> 00:52:23,740
잘 들어봐, 만약 내가
제 일정에는 갈비찜이 없었어요.

1198
00:52:23,739 --> 00:52:26,109
지금 이 학기
지배할 것이다.

1199
00:52:26,110 --> 00:52:28,870
하지만 제가 갈비를 추가하면
당신의 일정, 이것은

1200
00:52:28,869 --> 00:52:30,469
V 제곱까지 성장할 수 있습니다.

1201
00:52:30,469 --> 00:52:32,469
그러니까 어떤 의미에서는 더 그렇다는 거죠.
정보 전달 표현,

1202
00:52:32,469 --> 00:52:35,002
그냥 "음, ~에서"라고 말하는 것보다
최악의 경우 시간의 제곱이 됩니다.

1203
00:52:35,003 --> 00:52:35,920
이해가 되시나요?

1204
00:52:35,920 --> 00:52:38,289
이건 좀 낫네요.
공식.

1205
00:52:38,289 --> 00:52:40,630
좋아요, 이제 이 작업은 끝났습니다.
삐걱거리며 결승선에 도착했다.  안에

1206
00:52:40,630 --> 00:52:43,340
우리는 알고리즘을 가지고 있습니다
최단 경로를 계산합니다.

1207
00:52:43,340 --> 00:52:46,980
그럼 다음에 또 뵙겠습니다.
화요일에.

