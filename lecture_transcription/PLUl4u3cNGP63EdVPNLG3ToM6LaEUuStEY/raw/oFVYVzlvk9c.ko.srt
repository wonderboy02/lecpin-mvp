1
00:00:16,070 --> 00:00:16,080

 

2
00:00:16,080 --> 00:00:18,630

오늘 하루를 시작해 볼까요?

3
00:00:18,630 --> 00:00:18,640
오늘 하루를 시작해 볼까요?
 

4
00:00:18,640 --> 00:00:21,509
오늘 하루를 시작해 볼까요?
여러분 모두를 만나 뵙게 되어 기쁩니다. 혹시

5
00:00:21,509 --> 00:00:21,519
여러분 모두를 만나 뵙게 되어 기쁩니다. 혹시
 

6
00:00:21,519 --> 00:00:23,109
여러분 모두를 만나 뵙게 되어 기쁩니다. 혹시
기억 못 하시는 분들을 위해 말씀드리자면, 저는 저스틴입니다.

7
00:00:23,109 --> 00:00:23,119
기억 못 하시는 분들을 위해 말씀드리자면, 저는 저스틴입니다.
 

8
00:00:23,119 --> 00:00:24,990
기억 못 하시는 분들을 위해 말씀드리자면, 저는 저스틴입니다.
여러분이 아마 잊고 계셨을 세 번째 강사죠.

9
00:00:24,990 --> 00:00:25,000
여러분이 아마 잊고 계셨을 세 번째 강사죠.
 

10
00:00:25,000 --> 00:00:26,910
여러분이 아마 잊고 계셨을 세 번째 강사죠.
하지만 앞으로

11
00:00:26,910 --> 00:00:28,630
하지만 앞으로
 

12
00:00:28,630 --> 00:00:28,640

 

13
00:00:28,640 --> 00:00:30,230

그래프 이론 부분에서 저를 더 자주 보게 되실 겁니다. 제가

14
00:00:30,230 --> 00:00:30,240
그래프 이론 부분에서 저를 더 자주 보게 되실 겁니다. 제가
 

15
00:00:30,240 --> 00:00:31,830
그래프 이론 부분에서 저를 더 자주 보게 되실 겁니다. 제가
알고리즘 중에서 가장

16
00:00:31,830 --> 00:00:31,840
알고리즘 중에서 가장
 

17
00:00:31,840 --> 00:00:34,270
알고리즘 중에서 가장
좋아하는 분야거든요. 만약 제가

18
00:00:34,270 --> 00:00:34,280
좋아하는 분야거든요. 만약 제가
 

19
00:00:34,280 --> 00:00:35,869
좋아하는 분야거든요. 만약 제가
이론 컴퓨터 과학자로 환생한다면 아마

20
00:00:35,869 --> 00:00:35,879
이론 컴퓨터 과학자로 환생한다면 아마
 

21
00:00:35,879 --> 00:00:39,510
이론 컴퓨터 과학자로 환생한다면 아마
이 분야를 선택했을 거예요. 안녕하세요 여러분, 아시다시피 앞으로

22
00:00:39,510 --> 00:00:42,229
이 분야를 선택했을 거예요. 안녕하세요 여러분, 아시다시피 앞으로
 

23
00:00:42,229 --> 00:00:43,790

 

24
00:00:43,790 --> 00:00:43,800

 

25
00:00:43,800 --> 00:00:45,430

며칠 동안 박사 과정 입학 상담 방문일이 있습니다. 그래서 제가

26
00:00:45,430 --> 00:00:45,440
며칠 동안 박사 과정 입학 상담 방문일이 있습니다. 그래서 제가
 

27
00:00:45,440 --> 00:00:48,709
며칠 동안 박사 과정 입학 상담 방문일이 있습니다. 그래서 제가
캠프 카운슬러처럼 활기찬 목소리로 인사하려고 연습 중이에요. 그러니 제가

28
00:00:48,709 --> 00:00:48,719
캠프 카운슬러처럼 활기찬 목소리로 인사하려고 연습 중이에요. 그러니 제가
 

29
00:00:48,719 --> 00:00:50,950
캠프 카운슬러처럼 활기찬 목소리로 인사하려고 연습 중이에요. 그러니 제가
여러분 모두를 깨우게 하지 마세요. 아마

30
00:00:50,950 --> 00:00:52,029
여러분 모두를 깨우게 하지 마세요. 아마
 

31
00:00:52,029 --> 00:00:52,039

 

32
00:00:52,039 --> 00:00:55,430

좋아하지 않으실 거예요. 어쨌든,

33
00:00:55,430 --> 00:00:55,440
좋아하지 않으실 거예요. 어쨌든,
 

34
00:00:55,440 --> 00:00:57,790
좋아하지 않으실 거예요. 어쨌든,
66강에서 강의 계획서를 다시 보시면 아시겠지만,

35
00:00:57,790 --> 00:00:59,630
66강에서 강의 계획서를 다시 보시면 아시겠지만,
 

36
00:00:59,630 --> 00:00:59,640

 

37
00:00:59,640 --> 00:01:02,029

이 수업의 2부를 공식적으로 시작합니다. 몇 가지

38
00:01:02,029 --> 00:01:02,039
이 수업의 2부를 공식적으로 시작합니다. 몇 가지
 

39
00:01:02,039 --> 00:01:04,869
이 수업의 2부를 공식적으로 시작합니다. 몇 가지
추가 사항이 있습니다. 그럼,

40
00:01:04,869 --> 00:01:04,879
추가 사항이 있습니다. 그럼,
 

41
00:01:04,879 --> 00:01:06,149
추가 사항이 있습니다. 그럼,
질문이 없으시면

42
00:01:06,149 --> 00:01:06,159
질문이 없으시면
 

43
00:01:06,159 --> 00:01:09,190
질문이 없으시면
66강의 새로운 단원을 시작하겠습니다.

44
00:01:09,190 --> 00:01:09,200
66강의 새로운 단원을 시작하겠습니다.
 

45
00:01:09,200 --> 00:01:12,030
66강의 새로운 단원을 시작하겠습니다.
그래프 이론에 대해

46
00:01:12,030 --> 00:01:12,040
그래프 이론에 대해
 

47
00:01:12,040 --> 00:01:13,789
그래프 이론에 대해
이야기해 볼까요? 화면에 그래프가 나와 있죠.

48
00:01:13,789 --> 00:01:13,799
이야기해 볼까요? 화면에 그래프가 나와 있죠.
 

49
00:01:13,799 --> 00:01:15,870
이야기해 볼까요? 화면에 그래프가 나와 있죠.
물론

50
00:01:15,870 --> 00:01:17,469
물론
 

51
00:01:17,469 --> 00:01:17,479

 

52
00:01:17,479 --> 00:01:19,550

오늘 강의를 통해 좀 더 자세한 내용을 알려드리겠습니다. 제가

53
00:01:19,550 --> 00:01:19,560
오늘 강의를 통해 좀 더 자세한 내용을 알려드리겠습니다. 제가
 

54
00:01:19,560 --> 00:01:21,270
오늘 강의를 통해 좀 더 자세한 내용을 알려드리겠습니다. 제가
가르치는 법을 배우던 시절(지금도 배우고 있지만요)에

55
00:01:21,270 --> 00:01:22,950
가르치는 법을 배우던 시절(지금도 배우고 있지만요)에
 

56
00:01:22,950 --> 00:01:22,960

 

57
00:01:22,960 --> 00:01:25,789

제 박사 지도교수님께서 "

58
00:01:25,789 --> 00:01:25,799
제 박사 지도교수님께서 "
 

59
00:01:25,799 --> 00:01:26,950
제 박사 지도교수님께서 "
누군가에게

60
00:01:26,950 --> 00:01:26,960
누군가에게
 

61
00:01:26,960 --> 00:01:28,510
누군가에게
무언가를 가르치려면 최대한

62
00:01:28,510 --> 00:01:28,520
무언가를 가르치려면 최대한
 

63
00:01:28,520 --> 00:01:30,350
무언가를 가르치려면 최대한
크게 써야 한다"고 말씀하셨는데요. 그래서

64
00:01:30,350 --> 00:01:30,360
크게 써야 한다"고 말씀하셨는데요. 그래서
 

65
00:01:30,360 --> 00:01:32,389
크게 써야 한다"고 말씀하셨는데요. 그래서
오늘

66
00:01:32,389 --> 00:01:32,399
오늘
 

67
00:01:32,399 --> 00:01:35,870
오늘
슬라이드에서도 그 방식을 활용하고 있습니다. 어쨌든,

68
00:01:35,870 --> 00:01:35,880
슬라이드에서도 그 방식을 활용하고 있습니다. 어쨌든,
 

69
00:01:35,880 --> 00:01:37,030
슬라이드에서도 그 방식을 활용하고 있습니다. 어쨌든,
오늘은 그래프에 대한

70
00:01:37,030 --> 00:01:37,040
오늘은 그래프에 대한
 

71
00:01:37,040 --> 00:01:39,670
오늘은 그래프에 대한
첫 번째 강의를 할 건데요, 아마

72
00:01:39,670 --> 00:01:39,680
첫 번째 강의를 할 건데요, 아마
 

73
00:01:39,680 --> 00:01:42,350
첫 번째 강의를 할 건데요, 아마
많은 분들에게는 복습이 될 것 같고, 그렇지

74
00:01:42,350 --> 00:01:42,360
많은 분들에게는 복습이 될 것 같고, 그렇지
 

75
00:01:42,360 --> 00:01:44,590
많은 분들에게는 복습이 될 것 같고, 그렇지
않더라도 괜찮습니다.

76
00:01:44,590 --> 00:01:45,469
않더라도 괜찮습니다.
 

77
00:01:45,469 --> 00:01:45,479

 

78
00:01:45,479 --> 00:01:46,789

처음부터 시작해서

79
00:01:46,789 --> 00:01:49,109
처음부터 시작해서
 

80
00:01:49,109 --> 00:01:49,119

 

81
00:01:49,119 --> 00:01:50,550

그래프를 이해하고 다루는 데 필요한 개념들을 차근차근 쌓아갈 거고, 강의가 끝날 때쯤에는

82
00:01:50,550 --> 00:01:54,030
그래프를 이해하고 다루는 데 필요한 개념들을 차근차근 쌓아갈 거고, 강의가 끝날 때쯤에는
 

83
00:01:54,030 --> 00:01:54,040

 

84
00:01:54,040 --> 00:01:55,590

한 정점에서 다른 모든 정점까지의 최단 경로를 계산하는 알고리즘을 익힐 수 있기를 바랍니다. 혹시 용어를

85
00:01:55,590 --> 00:01:57,069
한 정점에서 다른 모든 정점까지의 최단 경로를 계산하는 알고리즘을 익힐 수 있기를 바랍니다. 혹시 용어를
 

86
00:01:57,069 --> 00:01:57,079

 

87
00:01:57,079 --> 00:02:00,029

잊어버렸을까 봐 다시 한번 설명드리자면,

88
00:02:00,029 --> 00:02:00,039
잊어버렸을까 봐 다시 한번 설명드리자면,
 

89
00:02:00,039 --> 00:02:02,270
잊어버렸을까 봐 다시 한번 설명드리자면,
그래프는 어떤 사람들은

90
00:02:02,270 --> 00:02:02,280
그래프는 어떤 사람들은
 

91
00:02:02,280 --> 00:02:04,109
그래프는 어떤 사람들은
네트워크라고도 부르는데, 이 용어는 여러 가지

92
00:02:04,109 --> 00:02:05,950
네트워크라고도 부르는데, 이 용어는 여러 가지
 

93
00:02:05,950 --> 00:02:05,960

 

94
00:02:05,960 --> 00:02:08,109

의미로 쓰이기도 합니다.  그래프는

95
00:02:08,109 --> 00:02:08,119
의미로 쓰이기도 합니다.  그래프는
 

96
00:02:08,119 --> 00:02:10,150
의미로 쓰이기도 합니다.  그래프는
두 가지 요소의 집합이죠.

97
00:02:10,150 --> 00:02:10,160
두 가지 요소의 집합이죠.
 

98
00:02:10,160 --> 00:02:11,790
두 가지 요소의 집합이죠.
이 괄호 표기법은 정점

99
00:02:11,790 --> 00:02:11,800
이 괄호 표기법은 정점
 

100
00:02:11,800 --> 00:02:14,630
이 괄호 표기법은 정점
집합과 간선

101
00:02:14,630 --> 00:02:14,640
집합과 간선
 

102
00:02:14,640 --> 00:02:18,110
집합과 간선
집합을 나타냅니다. 화면의

103
00:02:18,110 --> 00:02:18,120
집합을 나타냅니다. 화면의
 

104
00:02:18,120 --> 00:02:19,550
집합을 나타냅니다. 화면의
세 번째 부분에서 볼 수 있듯이, 간선은 정점과 간선의 외적의 부분집합입니다.

105
00:02:19,550 --> 00:02:22,869
세 번째 부분에서 볼 수 있듯이, 간선은 정점과 간선의 외적의 부분집합입니다.
 

106
00:02:22,869 --> 00:02:22,879

 

107
00:02:22,879 --> 00:02:24,830

이 표기법은 아주

108
00:02:24,830 --> 00:02:26,309
이 표기법은 아주
 

109
00:02:26,309 --> 00:02:26,319

 

110
00:02:26,319 --> 00:02:28,110

간단한 것을 복잡하게 표현한 것일 뿐입니다.

111
00:02:28,110 --> 00:02:30,270
간단한 것을 복잡하게 표현한 것일 뿐입니다.
 

112
00:02:30,270 --> 00:02:30,280

 

113
00:02:30,280 --> 00:02:31,509

화면에 보이는 그림처럼, 간선은

114
00:02:31,509 --> 00:02:33,270
화면에 보이는 그림처럼, 간선은
 

115
00:02:33,270 --> 00:02:33,280

 

116
00:02:33,280 --> 00:02:34,949

두 정점을 연결하는 요소입니다. 예를 들어, 시작 정점

117
00:02:34,949 --> 00:02:36,790
두 정점을 연결하는 요소입니다. 예를 들어, 시작 정점
 

118
00:02:36,790 --> 00:02:38,630

 

119
00:02:38,630 --> 00:02:38,640

 

120
00:02:38,640 --> 00:02:41,550

과 끝 정점은 정점과 간선

121
00:02:41,550 --> 00:02:41,560
과 끝 정점은 정점과 간선
 

122
00:02:41,560 --> 00:02:43,710
과 끝 정점은 정점과 간선
의 외적의 부분집합입니다.

123
00:02:43,710 --> 00:02:45,390
의 외적의 부분집합입니다.
 

124
00:02:45,390 --> 00:02:45,400

 

125
00:02:45,400 --> 00:02:46,910

화면의 세 번째 줄에 있는 표기법이 이해가 되셨으면 좋겠습니다. 이 표기법은

126
00:02:46,910 --> 00:02:48,910
화면의 세 번째 줄에 있는 표기법이 이해가 되셨으면 좋겠습니다. 이 표기법은
 

127
00:02:48,910 --> 00:02:48,920

 

128
00:02:48,920 --> 00:02:51,509

간선 또는 정점 쌍을 나타내는 간단한 표현입니다. 물론

129
00:02:51,509 --> 00:02:53,470
간선 또는 정점 쌍을 나타내는 간단한 표현입니다. 물론
 

130
00:02:53,470 --> 00:02:55,670

 

131
00:02:55,670 --> 00:02:55,680

 

132
00:02:55,680 --> 00:02:58,110

이 표기법에는 두 가지 특별한 경우가 있는데, 하나는

133
00:02:58,110 --> 00:02:58,120
이 표기법에는 두 가지 특별한 경우가 있는데, 하나는
 

134
00:02:58,120 --> 00:02:59,710
이 표기법에는 두 가지 특별한 경우가 있는데, 하나는
방향 그래프이고 다른 하나는 무

135
00:02:59,710 --> 00:02:59,720
방향 그래프이고 다른 하나는 무
 

136
00:02:59,720 --> 00:03:01,790
방향 그래프이고 다른 하나는 무
방향 그래프입니다. 화면에 표시된 순서와는

137
00:03:01,790 --> 00:03:01,800
방향 그래프입니다. 화면에 표시된 순서와는
 

138
00:03:01,800 --> 00:03:03,110
방향 그래프입니다. 화면에 표시된 순서와는
반대로 말씀드렸네요.  자,

139
00:03:03,110 --> 00:03:03,120
반대로 말씀드렸네요.  자,
 

140
00:03:03,120 --> 00:03:06,190
반대로 말씀드렸네요.  자,
무방향

141
00:03:06,190 --> 00:03:06,200
무방향
 

142
00:03:06,200 --> 00:03:08,430
무방향
그래프에서 간선은 여전히

143
00:03:08,430 --> 00:03:08,440
그래프에서 간선은 여전히
 

144
00:03:08,440 --> 00:03:09,949
그래프에서 간선은 여전히
두 정점의 연결 고리라고 생각하지만,

145
00:03:09,949 --> 00:03:11,149
두 정점의 연결 고리라고 생각하지만,
 

146
00:03:11,149 --> 00:03:11,159

 

147
00:03:11,159 --> 00:03:12,390

사실 표기법을 조금 다르게 해야 할 것 같습니다. 아마 수업

148
00:03:12,390 --> 00:03:12,400
사실 표기법을 조금 다르게 해야 할 것 같습니다. 아마 수업
 

149
00:03:12,400 --> 00:03:14,270
사실 표기법을 조금 다르게 해야 할 것 같습니다. 아마 수업
전에 슬라이드를 수정해야 할 것 같아요. 예를 들어

150
00:03:14,270 --> 00:03:14,280
전에 슬라이드를 수정해야 할 것 같아요. 예를 들어
 

151
00:03:14,280 --> 00:03:17,830
전에 슬라이드를 수정해야 할 것 같아요. 예를 들어
E =

152
00:03:17,830 --> 00:03:17,840
E =
 

153
00:03:17,840 --> 00:03:21,270
E =
W 쉼표 V라고 쓰는 대신

154
00:03:21,270 --> 00:03:21,280
W 쉼표 V라고 쓰는 대신
 

155
00:03:21,280 --> 00:03:25,589
W 쉼표 V라고 쓰는 대신
E = V 쉼표 W라고 써야 할 것 같습니다.

156
00:03:25,589 --> 00:03:27,309
E = V 쉼표 W라고 써야 할 것 같습니다.
 

157
00:03:27,309 --> 00:03:27,319

 

158
00:03:27,319 --> 00:03:28,869

슬라이드와

159
00:03:28,869 --> 00:03:28,879
슬라이드와
 

160
00:03:28,879 --> 00:03:30,429
슬라이드와
칠판에 쓴 표기법에 약간의 차이가 있다는 점에 주목하세요. 바로 이 집합

161
00:03:30,429 --> 00:03:30,439
칠판에 쓴 표기법에 약간의 차이가 있다는 점에 주목하세요. 바로 이 집합
 

162
00:03:30,439 --> 00:03:32,949
칠판에 쓴 표기법에 약간의 차이가 있다는 점에 주목하세요. 바로 이 집합
표기법입니다.

163
00:03:32,949 --> 00:03:32,959
표기법입니다.
 

164
00:03:32,959 --> 00:03:35,070
표기법입니다.
괄호와 물결선의 차이점은

165
00:03:35,070 --> 00:03:35,080
괄호와 물결선의 차이점은
 

166
00:03:35,080 --> 00:03:36,910
괄호와 물결선의 차이점은
괄호는 순서가 없는

167
00:03:36,910 --> 00:03:36,920
괄호는 순서가 없는
 

168
00:03:36,920 --> 00:03:39,470
괄호는 순서가 없는
집합을 나타내고, 칠판

169
00:03:39,470 --> 00:03:39,480
집합을 나타내고, 칠판
 

170
00:03:39,480 --> 00:03:41,670
집합을 나타내고, 칠판
이나

171
00:03:41,670 --> 00:03:41,680
이나
 

172
00:03:41,680 --> 00:03:43,670
이나
화면에 적힌 것은 순서가 있는 집합을 나타낸다는 것입니다. 물론 무

173
00:03:43,670 --> 00:03:43,680
화면에 적힌 것은 순서가 있는 집합을 나타낸다는 것입니다. 물론 무
 

174
00:03:43,680 --> 00:03:45,589
화면에 적힌 것은 순서가 있는 집합을 나타낸다는 것입니다. 물론 무
방향 그래프에서는 W

175
00:03:45,589 --> 00:03:45,599
방향 그래프에서는 W
 

176
00:03:45,599 --> 00:03:48,550
방향 그래프에서는 W
에서 V로 가는 간선과

177
00:03:48,550 --> 00:03:48,560
에서 V로 가는 간선과
 

178
00:03:48,560 --> 00:03:50,309
에서 V로 가는 간선과
V에서 W로 가는 간선이 서로 다른 것이 아닙니다. 둘 다 같은 간선입니다. 단지

179
00:03:50,309 --> 00:03:52,030
V에서 W로 가는 간선이 서로 다른 것이 아닙니다. 둘 다 같은 간선입니다. 단지
 

180
00:03:52,030 --> 00:03:52,040

 

181
00:03:52,040 --> 00:03:54,630

연결성을 나타내는 개념일 뿐이죠. 반면에

182
00:03:54,630 --> 00:03:54,640
연결성을 나타내는 개념일 뿐이죠. 반면에
 

183
00:03:54,640 --> 00:03:56,309
연결성을 나타내는 개념일 뿐이죠. 반면에
방향 그래프에서는

184
00:03:56,309 --> 00:03:59,069
방향 그래프에서는
 

185
00:03:59,069 --> 00:03:59,079

 

186
00:03:59,079 --> 00:04:02,270

W에서 V로 가는 간선을 나타낼 때 괄호 표기법을 사용합니다.

187
00:04:02,270 --> 00:04:02,280
W에서 V로 가는 간선을 나타낼 때 괄호 표기법을 사용합니다.
 

188
00:04:02,280 --> 00:04:04,589
W에서 V로 가는 간선을 나타낼 때 괄호 표기법을 사용합니다.
V에서 W로 가는 간선과는 다르다는 점이

189
00:04:04,589 --> 00:04:04,599
V에서 W로 가는 간선과는 다르다는 점이
 

190
00:04:04,599 --> 00:04:07,149
V에서 W로 가는 간선과는 다르다는 점이
큰 차이를 만들 거예요. 예를 들어, 오른쪽

191
00:04:07,149 --> 00:04:07,159
큰 차이를 만들 거예요. 예를 들어, 오른쪽
 

192
00:04:07,159 --> 00:04:09,589
큰 차이를 만들 거예요. 예를 들어, 오른쪽
그래프를

193
00:04:09,589 --> 00:04:09,599
그래프를
 

194
00:04:09,599 --> 00:04:12,750
그래프를
칠판에 다시 그려볼게요.

195
00:04:12,750 --> 00:04:12,760
칠판에 다시 그려볼게요.
 

196
00:04:12,760 --> 00:04:14,830
칠판에 다시 그려볼게요.
네 개의 정점이 있죠. 어젯밤에 그렸는데,

197
00:04:14,830 --> 00:04:14,840
네 개의 정점이 있죠. 어젯밤에 그렸는데,
 

198
00:04:14,840 --> 00:04:16,550
네 개의 정점이 있죠. 어젯밤에 그렸는데,
이 예시가 잘

199
00:04:16,550 --> 00:04:16,560
이 예시가 잘
 

200
00:04:16,560 --> 00:04:20,509
이 예시가 잘
작동했으면 좋겠네요.

201
00:04:20,509 --> 00:04:23,230

 

202
00:04:23,230 --> 00:04:23,240

 

203
00:04:23,240 --> 00:04:25,950

오른쪽 위

204
00:04:25,950 --> 00:04:25,960
오른쪽 위
 

205
00:04:25,960 --> 00:04:28,310
오른쪽 위
정점에서 왼쪽 아래 정점까지 간선을

206
00:04:28,310 --> 00:04:28,320
정점에서 왼쪽 아래 정점까지 간선을
 

207
00:04:28,320 --> 00:04:31,510
정점에서 왼쪽 아래 정점까지 간선을
따라

208
00:04:31,510 --> 00:04:34,350
따라
 

209
00:04:34,350 --> 00:04:38,070

 

210
00:04:38,070 --> 00:04:39,550

 

211
00:04:39,550 --> 00:04:42,029

 

212
00:04:42,029 --> 00:04:42,039

 

213
00:04:42,039 --> 00:04:44,990

갈 수 있을까요? 1, 2, 3 ...

214
00:04:44,990 --> 00:04:47,070
갈 수 있을까요? 1, 2, 3 ...
 

215
00:04:47,070 --> 00:04:49,270

 

216
00:04:49,270 --> 00:04:50,629

 

217
00:04:50,629 --> 00:04:53,390

 

218
00:04:53,390 --> 00:04:54,749

 

219
00:04:54,749 --> 00:04:56,749

 

220
00:04:56,749 --> 00:04:58,070

 

221
00:04:58,070 --> 00:04:59,950

 

222
00:04:59,950 --> 00:05:01,430

 

223
00:05:01,430 --> 00:05:03,270

 

224
00:05:03,270 --> 00:05:04,710

 

225
00:05:04,710 --> 00:05:06,749

 

226
00:05:06,749 --> 00:05:06,759

 

227
00:05:06,759 --> 00:05:08,029

여러분, 제가

228
00:05:08,029 --> 00:05:08,039
여러분, 제가
 

229
00:05:08,039 --> 00:05:09,990
여러분, 제가
4

230
00:05:09,990 --> 00:05:10,000
4
 

231
00:05:10,000 --> 00:05:11,749
4
분도

232
00:05:11,749 --> 00:05:11,759
분도
 

233
00:05:11,759 --> 00:05:13,390
분도
안 되는 시간에 여러분을 혼란스럽게 만든 건가요?

234
00:05:13,390 --> 00:05:13,400
안 되는 시간에 여러분을 혼란스럽게 만든 건가요?
 

235
00:05:13,400 --> 00:05:15,670
안 되는 시간에 여러분을 혼란스럽게 만든 건가요?
훌륭합니다! 그래서 저는

236
00:05:15,670 --> 00:05:15,680
훌륭합니다! 그래서 저는
 

237
00:05:15,680 --> 00:05:17,230
훌륭합니다! 그래서 저는
강의 노트에서 아주 조금 순서를 바꿨습니다.

238
00:05:17,230 --> 00:05:17,240
강의 노트에서 아주 조금 순서를 바꿨습니다.
 

239
00:05:17,240 --> 00:05:18,790
강의 노트에서 아주 조금 순서를 바꿨습니다.
그래프가 무엇인지 먼저 정의한 다음

240
00:05:18,790 --> 00:05:19,909
그래프가 무엇인지 먼저 정의한 다음
 

241
00:05:19,909 --> 00:05:19,919

 

242
00:05:19,919 --> 00:05:22,510

응용 사례를 설명하는 게 좋겠다고 생각했거든요. 어쨌든,

243
00:05:22,510 --> 00:05:24,710
응용 사례를 설명하는 게 좋겠다고 생각했거든요. 어쨌든,
 

244
00:05:24,710 --> 00:05:26,469

 

245
00:05:26,469 --> 00:05:26,479

 

246
00:05:26,479 --> 00:05:28,710

그래프는

247
00:05:28,710 --> 00:05:28,720
그래프는
 

248
00:05:28,720 --> 00:05:31,110
그래프는
우리 일상생활 어디에나 있다고 해도 과언이 아닐 겁니다. 여러 가지가

249
00:05:31,110 --> 00:05:33,670
우리 일상생활 어디에나 있다고 해도 과언이 아닐 겁니다. 여러 가지가
 

250
00:05:33,670 --> 00:05:33,680

 

251
00:05:33,680 --> 00:05:35,990

연결된 네트워크를

252
00:05:35,990 --> 00:05:37,830
연결된 네트워크를
 

253
00:05:37,830 --> 00:05:37,840

 

254
00:05:37,840 --> 00:05:40,430

생각할 때, 우리 머릿속에는 무의식적으로 그래프라는 추상적인 개념이 자리 잡고 있죠.

255
00:05:40,430 --> 00:05:40,440
생각할 때, 우리 머릿속에는 무의식적으로 그래프라는 추상적인 개념이 자리 잡고 있죠.
 

256
00:05:40,440 --> 00:05:42,150
생각할 때, 우리 머릿속에는 무의식적으로 그래프라는 추상적인 개념이 자리 잡고 있죠.
간단한 예로는

257
00:05:42,150 --> 00:05:43,830
간단한 예로는
 

258
00:05:43,830 --> 00:05:43,840

 

259
00:05:43,840 --> 00:05:45,870

컴퓨터 네트워크를 들 수 있습니다. 여기서

260
00:05:45,870 --> 00:05:45,880
컴퓨터 네트워크를 들 수 있습니다. 여기서
 

261
00:05:45,880 --> 00:05:48,390
컴퓨터 네트워크를 들 수 있습니다. 여기서
노드 또는 정점은

262
00:05:48,390 --> 00:05:48,400
노드 또는 정점은
 

263
00:05:48,400 --> 00:05:49,990
노드 또는 정점은
컴퓨터이고,

264
00:05:49,990 --> 00:05:50,000
컴퓨터이고,
 

265
00:05:50,000 --> 00:05:52,029
컴퓨터이고,
간선은 컴퓨터

266
00:05:52,029 --> 00:05:52,039
간선은 컴퓨터
 

267
00:05:52,039 --> 00:05:53,870
간선은 컴퓨터
들을 연결하는 케이블이라고 생각하면 됩니다.

268
00:05:53,870 --> 00:05:55,350
들을 연결하는 케이블이라고 생각하면 됩니다.
 

269
00:05:55,350 --> 00:05:55,360

 

270
00:05:55,360 --> 00:05:58,390

또는 소셜

271
00:05:58,390 --> 00:05:58,400
또는 소셜
 

272
00:05:58,400 --> 00:06:00,990
또는 소셜
네트워크를 예로 들면, 노드는

273
00:06:00,990 --> 00:06:01,000
네트워크를 예로 들면, 노드는
 

274
00:06:01,000 --> 00:06:03,110
네트워크를 예로 들면, 노드는
소셜 네트워크에 있는 사람들이고, 간선은

275
00:06:03,110 --> 00:06:03,120
소셜 네트워크에 있는 사람들이고, 간선은
 

276
00:06:03,120 --> 00:06:05,350
소셜 네트워크에 있는 사람들이고, 간선은
친구 관계나

277
00:06:05,350 --> 00:06:05,360
친구 관계나
 

278
00:06:05,360 --> 00:06:07,270
친구 관계나
친밀한 관계 등을 나타낼 수 있습니다.

279
00:06:07,270 --> 00:06:07,280
친밀한 관계 등을 나타낼 수 있습니다.
 

280
00:06:07,280 --> 00:06:08,950
친밀한 관계 등을 나타낼 수 있습니다.
사실,

281
00:06:08,950 --> 00:06:08,960
사실,
 

282
00:06:08,960 --> 00:06:11,309
사실,
방향 그래프와 무방향 그래프 모두 생각해 볼 수 있을 것 같습니다.

283
00:06:11,309 --> 00:06:13,749
방향 그래프와 무방향 그래프 모두 생각해 볼 수 있을 것 같습니다.
 

284
00:06:13,749 --> 00:06:13,759

 

285
00:06:13,759 --> 00:06:16,270

도로망, 그러니까 도로망에 대해 이야기해 볼까요? 제가

286
00:06:16,270 --> 00:06:17,629
도로망, 그러니까 도로망에 대해 이야기해 볼까요? 제가
 

287
00:06:17,629 --> 00:06:17,639

 

288
00:06:17,639 --> 00:06:19,870

구글에서 일한다고 가정해 볼게요. 저는 여러분의

289
00:06:19,870 --> 00:06:19,880
구글에서 일한다고 가정해 볼게요. 저는 여러분의
 

290
00:06:19,880 --> 00:06:22,309
구글에서 일한다고 가정해 볼게요. 저는 여러분의
집에서 MIT까지의 최단 경로를 알려드리고 싶습니다.

291
00:06:22,309 --> 00:06:22,319
집에서 MIT까지의 최단 경로를 알려드리고 싶습니다.
 

292
00:06:22,319 --> 00:06:24,070
집에서 MIT까지의 최단 경로를 알려드리고 싶습니다.
물론, 그렇게 하려면

293
00:06:24,070 --> 00:06:24,080
물론, 그렇게 하려면
 

294
00:06:24,080 --> 00:06:25,350
물론, 그렇게 하려면
기본적으로

295
00:06:25,350 --> 00:06:27,469
기본적으로
 

296
00:06:27,469 --> 00:06:29,270

 

297
00:06:29,270 --> 00:06:29,280

 

298
00:06:29,280 --> 00:06:30,390

그래프에서 두 정점 사이의 최단 경로를 계산하는 문제를 풀어야 합니다. 하지만

299
00:06:30,390 --> 00:06:31,710
그래프에서 두 정점 사이의 최단 경로를 계산하는 문제를 풀어야 합니다. 하지만
 

300
00:06:31,710 --> 00:06:31,720

 

301
00:06:31,720 --> 00:06:33,110

이

302
00:06:33,110 --> 00:06:33,120
이
 

303
00:06:33,120 --> 00:06:34,950
이
문제에는 우리가 이 강의에서 활용하지 않을 많은 구조적 요소가 있다는 점에서 약간 거짓말이라고 할 수 있겠네요.

304
00:06:34,950 --> 00:06:34,960
문제에는 우리가 이 강의에서 활용하지 않을 많은 구조적 요소가 있다는 점에서 약간 거짓말이라고 할 수 있겠네요.
 

305
00:06:34,960 --> 00:06:36,510
문제에는 우리가 이 강의에서 활용하지 않을 많은 구조적 요소가 있다는 점에서 약간 거짓말이라고 할 수 있겠네요.
도로망은

306
00:06:36,510 --> 00:06:36,520
도로망은
 

307
00:06:36,520 --> 00:06:38,909
도로망은
매우 특별한 유형의 그래프입니다.

308
00:06:38,909 --> 00:06:38,919
매우 특별한 유형의 그래프입니다.
 

309
00:06:38,919 --> 00:06:40,550
매우 특별한 유형의 그래프입니다.
고급 과정을 수강한다면,

310
00:06:40,550 --> 00:06:42,430
고급 과정을 수강한다면,
 

311
00:06:42,430 --> 00:06:42,440

 

312
00:06:42,440 --> 00:06:44,189

그래프에 대해 좀 더 잘 알면 일반적인 경우보다 더 나은 결과를 낼 수 있다고 생각할 수도 있겠죠.

313
00:06:44,189 --> 00:06:46,469
그래프에 대해 좀 더 잘 알면 일반적인 경우보다 더 나은 결과를 낼 수 있다고 생각할 수도 있겠죠.
 

314
00:06:46,469 --> 00:06:46,479

 

315
00:06:46,479 --> 00:06:47,909

하지만

316
00:06:47,909 --> 00:06:47,919
하지만
 

317
00:06:47,919 --> 00:06:50,550
하지만
66번째 강의에서 다룰 기본 알고리즘은 이 경우에도 분명히 관련이 있으며, 여러분이

318
00:06:50,550 --> 00:06:52,110
66번째 강의에서 다룰 기본 알고리즘은 이 경우에도 분명히 관련이 있으며, 여러분이
 

319
00:06:52,110 --> 00:06:53,950

 

320
00:06:53,950 --> 00:06:53,960

 

321
00:06:53,960 --> 00:06:55,749

매일 스마트

322
00:06:55,749 --> 00:06:55,759
매일 스마트
 

323
00:06:55,759 --> 00:06:57,629
매일 스마트
폰에서 구글 지도나 웨이보 등을 사용할 때 사용하는 도구들의 기본 구성 요소가 됩니다.

324
00:06:57,629 --> 00:06:59,629
폰에서 구글 지도나 웨이보 등을 사용할 때 사용하는 도구들의 기본 구성 요소가 됩니다.
 

325
00:06:59,629 --> 00:06:59,639

 

326
00:06:59,639 --> 00:07:00,710

물론 다른 많은 도구들도 있죠. 예를 들어,

327
00:07:00,710 --> 00:07:02,869
물론 다른 많은 도구들도 있죠. 예를 들어,
 

328
00:07:02,869 --> 00:07:02,879

 

329
00:07:02,879 --> 00:07:04,510

조금 더

330
00:07:04,510 --> 00:07:04,520
조금 더
 

331
00:07:04,520 --> 00:07:06,589
조금 더
미묘한 예시로는 집합이 있습니다.

332
00:07:06,589 --> 00:07:06,599
미묘한 예시로는 집합이 있습니다.
 

333
00:07:06,599 --> 00:07:08,830
미묘한 예시로는 집합이 있습니다.
이산적인 사물의 상태와 전이를

334
00:07:08,830 --> 00:07:08,840
이산적인 사물의 상태와 전이를
 

335
00:07:08,840 --> 00:07:11,510
이산적인 사물의 상태와 전이를
생각해 보세요. 예를 들어 루빅 큐브를 생각해 보면,

336
00:07:11,510 --> 00:07:11,520
생각해 보세요. 예를 들어 루빅 큐브를 생각해 보면,
 

337
00:07:11,520 --> 00:07:13,629
생각해 보세요. 예를 들어 루빅 큐브를 생각해 보면,
노드는

338
00:07:13,629 --> 00:07:13,639
노드는
 

339
00:07:13,639 --> 00:07:15,670
노드는
루빅 큐브의 모든 회전 상태를 나타내고,

340
00:07:15,670 --> 00:07:17,790
루빅 큐브의 모든 회전 상태를 나타내고,
 

341
00:07:17,790 --> 00:07:17,800

 

342
00:07:17,800 --> 00:07:20,350

엣지는 한 번의

343
00:07:20,350 --> 00:07:22,309
엣지는 한 번의
 

344
00:07:22,309 --> 00:07:22,319

 

345
00:07:22,319 --> 00:07:24,589

간단한 전이(예: 뒤집기)로 이 상태에서 저 상태로 이동할 수 있는지를 나타내는 그래프를 만들 수 있습니다.

346
00:07:24,589 --> 00:07:25,790
간단한 전이(예: 뒤집기)로 이 상태에서 저 상태로 이동할 수 있는지를 나타내는 그래프를 만들 수 있습니다.
 

347
00:07:25,790 --> 00:07:25,800

 

348
00:07:25,800 --> 00:07:27,749

루빅 큐브 용어는 잘 모르겠지만, 아마 아실 것 같네요. 한

349
00:07:27,749 --> 00:07:27,759
루빅 큐브 용어는 잘 모르겠지만, 아마 아실 것 같네요. 한
 

350
00:07:27,759 --> 00:07:29,869
루빅 큐브 용어는 잘 모르겠지만, 아마 아실 것 같네요. 한
번의 회전은

351
00:07:29,869 --> 00:07:29,879
번의 회전은
 

352
00:07:29,879 --> 00:07:31,749
번의 회전은
비틀기라고 하죠. 감사합니다.

353
00:07:31,749 --> 00:07:31,759
비틀기라고 하죠. 감사합니다.
 

354
00:07:31,759 --> 00:07:33,830
비틀기라고 하죠. 감사합니다.
물론 다른

355
00:07:33,830 --> 00:07:33,840
물론 다른
 

356
00:07:33,840 --> 00:07:36,430
물론 다른
곳에서도 많이 볼 수 있습니다. 예를 들어,

357
00:07:36,430 --> 00:07:36,440
곳에서도 많이 볼 수 있습니다. 예를 들어,
 

358
00:07:36,440 --> 00:07:38,550
곳에서도 많이 볼 수 있습니다. 예를 들어,
저는 MIT에서

359
00:07:38,550 --> 00:07:38,560
저는 MIT에서
 

360
00:07:38,560 --> 00:07:40,670
저는 MIT에서
컴퓨터 그래픽스 강의를 하는데,

361
00:07:40,670 --> 00:07:40,680
컴퓨터 그래픽스 강의를 하는데,
 

362
00:07:40,680 --> 00:07:42,350
컴퓨터 그래픽스 강의를 하는데,
그래프 이론은 우리가 매우 다르게 이야기하지만

363
00:07:42,350 --> 00:07:44,110
그래프 이론은 우리가 매우 다르게 이야기하지만
 

364
00:07:44,110 --> 00:07:44,120

 

365
00:07:44,120 --> 00:07:46,869

그 분야에서 끊임없이 등장합니다.

366
00:07:46,869 --> 00:07:46,879
그 분야에서 끊임없이 등장합니다.
 

367
00:07:46,879 --> 00:07:48,390
그 분야에서 끊임없이 등장합니다.
왜냐하면 컴퓨터의 모든 3D 모델 뒤에는 거대한 삼각형

368
00:07:48,390 --> 00:07:50,149
왜냐하면 컴퓨터의 모든 3D 모델 뒤에는 거대한 삼각형
 

369
00:07:50,149 --> 00:07:50,159

 

370
00:07:50,159 --> 00:07:53,189

네트워크가 있기 때문입니다. 이것을

371
00:07:53,189 --> 00:07:53,199
네트워크가 있기 때문입니다. 이것을
 

372
00:07:53,199 --> 00:07:55,029
네트워크가 있기 때문입니다. 이것을
삼각 표면이라고 하는데,

373
00:07:55,029 --> 00:07:55,039
삼각 표면이라고 하는데,
 

374
00:07:55,039 --> 00:07:57,149
삼각 표면이라고 하는데,
여기 보이는 황소자리 모양처럼 말이죠. 이것은 다름 아닌

375
00:07:57,149 --> 00:07:57,159
여기 보이는 황소자리 모양처럼 말이죠. 이것은 다름 아닌
 

376
00:07:57,159 --> 00:07:58,869
여기 보이는 황소자리 모양처럼 말이죠. 이것은 다름 아닌
그래프입니다. 사실,

377
00:07:58,869 --> 00:07:58,879
그래프입니다. 사실,
 

378
00:07:58,879 --> 00:08:01,430
그래프입니다. 사실,
6838 강의에서 다루는 알고리즘을 자세히 보면,

379
00:08:01,430 --> 00:08:01,440
6838 강의에서 다루는 알고리즘을 자세히 보면,
 

380
00:08:01,440 --> 00:08:03,469
6838 강의에서 다루는 알고리즘을 자세히 보면,
그것들이 변형된

381
00:08:03,469 --> 00:08:03,479
그것들이 변형된
 

382
00:08:03,479 --> 00:08:05,909
그것들이 변형된
그래프 알고리즘이라는 것을 알 수 있습니다. 제 강의를 예로 들어보겠습니다.

383
00:08:05,909 --> 00:08:05,919
그래프 알고리즘이라는 것을 알 수 있습니다. 제 강의를 예로 들어보겠습니다.
 

384
00:08:05,919 --> 00:08:07,230
그래프 알고리즘이라는 것을 알 수 있습니다. 제 강의를 예로 들어보겠습니다.
대학원 수업에서 우리는 미분

385
00:08:07,230 --> 00:08:08,909
대학원 수업에서 우리는 미분
 

386
00:08:08,909 --> 00:08:08,919

 

387
00:08:08,919 --> 00:08:10,230

기하를 많이 공부할 겁니다. 그리고 나서 한 발짝 물러서서 생각해 보면,

388
00:08:10,230 --> 00:08:12,350
기하를 많이 공부할 겁니다. 그리고 나서 한 발짝 물러서서 생각해 보면,
 

389
00:08:12,350 --> 00:08:13,990

 

390
00:08:13,990 --> 00:08:16,029

 

391
00:08:16,029 --> 00:08:16,039

 

392
00:08:16,039 --> 00:08:18,710

삼각형 메쉬의 곡률과 굴곡도를 계산하는 데 사용했던 알고리즘들이

393
00:08:18,710 --> 00:08:18,720
삼각형 메쉬의 곡률과 굴곡도를 계산하는 데 사용했던 알고리즘들이
 

394
00:08:18,720 --> 00:08:20,270
삼각형 메쉬의 곡률과 굴곡도를 계산하는 데 사용했던 알고리즘들이
그래프 알고리즘처럼 보이고,

395
00:08:20,270 --> 00:08:20,280
그래프 알고리즘처럼 보이고,
 

396
00:08:20,280 --> 00:08:21,990
그래프 알고리즘처럼 보이고,
네트워크에도

397
00:08:21,990 --> 00:08:22,000
네트워크에도
 

398
00:08:22,000 --> 00:08:23,749
네트워크에도
똑같은 방식으로 적용될 수 있다는 것을 알게 될 겁니다. 꽤 재밌는 발견이 될 거예요.

399
00:08:23,749 --> 00:08:26,790
똑같은 방식으로 적용될 수 있다는 것을 알게 될 겁니다. 꽤 재밌는 발견이 될 거예요.
 

400
00:08:26,790 --> 00:08:26,800

 

401
00:08:26,800 --> 00:08:29,110

마지막으로 재밌는 응용 사례 하나를 소개하자면, 저는

402
00:08:29,110 --> 00:08:29,120
마지막으로 재밌는 응용 사례 하나를 소개하자면, 저는
 

403
00:08:29,120 --> 00:08:31,149
마지막으로 재밌는 응용 사례 하나를 소개하자면, 저는
최근 며칠 동안

404
00:08:31,149 --> 00:08:31,159
최근 며칠 동안
 

405
00:08:31,159 --> 00:08:32,350
최근 며칠 동안
정치 재분배에 관한 컨퍼런스에 참석했는데,

406
00:08:32,350 --> 00:08:34,350
정치 재분배에 관한 컨퍼런스에 참석했는데,
 

407
00:08:34,350 --> 00:08:34,360

 

408
00:08:34,360 --> 00:08:36,070

그 컨퍼런스에서 대부분의 논의가

409
00:08:36,070 --> 00:08:36,080
그 컨퍼런스에서 대부분의 논의가
 

410
00:08:36,080 --> 00:08:38,790
그 컨퍼런스에서 대부분의 논의가
그래프 이론에 관한 것이었습니다.

411
00:08:38,790 --> 00:08:38,800
그래프 이론에 관한 것이었습니다.
 

412
00:08:38,800 --> 00:08:42,190
그래프 이론에 관한 것이었습니다.
그 이유는

413
00:08:42,190 --> 00:08:43,870
그 이유는
 

414
00:08:43,870 --> 00:08:43,880

 

415
00:08:43,880 --> 00:08:46,630

기하학 분야에서 자주 등장하는 주제와 관련이 있기 때문입니다. 예를 들어, 어떤 주의 투표구들을

416
00:08:46,630 --> 00:08:46,640
기하학 분야에서 자주 등장하는 주제와 관련이 있기 때문입니다. 예를 들어, 어떤 주의 투표구들을
 

417
00:08:46,640 --> 00:08:47,949
기하학 분야에서 자주 등장하는 주제와 관련이 있기 때문입니다. 예를 들어, 어떤 주의 투표구들을
생각해 보고,

418
00:08:47,949 --> 00:08:50,389
생각해 보고,
 

419
00:08:50,389 --> 00:08:50,399

 

420
00:08:50,399 --> 00:08:52,790

인접 관계를 살펴보면,

421
00:08:52,790 --> 00:08:54,870
인접 관계를 살펴보면,
 

422
00:08:54,870 --> 00:08:54,880

 

423
00:08:54,880 --> 00:08:56,949

각 투표구마다 노드를 넣고,

424
00:08:56,949 --> 00:08:56,959
각 투표구마다 노드를 넣고,
 

425
00:08:56,959 --> 00:08:58,630
각 투표구마다 노드를 넣고,
경계를 공유하는 투표구들 사이에 간선을 연결한다고 가정해 봅시다. 그러면

426
00:08:58,630 --> 00:08:58,640
경계를 공유하는 투표구들 사이에 간선을 연결한다고 가정해 봅시다. 그러면
 

427
00:08:58,640 --> 00:09:01,389
경계를 공유하는 투표구들 사이에 간선을 연결한다고 가정해 봅시다. 그러면
네트워크가 만들어지고,

428
00:09:01,389 --> 00:09:01,399
네트워크가 만들어지고,
 

429
00:09:01,399 --> 00:09:03,190
네트워크가 만들어지고,
그래프의 특정 영역은

430
00:09:03,190 --> 00:09:03,200
그래프의 특정 영역은
 

431
00:09:03,200 --> 00:09:05,069
그래프의 특정 영역은
이 네트워크의 연결된 부분이라고 할 수 있습니다.

432
00:09:05,069 --> 00:09:05,079
이 네트워크의 연결된 부분이라고 할 수 있습니다.
 

433
00:09:05,079 --> 00:09:07,470
이 네트워크의 연결된 부분이라고 할 수 있습니다.
어, 그래서 어쨌든 이건

434
00:09:07,470 --> 00:09:07,480
어, 그래서 어쨌든 이건
 

435
00:09:07,480 --> 00:09:09,630
어, 그래서 어쨌든 이건
그래프, 네트워크,

436
00:09:09,630 --> 00:09:09,640
그래프, 네트워크,
 

437
00:09:09,640 --> 00:09:11,590
그래프, 네트워크,
연결성 등이 말 그대로

438
00:09:11,590 --> 00:09:11,600
연결성 등이 말 그대로
 

439
00:09:11,600 --> 00:09:13,069
연결성 등이 말 그대로
어디를 가든 나타나는 예시 중 하나입니다.

440
00:09:13,069 --> 00:09:13,079
어디를 가든 나타나는 예시 중 하나입니다.
 

441
00:09:13,079 --> 00:09:15,750
어디를 가든 나타나는 예시 중 하나입니다.
완전히 피할 수 없죠. 그래서

442
00:09:15,750 --> 00:09:16,949
완전히 피할 수 없죠. 그래서
 

443
00:09:16,949 --> 00:09:16,959

 

444
00:09:16,959 --> 00:09:19,230

이 수업에서 꽤 많은 시간을 할애할 겁니다.

445
00:09:19,230 --> 00:09:22,269
이 수업에서 꽤 많은 시간을 할애할 겁니다.
 

446
00:09:22,269 --> 00:09:25,110

 

447
00:09:25,110 --> 00:09:25,120

 

448
00:09:25,120 --> 00:09:27,750

MIT에서 그래프 이론 관련 수업을 세 개 이상 수강할 수도 있고,

449
00:09:27,750 --> 00:09:30,230
MIT에서 그래프 이론 관련 수업을 세 개 이상 수강할 수도 있고,
 

450
00:09:30,230 --> 00:09:31,630

 

451
00:09:31,630 --> 00:09:31,640

 

452
00:09:31,640 --> 00:09:33,630

그래프에 대한 아주 간단한 문제만 풀어서 박사 학위를 딸 수도 있습니다. 물론 이 수업에서는

453
00:09:33,630 --> 00:09:35,790
그래프에 대한 아주 간단한 문제만 풀어서 박사 학위를 딸 수도 있습니다. 물론 이 수업에서는
 

454
00:09:35,790 --> 00:09:38,069

 

455
00:09:38,069 --> 00:09:38,079

 

456
00:09:38,079 --> 00:09:39,750

많은 강의 중 몇 개로 제한되어 있기 때문에, 우리가 해결하고자

457
00:09:39,750 --> 00:09:39,760
많은 강의 중 몇 개로 제한되어 있기 때문에, 우리가 해결하고자
 

458
00:09:39,760 --> 00:09:41,150
많은 강의 중 몇 개로 제한되어 있기 때문에, 우리가 해결하고자
하는 문제

459
00:09:41,150 --> 00:09:41,160
하는 문제
 

460
00:09:41,160 --> 00:09:43,030
하는 문제
와

461
00:09:43,030 --> 00:09:43,040
와
 

462
00:09:43,040 --> 00:09:44,949
와
우리가 관심을 가질 그래프 모두에 대해 몇 가지 가정을 할 겁니다.

463
00:09:44,949 --> 00:09:44,959
우리가 관심을 가질 그래프 모두에 대해 몇 가지 가정을 할 겁니다.
 

464
00:09:44,959 --> 00:09:47,150
우리가 관심을 가질 그래프 모두에 대해 몇 가지 가정을 할 겁니다.
특히,

465
00:09:47,150 --> 00:09:48,829
특히,
 

466
00:09:48,829 --> 00:09:48,839

 

467
00:09:48,839 --> 00:09:50,310

우리가 다룰 알고리즘에 큰 영향을 주지는 않지만 명시적으로

468
00:09:50,310 --> 00:09:50,320
우리가 다룰 알고리즘에 큰 영향을 주지는 않지만 명시적으로
 

469
00:09:50,320 --> 00:09:52,829
우리가 다룰 알고리즘에 큰 영향을 주지는 않지만 명시적으로
언급할 가치가 있는 한 가지 단순화된 가정은,

470
00:09:52,829 --> 00:09:52,839
언급할 가치가 있는 한 가지 단순화된 가정은,
 

471
00:09:52,839 --> 00:09:54,750
언급할 가치가 있는 한 가지 단순화된 가정은,
우리가 주로

472
00:09:54,750 --> 00:09:54,760
우리가 주로
 

473
00:09:54,760 --> 00:09:56,269
우리가 주로
특정 유형의 그래프, 즉

474
00:09:56,269 --> 00:09:56,279
특정 유형의 그래프, 즉
 

475
00:09:56,279 --> 00:09:57,670
특정 유형의 그래프, 즉
단순

476
00:09:57,670 --> 00:09:57,680
단순
 

477
00:09:57,680 --> 00:10:00,110
단순
그래프를 생각할 것이라는 점입니다. 사실,

478
00:10:00,110 --> 00:10:00,120
그래프를 생각할 것이라는 점입니다. 사실,
 

479
00:10:00,120 --> 00:10:02,190
그래프를 생각할 것이라는 점입니다. 사실,
그래프를 어떻게 정의하느냐에 따라 종종...

480
00:10:02,190 --> 00:10:03,949
그래프를 어떻게 정의하느냐에 따라 종종...
 

481
00:10:03,949 --> 00:10:03,959

 

482
00:10:03,959 --> 00:10:05,430

의도치 않게 그래프를 단순하게 만들 수도 있습니다.

483
00:10:05,430 --> 00:10:05,440
의도치 않게 그래프를 단순하게 만들 수도 있습니다.
 

484
00:10:05,440 --> 00:10:07,790
의도치 않게 그래프를 단순하게 만들 수도 있습니다.
예를 들어, 간선이

485
00:10:07,790 --> 00:10:07,800
예를 들어, 간선이
 

486
00:10:07,800 --> 00:10:10,350
예를 들어, 간선이
V와 V의 부분집합이라고 썼는데, 이는

487
00:10:10,350 --> 00:10:12,710
V와 V의 부분집합이라고 썼는데, 이는
 

488
00:10:12,710 --> 00:10:14,990

 

489
00:10:14,990 --> 00:10:15,000

 

490
00:10:15,000 --> 00:10:17,710

같은 두 정점을 통과하는 간선이 여러 개 있을 수 없다는 것을 의미할 수 있습니다.

491
00:10:17,710 --> 00:10:17,720
같은 두 정점을 통과하는 간선이 여러 개 있을 수 없다는 것을 의미할 수 있습니다.
 

492
00:10:17,720 --> 00:10:20,389
같은 두 정점을 통과하는 간선이 여러 개 있을 수 없다는 것을 의미할 수 있습니다.
그럼 단순하지 않은 그래프의 예를 살펴보겠습니다.

493
00:10:20,389 --> 00:10:20,399
그럼 단순하지 않은 그래프의 예를 살펴보겠습니다.
 

494
00:10:20,399 --> 00:10:23,069
그럼 단순하지 않은 그래프의 예를 살펴보겠습니다.
죄송하지만

495
00:10:23,069 --> 00:10:23,079
죄송하지만
 

496
00:10:23,079 --> 00:10:24,990
죄송하지만
단순 그래프를 정의하지는 않았습니다. 단순 그래프는

497
00:10:24,990 --> 00:10:25,000
단순 그래프를 정의하지는 않았습니다. 단순 그래프는
 

498
00:10:25,000 --> 00:10:27,509
단순 그래프를 정의하지는 않았습니다. 단순 그래프는
자기 루프가 없는 그래프입니다. 즉, 한

499
00:10:27,509 --> 00:10:27,519
자기 루프가 없는 그래프입니다. 즉, 한
 

500
00:10:27,519 --> 00:10:30,269
자기 루프가 없는 그래프입니다. 즉, 한
정점에서 자기 자신으로 가는 간선이 없고

501
00:10:30,269 --> 00:10:30,279
정점에서 자기 자신으로 가는 간선이 없고
 

502
00:10:30,279 --> 00:10:32,750
정점에서 자기 자신으로 가는 간선이 없고
모든 간선이 서로 다릅니다.

503
00:10:32,750 --> 00:10:35,550
모든 간선이 서로 다릅니다.
 

504
00:10:35,550 --> 00:10:35,560

 

505
00:10:35,560 --> 00:10:39,470

생각할 수 있는 가장 복잡한 그래프를 만들어 보겠습니다. 두 정점이 있다고 가정해 봅시다.

506
00:10:39,470 --> 00:10:42,069
생각할 수 있는 가장 복잡한 그래프를 만들어 보겠습니다. 두 정점이 있다고 가정해 봅시다.
 

507
00:10:42,069 --> 00:10:42,079

 

508
00:10:42,079 --> 00:10:44,069

두

509
00:10:44,069 --> 00:10:44,079
두
 

510
00:10:44,079 --> 00:10:47,350
두
정점을 연결하는 간선이 하나 있는 그래프는 단순합니다. 하지만

511
00:10:47,350 --> 00:10:49,030
정점을 연결하는 간선이 하나 있는 그래프는 단순합니다. 하지만
 

512
00:10:49,030 --> 00:10:51,110

 

513
00:10:51,110 --> 00:10:53,269

 

514
00:10:53,269 --> 00:10:53,279

 

515
00:10:53,279 --> 00:10:56,310

재미삼아 이 간선을 세 번 복제하면 단순하지 않은 그래프가 됩니다. 이는 두 번째 가정을 위반하는 것입니다. 더 나아가,

516
00:10:56,310 --> 00:10:58,350
재미삼아 이 간선을 세 번 복제하면 단순하지 않은 그래프가 됩니다. 이는 두 번째 가정을 위반하는 것입니다. 더 나아가,
 

517
00:10:58,350 --> 00:11:00,030

 

518
00:11:00,030 --> 00:11:00,040

 

519
00:11:00,040 --> 00:11:01,990

이 정점에서 자기 자신으로 가는 간선을 추가하면 첫 번째 가정도 위반하게 됩니다.

520
00:11:01,990 --> 00:11:02,000
이 정점에서 자기 자신으로 가는 간선을 추가하면 첫 번째 가정도 위반하게 됩니다.
 

521
00:11:02,000 --> 00:11:05,110
이 정점에서 자기 자신으로 가는 간선을 추가하면 첫 번째 가정도 위반하게 됩니다.
이는 단순하지

522
00:11:05,110 --> 00:11:05,120
이는 단순하지
 

523
00:11:05,120 --> 00:11:08,829
이는 단순하지
않은 그래프입니다.

524
00:11:08,829 --> 00:11:08,839

 

525
00:11:08,839 --> 00:11:10,629

단순 그래프... 사실 뭐라고 불러야 할지 모르겠네요.

526
00:11:10,629 --> 00:11:10,639
단순 그래프... 사실 뭐라고 불러야 할지 모르겠네요.
 

527
00:11:10,639 --> 00:11:12,990
단순 그래프... 사실 뭐라고 불러야 할지 모르겠네요.
일반 그래프?

528
00:11:12,990 --> 00:11:13,000
일반 그래프?
 

529
00:11:13,000 --> 00:11:14,910
일반 그래프?
복잡하다고 해야 할까요? 단순하지 않으니까요. 음... 잘

530
00:11:14,910 --> 00:11:14,920
복잡하다고 해야 할까요? 단순하지 않으니까요. 음... 잘
 

531
00:11:14,920 --> 00:11:19,310
복잡하다고 해야 할까요? 단순하지 않으니까요. 음... 잘
모르겠네요. 아, 멀티그래프? 뭐, 어쨌든 상관없지만요.

532
00:11:19,310 --> 00:11:20,389
모르겠네요. 아, 멀티그래프? 뭐, 어쨌든 상관없지만요.
 

533
00:11:20,389 --> 00:11:22,949

 

534
00:11:22,949 --> 00:11:22,959

 

535
00:11:22,959 --> 00:11:24,350

어쨌든 이 수업에서는

536
00:11:24,350 --> 00:11:24,360
어쨌든 이 수업에서는
 

537
00:11:24,360 --> 00:11:26,150
어쨌든 이 수업에서는
이 특정 상황에 대해서는 신경 쓰지 않을 겁니다.

538
00:11:26,150 --> 00:11:26,160
이 특정 상황에 대해서는 신경 쓰지 않을 겁니다.
 

539
00:11:26,160 --> 00:11:27,590
이 특정 상황에 대해서는 신경 쓰지 않을 겁니다.
물론

540
00:11:27,590 --> 00:11:27,600
물론
 

541
00:11:27,600 --> 00:11:28,949
물론
그래프 이론의 많은 응용 분야에서

542
00:11:28,949 --> 00:11:31,910
그래프 이론의 많은 응용 분야에서
 

543
00:11:31,910 --> 00:11:33,190

 

544
00:11:33,190 --> 00:11:33,200

 

545
00:11:33,200 --> 00:11:35,629

단순

546
00:11:35,629 --> 00:11:35,639

 

547
00:11:35,639 --> 00:11:38,389

그래프의 정의에 대해 질문하는 것은 완전히 합리적인 가정입니다. 자, 이제부터

548
00:11:38,389 --> 00:11:38,399
그래프의 정의에 대해 질문하는 것은 완전히 합리적인 가정입니다. 자, 이제부터
 

549
00:11:38,399 --> 00:11:39,910
그래프의 정의에 대해 질문하는 것은 완전히 합리적인 가정입니다. 자, 이제부터
그래프를 생각할 때

550
00:11:39,910 --> 00:11:39,920
그래프를 생각할 때
 

551
00:11:39,920 --> 00:11:41,150
그래프를 생각할 때
머릿속으로 그래프가

552
00:11:41,150 --> 00:11:41,160
머릿속으로 그래프가
 

553
00:11:41,160 --> 00:11:43,829
머릿속으로 그래프가
단순하다고 생각할 겁니다. 단순 그래프에는 좋은 속성이 하나 있는데,

554
00:11:43,829 --> 00:11:45,790
단순하다고 생각할 겁니다. 단순 그래프에는 좋은 속성이 하나 있는데,
 

555
00:11:45,790 --> 00:11:45,800

 

556
00:11:45,800 --> 00:11:48,350

화면에 크게 써 놓았듯이

557
00:11:48,350 --> 00:11:48,360
화면에 크게 써 놓았듯이
 

558
00:11:48,360 --> 00:11:52,269
화면에 크게 써 놓았듯이
간선의 개수는 빅 O 표기법으로 v²입니다.

559
00:11:52,269 --> 00:11:52,279
간선의 개수는 빅 O 표기법으로 v²입니다.
 

560
00:11:52,279 --> 00:11:54,110
간선의 개수는 빅 O 표기법으로 v²입니다.
이 공식을 조금 더 자세히 풀어보죠.

561
00:11:54,110 --> 00:11:56,190
이 공식을 조금 더 자세히 풀어보죠.
 

562
00:11:56,190 --> 00:11:56,200

 

563
00:11:56,200 --> 00:11:58,190

두 가지 경우가 있습니다. 하나는 그래프가

564
00:11:58,190 --> 00:11:58,200
두 가지 경우가 있습니다. 하나는 그래프가
 

565
00:11:58,200 --> 00:12:00,269
두 가지 경우가 있습니다. 하나는 그래프가
무방향 그래프일 때이고, 다른 하나는

566
00:12:00,269 --> 00:12:00,279
무방향 그래프일 때이고, 다른 하나는
 

567
00:12:00,279 --> 00:12:04,150
무방향 그래프일 때이고, 다른 하나는
방향 그래프일 때입니다. 네,

568
00:12:04,150 --> 00:12:04,160
방향 그래프일 때입니다. 네,
 

569
00:12:04,160 --> 00:12:11,150
방향 그래프일 때입니다. 네,
방향

570
00:12:11,150 --> 00:12:11,160

 

571
00:12:11,160 --> 00:12:13,230

그래프가 있다고 가정해 봅시다.

572
00:12:13,230 --> 00:12:15,949
그래프가 있다고 가정해 봅시다.
 

573
00:12:15,949 --> 00:12:15,959

 

574
00:12:15,959 --> 00:12:18,829

간선은 두 개의 선과 벡터로 이루어져 있습니다.  첫 번째 정점과

575
00:12:18,829 --> 00:12:18,839
간선은 두 개의 선과 벡터로 이루어져 있습니다.  첫 번째 정점과
 

576
00:12:18,839 --> 00:12:20,230
간선은 두 개의 선과 벡터로 이루어져 있습니다.  첫 번째 정점과
두 번째

577
00:12:20,230 --> 00:12:20,240
두 번째
 

578
00:12:20,240 --> 00:12:22,670
두 번째
정점으로 이루어진 간선이 있고, 두 번 반복될 수 없다는 것이 두

579
00:12:22,670 --> 00:12:24,150
정점으로 이루어진 간선이 있고, 두 번 반복될 수 없다는 것이 두
 

580
00:12:24,150 --> 00:12:24,160

 

581
00:12:24,160 --> 00:12:27,189

번째 가정과 같은 의미입니다.

582
00:12:27,189 --> 00:12:27,199
번째 가정과 같은 의미입니다.
 

583
00:12:27,199 --> 00:12:29,509
번째 가정과 같은 의미입니다.
특히, 우리는

584
00:12:29,509 --> 00:12:29,519
특히, 우리는
 

585
00:12:29,519 --> 00:12:31,750
특히, 우리는
mod e, 즉 그래프의 간선 개수가

586
00:12:31,750 --> 00:12:35,069
mod e, 즉 그래프의 간선 개수가
 

587
00:12:35,069 --> 00:12:35,079

 

588
00:12:35,079 --> 00:12:37,350

무엇으로 상한이 정해지는지 알고 있습니다.

589
00:12:37,350 --> 00:12:37,360
무엇으로 상한이 정해지는지 알고 있습니다.
 

590
00:12:37,360 --> 00:12:43,069
무엇으로 상한이 정해지는지 알고 있습니다.
어떤 정점 쌍이든 취할 수 있지만,

591
00:12:43,069 --> 00:12:45,030

 

592
00:12:45,030 --> 00:12:45,040

 

593
00:12:45,040 --> 00:12:47,030

그래프가

594
00:12:47,030 --> 00:12:47,040
그래프가
 

595
00:12:47,040 --> 00:12:50,069
그래프가
방향 그래프이기 때문에 출발점과 도착점이 중요합니다.

596
00:12:50,069 --> 00:12:50,079
방향 그래프이기 때문에 출발점과 도착점이 중요합니다.
 

597
00:12:50,079 --> 00:12:52,069
방향 그래프이기 때문에 출발점과 도착점이 중요합니다.
여기서 V choose to는 임의의

598
00:12:52,069 --> 00:12:52,079
여기서 V choose to는 임의의
 

599
00:12:52,079 --> 00:12:53,790
여기서 V choose to는 임의의
고유한 정점 쌍을 취할 수 있지만,

600
00:12:53,790 --> 00:12:53,800
고유한 정점 쌍을 취할 수 있지만,
 

601
00:12:53,800 --> 00:12:54,509
고유한 정점 쌍을 취할 수 있지만,

602
00:12:54,509 --> 00:12:56,470

 

603
00:12:56,470 --> 00:12:58,629

 

604
00:12:58,629 --> 00:12:58,639

 

605
00:12:58,639 --> 00:13:00,189

출발점과 도착점이 바뀔 수 있다는 점을 고려하여 앞에 2를 붙여야 한다는 것을 의미합니다.

606
00:13:00,189 --> 00:13:00,199
출발점과 도착점이 바뀔 수 있다는 점을 고려하여 앞에 2를 붙여야 한다는 것을 의미합니다.
 

607
00:13:00,199 --> 00:13:02,350
출발점과 도착점이 바뀔 수 있다는 점을 고려하여 앞에 2를 붙여야 한다는 것을 의미합니다.
물론 무방향 그래프의 경우에는

608
00:13:02,350 --> 00:13:04,230
물론 무방향 그래프의 경우에는
 

609
00:13:04,230 --> 00:13:09,189

 

610
00:13:09,189 --> 00:13:09,199

 

611
00:13:09,199 --> 00:13:12,470

이런 점을 고려할 필요가 없습니다. 여기서 e는

612
00:13:12,470 --> 00:13:12,480
이런 점을 고려할 필요가 없습니다. 여기서 e는
 

613
00:13:12,480 --> 00:13:16,470
이런 점을 고려할 필요가 없습니다. 여기서 e는
mod V choose to보다 작거나 같습니다. 즉,

614
00:13:16,470 --> 00:13:19,030
mod V choose to보다 작거나 같습니다. 즉,
 

615
00:13:19,030 --> 00:13:19,040

 

616
00:13:19,040 --> 00:13:21,269

모든 간선은 두 개의 정점으로 이루어져 있고,

617
00:13:21,269 --> 00:13:21,279
모든 간선은 두 개의 정점으로 이루어져 있고,
 

618
00:13:21,279 --> 00:13:23,470
모든 간선은 두 개의 정점으로 이루어져 있고,
간선은 고유하다는 것을 나타내는 방법입니다. 그리고

619
00:13:23,470 --> 00:13:25,310
간선은 고유하다는 것을 나타내는 방법입니다. 그리고
 

620
00:13:25,310 --> 00:13:25,320

 

621
00:13:25,320 --> 00:13:27,030

이항 계수 공식을 적어보면

622
00:13:27,030 --> 00:13:27,040
이항 계수 공식을 적어보면
 

623
00:13:27,040 --> 00:13:32,269
이항 계수 공식을 적어보면
두 가지 모두  이런 것들 중... 아,

624
00:13:32,269 --> 00:13:32,279

 

625
00:13:32,279 --> 00:13:36,550

맞다.

626
00:13:36,550 --> 00:13:36,560

 

627
00:13:36,560 --> 00:13:42,389

최악의 경우 mod V는 정사각형이고,

628
00:13:42,389 --> 00:13:42,399

 

629
00:13:42,399 --> 00:13:44,829

이는 완벽하게 이해가 됩니다.

630
00:13:44,829 --> 00:13:44,839
이는 완벽하게 이해가 됩니다.
 

631
00:13:44,839 --> 00:13:46,069
이는 완벽하게 이해가 됩니다.
왜냐하면 간선은 두 정점의 쌍이기 때문에 정사각형이 있을 거라고

632
00:13:46,069 --> 00:13:46,079
왜냐하면 간선은 두 정점의 쌍이기 때문에 정사각형이 있을 거라고
 

633
00:13:46,079 --> 00:13:47,750
왜냐하면 간선은 두 정점의 쌍이기 때문에 정사각형이 있을 거라고
예상하는 게 당연하죠. 네,

634
00:13:47,750 --> 00:13:53,590
예상하는 게 당연하죠. 네,
 

635
00:13:53,590 --> 00:13:53,600

 

636
00:13:53,600 --> 00:13:55,990

죄송합니다. 잘 안 들렸어요. 죄송합니다.

637
00:13:55,990 --> 00:13:56,000
죄송합니다. 잘 안 들렸어요. 죄송합니다.
 

638
00:13:56,000 --> 00:13:58,310
죄송합니다. 잘 안 들렸어요. 죄송합니다.
2는 뒤쪽, 즉 늪에서 온 겁니다. 네, 맞습니다. 방향 그래프의 경우

639
00:13:58,310 --> 00:13:59,550
2는 뒤쪽, 즉 늪에서 온 겁니다. 네, 맞습니다. 방향 그래프의 경우
 

640
00:13:59,550 --> 00:13:59,560

 

641
00:13:59,560 --> 00:14:01,550

2는

642
00:14:01,550 --> 00:14:03,430
2는
 

643
00:14:03,430 --> 00:14:03,440

 

644
00:14:03,440 --> 00:14:06,430

V에서 W로 가는 간선과 W에서

645
00:14:06,430 --> 00:14:06,440
V에서 W로 가는 간선과 W에서
 

646
00:14:06,440 --> 00:14:09,189
V에서 W로 가는 간선과 W에서
V로 가는 간선이 다르다는 사실에서 비롯됩니다.

647
00:14:09,189 --> 00:14:09,199
V로 가는 간선이 다르다는 사실에서 비롯됩니다.
 

648
00:14:09,199 --> 00:14:10,509
V로 가는 간선이 다르다는 사실에서 비롯됩니다.
이항

649
00:14:10,509 --> 00:14:10,519
이항
 

650
00:14:10,519 --> 00:14:12,030
이항
계수는 크기가 V인 집합에서

651
00:14:12,030 --> 00:14:12,040
계수는 크기가 V인 집합에서
 

652
00:14:12,040 --> 00:14:13,389
계수는 크기가 V인 집합에서
두 가지를 선택하는 방법의 수를 세는 것일 뿐

653
00:14:13,389 --> 00:14:15,470
두 가지를 선택하는 방법의 수를 세는 것일 뿐
 

654
00:14:15,470 --> 00:14:15,480

 

655
00:14:15,480 --> 00:14:18,389

순서는 고려하지 않습니다.

656
00:14:18,389 --> 00:14:18,399
순서는 고려하지 않습니다.
 

657
00:14:18,399 --> 00:14:19,829
순서는 고려하지 않습니다.
다른

658
00:14:19,829 --> 00:14:19,839
다른
 

659
00:14:19,839 --> 00:14:22,470
다른
질문 있으신가요? 좋습니다. 그럼 이것이 왜

660
00:14:22,470 --> 00:14:22,480
질문 있으신가요? 좋습니다. 그럼 이것이 왜
 

661
00:14:22,480 --> 00:14:24,389
질문 있으신가요? 좋습니다. 그럼 이것이 왜
중요할까요? 이러한 경계는

662
00:14:24,389 --> 00:14:25,470
중요할까요? 이러한 경계는
 

663
00:14:25,470 --> 00:14:25,480

 

664
00:14:25,480 --> 00:14:26,990

여러분에게는 다소 당연해 보일 수 있지만, 우리는

665
00:14:26,990 --> 00:14:27,000
여러분에게는 다소 당연해 보일 수 있지만, 우리는
 

666
00:14:27,000 --> 00:14:28,670
여러분에게는 다소 당연해 보일 수 있지만, 우리는
그래프 알고리즘을 작성할 것입니다. 이제

667
00:14:28,670 --> 00:14:28,680
그래프 알고리즘을 작성할 것입니다. 이제
 

668
00:14:28,680 --> 00:14:30,590
그래프 알고리즘을 작성할 것입니다. 이제
실행 시간과

669
00:14:30,590 --> 00:14:30,600
실행 시간과
 

670
00:14:30,600 --> 00:14:32,590
실행 시간과
차지하는 공간을 분석할 때, 정점의 수와 간선의 수라는 두 가지

671
00:14:32,590 --> 00:14:32,600
차지하는 공간을 분석할 때, 정점의 수와 간선의 수라는 두 가지
 

672
00:14:32,600 --> 00:14:33,949
차지하는 공간을 분석할 때, 정점의 수와 간선의 수라는 두 가지
다른 숫자를 고려할 수 있습니다. 예를 들어

673
00:14:33,949 --> 00:14:35,629
다른 숫자를 고려할 수 있습니다. 예를 들어
 

674
00:14:35,629 --> 00:14:36,590

 

675
00:14:36,590 --> 00:14:38,790

 

676
00:14:38,790 --> 00:14:38,800

 

677
00:14:38,800 --> 00:14:41,350

실행 시간이 다음과 같은 알고리즘을 작성한다고 가정해 보겠습니다.

678
00:14:41,350 --> 00:14:41,360
실행 시간이 다음과 같은 알고리즘을 작성한다고 가정해 보겠습니다.
 

679
00:14:41,360 --> 00:14:43,710
실행 시간이 다음과 같은 알고리즘을 작성한다고 가정해 보겠습니다.
간선 수에 비례한다고 생각할 수도 있고,

680
00:14:43,710 --> 00:14:43,720
간선 수에 비례한다고 생각할 수도 있고,
 

681
00:14:43,720 --> 00:14:45,310
간선 수에 비례한다고 생각할 수도 있고,
일반적으로

682
00:14:45,310 --> 00:14:45,320
일반적으로
 

683
00:14:45,320 --> 00:14:47,150
일반적으로
알고리즘의

684
00:14:47,150 --> 00:14:47,160
알고리즘의
 

685
00:14:47,160 --> 00:14:48,470
알고리즘의
실행 시간은 정점 수의 제곱에 비례한다고 생각할 수도 있습니다. 물론

686
00:14:48,470 --> 00:14:50,230
실행 시간은 정점 수의 제곱에 비례한다고 생각할 수도 있습니다. 물론
 

687
00:14:50,230 --> 00:14:50,240

 

688
00:14:50,240 --> 00:14:52,269

그래프에 추가적인 가정을 하지 않는 한 말이죠.

689
00:14:52,269 --> 00:14:53,389
그래프에 추가적인 가정을 하지 않는 한 말이죠.
 

690
00:14:53,389 --> 00:14:53,399

 

691
00:14:53,399 --> 00:14:55,069

이처럼 다양한 상수들 사이에는 어떤 연관성이 있으며, 이를 염두에 두는 것이

692
00:14:55,069 --> 00:14:55,079
이처럼 다양한 상수들 사이에는 어떤 연관성이 있으며, 이를 염두에 두는 것이
 

693
00:14:55,079 --> 00:14:56,269
이처럼 다양한 상수들 사이에는 어떤 연관성이 있으며, 이를 염두에 두는 것이
유용합니다.

694
00:14:56,269 --> 00:14:56,279
유용합니다.
 

695
00:14:56,279 --> 00:14:57,430
유용합니다.
때로는

696
00:14:57,430 --> 00:14:58,590
때로는
 

697
00:14:58,590 --> 00:15:00,509

 

698
00:15:00,509 --> 00:15:00,519

 

699
00:15:00,519 --> 00:15:02,269

대략 같은 관계를

700
00:15:02,269 --> 00:15:02,279
대략 같은 관계를
 

701
00:15:02,279 --> 00:15:03,269
대략 같은 관계를
다른

702
00:15:03,269 --> 00:15:03,279
다른
 

703
00:15:03,279 --> 00:15:05,310
다른
언어로 표현하는 여러 가지 표현식을 볼 수 있는데, 이는

704
00:15:05,310 --> 00:15:05,320
언어로 표현하는 여러 가지 표현식을 볼 수 있는데, 이는
 

705
00:15:05,320 --> 00:15:07,509
언어로 표현하는 여러 가지 표현식을 볼 수 있는데, 이는
더 정확하게 표현할 수 있다는 것을 의미하기도 합니다.

706
00:15:07,509 --> 00:15:07,519
더 정확하게 표현할 수 있다는 것을 의미하기도 합니다.
 

707
00:15:07,519 --> 00:15:09,269
더 정확하게 표현할 수 있다는 것을 의미하기도 합니다.
때때로 그래프는 희소 그래프라고

708
00:15:09,269 --> 00:15:09,279
때때로 그래프는 희소 그래프라고
 

709
00:15:09,279 --> 00:15:11,949
때때로 그래프는 희소 그래프라고
불립니다.

710
00:15:11,949 --> 00:15:11,959
불립니다.
 

711
00:15:11,959 --> 00:15:13,629
불립니다.
제가 일상적으로 다루는 거의 모든 그래프는

712
00:15:13,629 --> 00:15:13,639
제가 일상적으로 다루는 거의 모든 그래프는
 

713
00:15:13,639 --> 00:15:16,470
제가 일상적으로 다루는 거의 모든 그래프는
매우 희소합니다. 이는 위상 구조

714
00:15:16,470 --> 00:15:16,480
매우 희소합니다. 이는 위상 구조
 

715
00:15:16,480 --> 00:15:18,990
매우 희소합니다. 이는 위상 구조
의 결과입니다. 따라서

716
00:15:18,990 --> 00:15:21,310
의 결과입니다. 따라서
 

717
00:15:21,310 --> 00:15:21,320

 

718
00:15:21,320 --> 00:15:23,189

간선 수에 비례하는 알고리즘이 정점 수의 제곱에 비례하는

719
00:15:23,189 --> 00:15:23,199
간선 수에 비례하는 알고리즘이 정점 수의 제곱에 비례하는
 

720
00:15:23,199 --> 00:15:25,509
간선 수에 비례하는 알고리즘이 정점 수의 제곱에 비례하는
알고리즘보다 훨씬 더 바람직할 수 있습니다. 실제로는

721
00:15:25,509 --> 00:15:26,870
알고리즘보다 훨씬 더 바람직할 수 있습니다. 실제로는
 

722
00:15:26,870 --> 00:15:29,030

 

723
00:15:29,030 --> 00:15:29,040

 

724
00:15:29,040 --> 00:15:30,790

모든 가능한 쌍의 수보다 간선 수가 적은 경우가 많기 때문입니다. 이러한

725
00:15:30,790 --> 00:15:33,389
모든 가능한 쌍의 수보다 간선 수가 적은 경우가 많기 때문입니다. 이러한
 

726
00:15:33,389 --> 00:15:33,399

 

727
00:15:33,399 --> 00:15:35,069

이유로

728
00:15:35,069 --> 00:15:35,079
이유로
 

729
00:15:35,079 --> 00:15:36,350
이유로
이러한

730
00:15:36,350 --> 00:15:36,360
이러한
 

731
00:15:36,360 --> 00:15:38,509
이러한
수치들을 생각해 볼 가치가 있습니다. 자, 그럼 계속해서

732
00:15:38,509 --> 00:15:38,519
수치들을 생각해 볼 가치가 있습니다. 자, 그럼 계속해서
 

733
00:15:38,519 --> 00:15:41,069
수치들을 생각해 볼 가치가 있습니다. 자, 그럼 계속해서
지루한 정의들을 만들어 봅시다.  그래서

734
00:15:41,069 --> 00:15:41,079
지루한 정의들을 만들어 봅시다.  그래서
 

735
00:15:41,079 --> 00:15:42,629
지루한 정의들을 만들어 봅시다.  그래서
우리가 생각해 봐야 할 다른 것들은

736
00:15:42,629 --> 00:15:44,509
우리가 생각해 봐야 할 다른 것들은
 

737
00:15:44,509 --> 00:15:44,519

 

738
00:15:44,519 --> 00:15:46,590

그래프의 위상이나 연결성,

739
00:15:46,590 --> 00:15:46,600
그래프의 위상이나 연결성,
 

740
00:15:46,600 --> 00:15:48,030
그래프의 위상이나 연결성,
특히

741
00:15:48,030 --> 00:15:48,040
특히
 

742
00:15:48,040 --> 00:15:50,269
특히
이웃에 관한 것입니다. 일반적으로 우리는 정점

743
00:15:50,269 --> 00:15:50,279
이웃에 관한 것입니다. 일반적으로 우리는 정점
 

744
00:15:50,279 --> 00:15:52,430
이웃에 관한 것입니다. 일반적으로 우리는 정점
쌍을

745
00:15:52,430 --> 00:15:52,440
쌍을
 

746
00:15:52,440 --> 00:15:54,110
쌍을
서로 이웃으로 생각합니다. 두 정점 사이에 간선이 있으면 이웃이라고 생각하죠. 하지만

747
00:15:54,110 --> 00:15:56,150
서로 이웃으로 생각합니다. 두 정점 사이에 간선이 있으면 이웃이라고 생각하죠. 하지만
 

748
00:15:56,150 --> 00:15:58,150

 

749
00:15:58,150 --> 00:15:58,160

 

750
00:15:58,160 --> 00:16:00,350

방향 간선이 있는 경우,

751
00:16:00,350 --> 00:16:02,389
방향 간선이 있는 경우,
 

752
00:16:02,389 --> 00:16:04,030

 

753
00:16:04,030 --> 00:16:04,040

 

754
00:16:04,040 --> 00:16:06,230

이웃 관계에서 누가 간선을 주고받는지 주의해야 합니다. 자, 아주

755
00:16:06,230 --> 00:16:06,240
이웃 관계에서 누가 간선을 주고받는지 주의해야 합니다. 자, 아주
 

756
00:16:06,240 --> 00:16:08,749
이웃 관계에서 누가 간선을 주고받는지 주의해야 합니다. 자, 아주
간단한 그래프를 그려 보겠습니다.

757
00:16:08,749 --> 00:16:08,759
간단한 그래프를 그려 보겠습니다.
 

758
00:16:08,759 --> 00:16:11,389
간단한 그래프를 그려 보겠습니다.
여기 정점 0, 정점 1,

759
00:16:11,389 --> 00:16:11,399
여기 정점 0, 정점 1,
 

760
00:16:11,399 --> 00:16:14,110
여기 정점 0, 정점 1,
정점 2가 있고, 위로 가는 간선,

761
00:16:14,110 --> 00:16:14,120
정점 2가 있고, 위로 가는 간선,
 

762
00:16:14,120 --> 00:16:19,150
정점 2가 있고, 위로 가는 간선,
아래로 가는 간선, 그리고

763
00:16:19,150 --> 00:16:19,160
아래로 가는 간선, 그리고
 

764
00:16:19,160 --> 00:16:20,670
아래로 가는 간선, 그리고
사이클이 있을 수 있습니다.

765
00:16:20,670 --> 00:16:24,230
사이클이 있을 수 있습니다.
 

766
00:16:24,230 --> 00:16:24,240

 

767
00:16:24,240 --> 00:16:26,030

이웃에는 여러 가지 개념이 있습니다. 예를 들어 나가는

768
00:16:26,030 --> 00:16:26,040
이웃에는 여러 가지 개념이 있습니다. 예를 들어 나가는
 

769
00:16:26,040 --> 00:16:27,870
이웃에는 여러 가지 개념이 있습니다. 예를 들어 나가는
이웃 집합, 들어오는

770
00:16:27,870 --> 00:16:27,880
이웃 집합, 들어오는
 

771
00:16:27,880 --> 00:16:30,269
이웃 집합, 들어오는
이웃 집합 등이 있죠. 여기서 기본적인 아이디어는

772
00:16:30,269 --> 00:16:31,990
이웃 집합 등이 있죠. 여기서 기본적인 아이디어는
 

773
00:16:31,990 --> 00:16:32,000

 

774
00:16:32,000 --> 00:16:33,949

정점에서 나가는 간선과 들어오는 간선을 추적하는 것입니다.

775
00:16:33,949 --> 00:16:33,959
정점에서 나가는 간선과 들어오는 간선을 추적하는 것입니다.
 

776
00:16:33,959 --> 00:16:36,949
정점에서 나가는 간선과 들어오는 간선을 추적하는 것입니다.
예를 들어

777
00:16:36,949 --> 00:16:36,959
예를 들어
 

778
00:16:36,959 --> 00:16:38,309
예를 들어
나가는 이웃 집합은

779
00:16:38,309 --> 00:16:38,319
나가는 이웃 집합은
 

780
00:16:38,319 --> 00:16:43,949
나가는 이웃 집합은
adj+로 표기합니다.

781
00:16:43,949 --> 00:16:43,959
adj+로 표기합니다.
 

782
00:16:43,959 --> 00:16:46,749
adj+로 표기합니다.
여기서 나가는 이웃은 무엇일까요?

783
00:16:46,749 --> 00:16:46,759
여기서 나가는 이웃은 무엇일까요?
 

784
00:16:46,759 --> 00:16:49,870
여기서 나가는 이웃은 무엇일까요?
노드 0의 이웃 집합을

785
00:16:49,870 --> 00:16:49,880
노드 0의 이웃 집합을
 

786
00:16:49,880 --> 00:16:51,509
노드 0의 이웃 집합을
살펴보면,

787
00:16:51,509 --> 00:16:51,519
살펴보면,
 

788
00:16:51,519 --> 00:16:53,069
살펴보면,
노드 0에서 나가는 간선이 하나 있고, 그 간선이

789
00:16:53,069 --> 00:16:53,079
노드 0에서 나가는 간선이 하나 있고, 그 간선이
 

790
00:16:53,079 --> 00:16:57,189
노드 0에서 나가는 간선이 하나 있고, 그 간선이
노드 2를 가리키고 있습니다. 따라서 이 집합은

791
00:16:57,189 --> 00:16:57,199
노드 2를 가리키고 있습니다. 따라서 이 집합은
 

792
00:16:57,199 --> 00:16:59,430
노드 2를 가리키고 있습니다. 따라서 이 집합은
다른 노드 하나만을 포함합니다.

793
00:16:59,430 --> 00:16:59,440
다른 노드 하나만을 포함합니다.
 

794
00:16:59,440 --> 00:17:01,430
다른 노드 하나만을 포함합니다.

795
00:17:01,430 --> 00:17:01,440

 

796
00:17:01,440 --> 00:17:04,750

마찬가지로 노드 0의 들어오는 이웃 집합도 있습니다. 노드

797
00:17:04,750 --> 00:17:07,150
마찬가지로 노드 0의 들어오는 이웃 집합도 있습니다. 노드
 

798
00:17:07,150 --> 00:17:07,160

 

799
00:17:07,160 --> 00:17:10,909

1에서 들어오는 이웃이 하나 있으므로, 이

800
00:17:10,909 --> 00:17:10,919
1에서 들어오는 이웃이 하나 있으므로, 이
 

801
00:17:10,919 --> 00:17:13,230
1에서 들어오는 이웃이 하나 있으므로, 이
집합도

802
00:17:13,230 --> 00:17:13,240
집합도
 

803
00:17:13,240 --> 00:17:15,789
집합도
이와 같습니다. 물론 무방향 그래프에서는

804
00:17:15,789 --> 00:17:17,669
이와 같습니다. 물론 무방향 그래프에서는
 

805
00:17:17,669 --> 00:17:17,679

 

806
00:17:17,679 --> 00:17:19,470

이 두 가지를 구분하는 것이 중요하지 않습니다.

807
00:17:19,470 --> 00:17:19,480
이 두 가지를 구분하는 것이 중요하지 않습니다.
 

808
00:17:19,480 --> 00:17:20,990
이 두 가지를 구분하는 것이 중요하지 않습니다.
마지막 항목을 보면, 무

809
00:17:20,990 --> 00:17:21,000
마지막 항목을 보면, 무
 

810
00:17:21,000 --> 00:17:22,990
마지막 항목을 보면, 무
방향 그래프에서는

811
00:17:22,990 --> 00:17:23,000
방향 그래프에서는
 

812
00:17:23,000 --> 00:17:25,029
방향 그래프에서는
플러스 또는 마이너스 부호를 생략하는 경우가 많습니다. 왜냐하면

813
00:17:25,029 --> 00:17:25,039
플러스 또는 마이너스 부호를 생략하는 경우가 많습니다. 왜냐하면
 

814
00:17:25,039 --> 00:17:27,829
플러스 또는 마이너스 부호를 생략하는 경우가 많습니다. 왜냐하면
중요하지 않기 때문입니다.

815
00:17:27,829 --> 00:17:27,839
중요하지 않기 때문입니다.
 

816
00:17:27,839 --> 00:17:30,270
중요하지 않기 때문입니다.
어쨌든 중요한 용어가 하나 더 있는데, 바로 차수입니다.

817
00:17:30,270 --> 00:17:31,750
어쨌든 중요한 용어가 하나 더 있는데, 바로 차수입니다.
 

818
00:17:31,750 --> 00:17:34,230

 

819
00:17:34,230 --> 00:17:36,150

 

820
00:17:36,150 --> 00:17:36,160

 

821
00:17:36,160 --> 00:17:38,029

차수는 이 집합의 크기를 세는 것입니다. 즉, 나가는

822
00:17:38,029 --> 00:17:39,789
차수는 이 집합의 크기를 세는 것입니다. 즉, 나가는
 

823
00:17:39,789 --> 00:17:39,799

 

824
00:17:39,799 --> 00:17:41,950

간선의 수와 들어오는 간선의 수를 나타냅니다.

825
00:17:41,950 --> 00:17:44,870
간선의 수와 들어오는 간선의 수를 나타냅니다.
 

826
00:17:44,870 --> 00:17:44,880

 

827
00:17:44,880 --> 00:17:46,590

이 경우 두 숫자 모두

828
00:17:46,590 --> 00:17:46,600
이 경우 두 숫자 모두
 

829
00:17:46,600 --> 00:17:48,630
이 경우 두 숫자 모두
1입니다. 그렇지 않은 예를 살펴보겠습니다.

830
00:17:48,630 --> 00:17:48,640
1입니다. 그렇지 않은 예를 살펴보겠습니다.
 

831
00:17:48,640 --> 00:17:51,070
1입니다. 그렇지 않은 예를 살펴보겠습니다.
노드 1에는

832
00:17:51,070 --> 00:17:51,080
노드 1에는
 

833
00:17:51,080 --> 00:17:53,310
노드 1에는
두 개의 간선이 있습니다.

834
00:17:53,310 --> 00:17:53,320
두 개의 간선이 있습니다.
 

835
00:17:53,320 --> 00:17:56,390
두 개의 간선이 있습니다.
노드 1의 차수는 2이고, 노드 1로 향하는

836
00:17:56,390 --> 00:17:56,400
노드 1의 차수는 2이고, 노드 1로 향하는
 

837
00:17:56,400 --> 00:17:58,950
노드 1의 차수는 2이고, 노드 1로 향하는
간선이 하나 있으므로 노드 1의 차수는

838
00:17:58,950 --> 00:17:58,960
간선이 하나 있으므로 노드 1의 차수는
 

839
00:17:58,960 --> 00:18:00,630
간선이 하나 있으므로 노드 1의 차수는

840
00:18:00,630 --> 00:18:00,640

 

841
00:18:00,640 --> 00:18:03,310

1

842
00:18:03,310 --> 00:18:04,270
1
 

843
00:18:04,270 --> 00:18:05,990

 

844
00:18:05,990 --> 00:18:07,630

 

845
00:18:07,630 --> 00:18:09,950

 

846
00:18:09,950 --> 00:18:09,960

 

847
00:18:09,960 --> 00:18:12,789

입니다. 자, 왜 이렇게 할까요? 우리는 주어진 정점의 이웃 노드들을 순회하는 for 루프를 사용하는 그래프 알고리즘을 많이 작성할 것입니다. 이때 차수가 중요한 역할을 하므로,

848
00:18:12,789 --> 00:18:12,799
입니다. 자, 왜 이렇게 할까요? 우리는 주어진 정점의 이웃 노드들을 순회하는 for 루프를 사용하는 그래프 알고리즘을 많이 작성할 것입니다. 이때 차수가 중요한 역할을 하므로,
 

849
00:18:12,799 --> 00:18:15,310
입니다. 자, 왜 이렇게 할까요? 우리는 주어진 정점의 이웃 노드들을 순회하는 for 루프를 사용하는 그래프 알고리즘을 많이 작성할 것입니다. 이때 차수가 중요한 역할을 하므로,
이러한 값들을 약간 제한하는 것이 좋습니다.

850
00:18:15,310 --> 00:18:15,320
이러한 값들을 약간 제한하는 것이 좋습니다.
 

851
00:18:15,320 --> 00:18:17,830
이러한 값들을 약간 제한하는 것이 좋습니다.
특히, 너무 길게

852
00:18:17,830 --> 00:18:22,990
특히, 너무 길게
 

853
00:18:22,990 --> 00:18:23,000

 

854
00:18:23,000 --> 00:18:25,070

쓰면 공간이 부족해질 수 있으니, 다음과 같은 방법을 고려해 볼 수 있습니다.

855
00:18:25,070 --> 00:18:28,149
쓰면 공간이 부족해질 수 있으니, 다음과 같은 방법을 고려해 볼 수 있습니다.
 

856
00:18:28,149 --> 00:18:30,590

 

857
00:18:30,590 --> 00:18:33,669

 

858
00:18:33,669 --> 00:18:33,679

 

859
00:18:33,679 --> 00:18:36,190

그래프 내의 모든 노드를 살펴보고 각 노드의 차수를 모두 더해 보겠습니다.

860
00:18:36,190 --> 00:18:36,200
그래프 내의 모든 노드를 살펴보고 각 노드의 차수를 모두 더해 보겠습니다.
 

861
00:18:36,200 --> 00:18:41,110
그래프 내의 모든 노드를 살펴보고 각 노드의 차수를 모두 더해 보겠습니다.

862
00:18:41,110 --> 00:18:43,789

 

863
00:18:43,789 --> 00:18:43,799

 

864
00:18:43,799 --> 00:18:45,510

이 그래프를 보면, 이 정점에 인접한 간선이

865
00:18:45,510 --> 00:18:45,520
이 그래프를 보면, 이 정점에 인접한 간선이
 

866
00:18:45,520 --> 00:18:47,549
이 그래프를 보면, 이 정점에 인접한 간선이
세 개, 저 정점에 인접한 간선이 세 개, 그리고

867
00:18:47,549 --> 00:18:47,559
세 개, 저 정점에 인접한 간선이 세 개, 그리고
 

868
00:18:47,559 --> 00:18:49,470
세 개, 저 정점에 인접한 간선이 세 개, 그리고
이 정점에 인접한 간선이

869
00:18:49,470 --> 00:18:49,480
이 정점에 인접한 간선이
 

870
00:18:49,480 --> 00:18:51,630
이 정점에 인접한 간선이
두 개 있습니다. 이 모든 간선을 더하면 차수가 1이 됩니다. 이렇게 차수를 더하는 것이

871
00:18:51,630 --> 00:18:53,470
두 개 있습니다. 이 모든 간선을 더하면 차수가 1이 됩니다. 이렇게 차수를 더하는 것이
 

872
00:18:53,470 --> 00:18:53,480

 

873
00:18:53,480 --> 00:18:55,870

편리한 제한이 될 수 있습니다. 왜냐하면 모든 정점과 모든

874
00:18:55,870 --> 00:18:57,870
편리한 제한이 될 수 있습니다. 왜냐하면 모든 정점과 모든
 

875
00:18:57,870 --> 00:18:58,870

 

876
00:18:58,870 --> 00:19:00,870

 

877
00:19:00,870 --> 00:19:00,880

 

878
00:19:00,880 --> 00:19:02,669

이웃 노드에 대해 for 루프를 사용하는 알고리즘이 많이 사용될 것이기 때문입니다.  뭔가를 해야 하니까

879
00:19:02,669 --> 00:19:02,679
이웃 노드에 대해 for 루프를 사용하는 알고리즘이 많이 사용될 것이기 때문입니다.  뭔가를 해야 하니까
 

880
00:19:02,679 --> 00:19:04,630
이웃 노드에 대해 for 루프를 사용하는 알고리즘이 많이 사용될 것이기 때문입니다.  뭔가를 해야 하니까
대략 얼마나 걸릴지 알아두는 게 좋겠지.

881
00:19:04,630 --> 00:19:04,640
대략 얼마나 걸릴지 알아두는 게 좋겠지.
 

882
00:19:04,640 --> 00:19:07,270
대략 얼마나 걸릴지 알아두는 게 좋겠지.
음, 한번 생각해 보자. 무

883
00:19:07,270 --> 00:19:10,909
음, 한번 생각해 보자. 무
 

884
00:19:10,909 --> 00:19:10,919

 

885
00:19:10,919 --> 00:19:14,549

방향 그래프에서는 모든 간선이

886
00:19:14,549 --> 00:19:14,559
방향 그래프에서는 모든 간선이
 

887
00:19:14,559 --> 00:19:16,149
방향 그래프에서는 모든 간선이
두 개의

888
00:19:16,149 --> 00:19:16,159
두 개의
 

889
00:19:16,159 --> 00:19:19,870
두 개의
정점에 인접해 있다는 것을 알고 있지? 차수를 어떻게 계산하는지 생각해 보면, 간선은 서로

890
00:19:19,870 --> 00:19:21,750
정점에 인접해 있다는 것을 알고 있지? 차수를 어떻게 계산하는지 생각해 보면, 간선은 서로
 

891
00:19:21,750 --> 00:19:24,190

 

892
00:19:24,190 --> 00:19:25,830

 

893
00:19:25,830 --> 00:19:25,840

 

894
00:19:25,840 --> 00:19:27,510

다른 두 정점의 차수에 영향을 미친다는 것을 알 수 있지. 자, 잘

895
00:19:27,510 --> 00:19:32,549
다른 두 정점의 차수에 영향을 미친다는 것을 알 수 있지. 자, 잘
 

896
00:19:32,549 --> 00:19:32,559

 

897
00:19:32,559 --> 00:19:35,029

생각해 보면,

898
00:19:35,029 --> 00:19:37,029
생각해 보면,
 

899
00:19:37,029 --> 00:19:37,039

 

900
00:19:37,039 --> 00:19:42,070

그래프가

901
00:19:42,070 --> 00:19:42,080

 

902
00:19:42,080 --> 00:19:46,190

무방향일 경우... 아,

903
00:19:46,190 --> 00:19:46,200
무방향일 경우... 아,
 

904
00:19:46,200 --> 00:19:48,510
무방향일 경우... 아,
죄송합니다. 제가 또 헷갈렸네요.

905
00:19:48,510 --> 00:19:48,520
죄송합니다. 제가 또 헷갈렸네요.
 

906
00:19:48,520 --> 00:19:51,549
죄송합니다. 제가 또 헷갈렸네요.
두

907
00:19:51,549 --> 00:19:51,559
두
 

908
00:19:51,559 --> 00:19:53,350
두
정점과 하나의 간선을 가진 무방향 그래프가 있다고 가정해 봅시다.

909
00:19:53,350 --> 00:19:56,669
정점과 하나의 간선을 가진 무방향 그래프가 있다고 가정해 봅시다.
 

910
00:19:56,669 --> 00:19:56,679

 

911
00:19:56,679 --> 00:19:59,669

여기서 간선의 개수는 하나죠. 그렇다면

912
00:19:59,669 --> 00:19:59,679
여기서 간선의 개수는 하나죠. 그렇다면
 

913
00:19:59,679 --> 00:20:01,669
여기서 간선의 개수는 하나죠. 그렇다면
차수의 합은 얼마일까요?

914
00:20:01,669 --> 00:20:01,679
차수의 합은 얼마일까요?
 

915
00:20:01,679 --> 00:20:05,789
차수의 합은 얼마일까요?
1 + 1 = 2입니다. 네,

916
00:20:05,789 --> 00:20:05,799
1 + 1 = 2입니다. 네,
 

917
00:20:05,799 --> 00:20:10,710
1 + 1 = 2입니다. 네,
그래서 차수는 2입니다. 제

918
00:20:10,710 --> 00:20:10,720
그래서 차수는 2입니다. 제
 

919
00:20:10,720 --> 00:20:14,029
그래서 차수는 2입니다. 제
그래프가 무

920
00:20:14,029 --> 00:20:14,039

 

921
00:20:14,039 --> 00:20:18,270

방향이라면...  만약 내 그래프가

922
00:20:18,270 --> 00:20:18,280
방향이라면...  만약 내 그래프가
 

923
00:20:18,280 --> 00:20:21,549
방향이라면...  만약 내 그래프가
방향 그래프이고 내가 세는 것이 단순히

924
00:20:21,549 --> 00:20:21,559
방향 그래프이고 내가 세는 것이 단순히
 

925
00:20:21,559 --> 00:20:24,230
방향 그래프이고 내가 세는 것이 단순히
나가는 간선의 차수라면, 이해가 되시나요? 제가

926
00:20:24,230 --> 00:20:26,350
나가는 간선의 차수라면, 이해가 되시나요? 제가
 

927
00:20:26,350 --> 00:20:26,360

 

928
00:20:26,360 --> 00:20:27,990

방금 문장을 완전히 잘못 이해한 것 같으니

929
00:20:27,990 --> 00:20:28,000
방금 문장을 완전히 잘못 이해한 것 같으니
 

930
00:20:28,000 --> 00:20:29,549
방금 문장을 완전히 잘못 이해한 것 같으니
다시 시도해 보겠습니다.

931
00:20:29,549 --> 00:20:31,430
다시 시도해 보겠습니다.
 

932
00:20:31,430 --> 00:20:31,440

 

933
00:20:31,440 --> 00:20:34,029

모든 정점에서 나가는 간선의 수를 세는 경우를 모두 고려하면

934
00:20:34,029 --> 00:20:36,510
모든 정점에서 나가는 간선의 수를 세는 경우를 모두 고려하면
 

935
00:20:36,510 --> 00:20:36,520

 

936
00:20:36,520 --> 00:20:38,110

두 가지 경우가 있습니다. 하나는

937
00:20:38,110 --> 00:20:38,120
두 가지 경우가 있습니다. 하나는
 

938
00:20:38,120 --> 00:20:40,230
두 가지 경우가 있습니다. 하나는
방향 그래프이고 다른 하나는 무방향 그래프입니다.

939
00:20:40,230 --> 00:20:40,240
방향 그래프이고 다른 하나는 무방향 그래프입니다.
 

940
00:20:40,240 --> 00:20:42,070
방향 그래프이고 다른 하나는 무방향 그래프입니다.
무방향 그래프의 경우,

941
00:20:42,070 --> 00:20:42,080
무방향 그래프의 경우,
 

942
00:20:42,080 --> 00:20:43,950
무방향 그래프의 경우,
모든 간선이 동시에 들어오는 동시에 나가는 간선이기 때문에 계수는 2가 됩니다. 반면

943
00:20:43,950 --> 00:20:46,310
모든 간선이 동시에 들어오는 동시에 나가는 간선이기 때문에 계수는 2가 됩니다. 반면
 

944
00:20:46,310 --> 00:20:48,029

 

945
00:20:48,029 --> 00:20:48,039

 

946
00:20:48,039 --> 00:20:50,230

방향 그래프의 경우 계수는 1이 됩니다. 이해가 되시나요?

947
00:20:50,230 --> 00:20:50,240
방향 그래프의 경우 계수는 1이 됩니다. 이해가 되시나요?
 

948
00:20:50,240 --> 00:20:52,230
방향 그래프의 경우 계수는 1이 됩니다. 이해가 되시나요?
죄송합니다, 제가

949
00:20:52,230 --> 00:20:52,240
죄송합니다, 제가
 

950
00:20:52,240 --> 00:20:55,350
죄송합니다, 제가
잠깐 말을 잘못했네요. 좋습니다. 이 상한은 나중에

951
00:20:55,350 --> 00:20:55,360
잠깐 말을 잘못했네요. 좋습니다. 이 상한은 나중에
 

952
00:20:55,360 --> 00:20:56,750
잠깐 말을 잘못했네요. 좋습니다. 이 상한은 나중에
유용하게 쓰일 것입니다.

953
00:20:56,750 --> 00:20:56,760
유용하게 쓰일 것입니다.
 

954
00:20:56,760 --> 00:20:59,549
유용하게 쓰일 것입니다.
이제 그래프에 대해 생각해 보겠습니다.

955
00:20:59,549 --> 00:20:59,559
이제 그래프에 대해 생각해 보겠습니다.
 

956
00:20:59,559 --> 00:21:00,710
이제 그래프에 대해 생각해 보겠습니다.
지난 몇

957
00:21:00,710 --> 00:21:00,720
지난 몇
 

958
00:21:00,720 --> 00:21:02,549
지난 몇
주 동안 자료 구조에 대해 생각해 보았으니, 이제

959
00:21:02,549 --> 00:21:03,909
주 동안 자료 구조에 대해 생각해 보았으니, 이제
 

960
00:21:03,909 --> 00:21:03,919

 

961
00:21:03,919 --> 00:21:05,549

컴퓨터에 그래프를 저장하는 방법에 대해 생각해 봐야 합니다. 여러 가지

962
00:21:05,549 --> 00:21:05,559
컴퓨터에 그래프를 저장하는 방법에 대해 생각해 봐야 합니다. 여러 가지
 

963
00:21:05,559 --> 00:21:08,230
컴퓨터에 그래프를 저장하는 방법에 대해 생각해 봐야 합니다. 여러 가지
방법이 있는데, 그중 하나는

964
00:21:08,230 --> 00:21:10,230
방법이 있는데, 그중 하나는
 

965
00:21:10,230 --> 00:21:10,240

 

966
00:21:10,240 --> 00:21:12,310

집합에 대해 이야기했을 때처럼 쌍으로 저장하는 것입니다.

967
00:21:12,310 --> 00:21:13,630
집합에 대해 이야기했을 때처럼 쌍으로 저장하는 것입니다.
 

968
00:21:13,630 --> 00:21:13,640

 

969
00:21:13,640 --> 00:21:15,230

집합을 저장하는 방법은 여러 가지가 있는데, 그중 하나는...  생각해 보세요.

970
00:21:15,230 --> 00:21:15,240
집합을 저장하는 방법은 여러 가지가 있는데, 그중 하나는...  생각해 보세요.
 

971
00:21:15,240 --> 00:21:16,870
집합을 저장하는 방법은 여러 가지가 있는데, 그중 하나는...  생각해 보세요.
우리가

972
00:21:16,870 --> 00:21:16,880
우리가
 

973
00:21:16,880 --> 00:21:18,750
우리가
그 집합과 어떻게 상호작용할지에 따라, 그 집합과의 상호작용 유형을 최적화하고 최대한 빠르게 처리하기 위해

974
00:21:18,750 --> 00:21:18,760
그 집합과 어떻게 상호작용할지에 따라, 그 집합과의 상호작용 유형을 최적화하고 최대한 빠르게 처리하기 위해
 

975
00:21:18,760 --> 00:21:20,830
그 집합과 어떻게 상호작용할지에 따라, 그 집합과의 상호작용 유형을 최적화하고 최대한 빠르게 처리하기 위해
어떤 데이터 구조를 선택할지 결정할 수 있습니다.

976
00:21:20,830 --> 00:21:23,070
어떤 데이터 구조를 선택할지 결정할 수 있습니다.
 

977
00:21:23,070 --> 00:21:24,110

 

978
00:21:24,110 --> 00:21:25,470

 

979
00:21:25,470 --> 00:21:27,669

 

980
00:21:27,669 --> 00:21:27,679

 

981
00:21:27,679 --> 00:21:29,470

그래프도 마찬가지입니다. 예를 들어,

982
00:21:29,470 --> 00:21:31,750
그래프도 마찬가지입니다. 예를 들어,
 

983
00:21:31,750 --> 00:21:31,760

 

984
00:21:31,760 --> 00:21:34,230

그래프를 표현하는 가장 단순한 방법은 단순히 간선의

985
00:21:34,230 --> 00:21:34,240
그래프를 표현하는 가장 단순한 방법은 단순히 간선의
 

986
00:21:34,240 --> 00:21:36,269
그래프를 표현하는 가장 단순한 방법은 단순히 간선의
긴 목록을 사용하는 것입니다.

987
00:21:36,269 --> 00:21:36,279
긴 목록을 사용하는 것입니다.
 

988
00:21:36,279 --> 00:21:38,789
긴 목록을 사용하는 것입니다.
예를 들어, 이 그래프에서

989
00:21:38,789 --> 00:21:38,799
예를 들어, 이 그래프에서
 

990
00:21:38,799 --> 00:21:42,110
예를 들어, 이 그래프에서
01은

991
00:21:42,110 --> 00:21:42,120
01은
 

992
00:21:42,120 --> 00:21:45,590
01은
간선이고, 02는

993
00:21:45,590 --> 00:21:45,600
간선이고, 02는
 

994
00:21:45,600 --> 00:21:49,870
간선이고, 02는
또 다른 간선이고, 12, 21... 이렇게 간선 목록이 길게 나열되어 있다고 가정해 봅시다. 순서는

995
00:21:49,870 --> 00:21:53,070
또 다른 간선이고, 12, 21... 이렇게 간선 목록이 길게 나열되어 있다고 가정해 봅시다. 순서는
 

996
00:21:53,070 --> 00:21:53,080

 

997
00:21:53,080 --> 00:21:54,630

중요하지 않습니다.

998
00:21:54,630 --> 00:21:54,640
중요하지 않습니다.
 

999
00:21:54,640 --> 00:21:58,029
중요하지 않습니다.
첫 번째가 1이고, 2가 12입니다. 아, 맞습니다.

1000
00:21:58,029 --> 00:21:58,039
첫 번째가 1이고, 2가 12입니다. 아, 맞습니다.
 

1001
00:21:58,039 --> 00:22:00,590
첫 번째가 1이고, 2가 12입니다. 아, 맞습니다.
죄송합니다. 간선이 위쪽을 향하고 있네요.

1002
00:22:00,590 --> 00:22:00,600
죄송합니다. 간선이 위쪽을 향하고 있네요.
 

1003
00:22:00,600 --> 00:22:04,310
죄송합니다. 간선이 위쪽을 향하고 있네요.
에릭, 고마워요.

1004
00:22:04,310 --> 00:22:04,320

 

1005
00:22:04,320 --> 00:22:07,630

제이슨, 괜찮아요. 자, 이제

1006
00:22:07,630 --> 00:22:07,640
제이슨, 괜찮아요. 자, 이제
 

1007
00:22:07,640 --> 00:22:09,430
제이슨, 괜찮아요. 자, 이제
그래프 알고리즘이 있다고 가정해 봅시다.

1008
00:22:09,430 --> 00:22:11,669
그래프 알고리즘이 있다고 가정해 봅시다.
 

1009
00:22:11,669 --> 00:22:11,679

 

1010
00:22:11,679 --> 00:22:15,789

V에서 w로 가는 간선이 있는지 여러

1011
00:22:15,789 --> 00:22:15,799
V에서 w로 가는 간선이 있는지 여러
 

1012
00:22:15,799 --> 00:22:18,070
V에서 w로 가는 간선이 있는지 여러
번 확인해야 합니다.

1013
00:22:18,070 --> 00:22:18,080
번 확인해야 합니다.
 

1014
00:22:18,080 --> 00:22:20,029
번 확인해야 합니다.
이 데이터 구조에서 이 작업을 수행하는 데 얼마나 걸릴까요? 만약

1015
00:22:20,029 --> 00:22:21,789
이 데이터 구조에서 이 작업을 수행하는 데 얼마나 걸릴까요? 만약
 

1016
00:22:21,789 --> 00:22:21,799

 

1017
00:22:21,799 --> 00:22:23,830

간선 목록이 뒤죽박죽이고 정리가 안 되어 있다면...

1018
00:22:23,830 --> 00:22:23,840
간선 목록이 뒤죽박죽이고 정리가 안 되어 있다면...
 

1019
00:22:23,840 --> 00:22:26,230
간선 목록이 뒤죽박죽이고 정리가 안 되어 있다면...
V에서 W로 가는 간선이 존재하는지 알고 싶다고 가정해 봅시다. 제가 할 수 있는 유일한 방법은

1020
00:22:26,230 --> 00:22:28,029
V에서 W로 가는 간선이 존재하는지 알고 싶다고 가정해 봅시다. 제가 할 수 있는 유일한 방법은
 

1021
00:22:28,029 --> 00:22:28,039

 

1022
00:22:28,039 --> 00:22:29,830

이 집합을 따라가면서 "이 간선이

1023
00:22:29,830 --> 00:22:29,840
이 집합을 따라가면서 "이 간선이
 

1024
00:22:29,840 --> 00:22:31,430
이 집합을 따라가면서 "이 간선이
내가 찾고 있는 간선인가?", "아니오", "이 간선이 내가

1025
00:22:31,430 --> 00:22:31,440
내가 찾고 있는 간선인가?", "아니오", "이 간선이 내가
 

1026
00:22:31,440 --> 00:22:33,590
내가 찾고 있는 간선인가?", "아니오", "이 간선이 내가
찾고 있는

1027
00:22:33,590 --> 00:22:33,600
찾고 있는
 

1028
00:22:33,600 --> 00:22:35,590
찾고 있는
간선인가?"를 확인하는 for 루프를 작성하는 것뿐입니다. 즉, 간선을 찾을 때마다

1029
00:22:35,590 --> 00:22:38,110
간선인가?"를 확인하는 for 루프를 작성하는 것뿐입니다. 즉, 간선을 찾을 때마다
 

1030
00:22:38,110 --> 00:22:38,120

 

1031
00:22:38,120 --> 00:22:39,630

그래프에 있는 간선의 수에 비례하는 시간이 소요되는데, 이는 최대

1032
00:22:39,630 --> 00:22:39,640
그래프에 있는 간선의 수에 비례하는 시간이 소요되는데, 이는 최대
 

1033
00:22:39,640 --> 00:22:42,390
그래프에 있는 간선의 수에 비례하는 시간이 소요되는데, 이는 최대
V제곱에 달할 수 있습니다. 따라서 이는

1034
00:22:42,390 --> 00:22:44,630
V제곱에 달할 수 있습니다. 따라서 이는
 

1035
00:22:44,630 --> 00:22:46,230

 

1036
00:22:46,230 --> 00:22:46,240

 

1037
00:22:46,240 --> 00:22:48,190

컴퓨터에서 그래프를 표현하는 좋은 방법이 아닙니다. 데이터 구조를 다시 생각해 보면,

1038
00:22:48,190 --> 00:22:49,750
컴퓨터에서 그래프를 표현하는 좋은 방법이 아닙니다. 데이터 구조를 다시 생각해 보면,
 

1039
00:22:49,750 --> 00:22:49,760

 

1040
00:22:49,760 --> 00:22:51,070

간선 리스트는 좋은 방법이 아닐 수 있습니다.

1041
00:22:51,070 --> 00:22:51,080
간선 리스트는 좋은 방법이 아닐 수 있습니다.
 

1042
00:22:51,080 --> 00:22:52,950
간선 리스트는 좋은 방법이 아닐 수 있습니다.
물론

1043
00:22:52,950 --> 00:22:52,960
물론
 

1044
00:22:52,960 --> 00:22:54,669
물론
그래프를 표현하는 방식이

1045
00:22:54,669 --> 00:22:54,679
그래프를 표현하는 방식이
 

1046
00:22:54,679 --> 00:22:57,269
그래프를 표현하는 방식이
간선 리스트와 비슷하게 보이기는 하지만 말입니다.

1047
00:22:57,269 --> 00:22:57,279
간선 리스트와 비슷하게 보이기는 하지만 말입니다.
 

1048
00:22:57,279 --> 00:22:59,230
간선 리스트와 비슷하게 보이기는 하지만 말입니다.
어쨌든, 더 일반적인 방법은 인접

1049
00:22:59,230 --> 00:23:00,789
어쨌든, 더 일반적인 방법은 인접
 

1050
00:23:00,789 --> 00:23:00,799

 

1051
00:23:00,799 --> 00:23:04,549

리스트를 저장하는 것입니다.

1052
00:23:04,549 --> 00:23:04,559
리스트를 저장하는 것입니다.
 

1053
00:23:04,559 --> 00:23:07,390
리스트를 저장하는 것입니다.
인접 리스트의 기본 개념은 정점 U에서 U로 나가는

1054
00:23:07,390 --> 00:23:09,990
인접 리스트의 기본 개념은 정점 U에서 U로 나가는
 

1055
00:23:09,990 --> 00:23:13,029

 

1056
00:23:13,029 --> 00:23:15,510

 

1057
00:23:15,510 --> 00:23:17,789

 

1058
00:23:17,789 --> 00:23:17,799

 

1059
00:23:17,799 --> 00:23:23,310

모든 간선을 매핑하는 집합을 저장하는 것입니다.

1060
00:23:23,310 --> 00:23:23,320
모든 간선을 매핑하는 집합을 저장하는 것입니다.
 

1061
00:23:23,320 --> 00:23:25,549
모든 간선을 매핑하는 집합을 저장하는 것입니다.
다시 말해,

1062
00:23:25,549 --> 00:23:26,909
다시 말해,
 

1063
00:23:26,909 --> 00:23:26,919

 

1064
00:23:26,919 --> 00:23:29,789

모든 정점에서 나가는 모든 간선을 추적하는 것입니다.

1065
00:23:29,789 --> 00:23:31,669
모든 정점에서 나가는 모든 간선을 추적하는 것입니다.
 

1066
00:23:31,669 --> 00:23:31,679

 

1067
00:23:31,679 --> 00:23:33,029

이

1068
00:23:33,029 --> 00:23:33,039
이
 

1069
00:23:33,039 --> 00:23:34,950
이
객체를 어떻게 저장할지 결정해야 합니다. 종종

1070
00:23:34,950 --> 00:23:36,269
객체를 어떻게 저장할지 결정해야 합니다. 종종
 

1071
00:23:36,269 --> 00:23:36,279

 

1072
00:23:36,279 --> 00:23:38,950

V에서 W로 가는 간선이 있는지와 같은 쿼리에 답해야 하죠. 어떻게 하면

1073
00:23:38,950 --> 00:23:38,960
V에서 W로 가는 간선이 있는지와 같은 쿼리에 답해야 하죠. 어떻게 하면
 

1074
00:23:38,960 --> 00:23:42,070
V에서 W로 가는 간선이 있는지와 같은 쿼리에 답해야 하죠. 어떻게 하면
좋을까요? 먼저 V를 조회하면

1075
00:23:42,070 --> 00:23:44,470
좋을까요? 먼저 V를 조회하면
 

1076
00:23:44,470 --> 00:23:44,480

 

1077
00:23:44,480 --> 00:23:46,070

V에 인접한 모든 요소의 목록이나 집합이 반환됩니다.

1078
00:23:46,070 --> 00:23:46,080
V에 인접한 모든 요소의 목록이나 집합이 반환됩니다.
 

1079
00:23:46,080 --> 00:23:47,390
V에 인접한 모든 요소의 목록이나 집합이 반환됩니다.
이 집합을 조회해야 하는데, 이 과정이 매우 빨라야 합니다.

1080
00:23:47,390 --> 00:23:47,400
이 집합을 조회해야 하는데, 이 과정이 매우 빨라야 합니다.
 

1081
00:23:47,400 --> 00:23:50,029
이 집합을 조회해야 하는데, 이 과정이 매우 빨라야 합니다.
그래서

1082
00:23:50,029 --> 00:23:52,789
그래서
 

1083
00:23:52,789 --> 00:23:52,799

 

1084
00:23:52,799 --> 00:23:57,230

인접한

1085
00:23:57,230 --> 00:23:57,240
인접한
 

1086
00:23:57,240 --> 00:24:00,590
인접한
요소들의 집합을 직접

1087
00:24:00,590 --> 00:24:00,600
요소들의 집합을 직접
 

1088
00:24:00,600 --> 00:24:03,470
요소들의 집합을 직접
접근 배열이나 해시

1089
00:24:03,470 --> 00:24:03,480
접근 배열이나 해시
 

1090
00:24:03,480 --> 00:24:13,870
접근 배열이나 해시
테이블 같은 형태로 저장하면 조회 속도가 훨씬 빨라질 겁니다.

1091
00:24:13,870 --> 00:24:13,880

 

1092
00:24:13,880 --> 00:24:16,909

예를 들어, 그래프에서 간선이 존재하는지 확인하는 데 얼마나 걸릴까요?

1093
00:24:16,909 --> 00:24:18,029
예를 들어, 그래프에서 간선이 존재하는지 확인하는 데 얼마나 걸릴까요?
 

1094
00:24:18,029 --> 00:24:19,630

 

1095
00:24:19,630 --> 00:24:21,510

 

1096
00:24:21,510 --> 00:24:21,520

 

1097
00:24:21,520 --> 00:24:23,630

먼저

1098
00:24:23,630 --> 00:24:23,640
먼저
 

1099
00:24:23,640 --> 00:24:25,070
먼저
이 객체를 꺼내서 내부를 살펴봅니다. 만약 이 객체를 해시 테이블로

1100
00:24:25,070 --> 00:24:25,080
이 객체를 꺼내서 내부를 살펴봅니다. 만약 이 객체를 해시 테이블로
 

1101
00:24:25,080 --> 00:24:27,669
이 객체를 꺼내서 내부를 살펴봅니다. 만약 이 객체를 해시 테이블로
저장한다면,

1102
00:24:27,669 --> 00:24:27,679
저장한다면,
 

1103
00:24:27,679 --> 00:24:29,590
저장한다면,
예상 시간은 1차 탐색으로 계산됩니다. 왜냐하면 이것이 1차 탐색이고,

1104
00:24:29,590 --> 00:24:31,070
예상 시간은 1차 탐색으로 계산됩니다. 왜냐하면 이것이 1차 탐색이고,
 

1105
00:24:31,070 --> 00:24:32,630

 

1106
00:24:32,630 --> 00:24:32,640

 

1107
00:24:32,640 --> 00:24:34,830

또 다른 1차 탐색이 필요하기 때문입니다. 이렇게 간단한 방법으로

1108
00:24:34,830 --> 00:24:34,840
또 다른 1차 탐색이 필요하기 때문입니다. 이렇게 간단한 방법으로
 

1109
00:24:34,840 --> 00:24:37,190
또 다른 1차 탐색이 필요하기 때문입니다. 이렇게 간단한 방법으로
v^2에서 1로 시간을 단축할 수 있습니다. 네,

1110
00:24:37,190 --> 00:24:41,470
v^2에서 1로 시간을 단축할 수 있습니다. 네,
 

1111
00:24:41,470 --> 00:24:41,480

 

1112
00:24:41,480 --> 00:24:43,789

좋은 질문입니다.

1113
00:24:43,789 --> 00:24:43,799
좋은 질문입니다.
 

1114
00:24:43,799 --> 00:24:45,549
좋은 질문입니다.
설계 방식이 있습니다.  여기서 결정을 내려야 하는데, 죄송합니다. 제가

1115
00:24:45,549 --> 00:24:45,559
설계 방식이 있습니다.  여기서 결정을 내려야 하는데, 죄송합니다. 제가
 

1116
00:24:45,559 --> 00:24:47,070
설계 방식이 있습니다.  여기서 결정을 내려야 하는데, 죄송합니다. 제가
머릿속으로

1117
00:24:47,070 --> 00:24:47,080
머릿속으로
 

1118
00:24:47,080 --> 00:24:48,549
머릿속으로
무방향 그래프에 대해 많이 생각하다 보니

1119
00:24:48,549 --> 00:24:48,559
무방향 그래프에 대해 많이 생각하다 보니
 

1120
00:24:48,559 --> 00:24:49,870
무방향 그래프에 대해 많이 생각하다 보니
이런 실수를 자주 할 것 같습니다. 지적해 주셔서 감사합니다.

1121
00:24:49,870 --> 00:24:49,880
이런 실수를 자주 할 것 같습니다. 지적해 주셔서 감사합니다.
 

1122
00:24:49,880 --> 00:24:51,669
이런 실수를 자주 할 것 같습니다. 지적해 주셔서 감사합니다.
음,

1123
00:24:51,669 --> 00:24:53,149
음,
 

1124
00:24:53,149 --> 00:24:54,830

 

1125
00:24:54,830 --> 00:24:54,840

 

1126
00:24:54,840 --> 00:24:56,870

모든 정점의 나가는 간선, 즉 외부 간선만 추적하는 것이 합리적인 방법일 수 있습니다. 이는

1127
00:24:56,870 --> 00:24:56,880
모든 정점의 나가는 간선, 즉 외부 간선만 추적하는 것이 합리적인 방법일 수 있습니다. 이는
 

1128
00:24:56,880 --> 00:24:58,909
모든 정점의 나가는 간선, 즉 외부 간선만 추적하는 것이 합리적인 방법일 수 있습니다. 이는
알고리즘 설계에 따라 달라지는 결정입니다. 들어오는 간선을 추적할 수도 있고, 어떤 경우든 나중에 그래프를 어떻게 활용할지에 따라 달라

1129
00:24:58,909 --> 00:24:58,919
알고리즘 설계에 따라 달라지는 결정입니다. 들어오는 간선을 추적할 수도 있고, 어떤 경우든 나중에 그래프를 어떻게 활용할지에 따라 달라
 

1130
00:24:58,919 --> 00:25:00,070
알고리즘 설계에 따라 달라지는 결정입니다. 들어오는 간선을 추적할 수도 있고, 어떤 경우든 나중에 그래프를 어떻게 활용할지에 따라 달라
집니다. 중요한 것은

1131
00:25:00,070 --> 00:25:01,830
집니다. 중요한 것은
 

1132
00:25:01,830 --> 00:25:03,470

 

1133
00:25:03,470 --> 00:25:03,480

 

1134
00:25:03,480 --> 00:25:05,510

나중에 그래프를 어떻게 처리할지 계획하는 것입니다. 네,

1135
00:25:05,510 --> 00:25:05,520
나중에 그래프를 어떻게 처리할지 계획하는 것입니다. 네,
 

1136
00:25:05,520 --> 00:25:08,389
나중에 그래프를 어떻게 처리할지 계획하는 것입니다. 네,
좋은 지적입니다. 죄송합니다.

1137
00:25:08,389 --> 00:25:08,399
좋은 지적입니다. 죄송합니다.
 

1138
00:25:08,399 --> 00:25:10,510
좋은 지적입니다. 죄송합니다.
저는 기하학을 전공해서 방향

1139
00:25:10,510 --> 00:25:10,520
저는 기하학을 전공해서 방향
 

1140
00:25:10,520 --> 00:25:13,230
저는 기하학을 전공해서 방향
그래프를 접할 기회가 많지 않습니다. 하지만

1141
00:25:13,230 --> 00:25:13,240
그래프를 접할 기회가 많지 않습니다. 하지만
 

1142
00:25:13,240 --> 00:25:14,590
그래프를 접할 기회가 많지 않습니다. 하지만
모든 사람이 저와 같은 문제를 다루는 것은 아니라는 점을 기억하는 것이 중요합니다. 자,

1143
00:25:14,590 --> 00:25:16,029
모든 사람이 저와 같은 문제를 다루는 것은 아니라는 점을 기억하는 것이 중요합니다. 자,
 

1144
00:25:16,029 --> 00:25:16,039

 

1145
00:25:16,039 --> 00:25:19,310

이제 좀 더

1146
00:25:19,310 --> 00:25:19,320
이제 좀 더
 

1147
00:25:19,320 --> 00:25:21,510
이제 좀 더
극단적인 예를 들어보겠습니다. 세 번째

1148
00:25:21,510 --> 00:25:21,520
극단적인 예를 들어보겠습니다. 세 번째
 

1149
00:25:21,520 --> 00:25:23,149
극단적인 예를 들어보겠습니다. 세 번째
표현 방식으로는

1150
00:25:23,149 --> 00:25:24,669
표현 방식으로는
 

1151
00:25:24,669 --> 00:25:24,679

 

1152
00:25:24,679 --> 00:25:27,430

인접 리스트를 인접 행렬이라고 생각할 수 있습니다. 이 행렬에서는 이 간선이

1153
00:25:27,430 --> 00:25:28,909
인접 리스트를 인접 행렬이라고 생각할 수 있습니다. 이 행렬에서는 이 간선이
 

1154
00:25:28,909 --> 00:25:28,919

 

1155
00:25:28,919 --> 00:25:32,029

존재하는지, 저 간선이 존재하는지 등을 나타내는 거대한 v x v 배열을 유지합니다.

1156
00:25:32,029 --> 00:25:34,549
존재하는지, 저 간선이 존재하는지 등을 나타내는 거대한 v x v 배열을 유지합니다.
 

1157
00:25:34,549 --> 00:25:34,559

 

1158
00:25:34,559 --> 00:25:37,669

간선이 존재하는지 확인하는 것은 매우 쉽습니다.

1159
00:25:37,669 --> 00:25:37,679
간선이 존재하는지 확인하는 것은 매우 쉽습니다.
 

1160
00:25:37,679 --> 00:25:40,029
간선이 존재하는지 확인하는 것은 매우 쉽습니다.
하지만

1161
00:25:40,029 --> 00:25:40,039
하지만
 

1162
00:25:40,039 --> 00:25:41,430
하지만
그래프 알고리즘을 만든다고 가정해 보겠습니다.

1163
00:25:41,430 --> 00:25:41,440
그래프 알고리즘을 만든다고 가정해 보겠습니다.
 

1164
00:25:41,440 --> 00:25:44,149
그래프 알고리즘을 만든다고 가정해 보겠습니다.
어떤 정점의 모든 이웃을 순회하는 for 루프가 있을 겁니다. 예를 들어, 어떤 정점의

1165
00:25:44,149 --> 00:25:46,230
어떤 정점의 모든 이웃을 순회하는 for 루프가 있을 겁니다. 예를 들어, 어떤 정점의
 

1166
00:25:46,230 --> 00:25:46,240

 

1167
00:25:46,240 --> 00:25:48,870

모든 이웃을 순회하려면

1168
00:25:48,870 --> 00:25:50,590
모든 이웃을 순회하려면
 

1169
00:25:50,590 --> 00:25:51,870

 

1170
00:25:51,870 --> 00:25:51,880

 

1171
00:25:51,880 --> 00:25:53,269

이웃의 수에 비례하는 시간이 걸리겠죠.

1172
00:25:53,269 --> 00:25:53,279
이웃의 수에 비례하는 시간이 걸리겠죠.
 

1173
00:25:53,279 --> 00:25:55,710
이웃의 수에 비례하는 시간이 걸리겠죠.
하지만 만약 두 정점이 인접해 있는지 여부를 나타내는

1174
00:25:55,710 --> 00:25:55,720
하지만 만약 두 정점이 인접해 있는지 여부를 나타내는
 

1175
00:25:55,720 --> 00:25:57,510
하지만 만약 두 정점이 인접해 있는지 여부를 나타내는
이진 값들만 있는 큰 인접 행렬이 있다면,

1176
00:25:57,510 --> 00:26:00,070
이진 값들만 있는 큰 인접 행렬이 있다면,
 

1177
00:26:00,070 --> 00:26:02,950

 

1178
00:26:02,950 --> 00:26:02,960

 

1179
00:26:02,960 --> 00:26:05,149

모든 이웃을 순회하려면

1180
00:26:05,149 --> 00:26:05,159
모든 이웃을 순회하려면
 

1181
00:26:05,159 --> 00:26:07,070
모든 이웃을 순회하려면
모든 정점을 하나씩 확인하면서 어떤 정점이

1182
00:26:07,070 --> 00:26:07,080
모든 정점을 하나씩 확인하면서 어떤 정점이
 

1183
00:26:07,080 --> 00:26:09,269
모든 정점을 하나씩 확인하면서 어떤 정점이
1인지 확인하고 그에 따라

1184
00:26:09,269 --> 00:26:09,279
1인지 확인하고 그에 따라
 

1185
00:26:09,279 --> 00:26:11,110
1인지 확인하고 그에 따라
어떤 작업을 수행해야 합니다. 이렇게 하면

1186
00:26:11,110 --> 00:26:11,120
어떤 작업을 수행해야 합니다. 이렇게 하면
 

1187
00:26:11,120 --> 00:26:12,830
어떤 작업을 수행해야 합니다. 이렇게 하면
시간과 공간이 더 많이 소요될 수 있습니다. 이해가 되시나요? 어쨌든, 이것이 바로

1188
00:26:12,830 --> 00:26:15,350
시간과 공간이 더 많이 소요될 수 있습니다. 이해가 되시나요? 어쨌든, 이것이 바로
 

1189
00:26:15,350 --> 00:26:17,990

 

1190
00:26:17,990 --> 00:26:19,710

 

1191
00:26:19,710 --> 00:26:19,720

 

1192
00:26:19,720 --> 00:26:21,190

제가 코딩할 때 많이 사용하는 '게으른 사람의 그래프 표현'입니다.

1193
00:26:21,190 --> 00:26:21,200
제가 코딩할 때 많이 사용하는 '게으른 사람의 그래프 표현'입니다.
 

1194
00:26:21,200 --> 00:26:23,230
제가 코딩할 때 많이 사용하는 '게으른 사람의 그래프 표현'입니다.
인접 행렬은 다루기 쉽기 때문이죠. 하지만

1195
00:26:23,230 --> 00:26:23,240
인접 행렬은 다루기 쉽기 때문이죠. 하지만
 

1196
00:26:23,240 --> 00:26:25,590
인접 행렬은 다루기 쉽기 때문이죠. 하지만
공간을 많이 차지하고, 공간이 충분

1197
00:26:25,590 --> 00:26:26,590
공간을 많이 차지하고, 공간이 충분
 

1198
00:26:26,590 --> 00:26:26,600

 

1199
00:26:26,600 --> 00:26:27,909

하더라도 항상 가장 효율적인 방법은 아닙니다.

1200
00:26:27,909 --> 00:26:27,919
하더라도 항상 가장 효율적인 방법은 아닙니다.
 

1201
00:26:27,919 --> 00:26:29,830
하더라도 항상 가장 효율적인 방법은 아닙니다.
이웃을 순회하는 데

1202
00:26:29,830 --> 00:26:31,909
이웃을 순회하는 데
 

1203
00:26:31,909 --> 00:26:31,919

 

1204
00:26:31,919 --> 00:26:34,110

시간이 꽤 걸릴 수 있기 때문입니다. 오늘 강의의 핵심은 바로 이러한

1205
00:26:34,110 --> 00:26:36,510
시간이 꽤 걸릴 수 있기 때문입니다. 오늘 강의의 핵심은 바로 이러한
 

1206
00:26:36,510 --> 00:26:36,520

 

1207
00:26:36,520 --> 00:26:38,190

전형적인 문제를 소개하는 것입니다.

1208
00:26:38,190 --> 00:26:38,200
전형적인 문제를 소개하는 것입니다.
 

1209
00:26:38,200 --> 00:26:40,230
전형적인 문제를 소개하는 것입니다.
그래프에서 우리가 가장 걱정하는 것 중 하나는

1210
00:26:40,230 --> 00:26:40,240
그래프에서 우리가 가장 걱정하는 것 중 하나는
 

1211
00:26:40,240 --> 00:26:42,470
그래프에서 우리가 가장 걱정하는 것 중 하나는
경로, 특히 최단 경로를 계산하는 것입니다. 우선 가장 먼저 해야 할 일은

1212
00:26:42,470 --> 00:26:44,630
경로, 특히 최단 경로를 계산하는 것입니다. 우선 가장 먼저 해야 할 일은
 

1213
00:26:44,630 --> 00:26:47,230

 

1214
00:26:47,230 --> 00:26:47,240

 

1215
00:26:47,240 --> 00:26:49,389

그래프에서 경로가 무엇인지 정의하는 것입니다.

1216
00:26:49,389 --> 00:26:49,399
그래프에서 경로가 무엇인지 정의하는 것입니다.
 

1217
00:26:49,399 --> 00:26:51,590
그래프에서 경로가 무엇인지 정의하는 것입니다.
그래프를 도로망처럼 생각해 봅시다.

1218
00:26:51,590 --> 00:26:51,600
그래프를 도로망처럼 생각해 봅시다.
 

1219
00:26:51,600 --> 00:26:53,510
그래프를 도로망처럼 생각해 봅시다.
모든 노드를 교차점으로 생각해 보세요.

1220
00:26:53,510 --> 00:26:55,990
모든 노드를 교차점으로 생각해 보세요.
 

1221
00:26:55,990 --> 00:26:56,000

 

1222
00:26:56,000 --> 00:26:57,710

대략 켄달 스퀘어와 같은 모양이죠.

1223
00:26:57,710 --> 00:26:57,720
대략 켄달 스퀘어와 같은 모양이죠.
 

1224
00:26:57,720 --> 00:26:58,750
대략 켄달 스퀘어와 같은 모양이죠.
정사각형입니다. 어쨌든,

1225
00:26:58,750 --> 00:27:01,710
정사각형입니다. 어쨌든,
 

1226
00:27:01,710 --> 00:27:04,669

 

1227
00:27:04,669 --> 00:27:06,350

 

1228
00:27:06,350 --> 00:27:06,360

 

1229
00:27:06,360 --> 00:27:08,990

정점 1에서 정점 3으로 가는 방법이 있는지, 더 정확히 말하면 최단

1230
00:27:08,990 --> 00:27:10,470
정점 1에서 정점 3으로 가는 방법이 있는지, 더 정확히 말하면 최단
 

1231
00:27:10,470 --> 00:27:10,480

 

1232
00:27:10,480 --> 00:27:12,029

경로가 있는지를 찾고 싶다고 가정해 보겠습니다. 가장 먼저 해야 할 일은 찾고자 하는 것, 즉 경로를

1233
00:27:12,029 --> 00:27:14,430
경로가 있는지를 찾고 싶다고 가정해 보겠습니다. 가장 먼저 해야 할 일은 찾고자 하는 것, 즉 경로를
 

1234
00:27:14,430 --> 00:27:15,549

 

1235
00:27:15,549 --> 00:27:15,559

 

1236
00:27:15,559 --> 00:27:17,029

정의하는 것입니다. 경로는

1237
00:27:17,029 --> 00:27:19,710
정의하는 것입니다. 경로는
 

1238
00:27:19,710 --> 00:27:21,230

 

1239
00:27:21,230 --> 00:27:21,240

 

1240
00:27:21,240 --> 00:27:24,430

그래프에서

1241
00:27:24,430 --> 00:27:24,440
그래프에서
 

1242
00:27:24,440 --> 00:27:26,510
그래프에서
인접한 정점 쌍이 연결된 일련의 정점입니다. 그래프에서

1243
00:27:26,510 --> 00:27:29,230
인접한 정점 쌍이 연결된 일련의 정점입니다. 그래프에서
 

1244
00:27:29,230 --> 00:27:29,240

 

1245
00:27:29,240 --> 00:27:31,549

경로가 무엇인지 직관적으로 이해하는 것이 중요합니다.

1246
00:27:31,549 --> 00:27:31,559
경로가 무엇인지 직관적으로 이해하는 것이 중요합니다.
 

1247
00:27:31,559 --> 00:27:35,269
경로가 무엇인지 직관적으로 이해하는 것이 중요합니다.
예를 들어, 여기...  경로 P는 V1, V2, V3와 같습니다. 따라서

1248
00:27:35,269 --> 00:27:35,279
예를 들어, 여기...  경로 P는 V1, V2, V3와 같습니다. 따라서
 

1249
00:27:35,279 --> 00:27:37,070
예를 들어, 여기...  경로 P는 V1, V2, V3와 같습니다. 따라서
V1에서

1250
00:27:37,070 --> 00:27:37,080
V1에서
 

1251
00:27:37,080 --> 00:27:40,149
V1에서
V2로 가는 간선과 V2에서 V3로 가는 간선이 있으므로,

1252
00:27:40,149 --> 00:27:42,590
V2로 가는 간선과 V2에서 V3로 가는 간선이 있으므로,
 

1253
00:27:42,590 --> 00:27:44,630

 

1254
00:27:44,630 --> 00:27:44,640

 

1255
00:27:44,640 --> 00:27:46,789

정의에 따른 가정을 만족합니다. 그래프에서 경로가 아닌 것은

1256
00:27:46,789 --> 00:27:46,799
정의에 따른 가정을 만족합니다. 그래프에서 경로가 아닌 것은
 

1257
00:27:46,799 --> 00:27:49,149
정의에 따른 가정을 만족합니다. 그래프에서 경로가 아닌 것은
V1 → V3와 같은 경우입니다. 왜냐하면

1258
00:27:49,149 --> 00:27:49,159
V1 → V3와 같은 경우입니다. 왜냐하면
 

1259
00:27:49,159 --> 00:27:51,029
V1 → V3와 같은 경우입니다. 왜냐하면
간선이 없기 때문입니다.

1260
00:27:51,029 --> 00:27:51,039
간선이 없기 때문입니다.
 

1261
00:27:51,039 --> 00:27:54,710
간선이 없기 때문입니다.
경로에 대해 이야기할 때, 경로의

1262
00:27:54,710 --> 00:27:56,389
경로에 대해 이야기할 때, 경로의
 

1263
00:27:56,389 --> 00:27:56,399

 

1264
00:27:56,399 --> 00:27:58,430

길이를 나타내는 자연스러운 개념이 있습니다. 경로의 길이는

1265
00:27:58,430 --> 00:27:59,870
길이를 나타내는 자연스러운 개념이 있습니다. 경로의 길이는
 

1266
00:27:59,870 --> 00:27:59,880

 

1267
00:27:59,880 --> 00:28:01,389

경로에 있는 정점의 수에서

1268
00:28:01,389 --> 00:28:01,399
경로에 있는 정점의 수에서
 

1269
00:28:01,399 --> 00:28:03,950
경로에 있는 정점의 수에서
1을 뺀 값 또는 경로가 지나가는 간선의 수와 같다고 생각할 수 있습니다. 이 둘은

1270
00:28:03,950 --> 00:28:05,549
1을 뺀 값 또는 경로가 지나가는 간선의 수와 같다고 생각할 수 있습니다. 이 둘은
 

1271
00:28:05,549 --> 00:28:05,559

 

1272
00:28:05,559 --> 00:28:07,990

같은 의미입니다. 예를 들어,

1273
00:28:07,990 --> 00:28:08,000
같은 의미입니다. 예를 들어,
 

1274
00:28:08,000 --> 00:28:10,710
같은 의미입니다. 예를 들어,
여기 경로 P의 길이는 2입니다.

1275
00:28:10,710 --> 00:28:10,720
여기 경로 P의 길이는 2입니다.
 

1276
00:28:10,720 --> 00:28:13,470
여기 경로 P의 길이는 2입니다.
여러분,

1277
00:28:13,470 --> 00:28:13,480
여러분,
 

1278
00:28:13,480 --> 00:28:16,470
여러분,
제가 자주 접하는 코딩 오류 중 하나는

1279
00:28:16,470 --> 00:28:16,480
제가 자주 접하는 코딩 오류 중 하나는
 

1280
00:28:16,480 --> 00:28:19,029
제가 자주 접하는 코딩 오류 중 하나는
실수로 이 숫자에 1을 더하는 것입니다.

1281
00:28:19,029 --> 00:28:19,039
실수로 이 숫자에 1을 더하는 것입니다.
 

1282
00:28:19,039 --> 00:28:20,830
실수로 이 숫자에 1을 더하는 것입니다.
당연히 경로에는 간선의 수보다 정점이 하나 더 많습니다.

1283
00:28:20,830 --> 00:28:22,870
당연히 경로에는 간선의 수보다 정점이 하나 더 많습니다.
 

1284
00:28:22,870 --> 00:28:22,880

 

1285
00:28:22,880 --> 00:28:24,909

그리고

1286
00:28:24,909 --> 00:28:26,990
그리고
 

1287
00:28:26,990 --> 00:28:27,000

 

1288
00:28:27,000 --> 00:28:29,110

어떤 두 정점 사이에도 잠재적으로 하나 이상의 경로가 존재할 수 있습니다.

1289
00:28:29,110 --> 00:28:31,350
어떤 두 정점 사이에도 잠재적으로 하나 이상의 경로가 존재할 수 있습니다.
 

1290
00:28:31,350 --> 00:28:33,950

 

1291
00:28:33,950 --> 00:28:33,960

 

1292
00:28:33,960 --> 00:28:36,789

다음과 같은 무방향 그래프가 있다고 가정해 보겠습니다.

1293
00:28:36,789 --> 00:28:36,799
다음과 같은 무방향 그래프가 있다고 가정해 보겠습니다.
 

1294
00:28:36,799 --> 00:28:40,750
다음과 같은 무방향 그래프가 있다고 가정해 보겠습니다.
정사각형에 대각선을 더한 형태라고 생각하면 됩니다. 여기에

1295
00:28:40,750 --> 00:28:40,760
정사각형에 대각선을 더한 형태라고 생각하면 됩니다. 여기에
 

1296
00:28:40,760 --> 00:28:43,470
정사각형에 대각선을 더한 형태라고 생각하면 됩니다. 여기에
노드들이 있죠. 왼쪽 아래에서 오른쪽 위로 가는 완벽하게 유효한

1297
00:28:43,470 --> 00:28:43,480
노드들이 있죠. 왼쪽 아래에서 오른쪽 위로 가는 완벽하게 유효한
 

1298
00:28:43,480 --> 00:28:45,029
노드들이 있죠. 왼쪽 아래에서 오른쪽 위로 가는 완벽하게 유효한
경로는 옆으로

1299
00:28:45,029 --> 00:28:45,039
경로는 옆으로
 

1300
00:28:45,039 --> 00:28:48,149
경로는 옆으로
한 칸 이동하고 위로 한 칸 이동하는 것입니다. 하지만

1301
00:28:48,149 --> 00:28:48,159
한 칸 이동하고 위로 한 칸 이동하는 것입니다. 하지만
 

1302
00:28:48,159 --> 00:28:49,430
한 칸 이동하고 위로 한 칸 이동하는 것입니다. 하지만
물론 왼쪽 아래에서 오른쪽 위로 가는 더 효율적인 방법은

1303
00:28:49,430 --> 00:28:50,950
물론 왼쪽 아래에서 오른쪽 위로 가는 더 효율적인 방법은
 

1304
00:28:50,950 --> 00:28:53,750

 

1305
00:28:53,750 --> 00:28:53,760

 

1306
00:28:53,760 --> 00:28:55,669

대각선을 따라 이동하는 것입니다. 따라서 최단

1307
00:28:55,669 --> 00:28:55,679
대각선을 따라 이동하는 것입니다. 따라서 최단
 

1308
00:28:55,679 --> 00:28:57,350
대각선을 따라 이동하는 것입니다. 따라서 최단
경로란

1309
00:28:57,350 --> 00:28:59,070
경로란
 

1310
00:28:59,070 --> 00:29:01,110

 

1311
00:29:01,110 --> 00:29:02,870

 

1312
00:29:02,870 --> 00:29:02,880

 

1313
00:29:02,880 --> 00:29:04,430


1314
00:29:04,430 --> 00:29:04,440

 

1315
00:29:04,440 --> 00:29:06,630

그래프에서 임의의 두 정점 사이에 있는 간선 또는 정점의 수가 가장 적은 경로의 길이를 의미합니다. 자, 이것이 우리의 적입니다.

1316
00:29:06,630 --> 00:29:06,640
그래프에서 임의의 두 정점 사이에 있는 간선 또는 정점의 수가 가장 적은 경로의 길이를 의미합니다. 자, 이것이 우리의 적입니다.
 

1317
00:29:06,640 --> 00:29:08,269
그래프에서 임의의 두 정점 사이에 있는 간선 또는 정점의 수가 가장 적은 경로의 길이를 의미합니다. 자, 이것이 우리의 적입니다.
우리가 목표로 하는 것은 그래프

1318
00:29:08,269 --> 00:29:08,279
우리가 목표로 하는 것은 그래프
 

1319
00:29:08,279 --> 00:29:10,509
우리가 목표로 하는 것은 그래프
에서 정점 사이의 최단 경로를 계산하는 것입니다.

1320
00:29:10,509 --> 00:29:10,519
에서 정점 사이의 최단 경로를 계산하는 것입니다.
 

1321
00:29:10,519 --> 00:29:12,990
에서 정점 사이의 최단 경로를 계산하는 것입니다.
그리고 이것은 이

1322
00:29:12,990 --> 00:29:14,310
그리고 이것은 이
 

1323
00:29:14,310 --> 00:29:14,320

 

1324
00:29:14,320 --> 00:29:15,669

강의에서 꽤 많이 다룰 내용입니다. 매우

1325
00:29:15,669 --> 00:29:15,679
강의에서 꽤 많이 다룰 내용입니다. 매우
 

1326
00:29:15,679 --> 00:29:16,950
강의에서 꽤 많이 다룰 내용입니다. 매우
실용적인 문제이기 때문입니다. 예를 들어

1327
00:29:16,950 --> 00:29:16,960
실용적인 문제이기 때문입니다. 예를 들어
 

1328
00:29:16,960 --> 00:29:18,710
실용적인 문제이기 때문입니다. 예를 들어
라우팅 문제를 해결하고 싶을 때, 네트워크

1329
00:29:18,710 --> 00:29:18,720
라우팅 문제를 해결하고 싶을 때, 네트워크
 

1330
00:29:18,720 --> 00:29:20,149
라우팅 문제를 해결하고 싶을 때, 네트워크
에서 패킷을 이동시키고 싶을 때, 투어가

1331
00:29:20,149 --> 00:29:20,159
에서 패킷을 이동시키고 싶을 때, 투어가
 

1332
00:29:20,159 --> 00:29:22,110
에서 패킷을 이동시키고 싶을 때, 투어가
아닌 이상 중간에

1333
00:29:22,110 --> 00:29:24,549
아닌 이상 중간에
 

1334
00:29:24,549 --> 00:29:24,559

 

1335
00:29:24,559 --> 00:29:26,110

너무 많은 컴퓨터를 거치지 않는 것이 좋습니다. 그럴 때는

1336
00:29:26,110 --> 00:29:28,310
너무 많은 컴퓨터를 거치지 않는 것이 좋습니다. 그럴 때는
 

1337
00:29:28,310 --> 00:29:28,320

 

1338
00:29:28,320 --> 00:29:30,470

최단 경로를 원할 수도 있고,

1339
00:29:30,470 --> 00:29:30,480
최단 경로를 원할 수도 있고,
 

1340
00:29:30,480 --> 00:29:33,350
최단 경로를 원할 수도 있고,
Surface에서처럼 특정 지점에서 가장 가까운 지점으로 이동하고 싶을 수도 있습니다.  정보를

1341
00:29:33,350 --> 00:29:33,360
Surface에서처럼 특정 지점에서 가장 가까운 지점으로 이동하고 싶을 수도 있습니다.  정보를
 

1342
00:29:33,360 --> 00:29:35,230
Surface에서처럼 특정 지점에서 가장 가까운 지점으로 이동하고 싶을 수도 있습니다.  정보를
너무 멀리 이동시키지 않는 방식으로 정보를 전달하는 것이죠.

1343
00:29:35,230 --> 00:29:35,240
너무 멀리 이동시키지 않는 방식으로 정보를 전달하는 것이죠.
 

1344
00:29:35,240 --> 00:29:37,549
너무 멀리 이동시키지 않는 방식으로 정보를 전달하는 것이죠.
물론

1345
00:29:37,549 --> 00:29:39,310
물론
 

1346
00:29:39,310 --> 00:29:39,320

 

1347
00:29:39,320 --> 00:29:41,470

최단 경로 또는

1348
00:29:41,470 --> 00:29:41,480
최단 경로 또는
 

1349
00:29:41,480 --> 00:29:43,590
최단 경로 또는
경로의 존재 여부와 같은 다양한 변형이 존재합니다.

1350
00:29:43,590 --> 00:29:45,149
경로의 존재 여부와 같은 다양한 변형이 존재합니다.
 

1351
00:29:45,149 --> 00:29:45,159

 

1352
00:29:45,159 --> 00:29:47,549

그래프에서 해결할 수 있는 세 가지 유형의 모델 문제가 있습니다.

1353
00:29:47,549 --> 00:29:47,559
그래프에서 해결할 수 있는 세 가지 유형의 모델 문제가 있습니다.
 

1354
00:29:47,559 --> 00:29:50,029
그래프에서 해결할 수 있는 세 가지 유형의 모델 문제가 있습니다.
첫 번째는 이 과정에서 '

1355
00:29:50,029 --> 00:29:50,039
첫 번째는 이 과정에서 '
 

1356
00:29:50,039 --> 00:29:52,509
첫 번째는 이 과정에서 '
단일 쌍 도달 가능성'이라고 부르는 문제입니다. 그래프 G에서

1357
00:29:52,509 --> 00:29:52,519
단일 쌍 도달 가능성'이라고 부르는 문제입니다. 그래프 G에서
 

1358
00:29:52,519 --> 00:29:54,710
단일 쌍 도달 가능성'이라고 부르는 문제입니다. 그래프 G에서
두 정점 s와

1359
00:29:54,710 --> 00:29:54,720
두 정점 s와
 

1360
00:29:54,720 --> 00:29:58,750
두 정점 s와
t

1361
00:29:58,750 --> 00:29:58,760
t
 

1362
00:29:58,760 --> 00:30:00,909
t
사이에 경로가 존재하는지 묻는 것입니다. 이

1363
00:30:00,909 --> 00:30:03,269
사이에 경로가 존재하는지 묻는 것입니다. 이
 

1364
00:30:03,269 --> 00:30:03,279

 

1365
00:30:03,279 --> 00:30:06,389

그래프에서 이

1366
00:30:06,389 --> 00:30:06,399
그래프에서 이
 

1367
00:30:06,399 --> 00:30:08,149
그래프에서 이
문제가 항상 '예'라는 답을 반환하지 않는 극단적인 예는 무엇일까요?

1368
00:30:08,149 --> 00:30:09,710
문제가 항상 '예'라는 답을 반환하지 않는 극단적인 예는 무엇일까요?
 

1369
00:30:09,710 --> 00:30:09,720

 

1370
00:30:09,720 --> 00:30:11,470

우리는 모든 그래프가 연결되어 있다고 생각하지만,

1371
00:30:11,470 --> 00:30:14,310
우리는 모든 그래프가 연결되어 있다고 생각하지만,
 

1372
00:30:14,310 --> 00:30:14,320

 

1373
00:30:14,320 --> 00:30:15,909

우리가 정의한 대로 완벽하게 유효한 그래프는

1374
00:30:15,909 --> 00:30:15,919
우리가 정의한 대로 완벽하게 유효한 그래프는
 

1375
00:30:15,919 --> 00:30:17,630
우리가 정의한 대로 완벽하게 유효한 그래프는
정점이 10개이고 간선이 없는 그래프일 것입니다.

1376
00:30:17,630 --> 00:30:20,630
정점이 10개이고 간선이 없는 그래프일 것입니다.
 

1377
00:30:20,630 --> 00:30:20,640

 

1378
00:30:20,640 --> 00:30:21,870

만약 이러한 그래프만 고려한다면 이 함수는 매우 쉽게 코딩할 수 있을 것입니다.

1379
00:30:21,870 --> 00:30:21,880
만약 이러한 그래프만 고려한다면 이 함수는 매우 쉽게 코딩할 수 있을 것입니다.
 

1380
00:30:21,880 --> 00:30:24,310
만약 이러한 그래프만 고려한다면 이 함수는 매우 쉽게 코딩할 수 있을 것입니다.
하지만

1381
00:30:24,310 --> 00:30:24,320
하지만
 

1382
00:30:24,320 --> 00:30:26,669
하지만
어쨌든 경로의 존재 여부는

1383
00:30:26,669 --> 00:30:26,679
어쨌든 경로의 존재 여부는
 

1384
00:30:26,679 --> 00:30:28,029
어쨌든 경로의 존재 여부는
이미

1385
00:30:28,029 --> 00:30:28,039
이미
 

1386
00:30:28,039 --> 00:30:29,190
이미
알고리즘적 사고가 필요한 질문입니다.  아직

1387
00:30:29,190 --> 00:30:30,470
알고리즘적 사고가 필요한 질문입니다.  아직
 

1388
00:30:30,470 --> 00:30:30,480

 

1389
00:30:30,480 --> 00:30:32,149

그 방법을 알아내지는 못했지만, 지금 당장

1390
00:30:32,149 --> 00:30:32,159
그 방법을 알아내지는 못했지만, 지금 당장
 

1391
00:30:32,159 --> 00:30:34,310
그 방법을 알아내지는 못했지만, 지금 당장
해결할 수 있는 또 다른 문제는

1392
00:30:34,310 --> 00:30:34,320
해결할 수 있는 또 다른 문제는
 

1393
00:30:34,320 --> 00:30:36,230
해결할 수 있는 또 다른 문제는
최단 경로 찾기입니다. 그래프

1394
00:30:36,230 --> 00:30:36,240
최단 경로 찾기입니다. 그래프
 

1395
00:30:36,240 --> 00:30:38,430
최단 경로 찾기입니다. 그래프
와 두 정점이 주어졌을 때, 두 정점 사이의 거리는 얼마나 될까요?

1396
00:30:38,430 --> 00:30:40,990
와 두 정점이 주어졌을 때, 두 정점 사이의 거리는 얼마나 될까요?
 

1397
00:30:40,990 --> 00:30:41,000

 

1398
00:30:41,000 --> 00:30:42,750

만약 한 정점에서 다른 정점까지의 최단 거리를 구하고 싶다면, 두 번째

1399
00:30:42,750 --> 00:30:45,590
만약 한 정점에서 다른 정점까지의 최단 거리를 구하고 싶다면, 두 번째
 

1400
00:30:45,590 --> 00:30:45,600

 

1401
00:30:45,600 --> 00:30:47,190

문제를 이용해 첫 번째 문제를 해결할 수 있다는 것을 알 수 있습니다.

1402
00:30:47,190 --> 00:30:49,470
문제를 이용해 첫 번째 문제를 해결할 수 있다는 것을 알 수 있습니다.
 

1403
00:30:49,470 --> 00:30:50,789

 

1404
00:30:50,789 --> 00:30:50,799

 

1405
00:30:50,799 --> 00:30:53,230

두 정점 사이에 경로가 없을 때, 최단 경로의 길이는 얼마일까요?

1406
00:30:53,230 --> 00:30:54,710
두 정점 사이에 경로가 없을 때, 최단 경로의 길이는 얼마일까요?
 

1407
00:30:54,710 --> 00:30:54,720

 

1408
00:30:54,720 --> 00:30:57,629

무한대일까요? 아니면 어깨를 으쓱하며 "어깨를 으쓱" 하는 것도

1409
00:30:57,629 --> 00:30:57,639
무한대일까요? 아니면 어깨를 으쓱하며 "어깨를 으쓱" 하는 것도
 

1410
00:30:57,639 --> 00:31:00,269
무한대일까요? 아니면 어깨를 으쓱하며 "어깨를 으쓱" 하는 것도
충분히 타당한 답이죠. 네, 맞습니다. 그렇다면

1411
00:31:00,269 --> 00:31:02,149
충분히 타당한 답이죠. 네, 맞습니다. 그렇다면
 

1412
00:31:02,149 --> 00:31:02,159

 

1413
00:31:02,159 --> 00:31:04,710

도달 가능성 코드를 어떻게 구현할까요?

1414
00:31:04,710 --> 00:31:04,720
도달 가능성 코드를 어떻게 구현할까요?
 

1415
00:31:04,720 --> 00:31:06,149
도달 가능성 코드를 어떻게 구현할까요?
최단 경로 코드를 호출해서 무한대가 나오면

1416
00:31:06,149 --> 00:31:08,350
최단 경로 코드를 호출해서 무한대가 나오면
 

1417
00:31:08,350 --> 00:31:08,360

 

1418
00:31:08,360 --> 00:31:09,629

도달할 수 없다고 반환하고,

1419
00:31:09,629 --> 00:31:09,639
도달할 수 없다고 반환하고,
 

1420
00:31:09,639 --> 00:31:12,870
도달할 수 없다고 반환하고,
무한대가 아니면 도달 가능하다고 반환합니다.

1421
00:31:12,870 --> 00:31:12,880
무한대가 아니면 도달 가능하다고 반환합니다.
 

1422
00:31:12,880 --> 00:31:14,950
무한대가 아니면 도달 가능하다고 반환합니다.
알고리즘 수업에서 중요한 개념 중 하나는

1423
00:31:14,950 --> 00:31:14,960
알고리즘 수업에서 중요한 개념 중 하나는
 

1424
00:31:14,960 --> 00:31:16,590
알고리즘 수업에서 중요한 개념 중 하나는
환원(reduction)입니다.

1425
00:31:16,590 --> 00:31:16,600
환원(reduction)입니다.
 

1426
00:31:16,600 --> 00:31:18,990
환원(reduction)입니다.
하나의 함수를 이용해 다른 함수를 해결할 수 있다는 것이죠. 따라서

1427
00:31:18,990 --> 00:31:19,000
하나의 함수를 이용해 다른 함수를 해결할 수 있다는 것이죠. 따라서
 

1428
00:31:19,000 --> 00:31:20,909
하나의 함수를 이용해 다른 함수를 해결할 수 있다는 것이죠. 따라서
최단

1429
00:31:20,909 --> 00:31:20,919
최단
 

1430
00:31:20,919 --> 00:31:22,830
최단
경로 문제를 해결할 수 있다면, 그 코드를

1431
00:31:22,830 --> 00:31:22,840
경로 문제를 해결할 수 있다면, 그 코드를
 

1432
00:31:22,840 --> 00:31:24,509
경로 문제를 해결할 수 있다면, 그 코드를
호출해서 도달 가능성 문제도 해결할 수 있습니다.

1433
00:31:24,509 --> 00:31:25,629
호출해서 도달 가능성 문제도 해결할 수 있습니다.
 

1434
00:31:25,629 --> 00:31:25,639

 

1435
00:31:25,639 --> 00:31:28,509

마지막으로

1436
00:31:28,509 --> 00:31:28,519
마지막으로
 

1437
00:31:28,519 --> 00:31:30,789
마지막으로
단일 출발점 최단 경로에 대해 이야기해 보겠습니다.

1438
00:31:30,789 --> 00:31:32,669
단일 출발점 최단 경로에 대해 이야기해 보겠습니다.
 

1439
00:31:32,669 --> 00:31:32,679

 

1440
00:31:32,679 --> 00:31:34,110

여기 입력 노드는

1441
00:31:34,110 --> 00:31:34,120
여기 입력 노드는
 

1442
00:31:34,120 --> 00:31:36,830
여기 입력 노드는
s 하나뿐이니, 이 문제는

1443
00:31:36,830 --> 00:31:38,389
s 하나뿐이니, 이 문제는
 

1444
00:31:38,389 --> 00:31:38,399

 

1445
00:31:38,399 --> 00:31:41,710

s에서 그래프의 다른 모든 정점까지의 최단 경로 길이를 구하라는 것입니다. 즉,

1446
00:31:41,710 --> 00:31:43,950
s에서 그래프의 다른 모든 정점까지의 최단 경로 길이를 구하라는 것입니다. 즉,
 

1447
00:31:43,950 --> 00:31:43,960

 

1448
00:31:43,960 --> 00:31:45,389

모든 최단 거리 정보가 담긴 큰 배열을 반환하는 방식입니다. 그렇다면

1449
00:31:45,389 --> 00:31:45,399
모든 최단 거리 정보가 담긴 큰 배열을 반환하는 방식입니다. 그렇다면
 

1450
00:31:45,399 --> 00:31:48,669
모든 최단 거리 정보가 담긴 큰 배열을 반환하는 방식입니다. 그렇다면
단일

1451
00:31:48,669 --> 00:31:51,509
단일
 

1452
00:31:51,509 --> 00:31:51,519

 

1453
00:31:51,519 --> 00:31:53,190

출발점 최단 경로 문제를 사용하여 단일 쌍 최단 경로 문제를 풀 수 있을까요?

1454
00:31:53,190 --> 00:31:53,200
출발점 최단 경로 문제를 사용하여 단일 쌍 최단 경로 문제를 풀 수 있을까요?
 

1455
00:31:53,200 --> 00:31:55,190
출발점 최단 경로 문제를 사용하여 단일 쌍 최단 경로 문제를 풀 수 있을까요?

1456
00:31:55,190 --> 00:31:55,200

 

1457
00:31:55,200 --> 00:31:58,149

물론 가능합니다.

1458
00:31:58,149 --> 00:31:58,159
물론 가능합니다.
 

1459
00:31:58,159 --> 00:32:00,549
물론 가능합니다.
단일 쌍 최단 경로 문제에서 s를 가져와서

1460
00:32:00,549 --> 00:32:02,830
단일 쌍 최단 경로 문제에서 s를 가져와서
 

1461
00:32:02,830 --> 00:32:04,350

 

1462
00:32:04,350 --> 00:32:04,360

 

1463
00:32:04,360 --> 00:32:06,430

다른 모든 정점까지의 최단 경로를 계산한 다음, T

1464
00:32:06,430 --> 00:32:06,440
다른 모든 정점까지의 최단 경로를 계산한 다음, T
 

1465
00:32:06,440 --> 00:32:07,870
다른 모든 정점까지의 최단 경로를 계산한 다음, T
까지의 최단 경로만 남기고 나머지 정보는 모두 버릴 수 있습니다. 이제 문제가

1466
00:32:07,870 --> 00:32:10,269
까지의 최단 경로만 남기고 나머지 정보는 모두 버릴 수 있습니다. 이제 문제가
 

1467
00:32:10,269 --> 00:32:12,470

 

1468
00:32:12,470 --> 00:32:12,480

 

1469
00:32:12,480 --> 00:32:14,110

해결되었습니다. 이것이

1470
00:32:14,110 --> 00:32:14,120
해결되었습니다. 이것이
 

1471
00:32:14,120 --> 00:32:15,389
해결되었습니다. 이것이
두 번째 문제를 푸는 가장 빠른 방법이라는 것을 증명한 것은 아니지만, 적어도

1472
00:32:15,389 --> 00:32:15,399
두 번째 문제를 푸는 가장 빠른 방법이라는 것을 증명한 것은 아니지만, 적어도
 

1473
00:32:15,399 --> 00:32:17,789
두 번째 문제를 푸는 가장 빠른 방법이라는 것을 증명한 것은 아니지만, 적어도
세 번째 문제를 풀 수 있다면

1474
00:32:17,789 --> 00:32:17,799
세 번째 문제를 풀 수 있다면
 

1475
00:32:17,799 --> 00:32:20,269
세 번째 문제를 풀 수 있다면
두 번째 문제도 풀 수 있고,

1476
00:32:20,269 --> 00:32:20,279
두 번째 문제도 풀 수 있고,
 

1477
00:32:20,279 --> 00:32:21,870
두 번째 문제도 풀 수 있고,
두 번째 문제를 풀 수 있다면 첫 번째 문제도 풀 수 있다는 것을 보여줍니다.

1478
00:32:21,870 --> 00:32:21,880
두 번째 문제를 풀 수 있다면 첫 번째 문제도 풀 수 있다는 것을 보여줍니다.
 

1479
00:32:21,880 --> 00:32:23,909
두 번째 문제를 풀 수 있다면 첫 번째 문제도 풀 수 있다는 것을 보여줍니다.
오늘 강의에서는

1480
00:32:23,909 --> 00:32:23,919
오늘 강의에서는
 

1481
00:32:23,919 --> 00:32:26,190
오늘 강의에서는
세 번째 문제에 대해서만 다루겠습니다.

1482
00:32:26,190 --> 00:32:26,200
세 번째 문제에 대해서만 다루겠습니다.
 

1483
00:32:26,200 --> 00:32:27,190
세 번째 문제에 대해서만 다루겠습니다.
다시 말해, 이 문제들은 난이도 순으로

1484
00:32:27,190 --> 00:32:27,200
다시 말해, 이 문제들은 난이도 순으로
 

1485
00:32:27,200 --> 00:32:28,950
다시 말해, 이 문제들은 난이도 순으로
나열되어 있습니다.

1486
00:32:28,950 --> 00:32:28,960
나열되어 있습니다.
 

1487
00:32:28,960 --> 00:32:30,549
나열되어 있습니다.

1488
00:32:30,549 --> 00:32:32,710

 

1489
00:32:32,710 --> 00:32:32,720

 

1490
00:32:32,720 --> 00:32:34,549

단일 출발점 최단

1491
00:32:34,549 --> 00:32:34,559
단일 출발점 최단
 

1492
00:32:34,559 --> 00:32:35,629
단일 출발점 최단
경로 문제를 이해하기 위해

1493
00:32:35,629 --> 00:32:35,639
경로 문제를 이해하기 위해
 

1494
00:32:35,639 --> 00:32:37,830
경로 문제를 이해하기 위해
추가적인 구성을 하나 만들겠습니다. 이것은 하나의

1495
00:32:37,830 --> 00:32:37,840
추가적인 구성을 하나 만들겠습니다. 이것은 하나의
 

1496
00:32:37,840 --> 00:32:40,190
추가적인 구성을 하나 만들겠습니다. 이것은 하나의
아이디어입니다.  최단

1497
00:32:40,190 --> 00:32:40,200
아이디어입니다.  최단
 

1498
00:32:40,200 --> 00:32:42,350
아이디어입니다.  최단
경로 트리라고 부르죠. 아, 맞다.

1499
00:32:42,350 --> 00:32:42,360
경로 트리라고 부르죠. 아, 맞다.
 

1500
00:32:42,360 --> 00:32:44,470
경로 트리라고 부르죠. 아, 맞다.
어제 새벽 2시에 파워포인트 슬라이드 그리다가 귀찮아서 그냥

1501
00:32:44,470 --> 00:32:46,269
어제 새벽 2시에 파워포인트 슬라이드 그리다가 귀찮아서 그냥
 

1502
00:32:46,269 --> 00:32:46,279

 

1503
00:32:46,279 --> 00:32:47,230

칠판에 그림을 그리는 게 낫겠다 싶었어요. 자,

1504
00:32:47,230 --> 00:32:51,870
칠판에 그림을 그리는 게 낫겠다 싶었어요. 자,
 

1505
00:32:51,870 --> 00:32:51,880

 

1506
00:32:51,880 --> 00:32:56,430

그래프를 그려볼까요? 여기 A, B가 있습니다. 앞으로 노드를

1507
00:32:56,430 --> 00:32:56,440
그래프를 그려볼까요? 여기 A, B가 있습니다. 앞으로 노드를
 

1508
00:32:56,440 --> 00:32:58,389
그래프를 그려볼까요? 여기 A, B가 있습니다. 앞으로 노드를
나타낼 때 숫자 대신 문자를 사용할게요.

1509
00:32:58,389 --> 00:33:01,070
나타낼 때 숫자 대신 문자를 사용할게요.
 

1510
00:33:01,070 --> 00:33:02,430

 

1511
00:33:02,430 --> 00:33:02,440

 

1512
00:33:02,440 --> 00:33:05,190

최단 경로의 길이와 노드의 인덱스를 헷갈리지 않도록 하기 위해서요.

1513
00:33:05,190 --> 00:33:05,200
최단 경로의 길이와 노드의 인덱스를 헷갈리지 않도록 하기 위해서요.
 

1514
00:33:05,200 --> 00:33:08,629
최단 경로의 길이와 노드의 인덱스를 헷갈리지 않도록 하기 위해서요.
여기 A, B, C가 있습니다. 필기

1515
00:33:08,629 --> 00:33:08,639
여기 A, B, C가 있습니다. 필기
 

1516
00:33:08,639 --> 00:33:11,710
여기 A, B, C가 있습니다. 필기
내용과 맞춰볼게요. 여기

1517
00:33:11,710 --> 00:33:11,720
내용과 맞춰볼게요. 여기
 

1518
00:33:11,720 --> 00:33:13,590
내용과 맞춰볼게요. 여기
D, E, F도 있습니다. 이것도

1519
00:33:13,590 --> 00:33:13,600
D, E, F도 있습니다. 이것도
 

1520
00:33:13,600 --> 00:33:16,190
D, E, F도 있습니다. 이것도

1521
00:33:16,190 --> 00:33:18,389

 

1522
00:33:18,389 --> 00:33:18,399

 

1523
00:33:18,399 --> 00:33:20,509

무방향 그래프입니다. 교수님이

1524
00:33:20,509 --> 00:33:21,509
무방향 그래프입니다. 교수님이
 

1525
00:33:21,509 --> 00:33:21,519

 

1526
00:33:21,519 --> 00:33:22,950

무방향 그래프를 좋아하시니까요. 나중에 이렇게 하면

1527
00:33:22,950 --> 00:33:22,960
무방향 그래프를 좋아하시니까요. 나중에 이렇게 하면
 

1528
00:33:22,960 --> 00:33:24,070
무방향 그래프를 좋아하시니까요. 나중에 이렇게 하면
안 됐다는 피드백을 받을 거라는 걸 알지만요. 어쨌든,

1529
00:33:24,070 --> 00:33:27,149
안 됐다는 피드백을 받을 거라는 걸 알지만요. 어쨌든,
 

1530
00:33:27,149 --> 00:33:28,230

 

1531
00:33:28,230 --> 00:33:28,240

 

1532
00:33:28,240 --> 00:33:29,990

A에서 다른 모든 노드까지의 최단 경로,

1533
00:33:29,990 --> 00:33:30,000
A에서 다른 모든 노드까지의 최단 경로,
 

1534
00:33:30,000 --> 00:33:32,310
A에서 다른 모든 노드까지의 최단 경로,
또는 그 길이를 계산하고 싶다고 가정해 봅시다. 우선

1535
00:33:32,310 --> 00:33:32,320
또는 그 길이를 계산하고 싶다고 가정해 봅시다. 우선
 

1536
00:33:32,320 --> 00:33:33,750
또는 그 길이를 계산하고 싶다고 가정해 봅시다. 우선
알고리즘에 대해 이야기하지 않더라도

1537
00:33:33,750 --> 00:33:33,760
알고리즘에 대해 이야기하지 않더라도
 

1538
00:33:33,760 --> 00:33:35,070
알고리즘에 대해 이야기하지 않더라도
쉽게 짐작할 수 있겠죠? A에서

1539
00:33:35,070 --> 00:33:36,830
쉽게 짐작할 수 있겠죠? A에서
 

1540
00:33:36,830 --> 00:33:36,840

 

1541
00:33:36,840 --> 00:33:39,590

B까지의 최단 경로는 길이가 0이고, A에서

1542
00:33:39,590 --> 00:33:39,600
B까지의 최단 경로는 길이가 0이고, A에서
 

1543
00:33:39,600 --> 00:33:41,710
B까지의 최단 경로는 길이가 0이고, A에서
B까지의 최단 경로는 1입니다.  c까지 가는 데

1544
00:33:41,710 --> 00:33:41,720
B까지의 최단 경로는 1입니다.  c까지 가는 데
 

1545
00:33:41,720 --> 00:33:43,230
B까지의 최단 경로는 1입니다.  c까지 가는 데
2가 맞죠?

1546
00:33:43,230 --> 00:33:43,240
2가 맞죠?
 

1547
00:33:43,240 --> 00:33:46,350
2가 맞죠?
이제 이 사람들을 따라갈 수 있으니까요. 하지만 복잡해지죠. 분기가 많잖아요.

1548
00:33:46,350 --> 00:33:46,360
이제 이 사람들을 따라갈 수 있으니까요. 하지만 복잡해지죠. 분기가 많잖아요.
 

1549
00:33:46,360 --> 00:33:48,950
이제 이 사람들을 따라갈 수 있으니까요. 하지만 복잡해지죠. 분기가 많잖아요.
그래서 다음 최단 경로는

1550
00:33:48,950 --> 00:33:48,960
그래서 다음 최단 경로는
 

1551
00:33:48,960 --> 00:33:52,870
그래서 다음 최단 경로는
길이가 3이고, 그다음은 4인 식이죠.

1552
00:33:52,870 --> 00:33:54,110
길이가 3이고, 그다음은 4인 식이죠.
 

1553
00:33:54,110 --> 00:33:54,120

 

1554
00:33:54,120 --> 00:33:55,669

제가 여기에 표시한 숫자들이

1555
00:33:55,669 --> 00:33:55,679
제가 여기에 표시한 숫자들이
 

1556
00:33:55,679 --> 00:33:57,950
제가 여기에 표시한 숫자들이
a에서 다른 모든 정점까지의 최단 경로 길이라는 데 모두 동의하시나요?

1557
00:33:57,950 --> 00:33:57,960
a에서 다른 모든 정점까지의 최단 경로 길이라는 데 모두 동의하시나요?
 

1558
00:33:57,960 --> 00:34:00,509
a에서 다른 모든 정점까지의 최단 경로 길이라는 데 모두 동의하시나요?

1559
00:34:00,509 --> 00:34:00,519

 

1560
00:34:00,519 --> 00:34:02,909

그런데 제가 아직 설명하지 않은 게 있죠.

1561
00:34:02,909 --> 00:34:05,509
그런데 제가 아직 설명하지 않은 게 있죠.
 

1562
00:34:05,509 --> 00:34:05,519

 

1563
00:34:05,519 --> 00:34:07,070

경로를 실제로 계산하는 방법은 알려주지 않고, 그냥 경로 길이만 알려줬잖아요. 그래서 저는

1564
00:34:07,070 --> 00:34:08,430
경로를 실제로 계산하는 방법은 알려주지 않고, 그냥 경로 길이만 알려줬잖아요. 그래서 저는
 

1565
00:34:08,430 --> 00:34:11,149

 

1566
00:34:11,149 --> 00:34:11,159

 

1567
00:34:11,159 --> 00:34:12,950

단일

1568
00:34:12,950 --> 00:34:12,960
단일
 

1569
00:34:12,960 --> 00:34:16,230
단일
출발점 최단 경로 길이뿐만 아니라

1570
00:34:16,230 --> 00:34:16,240
출발점 최단 경로 길이뿐만 아니라
 

1571
00:34:16,240 --> 00:34:18,270
출발점 최단 경로 길이뿐만 아니라
단일 출발점

1572
00:34:18,270 --> 00:34:18,280
단일 출발점
 

1573
00:34:18,280 --> 00:34:21,109
단일 출발점
최단 경로도 알려주는 코드가 필요할 수도 있어요. 처음에는

1574
00:34:21,109 --> 00:34:22,510
최단 경로도 알려주는 코드가 필요할 수도 있어요. 처음에는
 

1575
00:34:22,510 --> 00:34:25,030

 

1576
00:34:25,030 --> 00:34:25,040

 

1577
00:34:25,040 --> 00:34:27,990

모든 경로를 저장할 수 있는 데이터 구조를 어떻게 만들어야 할지 고민하게 되죠.

1578
00:34:27,990 --> 00:34:28,000
모든 경로를 저장할 수 있는 데이터 구조를 어떻게 만들어야 할지 고민하게 되죠.
 

1579
00:34:28,000 --> 00:34:29,950
모든 경로를 저장할 수 있는 데이터 구조를 어떻게 만들어야 할지 고민하게 되죠.
각 경로에는 V개의

1580
00:34:29,950 --> 00:34:29,960
각 경로에는 V개의
 

1581
00:34:29,960 --> 00:34:31,430
각 경로에는 V개의
정점이 있을 수도 있고,

1582
00:34:31,430 --> 00:34:31,440
정점이 있을 수도 있고,
 

1583
00:34:31,440 --> 00:34:33,470
정점이 있을 수도 있고,
어떤 이유로든

1584
00:34:33,470 --> 00:34:33,480
어떤 이유로든
 

1585
00:34:33,480 --> 00:34:34,829
어떤 이유로든
그래프에 분기가 많아서 모든

1586
00:34:34,829 --> 00:34:34,839
그래프에 분기가 많아서 모든
 

1587
00:34:34,839 --> 00:34:37,109
그래프에 분기가 많아서 모든
경로가 엄청 길 수도 있잖아요. 분기 때문에 경로가

1588
00:34:37,109 --> 00:34:38,550
경로가 엄청 길 수도 있잖아요. 분기 때문에 경로가
 

1589
00:34:38,550 --> 00:34:38,560

 

1590
00:34:38,560 --> 00:34:39,829

길어질지

1591
00:34:39,829 --> 00:34:39,839
길어질지
 

1592
00:34:39,839 --> 00:34:41,909
길어질지
짧아질지도 생각해 봐야겠죠. 어쨌든, 모든

1593
00:34:41,909 --> 00:34:43,990
짧아질지도 생각해 봐야겠죠. 어쨌든, 모든
 

1594
00:34:43,990 --> 00:34:45,310

 

1595
00:34:45,310 --> 00:34:45,320

 

1596
00:34:45,320 --> 00:34:47,829

정점에 대해 a에서 다른 모든 정점까지의 최단 경로를 추적하는 아주 단순한 데이터 구조를 만들 수도 있을 거예요.

1597
00:34:47,829 --> 00:34:47,839
정점에 대해 a에서 다른 모든 정점까지의 최단 경로를 추적하는 아주 단순한 데이터 구조를 만들 수도 있을 거예요.
 

1598
00:34:47,839 --> 00:34:50,589
정점에 대해 a에서 다른 모든 정점까지의 최단 경로를 추적하는 아주 단순한 데이터 구조를 만들 수도 있을 거예요.
그

1599
00:34:50,589 --> 00:34:50,599
그
 

1600
00:34:50,599 --> 00:34:53,230
그
정점까지의 데이터 구조는 얼마나 클까요?

1601
00:34:53,230 --> 00:34:55,790
정점까지의 데이터 구조는 얼마나 클까요?
 

1602
00:34:55,790 --> 00:34:55,800

 

1603
00:34:55,800 --> 00:34:58,150

경로 길이에 대한 유일한 제약 조건이

1604
00:34:58,150 --> 00:34:58,160
경로 길이에 대한 유일한 제약 조건이
 

1605
00:34:58,160 --> 00:34:59,950
경로 길이에 대한 유일한 제약 조건이
대부분의 경우

1606
00:34:59,950 --> 00:34:59,960
대부분의 경우
 

1607
00:34:59,960 --> 00:35:02,510
대부분의 경우
그래프의 모든 정점을 거쳐야 한다는 것이라면, 하나의

1608
00:35:02,510 --> 00:35:02,520
그래프의 모든 정점을 거쳐야 한다는 것이라면, 하나의
 

1609
00:35:02,520 --> 00:35:04,950
그래프의 모든 정점을 거쳐야 한다는 것이라면, 하나의
경로는 V 공간을 차지하게 되므로 총

1610
00:35:04,950 --> 00:35:04,960
경로는 V 공간을 차지하게 되므로 총
 

1611
00:35:04,960 --> 00:35:06,710
경로는 V 공간을 차지하게 되므로 총
V^s 공간이 필요하게 됩니다. 이는 효율적이지 않죠.

1612
00:35:06,710 --> 00:35:08,910
V^s 공간이 필요하게 됩니다. 이는 효율적이지 않죠.
 

1613
00:35:08,910 --> 00:35:08,920

 

1614
00:35:08,920 --> 00:35:10,470

왜냐하면

1615
00:35:10,470 --> 00:35:10,480
왜냐하면
 

1616
00:35:10,480 --> 00:35:11,870
왜냐하면
현재 그래프에 있는 정보의 양은

1617
00:35:11,870 --> 00:35:11,880
현재 그래프에 있는 정보의 양은
 

1618
00:35:11,880 --> 00:35:13,270
현재 그래프에 있는 정보의 양은
선형적이기 때문입니다. 즉, 경로의 길이만 있으면 됩니다.

1619
00:35:13,270 --> 00:35:15,310
선형적이기 때문입니다. 즉, 경로의 길이만 있으면 됩니다.
 

1620
00:35:15,310 --> 00:35:15,320

 

1621
00:35:15,320 --> 00:35:16,870

처음에 그 경로를 재구성하려면 훨씬

1622
00:35:16,870 --> 00:35:16,880
처음에 그 경로를 재구성하려면 훨씬
 

1623
00:35:16,880 --> 00:35:18,790
처음에 그 경로를 재구성하려면 훨씬
더 많은 공간이 필요할 것 같은 느낌이 들지만,

1624
00:35:18,790 --> 00:35:20,790
더 많은 공간이 필요할 것 같은 느낌이 들지만,
 

1625
00:35:20,790 --> 00:35:20,800

 

1626
00:35:20,800 --> 00:35:22,230

실제로는

1627
00:35:22,230 --> 00:35:22,240
실제로는
 

1628
00:35:22,240 --> 00:35:23,990
실제로는
선형적인 공간만 필요합니다.

1629
00:35:23,990 --> 00:35:24,000
선형적인 공간만 필요합니다.
 

1630
00:35:24,000 --> 00:35:25,589
선형적인 공간만 필요합니다.
이를 위해 최단 경로 트리라는 객체를 저장하는 것이 아이디어입니다.

1631
00:35:25,589 --> 00:35:28,740
이를 위해 최단 경로 트리라는 객체를 저장하는 것이 아이디어입니다.
 

1632
00:35:28,740 --> 00:35:28,750

 

1633
00:35:28,750 --> 00:35:34,670

[음악]

1634
00:35:34,670 --> 00:35:34,680

 

1635
00:35:34,680 --> 00:35:36,030

질문은 재귀에 관한 것이었는데, 아직

1636
00:35:36,030 --> 00:35:36,040
질문은 재귀에 관한 것이었는데, 아직
 

1637
00:35:36,040 --> 00:35:37,310
질문은 재귀에 관한 것이었는데, 아직
그래프 알고리즘을 작성하지 않았으므로 재귀를 실제로 구현할 때까지 미루겠습니다. 그때

1638
00:35:37,310 --> 00:35:38,870
그래프 알고리즘을 작성하지 않았으므로 재귀를 실제로 구현할 때까지 미루겠습니다. 그때
 

1639
00:35:38,870 --> 00:35:41,150

 

1640
00:35:41,150 --> 00:35:41,160

 

1641
00:35:41,160 --> 00:35:42,230

더

1642
00:35:42,230 --> 00:35:42,240
더
 

1643
00:35:42,240 --> 00:35:44,589
더
자세히 생각해 보겠습니다. 하지만 매우

1644
00:35:44,589 --> 00:35:44,599
자세히 생각해 보겠습니다. 하지만 매우
 

1645
00:35:44,599 --> 00:35:45,790
자세히 생각해 보겠습니다. 하지만 매우
타당한 질문입니다.

1646
00:35:45,790 --> 00:35:45,800
타당한 질문입니다.
 

1647
00:35:45,800 --> 00:35:47,910
타당한 질문입니다.
재귀적인 그래프 알고리즘은 많이 있습니다.

1648
00:35:47,910 --> 00:35:47,920
재귀적인 그래프 알고리즘은 많이 있습니다.
 

1649
00:35:47,920 --> 00:35:49,950
재귀적인 그래프 알고리즘은 많이 있습니다.
그리고 나서 우리는...  우리

1650
00:35:49,950 --> 00:35:49,960
그리고 나서 우리는...  우리
 

1651
00:35:49,960 --> 00:35:53,630
그리고 나서 우리는...  우리
회계는 확실히 아주 꼼꼼하게 관리하죠.

1652
00:35:53,630 --> 00:35:53,640

 

1653
00:35:53,640 --> 00:35:57,030

그래서, 대신

1654
00:35:57,030 --> 00:35:57,040
그래서, 대신
 

1655
00:35:57,040 --> 00:35:58,430
그래서, 대신
최단 경로 트리라는 객체를 정의해 보겠습니다.

1656
00:35:58,430 --> 00:35:58,440
최단 경로 트리라는 객체를 정의해 보겠습니다.
 

1657
00:35:58,440 --> 00:36:01,309
최단 경로 트리라는 객체를 정의해 보겠습니다.
여기서 기본적인 요령은

1658
00:36:01,309 --> 00:36:01,319
여기서 기본적인 요령은
 

1659
00:36:01,319 --> 00:36:03,710
여기서 기본적인 요령은
A에서 C로 어떻게 가는지 묻는 것입니다.

1660
00:36:03,710 --> 00:36:06,990
A에서 C로 어떻게 가는지 묻는 것입니다.
 

1661
00:36:06,990 --> 00:36:07,000

 

1662
00:36:07,000 --> 00:36:07,950


1663
00:36:07,950 --> 00:36:07,960

 

1664
00:36:07,960 --> 00:36:10,270

최단 경로에는 항상 이전 정점인 A-C 정점이 있습니다. 최단 경로는

1665
00:36:10,270 --> 00:36:10,280
최단 경로에는 항상 이전 정점인 A-C 정점이 있습니다. 최단 경로는
 

1666
00:36:10,280 --> 00:36:11,390
최단 경로에는 항상 이전 정점인 A-C 정점이 있습니다. 최단 경로는
아주

1667
00:36:11,390 --> 00:36:11,400
아주
 

1668
00:36:11,400 --> 00:36:13,230
아주
멋진 속성을 가지고 있는데, 바로

1669
00:36:13,230 --> 00:36:13,240
멋진 속성을 가지고 있는데, 바로
 

1670
00:36:13,240 --> 00:36:15,390
멋진 속성을 가지고 있는데, 바로
A에서 C로 가는 최단 경로를

1671
00:36:15,390 --> 00:36:15,400
A에서 C로 가는 최단 경로를
 

1672
00:36:15,400 --> 00:36:18,190
A에서 C로 가는 최단 경로를
잘라내도 이전 정점으로 가는 최단 경로가 된다는 것입니다. 예를 들어 A에서 B를 거쳐

1673
00:36:18,190 --> 00:36:18,200
잘라내도 이전 정점으로 가는 최단 경로가 된다는 것입니다. 예를 들어 A에서 B를 거쳐
 

1674
00:36:18,200 --> 00:36:19,109
잘라내도 이전 정점으로 가는 최단 경로가 된다는 것입니다. 예를 들어 A에서 B를 거쳐

1675
00:36:19,109 --> 00:36:19,119

 

1676
00:36:19,119 --> 00:36:22,470

C로 간다면, 잘라낸 경로도

1677
00:36:22,470 --> 00:36:22,480
C로 간다면, 잘라낸 경로도
 

1678
00:36:22,480 --> 00:36:24,710
C로 간다면, 잘라낸 경로도
이전 정점으로 가는 최단 경로가 됩니다. 자, 이 부분을

1679
00:36:24,710 --> 00:36:24,720
이전 정점으로 가는 최단 경로가 됩니다. 자, 이 부분을
 

1680
00:36:24,720 --> 00:36:25,829
이전 정점으로 가는 최단 경로가 됩니다. 자, 이 부분을
좀 더 생각해 보겠습니다. 방금 설명은

1681
00:36:25,829 --> 00:36:27,230
좀 더 생각해 보겠습니다. 방금 설명은
 

1682
00:36:27,230 --> 00:36:27,240

 

1683
00:36:27,240 --> 00:36:29,790

강사님이 늘 그렇듯 좀

1684
00:36:29,790 --> 00:36:31,870
강사님이 늘 그렇듯 좀
 

1685
00:36:31,870 --> 00:36:33,870

 

1686
00:36:33,870 --> 00:36:33,880

 

1687
00:36:33,880 --> 00:36:37,790

서툴게 하셨으니, A에서 D로 가는 최단 경로가 A-B-C-

1688
00:36:37,790 --> 00:36:37,800
서툴게 하셨으니, A에서 D로 가는 최단 경로가 A-B-C-
 

1689
00:36:37,800 --> 00:36:41,270
서툴게 하셨으니, A에서 D로 가는 최단 경로가 A-B-C-
D라고 가정해 보겠습니다. 모두 동의하시겠죠? 이제

1690
00:36:41,270 --> 00:36:41,280
D라고 가정해 보겠습니다. 모두 동의하시겠죠? 이제
 

1691
00:36:41,280 --> 00:36:43,150
D라고 가정해 보겠습니다. 모두 동의하시겠죠? 이제
이 하위 목록에서

1692
00:36:43,150 --> 00:36:43,160
이 하위 목록에서
 

1693
00:36:43,160 --> 00:36:44,309
이 하위 목록에서
A에서

1694
00:36:44,309 --> 00:36:44,319
A에서
 

1695
00:36:44,319 --> 00:36:47,230
A에서
C까지를 살펴보겠습니다. 이

1696
00:36:47,230 --> 00:36:47,240
C까지를 살펴보겠습니다. 이
 

1697
00:36:47,240 --> 00:36:49,390
C까지를 살펴보겠습니다. 이
경로가 최단 경로가 아닌 경우가 있을까요?

1698
00:36:49,390 --> 00:36:52,349
경로가 최단 경로가 아닌 경우가 있을까요?
 

1699
00:36:52,349 --> 00:36:52,359

 

1700
00:36:52,359 --> 00:36:55,390

없죠. 만약

1701
00:36:55,390 --> 00:36:55,400
없죠. 만약
 

1702
00:36:55,400 --> 00:36:57,829
없죠. 만약
A에서 C로 가는 더 짧은 경로가 있다면,

1703
00:36:57,829 --> 00:36:57,839
A에서 C로 가는 더 짧은 경로가 있다면,
 

1704
00:36:57,839 --> 00:37:00,309
A에서 C로 가는 더 짧은 경로가 있다면,
여기에 끼워 넣어서 찾을 수 있을 테니까요.

1705
00:37:00,309 --> 00:37:00,319
여기에 끼워 넣어서 찾을 수 있을 테니까요.
 

1706
00:37:00,319 --> 00:37:02,069
여기에 끼워 넣어서 찾을 수 있을 테니까요.
A에서 D까지의 최단 경로를 보면 알 수 있듯이,

1707
00:37:02,069 --> 00:37:02,079
A에서 D까지의 최단 경로를 보면 알 수 있듯이,
 

1708
00:37:02,079 --> 00:37:05,670
A에서 D까지의 최단 경로를 보면 알 수 있듯이,
이러한

1709
00:37:05,670 --> 00:37:05,680
이러한
 

1710
00:37:05,680 --> 00:37:07,950
이러한
논리에 따라 최단 경로의 거대한 집합을 저장하는 대신, 일종의

1711
00:37:07,950 --> 00:37:10,430
논리에 따라 최단 경로의 거대한 집합을 저장하는 대신, 일종의
 

1712
00:37:10,430 --> 00:37:11,710

 

1713
00:37:11,710 --> 00:37:11,720

 

1714
00:37:11,720 --> 00:37:14,790

재귀적 방식을 적용하여

1715
00:37:14,790 --> 00:37:17,790
재귀적 방식을 적용하여
 

1716
00:37:17,790 --> 00:37:17,800

 

1717
00:37:17,800 --> 00:37:20,030

최단 경로에서 내 앞에 있는 정점 하나만 생각하면 됩니다.

1718
00:37:20,030 --> 00:37:21,750
최단 경로에서 내 앞에 있는 정점 하나만 생각하면 됩니다.
 

1719
00:37:21,750 --> 00:37:21,760

 

1720
00:37:21,760 --> 00:37:24,870

그래프를 살펴보면, 추적해야 할 핵심

1721
00:37:24,870 --> 00:37:24,880

 

1722
00:37:24,880 --> 00:37:27,230

요소는 선행 정점입니다. 최단 경로에서 F

1723
00:37:27,230 --> 00:37:28,829
요소는 선행 정점입니다. 최단 경로에서 F
 

1724
00:37:28,829 --> 00:37:30,990

 

1725
00:37:30,990 --> 00:37:31,000

 

1726
00:37:31,000 --> 00:37:33,550

의 선행 정점은 무엇일까요?

1727
00:37:33,550 --> 00:37:33,560
의 선행 정점은 무엇일까요?
 

1728
00:37:33,560 --> 00:37:35,230
의 선행 정점은 무엇일까요?
D 또는

1729
00:37:35,230 --> 00:37:35,240
D 또는
 

1730
00:37:35,240 --> 00:37:37,309
D 또는
E일 수 있는데, 이 경우에는 상관없습니다.

1731
00:37:37,309 --> 00:37:37,319
E일 수 있는데, 이 경우에는 상관없습니다.
 

1732
00:37:37,319 --> 00:37:41,670
E일 수 있는데, 이 경우에는 상관없습니다.
재미삼아 선행 정점을 E라고 해 봅시다. 그렇다면 E의 선행 정점은 무엇일까요? 최단 경로

1733
00:37:41,670 --> 00:37:44,150
재미삼아 선행 정점을 E라고 해 봅시다. 그렇다면 E의 선행 정점은 무엇일까요? 최단 경로
 

1734
00:37:44,150 --> 00:37:44,160

 

1735
00:37:44,160 --> 00:37:46,430

에서 가장 이전 정점 또는 간선은

1736
00:37:46,430 --> 00:37:48,270
에서 가장 이전 정점 또는 간선은
 

1737
00:37:48,270 --> 00:37:48,280

 

1738
00:37:48,280 --> 00:37:53,109

C입니다. D도 마찬가지입니다. 이제 A와 B를 보면, 여러 개의

1739
00:37:53,109 --> 00:37:53,119
C입니다. D도 마찬가지입니다. 이제 A와 B를 보면, 여러 개의
 

1740
00:37:53,119 --> 00:37:55,390
C입니다. D도 마찬가지입니다. 이제 A와 B를 보면, 여러 개의
화살표가 이 방향을 가리키고 있습니다.

1741
00:37:55,390 --> 00:37:55,400
화살표가 이 방향을 가리키고 있습니다.
 

1742
00:37:55,400 --> 00:37:57,910
화살표가 이 방향을 가리키고 있습니다.
따라서 각 정점에 대해

1743
00:37:57,910 --> 00:37:59,510
따라서 각 정점에 대해
 

1744
00:37:59,510 --> 00:37:59,520

 

1745
00:37:59,520 --> 00:38:01,270

최단 경로에서 이전 정점을 가리키는 화살표를 표시하면 됩니다.

1746
00:38:01,270 --> 00:38:01,280
최단 경로에서 이전 정점을 가리키는 화살표를 표시하면 됩니다.
 

1747
00:38:01,280 --> 00:38:02,589
최단 경로에서 이전 정점을 가리키는 화살표를 표시하면 됩니다.
전체 최단 경로를 저장하는 것이 아니라, 가장

1748
00:38:02,589 --> 00:38:02,599
전체 최단 경로를 저장하는 것이 아니라, 가장
 

1749
00:38:02,599 --> 00:38:05,270
전체 최단 경로를 저장하는 것이 아니라, 가장
마지막

1750
00:38:05,270 --> 00:38:05,280
마지막
 

1751
00:38:05,280 --> 00:38:07,430
마지막
정점의 간선만 저장하는 것입니다. 그렇다면 이 방식은 얼마나 많은 저장 공간을 차지할까요?

1752
00:38:07,430 --> 00:38:09,309
정점의 간선만 저장하는 것입니다. 그렇다면 이 방식은 얼마나 많은 저장 공간을 차지할까요?
 

1753
00:38:09,309 --> 00:38:09,319

 

1754
00:38:09,319 --> 00:38:12,390

V Space라고 표시되어 있죠. 즉,

1755
00:38:12,390 --> 00:38:12,400
V Space라고 표시되어 있죠. 즉,
 

1756
00:38:12,400 --> 00:38:14,550
V Space라고 표시되어 있죠. 즉,
크기가 얼마나 될까요?  정점 공간은

1757
00:38:14,550 --> 00:38:14,560
크기가 얼마나 될까요?  정점 공간은
 

1758
00:38:14,560 --> 00:38:16,390
크기가 얼마나 될까요?  정점 공간은
각 정점이 최단 경로

1759
00:38:16,390 --> 00:38:16,400
각 정점이 최단 경로
 

1760
00:38:16,400 --> 00:38:17,710
각 정점이 최단 경로
상의 이전 정점 하나만 저장하면 되기 때문에 매우 간단합니다. 자,

1761
00:38:17,710 --> 00:38:21,230
상의 이전 정점 하나만 저장하면 되기 때문에 매우 간단합니다. 자,
 

1762
00:38:21,230 --> 00:38:21,240

 

1763
00:38:21,240 --> 00:38:22,790

최단 경로를 추적하는 제 알고리즘은 무엇일까요?

1764
00:38:22,790 --> 00:38:22,800
최단 경로를 추적하는 제 알고리즘은 무엇일까요?
 

1765
00:38:22,800 --> 00:38:24,190
최단 경로를 추적하는 제 알고리즘은 무엇일까요?
아주 간단하죠.

1766
00:38:24,190 --> 00:38:24,200
아주 간단하죠.
 

1767
00:38:24,200 --> 00:38:26,270
아주 간단하죠.
이 간선을 따라 계속 이동하다가 다시 시작 정점으로 돌아오면 됩니다.

1768
00:38:26,270 --> 00:38:29,230
이 간선을 따라 계속 이동하다가 다시 시작 정점으로 돌아오면 됩니다.
 

1769
00:38:29,230 --> 00:38:29,240

 

1770
00:38:29,240 --> 00:38:30,630

이 객체를 최단

1771
00:38:30,630 --> 00:38:30,640
이 객체를 최단
 

1772
00:38:30,640 --> 00:38:32,349
이 객체를 최단
경로 트리라고 합니다. '트리'라는 단어를 하나 더 넣은 것을 눈치채셨나요?

1773
00:38:32,349 --> 00:38:34,109
경로 트리라고 합니다. '트리'라는 단어를 하나 더 넣은 것을 눈치채셨나요?
 

1774
00:38:34,109 --> 00:38:34,119

 

1775
00:38:34,119 --> 00:38:36,470

왜 그랬을까요?

1776
00:38:36,470 --> 00:38:36,480
왜 그랬을까요?
 

1777
00:38:36,480 --> 00:38:38,150
왜 그랬을까요?
이 그래프에 사이클이 있을 수 있을까요? 말이 안 되죠.

1778
00:38:38,150 --> 00:38:40,109
이 그래프에 사이클이 있을 수 있을까요? 말이 안 되죠.
 

1779
00:38:40,109 --> 00:38:40,119

 

1780
00:38:40,119 --> 00:38:41,390

최단 경로는

1781
00:38:41,390 --> 00:38:42,470
최단 경로는
 

1782
00:38:42,470 --> 00:38:42,480

 

1783
00:38:42,480 --> 00:38:45,670

기울기를 따라 원래 정점으로 되돌아갈 수 있어야 합니다.

1784
00:38:45,670 --> 00:38:45,680
기울기를 따라 원래 정점으로 되돌아갈 수 있어야 합니다.
 

1785
00:38:45,680 --> 00:38:48,349
기울기를 따라 원래 정점으로 되돌아갈 수 있어야 합니다.
다시 말해,

1786
00:38:48,349 --> 00:38:48,359
다시 말해,
 

1787
00:38:48,359 --> 00:38:51,550
다시 말해,
그래프에

1788
00:38:51,550 --> 00:38:52,990
그래프에
 

1789
00:38:52,990 --> 00:38:53,000

 

1790
00:38:53,000 --> 00:38:56,109

P(V)라는 정보를 추가할 겁니다. 이것은

1791
00:38:56,109 --> 00:38:56,119
P(V)라는 정보를 추가할 겁니다. 이것은
 

1792
00:38:56,119 --> 00:38:58,109
P(V)라는 정보를 추가할 겁니다. 이것은
시작점에서

1793
00:38:58,109 --> 00:38:58,119
시작점에서
 

1794
00:38:58,119 --> 00:38:59,710
시작점에서
정점

1795
00:38:59,710 --> 00:38:59,720
정점
 

1796
00:38:59,720 --> 00:39:02,230
정점
V까지의 최단 경로상의 이전 정점입니다. 제가

1797
00:39:02,230 --> 00:39:02,240
V까지의 최단 경로상의 이전 정점입니다. 제가
 

1798
00:39:02,240 --> 00:39:03,630
V까지의 최단 경로상의 이전 정점입니다. 제가
오늘 여러분께 주장하려고 했던 것은

1799
00:39:03,630 --> 00:39:03,640
오늘 여러분께 주장하려고 했던 것은
 

1800
00:39:03,640 --> 00:39:04,870
오늘 여러분께 주장하려고 했던 것은
이 정보만 있으면

1801
00:39:04,870 --> 00:39:04,880
이 정보만 있으면
 

1802
00:39:04,880 --> 00:39:06,670
이 정보만 있으면
최단 경로를 재구성하기에 충분하다는 것입니다.

1803
00:39:06,670 --> 00:39:06,680
최단 경로를 재구성하기에 충분하다는 것입니다.
 

1804
00:39:06,680 --> 00:39:09,230
최단 경로를 재구성하기에 충분하다는 것입니다.
P(V)를 계속 추가하고, 그다음 P(V)를 추가하고,

1805
00:39:09,230 --> 00:39:09,240
P(V)를 계속 추가하고, 그다음 P(V)를 추가하고,
 

1806
00:39:09,240 --> 00:39:11,069
P(V)를 계속 추가하고, 그다음 P(V)를 추가하고,
또 그다음 P(V)를 추가하는 식으로 계속하면 됩니다. 좀

1807
00:39:11,069 --> 00:39:11,079
또 그다음 P(V)를 추가하는 식으로 계속하면 됩니다. 좀
 

1808
00:39:11,079 --> 00:39:12,510
또 그다음 P(V)를 추가하는 식으로 계속하면 됩니다. 좀
더

1809
00:39:12,510 --> 00:39:12,520
더
 

1810
00:39:12,520 --> 00:39:14,910
더
복잡하게 들리겠지만, 실제로는 그렇지 않습니다.  음, 제가

1811
00:39:14,910 --> 00:39:14,920
복잡하게 들리겠지만, 실제로는 그렇지 않습니다.  음, 제가
 

1812
00:39:14,920 --> 00:39:17,069
복잡하게 들리겠지만, 실제로는 그렇지 않습니다.  음, 제가
원래 정점으로 되돌아갈 때까지는

1813
00:39:17,069 --> 00:39:17,079
원래 정점으로 되돌아갈 때까지는
 

1814
00:39:17,079 --> 00:39:18,750
원래 정점으로 되돌아갈 때까지는
이 객체가 개념적으로

1815
00:39:18,750 --> 00:39:18,760
이 객체가 개념적으로
 

1816
00:39:18,760 --> 00:39:21,030
이 객체가 개념적으로
최단 경로 트리라고 불립니다.

1817
00:39:21,030 --> 00:39:21,040
최단 경로 트리라고 불립니다.
 

1818
00:39:21,040 --> 00:39:22,990
최단 경로 트리라고 불립니다.

1819
00:39:22,990 --> 00:39:23,000

 

1820
00:39:23,000 --> 00:39:28,150

이에 대해 질문 있으신가요? 네,

1821
00:39:28,150 --> 00:39:28,160

 

1822
00:39:28,160 --> 00:39:36,150

저는 A와 D를 연결하는 간선을 가지고 있었습니다. 아, 좋습니다.

1823
00:39:36,150 --> 00:39:36,160

 

1824
00:39:36,160 --> 00:39:39,910

질문은 이렇습니다.

1825
00:39:39,910 --> 00:39:39,920
질문은 이렇습니다.
 

1826
00:39:39,920 --> 00:39:43,510
질문은 이렇습니다.
우리 동료가 간선을 추가했다고 가정해 봅시다. 정말

1827
00:39:43,510 --> 00:39:43,520
우리 동료가 간선을 추가했다고 가정해 봅시다. 정말
 

1828
00:39:43,520 --> 00:39:46,790
우리 동료가 간선을 추가했다고 가정해 봅시다. 정말
좋은

1829
00:39:46,790 --> 00:39:46,800
좋은
 

1830
00:39:46,800 --> 00:39:49,550
좋은
질문입니다. 누군가

1831
00:39:49,550 --> 00:39:52,069
질문입니다. 누군가
 

1832
00:39:52,069 --> 00:39:52,079

 

1833
00:39:52,079 --> 00:39:53,790

악의적으로, 예를 들어 적대적 신경망 STI를 만들어서

1834
00:39:53,790 --> 00:39:53,800
악의적으로, 예를 들어 적대적 신경망 STI를 만들어서
 

1835
00:39:53,800 --> 00:39:56,470
악의적으로, 예를 들어 적대적 신경망 STI를 만들어서
제 최단 경로 코드가 실패하도록 만들었다고 생각해 보세요.

1836
00:39:56,470 --> 00:39:56,480
제 최단 경로 코드가 실패하도록 만들었다고 생각해 보세요.
 

1837
00:39:56,480 --> 00:39:58,829
제 최단 경로 코드가 실패하도록 만들었다고 생각해 보세요.
이제 제가 드린 트리는 더

1838
00:39:58,829 --> 00:39:58,839
이제 제가 드린 트리는 더
 

1839
00:39:58,839 --> 00:40:01,550
이제 제가 드린 트리는 더
이상 정확하지 않습니다. 제

1840
00:40:01,550 --> 00:40:01,560
이상 정확하지 않습니다. 제
 

1841
00:40:01,560 --> 00:40:04,390
이상 정확하지 않습니다. 제
대답은 '예'입니다. 왜냐하면

1842
00:40:04,390 --> 00:40:04,400
대답은 '예'입니다. 왜냐하면
 

1843
00:40:04,400 --> 00:40:06,790
대답은 '예'입니다. 왜냐하면
이 간선을 추가함으로써

1844
00:40:06,790 --> 00:40:06,800
이 간선을 추가함으로써
 

1845
00:40:06,800 --> 00:40:08,349
이 간선을 추가함으로써
최단 경로의 길이가 바뀌었기 때문입니다.

1846
00:40:08,349 --> 00:40:08,359
최단 경로의 길이가 바뀌었기 때문입니다.
 

1847
00:40:08,359 --> 00:40:10,870
최단 경로의 길이가 바뀌었기 때문입니다.
A에서 D까지의 최단 경로는 이제 1이 됩니다.

1848
00:40:10,870 --> 00:40:10,880
A에서 D까지의 최단 경로는 이제 1이 됩니다.
 

1849
00:40:10,880 --> 00:40:12,470
A에서 D까지의 최단 경로는 이제 1이 됩니다.
따라서 이 트리는 더 이상 유효하지 않습니다.

1850
00:40:12,470 --> 00:40:12,480
따라서 이 트리는 더 이상 유효하지 않습니다.
 

1851
00:40:12,480 --> 00:40:16,150
따라서 이 트리는 더 이상 유효하지 않습니다.
새로운 트리가 필요합니다. 그렇다면

1852
00:40:16,150 --> 00:40:16,160
새로운 트리가 필요합니다. 그렇다면
 

1853
00:40:16,160 --> 00:40:19,230
새로운 트리가 필요합니다. 그렇다면
D의 이전 P는 무엇일까요?

1854
00:40:19,230 --> 00:40:19,240
D의 이전 P는 무엇일까요?
 

1855
00:40:19,240 --> 00:40:21,790
D의 이전 P는 무엇일까요?
C가 아니라 A가 되겠죠. 네, 맞습니다.

1856
00:40:21,790 --> 00:40:21,800
C가 아니라 A가 되겠죠. 네, 맞습니다.
 

1857
00:40:21,800 --> 00:40:24,430
C가 아니라 A가 되겠죠. 네, 맞습니다.
그리고 이는

1858
00:40:24,430 --> 00:40:24,440
그리고 이는
 

1859
00:40:24,440 --> 00:40:26,630
그리고 이는
실제로 반영된 것입니다.

1860
00:40:26,630 --> 00:40:26,640
실제로 반영된 것입니다.
 

1861
00:40:26,640 --> 00:40:28,069
실제로 반영된 것입니다.
최단

1862
00:40:28,069 --> 00:40:28,079
최단
 

1863
00:40:28,079 --> 00:40:30,430
최단
경로의 정말 짜증나는 특성 중 하나는 그래프에 간선을 하나 추가하면 모든 정점까지

1864
00:40:30,430 --> 00:40:30,440
경로의 정말 짜증나는 특성 중 하나는 그래프에 간선을 하나 추가하면 모든 정점까지
 

1865
00:40:30,440 --> 00:40:32,470
경로의 정말 짜증나는 특성 중 하나는 그래프에 간선을 하나 추가하면 모든 정점까지
의 최단 경로 길이가

1866
00:40:32,470 --> 00:40:32,480
의 최단 경로 길이가
 

1867
00:40:32,480 --> 00:40:34,750
의 최단 경로 길이가
바뀔 수 있다는 것입니다.

1868
00:40:34,750 --> 00:40:34,760
바뀔 수 있다는 것입니다.
 

1869
00:40:34,760 --> 00:40:36,510
바뀔 수 있다는 것입니다.
시작

1870
00:40:36,510 --> 00:40:36,520
시작
 

1871
00:40:36,520 --> 00:40:39,510
시작
정점은 예외겠지만요. 네, 그리고 이건

1872
00:40:39,510 --> 00:40:41,150
정점은 예외겠지만요. 네, 그리고 이건
 

1873
00:40:41,150 --> 00:40:41,160

 

1874
00:40:41,160 --> 00:40:43,510

특정 응용 분야에서 정말 큰 골칫거리입니다. 예를 들어,

1875
00:40:43,510 --> 00:40:43,520
특정 응용 분야에서 정말 큰 골칫거리입니다. 예를 들어,
 

1876
00:40:43,520 --> 00:40:44,910
특정 응용 분야에서 정말 큰 골칫거리입니다. 예를 들어,
응용 분야 이야기는 그만하고

1877
00:40:44,910 --> 00:40:44,920
응용 분야 이야기는 그만하고
 

1878
00:40:44,920 --> 00:40:47,550
응용 분야 이야기는 그만하고
다시 수학 이야기를 해볼까요? 저는 3D 모델을 많이 다루는데, 발레리나

1879
00:40:47,550 --> 00:40:49,470
다시 수학 이야기를 해볼까요? 저는 3D 모델을 많이 다루는데, 발레리나
 

1880
00:40:49,470 --> 00:40:49,480

 

1881
00:40:49,480 --> 00:40:51,790

같은 3D 모델 데이터 세트가 꽤 있습니다. 발레리나는

1882
00:40:51,790 --> 00:40:53,109
같은 3D 모델 데이터 세트가 꽤 있습니다. 발레리나는
 

1883
00:40:53,109 --> 00:40:53,119

 

1884
00:40:53,119 --> 00:40:54,069

손을 이렇게 모으는 경우가 있어서 정말 골치 아픈데,

1885
00:40:54,069 --> 00:40:54,079
손을 이렇게 모으는 경우가 있어서 정말 골치 아픈데,
 

1886
00:40:54,079 --> 00:40:56,710
손을 이렇게 모으는 경우가 있어서 정말 골치 아픈데,
갑자기

1887
00:40:56,710 --> 00:40:56,720
갑자기
 

1888
00:40:56,720 --> 00:41:00,230
갑자기
손가락 사이의 최단 경로가

1889
00:41:00,230 --> 00:41:00,240
손가락 사이의 최단 경로가
 

1890
00:41:00,240 --> 00:41:03,630
손가락 사이의 최단 경로가
몸 전체에서 0으로 바뀌어 버립니다. 이런 경우

1891
00:41:03,630 --> 00:41:05,030
몸 전체에서 0으로 바뀌어 버립니다. 이런 경우
 

1892
00:41:05,030 --> 00:41:05,040

 

1893
00:41:05,040 --> 00:41:06,950

최단 경로를 계산하는 점진적 알고리즘이 제대로 작동하지 않을 수 있습니다. 마치

1894
00:41:06,950 --> 00:41:08,790
최단 경로를 계산하는 점진적 알고리즘이 제대로 작동하지 않을 수 있습니다. 마치
 

1895
00:41:08,790 --> 00:41:10,550

 

1896
00:41:10,550 --> 00:41:10,560

 

1897
00:41:10,560 --> 00:41:12,950

손가락을 붙여버린 것처럼 잘못 계산하면 모든 것을 수정해야 하니까요. 네, 그래서

1898
00:41:12,950 --> 00:41:13,990
손가락을 붙여버린 것처럼 잘못 계산하면 모든 것을 수정해야 하니까요. 네, 그래서
 

1899
00:41:13,990 --> 00:41:14,000

 

1900
00:41:14,000 --> 00:41:15,349

이 문제를 어떻게 해결할지 생각해 보세요.

1901
00:41:15,349 --> 00:41:15,359
이 문제를 어떻게 해결할지 생각해 보세요.
 

1902
00:41:15,359 --> 00:41:19,550
이 문제를 어떻게 해결할지 생각해 보세요.
더 자세히 알고 싶으면 683a를 참고하세요.

1903
00:41:19,550 --> 00:41:19,560
더 자세히 알고 싶으면 683a를 참고하세요.
 

1904
00:41:19,560 --> 00:41:21,829
더 자세히 알고 싶으면 683a를 참고하세요.
시작 노드를 바꾸면

1905
00:41:21,829 --> 00:41:21,839
시작 노드를 바꾸면
 

1906
00:41:21,839 --> 00:41:23,430
시작 노드를 바꾸면
최단 경로도 다시 바뀝니다. 네,

1907
00:41:23,430 --> 00:41:24,510
최단 경로도 다시 바뀝니다. 네,
 

1908
00:41:24,510 --> 00:41:24,520

 

1909
00:41:24,520 --> 00:41:25,750

정말 지루한 내용이 될 것 같네요.  제가

1910
00:41:25,750 --> 00:41:27,790
정말 지루한 내용이 될 것 같네요.  제가
 

1911
00:41:27,790 --> 00:41:27,800

 

1912
00:41:27,800 --> 00:41:29,589

문제에 대해 뭔가를 바꾸거나, 출발점을 바꾸거나,

1913
00:41:29,589 --> 00:41:29,599
문제에 대해 뭔가를 바꾸거나, 출발점을 바꾸거나,
 

1914
00:41:29,599 --> 00:41:30,790
문제에 대해 뭔가를 바꾸거나, 출발점을 바꾸거나,
간선을 바꾸면

1915
00:41:30,790 --> 00:41:30,800
간선을 바꾸면
 

1916
00:41:30,800 --> 00:41:32,550
간선을 바꾸면
모든 최단 경로를 다시 계산해야 한다는 식으로 계속 답변해 드릴게요.

1917
00:41:32,550 --> 00:41:32,560
모든 최단 경로를 다시 계산해야 한다는 식으로 계속 답변해 드릴게요.
 

1918
00:41:32,560 --> 00:41:34,069
모든 최단 경로를 다시 계산해야 한다는 식으로 계속 답변해 드릴게요.
물론 그렇게 하지 않는 알고리즘도 있지만,

1919
00:41:34,069 --> 00:41:36,950
물론 그렇게 하지 않는 알고리즘도 있지만,
 

1920
00:41:36,950 --> 00:41:36,960

 

1921
00:41:36,960 --> 00:41:40,470

아직은 그런 알고리즘에 대해서는 생각해 보지 않을 거예요. 자, 평소처럼

1922
00:41:40,470 --> 00:41:40,480
아직은 그런 알고리즘에 대해서는 생각해 보지 않을 거예요. 자, 평소처럼
 

1923
00:41:40,480 --> 00:41:41,750
아직은 그런 알고리즘에 대해서는 생각해 보지 않을 거예요. 자, 평소처럼
제가 너무 말을 많이 해서 이제 강의에서 흥미로운 알고리즘을

1924
00:41:41,750 --> 00:41:41,760
제가 너무 말을 많이 해서 이제 강의에서 흥미로운 알고리즘을
 

1925
00:41:41,760 --> 00:41:43,589
제가 너무 말을 많이 해서 이제 강의에서 흥미로운 알고리즘을
실제로 설명할 시간이 10분 정도밖에 남지 않았네요. 사실

1926
00:41:43,589 --> 00:41:45,430
실제로 설명할 시간이 10분 정도밖에 남지 않았네요. 사실
 

1927
00:41:45,430 --> 00:41:47,470

 

1928
00:41:47,470 --> 00:41:47,480

 

1929
00:41:47,480 --> 00:41:48,750

그렇게 복잡하지는 않아서 잘 해낼 수 있을 것 같아요.

1930
00:41:48,750 --> 00:41:48,760
그렇게 복잡하지는 않아서 잘 해낼 수 있을 것 같아요.
 

1931
00:41:48,760 --> 00:41:50,750
그렇게 복잡하지는 않아서 잘 해낼 수 있을 것 같아요.
바로 이

1932
00:41:50,750 --> 00:41:50,760
바로 이
 

1933
00:41:50,760 --> 00:41:52,910
바로 이
경로들을 어떻게 계산하는지에 대한 알고리즘이죠. 네,

1934
00:41:52,910 --> 00:41:52,920
경로들을 어떻게 계산하는지에 대한 알고리즘이죠. 네,
 

1935
00:41:52,920 --> 00:41:54,550
경로들을 어떻게 계산하는지에 대한 알고리즘이죠. 네,
기본적으로 이

1936
00:41:54,550 --> 00:41:54,560
기본적으로 이
 

1937
00:41:54,560 --> 00:41:56,710
기본적으로 이
트리 비유를 바탕으로 제가 정말 좋아하는

1938
00:41:56,710 --> 00:41:56,720
트리 비유를 바탕으로 제가 정말 좋아하는
 

1939
00:41:56,720 --> 00:41:58,510
트리 비유를 바탕으로 제가 정말 좋아하는
또 다른 개념을 정의할 거예요.

1940
00:41:58,510 --> 00:42:00,390
또 다른 개념을 정의할 거예요.
 

1941
00:42:00,390 --> 00:42:00,400

 

1942
00:42:00,400 --> 00:42:01,710

제이슨의 노트에서 본 건데,

1943
00:42:01,710 --> 00:42:01,720
제이슨의 노트에서 본 건데,
 

1944
00:42:01,720 --> 00:42:03,230
제이슨의 노트에서 본 건데,
미적분과 비슷해서 마음에 들어요.

1945
00:42:03,230 --> 00:42:03,240
미적분과 비슷해서 마음에 들어요.
 

1946
00:42:03,240 --> 00:42:06,470
미적분과 비슷해서 마음에 들어요.
음, 그건

1947
00:42:06,470 --> 00:42:06,480
음, 그건
 

1948
00:42:06,480 --> 00:42:09,430
음, 그건
레벨 집합이라는 개념이에요. 이건 모든

1949
00:42:09,430 --> 00:42:09,440
레벨 집합이라는 개념이에요. 이건 모든
 

1950
00:42:09,440 --> 00:42:11,829
레벨 집합이라는 개념이에요. 이건 모든
정점들의 집합 L<sub>k</sub>이고, 이 정점들은

1951
00:42:11,829 --> 00:42:13,910
정점들의 집합 L<sub>k</sub>이고, 이 정점들은
 

1952
00:42:13,910 --> 00:42:13,920

 

1953
00:42:13,920 --> 00:42:16,589

출발점에서 거리 K만큼 떨어져 있는 정점들이에요. 예를 들어,

1954
00:42:16,589 --> 00:42:16,599
출발점에서 거리 K만큼 떨어져 있는 정점들이에요. 예를 들어,
 

1955
00:42:16,599 --> 00:42:18,750
출발점에서 거리 K만큼 떨어져 있는 정점들이에요. 예를 들어,
출발점 정점이 여기에 있다면...  예를 들어

1956
00:42:18,750 --> 00:42:18,760
출발점 정점이 여기에 있다면...  예를 들어
 

1957
00:42:18,760 --> 00:42:20,630
출발점 정점이 여기에 있다면...  예를 들어
맨 왼쪽 꼭짓점이 있다고 가정하면,

1958
00:42:20,630 --> 00:42:20,640
맨 왼쪽 꼭짓점이 있다고 가정하면,
 

1959
00:42:20,640 --> 00:42:23,950
맨 왼쪽 꼭짓점이 있다고 가정하면,
l0에는 당연히 그 꼭짓점만 포함됩니다.

1960
00:42:23,950 --> 00:42:23,960
l0에는 당연히 그 꼭짓점만 포함됩니다.
 

1961
00:42:23,960 --> 00:42:26,109
l0에는 당연히 그 꼭짓점만 포함됩니다.
L1은 그 다음 꼭짓점이고, L2는

1962
00:42:26,109 --> 00:42:26,119
L1은 그 다음 꼭짓점이고, L2는
 

1963
00:42:26,119 --> 00:42:29,870
L1은 그 다음 꼭짓점이고, L2는
세 번째 꼭짓점입니다. 그런데 L3는 세 개의

1964
00:42:29,870 --> 00:42:29,880
세 번째 꼭짓점입니다. 그런데 L3는 세 개의
 

1965
00:42:29,880 --> 00:42:31,829
세 번째 꼭짓점입니다. 그런데 L3는 세 개의
꼭짓점으로 이루어진 집합이죠. 왜냐하면 이 세 꼭짓점은 모두

1966
00:42:31,829 --> 00:42:33,309
꼭짓점으로 이루어진 집합이죠. 왜냐하면 이 세 꼭짓점은 모두
 

1967
00:42:33,309 --> 00:42:33,319

 

1968
00:42:33,319 --> 00:42:34,750

출발점에서 3만큼 떨어져 있기 때문입니다. 제가

1969
00:42:34,750 --> 00:42:34,760
출발점에서 3만큼 떨어져 있기 때문입니다. 제가
 

1970
00:42:34,760 --> 00:42:37,270
출발점에서 3만큼 떨어져 있기 때문입니다. 제가
여기 분홍색으로 표시해 둔 것들이죠. 자,

1971
00:42:37,270 --> 00:42:37,280
여기 분홍색으로 표시해 둔 것들이죠. 자,
 

1972
00:42:37,280 --> 00:42:40,230
여기 분홍색으로 표시해 둔 것들이죠. 자,
이 표기법은 이런 의미입니다. 아,

1973
00:42:40,230 --> 00:42:40,240
이 표기법은 이런 의미입니다. 아,
 

1974
00:42:40,240 --> 00:42:41,710
이 표기법은 이런 의미입니다. 아,
제가 약간 오타를 냈네요.

1975
00:42:41,710 --> 00:42:41,720
제가 약간 오타를 냈네요.
 

1976
00:42:41,720 --> 00:42:43,589
제가 약간 오타를 냈네요.
이 수업에서는 거리를 델타(Δ)라고 하는데,

1977
00:42:43,589 --> 00:42:43,599
이 수업에서는 거리를 델타(Δ)라고 하는데,
 

1978
00:42:43,599 --> 00:42:47,270
이 수업에서는 거리를 델타(Δ)라고 하는데,
D가 아닙니다. 어쨌든 최단 거리를 의미합니다. 맞습니다.

1979
00:42:47,270 --> 00:42:48,790
D가 아닙니다. 어쨌든 최단 거리를 의미합니다. 맞습니다.
 

1980
00:42:48,790 --> 00:42:48,800

 

1981
00:42:48,800 --> 00:42:50,190

예를 들어

1982
00:42:50,190 --> 00:42:50,200
예를 들어
 

1983
00:42:50,200 --> 00:42:52,390
예를 들어
l0에서 L1까지의 거리가 매우 멀다면,

1984
00:42:52,390 --> 00:42:53,950
l0에서 L1까지의 거리가 매우 멀다면,
 

1985
00:42:53,950 --> 00:42:53,960

 

1986
00:42:53,960 --> 00:42:56,109

l0과 L1 사이를 왔다 갔다 하면서 L4로 갔다가 다시

1987
00:42:56,109 --> 00:42:56,119
l0과 L1 사이를 왔다 갔다 하면서 L4로 갔다가 다시
 

1988
00:42:56,119 --> 00:42:57,910
l0과 L1 사이를 왔다 갔다 하면서 L4로 갔다가 다시
돌아올 수도 있겠죠. 하지만 그렇게 하면 시간을

1989
00:42:57,910 --> 00:42:57,920
돌아올 수도 있겠죠. 하지만 그렇게 하면 시간을
 

1990
00:42:57,920 --> 00:43:00,309
돌아올 수도 있겠죠. 하지만 그렇게 하면 시간을
계산하는 데 그다지 도움이 되지 않겠죠.

1991
00:43:00,309 --> 00:43:00,319
계산하는 데 그다지 도움이 되지 않겠죠.
 

1992
00:43:00,319 --> 00:43:03,349
계산하는 데 그다지 도움이 되지 않겠죠.
맞습니다.

1993
00:43:03,349 --> 00:43:03,359

 

1994
00:43:03,359 --> 00:43:07,150

아, 빨간색 배경은 꼭짓점들의 집합입니다.

1995
00:43:07,150 --> 00:43:07,160
아, 빨간색 배경은 꼭짓점들의 집합입니다.
 

1996
00:43:07,160 --> 00:43:09,630
아, 빨간색 배경은 꼭짓점들의 집합입니다.
예를 들어 L3에는 이 세 꼭짓점이 포함됩니다. 왜냐하면 이 세

1997
00:43:09,630 --> 00:43:09,640
예를 들어 L3에는 이 세 꼭짓점이 포함됩니다. 왜냐하면 이 세
 

1998
00:43:09,640 --> 00:43:11,790
예를 들어 L3에는 이 세 꼭짓점이 포함됩니다. 왜냐하면 이 세
꼭짓점은 모두

1999
00:43:11,790 --> 00:43:11,800
꼭짓점은 모두
 

2000
00:43:11,800 --> 00:43:13,470
꼭짓점은 모두
왼쪽에서 3만큼 떨어져 있기 때문입니다. 제가

2001
00:43:13,470 --> 00:43:15,670
왼쪽에서 3만큼 떨어져 있기 때문입니다. 제가
 

2002
00:43:15,670 --> 00:43:15,680

 

2003
00:43:15,680 --> 00:43:18,030

그림을 너무 과하게 그렸네요.  밤, 저는 이 알고리즘이 꽤

2004
00:43:18,030 --> 00:43:18,040
그림을 너무 과하게 그렸네요.  밤, 저는 이 알고리즘이 꽤
 

2005
00:43:18,040 --> 00:43:21,109
그림을 너무 과하게 그렸네요.  밤, 저는 이 알고리즘이 꽤
자랑스럽습니다. 자,

2006
00:43:21,109 --> 00:43:21,119
자랑스럽습니다. 자,
 

2007
00:43:21,119 --> 00:43:23,790
자랑스럽습니다. 자,
기본적으로 가장

2008
00:43:23,790 --> 00:43:25,470
기본적으로 가장
 

2009
00:43:25,470 --> 00:43:25,480

 

2010
00:43:25,480 --> 00:43:27,510

왼쪽 정점에서

2011
00:43:27,510 --> 00:43:27,520
왼쪽 정점에서
 

2012
00:43:27,520 --> 00:43:28,470
왼쪽 정점에서
다른 모든

2013
00:43:28,470 --> 00:43:28,480
다른 모든
 

2014
00:43:28,480 --> 00:43:30,549
다른 모든
정점까지의 최단 경로 길이를 계산하고 싶다면, 한 가지 방법은

2015
00:43:30,549 --> 00:43:30,559
정점까지의 최단 경로 길이를 계산하고 싶다면, 한 가지 방법은
 

2016
00:43:30,559 --> 00:43:32,030
정점까지의 최단 경로 길이를 계산하고 싶다면, 한 가지 방법은
모든 레벨 집합을 계산한 다음 현재

2017
00:43:32,030 --> 00:43:32,040
모든 레벨 집합을 계산한 다음 현재
 

2018
00:43:32,040 --> 00:43:33,950
모든 레벨 집합을 계산한 다음 현재
어떤 레벨 집합에 있는지 확인하는 것입니다. 그렇죠?

2019
00:43:33,950 --> 00:43:33,960
어떤 레벨 집합에 있는지 확인하는 것입니다. 그렇죠?
 

2020
00:43:33,960 --> 00:43:36,390
어떤 레벨 집합에 있는지 확인하는 것입니다. 그렇죠?
그래서 우리는 대략 그런 방식으로 작동하는 '

2021
00:43:36,390 --> 00:43:36,400
그래서 우리는 대략 그런 방식으로 작동하는 '
 

2022
00:43:36,400 --> 00:43:39,190
그래서 우리는 대략 그런 방식으로 작동하는 '
브레스 버 서치(Breath Ver Search)'라는 알고리즘을 소개할 것입니다.

2023
00:43:39,190 --> 00:43:42,030
브레스 버 서치(Breath Ver Search)'라는 알고리즘을 소개할 것입니다.
 

2024
00:43:42,030 --> 00:43:43,910

 

2025
00:43:43,910 --> 00:43:44,950

 

2026
00:43:44,950 --> 00:43:44,960

 

2027
00:43:44,960 --> 00:43:47,710

브레스 버 서치는 모든 레벨 집합 L을 계산하는 알고리즘입니다.

2028
00:43:47,710 --> 00:43:47,720
브레스 버 서치는 모든 레벨 집합 L을 계산하는 알고리즘입니다.
 

2029
00:43:47,720 --> 00:43:49,109
브레스 버 서치는 모든 레벨 집합 L을 계산하는 알고리즘입니다.
그리고 그로부터 최단 경로의

2030
00:43:49,109 --> 00:43:49,119
그리고 그로부터 최단 경로의
 

2031
00:43:49,119 --> 00:43:50,870
그리고 그로부터 최단 경로의
길이와 모양까지 구성할 수 있습니다.

2032
00:43:50,870 --> 00:43:50,880
길이와 모양까지 구성할 수 있습니다.
 

2033
00:43:50,880 --> 00:43:52,829
길이와 모양까지 구성할 수 있습니다.
이제

2034
00:43:52,829 --> 00:43:52,839
이제
 

2035
00:43:52,839 --> 00:43:54,549
이제
제 필기

2036
00:43:54,549 --> 00:43:54,559
제 필기
 

2037
00:43:54,559 --> 00:43:57,230
제 필기
노트를 참고하겠습니다.

2038
00:43:57,230 --> 00:43:57,240
노트를 참고하겠습니다.
 

2039
00:43:57,240 --> 00:43:58,270
노트를 참고하겠습니다.
알고리즘이 하는 일을

2040
00:43:58,270 --> 00:43:58,280
알고리즘이 하는 일을
 

2041
00:43:58,280 --> 00:43:59,950
알고리즘이 하는 일을

2042
00:43:59,950 --> 00:44:02,069

 

2043
00:44:02,069 --> 00:44:02,079

 

2044
00:44:02,079 --> 00:44:03,309

강의

2045
00:44:03,309 --> 00:44:03,319
강의
 

2046
00:44:03,319 --> 00:44:04,750
강의
노트와 화면에 있는 것과는 약간 다르게 적겠습니다. 하지만 아주

2047
00:44:04,750 --> 00:44:04,760
노트와 화면에 있는 것과는 약간 다르게 적겠습니다. 하지만 아주
 

2048
00:44:04,760 --> 00:44:08,750
노트와 화면에 있는 것과는 약간 다르게 적겠습니다. 하지만 아주
조금만요. 우선,

2049
00:44:08,750 --> 00:44:08,760
조금만요. 우선,
 

2050
00:44:08,760 --> 00:44:11,030
조금만요. 우선,
우리 모두 동의할 수 있는 한 가지는 레벨

2051
00:44:11,030 --> 00:44:11,040
우리 모두 동의할 수 있는 한 가지는 레벨
 

2052
00:44:11,040 --> 00:44:13,990
우리 모두 동의할 수 있는 한 가지는 레벨
집합 0이 있다는 것입니다. 오, 멋지네요! 이 분지형 그래프에는

2053
00:44:13,990 --> 00:44:14,000
집합 0이 있다는 것입니다. 오, 멋지네요! 이 분지형 그래프에는
 

2054
00:44:14,000 --> 00:44:17,510
집합 0이 있다는 것입니다. 오, 멋지네요! 이 분지형 그래프에는
노드가 하나 있습니다.

2055
00:44:17,510 --> 00:44:17,520
노드가 하나 있습니다.
 

2056
00:44:17,520 --> 00:44:20,589
노드가 하나 있습니다.
그 노드는 무엇일까요?  소스 노드가 맞죠?

2057
00:44:20,589 --> 00:44:21,829
그 노드는 무엇일까요?  소스 노드가 맞죠?
 

2058
00:44:21,829 --> 00:44:21,839

 

2059
00:44:21,839 --> 00:44:23,589

소스에서 0만큼 떨어진 유일한 것은

2060
00:44:23,589 --> 00:44:23,599
소스에서 0만큼 떨어진 유일한 것은
 

2061
00:44:23,599 --> 00:44:29,030
소스에서 0만큼 떨어진 유일한 것은
소스 노드뿐이니까요.

2062
00:44:29,030 --> 00:44:29,040

 

2063
00:44:29,040 --> 00:44:32,190

네, 알겠습니다. 그리고

2064
00:44:32,190 --> 00:44:33,710
네, 알겠습니다. 그리고
 

2065
00:44:33,710 --> 00:44:33,720

 

2066
00:44:33,720 --> 00:44:34,870

소스 노드에서 자기

2067
00:44:34,870 --> 00:44:34,880
소스 노드에서 자기
 

2068
00:44:34,880 --> 00:44:37,069
소스 노드에서 자기
자신까지의 거리를 초기화할 수 있습니다. 자, 셋!

2069
00:44:37,069 --> 00:44:37,079
자신까지의 거리를 초기화할 수 있습니다. 자, 셋!
 

2070
00:44:37,079 --> 00:44:39,150
자신까지의 거리를 초기화할 수 있습니다. 자, 셋!
소스 노드에서 자기 자신까지의 거리는 얼마일까요? 1, 2,

2071
00:44:39,150 --> 00:44:39,160
소스 노드에서 자기 자신까지의 거리는 얼마일까요? 1, 2,
 

2072
00:44:39,160 --> 00:44:41,710
소스 노드에서 자기 자신까지의 거리는 얼마일까요? 1, 2,
3, 0. 감사합니다.

2073
00:44:41,710 --> 00:44:41,720
3, 0. 감사합니다.
 

2074
00:44:41,720 --> 00:44:43,829
3, 0. 감사합니다.
이제 깨어나셨군요. 거의 11시,

2075
00:44:43,829 --> 00:44:43,839
이제 깨어나셨군요. 거의 11시,
 

2076
00:44:43,839 --> 00:44:47,230
이제 깨어나셨군요. 거의 11시,
12시네요. 몇 시죠? 거의 12시죠? 네, 그리고

2077
00:44:47,230 --> 00:44:47,240
12시네요. 몇 시죠? 거의 12시죠? 네, 그리고
 

2078
00:44:47,240 --> 00:44:50,390
12시네요. 몇 시죠? 거의 12시죠? 네, 그리고
마지막으로, 처음에는

2079
00:44:50,390 --> 00:44:51,510
마지막으로, 처음에는
 

2080
00:44:51,510 --> 00:44:51,520

 

2081
00:44:51,520 --> 00:44:54,109

배열 P에 대해 아는 것이 거의 없으니 그냥 비워둡니다.

2082
00:44:54,109 --> 00:44:54,119
배열 P에 대해 아는 것이 거의 없으니 그냥 비워둡니다.
 

2083
00:44:54,119 --> 00:44:56,390
배열 P에 대해 아는 것이 거의 없으니 그냥 비워둡니다.
소스 노드의 P는 어차피

2084
00:44:56,390 --> 00:44:56,400
소스 노드의 P는 어차피
 

2085
00:44:56,400 --> 00:44:57,470
소스 노드의 P는 어차피
중요하지 않으니까요.

2086
00:44:57,470 --> 00:44:57,480
중요하지 않으니까요.
 

2087
00:44:57,480 --> 00:44:58,910
중요하지 않으니까요.
소스 노드로 돌아오면

2088
00:44:58,910 --> 00:44:58,920
소스 노드로 돌아오면
 

2089
00:44:58,920 --> 00:45:01,109
소스 노드로 돌아오면
최단 경로 계산은 끝난 거니까요. 이제

2090
00:45:01,109 --> 00:45:01,119
최단 경로 계산은 끝난 거니까요. 이제
 

2091
00:45:01,119 --> 00:45:02,670
최단 경로 계산은 끝난 거니까요. 이제
모든

2092
00:45:02,670 --> 00:45:02,680
모든
 

2093
00:45:02,680 --> 00:45:05,750
모든
레벨 세트를 계산하고, 배열 P를 채우고,

2094
00:45:05,750 --> 00:45:05,760
레벨 세트를 계산하고, 배열 P를 채우고,
 

2095
00:45:05,760 --> 00:45:07,710
레벨 세트를 계산하고, 배열 P를 채우고,
거리까지 모두 한 번에 입력하는 알고리즘을 작성할 겁니다. 이 알고리즘을 '최단 경로

2096
00:45:07,710 --> 00:45:09,069
거리까지 모두 한 번에 입력하는 알고리즘을 작성할 겁니다. 이 알고리즘을 '최단 경로
 

2097
00:45:09,069 --> 00:45:09,079

 

2098
00:45:09,079 --> 00:45:10,190

우선

2099
00:45:10,190 --> 00:45:10,200
우선
 

2100
00:45:10,200 --> 00:45:14,750
우선
탐색'이라고 부르겠습니다. 그럼 해볼까요?

2101
00:45:14,750 --> 00:45:14,760

 

2102
00:45:14,760 --> 00:45:17,950

표기법을 사용해 보겠습니다. 여기서

2103
00:45:17,950 --> 00:45:17,960
표기법을 사용해 보겠습니다. 여기서
 

2104
00:45:17,960 --> 00:45:19,190
표기법을 사용해 보겠습니다. 여기서
기본적으로

2105
00:45:19,190 --> 00:45:19,200
기본적으로
 

2106
00:45:19,200 --> 00:45:20,829
기본적으로
귀납적 추론이 진행되고 있다는 것을 알 수 있죠.

2107
00:45:20,829 --> 00:45:20,839
귀납적 추론이 진행되고 있다는 것을 알 수 있죠.
 

2108
00:45:20,839 --> 00:45:22,470
귀납적 추론이 진행되고 있다는 것을 알 수 있죠.
레벨 세트 1을 계산해 보겠습니다.

2109
00:45:22,470 --> 00:45:22,480
레벨 세트 1을 계산해 보겠습니다.
 

2110
00:45:22,480 --> 00:45:24,990
레벨 세트 1을 계산해 보겠습니다.
레벨 세트 0부터 시작해서 레벨 세트 2, 레벨

2111
00:45:24,990 --> 00:45:25,000
레벨 세트 0부터 시작해서 레벨 세트 2, 레벨
 

2112
00:45:25,000 --> 00:45:27,190
레벨 세트 0부터 시작해서 레벨 세트 2, 레벨
세트 1부터 시작해서 이렇게 제

2113
00:45:27,190 --> 00:45:27,200
세트 1부터 시작해서 이렇게 제
 

2114
00:45:27,200 --> 00:45:30,950
세트 1부터 시작해서 이렇게 제
레벨 세트를 모두 채울 때까지 계속하는 거예요. 이해되시나요? 음,

2115
00:45:30,950 --> 00:45:32,710
레벨 세트를 모두 채울 때까지 계속하는 거예요. 이해되시나요? 음,
 

2116
00:45:32,710 --> 00:45:32,720

 

2117
00:45:32,720 --> 00:45:34,750

같은 내용을 조금 다르게 표현하는 방법이 있는데요,

2118
00:45:34,750 --> 00:45:34,760
같은 내용을 조금 다르게 표현하는 방법이 있는데요,
 

2119
00:45:34,760 --> 00:45:36,349
같은 내용을 조금 다르게 표현하는 방법이 있는데요,
while 루프를 사용할 거예요. 좀 정통적인 방법은 아니지만

2120
00:45:36,349 --> 00:45:36,359
while 루프를 사용할 거예요. 좀 정통적인 방법은 아니지만
 

2121
00:45:36,359 --> 00:45:39,670
while 루프를 사용할 거예요. 좀 정통적인 방법은 아니지만
괜찮아요. 먼저

2122
00:45:39,670 --> 00:45:39,680
괜찮아요. 먼저
 

2123
00:45:39,680 --> 00:45:42,630
괜찮아요. 먼저
숫자 i를 1로 초기화할게요.

2124
00:45:42,630 --> 00:45:42,640
숫자 i를 1로 초기화할게요.
 

2125
00:45:42,640 --> 00:45:44,670
숫자 i를 1로 초기화할게요.
이게 카운터가 될 거예요.

2126
00:45:44,670 --> 00:45:45,630
이게 카운터가 될 거예요.
 

2127
00:45:45,630 --> 00:45:45,640

 

2128
00:45:45,640 --> 00:45:47,870


2129
00:45:47,870 --> 00:45:50,630

 

2130
00:45:50,630 --> 00:45:50,640

 

2131
00:45:50,640 --> 00:45:54,030

이전 레벨 세트가 비어 있지 않은 동안, 즉

2132
00:45:54,030 --> 00:45:56,109
이전 레벨 세트가 비어 있지 않은 동안, 즉
 

2133
00:45:56,109 --> 00:45:56,119

 

2134
00:45:56,119 --> 00:45:57,950

이전 레벨 세트를 거쳐

2135
00:45:57,950 --> 00:45:57,960
이전 레벨 세트를 거쳐
 

2136
00:45:57,960 --> 00:46:00,150
이전 레벨 세트를 거쳐
다음 레벨 세트로 가는 경로가 있을 때까지 이 루프를 실행할 거예요. 왜냐하면

2137
00:46:00,150 --> 00:46:00,160
다음 레벨 세트로 가는 경로가 있을 때까지 이 루프를 실행할 거예요. 왜냐하면
 

2138
00:46:00,160 --> 00:46:02,270
다음 레벨 세트로 가는 경로가 있을 때까지 이 루프를 실행할 거예요. 왜냐하면
제 레벨 세트 중 하나가 비어 있으면, i가

2139
00:46:02,270 --> 00:46:02,280
제 레벨 세트 중 하나가 비어 있으면, i가
 

2140
00:46:02,280 --> 00:46:04,470
제 레벨 세트 중 하나가 비어 있으면, i가
더

2141
00:46:04,470 --> 00:46:04,480
더
 

2142
00:46:04,480 --> 00:46:06,069
더
큰 모든 레벨 세트도 비어 있게 되거든요.

2143
00:46:06,069 --> 00:46:07,309
큰 모든 레벨 세트도 비어 있게 되거든요.
 

2144
00:46:07,309 --> 00:46:09,549

 

2145
00:46:09,549 --> 00:46:09,559

 

2146
00:46:09,559 --> 00:46:11,309

i+

2147
00:46:11,309 --> 00:46:11,319
i+
 

2148
00:46:11,319 --> 00:46:16,870
i+
5처럼 거리가 1이 아닌 다른 값인 경우는 절대 없어요. 자, 이제 뭘 할까요?

2149
00:46:16,870 --> 00:46:21,829
5처럼 거리가 1이 아닌 다른 값인 경우는 절대 없어요. 자, 이제 뭘 할까요?
 

2150
00:46:21,829 --> 00:46:21,839

 

2151
00:46:21,839 --> 00:46:24,309

그래프를 다시 생각해 볼게요. 이

2152
00:46:24,309 --> 00:46:24,319
그래프를 다시 생각해 볼게요. 이
 

2153
00:46:24,319 --> 00:46:26,390
그래프를 다시 생각해 볼게요. 이
정점은 거리가 0이라는 걸 알고 있죠. 제가

2154
00:46:26,390 --> 00:46:26,400
정점은 거리가 0이라는 걸 알고 있죠. 제가
 

2155
00:46:26,400 --> 00:46:27,950
정점은 거리가 0이라는 걸 알고 있죠. 제가
처음에 생각했던 값이에요.

2156
00:46:27,950 --> 00:46:27,960
처음에 생각했던 값이에요.
 

2157
00:46:27,960 --> 00:46:29,190
처음에 생각했던 값이에요.
이제

2158
00:46:29,190 --> 00:46:29,200
이제
 

2159
00:46:29,200 --> 00:46:31,230
이제
이 정점의 모든 이웃을 살펴볼 거예요.  두 정점 사이의

2160
00:46:31,230 --> 00:46:31,240
이 정점의 모든 이웃을 살펴볼 거예요.  두 정점 사이의
 

2161
00:46:31,240 --> 00:46:34,589
이 정점의 모든 이웃을 살펴볼 거예요.  두 정점 사이의
거리를 1로 설정하면

2162
00:46:34,589 --> 00:46:34,599
거리를 1로 설정하면
 

2163
00:46:34,599 --> 00:46:36,870
거리를 1로 설정하면
의미가 통하고, 마찬가지로 이 정점의

2164
00:46:36,870 --> 00:46:36,880
의미가 통하고, 마찬가지로 이 정점의
 

2165
00:46:36,880 --> 00:46:37,870
의미가 통하고, 마찬가지로 이 정점의
거리도 1로 설정

2166
00:46:37,870 --> 00:46:39,870
거리도 1로 설정
 

2167
00:46:39,870 --> 00:46:41,390

 

2168
00:46:41,390 --> 00:46:44,390

 

2169
00:46:44,390 --> 00:46:46,710

 

2170
00:46:46,710 --> 00:46:48,430

 

2171
00:46:48,430 --> 00:46:51,510

 

2172
00:46:51,510 --> 00:46:53,750

 

2173
00:46:53,750 --> 00:46:53,760

 

2174
00:46:53,760 --> 00:46:55,670

합니다. 그런데 문제가 생길 수도 있어요. 예를 들어 설명하자면, 굳이 그리려고 하진 않겠지만, 정점을 두 개의 다른 레벨 세트에 두 번 추가하고 싶지 않을 때 문제가 발생할 수 있습니다. 예를 들어, 한 정점을 Li에 넣었다면 Li + 5처럼 두 레벨 세트에 넣고 싶지 않겠죠.

2175
00:46:55,670 --> 00:46:55,680
합니다. 그런데 문제가 생길 수도 있어요. 예를 들어 설명하자면, 굳이 그리려고 하진 않겠지만, 정점을 두 개의 다른 레벨 세트에 두 번 추가하고 싶지 않을 때 문제가 발생할 수 있습니다. 예를 들어, 한 정점을 Li에 넣었다면 Li + 5처럼 두 레벨 세트에 넣고 싶지 않겠죠.
 

2176
00:46:55,680 --> 00:46:56,950
합니다. 그런데 문제가 생길 수도 있어요. 예를 들어 설명하자면, 굳이 그리려고 하진 않겠지만, 정점을 두 개의 다른 레벨 세트에 두 번 추가하고 싶지 않을 때 문제가 발생할 수 있습니다. 예를 들어, 한 정점을 Li에 넣었다면 Li + 5처럼 두 레벨 세트에 넣고 싶지 않겠죠.
왜냐하면 이미 거리가 1만큼 떨어져 있다는 것을 알고 있기

2177
00:46:56,950 --> 00:46:59,270
왜냐하면 이미 거리가 1만큼 떨어져 있다는 것을 알고 있기
 

2178
00:46:59,270 --> 00:47:01,710

 

2179
00:47:01,710 --> 00:47:03,349

 

2180
00:47:03,349 --> 00:47:08,750

 

2181
00:47:08,750 --> 00:47:11,630

 

2182
00:47:11,630 --> 00:47:11,640

 

2183
00:47:11,640 --> 00:47:15,790

때문입니다. 이해가 되시나요? 자, 그럼 이제 이전 레벨 세트에 있는 모든 정점을 순회하면서, U에 인접한 모든 정점을 살펴볼 겁니다.

2184
00:47:15,790 --> 00:47:17,190
때문입니다. 이해가 되시나요? 자, 그럼 이제 이전 레벨 세트에 있는 모든 정점을 순회하면서, U에 인접한 모든 정점을 살펴볼 겁니다.
 

2185
00:47:17,190 --> 00:47:17,200

 

2186
00:47:17,200 --> 00:47:20,109

U에 도달하는 데 1-1단계가 걸린다면, U의 이웃 정점에 도달하는 데는 몇 단계가 걸릴까요? 8단계죠.

2187
00:47:20,109 --> 00:47:21,870
U에 도달하는 데 1-1단계가 걸린다면, U의 이웃 정점에 도달하는 데는 몇 단계가 걸릴까요? 8단계죠.
 

2188
00:47:21,870 --> 00:47:21,880

 

2189
00:47:21,880 --> 00:47:23,309


2190
00:47:23,309 --> 00:47:23,319

 

2191
00:47:23,319 --> 00:47:25,790

즉, 1-1단계의

2192
00:47:25,790 --> 00:47:25,800
즉, 1-1단계의
 

2193
00:47:25,800 --> 00:47:28,270
즉, 1-1단계의
경로를 따라가면서

2194
00:47:28,270 --> 00:47:28,280
경로를 따라가면서
 

2195
00:47:28,280 --> 00:47:30,870
경로를 따라가면서
간선을 하나 더 추가하면

2196
00:47:30,870 --> 00:47:30,880
간선을 하나 더 추가하면
 

2197
00:47:30,880 --> 00:47:34,990
간선을 하나 더 추가하면
새로운 정점에 도달할 수 있습니다. 그렇다면 어떻게 해야 할까요?

2198
00:47:34,990 --> 00:47:39,549
새로운 정점에 도달할 수 있습니다. 그렇다면 어떻게 해야 할까요?
 

2199
00:47:39,549 --> 00:47:39,559

 

2200
00:47:39,559 --> 00:47:43,150

인접한 정점 집합에 있는 모든 정점(V)을 순회하면 됩니다.  하지만

2201
00:47:43,150 --> 00:47:43,160
인접한 정점 집합에 있는 모든 정점(V)을 순회하면 됩니다.  하지만
 

2202
00:47:43,160 --> 00:47:45,109
인접한 정점 집합에 있는 모든 정점(V)을 순회하면 됩니다.  하지만
조금 조심해야 해요.

2203
00:47:45,109 --> 00:47:46,790
조금 조심해야 해요.
 

2204
00:47:46,790 --> 00:47:46,800

 

2205
00:47:46,800 --> 00:47:48,710

예를 들어, 간선이 역방향으로 연결되어 있으면 어떻게 될까요? 여기 소스로 돌아가는 간선이 있다고

2206
00:47:48,710 --> 00:47:48,720
예를 들어, 간선이 역방향으로 연결되어 있으면 어떻게 될까요? 여기 소스로 돌아가는 간선이 있다고
 

2207
00:47:48,720 --> 00:47:49,549
예를 들어, 간선이 역방향으로 연결되어 있으면 어떻게 될까요? 여기 소스로 돌아가는 간선이 있다고

2208
00:47:49,549 --> 00:47:49,559

 

2209
00:47:49,559 --> 00:47:52,910

가정해 볼게요. 네, 이건

2210
00:47:52,910 --> 00:47:52,920
가정해 볼게요. 네, 이건
 

2211
00:47:52,920 --> 00:47:55,309
가정해 볼게요. 네, 이건
유효한 예시죠. 이미 이전 레벨 집합에 소스를 추가했기 때문에

2212
00:47:55,309 --> 00:47:55,319
유효한 예시죠. 이미 이전 레벨 집합에 소스를 추가했기 때문에
 

2213
00:47:55,319 --> 00:47:57,069
유효한 예시죠. 이미 이전 레벨 집합에 소스를 추가했기 때문에
세 번째 레벨 집합에 소스를 추가하고 싶지 않아요.

2214
00:47:57,069 --> 00:47:59,109
세 번째 레벨 집합에 소스를 추가하고 싶지 않아요.
 

2215
00:47:59,109 --> 00:48:03,109

 

2216
00:48:03,109 --> 00:48:03,119

 

2217
00:48:03,119 --> 00:48:08,790

이전 레벨 집합들의 합집합을 없애고 싶어요.

2218
00:48:08,790 --> 00:48:12,589

 

2219
00:48:12,589 --> 00:48:12,599

 

2220
00:48:12,599 --> 00:48:14,549

다시 말해,

2221
00:48:14,549 --> 00:48:17,270
다시 말해,
 

2222
00:48:17,270 --> 00:48:17,280

 

2223
00:48:17,280 --> 00:48:20,150

레벨 집합 계산 알고리즘에서 아직 방문하지 않은 인접한 정점들만 고려할 거예요. 이제

2224
00:48:20,150 --> 00:48:22,190
레벨 집합 계산 알고리즘에서 아직 방문하지 않은 인접한 정점들만 고려할 거예요. 이제
 

2225
00:48:22,190 --> 00:48:22,200

 

2226
00:48:22,200 --> 00:48:24,630

배열을 업데이트하기만 하면 돼요. 특히,

2227
00:48:24,630 --> 00:48:27,829
배열을 업데이트하기만 하면 돼요. 특히,
 

2228
00:48:27,829 --> 00:48:27,839

 

2229
00:48:27,839 --> 00:48:30,870

정점 V를 레벨 집합 I에 추가할 거예요.

2230
00:48:30,870 --> 00:48:30,880
정점 V를 레벨 집합 I에 추가할 거예요.
 

2231
00:48:30,880 --> 00:48:34,790
정점 V를 레벨 집합 I에 추가할 거예요.
아직 V를 보지 못했기 때문에

2232
00:48:34,790 --> 00:48:34,800
아직 V를 보지 못했기 때문에
 

2233
00:48:34,800 --> 00:48:38,549
아직 V를 보지 못했기 때문에
S에서 V까지의 거리를

2234
00:48:38,549 --> 00:48:41,710
S에서 V까지의 거리를
 

2235
00:48:41,710 --> 00:48:41,720

 

2236
00:48:41,720 --> 00:48:44,230

I로 설정할 거예요. 왜냐하면 현재

2237
00:48:44,230 --> 00:48:44,240
I로 설정할 거예요. 왜냐하면 현재
 

2238
00:48:44,240 --> 00:48:48,190
I로 설정할 거예요. 왜냐하면 현재
레벨 집합 I을 채우고 있기 때문이죠.

2239
00:48:48,190 --> 00:48:48,200
레벨 집합 I을 채우고 있기 때문이죠.
 

2240
00:48:48,200 --> 00:48:50,270
레벨 집합 I을 채우고 있기 때문이죠.
마지막으로,

2241
00:48:50,270 --> 00:48:50,280
마지막으로,
 

2242
00:48:50,280 --> 00:48:53,750
마지막으로,
V의 p는 무엇일까요? 소스에서 V까지의 최단 경로에서 이전 정점은 무엇일까요? 바로

2243
00:48:53,750 --> 00:48:58,470
V의 p는 무엇일까요? 소스에서 V까지의 최단 경로에서 이전 정점은 무엇일까요? 바로
 

2244
00:48:58,470 --> 00:48:58,480

 

2245
00:48:58,480 --> 00:49:00,990

U입니다. 왜냐하면 U는 제가

2246
00:49:00,990 --> 00:49:01,000
U입니다. 왜냐하면 U는 제가
 

2247
00:49:01,000 --> 00:49:02,630
U입니다. 왜냐하면 U는 제가
만들고 있는 이전 레벨 집합에 있는 정점이기 때문이죠.

2248
00:49:02,630 --> 00:49:02,640
만들고 있는 이전 레벨 집합에 있는 정점이기 때문이죠.
 

2249
00:49:02,640 --> 00:49:06,349
만들고 있는 이전 레벨 집합에 있는 정점이기 때문이죠.
오른쪽에서 시작하는 경로에 대해 말씀드리려고 했는데,

2250
00:49:06,349 --> 00:49:06,359
오른쪽에서 시작하는 경로에 대해 말씀드리려고 했는데,
 

2251
00:49:06,359 --> 00:49:08,789
오른쪽에서 시작하는 경로에 대해 말씀드리려고 했는데,
공간이 부족해서 죄송합니다.

2252
00:49:08,789 --> 00:49:08,799
공간이 부족해서 죄송합니다.
 

2253
00:49:08,799 --> 00:49:12,190
공간이 부족해서 죄송합니다.
하지만 I도 증가시켜야 합니다. 자,

2254
00:49:12,190 --> 00:49:12,200
하지만 I도 증가시켜야 합니다. 자,
 

2255
00:49:12,200 --> 00:49:15,870
하지만 I도 증가시켜야 합니다. 자,
이 알고리즘은 무엇을 할까요?

2256
00:49:15,870 --> 00:49:15,880
이 알고리즘은 무엇을 할까요?
 

2257
00:49:15,880 --> 00:49:17,589
이 알고리즘은 무엇을 할까요?
한 번에 하나의 레벨 세트를 구축하는 것입니다.

2258
00:49:17,589 --> 00:49:17,599
한 번에 하나의 레벨 세트를 구축하는 것입니다.
 

2259
00:49:17,599 --> 00:49:19,950
한 번에 하나의 레벨 세트를 구축하는 것입니다.
그림으로 돌아가서,

2260
00:49:19,950 --> 00:49:19,960
그림으로 돌아가서,
 

2261
00:49:19,960 --> 00:49:22,270
그림으로 돌아가서,
l0을 시작 정점으로 초기화합니다. 그런 다음 l0에서

2262
00:49:22,270 --> 00:49:24,549
l0을 시작 정점으로 초기화합니다. 그런 다음 l0에서
 

2263
00:49:24,549 --> 00:49:24,559

 

2264
00:49:24,559 --> 00:49:26,150

나오는 모든 간선을 살펴봅니다. 이 경우 간선이 하나뿐이므로 길이가 1이 됩니다. 이런 식으로 계속됩니다. 따라서 이

2265
00:49:26,150 --> 00:49:27,470
나오는 모든 간선을 살펴봅니다. 이 경우 간선이 하나뿐이므로 길이가 1이 됩니다. 이런 식으로 계속됩니다. 따라서 이
 

2266
00:49:27,470 --> 00:49:30,270

 

2267
00:49:30,270 --> 00:49:31,390

 

2268
00:49:31,390 --> 00:49:33,470

 

2269
00:49:33,470 --> 00:49:34,710

 

2270
00:49:34,710 --> 00:49:34,720

 

2271
00:49:34,720 --> 00:49:36,910

알고리즘은 레벨 세트를 점진적으로 구축합니다. 이 알고리즘이

2272
00:49:36,910 --> 00:49:36,920
알고리즘은 레벨 세트를 점진적으로 구축합니다. 이 알고리즘이
 

2273
00:49:36,920 --> 00:49:39,390
알고리즘은 레벨 세트를 점진적으로 구축합니다. 이 알고리즘이
L, P, Delta 값을 정확하게 계산한다는 것을 귀납법으로 쉽게 증명할 수 있습니다. 이

2274
00:49:39,390 --> 00:49:39,400
L, P, Delta 값을 정확하게 계산한다는 것을 귀납법으로 쉽게 증명할 수 있습니다. 이
 

2275
00:49:39,400 --> 00:49:40,950
L, P, Delta 값을 정확하게 계산한다는 것을 귀납법으로 쉽게 증명할 수 있습니다. 이
모든 정보는

2276
00:49:40,950 --> 00:49:43,430
모든 정보는
 

2277
00:49:43,430 --> 00:49:43,440

 

2278
00:49:43,440 --> 00:49:45,030

최단 경로를 계산하는 데 필요합니다. 귀납적 증명 연습이 더

2279
00:49:45,030 --> 00:49:46,510
최단 경로를 계산하는 데 필요합니다. 귀납적 증명 연습이 더
 

2280
00:49:46,510 --> 00:49:46,520

 

2281
00:49:46,520 --> 00:49:48,710

필요하면 수업 시간에 직접 해보세요.

2282
00:49:48,710 --> 00:49:48,720
필요하면 수업 시간에 직접 해보세요.
 

2283
00:49:48,720 --> 00:49:51,750
필요하면 수업 시간에 직접 해보세요.
마지막으로

2284
00:49:51,750 --> 00:49:53,549
마지막으로
 

2285
00:49:53,549 --> 00:49:53,559

 

2286
00:49:53,559 --> 00:49:56,030

이 알고리즘의 실행 시간을 확인해 보겠습니다. 마지막에 잠깐

2287
00:49:56,030 --> 00:49:57,990
이 알고리즘의 실행 시간을 확인해 보겠습니다. 마지막에 잠깐
 

2288
00:49:57,990 --> 00:49:58,000

 

2289
00:49:58,000 --> 00:50:01,630

보여드리겠습니다.

2290
00:50:01,630 --> 00:50:01,640
보여드리겠습니다.
 

2291
00:50:01,640 --> 00:50:02,950
보여드리겠습니다.
먼저

2292
00:50:02,950 --> 00:50:02,960
먼저
 

2293
00:50:02,960 --> 00:50:06,430
먼저
제가 뭔가 실수를 했네요. 아, 이런.

2294
00:50:06,430 --> 00:50:06,440
제가 뭔가 실수를 했네요. 아, 이런.
 

2295
00:50:06,440 --> 00:50:09,470
제가 뭔가 실수를 했네요. 아, 이런.
괜찮아요. 제 알고리즘에서

2296
00:50:09,470 --> 00:50:09,480
괜찮아요. 제 알고리즘에서
 

2297
00:50:09,480 --> 00:50:10,829
괜찮아요. 제 알고리즘에서
0단계에 정점 개수와

2298
00:50:10,829 --> 00:50:10,839
0단계에 정점 개수와
 

2299
00:50:10,839 --> 00:50:12,510
0단계에 정점 개수와
같은 크기의 배열을 만들어야 했어요.

2300
00:50:12,510 --> 00:50:13,630
같은 크기의 배열을 만들어야 했어요.
 

2301
00:50:13,630 --> 00:50:13,640

 

2302
00:50:13,640 --> 00:50:16,829

66에서 기억하시죠?

2303
00:50:16,829 --> 00:50:19,150
66에서 기억하시죠?
 

2304
00:50:19,150 --> 00:50:19,160

 

2305
00:50:19,160 --> 00:50:21,270

메모리 할당에 얼마나 시간이 걸릴까요? 네, 할당한

2306
00:50:21,270 --> 00:50:21,280
메모리 할당에 얼마나 시간이 걸릴까요? 네, 할당한
 

2307
00:50:21,280 --> 00:50:22,510
메모리 할당에 얼마나 시간이 걸릴까요? 네, 할당한
메모리 양에 비례하는 시간이 걸립니다. 그렇죠? 벌써부터 걱정되시겠지만 시간이 부족하니

2308
00:50:22,510 --> 00:50:23,390
메모리 양에 비례하는 시간이 걸립니다. 그렇죠? 벌써부터 걱정되시겠지만 시간이 부족하니
 

2309
00:50:23,390 --> 00:50:25,789

 

2310
00:50:25,789 --> 00:50:27,190

 

2311
00:50:27,190 --> 00:50:27,200

 

2312
00:50:27,200 --> 00:50:29,670

끝까지 가보도록 하죠. 이미

2313
00:50:29,670 --> 00:50:29,680
끝까지 가보도록 하죠. 이미
 

2314
00:50:29,680 --> 00:50:31,789
끝까지 가보도록 하죠. 이미
V 시간이 소요됐어요.

2315
00:50:31,789 --> 00:50:31,799
V 시간이 소요됐어요.
 

2316
00:50:31,799 --> 00:50:34,789
V 시간이 소요됐어요.
최단 경로 배열이 V 공간을 차지하기 때문이죠. 게다가

2317
00:50:34,789 --> 00:50:37,150
최단 경로 배열이 V 공간을 차지하기 때문이죠. 게다가
 

2318
00:50:37,150 --> 00:50:37,160

 

2319
00:50:37,160 --> 00:50:41,030

모든 노드에 대해 이웃 노드를 모두 방문해야 하는 복잡한 for 루프도 있어요.

2320
00:50:41,030 --> 00:50:43,549
모든 노드에 대해 이웃 노드를 모두 방문해야 하는 복잡한 for 루프도 있어요.
 

2321
00:50:43,549 --> 00:50:43,559

 

2322
00:50:43,559 --> 00:50:45,750

우선, 같은

2323
00:50:45,750 --> 00:50:45,760
우선, 같은
 

2324
00:50:45,760 --> 00:50:48,230
우선, 같은
노드를 두 번 볼 수 있을까요?

2325
00:50:48,230 --> 00:50:48,240
노드를 두 번 볼 수 있을까요?
 

2326
00:50:48,240 --> 00:50:50,990
노드를 두 번 볼 수 있을까요?
아니죠. 거리에 따라 이동하니까요.

2327
00:50:50,990 --> 00:50:51,000
아니죠. 거리에 따라 이동하니까요.
 

2328
00:50:51,000 --> 00:50:53,349
아니죠. 거리에 따라 이동하니까요.
그리고

2329
00:50:53,349 --> 00:50:53,359
그리고
 

2330
00:50:53,359 --> 00:50:55,030
그리고
한 단계에서 본 노드는

2331
00:50:55,030 --> 00:50:55,040
한 단계에서 본 노드는
 

2332
00:50:55,040 --> 00:50:56,309
한 단계에서 본 노드는
다른 단계에서 볼 수 없어요. 이게

2333
00:50:56,309 --> 00:50:56,319
다른 단계에서 볼 수 없어요. 이게
 

2334
00:50:56,319 --> 00:50:57,870
다른 단계에서 볼 수 없어요. 이게
기본적인 구조죠. 다행히도

2335
00:50:57,870 --> 00:51:01,109
기본적인 구조죠. 다행히도
 

2336
00:51:01,109 --> 00:51:02,630

 

2337
00:51:02,630 --> 00:51:02,640

 

2338
00:51:02,640 --> 00:51:04,270

필요한 공식을 이미 증명했고, 제가 지우지 않았다면 다행이네요. 자,

2339
00:51:04,270 --> 00:51:04,280
필요한 공식을 이미 증명했고, 제가 지우지 않았다면 다행이네요. 자,
 

2340
00:51:04,280 --> 00:51:06,030
필요한 공식을 이미 증명했고, 제가 지우지 않았다면 다행이네요. 자,
여기 있어요.

2341
00:51:06,030 --> 00:51:06,040
여기 있어요.
 

2342
00:51:06,040 --> 00:51:08,430
여기 있어요.
이게

2343
00:51:08,430 --> 00:51:08,440
이게
 

2344
00:51:08,440 --> 00:51:10,829
이게
바로 우리가 원하는 시나리오입니다.  맞습니다.

2345
00:51:10,829 --> 00:51:10,839
바로 우리가 원하는 시나리오입니다.  맞습니다.
 

2346
00:51:10,839 --> 00:51:12,670
바로 우리가 원하는 시나리오입니다.  맞습니다.
왜냐하면 우리는

2347
00:51:12,670 --> 00:51:12,680
왜냐하면 우리는
 

2348
00:51:12,680 --> 00:51:15,270
왜냐하면 우리는
그래프의 모든 노드를 순회하고,

2349
00:51:15,270 --> 00:51:15,280
그래프의 모든 노드를 순회하고,
 

2350
00:51:15,280 --> 00:51:16,710
그래프의 모든 노드를 순회하고,
그 노드들의 이웃 노드들을 순회했기 때문입니다.

2351
00:51:16,710 --> 00:51:16,720
그 노드들의 이웃 노드들을 순회했기 때문입니다.
 

2352
00:51:16,720 --> 00:51:18,390
그 노드들의 이웃 노드들을 순회했기 때문입니다.
이것이

2353
00:51:18,390 --> 00:51:18,400
이것이
 

2354
00:51:18,400 --> 00:51:20,109
이것이
우리 알고리즘의 기본적인 계산 시간입니다.

2355
00:51:20,109 --> 00:51:20,119
우리 알고리즘의 기본적인 계산 시간입니다.
 

2356
00:51:20,119 --> 00:51:21,789
우리 알고리즘의 기본적인 계산 시간입니다.

2357
00:51:21,789 --> 00:51:21,799

 

2358
00:51:21,799 --> 00:51:24,230

따라서 for 루프, 또는

2359
00:51:24,230 --> 00:51:24,240
따라서 for 루프, 또는
 

2360
00:51:24,240 --> 00:51:26,950
따라서 for 루프, 또는
제 코드에서는 while 루프가 간선의 개수에 비례하는 시간을 발생시킵니다.

2361
00:51:26,950 --> 00:51:28,510
제 코드에서는 while 루프가 간선의 개수에 비례하는 시간을 발생시킵니다.
 

2362
00:51:28,510 --> 00:51:28,520

 

2363
00:51:28,520 --> 00:51:31,750

그렇다면 너비 우선 탐색의 총 실행 시간은 얼마일까요? 먼저

2364
00:51:31,750 --> 00:51:34,430
그렇다면 너비 우선 탐색의 총 실행 시간은 얼마일까요? 먼저
 

2365
00:51:34,430 --> 00:51:35,630

 

2366
00:51:35,630 --> 00:51:35,640

 

2367
00:51:35,640 --> 00:51:37,950

배열을 구성해야 합니다. 0단계에서만

2368
00:51:37,950 --> 00:51:37,960
배열을 구성해야 합니다. 0단계에서만
 

2369
00:51:37,960 --> 00:51:41,990
배열을 구성해야 합니다. 0단계에서만
V 시간을 계산했고, 그 다음에는

2370
00:51:41,990 --> 00:51:43,390
V 시간을 계산했고, 그 다음에는
 

2371
00:51:43,390 --> 00:51:43,400

 

2372
00:51:43,400 --> 00:51:45,950

간선의 개수만큼의 시간을 소모하는 작업을 반복해야 합니다. 따라서 전체

2373
00:51:45,950 --> 00:51:45,960
간선의 개수만큼의 시간을 소모하는 작업을 반복해야 합니다. 따라서 전체
 

2374
00:51:45,960 --> 00:51:51,230
간선의 개수만큼의 시간을 소모하는 작업을 반복해야 합니다. 따라서 전체
알고리즘의 실행 시간은 V를 법으로 하는 빅 O에 E를 법으로 하는

2375
00:51:51,230 --> 00:51:51,240
알고리즘의 실행 시간은 V를 법으로 하는 빅 O에 E를 법으로 하는
 

2376
00:51:51,240 --> 00:51:53,789
알고리즘의 실행 시간은 V를 법으로 하는 빅 O에 E를 법으로 하는

2377
00:51:53,789 --> 00:51:53,799

 

2378
00:51:53,799 --> 00:51:56,190

시간 복잡도를 더한 값입니다. 이 부분이

2379
00:51:56,190 --> 00:51:56,200
시간 복잡도를 더한 값입니다. 이 부분이
 

2380
00:51:56,200 --> 00:51:57,630
시간 복잡도를 더한 값입니다. 이 부분이
다소 중복된다고 생각할 수도 있지만,

2381
00:51:57,630 --> 00:51:59,589
다소 중복된다고 생각할 수도 있지만,
 

2382
00:51:59,589 --> 00:51:59,599

 

2383
00:51:59,599 --> 00:52:00,750

이 수업에서는

2384
00:52:00,750 --> 00:52:00,760
이 수업에서는
 

2385
00:52:00,760 --> 00:52:02,309
이 수업에서는
이 알고리즘을 선형 시간 알고리즘이라고 부릅니다.

2386
00:52:02,309 --> 00:52:03,950
이 알고리즘을 선형 시간 알고리즘이라고 부릅니다.
 

2387
00:52:03,950 --> 00:52:03,960

 

2388
00:52:03,960 --> 00:52:06,150

그래프를 저장하는 데 사용하는 공간에 대해 선형적이기 때문입니다.

2389
00:52:06,150 --> 00:52:06,160
그래프를 저장하는 데 사용하는 공간에 대해 선형적이기 때문입니다.
 

2390
00:52:06,160 --> 00:52:07,789
그래프를 저장하는 데 사용하는 공간에 대해 선형적이기 때문입니다.
개인적으로는

2391
00:52:07,789 --> 00:52:07,799
개인적으로는
 

2392
00:52:07,799 --> 00:52:09,829
개인적으로는
이 알고리즘이 V에 대해 제곱으로 증가할 수도 있다고 생각

2393
00:52:09,829 --> 00:52:09,839
이 알고리즘이 V에 대해 제곱으로 증가할 수도 있다고 생각
 

2394
00:52:09,839 --> 00:52:11,230
이 알고리즘이 V에 대해 제곱으로 증가할 수도 있다고 생각
하지만, 어쨌든

2395
00:52:11,230 --> 00:52:14,870
하지만, 어쨌든
 

2396
00:52:14,870 --> 00:52:14,880

 

2397
00:52:14,880 --> 00:52:17,190

이 두 가지 항이 모두 필요한 이유는 무엇일까요?

2398
00:52:17,190 --> 00:52:17,200
이 두 가지 항이 모두 필요한 이유는 무엇일까요?
 

2399
00:52:17,200 --> 00:52:18,349
이 두 가지 항이 모두 필요한 이유는 무엇일까요?

2400
00:52:18,349 --> 00:52:18,359

 

2401
00:52:18,359 --> 00:52:21,470

만약

2402
00:52:21,470 --> 00:52:21,480
만약
 

2403
00:52:21,480 --> 00:52:24,230
만약
제 그래프에 간선이 하나도 없다면 어떻게 될까요?  지금은 이 항이

2404
00:52:24,230 --> 00:52:24,240
제 그래프에 간선이 하나도 없다면 어떻게 될까요?  지금은 이 항이
 

2405
00:52:24,240 --> 00:52:26,990
제 그래프에 간선이 하나도 없다면 어떻게 될까요?  지금은 이 항이
지배적이지만,

2406
00:52:26,990 --> 00:52:27,000
지배적이지만,
 

2407
00:52:27,000 --> 00:52:29,349
지배적이지만,
그래프에 a를 추가하면 이 값이

2408
00:52:29,349 --> 00:52:29,359
그래프에 a를 추가하면 이 값이
 

2409
00:52:29,359 --> 00:52:31,390
그래프에 a를 추가하면 이 값이
v²까지 올라갈 수 있습니다. 따라서 단순히 "최악의 경우 v² 시간입니다"라고

2410
00:52:31,390 --> 00:52:31,400
v²까지 올라갈 수 있습니다. 따라서 단순히 "최악의 경우 v² 시간입니다"라고
 

2411
00:52:31,400 --> 00:52:33,069
v²까지 올라갈 수 있습니다. 따라서 단순히 "최악의 경우 v² 시간입니다"라고
말하는 것보다 이 표현이 더 유용한 정보를 제공합니다.

2412
00:52:33,069 --> 00:52:35,150
말하는 것보다 이 표현이 더 유용한 정보를 제공합니다.
 

2413
00:52:35,150 --> 00:52:35,160

 

2414
00:52:35,160 --> 00:52:36,910

이해가 되시나요? 이 공식이 조금 더 낫습니다. 자, 이렇게 해서

2415
00:52:36,910 --> 00:52:36,920
이해가 되시나요? 이 공식이 조금 더 낫습니다. 자, 이렇게 해서
 

2416
00:52:36,920 --> 00:52:39,230
이해가 되시나요? 이 공식이 조금 더 낫습니다. 자, 이렇게 해서
우리는 간신히

2417
00:52:39,230 --> 00:52:39,240
우리는 간신히
 

2418
00:52:39,240 --> 00:52:40,710
우리는 간신히
결승선에 도착했습니다.

2419
00:52:40,710 --> 00:52:40,720
결승선에 도착했습니다.
 

2420
00:52:40,720 --> 00:52:42,270
결승선에 도착했습니다.
최단 경로를 계산하는 알고리즘을 완성했습니다. 그럼

2421
00:52:42,270 --> 00:52:45,069
최단 경로를 계산하는 알고리즘을 완성했습니다. 그럼
 

2422
00:52:45,069 --> 00:52:45,079

 

2423
00:52:45,079 --> 00:52:48,359

화요일에 다시 뵙겠습니다.

