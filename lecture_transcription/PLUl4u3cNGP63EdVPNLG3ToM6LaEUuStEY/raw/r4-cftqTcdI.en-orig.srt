1
00:00:12,639 --> 00:00:15,190

all right welcome back to double-oh-six

2
00:00:15,190 --> 00:00:15,200
all right welcome back to double-oh-six
 

3
00:00:15,200 --> 00:00:17,750
all right welcome back to double-oh-six
today we start a totally new section of

4
00:00:17,750 --> 00:00:17,760
today we start a totally new section of
 

5
00:00:17,760 --> 00:00:18,710
today we start a totally new section of
the class

6
00:00:18,710 --> 00:00:18,720
the class
 

7
00:00:18,720 --> 00:00:21,189
the class
up till now we've mostly been showing

8
00:00:21,189 --> 00:00:21,199
up till now we've mostly been showing
 

9
00:00:21,199 --> 00:00:22,870
up till now we've mostly been showing
you really cool and powerful

10
00:00:22,870 --> 00:00:22,880
you really cool and powerful
 

11
00:00:22,880 --> 00:00:26,150
you really cool and powerful
algorithms sorting algorithms graph

12
00:00:26,150 --> 00:00:26,160
algorithms sorting algorithms graph
 

13
00:00:26,160 --> 00:00:28,310
algorithms sorting algorithms graph
algorithms data structures trees

14
00:00:28,310 --> 00:00:28,320
algorithms data structures trees
 

15
00:00:28,320 --> 00:00:30,070
algorithms data structures trees
lots of good stuff that you can apply to

16
00:00:30,070 --> 00:00:30,080
lots of good stuff that you can apply to
 

17
00:00:30,080 --> 00:00:31,910
lots of good stuff that you can apply to
solve tons of algorithmic problems

18
00:00:31,910 --> 00:00:31,920
solve tons of algorithmic problems
 

19
00:00:31,920 --> 00:00:33,670
solve tons of algorithmic problems
either by reducing to the

20
00:00:33,670 --> 00:00:33,680
either by reducing to the
 

21
00:00:33,680 --> 00:00:36,470
either by reducing to the
things data structures that we we showed

22
00:00:36,470 --> 00:00:36,480
things data structures that we we showed
 

23
00:00:36,480 --> 00:00:38,150
things data structures that we we showed
you or reducing to the graph problems

24
00:00:38,150 --> 00:00:38,160
you or reducing to the graph problems
 

25
00:00:38,160 --> 00:00:39,350
you or reducing to the graph problems
that we showed you

26
00:00:39,350 --> 00:00:39,360
that we showed you
 

27
00:00:39,360 --> 00:00:41,830
that we showed you
or by modifying those algorithms a bit

28
00:00:41,830 --> 00:00:41,840
or by modifying those algorithms a bit
 

29
00:00:41,840 --> 00:00:43,190
or by modifying those algorithms a bit
today we're going to start a

30
00:00:43,190 --> 00:00:43,200
today we're going to start a
 

31
00:00:43,200 --> 00:00:46,549
today we're going to start a
new section on algorithmic design how to

32
00:00:46,549 --> 00:00:46,559
new section on algorithmic design how to
 

33
00:00:46,559 --> 00:00:48,790
new section on algorithmic design how to
from scratch come up with a polynomial

34
00:00:48,790 --> 00:00:48,800
from scratch come up with a polynomial
 

35
00:00:48,800 --> 00:00:50,950
from scratch come up with a polynomial
time algorithm to solve a problem

36
00:00:50,950 --> 00:00:50,960
time algorithm to solve a problem
 

37
00:00:50,960 --> 00:00:53,670
time algorithm to solve a problem
so this is a and in particular we're

38
00:00:53,670 --> 00:00:53,680
so this is a and in particular we're
 

39
00:00:53,680 --> 00:00:54,790
so this is a and in particular we're
going to talk about

40
00:00:54,790 --> 00:00:54,800
going to talk about
 

41
00:00:54,800 --> 00:00:57,189
going to talk about
a algorithmic design paradigm called

42
00:00:57,189 --> 00:00:57,199
a algorithmic design paradigm called
 

43
00:00:57,199 --> 00:00:58,549
a algorithmic design paradigm called
dynamic programming

44
00:00:58,549 --> 00:00:58,559
dynamic programming
 

45
00:00:58,559 --> 00:01:00,150
dynamic programming
which is extremely powerful it's

46
00:01:00,150 --> 00:01:00,160
which is extremely powerful it's
 

47
00:01:00,160 --> 00:01:01,990
which is extremely powerful it's
probably the most powerful algorithmic

48
00:01:01,990 --> 00:01:02,000
probably the most powerful algorithmic
 

49
00:01:02,000 --> 00:01:03,590
probably the most powerful algorithmic
design paradigm very general

50
00:01:03,590 --> 00:01:03,600
design paradigm very general
 

51
00:01:03,600 --> 00:01:06,870
design paradigm very general
can solve lots of problems it's a

52
00:01:06,870 --> 00:01:06,880
can solve lots of problems it's a
 

53
00:01:06,880 --> 00:01:09,910
can solve lots of problems it's a
particular type of recursive algorithm

54
00:01:09,910 --> 00:01:09,920
particular type of recursive algorithm
 

55
00:01:09,920 --> 00:01:10,789
particular type of recursive algorithm
design

56
00:01:10,789 --> 00:01:10,799
design
 

57
00:01:10,799 --> 00:01:14,070
design
and in general this class

58
00:01:14,070 --> 00:01:14,080
and in general this class
 

59
00:01:14,080 --> 00:01:16,310
and in general this class
all of algorithms is about recursive

60
00:01:16,310 --> 00:01:16,320
all of algorithms is about recursive
 

61
00:01:16,320 --> 00:01:17,190
all of algorithms is about recursive
algorithm design

62
00:01:17,190 --> 00:01:17,200
algorithm design
 

63
00:01:17,200 --> 00:01:19,910
algorithm design
at some level because we want to write

64
00:01:19,910 --> 00:01:19,920
at some level because we want to write
 

65
00:01:19,920 --> 00:01:21,670
at some level because we want to write
constant size pieces of code

66
00:01:21,670 --> 00:01:21,680
constant size pieces of code
 

67
00:01:21,680 --> 00:01:23,830
constant size pieces of code
that solve problems of arbitrary size we

68
00:01:23,830 --> 00:01:23,840
that solve problems of arbitrary size we
 

69
00:01:23,840 --> 00:01:24,789
that solve problems of arbitrary size we
have some problem size

70
00:01:24,789 --> 00:01:24,799
have some problem size
 

71
00:01:24,799 --> 00:01:27,030
have some problem size
n and we're trying to write you know 100

72
00:01:27,030 --> 00:01:27,040
n and we're trying to write you know 100
 

73
00:01:27,040 --> 00:01:28,630
n and we're trying to write you know 100
lines of code or whatever some constant

74
00:01:28,630 --> 00:01:28,640
lines of code or whatever some constant
 

75
00:01:28,640 --> 00:01:29,830
lines of code or whatever some constant
amount that doesn't depend on the

76
00:01:29,830 --> 00:01:29,840
amount that doesn't depend on the
 

77
00:01:29,840 --> 00:01:31,830
amount that doesn't depend on the
problem size we have one algorithm that

78
00:01:31,830 --> 00:01:31,840
problem size we have one algorithm that
 

79
00:01:31,840 --> 00:01:33,350
problem size we have one algorithm that
solves all

80
00:01:33,350 --> 00:01:33,360
solves all
 

81
00:01:33,360 --> 00:01:35,510
solves all
instances of the problem and so we have

82
00:01:35,510 --> 00:01:35,520
instances of the problem and so we have
 

83
00:01:35,520 --> 00:01:36,789
instances of the problem and so we have
to write code

84
00:01:36,789 --> 00:01:36,799
to write code
 

85
00:01:36,799 --> 00:01:39,350
to write code
that is recursive or uses loops or

86
00:01:39,350 --> 00:01:39,360
that is recursive or uses loops or
 

87
00:01:39,360 --> 00:01:41,190
that is recursive or uses loops or
somehow reuses the instructions that we

88
00:01:41,190 --> 00:01:41,200
somehow reuses the instructions that we
 

89
00:01:41,200 --> 00:01:43,270
somehow reuses the instructions that we
give the computer

90
00:01:43,270 --> 00:01:43,280
give the computer
 

91
00:01:43,280 --> 00:01:45,270
give the computer
and you may know you can convert any

92
00:01:45,270 --> 00:01:45,280
and you may know you can convert any
 

93
00:01:45,280 --> 00:01:46,870
and you may know you can convert any
algorithm based on loops into an

94
00:01:46,870 --> 00:01:46,880
algorithm based on loops into an
 

95
00:01:46,880 --> 00:01:47,510
algorithm based on loops into an
algorithm

96
00:01:47,510 --> 00:01:47,520
algorithm
 

97
00:01:47,520 --> 00:01:49,590
algorithm
using recursion and we're going to take

98
00:01:49,590 --> 00:01:49,600
using recursion and we're going to take
 

99
00:01:49,600 --> 00:01:51,190
using recursion and we're going to take
the recursive view today

100
00:01:51,190 --> 00:01:51,200
the recursive view today
 

101
00:01:51,200 --> 00:01:53,030
the recursive view today
in particular because it fits very well

102
00:01:53,030 --> 00:01:53,040
in particular because it fits very well
 

103
00:01:53,040 --> 00:01:55,109
in particular because it fits very well
with our proof by induction

104
00:01:55,109 --> 00:01:55,119
with our proof by induction
 

105
00:01:55,119 --> 00:01:56,469
with our proof by induction
technique which we've used throughout

106
00:01:56,469 --> 00:01:56,479
technique which we've used throughout
 

107
00:01:56,479 --> 00:01:58,230
technique which we've used throughout
this class

108
00:01:58,230 --> 00:01:58,240
this class
 

109
00:01:58,240 --> 00:02:00,630
this class
but also because it gives us some

110
00:02:00,630 --> 00:02:00,640
but also because it gives us some
 

111
00:02:00,640 --> 00:02:02,069
but also because it gives us some
structure on how

112
00:02:02,069 --> 00:02:02,079
structure on how
 

113
00:02:02,079 --> 00:02:03,749
structure on how
different subproblems relate in

114
00:02:03,749 --> 00:02:03,759
different subproblems relate in
 

115
00:02:03,759 --> 00:02:05,670
different subproblems relate in
something called a sub problem graph

116
00:02:05,670 --> 00:02:05,680
something called a sub problem graph
 

117
00:02:05,680 --> 00:02:08,550
something called a sub problem graph
that we'll be talking about today

118
00:02:08,550 --> 00:02:08,560
that we'll be talking about today
 

119
00:02:08,560 --> 00:02:10,150
that we'll be talking about today
and so we're going to start out with in

120
00:02:10,150 --> 00:02:10,160
and so we're going to start out with in
 

121
00:02:10,160 --> 00:02:12,229
and so we're going to start out with in
general how do we design recursive

122
00:02:12,229 --> 00:02:12,239
general how do we design recursive
 

123
00:02:12,239 --> 00:02:13,270
general how do we design recursive
algorithms

124
00:02:13,270 --> 00:02:13,280
algorithms
 

125
00:02:13,280 --> 00:02:15,589
algorithms
that's sort of the overall encompassing

126
00:02:15,589 --> 00:02:15,599
that's sort of the overall encompassing
 

127
00:02:15,599 --> 00:02:17,430
that's sort of the overall encompassing
everything we have

128
00:02:17,430 --> 00:02:17,440
everything we have
 

129
00:02:17,440 --> 00:02:19,350
everything we have
thought very hard to come up with a cool

130
00:02:19,350 --> 00:02:19,360
thought very hard to come up with a cool
 

131
00:02:19,360 --> 00:02:20,869
thought very hard to come up with a cool
acronym for this paradigm

132
00:02:20,869 --> 00:02:20,879
acronym for this paradigm
 

133
00:02:20,879 --> 00:02:23,670
acronym for this paradigm
which we invented called sort bot thanks

134
00:02:23,670 --> 00:02:23,680
which we invented called sort bot thanks
 

135
00:02:23,680 --> 00:02:25,350
which we invented called sort bot thanks
jason

136
00:02:25,350 --> 00:02:25,360
jason
 

137
00:02:25,360 --> 00:02:27,190
jason
and so we'll talk it's not actually for

138
00:02:27,190 --> 00:02:27,200
and so we'll talk it's not actually for
 

139
00:02:27,200 --> 00:02:29,589
and so we'll talk it's not actually for
sorting it's just an acronym for

140
00:02:29,589 --> 00:02:29,599
sorting it's just an acronym for
 

141
00:02:29,599 --> 00:02:32,710
sorting it's just an acronym for
subproblems

142
00:02:32,710 --> 00:02:32,720

 

143
00:02:32,720 --> 00:02:36,070

relations topological order base case

144
00:02:36,070 --> 00:02:36,080
relations topological order base case
 

145
00:02:36,080 --> 00:02:39,430
relations topological order base case
original problem and time but it's an

146
00:02:39,430 --> 00:02:39,440
original problem and time but it's an
 

147
00:02:39,440 --> 00:02:40,070
original problem and time but it's an
acronym that

148
00:02:40,070 --> 00:02:40,080
acronym that
 

149
00:02:40,080 --> 00:02:43,670
acronym that
will help you remember all the steps you

150
00:02:43,670 --> 00:02:43,680
will help you remember all the steps you
 

151
00:02:43,680 --> 00:02:45,270
will help you remember all the steps you
need in order to specify a recursive

152
00:02:45,270 --> 00:02:45,280
need in order to specify a recursive
 

153
00:02:45,280 --> 00:02:45,990
need in order to specify a recursive
algorithm

154
00:02:45,990 --> 00:02:46,000
algorithm
 

155
00:02:46,000 --> 00:02:47,430
algorithm
and dynamic programming is going to

156
00:02:47,430 --> 00:02:47,440
and dynamic programming is going to
 

157
00:02:47,440 --> 00:02:50,070
and dynamic programming is going to
build on this template

158
00:02:50,070 --> 00:02:50,080
build on this template
 

159
00:02:50,080 --> 00:02:52,150
build on this template
by adding one new idea called

160
00:02:52,150 --> 00:02:52,160
by adding one new idea called
 

161
00:02:52,160 --> 00:02:54,229
by adding one new idea called
memoization which is just the idea of

162
00:02:54,229 --> 00:02:54,239
memoization which is just the idea of
 

163
00:02:54,239 --> 00:02:56,869
memoization which is just the idea of
reusing work that you've done before

164
00:02:56,869 --> 00:02:56,879
reusing work that you've done before
 

165
00:02:56,879 --> 00:02:58,630
reusing work that you've done before
and that's going to let us solve tons of

166
00:02:58,630 --> 00:02:58,640
and that's going to let us solve tons of
 

167
00:02:58,640 --> 00:03:00,229
and that's going to let us solve tons of
problems

168
00:03:00,229 --> 00:03:00,239
problems
 

169
00:03:00,239 --> 00:03:03,910
problems
and let's see i don't uh

170
00:03:03,910 --> 00:03:03,920
and let's see i don't uh
 

171
00:03:03,920 --> 00:03:07,190
and let's see i don't uh
let's get into it so we'll start out

172
00:03:07,190 --> 00:03:07,200
let's get into it so we'll start out
 

173
00:03:07,200 --> 00:03:10,390
let's get into it so we'll start out
today with sort bots so here is sort

174
00:03:10,390 --> 00:03:10,400
today with sort bots so here is sort
 

175
00:03:10,400 --> 00:03:13,750
today with sort bots so here is sort
bot down the column here this is a

176
00:03:13,750 --> 00:03:13,760
bot down the column here this is a
 

177
00:03:13,760 --> 00:03:16,309
bot down the column here this is a
recursive algorithm design paradigm

178
00:03:16,309 --> 00:03:16,319
recursive algorithm design paradigm
 

179
00:03:16,319 --> 00:03:18,149
recursive algorithm design paradigm
and in general what we're going to do is

180
00:03:18,149 --> 00:03:18,159
and in general what we're going to do is
 

181
00:03:18,159 --> 00:03:19,750
and in general what we're going to do is
take the problem that we actually want

182
00:03:19,750 --> 00:03:19,760
take the problem that we actually want
 

183
00:03:19,760 --> 00:03:20,470
take the problem that we actually want
to solve

184
00:03:20,470 --> 00:03:20,480
to solve
 

185
00:03:20,480 --> 00:03:23,030
to solve
and split it up into lots of possible

186
00:03:23,030 --> 00:03:23,040
and split it up into lots of possible
 

187
00:03:23,040 --> 00:03:24,149
and split it up into lots of possible
sub problems

188
00:03:24,149 --> 00:03:24,159
sub problems
 

189
00:03:24,159 --> 00:03:26,309
sub problems
and so the first part is to define what

190
00:03:26,309 --> 00:03:26,319
and so the first part is to define what
 

191
00:03:26,319 --> 00:03:28,149
and so the first part is to define what
the heck are the sub problems in general

192
00:03:28,149 --> 00:03:28,159
the heck are the sub problems in general
 

193
00:03:28,159 --> 00:03:29,830
the heck are the sub problems in general
we'll want some polynomial number of

194
00:03:29,830 --> 00:03:29,840
we'll want some polynomial number of
 

195
00:03:29,840 --> 00:03:30,470
we'll want some polynomial number of
them

196
00:03:30,470 --> 00:03:30,480
them
 

197
00:03:30,480 --> 00:03:33,430
them
but it's pretty open-ended what these

198
00:03:33,430 --> 00:03:33,440
but it's pretty open-ended what these
 

199
00:03:33,440 --> 00:03:34,070
but it's pretty open-ended what these
look like

200
00:03:34,070 --> 00:03:34,080
look like
 

201
00:03:34,080 --> 00:03:36,070
look like
and the hardest part usually in

202
00:03:36,070 --> 00:03:36,080
and the hardest part usually in
 

203
00:03:36,080 --> 00:03:38,390
and the hardest part usually in
deceptive defining a recursive algorithm

204
00:03:38,390 --> 00:03:38,400
deceptive defining a recursive algorithm
 

205
00:03:38,400 --> 00:03:39,750
deceptive defining a recursive algorithm
is figuring out what the sub problems

206
00:03:39,750 --> 00:03:39,760
is figuring out what the sub problems
 

207
00:03:39,760 --> 00:03:40,470
is figuring out what the sub problems
should be

208
00:03:40,470 --> 00:03:40,480
should be
 

209
00:03:40,480 --> 00:03:41,750
should be
usually they're related to the problem

210
00:03:41,750 --> 00:03:41,760
usually they're related to the problem
 

211
00:03:41,760 --> 00:03:43,670
usually they're related to the problem
you want to solve often

212
00:03:43,670 --> 00:03:43,680
you want to solve often
 

213
00:03:43,680 --> 00:03:45,350
you want to solve often
the problem you want to solve this is

214
00:03:45,350 --> 00:03:45,360
the problem you want to solve this is
 

215
00:03:45,360 --> 00:03:46,949
the problem you want to solve this is
actually near the last step

216
00:03:46,949 --> 00:03:46,959
actually near the last step
 

217
00:03:46,959 --> 00:03:48,149
actually near the last step
the original problem you're trying to

218
00:03:48,149 --> 00:03:48,159
the original problem you're trying to
 

219
00:03:48,159 --> 00:03:51,350
the original problem you're trying to
solve is often one of these sub problems

220
00:03:51,350 --> 00:03:51,360
solve is often one of these sub problems
 

221
00:03:51,360 --> 00:03:52,710
solve is often one of these sub problems
and then you use the smaller sub

222
00:03:52,710 --> 00:03:52,720
and then you use the smaller sub
 

223
00:03:52,720 --> 00:03:54,390
and then you use the smaller sub
problems in order to build up

224
00:03:54,390 --> 00:03:54,400
problems in order to build up
 

225
00:03:54,400 --> 00:03:57,190
problems in order to build up
the final original problem but sometimes

226
00:03:57,190 --> 00:03:57,200
the final original problem but sometimes
 

227
00:03:57,200 --> 00:03:58,630
the final original problem but sometimes
at the end you need to

228
00:03:58,630 --> 00:03:58,640
at the end you need to
 

229
00:03:58,640 --> 00:04:00,229
at the end you need to
take a bunch of sub problems and combine

230
00:04:00,229 --> 00:04:00,239
take a bunch of sub problems and combine
 

231
00:04:00,239 --> 00:04:01,830
take a bunch of sub problems and combine
it into your original problem

232
00:04:01,830 --> 00:04:01,840
it into your original problem
 

233
00:04:01,840 --> 00:04:03,830
it into your original problem
you can think one analogy you can think

234
00:04:03,830 --> 00:04:03,840
you can think one analogy you can think
 

235
00:04:03,840 --> 00:04:06,149
you can think one analogy you can think
of here is divide and conquer algorithms

236
00:04:06,149 --> 00:04:06,159
of here is divide and conquer algorithms
 

237
00:04:06,159 --> 00:04:08,949
of here is divide and conquer algorithms
which also had this kind of style but

238
00:04:08,949 --> 00:04:08,959
which also had this kind of style but
 

239
00:04:08,959 --> 00:04:11,190
which also had this kind of style but
more generally we're going to relate

240
00:04:11,190 --> 00:04:11,200
more generally we're going to relate
 

241
00:04:11,200 --> 00:04:14,390
more generally we're going to relate
different subproblem solutions with some

242
00:04:14,390 --> 00:04:14,400
different subproblem solutions with some
 

243
00:04:14,400 --> 00:04:16,870
different subproblem solutions with some
recursive structure some recursive

244
00:04:16,870 --> 00:04:16,880
recursive structure some recursive
 

245
00:04:16,880 --> 00:04:19,030
recursive structure some recursive
recurrence relation

246
00:04:19,030 --> 00:04:19,040
recurrence relation
 

247
00:04:19,040 --> 00:04:22,069
recurrence relation
this is just a recursive algorithm that

248
00:04:22,069 --> 00:04:22,079
this is just a recursive algorithm that
 

249
00:04:22,079 --> 00:04:24,070
this is just a recursive algorithm that
defines how to solve one problem in

250
00:04:24,070 --> 00:04:24,080
defines how to solve one problem in
 

251
00:04:24,080 --> 00:04:25,830
defines how to solve one problem in
terms of smaller

252
00:04:25,830 --> 00:04:25,840
terms of smaller
 

253
00:04:25,840 --> 00:04:28,390
terms of smaller
sub-problems for some notion of smaller

254
00:04:28,390 --> 00:04:28,400
sub-problems for some notion of smaller
 

255
00:04:28,400 --> 00:04:30,390
sub-problems for some notion of smaller
and this is given by the topological

256
00:04:30,390 --> 00:04:30,400
and this is given by the topological
 

257
00:04:30,400 --> 00:04:31,030
and this is given by the topological
order

258
00:04:31,030 --> 00:04:31,040
order
 

259
00:04:31,040 --> 00:04:33,189
order
so if we think of the sub problems as a

260
00:04:33,189 --> 00:04:33,199
so if we think of the sub problems as a
 

261
00:04:33,199 --> 00:04:34,070
so if we think of the sub problems as a
graph

262
00:04:34,070 --> 00:04:34,080
graph
 

263
00:04:34,080 --> 00:04:37,510
graph
and we draw an edge between

264
00:04:37,510 --> 00:04:37,520
and we draw an edge between
 

265
00:04:37,520 --> 00:04:39,830
and we draw an edge between
so the vertices of the graph are sub

266
00:04:39,830 --> 00:04:39,840
so the vertices of the graph are sub
 

267
00:04:39,840 --> 00:04:41,590
so the vertices of the graph are sub
problems the edges are the dependencies

268
00:04:41,590 --> 00:04:41,600
problems the edges are the dependencies
 

269
00:04:41,600 --> 00:04:42,950
problems the edges are the dependencies
between those sub problems then what

270
00:04:42,950 --> 00:04:42,960
between those sub problems then what
 

271
00:04:42,960 --> 00:04:43,510
between those sub problems then what
we'd like

272
00:04:43,510 --> 00:04:43,520
we'd like
 

273
00:04:43,520 --> 00:04:45,510
we'd like
is the topological ordering the

274
00:04:45,510 --> 00:04:45,520
is the topological ordering the
 

275
00:04:45,520 --> 00:04:47,430
is the topological ordering the
topological sort problem we talked about

276
00:04:47,430 --> 00:04:47,440
topological sort problem we talked about
 

277
00:04:47,440 --> 00:04:50,870
topological sort problem we talked about
in the context of dfs or dag shortest

278
00:04:50,870 --> 00:04:50,880
in the context of dfs or dag shortest
 

279
00:04:50,880 --> 00:04:51,510
in the context of dfs or dag shortest
paths

280
00:04:51,510 --> 00:04:51,520
paths
 

281
00:04:51,520 --> 00:04:54,230
paths
uh what we would like is that this uh

282
00:04:54,230 --> 00:04:54,240
uh what we would like is that this uh
 

283
00:04:54,240 --> 00:04:56,150
uh what we would like is that this uh
the sub problems and the calls the

284
00:04:56,150 --> 00:04:56,160
the sub problems and the calls the
 

285
00:04:56,160 --> 00:04:57,749
the sub problems and the calls the
recursive calls between them in this

286
00:04:57,749 --> 00:04:57,759
recursive calls between them in this
 

287
00:04:57,759 --> 00:04:59,110
recursive calls between them in this
recursive relation

288
00:04:59,110 --> 00:04:59,120
recursive relation
 

289
00:04:59,120 --> 00:05:01,670
recursive relation
forms a dag we want it to be acyclic

290
00:05:01,670 --> 00:05:01,680
forms a dag we want it to be acyclic
 

291
00:05:01,680 --> 00:05:02,469
forms a dag we want it to be acyclic
otherwise

292
00:05:02,469 --> 00:05:02,479
otherwise
 

293
00:05:02,479 --> 00:05:04,150
otherwise
you have an infinite loop in your

294
00:05:04,150 --> 00:05:04,160
you have an infinite loop in your
 

295
00:05:04,160 --> 00:05:05,990
you have an infinite loop in your
recursive calls if you have a cycle

296
00:05:05,990 --> 00:05:06,000
recursive calls if you have a cycle
 

297
00:05:06,000 --> 00:05:09,029
recursive calls if you have a cycle
you're just go you'll never terminate

298
00:05:09,029 --> 00:05:09,039
you're just go you'll never terminate
 

299
00:05:09,039 --> 00:05:11,670
you're just go you'll never terminate
and so to spec to make sure that our

300
00:05:11,670 --> 00:05:11,680
and so to spec to make sure that our
 

301
00:05:11,680 --> 00:05:13,590
and so to spec to make sure that our
these dependencies between subproblems

302
00:05:13,590 --> 00:05:13,600
these dependencies between subproblems
 

303
00:05:13,600 --> 00:05:15,510
these dependencies between subproblems
given by this recurrence relation

304
00:05:15,510 --> 00:05:15,520
given by this recurrence relation
 

305
00:05:15,520 --> 00:05:18,070
given by this recurrence relation
is a cyclic uh one way to do that is to

306
00:05:18,070 --> 00:05:18,080
is a cyclic uh one way to do that is to
 

307
00:05:18,080 --> 00:05:20,469
is a cyclic uh one way to do that is to
specify a topological order

308
00:05:20,469 --> 00:05:20,479
specify a topological order
 

309
00:05:20,479 --> 00:05:21,749
specify a topological order
okay or you could prove it some other

310
00:05:21,749 --> 00:05:21,759
okay or you could prove it some other
 

311
00:05:21,759 --> 00:05:24,550
okay or you could prove it some other
way but often it's just a for loop

312
00:05:24,550 --> 00:05:24,560
way but often it's just a for loop
 

313
00:05:24,560 --> 00:05:27,430
way but often it's just a for loop
to say just do it in this order then of

314
00:05:27,430 --> 00:05:27,440
to say just do it in this order then of
 

315
00:05:27,440 --> 00:05:27,749
to say just do it in this order then of
course

316
00:05:27,749 --> 00:05:27,759
course
 

317
00:05:27,759 --> 00:05:30,790
course
any recursive structure needs base cases

318
00:05:30,790 --> 00:05:30,800
any recursive structure needs base cases
 

319
00:05:30,800 --> 00:05:31,189
any recursive structure needs base cases
so

320
00:05:31,189 --> 00:05:31,199
so
 

321
00:05:31,199 --> 00:05:34,070
so
that's a useful step not to forget um we

322
00:05:34,070 --> 00:05:34,080
that's a useful step not to forget um we
 

323
00:05:34,080 --> 00:05:35,430
that's a useful step not to forget um we
want to solve the original problem using

324
00:05:35,430 --> 00:05:35,440
want to solve the original problem using
 

325
00:05:35,440 --> 00:05:37,110
want to solve the original problem using
these sub problems and then we analyze

326
00:05:37,110 --> 00:05:37,120
these sub problems and then we analyze
 

327
00:05:37,120 --> 00:05:38,070
these sub problems and then we analyze
our running time

328
00:05:38,070 --> 00:05:38,080
our running time
 

329
00:05:38,080 --> 00:05:41,909
our running time
at the end so six easy steps

330
00:05:41,909 --> 00:05:41,919
at the end so six easy steps
 

331
00:05:41,919 --> 00:05:43,830
at the end so six easy steps
actually the hardest ones are these two

332
00:05:43,830 --> 00:05:43,840
actually the hardest ones are these two
 

333
00:05:43,840 --> 00:05:45,430
actually the hardest ones are these two
which are interrelated

334
00:05:45,430 --> 00:05:45,440
which are interrelated
 

335
00:05:45,440 --> 00:05:47,830
which are interrelated
and what we're going to see over the

336
00:05:47,830 --> 00:05:47,840
and what we're going to see over the
 

337
00:05:47,840 --> 00:05:49,749
and what we're going to see over the
next four lectures this is the first of

338
00:05:49,749 --> 00:05:49,759
next four lectures this is the first of
 

339
00:05:49,759 --> 00:05:51,590
next four lectures this is the first of
four lectures on dynamic programming

340
00:05:51,590 --> 00:05:51,600
four lectures on dynamic programming
 

341
00:05:51,600 --> 00:05:53,350
four lectures on dynamic programming
is lots of examples of applying this

342
00:05:53,350 --> 00:05:53,360
is lots of examples of applying this
 

343
00:05:53,360 --> 00:05:55,029
is lots of examples of applying this
paradigm over and over

344
00:05:55,029 --> 00:05:55,039
paradigm over and over
 

345
00:05:55,039 --> 00:05:57,110
paradigm over and over
together with the memoization idea which

346
00:05:57,110 --> 00:05:57,120
together with the memoization idea which
 

347
00:05:57,120 --> 00:05:58,790
together with the memoization idea which
we'll get to soon

348
00:05:58,790 --> 00:05:58,800
we'll get to soon
 

349
00:05:58,800 --> 00:06:01,510
we'll get to soon
let's see an example first of an

350
00:06:01,510 --> 00:06:01,520
let's see an example first of an
 

351
00:06:01,520 --> 00:06:03,110
let's see an example first of an
algorithm we've already seen which is

352
00:06:03,110 --> 00:06:03,120
algorithm we've already seen which is
 

353
00:06:03,120 --> 00:06:03,990
algorithm we've already seen which is
merge sort

354
00:06:03,990 --> 00:06:04,000
merge sort
 

355
00:06:04,000 --> 00:06:05,670
merge sort
so a divide and conquer algorithm

356
00:06:05,670 --> 00:06:05,680
so a divide and conquer algorithm
 

357
00:06:05,680 --> 00:06:07,270
so a divide and conquer algorithm
phrased in this

358
00:06:07,270 --> 00:06:07,280
phrased in this
 

359
00:06:07,280 --> 00:06:09,830
phrased in this
with this structure of sort bot so for

360
00:06:09,830 --> 00:06:09,840
with this structure of sort bot so for
 

361
00:06:09,840 --> 00:06:11,350
with this structure of sort bot so for
the subproblems

362
00:06:11,350 --> 00:06:11,360
the subproblems
 

363
00:06:11,360 --> 00:06:13,110
the subproblems
so original problem is to sort the

364
00:06:13,110 --> 00:06:13,120
so original problem is to sort the
 

365
00:06:13,120 --> 00:06:14,629
so original problem is to sort the
elements of a

366
00:06:14,629 --> 00:06:14,639
elements of a
 

367
00:06:14,639 --> 00:06:16,309
elements of a
and some sub problems that we solve

368
00:06:16,309 --> 00:06:16,319
and some sub problems that we solve
 

369
00:06:16,319 --> 00:06:18,790
and some sub problems that we solve
along the way are sorting different

370
00:06:18,790 --> 00:06:18,800
along the way are sorting different
 

371
00:06:18,800 --> 00:06:21,830
along the way are sorting different
subarrays of a so for every well not for

372
00:06:21,830 --> 00:06:21,840
subarrays of a so for every well not for
 

373
00:06:21,840 --> 00:06:23,189
subarrays of a so for every well not for
every i and j but for some

374
00:06:23,189 --> 00:06:23,199
every i and j but for some
 

375
00:06:23,199 --> 00:06:26,550
every i and j but for some
i and js we sort the items from

376
00:06:26,550 --> 00:06:26,560
i and js we sort the items from
 

377
00:06:26,560 --> 00:06:28,950
i and js we sort the items from
i up to j minus 1. so i'm going to

378
00:06:28,950 --> 00:06:28,960
i up to j minus 1. so i'm going to
 

379
00:06:28,960 --> 00:06:30,550
i up to j minus 1. so i'm going to
define that subproblem to be

380
00:06:30,550 --> 00:06:30,560
define that subproblem to be
 

381
00:06:30,560 --> 00:06:33,029
define that subproblem to be
s of i j so this is something that i

382
00:06:33,029 --> 00:06:33,039
s of i j so this is something that i
 

383
00:06:33,039 --> 00:06:34,629
s of i j so this is something that i
might want to solve

384
00:06:34,629 --> 00:06:34,639
might want to solve
 

385
00:06:34,639 --> 00:06:36,550
might want to solve
the original problem that i want to

386
00:06:36,550 --> 00:06:36,560
the original problem that i want to
 

387
00:06:36,560 --> 00:06:39,110
the original problem that i want to
solve is s of 0 comma n where n is the

388
00:06:39,110 --> 00:06:39,120
solve is s of 0 comma n where n is the
 

389
00:06:39,120 --> 00:06:40,230
solve is s of 0 comma n where n is the
length of the array

390
00:06:40,230 --> 00:06:40,240
length of the array
 

391
00:06:40,240 --> 00:06:42,150
length of the array
so that's what i actually care about in

392
00:06:42,150 --> 00:06:42,160
so that's what i actually care about in
 

393
00:06:42,160 --> 00:06:44,150
so that's what i actually care about in
the end but we're going to solve that

394
00:06:44,150 --> 00:06:44,160
the end but we're going to solve that
 

395
00:06:44,160 --> 00:06:46,550
the end but we're going to solve that
by writing it recursively in terms of

396
00:06:46,550 --> 00:06:46,560
by writing it recursively in terms of
 

397
00:06:46,560 --> 00:06:47,510
by writing it recursively in terms of
sorting different

398
00:06:47,510 --> 00:06:47,520
sorting different
 

399
00:06:47,520 --> 00:06:49,990
sorting different
subarrays as follows this is the

400
00:06:49,990 --> 00:06:50,000
subarrays as follows this is the
 

401
00:06:50,000 --> 00:06:51,589
subarrays as follows this is the
recurrence relation

402
00:06:51,589 --> 00:06:51,599
recurrence relation
 

403
00:06:51,599 --> 00:06:53,029
recurrence relation
i've written it very simply here of

404
00:06:53,029 --> 00:06:53,039
i've written it very simply here of
 

405
00:06:53,039 --> 00:06:55,029
i've written it very simply here of
course there's a merge algorithm

406
00:06:55,029 --> 00:06:55,039
course there's a merge algorithm
 

407
00:06:55,039 --> 00:06:57,110
course there's a merge algorithm
which is uh somewhat complicated but

408
00:06:57,110 --> 00:06:57,120
which is uh somewhat complicated but
 

409
00:06:57,120 --> 00:06:59,270
which is uh somewhat complicated but
it's we we saw the two finger

410
00:06:59,270 --> 00:06:59,280
it's we we saw the two finger
 

411
00:06:59,280 --> 00:07:02,390
it's we we saw the two finger
linear time merge algorithm given two

412
00:07:02,390 --> 00:07:02,400
linear time merge algorithm given two
 

413
00:07:02,400 --> 00:07:05,430
linear time merge algorithm given two
sorted arrays so this is supposed to be

414
00:07:05,430 --> 00:07:05,440
sorted arrays so this is supposed to be
 

415
00:07:05,440 --> 00:07:08,150
sorted arrays so this is supposed to be
the sorted array version of the items i

416
00:07:08,150 --> 00:07:08,160
the sorted array version of the items i
 

417
00:07:08,160 --> 00:07:08,870
the sorted array version of the items i
through m

418
00:07:08,870 --> 00:07:08,880
through m
 

419
00:07:08,880 --> 00:07:11,589
through m
m is the middle element between i and j

420
00:07:11,589 --> 00:07:11,599
m is the middle element between i and j
 

421
00:07:11,599 --> 00:07:11,990
m is the middle element between i and j
and

422
00:07:11,990 --> 00:07:12,000
and
 

423
00:07:12,000 --> 00:07:14,150
and
the sorted array of the items from m up

424
00:07:14,150 --> 00:07:14,160
the sorted array of the items from m up
 

425
00:07:14,160 --> 00:07:15,749
the sorted array of the items from m up
to j

426
00:07:15,749 --> 00:07:15,759
to j
 

427
00:07:15,759 --> 00:07:17,830
to j
if we merge those that gives us the

428
00:07:17,830 --> 00:07:17,840
if we merge those that gives us the
 

429
00:07:17,840 --> 00:07:18,870
if we merge those that gives us the
sorted array

430
00:07:18,870 --> 00:07:18,880
sorted array
 

431
00:07:18,880 --> 00:07:22,550
sorted array
from i up to j and that's exactly what

432
00:07:22,550 --> 00:07:22,560
from i up to j and that's exactly what
 

433
00:07:22,560 --> 00:07:23,430
from i up to j and that's exactly what
merge sort

434
00:07:23,430 --> 00:07:23,440
merge sort
 

435
00:07:23,440 --> 00:07:27,670
merge sort
does so this is in general this relation

436
00:07:27,670 --> 00:07:27,680
does so this is in general this relation
 

437
00:07:27,680 --> 00:07:30,790
does so this is in general this relation
is just some algorithm

438
00:07:30,790 --> 00:07:30,800
is just some algorithm
 

439
00:07:30,800 --> 00:07:33,270
is just some algorithm
for if you if you're given the solutions

440
00:07:33,270 --> 00:07:33,280
for if you if you're given the solutions
 

441
00:07:33,280 --> 00:07:35,270
for if you if you're given the solutions
to some smaller sub problems

442
00:07:35,270 --> 00:07:35,280
to some smaller sub problems
 

443
00:07:35,280 --> 00:07:38,629
to some smaller sub problems
how do i solve uh the sub problem that i

444
00:07:38,629 --> 00:07:38,639
how do i solve uh the sub problem that i
 

445
00:07:38,639 --> 00:07:41,589
how do i solve uh the sub problem that i
want to solve

446
00:07:41,589 --> 00:07:41,599

 

447
00:07:41,599 --> 00:07:44,150

and so we need to make sure that this

448
00:07:44,150 --> 00:07:44,160
and so we need to make sure that this
 

449
00:07:44,160 --> 00:07:45,270
and so we need to make sure that this
problem

450
00:07:45,270 --> 00:07:45,280
problem
 

451
00:07:45,280 --> 00:07:47,270
problem
is bigger than the ones that we

452
00:07:47,270 --> 00:07:47,280
is bigger than the ones that we
 

453
00:07:47,280 --> 00:07:48,469
is bigger than the ones that we
recursively call on

454
00:07:48,469 --> 00:07:48,479
recursively call on
 

455
00:07:48,479 --> 00:07:50,710
recursively call on
and that we don't get an infinite cyclic

456
00:07:50,710 --> 00:07:50,720
and that we don't get an infinite cyclic
 

457
00:07:50,720 --> 00:07:51,909
and that we don't get an infinite cyclic
group of recursions

458
00:07:51,909 --> 00:07:51,919
group of recursions
 

459
00:07:51,919 --> 00:07:53,990
group of recursions
and here a valid topological order is to

460
00:07:53,990 --> 00:07:54,000
and here a valid topological order is to
 

461
00:07:54,000 --> 00:07:57,350
and here a valid topological order is to
say solve these problems in order

462
00:07:57,350 --> 00:07:57,360
say solve these problems in order
 

463
00:07:57,360 --> 00:07:59,589
say solve these problems in order
where j minus i the length of the

464
00:07:59,589 --> 00:07:59,599
where j minus i the length of the
 

465
00:07:59,599 --> 00:08:00,469
where j minus i the length of the
subarray

466
00:08:00,469 --> 00:08:00,479
subarray
 

467
00:08:00,479 --> 00:08:03,029
subarray
is increasing and then you can check

468
00:08:03,029 --> 00:08:03,039
is increasing and then you can check
 

469
00:08:03,039 --> 00:08:03,670
is increasing and then you can check
because m

470
00:08:03,670 --> 00:08:03,680
because m
 

471
00:08:03,680 --> 00:08:06,390
because m
is strictly between i and j as long as

472
00:08:06,390 --> 00:08:06,400
is strictly between i and j as long as
 

473
00:08:06,400 --> 00:08:08,390
is strictly between i and j as long as
we're not in a base case

474
00:08:08,390 --> 00:08:08,400
we're not in a base case
 

475
00:08:08,400 --> 00:08:11,510
we're not in a base case
then we know uh we can

476
00:08:11,510 --> 00:08:11,520
then we know uh we can
 

477
00:08:11,520 --> 00:08:13,589
then we know uh we can
these subarrays will be smaller than

478
00:08:13,589 --> 00:08:13,599
these subarrays will be smaller than
 

479
00:08:13,599 --> 00:08:15,189
these subarrays will be smaller than
this one and so this increasing order

480
00:08:15,189 --> 00:08:15,199
this one and so this increasing order
 

481
00:08:15,199 --> 00:08:17,270
this one and so this increasing order
gives us a valid topological order

482
00:08:17,270 --> 00:08:17,280
gives us a valid topological order
 

483
00:08:17,280 --> 00:08:19,990
gives us a valid topological order
on all of the problems all the sub

484
00:08:19,990 --> 00:08:20,000
on all of the problems all the sub
 

485
00:08:20,000 --> 00:08:22,070
on all of the problems all the sub
problems uh we have a base case which is

486
00:08:22,070 --> 00:08:22,080
problems uh we have a base case which is
 

487
00:08:22,080 --> 00:08:23,830
problems uh we have a base case which is
if we don't want to sort anything

488
00:08:23,830 --> 00:08:23,840
if we don't want to sort anything
 

489
00:08:23,840 --> 00:08:26,469
if we don't want to sort anything
that's the empty array i already said

490
00:08:26,469 --> 00:08:26,479
that's the empty array i already said
 

491
00:08:26,479 --> 00:08:27,830
that's the empty array i already said
the original problem and then running

492
00:08:27,830 --> 00:08:27,840
the original problem and then running
 

493
00:08:27,840 --> 00:08:28,629
the original problem and then running
time

494
00:08:28,629 --> 00:08:28,639
time
 

495
00:08:28,639 --> 00:08:31,350
time
is i mean there's no better way to solve

496
00:08:31,350 --> 00:08:31,360
is i mean there's no better way to solve
 

497
00:08:31,360 --> 00:08:31,990
is i mean there's no better way to solve
it than

498
00:08:31,990 --> 00:08:32,000
it than
 

499
00:08:32,000 --> 00:08:33,430
it than
the recurrence that we already saw how

500
00:08:33,430 --> 00:08:33,440
the recurrence that we already saw how
 

501
00:08:33,440 --> 00:08:35,350
the recurrence that we already saw how
to solve so this is just another way to

502
00:08:35,350 --> 00:08:35,360
to solve so this is just another way to
 

503
00:08:35,360 --> 00:08:37,350
to solve so this is just another way to
think of n log n merge sort

504
00:08:37,350 --> 00:08:37,360
think of n log n merge sort
 

505
00:08:37,360 --> 00:08:41,110
think of n log n merge sort
in this labeled framework of sort bot

506
00:08:41,110 --> 00:08:41,120
in this labeled framework of sort bot
 

507
00:08:41,120 --> 00:08:44,470
in this labeled framework of sort bot
let's get to another problem that does

508
00:08:44,470 --> 00:08:44,480
let's get to another problem that does
 

509
00:08:44,480 --> 00:08:45,350
let's get to another problem that does
not

510
00:08:45,350 --> 00:08:45,360
not
 

511
00:08:45,360 --> 00:08:49,509
not
fit recursion so well but we can

512
00:08:49,509 --> 00:08:49,519
fit recursion so well but we can
 

513
00:08:49,519 --> 00:08:52,630
fit recursion so well but we can
make it better so this we're going to

514
00:08:52,630 --> 00:08:52,640
make it better so this we're going to
 

515
00:08:52,640 --> 00:08:54,470
make it better so this we're going to
start with a very simple problem which

516
00:08:54,470 --> 00:08:54,480
start with a very simple problem which
 

517
00:08:54,480 --> 00:08:55,110
start with a very simple problem which
is

518
00:08:55,110 --> 00:08:55,120
is
 

519
00:08:55,120 --> 00:08:58,949
is
computing fibonacci numbers

520
00:08:58,949 --> 00:08:58,959

 

521
00:08:58,959 --> 00:09:00,790

it's really just a toy problem to

522
00:09:00,790 --> 00:09:00,800
it's really just a toy problem to
 

523
00:09:00,800 --> 00:09:03,670
it's really just a toy problem to
illustrate a very powerful idea which is

524
00:09:03,670 --> 00:09:03,680
illustrate a very powerful idea which is
 

525
00:09:03,680 --> 00:09:06,230
illustrate a very powerful idea which is
memoization

526
00:09:06,230 --> 00:09:06,240
memoization
 

527
00:09:06,240 --> 00:09:08,310
memoization
so the problem i'm interested in is i'm

528
00:09:08,310 --> 00:09:08,320
so the problem i'm interested in is i'm
 

529
00:09:08,320 --> 00:09:09,670
so the problem i'm interested in is i'm
given a particular number

530
00:09:09,670 --> 00:09:09,680
given a particular number
 

531
00:09:09,680 --> 00:09:12,949
given a particular number
n and i want to compute

532
00:09:12,949 --> 00:09:12,959
n and i want to compute
 

533
00:09:12,959 --> 00:09:15,350
n and i want to compute
the nth fibonacci number and in case you

534
00:09:15,350 --> 00:09:15,360
the nth fibonacci number and in case you
 

535
00:09:15,360 --> 00:09:15,990
the nth fibonacci number and in case you
forgot

536
00:09:15,990 --> 00:09:16,000
forgot
 

537
00:09:16,000 --> 00:09:17,990
forgot
the nth fibonacci number is given by

538
00:09:17,990 --> 00:09:18,000
the nth fibonacci number is given by
 

539
00:09:18,000 --> 00:09:19,269
the nth fibonacci number is given by
this recurrence fn

540
00:09:19,269 --> 00:09:19,279
this recurrence fn
 

541
00:09:19,279 --> 00:09:22,389
this recurrence fn
is fn minus one plus fn minus two with

542
00:09:22,389 --> 00:09:22,399
is fn minus one plus fn minus two with
 

543
00:09:22,399 --> 00:09:23,350
is fn minus one plus fn minus two with
base case

544
00:09:23,350 --> 00:09:23,360
base case
 

545
00:09:23,360 --> 00:09:29,190
base case
uh let's say f1 equals f2 equals one

546
00:09:29,190 --> 00:09:29,200

 

547
00:09:29,200 --> 00:09:30,870

and so we'd like to compute this this

548
00:09:30,870 --> 00:09:30,880
and so we'd like to compute this this
 

549
00:09:30,880 --> 00:09:33,190
and so we'd like to compute this this
seems this is a recurrence

550
00:09:33,190 --> 00:09:33,200
seems this is a recurrence
 

551
00:09:33,200 --> 00:09:36,310
seems this is a recurrence
so it seems very natural to write it as

552
00:09:36,310 --> 00:09:36,320
so it seems very natural to write it as
 

553
00:09:36,320 --> 00:09:38,070
so it seems very natural to write it as
a recursive algorithm so let's try to do

554
00:09:38,070 --> 00:09:38,080
a recursive algorithm so let's try to do
 

555
00:09:38,080 --> 00:09:38,470
a recursive algorithm so let's try to do
it

556
00:09:38,470 --> 00:09:38,480
it
 

557
00:09:38,480 --> 00:09:41,430
it
we start with what are the sub-problems

558
00:09:41,430 --> 00:09:41,440
we start with what are the sub-problems
 

559
00:09:41,440 --> 00:09:44,070
we start with what are the sub-problems
the obvious sub-problems

560
00:09:44,070 --> 00:09:44,080
the obvious sub-problems
 

561
00:09:44,080 --> 00:09:47,670
the obvious sub-problems
are just the various fibonacci numbers

562
00:09:47,670 --> 00:09:47,680
are just the various fibonacci numbers
 

563
00:09:47,680 --> 00:09:52,470
are just the various fibonacci numbers
fi for i between

564
00:09:52,470 --> 00:09:52,480
fi for i between
 

565
00:09:52,480 --> 00:09:55,670
fi for i between
one and n

566
00:09:55,670 --> 00:09:55,680
one and n
 

567
00:09:55,680 --> 00:10:00,470
one and n
so they're n of these sub problems

568
00:10:00,470 --> 00:10:00,480

 

569
00:10:00,480 --> 00:10:03,509

cool let's see we want a relation

570
00:10:03,509 --> 00:10:03,519
cool let's see we want a relation
 

571
00:10:03,519 --> 00:10:07,430
cool let's see we want a relation
between them

572
00:10:07,430 --> 00:10:07,440

 

573
00:10:07,440 --> 00:10:09,430

well maybe i'll just to distinguish the

574
00:10:09,430 --> 00:10:09,440
well maybe i'll just to distinguish the
 

575
00:10:09,440 --> 00:10:11,509
well maybe i'll just to distinguish the
problems from the fibonacci numbers

576
00:10:11,509 --> 00:10:11,519
problems from the fibonacci numbers
 

577
00:10:11,519 --> 00:10:14,790
problems from the fibonacci numbers
let me write f of i this is a function

578
00:10:14,790 --> 00:10:14,800
let me write f of i this is a function
 

579
00:10:14,800 --> 00:10:16,630
let me write f of i this is a function
an algorithm we're going to define and

580
00:10:16,630 --> 00:10:16,640
an algorithm we're going to define and
 

581
00:10:16,640 --> 00:10:18,870
an algorithm we're going to define and
it's defined to be

582
00:10:18,870 --> 00:10:18,880
it's defined to be
 

583
00:10:18,880 --> 00:10:20,949
it's defined to be
the goal we're trying to get is the i

584
00:10:20,949 --> 00:10:20,959
the goal we're trying to get is the i
 

585
00:10:20,959 --> 00:10:22,150
the goal we're trying to get is the i
fibonacci number

586
00:10:22,150 --> 00:10:22,160
fibonacci number
 

587
00:10:22,160 --> 00:10:25,269
fibonacci number
given i and then we can write

588
00:10:25,269 --> 00:10:25,279
given i and then we can write
 

589
00:10:25,279 --> 00:10:27,990
given i and then we can write
the recurrence relation on these guys

590
00:10:27,990 --> 00:10:28,000
the recurrence relation on these guys
 

591
00:10:28,000 --> 00:10:28,550
the recurrence relation on these guys
just uh

592
00:10:28,550 --> 00:10:28,560
just uh
 

593
00:10:28,560 --> 00:10:31,750
just uh
f of i equals f of i minus 1

594
00:10:31,750 --> 00:10:31,760
f of i equals f of i minus 1
 

595
00:10:31,760 --> 00:10:34,710
f of i equals f of i minus 1
plus f of i minus 2. so in other words

596
00:10:34,710 --> 00:10:34,720
plus f of i minus 2. so in other words
 

597
00:10:34,720 --> 00:10:36,630
plus f of i minus 2. so in other words
recursively compute

598
00:10:36,630 --> 00:10:36,640
recursively compute
 

599
00:10:36,640 --> 00:10:38,310
recursively compute
those fibonacci numbers then add them

600
00:10:38,310 --> 00:10:38,320
those fibonacci numbers then add them
 

601
00:10:38,320 --> 00:10:40,949
those fibonacci numbers then add them
together that's an algorithm

602
00:10:40,949 --> 00:10:40,959
together that's an algorithm
 

603
00:10:40,959 --> 00:10:48,389
together that's an algorithm
next is t for topological order

604
00:10:48,389 --> 00:10:48,399

 

605
00:10:48,399 --> 00:10:51,110

here of course we just want to compute

606
00:10:51,110 --> 00:10:51,120
here of course we just want to compute
 

607
00:10:51,120 --> 00:10:52,550
here of course we just want to compute
these in order of increasing

608
00:10:52,550 --> 00:10:52,560
these in order of increasing
 

609
00:10:52,560 --> 00:10:57,750
these in order of increasing
i from the base cases up

610
00:10:57,750 --> 00:10:57,760
i from the base cases up
 

611
00:10:57,760 --> 00:10:59,990
i from the base cases up
another way i like to write this is as a

612
00:10:59,990 --> 00:11:00,000
another way i like to write this is as a
 

613
00:11:00,000 --> 00:11:01,110
another way i like to write this is as a
for loop

614
00:11:01,110 --> 00:11:01,120
for loop
 

615
00:11:01,120 --> 00:11:04,710
for loop
for i equals one to n

616
00:11:04,710 --> 00:11:04,720
for i equals one to n
 

617
00:11:04,720 --> 00:11:07,190
for i equals one to n
maybe we'll see why but this gives an

618
00:11:07,190 --> 00:11:07,200
maybe we'll see why but this gives an
 

619
00:11:07,200 --> 00:11:09,110
maybe we'll see why but this gives an
explicit order

620
00:11:09,110 --> 00:11:09,120
explicit order
 

621
00:11:09,120 --> 00:11:13,430
explicit order
of to compute these sub-problems

622
00:11:13,430 --> 00:11:13,440

 

623
00:11:13,440 --> 00:11:20,150

and all right base case is just the same

624
00:11:20,150 --> 00:11:20,160

 

625
00:11:20,160 --> 00:11:21,990

as the fibonacci numbers but i guess i

626
00:11:21,990 --> 00:11:22,000
as the fibonacci numbers but i guess i
 

627
00:11:22,000 --> 00:11:25,750
as the fibonacci numbers but i guess i
should write parentheses

628
00:11:25,750 --> 00:11:25,760

 

629
00:11:25,760 --> 00:11:28,630

the original problem we want to solve is

630
00:11:28,630 --> 00:11:28,640
the original problem we want to solve is
 

631
00:11:28,640 --> 00:11:29,030
the original problem we want to solve is
f

632
00:11:29,030 --> 00:11:29,040
f
 

633
00:11:29,040 --> 00:11:32,069
f
n and the time

634
00:11:32,069 --> 00:11:32,079
n and the time
 

635
00:11:32,079 --> 00:11:33,269
n and the time
all right here's where things get

636
00:11:33,269 --> 00:11:33,279
all right here's where things get
 

637
00:11:33,279 --> 00:11:35,670
all right here's where things get
interesting or bad

638
00:11:35,670 --> 00:11:35,680
interesting or bad
 

639
00:11:35,680 --> 00:11:38,389
interesting or bad
so what is the running time of this

640
00:11:38,389 --> 00:11:38,399
so what is the running time of this
 

641
00:11:38,399 --> 00:11:39,509
so what is the running time of this
recursive algorithm

642
00:11:39,509 --> 00:11:39,519
recursive algorithm
 

643
00:11:39,519 --> 00:11:42,069
recursive algorithm
as i've stated it so far the running

644
00:11:42,069 --> 00:11:42,079
as i've stated it so far the running
 

645
00:11:42,079 --> 00:11:43,910
as i've stated it so far the running
time is

646
00:11:43,910 --> 00:11:43,920
time is
 

647
00:11:43,920 --> 00:11:46,630
time is
given by a recurrence let's write the

648
00:11:46,630 --> 00:11:46,640
given by a recurrence let's write the
 

649
00:11:46,640 --> 00:11:47,590
given by a recurrence let's write the
recurrence

650
00:11:47,590 --> 00:11:47,600
recurrence
 

651
00:11:47,600 --> 00:11:51,269
recurrence
so in order to compute f of n uh

652
00:11:51,269 --> 00:11:51,279
so in order to compute f of n uh
 

653
00:11:51,279 --> 00:11:54,710
so in order to compute f of n uh
i recursively compute f of i minus 1

654
00:11:54,710 --> 00:11:54,720
i recursively compute f of i minus 1
 

655
00:11:54,720 --> 00:11:58,389
i recursively compute f of i minus 1
or f of n minus 1 here

656
00:11:58,389 --> 00:11:58,399
or f of n minus 1 here
 

657
00:11:58,399 --> 00:12:01,430
or f of n minus 1 here
and i recursively compute f

658
00:12:01,430 --> 00:12:01,440
and i recursively compute f
 

659
00:12:01,440 --> 00:12:04,949
and i recursively compute f
of n minus 2 so that will take t of n

660
00:12:04,949 --> 00:12:04,959
of n minus 2 so that will take t of n
 

661
00:12:04,959 --> 00:12:06,790
of n minus 2 so that will take t of n
minus 2 this first step will take t of n

662
00:12:06,790 --> 00:12:06,800
minus 2 this first step will take t of n
 

663
00:12:06,800 --> 00:12:07,829
minus 2 this first step will take t of n
minus 1.

664
00:12:07,829 --> 00:12:07,839
minus 1.
 

665
00:12:07,839 --> 00:12:10,870
minus 1.
and now i need to solve this recurrence

666
00:12:10,870 --> 00:12:10,880
and now i need to solve this recurrence
 

667
00:12:10,880 --> 00:12:13,190
and now i need to solve this recurrence
uh this is not a recurrence that falls

668
00:12:13,190 --> 00:12:13,200
uh this is not a recurrence that falls
 

669
00:12:13,200 --> 00:12:15,350
uh this is not a recurrence that falls
to the master method it doesn't have a

670
00:12:15,350 --> 00:12:15,360
to the master method it doesn't have a
 

671
00:12:15,360 --> 00:12:18,629
to the master method it doesn't have a
divided by so we have to think about it

672
00:12:18,629 --> 00:12:18,639
divided by so we have to think about it
 

673
00:12:18,639 --> 00:12:19,350
divided by so we have to think about it
a little bit

674
00:12:19,350 --> 00:12:19,360
a little bit
 

675
00:12:19,360 --> 00:12:20,629
a little bit
but we don't have to think about it too

676
00:12:20,629 --> 00:12:20,639
but we don't have to think about it too
 

677
00:12:20,639 --> 00:12:22,790
but we don't have to think about it too
hard because this recurrence

678
00:12:22,790 --> 00:12:22,800
hard because this recurrence
 

679
00:12:22,800 --> 00:12:25,110
hard because this recurrence
is the same as this recurrence which is

680
00:12:25,110 --> 00:12:25,120
is the same as this recurrence which is
 

681
00:12:25,120 --> 00:12:26,629
is the same as this recurrence which is
the same as this recurrence i've written

682
00:12:26,629 --> 00:12:26,639
the same as this recurrence i've written
 

683
00:12:26,639 --> 00:12:27,750
the same as this recurrence i've written
it three times now

684
00:12:27,750 --> 00:12:27,760
it three times now
 

685
00:12:27,760 --> 00:12:30,069
it three times now
and so the solution to this is the nth

686
00:12:30,069 --> 00:12:30,079
and so the solution to this is the nth
 

687
00:12:30,079 --> 00:12:31,990
and so the solution to this is the nth
fibonacci number

688
00:12:31,990 --> 00:12:32,000
fibonacci number
 

689
00:12:32,000 --> 00:12:34,550
fibonacci number
uh oh sorry it's a little bit worse

690
00:12:34,550 --> 00:12:34,560
uh oh sorry it's a little bit worse
 

691
00:12:34,560 --> 00:12:35,030
uh oh sorry it's a little bit worse
because

692
00:12:35,030 --> 00:12:35,040
because
 

693
00:12:35,040 --> 00:12:37,430
because
in addition to those recursions i also

694
00:12:37,430 --> 00:12:37,440
in addition to those recursions i also
 

695
00:12:37,440 --> 00:12:39,670
in addition to those recursions i also
spend constant time to do the addition

696
00:12:39,670 --> 00:12:39,680
spend constant time to do the addition
 

697
00:12:39,680 --> 00:12:41,590
spend constant time to do the addition
maybe more than constant time but if we

698
00:12:41,590 --> 00:12:41,600
maybe more than constant time but if we
 

699
00:12:41,600 --> 00:12:44,710
maybe more than constant time but if we
just count the number of additions we do

700
00:12:44,710 --> 00:12:44,720
just count the number of additions we do
 

701
00:12:44,720 --> 00:12:50,829
just count the number of additions we do
it will be plus plus one

702
00:12:50,829 --> 00:12:50,839

 

703
00:12:50,839 --> 00:12:53,670

additions

704
00:12:53,670 --> 00:12:53,680
additions
 

705
00:12:53,680 --> 00:12:56,389
additions
okay but this is bigger than the nth

706
00:12:56,389 --> 00:12:56,399
okay but this is bigger than the nth
 

707
00:12:56,399 --> 00:12:58,150
okay but this is bigger than the nth
fibonacci number

708
00:12:58,150 --> 00:12:58,160
fibonacci number
 

709
00:12:58,160 --> 00:12:59,910
fibonacci number
and if you know anything about fibonacci

710
00:12:59,910 --> 00:12:59,920
and if you know anything about fibonacci
 

711
00:12:59,920 --> 00:13:01,269
and if you know anything about fibonacci
numbers

712
00:13:01,269 --> 00:13:01,279
numbers
 

713
00:13:01,279 --> 00:13:04,710
numbers
they grow exponentially they're about

714
00:13:04,710 --> 00:13:04,720
they grow exponentially they're about
 

715
00:13:04,720 --> 00:13:06,870
they grow exponentially they're about
golden ratio to the n i'm wearing golden

716
00:13:06,870 --> 00:13:06,880
golden ratio to the n i'm wearing golden
 

717
00:13:06,880 --> 00:13:09,350
golden ratio to the n i'm wearing golden
ratio in case you forgot the number

718
00:13:09,350 --> 00:13:09,360
ratio in case you forgot the number
 

719
00:13:09,360 --> 00:13:12,470
ratio in case you forgot the number
so that's bad because golden ratio is

720
00:13:12,470 --> 00:13:12,480
so that's bad because golden ratio is
 

721
00:13:12,480 --> 00:13:14,470
so that's bad because golden ratio is
bigger than one so this is exponential

722
00:13:14,470 --> 00:13:14,480
bigger than one so this is exponential
 

723
00:13:14,480 --> 00:13:15,110
bigger than one so this is exponential
growth

724
00:13:15,110 --> 00:13:15,120
growth
 

725
00:13:15,120 --> 00:13:16,629
growth
as we know especially in this time

726
00:13:16,629 --> 00:13:16,639
as we know especially in this time
 

727
00:13:16,639 --> 00:13:18,150
as we know especially in this time
exponential growth is bad

728
00:13:18,150 --> 00:13:18,160
exponential growth is bad
 

729
00:13:18,160 --> 00:13:19,910
exponential growth is bad
and algorithms exponential growth is bad

730
00:13:19,910 --> 00:13:19,920
and algorithms exponential growth is bad
 

731
00:13:19,920 --> 00:13:21,990
and algorithms exponential growth is bad
because we can only solve very small

732
00:13:21,990 --> 00:13:22,000
because we can only solve very small
 

733
00:13:22,000 --> 00:13:23,829
because we can only solve very small
problems with exponential growth very

734
00:13:23,829 --> 00:13:23,839
problems with exponential growth very
 

735
00:13:23,839 --> 00:13:26,069
problems with exponential growth very
small n so this is a

736
00:13:26,069 --> 00:13:26,079
small n so this is a
 

737
00:13:26,079 --> 00:13:27,829
small n so this is a
terrible way to compute the nth

738
00:13:27,829 --> 00:13:27,839
terrible way to compute the nth
 

739
00:13:27,839 --> 00:13:32,829
terrible way to compute the nth
fibonacci number

740
00:13:32,829 --> 00:13:32,839

 

741
00:13:32,839 --> 00:13:37,030

exponential

742
00:13:37,030 --> 00:13:37,040

 

743
00:13:37,040 --> 00:13:40,150

bad

744
00:13:40,150 --> 00:13:40,160

 

745
00:13:40,160 --> 00:13:43,430

okay so don't do this

746
00:13:43,430 --> 00:13:43,440
okay so don't do this
 

747
00:13:43,440 --> 00:13:46,310
okay so don't do this
but there's a very tiny tweak to this

748
00:13:46,310 --> 00:13:46,320
but there's a very tiny tweak to this
 

749
00:13:46,320 --> 00:13:47,030
but there's a very tiny tweak to this
algorithm

750
00:13:47,030 --> 00:13:47,040
algorithm
 

751
00:13:47,040 --> 00:13:50,069
algorithm
that makes it really good which is

752
00:13:50,069 --> 00:13:50,079
that makes it really good which is
 

753
00:13:50,079 --> 00:13:55,110
that makes it really good which is
memoization and this is a big idea

754
00:13:55,110 --> 00:13:55,120
memoization and this is a big idea
 

755
00:13:55,120 --> 00:14:00,829
memoization and this is a big idea
it is the big idea of dynamic

756
00:14:00,829 --> 00:14:00,839

 

757
00:14:00,839 --> 00:14:02,629

programming

758
00:14:02,629 --> 00:14:02,639
programming
 

759
00:14:02,639 --> 00:14:05,829
programming
it's a funny word probably made up by a

760
00:14:05,829 --> 00:14:05,839
it's a funny word probably made up by a
 

761
00:14:05,839 --> 00:14:07,269
it's a funny word probably made up by a
computer scientist

762
00:14:07,269 --> 00:14:07,279
computer scientist
 

763
00:14:07,279 --> 00:14:10,110
computer scientist
um instead of memorization it's

764
00:14:10,110 --> 00:14:10,120
um instead of memorization it's
 

765
00:14:10,120 --> 00:14:11,829
um instead of memorization it's
memoization

766
00:14:11,829 --> 00:14:11,839
memoization
 

767
00:14:11,839 --> 00:14:13,750
memoization
because we're going to write things down

768
00:14:13,750 --> 00:14:13,760
because we're going to write things down
 

769
00:14:13,760 --> 00:14:16,470
because we're going to write things down
in a memo pad is the idea

770
00:14:16,470 --> 00:14:16,480
in a memo pad is the idea
 

771
00:14:16,480 --> 00:14:17,990
in a memo pad is the idea
and it's a very simple idea which is

772
00:14:17,990 --> 00:14:18,000
and it's a very simple idea which is
 

773
00:14:18,000 --> 00:14:20,629
and it's a very simple idea which is
just remember

774
00:14:20,629 --> 00:14:20,639
just remember
 

775
00:14:20,639 --> 00:14:35,590
just remember
and reuse solutions to sub-problems

776
00:14:35,590 --> 00:14:35,600

 

777
00:14:35,600 --> 00:14:39,430

so let's draw the recursion tree

778
00:14:39,430 --> 00:14:39,440
so let's draw the recursion tree
 

779
00:14:39,440 --> 00:14:42,389
so let's draw the recursion tree
for this recursive algorithm as we've

780
00:14:42,389 --> 00:14:42,399
for this recursive algorithm as we've
 

781
00:14:42,399 --> 00:14:43,430
for this recursive algorithm as we've
done it so far

782
00:14:43,430 --> 00:14:43,440
done it so far
 

783
00:14:43,440 --> 00:14:45,910
done it so far
so at the top we let me make a little

784
00:14:45,910 --> 00:14:45,920
so at the top we let me make a little
 

785
00:14:45,920 --> 00:14:48,949
so at the top we let me make a little
bit of space

786
00:14:48,949 --> 00:14:48,959

 

787
00:14:48,959 --> 00:14:53,509

at the top we are calling f of n

788
00:14:53,509 --> 00:14:53,519
at the top we are calling f of n
 

789
00:14:53,519 --> 00:14:56,790
at the top we are calling f of n
and then that calls f of n minus 1

790
00:14:56,790 --> 00:14:56,800
and then that calls f of n minus 1
 

791
00:14:56,800 --> 00:14:59,590
and then that calls f of n minus 1
and f of n minus two and it does an

792
00:14:59,590 --> 00:14:59,600
and f of n minus two and it does an
 

793
00:14:59,600 --> 00:15:00,870
and f of n minus two and it does an
addition up here

794
00:15:00,870 --> 00:15:00,880
addition up here
 

795
00:15:00,880 --> 00:15:04,550
addition up here
and then this calls f of n minus two

796
00:15:04,550 --> 00:15:04,560
and then this calls f of n minus two
 

797
00:15:04,560 --> 00:15:08,150
and then this calls f of n minus two
and this calls f of n minus three

798
00:15:08,150 --> 00:15:08,160
and this calls f of n minus three
 

799
00:15:08,160 --> 00:15:11,269
and this calls f of n minus three
this calls f of n minus three

800
00:15:11,269 --> 00:15:11,279
this calls f of n minus three
 

801
00:15:11,279 --> 00:15:16,230
this calls f of n minus three
and this calls f of n minus 4.

802
00:15:16,230 --> 00:15:16,240

 

803
00:15:16,240 --> 00:15:21,509

okay and we notice that

804
00:15:21,509 --> 00:15:21,519

 

805
00:15:21,519 --> 00:15:24,949

this sub problem is the same as this sub

806
00:15:24,949 --> 00:15:24,959
this sub problem is the same as this sub
 

807
00:15:24,959 --> 00:15:25,670
this sub problem is the same as this sub
problem

808
00:15:25,670 --> 00:15:25,680
problem
 

809
00:15:25,680 --> 00:15:27,910
problem
so to compute f of n minus 1 i need f of

810
00:15:27,910 --> 00:15:27,920
so to compute f of n minus 1 i need f of
 

811
00:15:27,920 --> 00:15:29,670
so to compute f of n minus 1 i need f of
n minus 3 and also to compute f of n

812
00:15:29,670 --> 00:15:29,680
n minus 3 and also to compute f of n
 

813
00:15:29,680 --> 00:15:31,910
n minus 3 and also to compute f of n
minus 2 i need f of n minus 3.

814
00:15:31,910 --> 00:15:31,920
minus 2 i need f of n minus 3.
 

815
00:15:31,920 --> 00:15:33,829
minus 2 i need f of n minus 3.
so why are we computing it twice let's

816
00:15:33,829 --> 00:15:33,839
so why are we computing it twice let's
 

817
00:15:33,839 --> 00:15:36,069
so why are we computing it twice let's
just do it once

818
00:15:36,069 --> 00:15:36,079
just do it once
 

819
00:15:36,079 --> 00:15:38,230
just do it once
when we solve it let's write it in a

820
00:15:38,230 --> 00:15:38,240
when we solve it let's write it in a
 

821
00:15:38,240 --> 00:15:39,350
when we solve it let's write it in a
table somewhere

822
00:15:39,350 --> 00:15:39,360
table somewhere
 

823
00:15:39,360 --> 00:15:41,110
table somewhere
and then when we need it again we'll

824
00:15:41,110 --> 00:15:41,120
and then when we need it again we'll
 

825
00:15:41,120 --> 00:15:44,550
and then when we need it again we'll
just reuse that value question

826
00:15:44,550 --> 00:15:44,560

 

827
00:15:44,560 --> 00:15:47,030

f of n minus 2 is also shared so let me

828
00:15:47,030 --> 00:15:47,040
f of n minus 2 is also shared so let me
 

829
00:15:47,040 --> 00:15:48,310
f of n minus 2 is also shared so let me
use a different

830
00:15:48,310 --> 00:15:48,320
use a different
 

831
00:15:48,320 --> 00:15:51,430
use a different
symbol f of n minus 2 is already

832
00:15:51,430 --> 00:15:51,440
symbol f of n minus 2 is already
 

833
00:15:51,440 --> 00:15:54,629
symbol f of n minus 2 is already
here so this was at the same level but

834
00:15:54,629 --> 00:15:54,639
here so this was at the same level but
 

835
00:15:54,639 --> 00:15:56,230
here so this was at the same level but
we also get shared reuse

836
00:15:56,230 --> 00:15:56,240
we also get shared reuse
 

837
00:15:56,240 --> 00:15:57,990
we also get shared reuse
between different levels in fact i

838
00:15:57,990 --> 00:15:58,000
between different levels in fact i
 

839
00:15:58,000 --> 00:15:59,670
between different levels in fact i
wouldn't even call f of n minus 3

840
00:15:59,670 --> 00:15:59,680
wouldn't even call f of n minus 3
 

841
00:15:59,680 --> 00:16:01,670
wouldn't even call f of n minus 3
because this whole part

842
00:16:01,670 --> 00:16:01,680
because this whole part
 

843
00:16:01,680 --> 00:16:03,189
because this whole part
doesn't need to be computed a second

844
00:16:03,189 --> 00:16:03,199
doesn't need to be computed a second
 

845
00:16:03,199 --> 00:16:05,430
doesn't need to be computed a second
time if i already computed it here

846
00:16:05,430 --> 00:16:05,440
time if i already computed it here
 

847
00:16:05,440 --> 00:16:06,790
time if i already computed it here
it doesn't matter which one comes first

848
00:16:06,790 --> 00:16:06,800
it doesn't matter which one comes first
 

849
00:16:06,800 --> 00:16:08,710
it doesn't matter which one comes first
let's say this one comes first once this

850
00:16:08,710 --> 00:16:08,720
let's say this one comes first once this
 

851
00:16:08,720 --> 00:16:09,189
let's say this one comes first once this
is done

852
00:16:09,189 --> 00:16:09,199
is done
 

853
00:16:09,199 --> 00:16:11,430
is done
i can write it down and reuse it over

854
00:16:11,430 --> 00:16:11,440
i can write it down and reuse it over
 

855
00:16:11,440 --> 00:16:12,870
i can write it down and reuse it over
here

856
00:16:12,870 --> 00:16:12,880
here
 

857
00:16:12,880 --> 00:16:15,189
here
okay but actually and then in here we're

858
00:16:15,189 --> 00:16:15,199
okay but actually and then in here we're
 

859
00:16:15,199 --> 00:16:17,829
okay but actually and then in here we're
going to call f of n minus 3

860
00:16:17,829 --> 00:16:17,839
going to call f of n minus 3
 

861
00:16:17,839 --> 00:16:19,990
going to call f of n minus 3
so there's still a another computation

862
00:16:19,990 --> 00:16:20,000
so there's still a another computation
 

863
00:16:20,000 --> 00:16:21,269
so there's still a another computation
of f of n minus 3.

864
00:16:21,269 --> 00:16:21,279
of f of n minus 3.
 

865
00:16:21,279 --> 00:16:23,189
of f of n minus 3.
when that one's done i won't need to do

866
00:16:23,189 --> 00:16:23,199
when that one's done i won't need to do
 

867
00:16:23,199 --> 00:16:25,590
when that one's done i won't need to do
any do this recursively

868
00:16:25,590 --> 00:16:25,600
any do this recursively
 

869
00:16:25,600 --> 00:16:28,150
any do this recursively
okay so magically this is going to make

870
00:16:28,150 --> 00:16:28,160
okay so magically this is going to make
 

871
00:16:28,160 --> 00:16:29,749
okay so magically this is going to make
this algorithm efficient with this

872
00:16:29,749 --> 00:16:29,759
this algorithm efficient with this
 

873
00:16:29,759 --> 00:16:32,710
this algorithm efficient with this
very simple tweak let me write down the

874
00:16:32,710 --> 00:16:32,720
very simple tweak let me write down the
 

875
00:16:32,720 --> 00:16:34,949
very simple tweak let me write down the
tweak more explicitly

876
00:16:34,949 --> 00:16:34,959
tweak more explicitly
 

877
00:16:34,959 --> 00:16:37,990
tweak more explicitly
i won't write code here but

878
00:16:37,990 --> 00:16:38,000
i won't write code here but
 

879
00:16:38,000 --> 00:16:41,670
i won't write code here but
just describe it as a data structure

880
00:16:41,670 --> 00:16:41,680
just describe it as a data structure
 

881
00:16:41,680 --> 00:16:43,189
just describe it as a data structure
so we're going to maintain our good

882
00:16:43,189 --> 00:16:43,199
so we're going to maintain our good
 

883
00:16:43,199 --> 00:16:47,749
so we're going to maintain our good
friend the dictionary

884
00:16:47,749 --> 00:16:47,759

 

885
00:16:47,759 --> 00:16:52,069

which is abstract data type or interface

886
00:16:52,069 --> 00:16:52,079
which is abstract data type or interface
 

887
00:16:52,079 --> 00:16:53,430
which is abstract data type or interface
we could use different data structures

888
00:16:53,430 --> 00:16:53,440
we could use different data structures
 

889
00:16:53,440 --> 00:16:55,829
we could use different data structures
to do it but we're going to map

890
00:16:55,829 --> 00:16:55,839
to do it but we're going to map
 

891
00:16:55,839 --> 00:16:59,110
to do it but we're going to map
sub problems to their solutions

892
00:16:59,110 --> 00:16:59,120
sub problems to their solutions
 

893
00:16:59,120 --> 00:17:01,189
sub problems to their solutions
at least the ones that we've solved

894
00:17:01,189 --> 00:17:01,199
at least the ones that we've solved
 

895
00:17:01,199 --> 00:17:04,470
at least the ones that we've solved
already

896
00:17:04,470 --> 00:17:04,480

 

897
00:17:04,480 --> 00:17:06,630

and usually we can do this with just a

898
00:17:06,630 --> 00:17:06,640
and usually we can do this with just a
 

899
00:17:06,640 --> 00:17:07,829
and usually we can do this with just a
direct access array

900
00:17:07,829 --> 00:17:07,839
direct access array
 

901
00:17:07,839 --> 00:17:09,510
direct access array
though you could use a hash table just

902
00:17:09,510 --> 00:17:09,520
though you could use a hash table just
 

903
00:17:09,520 --> 00:17:16,829
though you could use a hash table just
get expected bounds

904
00:17:16,829 --> 00:17:16,839

 

905
00:17:16,839 --> 00:17:17,990

so

906
00:17:17,990 --> 00:17:18,000
so
 

907
00:17:18,000 --> 00:17:21,270
so
uh when we

908
00:17:21,270 --> 00:17:21,280

 

909
00:17:21,280 --> 00:17:22,789

write the code for our recursive

910
00:17:22,789 --> 00:17:22,799
write the code for our recursive
 

911
00:17:22,799 --> 00:17:24,630
write the code for our recursive
function so in general once we have a

912
00:17:24,630 --> 00:17:24,640
function so in general once we have a
 

913
00:17:24,640 --> 00:17:25,510
function so in general once we have a
sort bot

914
00:17:25,510 --> 00:17:25,520
sort bot
 

915
00:17:25,520 --> 00:17:27,750
sort bot
description we can turn this into code

916
00:17:27,750 --> 00:17:27,760
description we can turn this into code
 

917
00:17:27,760 --> 00:17:29,270
description we can turn this into code
right we define

918
00:17:29,270 --> 00:17:29,280
right we define
 

919
00:17:29,280 --> 00:17:32,789
right we define
f of i and it says am i in a base case

920
00:17:32,789 --> 00:17:32,799
f of i and it says am i in a base case
 

921
00:17:32,799 --> 00:17:34,150
f of i and it says am i in a base case
if so return this

922
00:17:34,150 --> 00:17:34,160
if so return this
 

923
00:17:34,160 --> 00:17:36,870
if so return this
otherwise do this recursive call that's

924
00:17:36,870 --> 00:17:36,880
otherwise do this recursive call that's
 

925
00:17:36,880 --> 00:17:38,150
otherwise do this recursive call that's
our recursive algorithm

926
00:17:38,150 --> 00:17:38,160
our recursive algorithm
 

927
00:17:38,160 --> 00:17:39,590
our recursive algorithm
but we're going to do a little more now

928
00:17:39,590 --> 00:17:39,600
but we're going to do a little more now
 

929
00:17:39,600 --> 00:17:43,350
but we're going to do a little more now
at first we're going to check

930
00:17:43,350 --> 00:17:43,360

 

931
00:17:43,360 --> 00:17:45,350

whether this sub problem that we're

932
00:17:45,350 --> 00:17:45,360
whether this sub problem that we're
 

933
00:17:45,360 --> 00:17:49,350
whether this sub problem that we're
trying to solve has already been solved

934
00:17:49,350 --> 00:17:49,360

 

935
00:17:49,360 --> 00:17:55,590

and if so we return that stored solution

936
00:17:55,590 --> 00:17:55,600
and if so we return that stored solution
 

937
00:17:55,600 --> 00:17:58,830
and if so we return that stored solution
that's the easy case but it might not

938
00:17:58,830 --> 00:17:58,840
that's the easy case but it might not
 

939
00:17:58,840 --> 00:18:10,710
that's the easy case but it might not
exist

940
00:18:10,710 --> 00:18:10,720

 

941
00:18:10,720 --> 00:18:13,270

and then we'll we'll compute it in the

942
00:18:13,270 --> 00:18:13,280
and then we'll we'll compute it in the
 

943
00:18:13,280 --> 00:18:14,150
and then we'll we'll compute it in the
usual way

944
00:18:14,150 --> 00:18:14,160
usual way
 

945
00:18:14,160 --> 00:18:17,350
usual way
so what the code then would look like to

946
00:18:17,350 --> 00:18:17,360
so what the code then would look like to
 

947
00:18:17,360 --> 00:18:17,909
so what the code then would look like to
define

948
00:18:17,909 --> 00:18:17,919
define
 

949
00:18:17,919 --> 00:18:21,430
define
f of i is first we check is i in our

950
00:18:21,430 --> 00:18:21,440
f of i is first we check is i in our
 

951
00:18:21,440 --> 00:18:23,350
f of i is first we check is i in our
in our data structure this is usually

952
00:18:23,350 --> 00:18:23,360
in our data structure this is usually
 

953
00:18:23,360 --> 00:18:24,710
in our data structure this is usually
called

954
00:18:24,710 --> 00:18:24,720
called
 

955
00:18:24,720 --> 00:18:28,549
called
the memo

956
00:18:28,549 --> 00:18:28,559
the memo
 

957
00:18:28,559 --> 00:18:31,830
the memo
so we say is this sub problem is i in my

958
00:18:31,830 --> 00:18:31,840
so we say is this sub problem is i in my
 

959
00:18:31,840 --> 00:18:32,390
so we say is this sub problem is i in my
memo

960
00:18:32,390 --> 00:18:32,400
memo
 

961
00:18:32,400 --> 00:18:34,549
memo
data structure if so just return memo of

962
00:18:34,549 --> 00:18:34,559
data structure if so just return memo of
 

963
00:18:34,559 --> 00:18:36,789
data structure if so just return memo of
i done no recursion necessary

964
00:18:36,789 --> 00:18:36,799
i done no recursion necessary
 

965
00:18:36,799 --> 00:18:39,830
i done no recursion necessary
otherwise check if i'm a base case if so

966
00:18:39,830 --> 00:18:39,840
otherwise check if i'm a base case if so
 

967
00:18:39,840 --> 00:18:43,270
otherwise check if i'm a base case if so
done otherwise recurse so recursively

968
00:18:43,270 --> 00:18:43,280
done otherwise recurse so recursively
 

969
00:18:43,280 --> 00:18:45,029
done otherwise recurse so recursively
call f of i minus 1 and f

970
00:18:45,029 --> 00:18:45,039
call f of i minus 1 and f
 

971
00:18:45,039 --> 00:18:47,430
call f of i minus 1 and f
minus 2. and in this recursion we can

972
00:18:47,430 --> 00:18:47,440
minus 2. and in this recursion we can
 

973
00:18:47,440 --> 00:18:50,150
minus 2. and in this recursion we can
see that after we call f of i minus 1

974
00:18:50,150 --> 00:18:50,160
see that after we call f of i minus 1
 

975
00:18:50,160 --> 00:18:51,830
see that after we call f of i minus 1
in fact it will have already computed f

976
00:18:51,830 --> 00:18:51,840
in fact it will have already computed f
 

977
00:18:51,840 --> 00:18:53,510
in fact it will have already computed f
of i minus 2. so while this call is

978
00:18:53,510 --> 00:18:53,520
of i minus 2. so while this call is
 

979
00:18:53,520 --> 00:18:54,470
of i minus 2. so while this call is
recursive

980
00:18:54,470 --> 00:18:54,480
recursive
 

981
00:18:54,480 --> 00:18:56,470
recursive
this one will immediately terminate

982
00:18:56,470 --> 00:18:56,480
this one will immediately terminate
 

983
00:18:56,480 --> 00:18:58,230
this one will immediately terminate
because i minus 2 will already be in the

984
00:18:58,230 --> 00:18:58,240
because i minus 2 will already be in the
 

985
00:18:58,240 --> 00:18:59,510
because i minus 2 will already be in the
memo table

986
00:18:59,510 --> 00:18:59,520
memo table
 

987
00:18:59,520 --> 00:19:02,390
memo table
and so if you think about what happens

988
00:19:02,390 --> 00:19:02,400
and so if you think about what happens
 

989
00:19:02,400 --> 00:19:04,150
and so if you think about what happens
in fact we'll just have recursion down

990
00:19:04,150 --> 00:19:04,160
in fact we'll just have recursion down
 

991
00:19:04,160 --> 00:19:05,590
in fact we'll just have recursion down
the left branch

992
00:19:05,590 --> 00:19:05,600
the left branch
 

993
00:19:05,600 --> 00:19:08,549
the left branch
of this thing and all the right branches

994
00:19:08,549 --> 00:19:08,559
of this thing and all the right branches
 

995
00:19:08,559 --> 00:19:10,150
of this thing and all the right branches
will be free we can just look things up

996
00:19:10,150 --> 00:19:10,160
will be free we can just look things up
 

997
00:19:10,160 --> 00:19:11,909
will be free we can just look things up
in the memo table

998
00:19:11,909 --> 00:19:11,919
in the memo table
 

999
00:19:11,919 --> 00:19:14,390
in the memo table
so what is the overall running time for

1000
00:19:14,390 --> 00:19:14,400
so what is the overall running time for
 

1001
00:19:14,400 --> 00:19:21,990
so what is the overall running time for
fibonacci

1002
00:19:21,990 --> 00:19:22,000

 

1003
00:19:22,000 --> 00:19:25,350

this should be order n

1004
00:19:25,350 --> 00:19:25,360
this should be order n
 

1005
00:19:25,360 --> 00:19:28,070
this should be order n
why is it order n this is number of

1006
00:19:28,070 --> 00:19:28,080
why is it order n this is number of
 

1007
00:19:28,080 --> 00:19:31,669
why is it order n this is number of
additions

1008
00:19:31,669 --> 00:19:31,679

 

1009
00:19:31,679 --> 00:19:36,150

come back to that in a second

1010
00:19:36,150 --> 00:19:36,160

 

1011
00:19:36,160 --> 00:19:38,710

in general the way to analyze an

1012
00:19:38,710 --> 00:19:38,720
in general the way to analyze an
 

1013
00:19:38,720 --> 00:19:39,990
in general the way to analyze an
algorithm like this that uses

1014
00:19:39,990 --> 00:19:40,000
algorithm like this that uses
 

1015
00:19:40,000 --> 00:19:41,669
algorithm like this that uses
memorization is we just count

1016
00:19:41,669 --> 00:19:41,679
memorization is we just count
 

1017
00:19:41,679 --> 00:19:43,190
memorization is we just count
how many different sub-problems are

1018
00:19:43,190 --> 00:19:43,200
how many different sub-problems are
 

1019
00:19:43,200 --> 00:19:44,630
how many different sub-problems are
there because once we solve the

1020
00:19:44,630 --> 00:19:44,640
there because once we solve the
 

1021
00:19:44,640 --> 00:19:46,470
there because once we solve the
sub-problem we will never solve it again

1022
00:19:46,470 --> 00:19:46,480
sub-problem we will never solve it again
 

1023
00:19:46,480 --> 00:19:48,150
sub-problem we will never solve it again
that's the whole idea of a memo table so

1024
00:19:48,150 --> 00:19:48,160
that's the whole idea of a memo table so
 

1025
00:19:48,160 --> 00:19:49,750
that's the whole idea of a memo table so
we will solve each sub-problem

1026
00:19:49,750 --> 00:19:49,760
we will solve each sub-problem
 

1027
00:19:49,760 --> 00:19:52,470
we will solve each sub-problem
at most once and so we just need to

1028
00:19:52,470 --> 00:19:52,480
at most once and so we just need to
 

1029
00:19:52,480 --> 00:19:54,070
at most once and so we just need to
count how much time does it take to

1030
00:19:54,070 --> 00:19:54,080
count how much time does it take to
 

1031
00:19:54,080 --> 00:19:54,950
count how much time does it take to
solve

1032
00:19:54,950 --> 00:19:54,960
solve
 

1033
00:19:54,960 --> 00:19:57,590
solve
every subproblem and here you can see

1034
00:19:57,590 --> 00:19:57,600
every subproblem and here you can see
 

1035
00:19:57,600 --> 00:19:58,870
every subproblem and here you can see
it's constant

1036
00:19:58,870 --> 00:19:58,880
it's constant
 

1037
00:19:58,880 --> 00:20:00,470
it's constant
either it's a base case and it takes

1038
00:20:00,470 --> 00:20:00,480
either it's a base case and it takes
 

1039
00:20:00,480 --> 00:20:02,310
either it's a base case and it takes
constant time or

1040
00:20:02,310 --> 00:20:02,320
constant time or
 

1041
00:20:02,320 --> 00:20:05,110
constant time or
we recursively call these things but

1042
00:20:05,110 --> 00:20:05,120
we recursively call these things but
 

1043
00:20:05,120 --> 00:20:06,470
we recursively call these things but
those are different sub problems so

1044
00:20:06,470 --> 00:20:06,480
those are different sub problems so
 

1045
00:20:06,480 --> 00:20:08,149
those are different sub problems so
we're going to count those later

1046
00:20:08,149 --> 00:20:08,159
we're going to count those later
 

1047
00:20:08,159 --> 00:20:09,430
we're going to count those later
and then the work that's actually done

1048
00:20:09,430 --> 00:20:09,440
and then the work that's actually done
 

1049
00:20:09,440 --> 00:20:11,990
and then the work that's actually done
by this recurrence is a single addition

1050
00:20:11,990 --> 00:20:12,000
by this recurrence is a single addition
 

1051
00:20:12,000 --> 00:20:15,110
by this recurrence is a single addition
so in fact it's n additions to compute f

1052
00:20:15,110 --> 00:20:15,120
so in fact it's n additions to compute f
 

1053
00:20:15,120 --> 00:20:20,070
so in fact it's n additions to compute f
n will be exactly n additions

1054
00:20:20,070 --> 00:20:20,080
n will be exactly n additions
 

1055
00:20:20,080 --> 00:20:22,149
n will be exactly n additions
so it turns out to be very nice closed

1056
00:20:22,149 --> 00:20:22,159
so it turns out to be very nice closed
 

1057
00:20:22,159 --> 00:20:23,909
so it turns out to be very nice closed
form in this case

1058
00:20:23,909 --> 00:20:23,919
form in this case
 

1059
00:20:23,919 --> 00:20:27,750
form in this case
um it should be exactly n sub problems

1060
00:20:27,750 --> 00:20:27,760
um it should be exactly n sub problems
 

1061
00:20:27,760 --> 00:20:30,390
um it should be exactly n sub problems
to compute f of n and because we start

1062
00:20:30,390 --> 00:20:30,400
to compute f of n and because we start
 

1063
00:20:30,400 --> 00:20:30,870
to compute f of n and because we start
stop

1064
00:20:30,870 --> 00:20:30,880
stop
 

1065
00:20:30,880 --> 00:20:34,230
stop
at one and each one has

1066
00:20:34,230 --> 00:20:34,240
at one and each one has
 

1067
00:20:34,240 --> 00:20:36,390
at one and each one has
one addition involved i guess not the

1068
00:20:36,390 --> 00:20:36,400
one addition involved i guess not the
 

1069
00:20:36,400 --> 00:20:39,830
one addition involved i guess not the
base case so maybe n minus two

1070
00:20:39,830 --> 00:20:39,840
base case so maybe n minus two
 

1071
00:20:39,840 --> 00:20:42,950
base case so maybe n minus two
okay definitely order n uh

1072
00:20:42,950 --> 00:20:42,960
okay definitely order n uh
 

1073
00:20:42,960 --> 00:20:46,070
okay definitely order n uh
now there's this one subtlety uh which

1074
00:20:46,070 --> 00:20:46,080
now there's this one subtlety uh which
 

1075
00:20:46,080 --> 00:20:47,669
now there's this one subtlety uh which
let's forget about dynamic programming

1076
00:20:47,669 --> 00:20:47,679
let's forget about dynamic programming
 

1077
00:20:47,679 --> 00:20:49,190
let's forget about dynamic programming
for a moment and go back to

1078
00:20:49,190 --> 00:20:49,200
for a moment and go back to
 

1079
00:20:49,200 --> 00:20:51,350
for a moment and go back to
good old lecture one and two talking

1080
00:20:51,350 --> 00:20:51,360
good old lecture one and two talking
 

1081
00:20:51,360 --> 00:20:53,909
good old lecture one and two talking
about the word ram model of computation

1082
00:20:53,909 --> 00:20:53,919
about the word ram model of computation
 

1083
00:20:53,919 --> 00:20:57,270
about the word ram model of computation
um a question here that usually doesn't

1084
00:20:57,270 --> 00:20:57,280
um a question here that usually doesn't
 

1085
00:20:57,280 --> 00:20:57,990
um a question here that usually doesn't
matter

1086
00:20:57,990 --> 00:20:58,000
matter
 

1087
00:20:58,000 --> 00:20:59,430
matter
in this class usually we assume

1088
00:20:59,430 --> 00:20:59,440
in this class usually we assume
 

1089
00:20:59,440 --> 00:21:01,350
in this class usually we assume
additions take constant time

1090
00:21:01,350 --> 00:21:01,360
additions take constant time
 

1091
00:21:01,360 --> 00:21:03,029
additions take constant time
and we usually do that because it's

1092
00:21:03,029 --> 00:21:03,039
and we usually do that because it's
 

1093
00:21:03,039 --> 00:21:05,590
and we usually do that because it's
usually true and in general our model is

1094
00:21:05,590 --> 00:21:05,600
usually true and in general our model is
 

1095
00:21:05,600 --> 00:21:06,390
usually true and in general our model is
that w

1096
00:21:06,390 --> 00:21:06,400
that w
 

1097
00:21:06,400 --> 00:21:09,590
that w
bit additions

1098
00:21:09,590 --> 00:21:09,600
bit additions
 

1099
00:21:09,600 --> 00:21:12,630
bit additions
where w is our machine word size

1100
00:21:12,630 --> 00:21:12,640
where w is our machine word size
 

1101
00:21:12,640 --> 00:21:19,590
where w is our machine word size
takes constant time

1102
00:21:19,590 --> 00:21:19,600

 

1103
00:21:19,600 --> 00:21:21,510

but for this problem and this problem

1104
00:21:21,510 --> 00:21:21,520
but for this problem and this problem
 

1105
00:21:21,520 --> 00:21:23,909
but for this problem and this problem
only pretty much for fibonacci numbers

1106
00:21:23,909 --> 00:21:23,919
only pretty much for fibonacci numbers
 

1107
00:21:23,919 --> 00:21:25,510
only pretty much for fibonacci numbers
i happen to know that the fibonacci

1108
00:21:25,510 --> 00:21:25,520
i happen to know that the fibonacci
 

1109
00:21:25,520 --> 00:21:27,350
i happen to know that the fibonacci
numbers grow exponentially so to write

1110
00:21:27,350 --> 00:21:27,360
numbers grow exponentially so to write
 

1111
00:21:27,360 --> 00:21:28,390
numbers grow exponentially so to write
them down

1112
00:21:28,390 --> 00:21:28,400
them down
 

1113
00:21:28,400 --> 00:21:32,630
them down
actually requires uh theta n bits

1114
00:21:32,630 --> 00:21:32,640
actually requires uh theta n bits
 

1115
00:21:32,640 --> 00:21:34,549
actually requires uh theta n bits
because they are some constant to the n

1116
00:21:34,549 --> 00:21:34,559
because they are some constant to the n
 

1117
00:21:34,559 --> 00:21:37,669
because they are some constant to the n
power and so they're actually really big

1118
00:21:37,669 --> 00:21:37,679
power and so they're actually really big
 

1119
00:21:37,679 --> 00:21:40,470
power and so they're actually really big
uh potential n is probably bigger than w

1120
00:21:40,470 --> 00:21:40,480
uh potential n is probably bigger than w
 

1121
00:21:40,480 --> 00:21:41,190
uh potential n is probably bigger than w
usually you

1122
00:21:41,190 --> 00:21:41,200
usually you
 

1123
00:21:41,200 --> 00:21:43,270
usually you
think of problems that are much bigger

1124
00:21:43,270 --> 00:21:43,280
think of problems that are much bigger
 

1125
00:21:43,280 --> 00:21:45,430
think of problems that are much bigger
than 64 or whatever your word size

1126
00:21:45,430 --> 00:21:45,440
than 64 or whatever your word size
 

1127
00:21:45,440 --> 00:21:46,470
than 64 or whatever your word size
happens to be

1128
00:21:46,470 --> 00:21:46,480
happens to be
 

1129
00:21:46,480 --> 00:21:48,789
happens to be
we do assume that w is at least log n

1130
00:21:48,789 --> 00:21:48,799
we do assume that w is at least log n
 

1131
00:21:48,799 --> 00:21:49,990
we do assume that w is at least log n
but n is

1132
00:21:49,990 --> 00:21:50,000
but n is
 

1133
00:21:50,000 --> 00:21:51,669
but n is
probably bigger than w might be bigger

1134
00:21:51,669 --> 00:21:51,679
probably bigger than w might be bigger
 

1135
00:21:51,679 --> 00:21:53,510
probably bigger than w might be bigger
or smaller we don't know

1136
00:21:53,510 --> 00:21:53,520
or smaller we don't know
 

1137
00:21:53,520 --> 00:21:57,430
or smaller we don't know
and in general to do an n bit addition

1138
00:21:57,430 --> 00:21:57,440
and in general to do an n bit addition
 

1139
00:21:57,440 --> 00:22:01,510
and in general to do an n bit addition
these are n bit additions

1140
00:22:01,510 --> 00:22:01,520
these are n bit additions
 

1141
00:22:01,520 --> 00:22:05,510
these are n bit additions
is going to take a ceiling of n over w

1142
00:22:05,510 --> 00:22:05,520
is going to take a ceiling of n over w
 

1143
00:22:05,520 --> 00:22:09,750
is going to take a ceiling of n over w
time so in the end we will spend

1144
00:22:09,750 --> 00:22:09,760
time so in the end we will spend
 

1145
00:22:09,760 --> 00:22:11,669
time so in the end we will spend
this times n because we have to do that

1146
00:22:11,669 --> 00:22:11,679
this times n because we have to do that
 

1147
00:22:11,679 --> 00:22:13,110
this times n because we have to do that
many of them which

1148
00:22:13,110 --> 00:22:13,120
many of them which
 

1149
00:22:13,120 --> 00:22:17,270
many of them which
is n plus n squared over w

1150
00:22:17,270 --> 00:22:17,280
is n plus n squared over w
 

1151
00:22:17,280 --> 00:22:19,830
is n plus n squared over w
time so a bit of a weird running time

1152
00:22:19,830 --> 00:22:19,840
time so a bit of a weird running time
 

1153
00:22:19,840 --> 00:22:20,390
time so a bit of a weird running time
but

1154
00:22:20,390 --> 00:22:20,400
but
 

1155
00:22:20,400 --> 00:22:23,350
but
it's polynomial whereas this original

1156
00:22:23,350 --> 00:22:23,360
it's polynomial whereas this original
 

1157
00:22:23,360 --> 00:22:25,909
it's polynomial whereas this original
recursive algorithm was exponential

1158
00:22:25,909 --> 00:22:25,919
recursive algorithm was exponential
 

1159
00:22:25,919 --> 00:22:28,390
recursive algorithm was exponential
here using this one simple idea of just

1160
00:22:28,390 --> 00:22:28,400
here using this one simple idea of just
 

1161
00:22:28,400 --> 00:22:29,830
here using this one simple idea of just
remembering the work we've done suddenly

1162
00:22:29,830 --> 00:22:29,840
remembering the work we've done suddenly
 

1163
00:22:29,840 --> 00:22:31,510
remembering the work we've done suddenly
this exponential time algorithm becomes

1164
00:22:31,510 --> 00:22:31,520
this exponential time algorithm becomes
 

1165
00:22:31,520 --> 00:22:32,390
this exponential time algorithm becomes
polynomial

1166
00:22:32,390 --> 00:22:32,400
polynomial
 

1167
00:22:32,400 --> 00:22:35,750
polynomial
why because we have few sub-problems we

1168
00:22:35,750 --> 00:22:35,760
why because we have few sub-problems we
 

1169
00:22:35,760 --> 00:22:37,029
why because we have few sub-problems we
had

1170
00:22:37,029 --> 00:22:37,039
had
 

1171
00:22:37,039 --> 00:22:40,390
had
n sub-problems

1172
00:22:40,390 --> 00:22:40,400
n sub-problems
 

1173
00:22:40,400 --> 00:22:42,070
n sub-problems
for each subproblem we could write a

1174
00:22:42,070 --> 00:22:42,080
for each subproblem we could write a
 

1175
00:22:42,080 --> 00:22:44,149
for each subproblem we could write a
recurrence relation that if we already

1176
00:22:44,149 --> 00:22:44,159
recurrence relation that if we already
 

1177
00:22:44,159 --> 00:22:44,789
recurrence relation that if we already
knew

1178
00:22:44,789 --> 00:22:44,799
knew
 

1179
00:22:44,799 --> 00:22:47,110
knew
the solutions to smaller sub-problems we

1180
00:22:47,110 --> 00:22:47,120
the solutions to smaller sub-problems we
 

1181
00:22:47,120 --> 00:22:48,230
the solutions to smaller sub-problems we
could compute

1182
00:22:48,230 --> 00:22:48,240
could compute
 

1183
00:22:48,240 --> 00:22:50,470
could compute
this bigger problem very efficiently

1184
00:22:50,470 --> 00:22:50,480
this bigger problem very efficiently
 

1185
00:22:50,480 --> 00:22:52,470
this bigger problem very efficiently
this happened to be constant time

1186
00:22:52,470 --> 00:22:52,480
this happened to be constant time
 

1187
00:22:52,480 --> 00:22:56,149
this happened to be constant time
or constant additions

1188
00:22:56,149 --> 00:22:56,159

 

1189
00:22:56,159 --> 00:22:58,630

n over w time but as long as this is

1190
00:22:58,630 --> 00:22:58,640
n over w time but as long as this is
 

1191
00:22:58,640 --> 00:22:59,510
n over w time but as long as this is
polynomial

1192
00:22:59,510 --> 00:22:59,520
polynomial
 

1193
00:22:59,520 --> 00:23:02,310
polynomial
and this is polynomial we're happy

1194
00:23:02,310 --> 00:23:02,320
and this is polynomial we're happy
 

1195
00:23:02,320 --> 00:23:03,270
and this is polynomial we're happy
because

1196
00:23:03,270 --> 00:23:03,280
because
 

1197
00:23:03,280 --> 00:23:05,590
because
we we have this nice formula that the

1198
00:23:05,590 --> 00:23:05,600
we we have this nice formula that the
 

1199
00:23:05,600 --> 00:23:06,789
we we have this nice formula that the
time

1200
00:23:06,789 --> 00:23:06,799
time
 

1201
00:23:06,799 --> 00:23:09,750
time
it takes is at most the sum over all sub

1202
00:23:09,750 --> 00:23:09,760
it takes is at most the sum over all sub
 

1203
00:23:09,760 --> 00:23:13,669
it takes is at most the sum over all sub
problems

1204
00:23:13,669 --> 00:23:13,679

 

1205
00:23:13,679 --> 00:23:18,470

of the relation time

1206
00:23:18,470 --> 00:23:18,480

 

1207
00:23:18,480 --> 00:23:22,390

okay so i'm referring to subproblems the

1208
00:23:22,390 --> 00:23:22,400
okay so i'm referring to subproblems the
 

1209
00:23:22,400 --> 00:23:25,510
okay so i'm referring to subproblems the
number of them and the time it takes to

1210
00:23:25,510 --> 00:23:25,520
number of them and the time it takes to
 

1211
00:23:25,520 --> 00:23:27,830
number of them and the time it takes to
evaluate this ignoring the recursive

1212
00:23:27,830 --> 00:23:27,840
evaluate this ignoring the recursive
 

1213
00:23:27,840 --> 00:23:30,149
evaluate this ignoring the recursive
calls that's important this is the

1214
00:23:30,149 --> 00:23:30,159
calls that's important this is the
 

1215
00:23:30,159 --> 00:23:38,070
calls that's important this is the
uh non-recursive part

1216
00:23:38,070 --> 00:23:38,080

 

1217
00:23:38,080 --> 00:23:40,390

in the notes i call this non-recursive

1218
00:23:40,390 --> 00:23:40,400
in the notes i call this non-recursive
 

1219
00:23:40,400 --> 00:23:45,590
in the notes i call this non-recursive
work

1220
00:23:45,590 --> 00:23:45,600

 

1221
00:23:45,600 --> 00:23:48,950

so this formula gives us a way to bound

1222
00:23:48,950 --> 00:23:48,960
so this formula gives us a way to bound
 

1223
00:23:48,960 --> 00:23:50,630
so this formula gives us a way to bound
the running time

1224
00:23:50,630 --> 00:23:50,640
the running time
 

1225
00:23:50,640 --> 00:23:52,870
the running time
of one of these algorithms if we use

1226
00:23:52,870 --> 00:23:52,880
of one of these algorithms if we use
 

1227
00:23:52,880 --> 00:23:53,990
of one of these algorithms if we use
memoization

1228
00:23:53,990 --> 00:23:54,000
memoization
 

1229
00:23:54,000 --> 00:23:55,590
memoization
without memoization this is not true

1230
00:23:55,590 --> 00:23:55,600
without memoization this is not true
 

1231
00:23:55,600 --> 00:23:57,590
without memoization this is not true
fibonacci took exponential time

1232
00:23:57,590 --> 00:23:57,600
fibonacci took exponential time
 

1233
00:23:57,600 --> 00:23:59,430
fibonacci took exponential time
but if we add memoization we know that

1234
00:23:59,430 --> 00:23:59,440
but if we add memoization we know that
 

1235
00:23:59,440 --> 00:24:01,430
but if we add memoization we know that
we only solve each sub problem once

1236
00:24:01,430 --> 00:24:01,440
we only solve each sub problem once
 

1237
00:24:01,440 --> 00:24:03,430
we only solve each sub problem once
and so we just need to see for each one

1238
00:24:03,430 --> 00:24:03,440
and so we just need to see for each one
 

1239
00:24:03,440 --> 00:24:05,430
and so we just need to see for each one
how much did it cost me to compute it

1240
00:24:05,430 --> 00:24:05,440
how much did it cost me to compute it
 

1241
00:24:05,440 --> 00:24:07,269
how much did it cost me to compute it
assuming all the recursion work is free

1242
00:24:07,269 --> 00:24:07,279
assuming all the recursion work is free
 

1243
00:24:07,279 --> 00:24:09,190
assuming all the recursion work is free
because that's already taken into

1244
00:24:09,190 --> 00:24:09,200
because that's already taken into
 

1245
00:24:09,200 --> 00:24:10,950
because that's already taken into
account by the summation

1246
00:24:10,950 --> 00:24:10,960
account by the summation
 

1247
00:24:10,960 --> 00:24:12,470
account by the summation
so in particular this summation is at

1248
00:24:12,470 --> 00:24:12,480
so in particular this summation is at
 

1249
00:24:12,480 --> 00:24:13,990
so in particular this summation is at
most the number of sub-problems

1250
00:24:13,990 --> 00:24:14,000
most the number of sub-problems
 

1251
00:24:14,000 --> 00:24:15,830
most the number of sub-problems
times the time per sub-problem which in

1252
00:24:15,830 --> 00:24:15,840
times the time per sub-problem which in
 

1253
00:24:15,840 --> 00:24:17,350
times the time per sub-problem which in
this case is order n

1254
00:24:17,350 --> 00:24:17,360
this case is order n
 

1255
00:24:17,360 --> 00:24:19,350
this case is order n
we could try to apply that analysis to

1256
00:24:19,350 --> 00:24:19,360
we could try to apply that analysis to
 

1257
00:24:19,360 --> 00:24:20,549
we could try to apply that analysis to
merge sort because

1258
00:24:20,549 --> 00:24:20,559
merge sort because
 

1259
00:24:20,559 --> 00:24:22,630
merge sort because
after all this is also a recursive

1260
00:24:22,630 --> 00:24:22,640
after all this is also a recursive
 

1261
00:24:22,640 --> 00:24:23,669
after all this is also a recursive
algorithm

1262
00:24:23,669 --> 00:24:23,679
algorithm
 

1263
00:24:23,679 --> 00:24:25,190
algorithm
it happens to not benefit from

1264
00:24:25,190 --> 00:24:25,200
it happens to not benefit from
 

1265
00:24:25,200 --> 00:24:26,710
it happens to not benefit from
memoization but we could throw in

1266
00:24:26,710 --> 00:24:26,720
memoization but we could throw in
 

1267
00:24:26,720 --> 00:24:29,029
memoization but we could throw in
memorization it wouldn't hurt us

1268
00:24:29,029 --> 00:24:29,039
memorization it wouldn't hurt us
 

1269
00:24:29,039 --> 00:24:30,630
memorization it wouldn't hurt us
but if you think about the call graph

1270
00:24:30,630 --> 00:24:30,640
but if you think about the call graph
 

1271
00:24:30,640 --> 00:24:34,230
but if you think about the call graph
here which is like

1272
00:24:34,230 --> 00:24:34,240
here which is like
 

1273
00:24:34,240 --> 00:24:37,430
here which is like
s of zero n which calls s

1274
00:24:37,430 --> 00:24:37,440
s of zero n which calls s
 

1275
00:24:37,440 --> 00:24:40,470
s of zero n which calls s
of n of zero n over two

1276
00:24:40,470 --> 00:24:40,480
of n of zero n over two
 

1277
00:24:40,480 --> 00:24:44,070
of n of zero n over two
and s of n over two n

1278
00:24:44,070 --> 00:24:44,080
and s of n over two n
 

1279
00:24:44,080 --> 00:24:46,789
and s of n over two n
and so on it has the same picture but

1280
00:24:46,789 --> 00:24:46,799
and so on it has the same picture but
 

1281
00:24:46,799 --> 00:24:47,909
and so on it has the same picture but
there's actually

1282
00:24:47,909 --> 00:24:47,919
there's actually
 

1283
00:24:47,919 --> 00:24:50,070
there's actually
no common substructure here you'll never

1284
00:24:50,070 --> 00:24:50,080
no common substructure here you'll never
 

1285
00:24:50,080 --> 00:24:52,230
no common substructure here you'll never
see a repeated sub-problem because

1286
00:24:52,230 --> 00:24:52,240
see a repeated sub-problem because
 

1287
00:24:52,240 --> 00:24:53,990
see a repeated sub-problem because
this range is completely disjoint from

1288
00:24:53,990 --> 00:24:54,000
this range is completely disjoint from
 

1289
00:24:54,000 --> 00:24:55,430
this range is completely disjoint from
this range

1290
00:24:55,430 --> 00:24:55,440
this range
 

1291
00:24:55,440 --> 00:24:56,950
this range
but you could throw in memorization and

1292
00:24:56,950 --> 00:24:56,960
but you could throw in memorization and
 

1293
00:24:56,960 --> 00:24:58,390
but you could throw in memorization and
try to analyze in the same way and say

1294
00:24:58,390 --> 00:24:58,400
try to analyze in the same way and say
 

1295
00:24:58,400 --> 00:25:01,190
try to analyze in the same way and say
well how many sub problems are there

1296
00:25:01,190 --> 00:25:01,200
well how many sub problems are there
 

1297
00:25:01,200 --> 00:25:03,590
well how many sub problems are there
well looks like there's there's n

1298
00:25:03,590 --> 00:25:03,600
well looks like there's there's n
 

1299
00:25:03,600 --> 00:25:05,350
well looks like there's there's n
choices for i

1300
00:25:05,350 --> 00:25:05,360
choices for i
 

1301
00:25:05,360 --> 00:25:08,630
choices for i
and not quite n choices but

1302
00:25:08,630 --> 00:25:08,640
and not quite n choices but
 

1303
00:25:08,640 --> 00:25:10,630
and not quite n choices but
in general it's at most n squared

1304
00:25:10,630 --> 00:25:10,640
in general it's at most n squared
 

1305
00:25:10,640 --> 00:25:12,070
in general it's at most n squared
different choices in fact it's the

1306
00:25:12,070 --> 00:25:12,080
different choices in fact it's the
 

1307
00:25:12,080 --> 00:25:14,630
different choices in fact it's the
triangular number

1308
00:25:14,630 --> 00:25:14,640
triangular number
 

1309
00:25:14,640 --> 00:25:17,830
triangular number
sum of i equals 1 to n of i

1310
00:25:17,830 --> 00:25:17,840
sum of i equals 1 to n of i
 

1311
00:25:17,840 --> 00:25:20,070
sum of i equals 1 to n of i
different possible choices for i and j

1312
00:25:20,070 --> 00:25:20,080
different possible choices for i and j
 

1313
00:25:20,080 --> 00:25:22,870
different possible choices for i and j
but this is theta n squared

1314
00:25:22,870 --> 00:25:22,880
but this is theta n squared
 

1315
00:25:22,880 --> 00:25:27,269
but this is theta n squared
sub problems which seems not so good

1316
00:25:27,269 --> 00:25:27,279
sub problems which seems not so good
 

1317
00:25:27,279 --> 00:25:28,630
sub problems which seems not so good
and then how much time are we spending

1318
00:25:28,630 --> 00:25:28,640
and then how much time are we spending
 

1319
00:25:28,640 --> 00:25:30,549
and then how much time are we spending
for per sub problem well

1320
00:25:30,549 --> 00:25:30,559
for per sub problem well
 

1321
00:25:30,559 --> 00:25:33,750
for per sub problem well
to solve s of i j we have to merge

1322
00:25:33,750 --> 00:25:33,760
to solve s of i j we have to merge
 

1323
00:25:33,760 --> 00:25:35,510
to solve s of i j we have to merge
about that many elements we know merge

1324
00:25:35,510 --> 00:25:35,520
about that many elements we know merge
 

1325
00:25:35,520 --> 00:25:37,669
about that many elements we know merge
takes linear time and so this takes

1326
00:25:37,669 --> 00:25:37,679
takes linear time and so this takes
 

1327
00:25:37,679 --> 00:25:40,789
takes linear time and so this takes
uh theta j minus i time

1328
00:25:40,789 --> 00:25:40,799
uh theta j minus i time
 

1329
00:25:40,799 --> 00:25:44,070
uh theta j minus i time
to evaluate and so

1330
00:25:44,070 --> 00:25:44,080
to evaluate and so
 

1331
00:25:44,080 --> 00:25:45,990
to evaluate and so
uh what we'd like to do is sum over all

1332
00:25:45,990 --> 00:25:46,000
uh what we'd like to do is sum over all
 

1333
00:25:46,000 --> 00:25:47,110
uh what we'd like to do is sum over all
the sub-problems

1334
00:25:47,110 --> 00:25:47,120
the sub-problems
 

1335
00:25:47,120 --> 00:25:50,149
the sub-problems
of j minus i this is the uh not

1336
00:25:50,149 --> 00:25:50,159
of j minus i this is the uh not
 

1337
00:25:50,159 --> 00:25:51,909
of j minus i this is the uh not
triangular number but the tetrahedral

1338
00:25:51,909 --> 00:25:51,919
triangular number but the tetrahedral
 

1339
00:25:51,919 --> 00:25:53,669
triangular number but the tetrahedral
number i guess

1340
00:25:53,669 --> 00:25:53,679
number i guess
 

1341
00:25:53,679 --> 00:25:55,909
number i guess
and so we end up that the running time

1342
00:25:55,909 --> 00:25:55,919
and so we end up that the running time
 

1343
00:25:55,919 --> 00:25:57,430
and so we end up that the running time
is at most

1344
00:25:57,430 --> 00:25:57,440
is at most
 

1345
00:25:57,440 --> 00:26:00,630
is at most
n cubed

1346
00:26:00,630 --> 00:26:00,640

 

1347
00:26:00,640 --> 00:26:04,230

great um so it's true that n log n is

1348
00:26:04,230 --> 00:26:04,240
great um so it's true that n log n is
 

1349
00:26:04,240 --> 00:26:05,750
great um so it's true that n log n is
less than or equal to n cubed

1350
00:26:05,750 --> 00:26:05,760
less than or equal to n cubed
 

1351
00:26:05,760 --> 00:26:07,750
less than or equal to n cubed
but obviously not terribly useful this

1352
00:26:07,750 --> 00:26:07,760
but obviously not terribly useful this
 

1353
00:26:07,760 --> 00:26:09,990
but obviously not terribly useful this
algorithm by the way we already know

1354
00:26:09,990 --> 00:26:10,000
algorithm by the way we already know
 

1355
00:26:10,000 --> 00:26:12,390
algorithm by the way we already know
how to analyze it is indeed n log n and

1356
00:26:12,390 --> 00:26:12,400
how to analyze it is indeed n log n and
 

1357
00:26:12,400 --> 00:26:14,070
how to analyze it is indeed n log n and
the running time turns out to be

1358
00:26:14,070 --> 00:26:14,080
the running time turns out to be
 

1359
00:26:14,080 --> 00:26:17,190
the running time turns out to be
theta n log n so

1360
00:26:17,190 --> 00:26:17,200
theta n log n so
 

1361
00:26:17,200 --> 00:26:19,269
theta n log n so
sometimes this is this equation is not

1362
00:26:19,269 --> 00:26:19,279
sometimes this is this equation is not
 

1363
00:26:19,279 --> 00:26:20,710
sometimes this is this equation is not
what you want to use

1364
00:26:20,710 --> 00:26:20,720
what you want to use
 

1365
00:26:20,720 --> 00:26:22,549
what you want to use
but often it's good enough and

1366
00:26:22,549 --> 00:26:22,559
but often it's good enough and
 

1367
00:26:22,559 --> 00:26:23,750
but often it's good enough and
especially if you just want to get a

1368
00:26:23,750 --> 00:26:23,760
especially if you just want to get a
 

1369
00:26:23,760 --> 00:26:25,350
especially if you just want to get a
polynomial upper bound and then you can

1370
00:26:25,350 --> 00:26:25,360
polynomial upper bound and then you can
 

1371
00:26:25,360 --> 00:26:27,029
polynomial upper bound and then you can
try to optimize it later

1372
00:26:27,029 --> 00:26:27,039
try to optimize it later
 

1373
00:26:27,039 --> 00:26:28,549
try to optimize it later
this will give you a polynomial upper

1374
00:26:28,549 --> 00:26:28,559
this will give you a polynomial upper
 

1375
00:26:28,559 --> 00:26:29,510
this will give you a polynomial upper
bound as long as the number of

1376
00:26:29,510 --> 00:26:29,520
bound as long as the number of
 

1377
00:26:29,520 --> 00:26:30,950
bound as long as the number of
subproblems is polynomial

1378
00:26:30,950 --> 00:26:30,960
subproblems is polynomial
 

1379
00:26:30,960 --> 00:26:32,230
subproblems is polynomial
and the time per subproblem is

1380
00:26:32,230 --> 00:26:32,240
and the time per subproblem is
 

1381
00:26:32,240 --> 00:26:34,549
and the time per subproblem is
polynomial and indeed

1382
00:26:34,549 --> 00:26:34,559
polynomial and indeed
 

1383
00:26:34,559 --> 00:26:36,149
polynomial and indeed
n cubed is polynomial it's not a great

1384
00:26:36,149 --> 00:26:36,159
n cubed is polynomial it's not a great
 

1385
00:26:36,159 --> 00:26:37,990
n cubed is polynomial it's not a great
polynomial but

1386
00:26:37,990 --> 00:26:38,000
polynomial but
 

1387
00:26:38,000 --> 00:26:40,149
polynomial but
this is a an alternate way to analyze

1388
00:26:40,149 --> 00:26:40,159
this is a an alternate way to analyze
 

1389
00:26:40,159 --> 00:26:41,590
this is a an alternate way to analyze
merge sort obviously

1390
00:26:41,590 --> 00:26:41,600
merge sort obviously
 

1391
00:26:41,600 --> 00:26:43,750
merge sort obviously
don't do this for merge sort but it

1392
00:26:43,750 --> 00:26:43,760
don't do this for merge sort but it
 

1393
00:26:43,760 --> 00:26:45,029
don't do this for merge sort but it
illustrates the

1394
00:26:45,029 --> 00:26:45,039
illustrates the
 

1395
00:26:45,039 --> 00:26:49,029
illustrates the
technique good so far

1396
00:26:49,029 --> 00:26:49,039
technique good so far
 

1397
00:26:49,039 --> 00:26:52,149
technique good so far
any questions all right

1398
00:26:52,149 --> 00:26:52,159
any questions all right
 

1399
00:26:52,159 --> 00:26:57,590
any questions all right
uh let me remember where we are

1400
00:26:57,590 --> 00:26:57,600

 

1401
00:26:57,600 --> 00:27:00,549

cool so the next thing i'd like to do is

1402
00:27:00,549 --> 00:27:00,559
cool so the next thing i'd like to do is
 

1403
00:27:00,559 --> 00:27:01,110
cool so the next thing i'd like to do is
uh

1404
00:27:01,110 --> 00:27:01,120
uh
 

1405
00:27:01,120 --> 00:27:02,549
uh
show you one more algorithm that we've

1406
00:27:02,549 --> 00:27:02,559
show you one more algorithm that we've
 

1407
00:27:02,559 --> 00:27:04,230
show you one more algorithm that we've
already seen in this class that fits

1408
00:27:04,230 --> 00:27:04,240
already seen in this class that fits
 

1409
00:27:04,240 --> 00:27:07,350
already seen in this class that fits
very nicely into this structure

1410
00:27:07,350 --> 00:27:07,360
very nicely into this structure
 

1411
00:27:07,360 --> 00:27:09,990
very nicely into this structure
arguably is a dynamic program and that

1412
00:27:09,990 --> 00:27:10,000
arguably is a dynamic program and that
 

1413
00:27:10,000 --> 00:27:10,470
arguably is a dynamic program and that
is

1414
00:27:10,470 --> 00:27:10,480
is
 

1415
00:27:10,480 --> 00:27:14,070
is
uh dag shortest paths oh so just to

1416
00:27:14,070 --> 00:27:14,080
uh dag shortest paths oh so just to
 

1417
00:27:14,080 --> 00:27:15,430
uh dag shortest paths oh so just to
close the loop here

1418
00:27:15,430 --> 00:27:15,440
close the loop here
 

1419
00:27:15,440 --> 00:27:18,830
close the loop here
when i say dynamic programming i mean

1420
00:27:18,830 --> 00:27:18,840
when i say dynamic programming i mean
 

1421
00:27:18,840 --> 00:27:21,909
when i say dynamic programming i mean
recursion with memoization

1422
00:27:21,909 --> 00:27:21,919
recursion with memoization
 

1423
00:27:21,919 --> 00:27:25,510
recursion with memoization
i mean we take we we

1424
00:27:25,510 --> 00:27:25,520
i mean we take we we
 

1425
00:27:25,520 --> 00:27:28,470
i mean we take we we
write a recursive piece of code which is

1426
00:27:28,470 --> 00:27:28,480
write a recursive piece of code which is
 

1427
00:27:28,480 --> 00:27:29,029
write a recursive piece of code which is
like

1428
00:27:29,029 --> 00:27:29,039
like
 

1429
00:27:29,039 --> 00:27:32,470
like
def f of some args um

1430
00:27:32,470 --> 00:27:32,480
def f of some args um
 

1431
00:27:32,480 --> 00:27:38,070
def f of some args um
some you know sub-problem specification

1432
00:27:38,070 --> 00:27:38,080

 

1433
00:27:38,080 --> 00:27:42,310

we check is the sub-problem uh

1434
00:27:42,310 --> 00:27:42,320
we check is the sub-problem uh
 

1435
00:27:42,320 --> 00:27:45,590
we check is the sub-problem uh
in the memo table if so

1436
00:27:45,590 --> 00:27:45,600
in the memo table if so
 

1437
00:27:45,600 --> 00:27:50,310
in the memo table if so
uh return

1438
00:27:50,310 --> 00:27:50,320

 

1439
00:27:50,320 --> 00:27:56,470

memo of subproblem

1440
00:27:56,470 --> 00:27:56,480

 

1441
00:27:56,480 --> 00:27:59,909

and otherwise

1442
00:27:59,909 --> 00:27:59,919

 

1443
00:27:59,919 --> 00:28:01,909

check if it's a base case if and solve

1444
00:28:01,909 --> 00:28:01,919
check if it's a base case if and solve
 

1445
00:28:01,919 --> 00:28:04,070
check if it's a base case if and solve
it if it's a base case and otherwise

1446
00:28:04,070 --> 00:28:04,080
it if it's a base case and otherwise
 

1447
00:28:04,080 --> 00:28:07,190
it if it's a base case and otherwise
write the uh

1448
00:28:07,190 --> 00:28:07,200

 

1449
00:28:07,200 --> 00:28:10,789

recurrence recurse via

1450
00:28:10,789 --> 00:28:10,799
recurrence recurse via
 

1451
00:28:10,799 --> 00:28:14,630
recurrence recurse via
relation

1452
00:28:14,630 --> 00:28:14,640

 

1453
00:28:14,640 --> 00:28:19,269

and set the memo table

1454
00:28:19,269 --> 00:28:19,279

 

1455
00:28:19,279 --> 00:28:21,669

of the subproblem to be one of those

1456
00:28:21,669 --> 00:28:21,679
of the subproblem to be one of those
 

1457
00:28:21,679 --> 00:28:23,110
of the subproblem to be one of those
things

1458
00:28:23,110 --> 00:28:23,120
things
 

1459
00:28:23,120 --> 00:28:25,350
things
okay so this is the generic dynamic

1460
00:28:25,350 --> 00:28:25,360
okay so this is the generic dynamic
 

1461
00:28:25,360 --> 00:28:26,230
okay so this is the generic dynamic
program

1462
00:28:26,230 --> 00:28:26,240
program
 

1463
00:28:26,240 --> 00:28:29,750
program
and implicitly i'm writing fibonacci

1464
00:28:29,750 --> 00:28:29,760
and implicitly i'm writing fibonacci
 

1465
00:28:29,760 --> 00:28:33,110
and implicitly i'm writing fibonacci
in that way and all of the dynamic

1466
00:28:33,110 --> 00:28:33,120
in that way and all of the dynamic
 

1467
00:28:33,120 --> 00:28:35,269
in that way and all of the dynamic
programs have this implicit structure

1468
00:28:35,269 --> 00:28:35,279
programs have this implicit structure
 

1469
00:28:35,279 --> 00:28:37,590
programs have this implicit structure
where i start with a memo table which is

1470
00:28:37,590 --> 00:28:37,600
where i start with a memo table which is
 

1471
00:28:37,600 --> 00:28:41,029
where i start with a memo table which is
empty

1472
00:28:41,029 --> 00:28:41,039

 

1473
00:28:41,039 --> 00:28:43,269

and i always just check if i'm in the

1474
00:28:43,269 --> 00:28:43,279
and i always just check if i'm in the
 

1475
00:28:43,279 --> 00:28:44,310
and i always just check if i'm in the
memo table

1476
00:28:44,310 --> 00:28:44,320
memo table
 

1477
00:28:44,320 --> 00:28:46,710
memo table
if i am i return it otherwise i compute

1478
00:28:46,710 --> 00:28:46,720
if i am i return it otherwise i compute
 

1479
00:28:46,720 --> 00:28:50,470
if i am i return it otherwise i compute
according to this recursive relation

1480
00:28:50,470 --> 00:28:50,480
according to this recursive relation
 

1481
00:28:50,480 --> 00:28:54,470
according to this recursive relation
by recursively calling f

1482
00:28:54,470 --> 00:28:54,480

 

1483
00:28:54,480 --> 00:28:57,029

and that's it so this is every dp

1484
00:28:57,029 --> 00:28:57,039
and that's it so this is every dp
 

1485
00:28:57,039 --> 00:28:58,070
and that's it so this is every dp
algorithm is going to have that

1486
00:28:58,070 --> 00:28:58,080
algorithm is going to have that
 

1487
00:28:58,080 --> 00:29:00,389
algorithm is going to have that
structure

1488
00:29:00,389 --> 00:29:00,399
structure
 

1489
00:29:00,399 --> 00:29:02,549
structure
and it's just using recursion and

1490
00:29:02,549 --> 00:29:02,559
and it's just using recursion and
 

1491
00:29:02,559 --> 00:29:04,710
and it's just using recursion and
memorization together

1492
00:29:04,710 --> 00:29:04,720
memorization together
 

1493
00:29:04,720 --> 00:29:06,870
memorization together
okay so now let's apply that technique

1494
00:29:06,870 --> 00:29:06,880
okay so now let's apply that technique
 

1495
00:29:06,880 --> 00:29:09,430
okay so now let's apply that technique
to think about the dag shortest paths

1496
00:29:09,430 --> 00:29:09,440
to think about the dag shortest paths
 

1497
00:29:09,440 --> 00:29:12,630
to think about the dag shortest paths
problem the problem was i give you a dag

1498
00:29:12,630 --> 00:29:12,640
problem the problem was i give you a dag
 

1499
00:29:12,640 --> 00:29:14,070
problem the problem was i give you a dag
i give you a source vertex

1500
00:29:14,070 --> 00:29:14,080
i give you a source vertex
 

1501
00:29:14,080 --> 00:29:16,789
i give you a source vertex
s single source shortest paths compute

1502
00:29:16,789 --> 00:29:16,799
s single source shortest paths compute
 

1503
00:29:16,799 --> 00:29:18,389
s single source shortest paths compute
the shortest path weight

1504
00:29:18,389 --> 00:29:18,399
the shortest path weight
 

1505
00:29:18,399 --> 00:29:20,950
the shortest path weight
from s to every vertex that's the goal

1506
00:29:20,950 --> 00:29:20,960
from s to every vertex that's the goal
 

1507
00:29:20,960 --> 00:29:22,230
from s to every vertex that's the goal
of the problem

1508
00:29:22,230 --> 00:29:22,240
of the problem
 

1509
00:29:22,240 --> 00:29:23,909
of the problem
and we saw a way to solve that which is

1510
00:29:23,909 --> 00:29:23,919
and we saw a way to solve that which is
 

1511
00:29:23,919 --> 00:29:25,669
and we saw a way to solve that which is
dag relaxation i'm going to show you a

1512
00:29:25,669 --> 00:29:25,679
dag relaxation i'm going to show you a
 

1513
00:29:25,679 --> 00:29:25,990
dag relaxation i'm going to show you a
different

1514
00:29:25,990 --> 00:29:26,000
different
 

1515
00:29:26,000 --> 00:29:27,750
different
way which turns out to be basically the

1516
00:29:27,750 --> 00:29:27,760
way which turns out to be basically the
 

1517
00:29:27,760 --> 00:29:29,669
way which turns out to be basically the
same but upside down

1518
00:29:29,669 --> 00:29:29,679
same but upside down
 

1519
00:29:29,679 --> 00:29:32,950
same but upside down
or flipped left to right depending which

1520
00:29:32,950 --> 00:29:32,960
or flipped left to right depending which
 

1521
00:29:32,960 --> 00:29:33,430
or flipped left to right depending which
way you

1522
00:29:33,430 --> 00:29:33,440
way you
 

1523
00:29:33,440 --> 00:29:36,950
way you
direct your edges so

1524
00:29:36,950 --> 00:29:36,960
direct your edges so
 

1525
00:29:36,960 --> 00:29:38,710
direct your edges so
what are our sub problems well here

1526
00:29:38,710 --> 00:29:38,720
what are our sub problems well here
 

1527
00:29:38,720 --> 00:29:39,909
what are our sub problems well here
actually they're kind of spelled out for

1528
00:29:39,909 --> 00:29:39,919
actually they're kind of spelled out for
 

1529
00:29:39,919 --> 00:29:42,070
actually they're kind of spelled out for
us we want to compute delta of sv for

1530
00:29:42,070 --> 00:29:42,080
us we want to compute delta of sv for
 

1531
00:29:42,080 --> 00:29:42,549
us we want to compute delta of sv for
all v

1532
00:29:42,549 --> 00:29:42,559
all v
 

1533
00:29:42,559 --> 00:29:47,029
all v
so that is uh size of these sub-problems

1534
00:29:47,029 --> 00:29:47,039
so that is uh size of these sub-problems
 

1535
00:29:47,039 --> 00:29:50,149
so that is uh size of these sub-problems
that turns out to be enough for this

1536
00:29:50,149 --> 00:29:50,159
that turns out to be enough for this
 

1537
00:29:50,159 --> 00:29:52,710
that turns out to be enough for this
overall problem and the original problem

1538
00:29:52,710 --> 00:29:52,720
overall problem and the original problem
 

1539
00:29:52,720 --> 00:29:53,510
overall problem and the original problem
we want to solve

1540
00:29:53,510 --> 00:29:53,520
we want to solve
 

1541
00:29:53,520 --> 00:29:55,430
we want to solve
is all of the sub problems we solve all

1542
00:29:55,430 --> 00:29:55,440
is all of the sub problems we solve all
 

1543
00:29:55,440 --> 00:29:56,950
is all of the sub problems we solve all
the sub problems we're done

1544
00:29:56,950 --> 00:29:56,960
the sub problems we're done
 

1545
00:29:56,960 --> 00:29:59,830
the sub problems we're done
and then we have uh i think we wrote

1546
00:29:59,830 --> 00:29:59,840
and then we have uh i think we wrote
 

1547
00:29:59,840 --> 00:30:01,430
and then we have uh i think we wrote
this at some point during

1548
00:30:01,430 --> 00:30:01,440
this at some point during
 

1549
00:30:01,440 --> 00:30:04,149
this at some point during
the dag shortest paths lecture we have a

1550
00:30:04,149 --> 00:30:04,159
the dag shortest paths lecture we have a
 

1551
00:30:04,159 --> 00:30:06,149
the dag shortest paths lecture we have a
recursive relation saying that

1552
00:30:06,149 --> 00:30:06,159
recursive relation saying that
 

1553
00:30:06,159 --> 00:30:09,110
recursive relation saying that
the the shortest way to get from s to v

1554
00:30:09,110 --> 00:30:09,120
the the shortest way to get from s to v
 

1555
00:30:09,120 --> 00:30:11,190
the the shortest way to get from s to v
is the minimum

1556
00:30:11,190 --> 00:30:11,200
is the minimum
 

1557
00:30:11,200 --> 00:30:13,110
is the minimum
of the shortest path to get to some

1558
00:30:13,110 --> 00:30:13,120
of the shortest path to get to some
 

1559
00:30:13,120 --> 00:30:14,230
of the shortest path to get to some
vertex u

1560
00:30:14,230 --> 00:30:14,240
vertex u
 

1561
00:30:14,240 --> 00:30:16,230
vertex u
plus the weight of the edge from u to v

1562
00:30:16,230 --> 00:30:16,240
plus the weight of the edge from u to v
 

1563
00:30:16,240 --> 00:30:19,430
plus the weight of the edge from u to v
why because if we look at a vertex v

1564
00:30:19,430 --> 00:30:19,440
why because if we look at a vertex v
 

1565
00:30:19,440 --> 00:30:21,909
why because if we look at a vertex v
unless we started there we came from

1566
00:30:21,909 --> 00:30:21,919
unless we started there we came from
 

1567
00:30:21,919 --> 00:30:23,190
unless we started there we came from
somewhere

1568
00:30:23,190 --> 00:30:23,200
somewhere
 

1569
00:30:23,200 --> 00:30:26,389
somewhere
and so we can consider all of the

1570
00:30:26,389 --> 00:30:26,399
and so we can consider all of the
 

1571
00:30:26,399 --> 00:30:27,029
and so we can consider all of the
possible

1572
00:30:27,029 --> 00:30:27,039
possible
 

1573
00:30:27,039 --> 00:30:30,470
possible
choices for the previous vertex u and

1574
00:30:30,470 --> 00:30:30,480
choices for the previous vertex u and
 

1575
00:30:30,480 --> 00:30:33,110
choices for the previous vertex u and
if you start at s and get to v you must

1576
00:30:33,110 --> 00:30:33,120
if you start at s and get to v you must
 

1577
00:30:33,120 --> 00:30:34,789
if you start at s and get to v you must
go through one of them

1578
00:30:34,789 --> 00:30:34,799
go through one of them
 

1579
00:30:34,799 --> 00:30:36,950
go through one of them
and so this is finding the best way

1580
00:30:36,950 --> 00:30:36,960
and so this is finding the best way
 

1581
00:30:36,960 --> 00:30:38,710
and so this is finding the best way
among all the choices of you

1582
00:30:38,710 --> 00:30:38,720
among all the choices of you
 

1583
00:30:38,720 --> 00:30:40,549
among all the choices of you
uh what's the best way to get to you and

1584
00:30:40,549 --> 00:30:40,559
uh what's the best way to get to you and
 

1585
00:30:40,559 --> 00:30:41,990
uh what's the best way to get to you and
then take the edge from u to v

1586
00:30:41,990 --> 00:30:42,000
then take the edge from u to v
 

1587
00:30:42,000 --> 00:30:45,590
then take the edge from u to v
for all edges uv and this is adjacency

1588
00:30:45,590 --> 00:30:45,600
for all edges uv and this is adjacency
 

1589
00:30:45,600 --> 00:30:48,310
for all edges uv and this is adjacency
minus we don't usually think of that

1590
00:30:48,310 --> 00:30:48,320
minus we don't usually think of that
 

1591
00:30:48,320 --> 00:30:50,070
minus we don't usually think of that
usually we look at adjacency plus the

1592
00:30:50,070 --> 00:30:50,080
usually we look at adjacency plus the
 

1593
00:30:50,080 --> 00:30:51,750
usually we look at adjacency plus the
outgoing edges this is the incoming

1594
00:30:51,750 --> 00:30:51,760
outgoing edges this is the incoming
 

1595
00:30:51,760 --> 00:30:52,950
outgoing edges this is the incoming
edges

1596
00:30:52,950 --> 00:30:52,960
edges
 

1597
00:30:52,960 --> 00:30:56,149
edges
and so u is an incoming uv is an

1598
00:30:56,149 --> 00:30:56,159
and so u is an incoming uv is an
 

1599
00:30:56,159 --> 00:30:58,389
and so u is an incoming uv is an
incoming edge into v

1600
00:30:58,389 --> 00:30:58,399
incoming edge into v
 

1601
00:30:58,399 --> 00:31:00,070
incoming edge into v
okay if we take that minimum and of

1602
00:31:00,070 --> 00:31:00,080
okay if we take that minimum and of
 

1603
00:31:00,080 --> 00:31:01,830
okay if we take that minimum and of
course the possible there

1604
00:31:01,830 --> 00:31:01,840
course the possible there
 

1605
00:31:01,840 --> 00:31:03,590
course the possible there
there is no way to get to v and so i'll

1606
00:31:03,590 --> 00:31:03,600
there is no way to get to v and so i'll
 

1607
00:31:03,600 --> 00:31:05,830
there is no way to get to v and so i'll
also throw infinity into this set

1608
00:31:05,830 --> 00:31:05,840
also throw infinity into this set
 

1609
00:31:05,840 --> 00:31:07,750
also throw infinity into this set
take the min of that set that will give

1610
00:31:07,750 --> 00:31:07,760
take the min of that set that will give
 

1611
00:31:07,760 --> 00:31:09,350
take the min of that set that will give
me the shortest path weight

1612
00:31:09,350 --> 00:31:09,360
me the shortest path weight
 

1613
00:31:09,360 --> 00:31:12,149
me the shortest path weight
in an acyclic graph from s to v and

1614
00:31:12,149 --> 00:31:12,159
in an acyclic graph from s to v and
 

1615
00:31:12,159 --> 00:31:13,990
in an acyclic graph from s to v and
great this is recursive right this was a

1616
00:31:13,990 --> 00:31:14,000
great this is recursive right this was a
 

1617
00:31:14,000 --> 00:31:14,789
great this is recursive right this was a
sub problem

1618
00:31:14,789 --> 00:31:14,799
sub problem
 

1619
00:31:14,799 --> 00:31:18,389
sub problem
these are sub problems which are smaller

1620
00:31:18,389 --> 00:31:18,399
these are sub problems which are smaller
 

1621
00:31:18,399 --> 00:31:20,470
these are sub problems which are smaller
i guess there's no clear notion of

1622
00:31:20,470 --> 00:31:20,480
i guess there's no clear notion of
 

1623
00:31:20,480 --> 00:31:22,470
i guess there's no clear notion of
smaller here

1624
00:31:22,470 --> 00:31:22,480
smaller here
 

1625
00:31:22,480 --> 00:31:24,710
smaller here
except we already know the clear notion

1626
00:31:24,710 --> 00:31:24,720
except we already know the clear notion
 

1627
00:31:24,720 --> 00:31:25,909
except we already know the clear notion
of smaller is

1628
00:31:25,909 --> 00:31:25,919
of smaller is
 

1629
00:31:25,919 --> 00:31:30,470
of smaller is
the topological order of our dag

1630
00:31:30,470 --> 00:31:30,480
the topological order of our dag
 

1631
00:31:30,480 --> 00:31:32,070
the topological order of our dag
because our graph is acyclic we know it

1632
00:31:32,070 --> 00:31:32,080
because our graph is acyclic we know it
 

1633
00:31:32,080 --> 00:31:33,430
because our graph is acyclic we know it
has a topological order we know how to

1634
00:31:33,430 --> 00:31:33,440
has a topological order we know how to
 

1635
00:31:33,440 --> 00:31:36,230
has a topological order we know how to
compute it with dfs

1636
00:31:36,230 --> 00:31:36,240
compute it with dfs
 

1637
00:31:36,240 --> 00:31:38,710
compute it with dfs
and so that guarantees uh there's a

1638
00:31:38,710 --> 00:31:38,720
and so that guarantees uh there's a
 

1639
00:31:38,720 --> 00:31:40,470
and so that guarantees uh there's a
topological order to compute these

1640
00:31:40,470 --> 00:31:40,480
topological order to compute these
 

1641
00:31:40,480 --> 00:31:41,669
topological order to compute these
problems

1642
00:31:41,669 --> 00:31:41,679
problems
 

1643
00:31:41,679 --> 00:31:45,029
problems
and in fact the the relationship

1644
00:31:45,029 --> 00:31:45,039
and in fact the the relationship
 

1645
00:31:45,039 --> 00:31:48,389
and in fact the the relationship
between problems is exactly

1646
00:31:48,389 --> 00:31:48,399
between problems is exactly
 

1647
00:31:48,399 --> 00:31:51,269
between problems is exactly
the given graph g in order to compute

1648
00:31:51,269 --> 00:31:51,279
the given graph g in order to compute
 

1649
00:31:51,279 --> 00:31:53,190
the given graph g in order to compute
the shortest path weight from

1650
00:31:53,190 --> 00:31:53,200
the shortest path weight from
 

1651
00:31:53,200 --> 00:31:55,190
the shortest path weight from
s to v i need to know the shortest

1652
00:31:55,190 --> 00:31:55,200
s to v i need to know the shortest
 

1653
00:31:55,200 --> 00:31:57,190
s to v i need to know the shortest
pathway from s to all of the incoming

1654
00:31:57,190 --> 00:31:57,200
pathway from s to all of the incoming
 

1655
00:31:57,200 --> 00:31:58,070
pathway from s to all of the incoming
vertices

1656
00:31:58,070 --> 00:31:58,080
vertices
 

1657
00:31:58,080 --> 00:32:01,190
vertices
to v and so this is uh i guess

1658
00:32:01,190 --> 00:32:01,200
to v and so this is uh i guess
 

1659
00:32:01,200 --> 00:32:04,389
to v and so this is uh i guess
in the call graph this vertex calls this

1660
00:32:04,389 --> 00:32:04,399
in the call graph this vertex calls this
 

1661
00:32:04,399 --> 00:32:05,509
in the call graph this vertex calls this
vertex

1662
00:32:05,509 --> 00:32:05,519
vertex
 

1663
00:32:05,519 --> 00:32:07,830
vertex
but i'll direct the edge this way to say

1664
00:32:07,830 --> 00:32:07,840
but i'll direct the edge this way to say
 

1665
00:32:07,840 --> 00:32:09,269
but i'll direct the edge this way to say
that this vertex

1666
00:32:09,269 --> 00:32:09,279
that this vertex
 

1667
00:32:09,279 --> 00:32:12,950
that this vertex
requires uh this vertex needs to be

1668
00:32:12,950 --> 00:32:12,960
requires uh this vertex needs to be
 

1669
00:32:12,960 --> 00:32:14,789
requires uh this vertex needs to be
computed before this one

1670
00:32:14,789 --> 00:32:14,799
computed before this one
 

1671
00:32:14,799 --> 00:32:16,149
computed before this one
and so then i can compute them in a

1672
00:32:16,149 --> 00:32:16,159
and so then i can compute them in a
 

1673
00:32:16,159 --> 00:32:18,630
and so then i can compute them in a
topological order

1674
00:32:18,630 --> 00:32:18,640
topological order
 

1675
00:32:18,640 --> 00:32:20,549
topological order
okay we have a base case which is delta

1676
00:32:20,549 --> 00:32:20,559
okay we have a base case which is delta
 

1677
00:32:20,559 --> 00:32:22,710
okay we have a base case which is delta
of ss equals zero

1678
00:32:22,710 --> 00:32:22,720
of ss equals zero
 

1679
00:32:22,720 --> 00:32:25,990
of ss equals zero
and the running time is again we can use

1680
00:32:25,990 --> 00:32:26,000
and the running time is again we can use
 

1681
00:32:26,000 --> 00:32:27,909
and the running time is again we can use
this formula and say let's just sum over

1682
00:32:27,909 --> 00:32:27,919
this formula and say let's just sum over
 

1683
00:32:27,919 --> 00:32:29,110
this formula and say let's just sum over
all the sub-problems

1684
00:32:29,110 --> 00:32:29,120
all the sub-problems
 

1685
00:32:29,120 --> 00:32:30,789
all the sub-problems
of the non-recursive work in our

1686
00:32:30,789 --> 00:32:30,799
of the non-recursive work in our
 

1687
00:32:30,799 --> 00:32:32,230
of the non-recursive work in our
recurrence relation

1688
00:32:32,230 --> 00:32:32,240
recurrence relation
 

1689
00:32:32,240 --> 00:32:35,269
recurrence relation
and so it's computing this min if i gave

1690
00:32:35,269 --> 00:32:35,279
and so it's computing this min if i gave
 

1691
00:32:35,279 --> 00:32:36,549
and so it's computing this min if i gave
you

1692
00:32:36,549 --> 00:32:36,559
you
 

1693
00:32:36,559 --> 00:32:39,190
you
these deltas for free and i gave you

1694
00:32:39,190 --> 00:32:39,200
these deltas for free and i gave you
 

1695
00:32:39,200 --> 00:32:40,950
these deltas for free and i gave you
these weights which we know

1696
00:32:40,950 --> 00:32:40,960
these weights which we know
 

1697
00:32:40,960 --> 00:32:43,029
these weights which we know
from our weight data structure how long

1698
00:32:43,029 --> 00:32:43,039
from our weight data structure how long
 

1699
00:32:43,039 --> 00:32:44,630
from our weight data structure how long
does it take to compute this min well

1700
00:32:44,630 --> 00:32:44,640
does it take to compute this min well
 

1701
00:32:44,640 --> 00:32:46,149
does it take to compute this min well
however many things there are and how

1702
00:32:46,149 --> 00:32:46,159
however many things there are and how
 

1703
00:32:46,159 --> 00:32:47,430
however many things there are and how
many numbers were

1704
00:32:47,430 --> 00:32:47,440
many numbers were
 

1705
00:32:47,440 --> 00:32:49,990
many numbers were
were mining which is the size of the

1706
00:32:49,990 --> 00:32:50,000
were mining which is the size of the
 

1707
00:32:50,000 --> 00:32:51,750
were mining which is the size of the
incoming adjacency list

1708
00:32:51,750 --> 00:32:51,760
incoming adjacency list
 

1709
00:32:51,760 --> 00:32:54,710
incoming adjacency list
plus one for that infinity and so if you

1710
00:32:54,710 --> 00:32:54,720
plus one for that infinity and so if you
 

1711
00:32:54,720 --> 00:32:56,230
plus one for that infinity and so if you
compute this sum

1712
00:32:56,230 --> 00:32:56,240
compute this sum
 

1713
00:32:56,240 --> 00:32:57,990
compute this sum
sum of incoming edges to every vertex

1714
00:32:57,990 --> 00:32:58,000
sum of incoming edges to every vertex
 

1715
00:32:58,000 --> 00:32:59,909
sum of incoming edges to every vertex
that's all the edges

1716
00:32:59,909 --> 00:32:59,919
that's all the edges
 

1717
00:32:59,919 --> 00:33:04,389
that's all the edges
so this is v plus e okay so

1718
00:33:04,389 --> 00:33:04,399
so this is v plus e okay so
 

1719
00:33:04,399 --> 00:33:07,909
so this is v plus e okay so
in fact this algorithm is

1720
00:33:07,909 --> 00:33:07,919
in fact this algorithm is
 

1721
00:33:07,919 --> 00:33:09,750
in fact this algorithm is
morally the same algorithm is the one

1722
00:33:09,750 --> 00:33:09,760
morally the same algorithm is the one
 

1723
00:33:09,760 --> 00:33:11,190
morally the same algorithm is the one
that we saw in the dag shortest path

1724
00:33:11,190 --> 00:33:11,200
that we saw in the dag shortest path
 

1725
00:33:11,200 --> 00:33:11,830
that we saw in the dag shortest path
lecture

1726
00:33:11,830 --> 00:33:11,840
lecture
 

1727
00:33:11,840 --> 00:33:15,750
lecture
which was computer topological order

1728
00:33:15,750 --> 00:33:15,760
which was computer topological order
 

1729
00:33:15,760 --> 00:33:19,269
which was computer topological order
and process vertices in that order

1730
00:33:19,269 --> 00:33:19,279
and process vertices in that order
 

1731
00:33:19,279 --> 00:33:22,870
and process vertices in that order
and relax edges going out from

1732
00:33:22,870 --> 00:33:22,880
and relax edges going out from
 

1733
00:33:22,880 --> 00:33:25,909
and relax edges going out from
vertices so here uh so in

1734
00:33:25,909 --> 00:33:25,919
vertices so here uh so in
 

1735
00:33:25,919 --> 00:33:27,750
vertices so here uh so in
in that algorithm we would have uh tried

1736
00:33:27,750 --> 00:33:27,760
in that algorithm we would have uh tried
 

1737
00:33:27,760 --> 00:33:28,950
in that algorithm we would have uh tried
to relax this edge

1738
00:33:28,950 --> 00:33:28,960
to relax this edge
 

1739
00:33:28,960 --> 00:33:31,190
to relax this edge
if if there's a better path to v and the

1740
00:33:31,190 --> 00:33:31,200
if if there's a better path to v and the
 

1741
00:33:31,200 --> 00:33:32,549
if if there's a better path to v and the
first one certainly is better than

1742
00:33:32,549 --> 00:33:32,559
first one certainly is better than
 

1743
00:33:32,559 --> 00:33:33,350
first one certainly is better than
infinity

1744
00:33:33,350 --> 00:33:33,360
infinity
 

1745
00:33:33,360 --> 00:33:36,470
infinity
so the first one we relax uh indeed

1746
00:33:36,470 --> 00:33:36,480
so the first one we relax uh indeed
 

1747
00:33:36,480 --> 00:33:38,230
so the first one we relax uh indeed
uh the next edge if this is a if this

1748
00:33:38,230 --> 00:33:38,240
uh the next edge if this is a if this
 

1749
00:33:38,240 --> 00:33:40,070
uh the next edge if this is a if this
gave a better path from s to v then we

1750
00:33:40,070 --> 00:33:40,080
gave a better path from s to v then we
 

1751
00:33:40,080 --> 00:33:41,509
gave a better path from s to v then we
would relax that edge and update the

1752
00:33:41,509 --> 00:33:41,519
would relax that edge and update the
 

1753
00:33:41,519 --> 00:33:42,310
would relax that edge and update the
weight here

1754
00:33:42,310 --> 00:33:42,320
weight here
 

1755
00:33:42,320 --> 00:33:44,149
weight here
and do the same here in the end we're

1756
00:33:44,149 --> 00:33:44,159
and do the same here in the end we're
 

1757
00:33:44,159 --> 00:33:45,909
and do the same here in the end we're
just computing this min

1758
00:33:45,909 --> 00:33:45,919
just computing this min
 

1759
00:33:45,919 --> 00:33:47,590
just computing this min
in the relaxation algorithm but doing it

1760
00:33:47,590 --> 00:33:47,600
in the relaxation algorithm but doing it
 

1761
00:33:47,600 --> 00:33:49,750
in the relaxation algorithm but doing it
step by step in the in the relaxation

1762
00:33:49,750 --> 00:33:49,760
step by step in the in the relaxation
 

1763
00:33:49,760 --> 00:33:51,509
step by step in the in the relaxation
algorithm tag relaxation

1764
00:33:51,509 --> 00:33:51,519
algorithm tag relaxation
 

1765
00:33:51,519 --> 00:33:55,110
algorithm tag relaxation
we for each incoming edge to v

1766
00:33:55,110 --> 00:33:55,120
we for each incoming edge to v
 

1767
00:33:55,120 --> 00:33:58,710
we for each incoming edge to v
we update d of v if it's better

1768
00:33:58,710 --> 00:33:58,720
we update d of v if it's better
 

1769
00:33:58,720 --> 00:34:01,269
we update d of v if it's better
and so if you if you repeatedly update

1770
00:34:01,269 --> 00:34:01,279
and so if you if you repeatedly update
 

1771
00:34:01,279 --> 00:34:02,710
and so if you if you repeatedly update
if you're better that ends up computing

1772
00:34:02,710 --> 00:34:02,720
if you're better that ends up computing
 

1773
00:34:02,720 --> 00:34:04,230
if you're better that ends up computing
a min

1774
00:34:04,230 --> 00:34:04,240
a min
 

1775
00:34:04,240 --> 00:34:06,470
a min
okay so this is the same algorithm just

1776
00:34:06,470 --> 00:34:06,480
okay so this is the same algorithm just
 

1777
00:34:06,480 --> 00:34:08,389
okay so this is the same algorithm just
kind of flipped backwards

1778
00:34:08,389 --> 00:34:08,399
kind of flipped backwards
 

1779
00:34:08,399 --> 00:34:10,950
kind of flipped backwards
uh a funny thing although we wrote down

1780
00:34:10,950 --> 00:34:10,960
uh a funny thing although we wrote down
 

1781
00:34:10,960 --> 00:34:12,790
uh a funny thing although we wrote down
the topological order

1782
00:34:12,790 --> 00:34:12,800
the topological order
 

1783
00:34:12,800 --> 00:34:15,669
the topological order
of the subproblem graph here is the

1784
00:34:15,669 --> 00:34:15,679
of the subproblem graph here is the
 

1785
00:34:15,679 --> 00:34:17,990
of the subproblem graph here is the
topological order of g because

1786
00:34:17,990 --> 00:34:18,000
topological order of g because
 

1787
00:34:18,000 --> 00:34:21,909
topological order of g because
the sub-problem graph is g

1788
00:34:21,909 --> 00:34:21,919

 

1789
00:34:21,919 --> 00:34:23,510

the algorithm doesn't actually have to

1790
00:34:23,510 --> 00:34:23,520
the algorithm doesn't actually have to
 

1791
00:34:23,520 --> 00:34:25,349
the algorithm doesn't actually have to
compute one it's doing it

1792
00:34:25,349 --> 00:34:25,359
compute one it's doing it
 

1793
00:34:25,359 --> 00:34:27,510
compute one it's doing it
automatically for free if you think

1794
00:34:27,510 --> 00:34:27,520
automatically for free if you think
 

1795
00:34:27,520 --> 00:34:28,629
automatically for free if you think
about

1796
00:34:28,629 --> 00:34:28,639
about
 

1797
00:34:28,639 --> 00:34:31,669
about
this algorithm a generic

1798
00:34:31,669 --> 00:34:31,679
this algorithm a generic
 

1799
00:34:31,679 --> 00:34:34,790
this algorithm a generic
dp algorithm which is check whether

1800
00:34:34,790 --> 00:34:34,800
dp algorithm which is check whether
 

1801
00:34:34,800 --> 00:34:36,869
dp algorithm which is check whether
we're in a memo table if so return

1802
00:34:36,869 --> 00:34:36,879
we're in a memo table if so return
 

1803
00:34:36,879 --> 00:34:40,710
we're in a memo table if so return
otherwise recurse or base case

1804
00:34:40,710 --> 00:34:40,720
otherwise recurse or base case
 

1805
00:34:40,720 --> 00:34:43,190
otherwise recurse or base case
this actually is a depth for search

1806
00:34:43,190 --> 00:34:43,200
this actually is a depth for search
 

1807
00:34:43,200 --> 00:34:44,790
this actually is a depth for search
through the sub-problem graph

1808
00:34:44,790 --> 00:34:44,800
through the sub-problem graph
 

1809
00:34:44,800 --> 00:34:47,030
through the sub-problem graph
technically through the reverse of the

1810
00:34:47,030 --> 00:34:47,040
technically through the reverse of the
 

1811
00:34:47,040 --> 00:34:48,310
technically through the reverse of the
subproblem graph

1812
00:34:48,310 --> 00:34:48,320
subproblem graph
 

1813
00:34:48,320 --> 00:34:51,349
subproblem graph
if i draw an edge

1814
00:34:51,349 --> 00:34:51,359
if i draw an edge
 

1815
00:34:51,359 --> 00:34:55,349
if i draw an edge
so from small

1816
00:34:55,349 --> 00:34:55,359
so from small
 

1817
00:34:55,359 --> 00:34:58,710
so from small
to big so

1818
00:34:58,710 --> 00:34:58,720
to big so
 

1819
00:34:58,720 --> 00:35:01,190
to big so
if i'm just saying i orient the edges

1820
00:35:01,190 --> 00:35:01,200
if i'm just saying i orient the edges
 

1821
00:35:01,200 --> 00:35:02,950
if i'm just saying i orient the edges
from my smaller sub problems to the ones

1822
00:35:02,950 --> 00:35:02,960
from my smaller sub problems to the ones
 

1823
00:35:02,960 --> 00:35:04,230
from my smaller sub problems to the ones
that need it

1824
00:35:04,230 --> 00:35:04,240
that need it
 

1825
00:35:04,240 --> 00:35:06,230
that need it
then i'm actually definitely searching

1826
00:35:06,230 --> 00:35:06,240
then i'm actually definitely searching
 

1827
00:35:06,240 --> 00:35:08,230
then i'm actually definitely searching
backwards in this graph

1828
00:35:08,230 --> 00:35:08,240
backwards in this graph
 

1829
00:35:08,240 --> 00:35:09,910
backwards in this graph
because the bigger problem calls the

1830
00:35:09,910 --> 00:35:09,920
because the bigger problem calls the
 

1831
00:35:09,920 --> 00:35:12,150
because the bigger problem calls the
smaller problem

1832
00:35:12,150 --> 00:35:12,160
smaller problem
 

1833
00:35:12,160 --> 00:35:14,710
smaller problem
and the memo table is serving as the

1834
00:35:14,710 --> 00:35:14,720
and the memo table is serving as the
 

1835
00:35:14,720 --> 00:35:15,990
and the memo table is serving as the
have i visited this vertex

1836
00:35:15,990 --> 00:35:16,000
have i visited this vertex
 

1837
00:35:16,000 --> 00:35:19,030
have i visited this vertex
already check in dfs so this is actually

1838
00:35:19,030 --> 00:35:19,040
already check in dfs so this is actually
 

1839
00:35:19,040 --> 00:35:20,390
already check in dfs so this is actually
a dfs algorithm

1840
00:35:20,390 --> 00:35:20,400
a dfs algorithm
 

1841
00:35:20,400 --> 00:35:23,510
a dfs algorithm
plus we're doing some computation

1842
00:35:23,510 --> 00:35:23,520
plus we're doing some computation
 

1843
00:35:23,520 --> 00:35:25,589
plus we're doing some computation
to actually solve the sub problems we

1844
00:35:25,589 --> 00:35:25,599
to actually solve the sub problems we
 

1845
00:35:25,599 --> 00:35:26,870
to actually solve the sub problems we
care about

1846
00:35:26,870 --> 00:35:26,880
care about
 

1847
00:35:26,880 --> 00:35:28,710
care about
so implicit in this algorithm we are

1848
00:35:28,710 --> 00:35:28,720
so implicit in this algorithm we are
 

1849
00:35:28,720 --> 00:35:29,990
so implicit in this algorithm we are
doing a dfs and at

1850
00:35:29,990 --> 00:35:30,000
doing a dfs and at
 

1851
00:35:30,000 --> 00:35:32,069
doing a dfs and at
the same time we're doing this shortest

1852
00:35:32,069 --> 00:35:32,079
the same time we're doing this shortest
 

1853
00:35:32,079 --> 00:35:33,670
the same time we're doing this shortest
path computation

1854
00:35:33,670 --> 00:35:33,680
path computation
 

1855
00:35:33,680 --> 00:35:36,870
path computation
uh in the finishing order of that dfs

1856
00:35:36,870 --> 00:35:36,880
uh in the finishing order of that dfs
 

1857
00:35:36,880 --> 00:35:37,589
uh in the finishing order of that dfs
traversal

1858
00:35:37,589 --> 00:35:37,599
traversal
 

1859
00:35:37,599 --> 00:35:39,190
traversal
because all the edges are backwards this

1860
00:35:39,190 --> 00:35:39,200
because all the edges are backwards this
 

1861
00:35:39,200 --> 00:35:40,950
because all the edges are backwards this
is the same as the reverse finishing

1862
00:35:40,950 --> 00:35:40,960
is the same as the reverse finishing
 

1863
00:35:40,960 --> 00:35:42,870
is the same as the reverse finishing
order if the graph is forwards so in the

1864
00:35:42,870 --> 00:35:42,880
order if the graph is forwards so in the
 

1865
00:35:42,880 --> 00:35:43,430
order if the graph is forwards so in the
end

1866
00:35:43,430 --> 00:35:43,440
end
 

1867
00:35:43,440 --> 00:35:46,230
end
we're computing a topological order

1868
00:35:46,230 --> 00:35:46,240
we're computing a topological order
 

1869
00:35:46,240 --> 00:35:46,950
we're computing a topological order
because

1870
00:35:46,950 --> 00:35:46,960
because
 

1871
00:35:46,960 --> 00:35:50,150
because
uh dynamic programming includes in it

1872
00:35:50,150 --> 00:35:50,160
uh dynamic programming includes in it
 

1873
00:35:50,160 --> 00:35:54,390
uh dynamic programming includes in it
uh depth first search oh a lot of words

1874
00:35:54,390 --> 00:35:54,400
uh depth first search oh a lot of words
 

1875
00:35:54,400 --> 00:35:57,030
uh depth first search oh a lot of words
but it's kind of cool that this

1876
00:35:57,030 --> 00:35:57,040
but it's kind of cool that this
 

1877
00:35:57,040 --> 00:35:59,349
but it's kind of cool that this
framework just solves dag shortest paths

1878
00:35:59,349 --> 00:35:59,359
framework just solves dag shortest paths
 

1879
00:35:59,359 --> 00:36:00,230
framework just solves dag shortest paths
without

1880
00:36:00,230 --> 00:36:00,240
without
 

1881
00:36:00,240 --> 00:36:03,270
without
much work i mean we we did a lot of work

1882
00:36:03,270 --> 00:36:03,280
much work i mean we we did a lot of work
 

1883
00:36:03,280 --> 00:36:04,550
much work i mean we we did a lot of work
in shorts paths to prove that this

1884
00:36:04,550 --> 00:36:04,560
in shorts paths to prove that this
 

1885
00:36:04,560 --> 00:36:05,670
in shorts paths to prove that this
relation is true

1886
00:36:05,670 --> 00:36:05,680
relation is true
 

1887
00:36:05,680 --> 00:36:07,430
relation is true
but once you know it's true the

1888
00:36:07,430 --> 00:36:07,440
but once you know it's true the
 

1889
00:36:07,440 --> 00:36:08,950
but once you know it's true the
algorithm part is

1890
00:36:08,950 --> 00:36:08,960
algorithm part is
 

1891
00:36:08,960 --> 00:36:12,390
algorithm part is
is pretty much free you just write down

1892
00:36:12,390 --> 00:36:12,400
is pretty much free you just write down
 

1893
00:36:12,400 --> 00:36:15,829
is pretty much free you just write down
sort bot and you're done

1894
00:36:15,829 --> 00:36:15,839

 

1895
00:36:15,839 --> 00:36:21,190

okay this brings us to

1896
00:36:21,190 --> 00:36:21,200
okay this brings us to
 

1897
00:36:21,200 --> 00:36:25,190
okay this brings us to
in general at this point we have seen

1898
00:36:25,190 --> 00:36:25,200
in general at this point we have seen
 

1899
00:36:25,200 --> 00:36:25,510
in general at this point we have seen
two

1900
00:36:25,510 --> 00:36:25,520
two
 

1901
00:36:25,520 --> 00:36:27,430
two
examples of dynamic programming i guess

1902
00:36:27,430 --> 00:36:27,440
examples of dynamic programming i guess
 

1903
00:36:27,440 --> 00:36:28,550
examples of dynamic programming i guess
technically merge sort

1904
00:36:28,550 --> 00:36:28,560
technically merge sort
 

1905
00:36:28,560 --> 00:36:29,910
technically merge sort
you can think of as a dynamic program

1906
00:36:29,910 --> 00:36:29,920
you can think of as a dynamic program
 

1907
00:36:29,920 --> 00:36:31,270
you can think of as a dynamic program
but it doesn't actually reuse anything

1908
00:36:31,270 --> 00:36:31,280
but it doesn't actually reuse anything
 

1909
00:36:31,280 --> 00:36:32,470
but it doesn't actually reuse anything
so it's not interesting

1910
00:36:32,470 --> 00:36:32,480
so it's not interesting
 

1911
00:36:32,480 --> 00:36:33,829
so it's not interesting
and indeed that gave us a really bad

1912
00:36:33,829 --> 00:36:33,839
and indeed that gave us a really bad
 

1913
00:36:33,839 --> 00:36:35,750
and indeed that gave us a really bad
bound we've definitely seen bag shortest

1914
00:36:35,750 --> 00:36:35,760
bound we've definitely seen bag shortest
 

1915
00:36:35,760 --> 00:36:36,310
bound we've definitely seen bag shortest
paths

1916
00:36:36,310 --> 00:36:36,320
paths
 

1917
00:36:36,320 --> 00:36:38,310
paths
and fibonacci numbers as two interesting

1918
00:36:38,310 --> 00:36:38,320
and fibonacci numbers as two interesting
 

1919
00:36:38,320 --> 00:36:39,349
and fibonacci numbers as two interesting
examples

1920
00:36:39,349 --> 00:36:39,359
examples
 

1921
00:36:39,359 --> 00:36:41,670
examples
and what the next remainder of this

1922
00:36:41,670 --> 00:36:41,680
and what the next remainder of this
 

1923
00:36:41,680 --> 00:36:43,430
and what the next remainder of this
lecture and the next three lectures are

1924
00:36:43,430 --> 00:36:43,440
lecture and the next three lectures are
 

1925
00:36:43,440 --> 00:36:44,550
lecture and the next three lectures are
going to be about

1926
00:36:44,550 --> 00:36:44,560
going to be about
 

1927
00:36:44,560 --> 00:36:47,430
going to be about
is more and more examples of dynamic

1928
00:36:47,430 --> 00:36:47,440
is more and more examples of dynamic
 

1929
00:36:47,440 --> 00:36:49,030
is more and more examples of dynamic
programming and how you can use it to

1930
00:36:49,030 --> 00:36:49,040
programming and how you can use it to
 

1931
00:36:49,040 --> 00:36:49,670
programming and how you can use it to
solve

1932
00:36:49,670 --> 00:36:49,680
solve
 

1933
00:36:49,680 --> 00:36:51,589
solve
increasingly general problems so far

1934
00:36:51,589 --> 00:36:51,599
increasingly general problems so far
 

1935
00:36:51,599 --> 00:36:53,109
increasingly general problems so far
we've just solved an easy problem

1936
00:36:53,109 --> 00:36:53,119
we've just solved an easy problem
 

1937
00:36:53,119 --> 00:36:54,310
we've just solved an easy problem
and a problem we already knew how to

1938
00:36:54,310 --> 00:36:54,320
and a problem we already knew how to
 

1939
00:36:54,320 --> 00:37:00,150
and a problem we already knew how to
solve let's go to a new problem

1940
00:37:00,150 --> 00:37:00,160

 

1941
00:37:00,160 --> 00:37:03,670

which is bowling bowling is popular in

1942
00:37:03,670 --> 00:37:03,680
which is bowling bowling is popular in
 

1943
00:37:03,680 --> 00:37:06,150
which is bowling bowling is popular in
boston

1944
00:37:06,150 --> 00:37:06,160
boston
 

1945
00:37:06,160 --> 00:37:09,670
boston
this boston likes to play candlepin

1946
00:37:09,670 --> 00:37:09,680
this boston likes to play candlepin
 

1947
00:37:09,680 --> 00:37:11,589
this boston likes to play candlepin
bowling which is a bit unusual

1948
00:37:11,589 --> 00:37:11,599
bowling which is a bit unusual
 

1949
00:37:11,599 --> 00:37:13,510
bowling which is a bit unusual
uh today we're going to play an even

1950
00:37:13,510 --> 00:37:13,520
uh today we're going to play an even
 

1951
00:37:13,520 --> 00:37:15,589
uh today we're going to play an even
more unusual bowling game

1952
00:37:15,589 --> 00:37:15,599
more unusual bowling game
 

1953
00:37:15,599 --> 00:37:18,550
more unusual bowling game
one that i made up based on a bowling

1954
00:37:18,550 --> 00:37:18,560
one that i made up based on a bowling
 

1955
00:37:18,560 --> 00:37:19,030
one that i made up based on a bowling
game

1956
00:37:19,030 --> 00:37:19,040
game
 

1957
00:37:19,040 --> 00:37:22,710
game
that henry dudeny made up in 1908

1958
00:37:22,710 --> 00:37:22,720
that henry dudeny made up in 1908
 

1959
00:37:22,720 --> 00:37:25,990
that henry dudeny made up in 1908
so ancient bowling i might call it

1960
00:37:25,990 --> 00:37:26,000
so ancient bowling i might call it
 

1961
00:37:26,000 --> 00:37:28,069
so ancient bowling i might call it
or i think linear bowling is what i

1962
00:37:28,069 --> 00:37:28,079
or i think linear bowling is what i
 

1963
00:37:28,079 --> 00:37:29,829
or i think linear bowling is what i
might call it i'll just call it bowling

1964
00:37:29,829 --> 00:37:29,839
might call it i'll just call it bowling
 

1965
00:37:29,839 --> 00:37:31,829
might call it i'll just call it bowling
here

1966
00:37:31,829 --> 00:37:31,839
here
 

1967
00:37:31,839 --> 00:37:33,829
here
and now i'm going to attempt to draw a

1968
00:37:33,829 --> 00:37:33,839
and now i'm going to attempt to draw a
 

1969
00:37:33,839 --> 00:37:36,790
and now i'm going to attempt to draw a
bowling pin not bad

1970
00:37:36,790 --> 00:37:36,800
bowling pin not bad
 

1971
00:37:36,800 --> 00:37:39,430
bowling pin not bad
that might get progressively worse so

1972
00:37:39,430 --> 00:37:39,440
that might get progressively worse so
 

1973
00:37:39,440 --> 00:37:40,470
that might get progressively worse so
imagine

1974
00:37:40,470 --> 00:37:40,480
imagine
 

1975
00:37:40,480 --> 00:37:42,710
imagine
n identical bowling pins please pretend

1976
00:37:42,710 --> 00:37:42,720
n identical bowling pins please pretend
 

1977
00:37:42,720 --> 00:37:43,990
n identical bowling pins please pretend
these are identical

1978
00:37:43,990 --> 00:37:44,000
these are identical
 

1979
00:37:44,000 --> 00:37:47,030
these are identical
and i have a ball which is

1980
00:37:47,030 --> 00:37:47,040
and i have a ball which is
 

1981
00:37:47,040 --> 00:37:49,430
and i have a ball which is
approximately the same size as a bowling

1982
00:37:49,430 --> 00:37:49,440
approximately the same size as a bowling
 

1983
00:37:49,440 --> 00:37:51,349
approximately the same size as a bowling
pin these bowling pins are

1984
00:37:51,349 --> 00:37:51,359
pin these bowling pins are
 

1985
00:37:51,359 --> 00:37:52,710
pin these bowling pins are
pretty close together i should have left

1986
00:37:52,710 --> 00:37:52,720
pretty close together i should have left
 

1987
00:37:52,720 --> 00:37:54,630
pretty close together i should have left
a little gap here

1988
00:37:54,630 --> 00:37:54,640
a little gap here
 

1989
00:37:54,640 --> 00:37:57,349
a little gap here
and you're a really good bowler now

1990
00:37:57,349 --> 00:37:57,359
and you're a really good bowler now
 

1991
00:37:57,359 --> 00:37:58,790
and you're a really good bowler now
unfortunately these bowling

1992
00:37:58,790 --> 00:37:58,800
unfortunately these bowling
 

1993
00:37:58,800 --> 00:38:01,510
unfortunately these bowling
pins are on a line and you're bowling

1994
00:38:01,510 --> 00:38:01,520
pins are on a line and you're bowling
 

1995
00:38:01,520 --> 00:38:02,230
pins are on a line and you're bowling
from

1996
00:38:02,230 --> 00:38:02,240
from
 

1997
00:38:02,240 --> 00:38:06,069
from
way down at infinity so when you bowl

1998
00:38:06,069 --> 00:38:06,079
way down at infinity so when you bowl
 

1999
00:38:06,079 --> 00:38:09,349
way down at infinity so when you bowl
um you can only hit one pin or two pins

2000
00:38:09,349 --> 00:38:09,359
um you can only hit one pin or two pins
 

2001
00:38:09,359 --> 00:38:09,750
um you can only hit one pin or two pins
or

2002
00:38:09,750 --> 00:38:09,760
or
 

2003
00:38:09,760 --> 00:38:11,430
or
zero pins but probably you want to hit

2004
00:38:11,430 --> 00:38:11,440
zero pins but probably you want to hit
 

2005
00:38:11,440 --> 00:38:13,589
zero pins but probably you want to hit
some pins uh so if you

2006
00:38:13,589 --> 00:38:13,599
some pins uh so if you
 

2007
00:38:13,599 --> 00:38:15,589
some pins uh so if you
pull straight at a pin you will just hit

2008
00:38:15,589 --> 00:38:15,599
pull straight at a pin you will just hit
 

2009
00:38:15,599 --> 00:38:16,870
pull straight at a pin you will just hit
that one pin

2010
00:38:16,870 --> 00:38:16,880
that one pin
 

2011
00:38:16,880 --> 00:38:19,589
that one pin
and if you bowl in the middle between

2012
00:38:19,589 --> 00:38:19,599
and if you bowl in the middle between
 

2013
00:38:19,599 --> 00:38:20,630
and if you bowl in the middle between
two pins

2014
00:38:20,630 --> 00:38:20,640
two pins
 

2015
00:38:20,640 --> 00:38:23,589
two pins
you will knock down that's a ball sorry

2016
00:38:23,589 --> 00:38:23,599
you will knock down that's a ball sorry
 

2017
00:38:23,599 --> 00:38:24,470
you will knock down that's a ball sorry
you will knock down

2018
00:38:24,470 --> 00:38:24,480
you will knock down
 

2019
00:38:24,480 --> 00:38:27,270
you will knock down
two pins okay this is your model of

2020
00:38:27,270 --> 00:38:27,280
two pins okay this is your model of
 

2021
00:38:27,280 --> 00:38:28,470
two pins okay this is your model of
bowling

2022
00:38:28,470 --> 00:38:28,480
bowling
 

2023
00:38:28,480 --> 00:38:31,829
bowling
model of computation now what makes this

2024
00:38:31,829 --> 00:38:31,839
model of computation now what makes this
 

2025
00:38:31,839 --> 00:38:35,990
model of computation now what makes this
interesting is that the pins have values

2026
00:38:35,990 --> 00:38:36,000
interesting is that the pins have values
 

2027
00:38:36,000 --> 00:38:39,430
interesting is that the pins have values
pin i has value

2028
00:38:39,430 --> 00:38:39,440
pin i has value
 

2029
00:38:39,440 --> 00:38:42,550
pin i has value
yeah this is obviously a toy problem uh

2030
00:38:42,550 --> 00:38:42,560
yeah this is obviously a toy problem uh
 

2031
00:38:42,560 --> 00:38:45,030
yeah this is obviously a toy problem uh
though this problem this type of bowling

2032
00:38:45,030 --> 00:38:45,040
though this problem this type of bowling
 

2033
00:38:45,040 --> 00:38:47,510
though this problem this type of bowling
does go back to 1908

2034
00:38:47,510 --> 00:38:47,520
does go back to 1908
 

2035
00:38:47,520 --> 00:38:49,270
does go back to 1908
it was also a toy problem in that

2036
00:38:49,270 --> 00:38:49,280
it was also a toy problem in that
 

2037
00:38:49,280 --> 00:38:51,190
it was also a toy problem in that
setting so each of these

2038
00:38:51,190 --> 00:38:51,200
setting so each of these
 

2039
00:38:51,200 --> 00:38:55,349
setting so each of these
uh bowling pins has some number on it

2040
00:38:55,349 --> 00:38:55,359
uh bowling pins has some number on it
 

2041
00:38:55,359 --> 00:39:00,310
uh bowling pins has some number on it
let's say one nine nine

2042
00:39:00,310 --> 00:39:00,320
let's say one nine nine
 

2043
00:39:00,320 --> 00:39:02,630
let's say one nine nine
let me do a slightly more interesting

2044
00:39:02,630 --> 00:39:02,640
let me do a slightly more interesting
 

2045
00:39:02,640 --> 00:39:05,030
let me do a slightly more interesting
example maybe another one here

2046
00:39:05,030 --> 00:39:05,040
example maybe another one here
 

2047
00:39:05,040 --> 00:39:08,230
example maybe another one here
uh and a two

2048
00:39:08,230 --> 00:39:08,240
uh and a two
 

2049
00:39:08,240 --> 00:39:11,109
uh and a two
and a five and a five something like

2050
00:39:11,109 --> 00:39:11,119
and a five and a five something like
 

2051
00:39:11,119 --> 00:39:13,270
and a five and a five something like
this

2052
00:39:13,270 --> 00:39:13,280
this
 

2053
00:39:13,280 --> 00:39:16,470
this
okay uh or maybe make a little more

2054
00:39:16,470 --> 00:39:16,480
okay uh or maybe make a little more
 

2055
00:39:16,480 --> 00:39:17,589
okay uh or maybe make a little more
interesting let's put some negative

2056
00:39:17,589 --> 00:39:17,599
interesting let's put some negative
 

2057
00:39:17,599 --> 00:39:19,349
interesting let's put some negative
numbers on here

2058
00:39:19,349 --> 00:39:19,359
numbers on here
 

2059
00:39:19,359 --> 00:39:21,510
numbers on here
okay and the model uh so you're at the

2060
00:39:21,510 --> 00:39:21,520
okay and the model uh so you're at the
 

2061
00:39:21,520 --> 00:39:23,990
okay and the model uh so you're at the
carnival bowling

2062
00:39:23,990 --> 00:39:24,000
carnival bowling
 

2063
00:39:24,000 --> 00:39:26,069
carnival bowling
each pin has different potentially

2064
00:39:26,069 --> 00:39:26,079
each pin has different potentially
 

2065
00:39:26,079 --> 00:39:27,430
each pin has different potentially
different values

2066
00:39:27,430 --> 00:39:27,440
different values
 

2067
00:39:27,440 --> 00:39:31,270
different values
and the model is if you hit

2068
00:39:31,270 --> 00:39:31,280
and the model is if you hit
 

2069
00:39:31,280 --> 00:39:35,109
and the model is if you hit
one pin i

2070
00:39:35,109 --> 00:39:35,119
one pin i
 

2071
00:39:35,119 --> 00:39:38,150
one pin i
then you get vi points

2072
00:39:38,150 --> 00:39:38,160
then you get vi points
 

2073
00:39:38,160 --> 00:39:40,710
then you get vi points
so that's straightforward to make it

2074
00:39:40,710 --> 00:39:40,720
so that's straightforward to make it
 

2075
00:39:40,720 --> 00:39:41,349
so that's straightforward to make it
interesting

2076
00:39:41,349 --> 00:39:41,359
interesting
 

2077
00:39:41,359 --> 00:39:43,750
interesting
when you hit two pins you get the

2078
00:39:43,750 --> 00:39:43,760
when you hit two pins you get the
 

2079
00:39:43,760 --> 00:39:45,109
when you hit two pins you get the
product

2080
00:39:45,109 --> 00:39:45,119
product
 

2081
00:39:45,119 --> 00:39:47,190
product
so if i hit two pins it's always i and i

2082
00:39:47,190 --> 00:39:47,200
so if i hit two pins it's always i and i
 

2083
00:39:47,200 --> 00:39:48,470
so if i hit two pins it's always i and i
plus one

2084
00:39:48,470 --> 00:39:48,480
plus one
 

2085
00:39:48,480 --> 00:39:54,829
plus one
for some i you get vi times vi plus one

2086
00:39:54,829 --> 00:39:54,839

 

2087
00:39:54,839 --> 00:39:57,109

points this is the

2088
00:39:57,109 --> 00:39:57,119
points this is the
 

2089
00:39:57,119 --> 00:39:58,470
points this is the
the game you're playing and it doesn't

2090
00:39:58,470 --> 00:39:58,480
the game you're playing and it doesn't
 

2091
00:39:58,480 --> 00:40:00,710
the game you're playing and it doesn't
really matter that this is a product

2092
00:40:00,710 --> 00:40:00,720
really matter that this is a product
 

2093
00:40:00,720 --> 00:40:03,270
really matter that this is a product
uh product is just some weird function

2094
00:40:03,270 --> 00:40:03,280
uh product is just some weird function
 

2095
00:40:03,280 --> 00:40:04,550
uh product is just some weird function
that's hard to

2096
00:40:04,550 --> 00:40:04,560
that's hard to
 

2097
00:40:04,560 --> 00:40:07,349
that's hard to
imagine if you stare at this long enough

2098
00:40:07,349 --> 00:40:07,359
imagine if you stare at this long enough
 

2099
00:40:07,359 --> 00:40:08,950
imagine if you stare at this long enough
you should convince yourself that the

2100
00:40:08,950 --> 00:40:08,960
you should convince yourself that the
 

2101
00:40:08,960 --> 00:40:11,670
you should convince yourself that the
optimal solution is probably to

2102
00:40:11,670 --> 00:40:11,680
optimal solution is probably to
 

2103
00:40:11,680 --> 00:40:13,190
optimal solution is probably to
so for each of these numbers i could

2104
00:40:13,190 --> 00:40:13,200
so for each of these numbers i could
 

2105
00:40:13,200 --> 00:40:15,190
so for each of these numbers i could
leave it singleton or pair it with its

2106
00:40:15,190 --> 00:40:15,200
leave it singleton or pair it with its
 

2107
00:40:15,200 --> 00:40:16,630
leave it singleton or pair it with its
left neighbor or pair it with its right

2108
00:40:16,630 --> 00:40:16,640
left neighbor or pair it with its right
 

2109
00:40:16,640 --> 00:40:18,230
left neighbor or pair it with its right
neighbor but the pairings can't overlap

2110
00:40:18,230 --> 00:40:18,240
neighbor but the pairings can't overlap
 

2111
00:40:18,240 --> 00:40:19,510
neighbor but the pairings can't overlap
because once i hit a pin

2112
00:40:19,510 --> 00:40:19,520
because once i hit a pin
 

2113
00:40:19,520 --> 00:40:21,829
because once i hit a pin
it's gone it's knocked over and it

2114
00:40:21,829 --> 00:40:21,839
it's gone it's knocked over and it
 

2115
00:40:21,839 --> 00:40:22,630
it's gone it's knocked over and it
disappears

2116
00:40:22,630 --> 00:40:22,640
disappears
 

2117
00:40:22,640 --> 00:40:24,950
disappears
so because of these nines which are very

2118
00:40:24,950 --> 00:40:24,960
so because of these nines which are very
 

2119
00:40:24,960 --> 00:40:25,750
so because of these nines which are very
high

2120
00:40:25,750 --> 00:40:25,760
high
 

2121
00:40:25,760 --> 00:40:27,270
high
value what i'd probably like to do is

2122
00:40:27,270 --> 00:40:27,280
value what i'd probably like to do is
 

2123
00:40:27,280 --> 00:40:29,190
value what i'd probably like to do is
hit both of them together so pair them

2124
00:40:29,190 --> 00:40:29,200
hit both of them together so pair them
 

2125
00:40:29,200 --> 00:40:30,630
hit both of them together so pair them
up

2126
00:40:30,630 --> 00:40:30,640
up
 

2127
00:40:30,640 --> 00:40:32,870
up
because 9 times 9 is 81 that's really

2128
00:40:32,870 --> 00:40:32,880
because 9 times 9 is 81 that's really
 

2129
00:40:32,880 --> 00:40:34,069
because 9 times 9 is 81 that's really
big much better than hitting them

2130
00:40:34,069 --> 00:40:34,079
big much better than hitting them
 

2131
00:40:34,079 --> 00:40:35,990
big much better than hitting them
individually or hitting 9 times 1 or 9

2132
00:40:35,990 --> 00:40:36,000
individually or hitting 9 times 1 or 9
 

2133
00:40:36,000 --> 00:40:37,750
individually or hitting 9 times 1 or 9
times 2.

2134
00:40:37,750 --> 00:40:37,760
times 2.
 

2135
00:40:37,760 --> 00:40:39,510
times 2.
one and one is kind of funny because

2136
00:40:39,510 --> 00:40:39,520
one and one is kind of funny because
 

2137
00:40:39,520 --> 00:40:40,710
one and one is kind of funny because
it's actually better to hit them

2138
00:40:40,710 --> 00:40:40,720
it's actually better to hit them
 

2139
00:40:40,720 --> 00:40:41,589
it's actually better to hit them
individually

2140
00:40:41,589 --> 00:40:41,599
individually
 

2141
00:40:41,599 --> 00:40:43,109
individually
that will give you two points whereas if

2142
00:40:43,109 --> 00:40:43,119
that will give you two points whereas if
 

2143
00:40:43,119 --> 00:40:46,150
that will give you two points whereas if
i pair them up i only get one point

2144
00:40:46,150 --> 00:40:46,160
i pair them up i only get one point
 

2145
00:40:46,160 --> 00:40:47,750
i pair them up i only get one point
two and minus five that seems bad

2146
00:40:47,750 --> 00:40:47,760
two and minus five that seems bad
 

2147
00:40:47,760 --> 00:40:49,750
two and minus five that seems bad
negative ten points my goal is to

2148
00:40:49,750 --> 00:40:49,760
negative ten points my goal is to
 

2149
00:40:49,760 --> 00:40:56,790
negative ten points my goal is to
maximize score

2150
00:40:56,790 --> 00:40:56,800

 

2151
00:40:56,800 --> 00:41:00,150

do you have to hit all the pins

2152
00:41:00,150 --> 00:41:00,160

 

2153
00:41:00,160 --> 00:41:01,670

let's say no you don't have to hit all

2154
00:41:01,670 --> 00:41:01,680
let's say no you don't have to hit all
 

2155
00:41:01,680 --> 00:41:04,710
let's say no you don't have to hit all
the pins so i could skip the minus fives

2156
00:41:04,710 --> 00:41:04,720
the pins so i could skip the minus fives
 

2157
00:41:04,720 --> 00:41:07,109
the pins so i could skip the minus fives
but in fact here uh because they're

2158
00:41:07,109 --> 00:41:07,119
but in fact here uh because they're
 

2159
00:41:07,119 --> 00:41:09,030
but in fact here uh because they're
adjacent minus five times minus five is

2160
00:41:09,030 --> 00:41:09,040
adjacent minus five times minus five is
 

2161
00:41:09,040 --> 00:41:11,109
adjacent minus five times minus five is
good that's 25 points

2162
00:41:11,109 --> 00:41:11,119
good that's 25 points
 

2163
00:41:11,119 --> 00:41:13,270
good that's 25 points
so uh the optimal solution for this

2164
00:41:13,270 --> 00:41:13,280
so uh the optimal solution for this
 

2165
00:41:13,280 --> 00:41:14,630
so uh the optimal solution for this
particular instance

2166
00:41:14,630 --> 00:41:14,640
particular instance
 

2167
00:41:14,640 --> 00:41:17,510
particular instance
are to hit all the pins these positive

2168
00:41:17,510 --> 00:41:17,520
are to hit all the pins these positive
 

2169
00:41:17,520 --> 00:41:17,990
are to hit all the pins these positive
uh

2170
00:41:17,990 --> 00:41:18,000
uh
 

2171
00:41:18,000 --> 00:41:20,630
uh
these together these together if i added

2172
00:41:20,630 --> 00:41:20,640
these together these together if i added
 

2173
00:41:20,640 --> 00:41:22,710
these together these together if i added
for example another pin of minus three

2174
00:41:22,710 --> 00:41:22,720
for example another pin of minus three
 

2175
00:41:22,720 --> 00:41:23,349
for example another pin of minus three
here

2176
00:41:23,349 --> 00:41:23,359
here
 

2177
00:41:23,359 --> 00:41:25,670
here
i would choose not to hit that pin good

2178
00:41:25,670 --> 00:41:25,680
i would choose not to hit that pin good
 

2179
00:41:25,680 --> 00:41:27,349
i would choose not to hit that pin good
question so

2180
00:41:27,349 --> 00:41:27,359
question so
 

2181
00:41:27,359 --> 00:41:29,510
question so
you just play until you are tired when

2182
00:41:29,510 --> 00:41:29,520
you just play until you are tired when
 

2183
00:41:29,520 --> 00:41:31,270
you just play until you are tired when
you decide to stop playing

2184
00:41:31,270 --> 00:41:31,280
you decide to stop playing
 

2185
00:41:31,280 --> 00:41:32,950
you decide to stop playing
how can i maximize your score there are

2186
00:41:32,950 --> 00:41:32,960
how can i maximize your score there are
 

2187
00:41:32,960 --> 00:41:34,630
how can i maximize your score there are
many variations this game

2188
00:41:34,630 --> 00:41:34,640
many variations this game
 

2189
00:41:34,640 --> 00:41:37,750
many variations this game
all of them basically any variation

2190
00:41:37,750 --> 00:41:37,760
all of them basically any variation
 

2191
00:41:37,760 --> 00:41:39,750
all of them basically any variation
not literally every variation but many

2192
00:41:39,750 --> 00:41:39,760
not literally every variation but many
 

2193
00:41:39,760 --> 00:41:41,349
not literally every variation but many
many variations of this problem can all

2194
00:41:41,349 --> 00:41:41,359
many variations of this problem can all
 

2195
00:41:41,359 --> 00:41:42,150
many variations of this problem can all
be solved

2196
00:41:42,150 --> 00:41:42,160
be solved
 

2197
00:41:42,160 --> 00:41:44,390
be solved
quickly with dynamic programming but

2198
00:41:44,390 --> 00:41:44,400
quickly with dynamic programming but
 

2199
00:41:44,400 --> 00:41:47,990
quickly with dynamic programming but
let's solve this particular one

2200
00:41:47,990 --> 00:41:48,000
let's solve this particular one
 

2201
00:41:48,000 --> 00:41:54,950
let's solve this particular one
okay um

2202
00:41:54,950 --> 00:41:54,960

 

2203
00:41:54,960 --> 00:41:57,270

so now we're really in algorithmic

2204
00:41:57,270 --> 00:41:57,280
so now we're really in algorithmic
 

2205
00:41:57,280 --> 00:41:58,309
so now we're really in algorithmic
design mode

2206
00:41:58,309 --> 00:41:58,319
design mode
 

2207
00:41:58,319 --> 00:42:01,589
design mode
we need to think about sort bot

2208
00:42:01,589 --> 00:42:01,599
we need to think about sort bot
 

2209
00:42:01,599 --> 00:42:03,190
we need to think about sort bot
and in particular we need to think about

2210
00:42:03,190 --> 00:42:03,200
and in particular we need to think about
 

2211
00:42:03,200 --> 00:42:04,870
and in particular we need to think about
what would the subproblems be

2212
00:42:04,870 --> 00:42:04,880
what would the subproblems be
 

2213
00:42:04,880 --> 00:42:06,950
what would the subproblems be
here and at this point we don't have a

2214
00:42:06,950 --> 00:42:06,960
here and at this point we don't have a
 

2215
00:42:06,960 --> 00:42:09,270
here and at this point we don't have a
lot of of help so i should probably give

2216
00:42:09,270 --> 00:42:09,280
lot of of help so i should probably give
 

2217
00:42:09,280 --> 00:42:11,190
lot of of help so i should probably give
you some tools

2218
00:42:11,190 --> 00:42:11,200
you some tools
 

2219
00:42:11,200 --> 00:42:13,190
you some tools
if i want to solve a problem like this

2220
00:42:13,190 --> 00:42:13,200
if i want to solve a problem like this
 

2221
00:42:13,200 --> 00:42:14,870
if i want to solve a problem like this
the input

2222
00:42:14,870 --> 00:42:14,880
the input
 

2223
00:42:14,880 --> 00:42:18,150
the input
is a sequence of numbers right it's a

2224
00:42:18,150 --> 00:42:18,160
is a sequence of numbers right it's a
 

2225
00:42:18,160 --> 00:42:18,870
is a sequence of numbers right it's a
sequence

2226
00:42:18,870 --> 00:42:18,880
sequence
 

2227
00:42:18,880 --> 00:42:20,390
sequence
data structure maybe it's an array of

2228
00:42:20,390 --> 00:42:20,400
data structure maybe it's an array of
 

2229
00:42:20,400 --> 00:42:23,030
data structure maybe it's an array of
numbers which is this v

2230
00:42:23,030 --> 00:42:23,040
numbers which is this v
 

2231
00:42:23,040 --> 00:42:26,550
numbers which is this v
v array

2232
00:42:26,550 --> 00:42:26,560

 

2233
00:42:26,560 --> 00:42:30,309

and let's see

2234
00:42:30,309 --> 00:42:30,319
and let's see
 

2235
00:42:30,319 --> 00:42:39,510
and let's see
um a general tool for subproblem design

2236
00:42:39,510 --> 00:42:39,520

 

2237
00:42:39,520 --> 00:42:41,510

which will cover most of the problems

2238
00:42:41,510 --> 00:42:41,520
which will cover most of the problems
 

2239
00:42:41,520 --> 00:42:43,510
which will cover most of the problems
maybe all of the problems that we

2240
00:42:43,510 --> 00:42:43,520
maybe all of the problems that we
 

2241
00:42:43,520 --> 00:42:45,430
maybe all of the problems that we
see in this class for dynamic

2242
00:42:45,430 --> 00:42:45,440
see in this class for dynamic
 

2243
00:42:45,440 --> 00:42:46,950
see in this class for dynamic
programming

2244
00:42:46,950 --> 00:42:46,960
programming
 

2245
00:42:46,960 --> 00:42:51,109
programming
here's a trick if

2246
00:42:51,109 --> 00:42:51,119
here's a trick if
 

2247
00:42:51,119 --> 00:42:54,950
here's a trick if
your

2248
00:42:54,950 --> 00:42:54,960

 

2249
00:42:54,960 --> 00:43:01,030

input is a sequence

2250
00:43:01,030 --> 00:43:01,040

 

2251
00:43:01,040 --> 00:43:10,829

here's some good sub problems to

2252
00:43:10,829 --> 00:43:10,839

 

2253
00:43:10,839 --> 00:43:12,630

consider

2254
00:43:12,630 --> 00:43:12,640
consider
 

2255
00:43:12,640 --> 00:43:17,990
consider
uh we could do all prefixes

2256
00:43:17,990 --> 00:43:18,000

 

2257
00:43:18,000 --> 00:43:22,069

so let's call the sequence x

2258
00:43:22,069 --> 00:43:22,079
so let's call the sequence x
 

2259
00:43:22,079 --> 00:43:24,870
so let's call the sequence x
so we could do x prefix means up to a

2260
00:43:24,870 --> 00:43:24,880
so we could do x prefix means up to a
 

2261
00:43:24,880 --> 00:43:27,510
so we could do x prefix means up to a
given i for all i

2262
00:43:27,510 --> 00:43:27,520
given i for all i
 

2263
00:43:27,520 --> 00:43:31,430
given i for all i
we could do all the suffixes

2264
00:43:31,430 --> 00:43:31,440

 

2265
00:43:31,440 --> 00:43:34,710

x from i onward for all i

2266
00:43:34,710 --> 00:43:34,720
x from i onward for all i
 

2267
00:43:34,720 --> 00:43:39,349
x from i onward for all i
or we could do substrings

2268
00:43:39,349 --> 00:43:39,359

 

2269
00:43:39,359 --> 00:43:41,670

which are the consecutive items from i

2270
00:43:41,670 --> 00:43:41,680
which are the consecutive items from i
 

2271
00:43:41,680 --> 00:43:42,950
which are the consecutive items from i
to j

2272
00:43:42,950 --> 00:43:42,960
to j
 

2273
00:43:42,960 --> 00:43:44,309
to j
i don't write subsequence here

2274
00:43:44,309 --> 00:43:44,319
i don't write subsequence here
 

2275
00:43:44,319 --> 00:43:46,150
i don't write subsequence here
subsequence means you can emit items in

2276
00:43:46,150 --> 00:43:46,160
subsequence means you can emit items in
 

2277
00:43:46,160 --> 00:43:46,870
subsequence means you can emit items in
the middle

2278
00:43:46,870 --> 00:43:46,880
the middle
 

2279
00:43:46,880 --> 00:43:48,550
the middle
so substring you have to start at some

2280
00:43:48,550 --> 00:43:48,560
so substring you have to start at some
 

2281
00:43:48,560 --> 00:43:51,510
so substring you have to start at some
position and do all the things up to j

2282
00:43:51,510 --> 00:43:51,520
position and do all the things up to j
 

2283
00:43:51,520 --> 00:43:53,430
position and do all the things up to j
uh so these are nice easy to express in

2284
00:43:53,430 --> 00:43:53,440
uh so these are nice easy to express in
 

2285
00:43:53,440 --> 00:43:55,109
uh so these are nice easy to express in
python notation

2286
00:43:55,109 --> 00:43:55,119
python notation
 

2287
00:43:55,119 --> 00:43:56,630
python notation
and these are great because they're

2288
00:43:56,630 --> 00:43:56,640
and these are great because they're
 

2289
00:43:56,640 --> 00:43:58,550
and these are great because they're
polynomial right if i have n

2290
00:43:58,550 --> 00:43:58,560
polynomial right if i have n
 

2291
00:43:58,560 --> 00:44:01,190
polynomial right if i have n
things if the length of my sequence x is

2292
00:44:01,190 --> 00:44:01,200
things if the length of my sequence x is
 

2293
00:44:01,200 --> 00:44:02,069
things if the length of my sequence x is
n

2294
00:44:02,069 --> 00:44:02,079
n
 

2295
00:44:02,079 --> 00:44:04,630
n
then there are n sequences n prefixes

2296
00:44:04,630 --> 00:44:04,640
then there are n sequences n prefixes
 

2297
00:44:04,640 --> 00:44:06,550
then there are n sequences n prefixes
technically n plus one so

2298
00:44:06,550 --> 00:44:06,560
technically n plus one so
 

2299
00:44:06,560 --> 00:44:08,950
technically n plus one so
let's do theta n prefixes they're theta

2300
00:44:08,950 --> 00:44:08,960
let's do theta n prefixes they're theta
 

2301
00:44:08,960 --> 00:44:10,230
let's do theta n prefixes they're theta
and suffixes

2302
00:44:10,230 --> 00:44:10,240
and suffixes
 

2303
00:44:10,240 --> 00:44:13,510
and suffixes
and they're theta and squared

2304
00:44:13,510 --> 00:44:13,520
and they're theta and squared
 

2305
00:44:13,520 --> 00:44:15,510
and they're theta and squared
substrings because there's n roughly n

2306
00:44:15,510 --> 00:44:15,520
substrings because there's n roughly n
 

2307
00:44:15,520 --> 00:44:17,430
substrings because there's n roughly n
choices for i and j

2308
00:44:17,430 --> 00:44:17,440
choices for i and j
 

2309
00:44:17,440 --> 00:44:21,030
choices for i and j
separately sorry

2310
00:44:21,030 --> 00:44:21,040
separately sorry
 

2311
00:44:21,040 --> 00:44:23,109
separately sorry
subsequences good right i didn't write

2312
00:44:23,109 --> 00:44:23,119
subsequences good right i didn't write
 

2313
00:44:23,119 --> 00:44:24,790
subsequences good right i didn't write
subsequences because in fact there are

2314
00:44:24,790 --> 00:44:24,800
subsequences because in fact there are
 

2315
00:44:24,800 --> 00:44:26,550
subsequences because in fact there are
exponentially many subsequences right

2316
00:44:26,550 --> 00:44:26,560
exponentially many subsequences right
 

2317
00:44:26,560 --> 00:44:27,589
exponentially many subsequences right
it's 2 to the n

2318
00:44:27,589 --> 00:44:27,599
it's 2 to the n
 

2319
00:44:27,599 --> 00:44:29,829
it's 2 to the n
for every item i could choose it or not

2320
00:44:29,829 --> 00:44:29,839
for every item i could choose it or not
 

2321
00:44:29,839 --> 00:44:31,990
for every item i could choose it or not
so i don't want to parametrize i don't

2322
00:44:31,990 --> 00:44:32,000
so i don't want to parametrize i don't
 

2323
00:44:32,000 --> 00:44:34,069
so i don't want to parametrize i don't
want my sub problems to be sub sequences

2324
00:44:34,069 --> 00:44:34,079
want my sub problems to be sub sequences
 

2325
00:44:34,079 --> 00:44:34,950
want my sub problems to be sub sequences
because that's

2326
00:44:34,950 --> 00:44:34,960
because that's
 

2327
00:44:34,960 --> 00:44:37,270
because that's
guaranteed well then you're guaranteed

2328
00:44:37,270 --> 00:44:37,280
guaranteed well then you're guaranteed
 

2329
00:44:37,280 --> 00:44:38,390
guaranteed well then you're guaranteed
to get an exponential number of

2330
00:44:38,390 --> 00:44:38,400
to get an exponential number of
 

2331
00:44:38,400 --> 00:44:40,069
to get an exponential number of
sub-problems which is bad

2332
00:44:40,069 --> 00:44:40,079
sub-problems which is bad
 

2333
00:44:40,079 --> 00:44:41,430
sub-problems which is bad
we'd like to bound the number of

2334
00:44:41,430 --> 00:44:41,440
we'd like to bound the number of
 

2335
00:44:41,440 --> 00:44:43,430
we'd like to bound the number of
sub-problems by a polynomial

2336
00:44:43,430 --> 00:44:43,440
sub-problems by a polynomial
 

2337
00:44:43,440 --> 00:44:46,069
sub-problems by a polynomial
so these are three natural ways to get

2338
00:44:46,069 --> 00:44:46,079
so these are three natural ways to get
 

2339
00:44:46,079 --> 00:44:47,670
so these are three natural ways to get
uh polynomial bounds

2340
00:44:47,670 --> 00:44:47,680
uh polynomial bounds
 

2341
00:44:47,680 --> 00:44:49,589
uh polynomial bounds
now prefixes and suffixes are obviously

2342
00:44:49,589 --> 00:44:49,599
now prefixes and suffixes are obviously
 

2343
00:44:49,599 --> 00:44:51,430
now prefixes and suffixes are obviously
better because there's fewer of them

2344
00:44:51,430 --> 00:44:51,440
better because there's fewer of them
 

2345
00:44:51,440 --> 00:44:54,470
better because there's fewer of them
linear instead of quadratic and usually

2346
00:44:54,470 --> 00:44:54,480
linear instead of quadratic and usually
 

2347
00:44:54,480 --> 00:44:56,470
linear instead of quadratic and usually
almost every problem you'll encounter

2348
00:44:56,470 --> 00:44:56,480
almost every problem you'll encounter
 

2349
00:44:56,480 --> 00:44:58,470
almost every problem you'll encounter
prefixes and suffixes are equally good

2350
00:44:58,470 --> 00:44:58,480
prefixes and suffixes are equally good
 

2351
00:44:58,480 --> 00:44:59,829
prefixes and suffixes are equally good
it doesn't really matter which one you

2352
00:44:59,829 --> 00:44:59,839
it doesn't really matter which one you
 

2353
00:44:59,839 --> 00:45:00,630
it doesn't really matter which one you
choose

2354
00:45:00,630 --> 00:45:00,640
choose
 

2355
00:45:00,640 --> 00:45:03,510
choose
so maybe you like to think of well we'll

2356
00:45:03,510 --> 00:45:03,520
so maybe you like to think of well we'll
 

2357
00:45:03,520 --> 00:45:05,990
so maybe you like to think of well we'll
get to

2358
00:45:05,990 --> 00:45:06,000

 

2359
00:45:06,000 --> 00:45:08,230

it's you just choose whichever is more

2360
00:45:08,230 --> 00:45:08,240
it's you just choose whichever is more
 

2361
00:45:08,240 --> 00:45:11,030
it's you just choose whichever is more
comfortable for you

2362
00:45:11,030 --> 00:45:11,040

 

2363
00:45:11,040 --> 00:45:12,470

but sometimes it's not enough and we'll

2364
00:45:12,470 --> 00:45:12,480
but sometimes it's not enough and we'll
 

2365
00:45:12,480 --> 00:45:13,910
but sometimes it's not enough and we'll
have to go to substrings that won't be

2366
00:45:13,910 --> 00:45:13,920
have to go to substrings that won't be
 

2367
00:45:13,920 --> 00:45:15,910
have to go to substrings that won't be
for another lecture or two

2368
00:45:15,910 --> 00:45:15,920
for another lecture or two
 

2369
00:45:15,920 --> 00:45:18,710
for another lecture or two
okay today i claim that prefixes or

2370
00:45:18,710 --> 00:45:18,720
okay today i claim that prefixes or
 

2371
00:45:18,720 --> 00:45:19,829
okay today i claim that prefixes or
suffixes

2372
00:45:19,829 --> 00:45:19,839
suffixes
 

2373
00:45:19,839 --> 00:45:23,270
suffixes
are uh enough to solve the bowling

2374
00:45:23,270 --> 00:45:23,280
are uh enough to solve the bowling
 

2375
00:45:23,280 --> 00:45:24,630
are uh enough to solve the bowling
problem

2376
00:45:24,630 --> 00:45:24,640
problem
 

2377
00:45:24,640 --> 00:45:26,790
problem
so what we're going to do is think about

2378
00:45:26,790 --> 00:45:26,800
so what we're going to do is think about
 

2379
00:45:26,800 --> 00:45:28,710
so what we're going to do is think about
i prefer suffixes usually

2380
00:45:28,710 --> 00:45:28,720
i prefer suffixes usually
 

2381
00:45:28,720 --> 00:45:30,309
i prefer suffixes usually
because i like to work from left to

2382
00:45:30,309 --> 00:45:30,319
because i like to work from left to
 

2383
00:45:30,319 --> 00:45:32,550
because i like to work from left to
right from the beginning to the end

2384
00:45:32,550 --> 00:45:32,560
right from the beginning to the end
 

2385
00:45:32,560 --> 00:45:34,630
right from the beginning to the end
so we're going to think of a suffix of

2386
00:45:34,630 --> 00:45:34,640
so we're going to think of a suffix of
 

2387
00:45:34,640 --> 00:45:37,190
so we're going to think of a suffix of
the bowling pins

2388
00:45:37,190 --> 00:45:37,200
the bowling pins
 

2389
00:45:37,200 --> 00:45:39,190
the bowling pins
and so what is the sub problem on a

2390
00:45:39,190 --> 00:45:39,200
and so what is the sub problem on a
 

2391
00:45:39,200 --> 00:45:40,309
and so what is the sub problem on a
suffix well

2392
00:45:40,309 --> 00:45:40,319
suffix well
 

2393
00:45:40,319 --> 00:45:41,910
suffix well
a natural version is just to solve the

2394
00:45:41,910 --> 00:45:41,920
a natural version is just to solve the
 

2395
00:45:41,920 --> 00:45:43,430
a natural version is just to solve the
original problem

2396
00:45:43,430 --> 00:45:43,440
original problem
 

2397
00:45:43,440 --> 00:45:45,670
original problem
bowling how do i maximize my score if

2398
00:45:45,670 --> 00:45:45,680
bowling how do i maximize my score if
 

2399
00:45:45,680 --> 00:45:47,589
bowling how do i maximize my score if
all i were given were these pins

2400
00:45:47,589 --> 00:45:47,599
all i were given were these pins
 

2401
00:45:47,599 --> 00:45:49,829
all i were given were these pins
suppose the pins to the left of i didn't

2402
00:45:49,829 --> 00:45:49,839
suppose the pins to the left of i didn't
 

2403
00:45:49,839 --> 00:45:50,790
suppose the pins to the left of i didn't
exist

2404
00:45:50,790 --> 00:45:50,800
exist
 

2405
00:45:50,800 --> 00:45:52,230
exist
how would i maximize my score on the

2406
00:45:52,230 --> 00:45:52,240
how would i maximize my score on the
 

2407
00:45:52,240 --> 00:45:54,550
how would i maximize my score on the
remaining pins or for this suffix

2408
00:45:54,550 --> 00:45:54,560
remaining pins or for this suffix
 

2409
00:45:54,560 --> 00:45:56,550
remaining pins or for this suffix
given these four pins what would i do

2410
00:45:56,550 --> 00:45:56,560
given these four pins what would i do
 

2411
00:45:56,560 --> 00:45:57,829
given these four pins what would i do
and there's some weird sub problems here

2412
00:45:57,829 --> 00:45:57,839
and there's some weird sub problems here
 

2413
00:45:57,839 --> 00:45:59,430
and there's some weird sub problems here
right if i just gave you the last pin

2414
00:45:59,430 --> 00:45:59,440
right if i just gave you the last pin
 

2415
00:45:59,440 --> 00:46:00,390
right if i just gave you the last pin
what would you do

2416
00:46:00,390 --> 00:46:00,400
what would you do
 

2417
00:46:00,400 --> 00:46:01,990
what would you do
nothing that's clearly different from

2418
00:46:01,990 --> 00:46:02,000
nothing that's clearly different from
 

2419
00:46:02,000 --> 00:46:04,230
nothing that's clearly different from
what i would do globally here

2420
00:46:04,230 --> 00:46:04,240
what i would do globally here
 

2421
00:46:04,240 --> 00:46:06,309
what i would do globally here
but i claim if i can solve all suffixes

2422
00:46:06,309 --> 00:46:06,319
but i claim if i can solve all suffixes
 

2423
00:46:06,319 --> 00:46:08,550
but i claim if i can solve all suffixes
i can solve my original problem because

2424
00:46:08,550 --> 00:46:08,560
i can solve my original problem because
 

2425
00:46:08,560 --> 00:46:12,829
i can solve my original problem because
one of the suffixes is the whole

2426
00:46:12,829 --> 00:46:12,839

 

2427
00:46:12,839 --> 00:46:13,990

sequence

2428
00:46:13,990 --> 00:46:14,000
sequence
 

2429
00:46:14,000 --> 00:46:18,790
sequence
so let's do it

2430
00:46:18,790 --> 00:46:18,800

 

2431
00:46:18,800 --> 00:46:21,990

sort bot

2432
00:46:21,990 --> 00:46:22,000

 

2433
00:46:22,000 --> 00:46:26,470

for bowling

2434
00:46:26,470 --> 00:46:26,480

 

2435
00:46:26,480 --> 00:46:29,670

so here's our dynamic program uh the sub

2436
00:46:29,670 --> 00:46:29,680
so here's our dynamic program uh the sub
 

2437
00:46:29,680 --> 00:46:32,870
so here's our dynamic program uh the sub
problems

2438
00:46:32,870 --> 00:46:32,880

 

2439
00:46:32,880 --> 00:46:35,910

are suffixes so um

2440
00:46:35,910 --> 00:46:35,920
are suffixes so um
 

2441
00:46:35,920 --> 00:46:39,349
are suffixes so um
all right b of i is the maximum score we

2442
00:46:39,349 --> 00:46:39,359
all right b of i is the maximum score we
 

2443
00:46:39,359 --> 00:46:42,870
all right b of i is the maximum score we
could get

2444
00:46:42,870 --> 00:46:42,880
could get
 

2445
00:46:42,880 --> 00:46:46,710
could get
possible

2446
00:46:46,710 --> 00:46:46,720

 

2447
00:46:46,720 --> 00:46:50,390

with our starting

2448
00:46:50,390 --> 00:46:50,400
with our starting
 

2449
00:46:50,400 --> 00:46:53,990
with our starting
if we started a game with pins

2450
00:46:53,990 --> 00:46:54,000
if we started a game with pins
 

2451
00:46:54,000 --> 00:46:57,510
if we started a game with pins
um i i plus one up to

2452
00:46:57,510 --> 00:46:57,520
um i i plus one up to
 

2453
00:46:57,520 --> 00:47:01,270
um i i plus one up to
n minus one okay which is a suffix of

2454
00:47:01,270 --> 00:47:01,280
n minus one okay which is a suffix of
 

2455
00:47:01,280 --> 00:47:02,390
n minus one okay which is a suffix of
the pins

2456
00:47:02,390 --> 00:47:02,400
the pins
 

2457
00:47:02,400 --> 00:47:03,670
the pins
very important whenever you write a

2458
00:47:03,670 --> 00:47:03,680
very important whenever you write a
 

2459
00:47:03,680 --> 00:47:05,510
very important whenever you write a
dynamic program to define what your

2460
00:47:05,510 --> 00:47:05,520
dynamic program to define what your
 

2461
00:47:05,520 --> 00:47:07,109
dynamic program to define what your
sub-problems are don't just say how to

2462
00:47:07,109 --> 00:47:07,119
sub-problems are don't just say how to
 

2463
00:47:07,119 --> 00:47:07,910
sub-problems are don't just say how to
compute them

2464
00:47:07,910 --> 00:47:07,920
compute them
 

2465
00:47:07,920 --> 00:47:09,990
compute them
but first say what is the goal of the

2466
00:47:09,990 --> 00:47:10,000
but first say what is the goal of the
 

2467
00:47:10,000 --> 00:47:11,829
but first say what is the goal of the
subproblem this is a common mistake to

2468
00:47:11,829 --> 00:47:11,839
subproblem this is a common mistake to
 

2469
00:47:11,839 --> 00:47:12,550
subproblem this is a common mistake to
forget

2470
00:47:12,550 --> 00:47:12,560
forget
 

2471
00:47:12,560 --> 00:47:15,510
forget
to state what you're trying to do so now

2472
00:47:15,510 --> 00:47:15,520
to state what you're trying to do so now
 

2473
00:47:15,520 --> 00:47:16,230
to state what you're trying to do so now
i have to find

2474
00:47:16,230 --> 00:47:16,240
i have to find
 

2475
00:47:16,240 --> 00:47:19,670
i have to find
b of i um now what is the

2476
00:47:19,670 --> 00:47:19,680
b of i um now what is the
 

2477
00:47:19,680 --> 00:47:21,430
b of i um now what is the
original thing i'm trying to solve i

2478
00:47:21,430 --> 00:47:21,440
original thing i'm trying to solve i
 

2479
00:47:21,440 --> 00:47:24,150
original thing i'm trying to solve i
like to you can you can also put in sort

2480
00:47:24,150 --> 00:47:24,160
like to you can you can also put in sort
 

2481
00:47:24,160 --> 00:47:25,109
like to you can you can also put in sort
by you could put the o

2482
00:47:25,109 --> 00:47:25,119
by you could put the o
 

2483
00:47:25,119 --> 00:47:26,790
by you could put the o
earlier also then it's actually spell

2484
00:47:26,790 --> 00:47:26,800
earlier also then it's actually spell
 

2485
00:47:26,800 --> 00:47:29,829
earlier also then it's actually spell
sort so why don't i do that for fun

2486
00:47:29,829 --> 00:47:29,839
sort so why don't i do that for fun
 

2487
00:47:29,839 --> 00:47:31,270
sort so why don't i do that for fun
the original problem we're trying to

2488
00:47:31,270 --> 00:47:31,280
the original problem we're trying to
 

2489
00:47:31,280 --> 00:47:33,270
the original problem we're trying to
solve is b

2490
00:47:33,270 --> 00:47:33,280
solve is b
 

2491
00:47:33,280 --> 00:47:36,470
solve is b
of zero right because that is all of the

2492
00:47:36,470 --> 00:47:36,480
of zero right because that is all of the
 

2493
00:47:36,480 --> 00:47:38,390
of zero right because that is all of the
pins the suffix starting at zero is

2494
00:47:38,390 --> 00:47:38,400
pins the suffix starting at zero is
 

2495
00:47:38,400 --> 00:47:39,589
pins the suffix starting at zero is
everything

2496
00:47:39,589 --> 00:47:39,599
everything
 

2497
00:47:39,599 --> 00:47:42,790
everything
so if we can solve that we're done next

2498
00:47:42,790 --> 00:47:42,800
so if we can solve that we're done next
 

2499
00:47:42,800 --> 00:47:43,109
so if we can solve that we're done next
is

2500
00:47:43,109 --> 00:47:43,119
is
 

2501
00:47:43,119 --> 00:47:46,390
is
r for relate this

2502
00:47:46,390 --> 00:47:46,400
r for relate this
 

2503
00:47:46,400 --> 00:47:48,630
r for relate this
is the test of did i get the sub

2504
00:47:48,630 --> 00:47:48,640
is the test of did i get the sub
 

2505
00:47:48,640 --> 00:47:50,790
is the test of did i get the sub
problems right is whether i can write

2506
00:47:50,790 --> 00:47:50,800
problems right is whether i can write
 

2507
00:47:50,800 --> 00:47:53,670
problems right is whether i can write
a recurrence relation so let's try to do

2508
00:47:53,670 --> 00:47:53,680
a recurrence relation so let's try to do
 

2509
00:47:53,680 --> 00:47:54,309
a recurrence relation so let's try to do
it

2510
00:47:54,309 --> 00:47:54,319
it
 

2511
00:47:54,319 --> 00:47:58,309
it
we want to compute b of i

2512
00:47:58,309 --> 00:47:58,319

 

2513
00:47:58,319 --> 00:48:01,750

so we have pin i here

2514
00:48:01,750 --> 00:48:01,760
so we have pin i here
 

2515
00:48:01,760 --> 00:48:07,589
so we have pin i here
and then the remaining pins

2516
00:48:07,589 --> 00:48:07,599
and then the remaining pins
 

2517
00:48:07,599 --> 00:48:09,589
and then the remaining pins
and the big idea here is to just think

2518
00:48:09,589 --> 00:48:09,599
and the big idea here is to just think
 

2519
00:48:09,599 --> 00:48:10,630
and the big idea here is to just think
about

2520
00:48:10,630 --> 00:48:10,640
about
 

2521
00:48:10,640 --> 00:48:12,950
about
the nice thing about suffixes is if i

2522
00:48:12,950 --> 00:48:12,960
the nice thing about suffixes is if i
 

2523
00:48:12,960 --> 00:48:14,790
the nice thing about suffixes is if i
take off something from the beginning

2524
00:48:14,790 --> 00:48:14,800
take off something from the beginning
 

2525
00:48:14,800 --> 00:48:16,710
take off something from the beginning
i still have a suffix remember my goal

2526
00:48:16,710 --> 00:48:16,720
i still have a suffix remember my goal
 

2527
00:48:16,720 --> 00:48:18,230
i still have a suffix remember my goal
is to take this sub problem which is

2528
00:48:18,230 --> 00:48:18,240
is to take this sub problem which is
 

2529
00:48:18,240 --> 00:48:20,069
is to take this sub problem which is
the suffix starting at i and reduce it

2530
00:48:20,069 --> 00:48:20,079
the suffix starting at i and reduce it
 

2531
00:48:20,079 --> 00:48:21,910
the suffix starting at i and reduce it
to a smaller sub problem which means a

2532
00:48:21,910 --> 00:48:21,920
to a smaller sub problem which means a
 

2533
00:48:21,920 --> 00:48:23,589
to a smaller sub problem which means a
smaller suffix

2534
00:48:23,589 --> 00:48:23,599
smaller suffix
 

2535
00:48:23,599 --> 00:48:26,309
smaller suffix
so i'd like to clip off a couple one or

2536
00:48:26,309 --> 00:48:26,319
so i'd like to clip off a couple one or
 

2537
00:48:26,319 --> 00:48:27,109
so i'd like to clip off a couple one or
two

2538
00:48:27,109 --> 00:48:27,119
two
 

2539
00:48:27,119 --> 00:48:29,589
two
items here and then the remaining

2540
00:48:29,589 --> 00:48:29,599
items here and then the remaining
 

2541
00:48:29,599 --> 00:48:30,710
items here and then the remaining
problem

2542
00:48:30,710 --> 00:48:30,720
problem
 

2543
00:48:30,720 --> 00:48:33,990
problem
will be one of my sub problems i'll be

2544
00:48:33,990 --> 00:48:34,000
will be one of my sub problems i'll be
 

2545
00:48:34,000 --> 00:48:36,150
will be one of my sub problems i'll be
able to recursively call b of something

2546
00:48:36,150 --> 00:48:36,160
able to recursively call b of something
 

2547
00:48:36,160 --> 00:48:37,270
able to recursively call b of something
smaller than i

2548
00:48:37,270 --> 00:48:37,280
smaller than i
 

2549
00:48:37,280 --> 00:48:39,510
smaller than i
or sorry b of something larger than i

2550
00:48:39,510 --> 00:48:39,520
or sorry b of something larger than i
 

2551
00:48:39,520 --> 00:48:41,510
or sorry b of something larger than i
will be a smaller subsequence because

2552
00:48:41,510 --> 00:48:41,520
will be a smaller subsequence because
 

2553
00:48:41,520 --> 00:48:43,589
will be a smaller subsequence because
we're starting later

2554
00:48:43,589 --> 00:48:43,599
we're starting later
 

2555
00:48:43,599 --> 00:48:46,150
we're starting later
okay so what could i do well the idea is

2556
00:48:46,150 --> 00:48:46,160
okay so what could i do well the idea is
 

2557
00:48:46,160 --> 00:48:47,829
okay so what could i do well the idea is
to just look at pin eye and think

2558
00:48:47,829 --> 00:48:47,839
to just look at pin eye and think
 

2559
00:48:47,839 --> 00:48:50,790
to just look at pin eye and think
what what could i do to pin i i could

2560
00:48:50,790 --> 00:48:50,800
what what could i do to pin i i could
 

2561
00:48:50,800 --> 00:48:52,790
what what could i do to pin i i could
not hit it ever with a ball i could skip

2562
00:48:52,790 --> 00:48:52,800
not hit it ever with a ball i could skip
 

2563
00:48:52,800 --> 00:48:55,430
not hit it ever with a ball i could skip
it that's one option what would be my

2564
00:48:55,430 --> 00:48:55,440
it that's one option what would be my
 

2565
00:48:55,440 --> 00:48:57,589
it that's one option what would be my
score then

2566
00:48:57,589 --> 00:48:57,599
score then
 

2567
00:48:57,599 --> 00:49:01,270
score then
well i if i skip pin i

2568
00:49:01,270 --> 00:49:01,280
well i if i skip pin i
 

2569
00:49:01,280 --> 00:49:02,950
well i if i skip pin i
that leaves the remaining pins which is

2570
00:49:02,950 --> 00:49:02,960
that leaves the remaining pins which is
 

2571
00:49:02,960 --> 00:49:04,390
that leaves the remaining pins which is
just a smaller suffix

2572
00:49:04,390 --> 00:49:04,400
just a smaller suffix
 

2573
00:49:04,400 --> 00:49:08,630
just a smaller suffix
so that is uh b of i plus one

2574
00:49:08,630 --> 00:49:08,640
so that is uh b of i plus one
 

2575
00:49:08,640 --> 00:49:10,150
so that is uh b of i plus one
i'm going to write a max out here

2576
00:49:10,150 --> 00:49:10,160
i'm going to write a max out here
 

2577
00:49:10,160 --> 00:49:11,829
i'm going to write a max out here
because i'd like to maximize my score

2578
00:49:11,829 --> 00:49:11,839
because i'd like to maximize my score
 

2579
00:49:11,839 --> 00:49:13,030
because i'd like to maximize my score
and one of the options is

2580
00:49:13,030 --> 00:49:13,040
and one of the options is
 

2581
00:49:13,040 --> 00:49:15,990
and one of the options is
forget about pin i just solve the rest

2582
00:49:15,990 --> 00:49:16,000
forget about pin i just solve the rest
 

2583
00:49:16,000 --> 00:49:17,190
forget about pin i just solve the rest
another option is i

2584
00:49:17,190 --> 00:49:17,200
another option is i
 

2585
00:49:17,200 --> 00:49:21,349
another option is i
throw a ball and i exactly hit pin i

2586
00:49:21,349 --> 00:49:21,359
throw a ball and i exactly hit pin i
 

2587
00:49:21,359 --> 00:49:23,510
throw a ball and i exactly hit pin i
that's a thing i could do and it would

2588
00:49:23,510 --> 00:49:23,520
that's a thing i could do and it would
 

2589
00:49:23,520 --> 00:49:25,030
that's a thing i could do and it would
it would leave exactly the same

2590
00:49:25,030 --> 00:49:25,040
it would leave exactly the same
 

2591
00:49:25,040 --> 00:49:26,150
it would leave exactly the same
remainder

2592
00:49:26,150 --> 00:49:26,160
remainder
 

2593
00:49:26,160 --> 00:49:31,349
remainder
so another option is b of i plus 1

2594
00:49:31,349 --> 00:49:31,359
so another option is b of i plus 1
 

2595
00:49:31,359 --> 00:49:35,750
so another option is b of i plus 1
plus v i uh why would i prefer this over

2596
00:49:35,750 --> 00:49:35,760
plus v i uh why would i prefer this over
 

2597
00:49:35,760 --> 00:49:37,589
plus v i uh why would i prefer this over
this well if v i is negative

2598
00:49:37,589 --> 00:49:37,599
this well if v i is negative
 

2599
00:49:37,599 --> 00:49:40,790
this well if v i is negative
i'd prefer this but if u is positive

2600
00:49:40,790 --> 00:49:40,800
i'd prefer this but if u is positive
 

2601
00:49:40,800 --> 00:49:42,710
i'd prefer this but if u is positive
i'd actually prefer this over that okay

2602
00:49:42,710 --> 00:49:42,720
i'd actually prefer this over that okay
 

2603
00:49:42,720 --> 00:49:44,309
i'd actually prefer this over that okay
so you're going to figure out which is

2604
00:49:44,309 --> 00:49:44,319
so you're going to figure out which is
 

2605
00:49:44,319 --> 00:49:47,750
so you're going to figure out which is
which is better just locally

2606
00:49:47,750 --> 00:49:47,760

 

2607
00:49:47,760 --> 00:49:49,109

but then there's another thing i can do

2608
00:49:49,109 --> 00:49:49,119
but then there's another thing i can do
 

2609
00:49:49,119 --> 00:49:52,309
but then there's another thing i can do
which is maybe i hit this pin

2610
00:49:52,309 --> 00:49:52,319
which is maybe i hit this pin
 

2611
00:49:52,319 --> 00:49:54,390
which is maybe i hit this pin
in a pair with some other pin now

2612
00:49:54,390 --> 00:49:54,400
in a pair with some other pin now
 

2613
00:49:54,400 --> 00:49:55,990
in a pair with some other pin now
there's no pin to the left of this one

2614
00:49:55,990 --> 00:49:56,000
there's no pin to the left of this one
 

2615
00:49:56,000 --> 00:49:58,230
there's no pin to the left of this one
we're assuming we only have the suffix

2616
00:49:58,230 --> 00:49:58,240
we're assuming we only have the suffix
 

2617
00:49:58,240 --> 00:50:00,710
we're assuming we only have the suffix
and so the only other thing i can do is

2618
00:50:00,710 --> 00:50:00,720
and so the only other thing i can do is
 

2619
00:50:00,720 --> 00:50:02,069
and so the only other thing i can do is
throw a ball and hit

2620
00:50:02,069 --> 00:50:02,079
throw a ball and hit
 

2621
00:50:02,079 --> 00:50:03,990
throw a ball and hit
i together with i plus one and then i

2622
00:50:03,990 --> 00:50:04,000
i together with i plus one and then i
 

2623
00:50:04,000 --> 00:50:05,430
i together with i plus one and then i
get the product

2624
00:50:05,430 --> 00:50:05,440
get the product
 

2625
00:50:05,440 --> 00:50:08,630
get the product
now what pins remain i plus two on still

2626
00:50:08,630 --> 00:50:08,640
now what pins remain i plus two on still
 

2627
00:50:08,640 --> 00:50:09,829
now what pins remain i plus two on still
a suffix

2628
00:50:09,829 --> 00:50:09,839
a suffix
 

2629
00:50:09,839 --> 00:50:11,670
a suffix
so if i remove one or two items of

2630
00:50:11,670 --> 00:50:11,680
so if i remove one or two items of
 

2631
00:50:11,680 --> 00:50:13,109
so if i remove one or two items of
course i still get a suffix

2632
00:50:13,109 --> 00:50:13,119
course i still get a suffix
 

2633
00:50:13,119 --> 00:50:16,309
course i still get a suffix
in this case b of i plus two and then

2634
00:50:16,309 --> 00:50:16,319
in this case b of i plus two and then
 

2635
00:50:16,319 --> 00:50:17,190
in this case b of i plus two and then
the number of

2636
00:50:17,190 --> 00:50:17,200
the number of
 

2637
00:50:17,200 --> 00:50:20,309
the number of
points that i add on are vi times vi

2638
00:50:20,309 --> 00:50:20,319
points that i add on are vi times vi
 

2639
00:50:20,319 --> 00:50:21,829
points that i add on are vi times vi
plus one

2640
00:50:21,829 --> 00:50:21,839
plus one
 

2641
00:50:21,839 --> 00:50:25,829
plus one
so this is a max of three things

2642
00:50:25,829 --> 00:50:25,839
so this is a max of three things
 

2643
00:50:25,839 --> 00:50:27,430
so this is a max of three things
so how long does it take me to compute

2644
00:50:27,430 --> 00:50:27,440
so how long does it take me to compute
 

2645
00:50:27,440 --> 00:50:28,950
so how long does it take me to compute
it i claim

2646
00:50:28,950 --> 00:50:28,960
it i claim
 

2647
00:50:28,960 --> 00:50:31,430
it i claim
constant time if i don't count the time

2648
00:50:31,430 --> 00:50:31,440
constant time if i don't count the time
 

2649
00:50:31,440 --> 00:50:32,630
constant time if i don't count the time
it takes to compute these other

2650
00:50:32,630 --> 00:50:32,640
it takes to compute these other
 

2651
00:50:32,640 --> 00:50:34,309
it takes to compute these other
subproblems which are smaller

2652
00:50:34,309 --> 00:50:34,319
subproblems which are smaller
 

2653
00:50:34,319 --> 00:50:36,710
subproblems which are smaller
because they are smaller suffixes

2654
00:50:36,710 --> 00:50:36,720
because they are smaller suffixes
 

2655
00:50:36,720 --> 00:50:38,069
because they are smaller suffixes
further to the right

2656
00:50:38,069 --> 00:50:38,079
further to the right
 

2657
00:50:38,079 --> 00:50:39,990
further to the right
uh then i'm doing you know a couple of

2658
00:50:39,990 --> 00:50:40,000
uh then i'm doing you know a couple of
 

2659
00:50:40,000 --> 00:50:41,510
uh then i'm doing you know a couple of
additions product

2660
00:50:41,510 --> 00:50:41,520
additions product
 

2661
00:50:41,520 --> 00:50:44,069
additions product
max these are all nice numbers they will

2662
00:50:44,069 --> 00:50:44,079
max these are all nice numbers they will
 

2663
00:50:44,079 --> 00:50:45,750
max these are all nice numbers they will
assume that they live in a w

2664
00:50:45,750 --> 00:50:45,760
assume that they live in a w
 

2665
00:50:45,760 --> 00:50:49,030
assume that they live in a w
bit word um because they're only doing

2666
00:50:49,030 --> 00:50:49,040
bit word um because they're only doing
 

2667
00:50:49,040 --> 00:50:50,790
bit word um because they're only doing
constant size products that's good

2668
00:50:50,790 --> 00:50:50,800
constant size products that's good
 

2669
00:50:50,800 --> 00:50:54,390
constant size products that's good
uh so this takes constant constant

2670
00:50:54,390 --> 00:50:54,400
uh so this takes constant constant
 

2671
00:50:54,400 --> 00:50:56,470
uh so this takes constant constant
non-recursive work

2672
00:50:56,470 --> 00:50:56,480
non-recursive work
 

2673
00:50:56,480 --> 00:50:58,790
non-recursive work
how many sub-problems are but suffixes

2674
00:50:58,790 --> 00:50:58,800
how many sub-problems are but suffixes
 

2675
00:50:58,800 --> 00:51:01,109
how many sub-problems are but suffixes
so it's a linear number of sub-problems

2676
00:51:01,109 --> 00:51:01,119
so it's a linear number of sub-problems
 

2677
00:51:01,119 --> 00:51:03,190
so it's a linear number of sub-problems
and so the time i'm going to end up

2678
00:51:03,190 --> 00:51:03,200
and so the time i'm going to end up
 

2679
00:51:03,200 --> 00:51:05,109
and so the time i'm going to end up
needing

2680
00:51:05,109 --> 00:51:05,119
needing
 

2681
00:51:05,119 --> 00:51:09,030
needing
is the number of sub-problems n times

2682
00:51:09,030 --> 00:51:09,040
is the number of sub-problems n times
 

2683
00:51:09,040 --> 00:51:10,870
is the number of sub-problems n times
the non-recursive work i do per sub

2684
00:51:10,870 --> 00:51:10,880
the non-recursive work i do per sub
 

2685
00:51:10,880 --> 00:51:12,230
the non-recursive work i do per sub
problem which is constant

2686
00:51:12,230 --> 00:51:12,240
problem which is constant
 

2687
00:51:12,240 --> 00:51:16,069
problem which is constant
and so this is linear time

2688
00:51:16,069 --> 00:51:16,079
and so this is linear time
 

2689
00:51:16,079 --> 00:51:18,790
and so this is linear time
great now i didn't finish sort bot so

2690
00:51:18,790 --> 00:51:18,800
great now i didn't finish sort bot so
 

2691
00:51:18,800 --> 00:51:19,349
great now i didn't finish sort bot so
there's

2692
00:51:19,349 --> 00:51:19,359
there's
 

2693
00:51:19,359 --> 00:51:21,270
there's
another t which is to make sure that

2694
00:51:21,270 --> 00:51:21,280
another t which is to make sure that
 

2695
00:51:21,280 --> 00:51:24,150
another t which is to make sure that
there is a topological order

2696
00:51:24,150 --> 00:51:24,160
there is a topological order
 

2697
00:51:24,160 --> 00:51:30,630
there is a topological order
and that is in decreasing i order

2698
00:51:30,630 --> 00:51:30,640

 

2699
00:51:30,640 --> 00:51:33,829

or i might write that as a for loop

2700
00:51:33,829 --> 00:51:33,839
or i might write that as a for loop
 

2701
00:51:33,839 --> 00:51:37,349
or i might write that as a for loop
for i equals n n minus 1.

2702
00:51:37,349 --> 00:51:37,359
for i equals n n minus 1.
 

2703
00:51:37,359 --> 00:51:39,670
for i equals n n minus 1.
this is the order that i would compute

2704
00:51:39,670 --> 00:51:39,680
this is the order that i would compute
 

2705
00:51:39,680 --> 00:51:40,790
this is the order that i would compute
uh

2706
00:51:40,790 --> 00:51:40,800
uh
 

2707
00:51:40,800 --> 00:51:42,790
uh
my problems because the suffix starting

2708
00:51:42,790 --> 00:51:42,800
my problems because the suffix starting
 

2709
00:51:42,800 --> 00:51:44,630
my problems because the suffix starting
at n is the empty suffix

2710
00:51:44,630 --> 00:51:44,640
at n is the empty suffix
 

2711
00:51:44,640 --> 00:51:46,230
at n is the empty suffix
the suffix starting at zero that's the

2712
00:51:46,230 --> 00:51:46,240
the suffix starting at zero that's the
 

2713
00:51:46,240 --> 00:51:47,670
the suffix starting at zero that's the
one i actually want to compute that's

2714
00:51:47,670 --> 00:51:47,680
one i actually want to compute that's
 

2715
00:51:47,680 --> 00:51:50,309
one i actually want to compute that's
the final suffix i should be computing

2716
00:51:50,309 --> 00:51:50,319
the final suffix i should be computing
 

2717
00:51:50,319 --> 00:51:53,670
the final suffix i should be computing
and then we have a b for base case

2718
00:51:53,670 --> 00:51:53,680
and then we have a b for base case
 

2719
00:51:53,680 --> 00:51:57,589
and then we have a b for base case
which is that first case b of n

2720
00:51:57,589 --> 00:51:57,599
which is that first case b of n
 

2721
00:51:57,599 --> 00:52:00,870
which is that first case b of n
equals uh zero

2722
00:52:00,870 --> 00:52:00,880
equals uh zero
 

2723
00:52:00,880 --> 00:52:02,390
equals uh zero
because there's no pins so i don't get

2724
00:52:02,390 --> 00:52:02,400
because there's no pins so i don't get
 

2725
00:52:02,400 --> 00:52:04,309
because there's no pins so i don't get
any points

2726
00:52:04,309 --> 00:52:04,319
any points
 

2727
00:52:04,319 --> 00:52:07,829
any points
sad

2728
00:52:07,829 --> 00:52:07,839

 

2729
00:52:07,839 --> 00:52:10,309

okay so this is it we just take these

2730
00:52:10,309 --> 00:52:10,319
okay so this is it we just take these
 

2731
00:52:10,319 --> 00:52:11,510
okay so this is it we just take these
components

2732
00:52:11,510 --> 00:52:11,520
components
 

2733
00:52:11,520 --> 00:52:13,670
components
plug them into this recursive memoized

2734
00:52:13,670 --> 00:52:13,680
plug them into this recursive memoized
 

2735
00:52:13,680 --> 00:52:14,549
plug them into this recursive memoized
algorithm

2736
00:52:14,549 --> 00:52:14,559
algorithm
 

2737
00:52:14,559 --> 00:52:16,950
algorithm
and we have a linear time algorithm i

2738
00:52:16,950 --> 00:52:16,960
and we have a linear time algorithm i
 

2739
00:52:16,960 --> 00:52:17,990
and we have a linear time algorithm i
want to briefly mention

2740
00:52:17,990 --> 00:52:18,000
want to briefly mention
 

2741
00:52:18,000 --> 00:52:19,510
want to briefly mention
a different way you could plug together

2742
00:52:19,510 --> 00:52:19,520
a different way you could plug together
 

2743
00:52:19,520 --> 00:52:21,270
a different way you could plug together
those pieces which is called bottom up

2744
00:52:21,270 --> 00:52:21,280
those pieces which is called bottom up
 

2745
00:52:21,280 --> 00:52:25,109
those pieces which is called bottom up
dp

2746
00:52:25,109 --> 00:52:25,119

 

2747
00:52:25,119 --> 00:52:29,270

which is uh let's do it for this example

2748
00:52:29,270 --> 00:52:29,280
which is uh let's do it for this example
 

2749
00:52:29,280 --> 00:52:32,630
which is uh let's do it for this example
so if i have um

2750
00:52:32,630 --> 00:52:32,640
so if i have um
 

2751
00:52:32,640 --> 00:52:35,589
so if i have um
let's see let me start with the base

2752
00:52:35,589 --> 00:52:35,599
let's see let me start with the base
 

2753
00:52:35,599 --> 00:52:37,750
let's see let me start with the base
case

2754
00:52:37,750 --> 00:52:37,760
case
 

2755
00:52:37,760 --> 00:52:40,309
case
b of n equals zero but now it's an

2756
00:52:40,309 --> 00:52:40,319
b of n equals zero but now it's an
 

2757
00:52:40,319 --> 00:52:41,430
b of n equals zero but now it's an
assignment

2758
00:52:41,430 --> 00:52:41,440
assignment
 

2759
00:52:41,440 --> 00:52:42,950
assignment
and i'm going to do the for loop from

2760
00:52:42,950 --> 00:52:42,960
and i'm going to do the for loop from
 

2761
00:52:42,960 --> 00:52:44,950
and i'm going to do the for loop from
the topological order for i equals

2762
00:52:44,950 --> 00:52:44,960
the topological order for i equals
 

2763
00:52:44,960 --> 00:52:49,030
the topological order for i equals
m n minus 1 to 0.

2764
00:52:49,030 --> 00:52:49,040
m n minus 1 to 0.
 

2765
00:52:49,040 --> 00:52:52,630
m n minus 1 to 0.
now i'm going to do the relation b of i

2766
00:52:52,630 --> 00:52:52,640
now i'm going to do the relation b of i
 

2767
00:52:52,640 --> 00:52:57,430
now i'm going to do the relation b of i
equals max of b of i plus 1

2768
00:52:57,430 --> 00:52:57,440
equals max of b of i plus 1
 

2769
00:52:57,440 --> 00:53:00,549
equals max of b of i plus 1
and b of i plus uh

2770
00:53:00,549 --> 00:53:00,559
and b of i plus uh
 

2771
00:53:00,559 --> 00:53:05,190
and b of i plus uh
1 plus v i and v of i plus 2

2772
00:53:05,190 --> 00:53:05,200
1 plus v i and v of i plus 2
 

2773
00:53:05,200 --> 00:53:08,390
1 plus v i and v of i plus 2
plus v i v i plus 1.

2774
00:53:08,390 --> 00:53:08,400
plus v i v i plus 1.
 

2775
00:53:08,400 --> 00:53:10,790
plus v i v i plus 1.
technically this only works if i is

2776
00:53:10,790 --> 00:53:10,800
technically this only works if i is
 

2777
00:53:10,800 --> 00:53:12,790
technically this only works if i is
strictly less than n minus 1.

2778
00:53:12,790 --> 00:53:12,800
strictly less than n minus 1.
 

2779
00:53:12,800 --> 00:53:15,829
strictly less than n minus 1.
so i should have an if i is less than n

2780
00:53:15,829 --> 00:53:15,839
so i should have an if i is less than n
 

2781
00:53:15,839 --> 00:53:17,589
so i should have an if i is less than n
minus 1 for that last part

2782
00:53:17,589 --> 00:53:17,599
minus 1 for that last part
 

2783
00:53:17,599 --> 00:53:19,270
minus 1 for that last part
because i can only do i can only hit two

2784
00:53:19,270 --> 00:53:19,280
because i can only do i can only hit two
 

2785
00:53:19,280 --> 00:53:22,470
because i can only do i can only hit two
pins if there's at least two pins left

2786
00:53:22,470 --> 00:53:22,480
pins if there's at least two pins left
 

2787
00:53:22,480 --> 00:53:25,829
pins if there's at least two pins left
and then return

2788
00:53:25,829 --> 00:53:25,839

 

2789
00:53:25,839 --> 00:53:28,549

b of zero so what i just did is a

2790
00:53:28,549 --> 00:53:28,559
b of zero so what i just did is a
 

2791
00:53:28,559 --> 00:53:29,430
b of zero so what i just did is a
transformation

2792
00:53:29,430 --> 00:53:29,440
transformation
 

2793
00:53:29,440 --> 00:53:33,589
transformation
from this sort bot template into

2794
00:53:33,589 --> 00:53:33,599
from this sort bot template into
 

2795
00:53:33,599 --> 00:53:36,230
from this sort bot template into
a non-recursive algorithm a for loop

2796
00:53:36,230 --> 00:53:36,240
a non-recursive algorithm a for loop
 

2797
00:53:36,240 --> 00:53:37,270
a non-recursive algorithm a for loop
algorithm

2798
00:53:37,270 --> 00:53:37,280
algorithm
 

2799
00:53:37,280 --> 00:53:40,230
algorithm
where i wrote my base case first then i

2800
00:53:40,230 --> 00:53:40,240
where i wrote my base case first then i
 

2801
00:53:40,240 --> 00:53:40,950
where i wrote my base case first then i
did my

2802
00:53:40,950 --> 00:53:40,960
did my
 

2803
00:53:40,960 --> 00:53:44,309
did my
topological order then i did my

2804
00:53:44,309 --> 00:53:44,319
topological order then i did my
 

2805
00:53:44,319 --> 00:53:48,950
topological order then i did my
relation then at the end i did my base

2806
00:53:48,950 --> 00:53:48,960
relation then at the end i did my base
 

2807
00:53:48,960 --> 00:53:53,589
relation then at the end i did my base
not base case the original problem

2808
00:53:53,589 --> 00:53:53,599

 

2809
00:53:53,599 --> 00:53:55,349

and provided you can write your

2810
00:53:55,349 --> 00:53:55,359
and provided you can write your
 

2811
00:53:55,359 --> 00:53:57,589
and provided you can write your
topological order as some for loops

2812
00:53:57,589 --> 00:53:57,599
topological order as some for loops
 

2813
00:53:57,599 --> 00:53:59,030
topological order as some for loops
this is actually a great way to write

2814
00:53:59,030 --> 00:53:59,040
this is actually a great way to write
 

2815
00:53:59,040 --> 00:54:01,190
this is actually a great way to write
down a dp as code if i were going to

2816
00:54:01,190 --> 00:54:01,200
down a dp as code if i were going to
 

2817
00:54:01,200 --> 00:54:02,549
down a dp as code if i were going to
implement this algorithm i would write

2818
00:54:02,549 --> 00:54:02,559
implement this algorithm i would write
 

2819
00:54:02,559 --> 00:54:04,230
implement this algorithm i would write
it this way because this is super fast

2820
00:54:04,230 --> 00:54:04,240
it this way because this is super fast
 

2821
00:54:04,240 --> 00:54:05,430
it this way because this is super fast
no recursive calls

2822
00:54:05,430 --> 00:54:05,440
no recursive calls
 

2823
00:54:05,440 --> 00:54:07,589
no recursive calls
just one for loop in fact this is almost

2824
00:54:07,589 --> 00:54:07,599
just one for loop in fact this is almost
 

2825
00:54:07,599 --> 00:54:09,109
just one for loop in fact this is almost
a trivial algorithm it's amazing that

2826
00:54:09,109 --> 00:54:09,119
a trivial algorithm it's amazing that
 

2827
00:54:09,119 --> 00:54:09,430
a trivial algorithm it's amazing that
this

2828
00:54:09,430 --> 00:54:09,440
this
 

2829
00:54:09,440 --> 00:54:12,549
this
solves the bowling problem

2830
00:54:12,549 --> 00:54:12,559
solves the bowling problem
 

2831
00:54:12,559 --> 00:54:14,710
solves the bowling problem
it's in some sense considering every

2832
00:54:14,710 --> 00:54:14,720
it's in some sense considering every
 

2833
00:54:14,720 --> 00:54:16,790
it's in some sense considering every
possible strategy i could

2834
00:54:16,790 --> 00:54:16,800
possible strategy i could
 

2835
00:54:16,800 --> 00:54:19,910
possible strategy i could
for bowling these pins what we're using

2836
00:54:19,910 --> 00:54:19,920
for bowling these pins what we're using
 

2837
00:54:19,920 --> 00:54:21,030
for bowling these pins what we're using
is what we like to call

2838
00:54:21,030 --> 00:54:21,040
is what we like to call
 

2839
00:54:21,040 --> 00:54:23,990
is what we like to call
local brute force where when we think

2840
00:54:23,990 --> 00:54:24,000
local brute force where when we think
 

2841
00:54:24,000 --> 00:54:24,630
local brute force where when we think
about pin

2842
00:54:24,630 --> 00:54:24,640
about pin
 

2843
00:54:24,640 --> 00:54:26,790
about pin
i we look at all of the possible things

2844
00:54:26,790 --> 00:54:26,800
i we look at all of the possible things
 

2845
00:54:26,800 --> 00:54:27,990
i we look at all of the possible things
i could do to pin i

2846
00:54:27,990 --> 00:54:28,000
i could do to pin i
 

2847
00:54:28,000 --> 00:54:29,670
i could do to pin i
here there's really only three options

2848
00:54:29,670 --> 00:54:29,680
here there's really only three options
 

2849
00:54:29,680 --> 00:54:31,109
here there's really only three options
of what i could do

2850
00:54:31,109 --> 00:54:31,119
of what i could do
 

2851
00:54:31,119 --> 00:54:33,430
of what i could do
now normally if i if i tried all the

2852
00:54:33,430 --> 00:54:33,440
now normally if i if i tried all the
 

2853
00:54:33,440 --> 00:54:34,549
now normally if i if i tried all the
options for pin i

2854
00:54:34,549 --> 00:54:34,559
options for pin i
 

2855
00:54:34,559 --> 00:54:36,390
options for pin i
and then all the options for i plus 1

2856
00:54:36,390 --> 00:54:36,400
and then all the options for i plus 1
 

2857
00:54:36,400 --> 00:54:38,230
and then all the options for i plus 1
and i plus 2 and so on that would be

2858
00:54:38,230 --> 00:54:38,240
and i plus 2 and so on that would be
 

2859
00:54:38,240 --> 00:54:40,549
and i plus 2 and so on that would be
exponential it'd be 3 times 3 times 3

2860
00:54:40,549 --> 00:54:40,559
exponential it'd be 3 times 3 times 3
 

2861
00:54:40,559 --> 00:54:43,430
exponential it'd be 3 times 3 times 3
that's bad but because i can reuse these

2862
00:54:43,430 --> 00:54:43,440
that's bad but because i can reuse these
 

2863
00:54:43,440 --> 00:54:44,789
that's bad but because i can reuse these
sub problems

2864
00:54:44,789 --> 00:54:44,799
sub problems
 

2865
00:54:44,799 --> 00:54:47,510
sub problems
it turns out to only be linear time it's

2866
00:54:47,510 --> 00:54:47,520
it turns out to only be linear time it's
 

2867
00:54:47,520 --> 00:54:48,230
it turns out to only be linear time it's
almost like

2868
00:54:48,230 --> 00:54:48,240
almost like
 

2869
00:54:48,240 --> 00:54:51,430
almost like
magic dp

2870
00:54:51,430 --> 00:54:51,440
magic dp
 

2871
00:54:51,440 --> 00:54:54,950
magic dp
dp dp is essentially an idea of

2872
00:54:54,950 --> 00:54:54,960
dp dp is essentially an idea of
 

2873
00:54:54,960 --> 00:55:02,150
dp dp is essentially an idea of
using local brute force

2874
00:55:02,150 --> 00:55:02,160

 

2875
00:55:02,160 --> 00:55:05,270

and by defining a small number of sub

2876
00:55:05,270 --> 00:55:05,280
and by defining a small number of sub
 

2877
00:55:05,280 --> 00:55:06,710
and by defining a small number of sub
problems up front and

2878
00:55:06,710 --> 00:55:06,720
problems up front and
 

2879
00:55:06,720 --> 00:55:08,710
problems up front and
as long as i stay within those sub

2880
00:55:08,710 --> 00:55:08,720
as long as i stay within those sub
 

2881
00:55:08,720 --> 00:55:10,470
as long as i stay within those sub
problems as long as i'm always recursing

2882
00:55:10,470 --> 00:55:10,480
problems as long as i'm always recursing
 

2883
00:55:10,480 --> 00:55:12,710
problems as long as i'm always recursing
into this polynomial space

2884
00:55:12,710 --> 00:55:12,720
into this polynomial space
 

2885
00:55:12,720 --> 00:55:15,510
into this polynomial space
i end up only doing polynomial work even

2886
00:55:15,510 --> 00:55:15,520
i end up only doing polynomial work even
 

2887
00:55:15,520 --> 00:55:16,950
i end up only doing polynomial work even
though i'm in some sense exploring

2888
00:55:16,950 --> 00:55:16,960
though i'm in some sense exploring
 

2889
00:55:16,960 --> 00:55:19,510
though i'm in some sense exploring
exponentially many options

2890
00:55:19,510 --> 00:55:19,520
exponentially many options
 

2891
00:55:19,520 --> 00:55:21,910
exponentially many options
and it's it's because what i do for this

2892
00:55:21,910 --> 00:55:21,920
and it's it's because what i do for this
 

2893
00:55:21,920 --> 00:55:23,109
and it's it's because what i do for this
pin doesn't depend

2894
00:55:23,109 --> 00:55:23,119
pin doesn't depend
 

2895
00:55:23,119 --> 00:55:25,349
pin doesn't depend
too much to what i do to a pin much

2896
00:55:25,349 --> 00:55:25,359
too much to what i do to a pin much
 

2897
00:55:25,359 --> 00:55:27,109
too much to what i do to a pin much
later and there's a lot of intuition

2898
00:55:27,109 --> 00:55:27,119
later and there's a lot of intuition
 

2899
00:55:27,119 --> 00:55:28,789
later and there's a lot of intuition
going on here for what

2900
00:55:28,789 --> 00:55:28,799
going on here for what
 

2901
00:55:28,799 --> 00:55:32,230
going on here for what
uh when dp works but we're going to see

2902
00:55:32,230 --> 00:55:32,240
uh when dp works but we're going to see
 

2903
00:55:32,240 --> 00:55:33,750
uh when dp works but we're going to see
a lot more examples of that

2904
00:55:33,750 --> 00:55:33,760
a lot more examples of that
 

2905
00:55:33,760 --> 00:55:37,270
a lot more examples of that
coming up and i just want to mention

2906
00:55:37,270 --> 00:55:37,280
coming up and i just want to mention
 

2907
00:55:37,280 --> 00:55:38,950
coming up and i just want to mention
that the intuition for how to write a

2908
00:55:38,950 --> 00:55:38,960
that the intuition for how to write a
 

2909
00:55:38,960 --> 00:55:39,910
that the intuition for how to write a
recurrence like this

2910
00:55:39,910 --> 00:55:39,920
recurrence like this
 

2911
00:55:39,920 --> 00:55:41,990
recurrence like this
is to think about in the case of

2912
00:55:41,990 --> 00:55:42,000
is to think about in the case of
 

2913
00:55:42,000 --> 00:55:43,510
is to think about in the case of
suffixes you always want to think about

2914
00:55:43,510 --> 00:55:43,520
suffixes you always want to think about
 

2915
00:55:43,520 --> 00:55:44,390
suffixes you always want to think about
the first item

2916
00:55:44,390 --> 00:55:44,400
the first item
 

2917
00:55:44,400 --> 00:55:46,390
the first item
or maybe the first couple items the case

2918
00:55:46,390 --> 00:55:46,400
or maybe the first couple items the case
 

2919
00:55:46,400 --> 00:55:48,150
or maybe the first couple items the case
of prefixes you always think about the

2920
00:55:48,150 --> 00:55:48,160
of prefixes you always think about the
 

2921
00:55:48,160 --> 00:55:49,030
of prefixes you always think about the
last item

2922
00:55:49,030 --> 00:55:49,040
last item
 

2923
00:55:49,040 --> 00:55:51,270
last item
and for sub strings it's could be any

2924
00:55:51,270 --> 00:55:51,280
and for sub strings it's could be any
 

2925
00:55:51,280 --> 00:55:52,950
and for sub strings it's could be any
item maybe in the middle

2926
00:55:52,950 --> 00:55:52,960
item maybe in the middle
 

2927
00:55:52,960 --> 00:55:54,309
item maybe in the middle
if i remove an item from the middle of

2928
00:55:54,309 --> 00:55:54,319
if i remove an item from the middle of
 

2929
00:55:54,319 --> 00:55:55,910
if i remove an item from the middle of
the substring i get two substrings so i

2930
00:55:55,910 --> 00:55:55,920
the substring i get two substrings so i
 

2931
00:55:55,920 --> 00:55:57,670
the substring i get two substrings so i
can recurse

2932
00:55:57,670 --> 00:55:57,680
can recurse
 

2933
00:55:57,680 --> 00:55:59,990
can recurse
here or in general what we want to do is

2934
00:55:59,990 --> 00:56:00,000
here or in general what we want to do is
 

2935
00:56:00,000 --> 00:56:00,710
here or in general what we want to do is
identify

2936
00:56:00,710 --> 00:56:00,720
identify
 

2937
00:56:00,720 --> 00:56:03,990
identify
some feature of the solution that if we

2938
00:56:03,990 --> 00:56:04,000
some feature of the solution that if we
 

2939
00:56:04,000 --> 00:56:05,829
some feature of the solution that if we
knew that feature

2940
00:56:05,829 --> 00:56:05,839
knew that feature
 

2941
00:56:05,839 --> 00:56:07,910
knew that feature
we would be done we would reduce to a

2942
00:56:07,910 --> 00:56:07,920
we would be done we would reduce to a
 

2943
00:56:07,920 --> 00:56:09,270
we would be done we would reduce to a
smaller sub problem

2944
00:56:09,270 --> 00:56:09,280
smaller sub problem
 

2945
00:56:09,280 --> 00:56:11,270
smaller sub problem
in this case we just say well what are

2946
00:56:11,270 --> 00:56:11,280
in this case we just say well what are
 

2947
00:56:11,280 --> 00:56:13,030
in this case we just say well what are
the possible things i could do

2948
00:56:13,030 --> 00:56:13,040
the possible things i could do
 

2949
00:56:13,040 --> 00:56:16,630
the possible things i could do
to the first pin there are three options

2950
00:56:16,630 --> 00:56:16,640
to the first pin there are three options
 

2951
00:56:16,640 --> 00:56:18,549
to the first pin there are three options
if i knew which option it was i would be

2952
00:56:18,549 --> 00:56:18,559
if i knew which option it was i would be
 

2953
00:56:18,559 --> 00:56:21,349
if i knew which option it was i would be
done i could recurse and do my addition

2954
00:56:21,349 --> 00:56:21,359
done i could recurse and do my addition
 

2955
00:56:21,359 --> 00:56:22,870
done i could recurse and do my addition
now i don't know which thing i want to

2956
00:56:22,870 --> 00:56:22,880
now i don't know which thing i want to
 

2957
00:56:22,880 --> 00:56:24,950
now i don't know which thing i want to
do so just try them all

2958
00:56:24,950 --> 00:56:24,960
do so just try them all
 

2959
00:56:24,960 --> 00:56:26,870
do so just try them all
and take the max and if you're

2960
00:56:26,870 --> 00:56:26,880
and take the max and if you're
 

2961
00:56:26,880 --> 00:56:28,230
and take the max and if you're
maximizing you take the max if you're

2962
00:56:28,230 --> 00:56:28,240
maximizing you take the max if you're
 

2963
00:56:28,240 --> 00:56:29,670
maximizing you take the max if you're
minimizing you take them in

2964
00:56:29,670 --> 00:56:29,680
minimizing you take them in
 

2965
00:56:29,680 --> 00:56:32,390
minimizing you take them in
sometimes you take an or or an and there

2966
00:56:32,390 --> 00:56:32,400
sometimes you take an or or an and there
 

2967
00:56:32,400 --> 00:56:34,309
sometimes you take an or or an and there
might be some combination function

2968
00:56:34,309 --> 00:56:34,319
might be some combination function
 

2969
00:56:34,319 --> 00:56:35,910
might be some combination function
for optimization problems where you're

2970
00:56:35,910 --> 00:56:35,920
for optimization problems where you're
 

2971
00:56:35,920 --> 00:56:37,430
for optimization problems where you're
trying to maximize or minimize something

2972
00:56:37,430 --> 00:56:37,440
trying to maximize or minimize something
 

2973
00:56:37,440 --> 00:56:38,470
trying to maximize or minimize something
like shortest paths we're trying to

2974
00:56:38,470 --> 00:56:38,480
like shortest paths we're trying to
 

2975
00:56:38,480 --> 00:56:40,390
like shortest paths we're trying to
minimize we put them in here

2976
00:56:40,390 --> 00:56:40,400
minimize we put them in here
 

2977
00:56:40,400 --> 00:56:43,670
minimize we put them in here
so usually it's min or max and this is

2978
00:56:43,670 --> 00:56:43,680
so usually it's min or max and this is
 

2979
00:56:43,680 --> 00:56:45,589
so usually it's min or max and this is
extremely powerful

2980
00:56:45,589 --> 00:56:45,599
extremely powerful
 

2981
00:56:45,599 --> 00:56:48,390
extremely powerful
uh all you need to do the hard part is

2982
00:56:48,390 --> 00:56:48,400
uh all you need to do the hard part is
 

2983
00:56:48,400 --> 00:56:49,190
uh all you need to do the hard part is
this

2984
00:56:49,190 --> 00:56:49,200
this
 

2985
00:56:49,200 --> 00:56:52,230
this
inspired design part where you say

2986
00:56:52,230 --> 00:56:52,240
inspired design part where you say
 

2987
00:56:52,240 --> 00:56:54,710
inspired design part where you say
what do i need to know that would let me

2988
00:56:54,710 --> 00:56:54,720
what do i need to know that would let me
 

2989
00:56:54,720 --> 00:56:55,990
what do i need to know that would let me
solve my problem

2990
00:56:55,990 --> 00:56:56,000
solve my problem
 

2991
00:56:56,000 --> 00:56:57,910
solve my problem
if you can identify that and the number

2992
00:56:57,910 --> 00:56:57,920
if you can identify that and the number
 

2993
00:56:57,920 --> 00:57:00,309
if you can identify that and the number
of choices for what you need to know

2994
00:57:00,309 --> 00:57:00,319
of choices for what you need to know
 

2995
00:57:00,319 --> 00:57:03,589
of choices for what you need to know
is polynomial then you will be able to

2996
00:57:03,589 --> 00:57:03,599
is polynomial then you will be able to
 

2997
00:57:03,599 --> 00:57:05,750
is polynomial then you will be able to
get a polynomial dynamic program that's

2998
00:57:05,750 --> 00:57:05,760
get a polynomial dynamic program that's
 

2999
00:57:05,760 --> 00:57:07,349
get a polynomial dynamic program that's
the intuition we'll see a lot more

3000
00:57:07,349 --> 00:57:07,359
the intuition we'll see a lot more
 

3001
00:57:07,359 --> 00:57:08,309
the intuition we'll see a lot more
examples

3002
00:57:08,309 --> 00:57:08,319
examples
 

3003
00:57:08,319 --> 00:57:13,839
examples
in the next three lectures

